
lwIP_NIOS_II_Example.elf:     file format elf32-littlenios2
lwIP_NIOS_II_Example.elf
architecture: nios2, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00000020

Program Header:
    LOAD off    0x00001020 vaddr 0x00000020 paddr 0x00000020 align 2**12
         filesz 0x00031238 memsz 0x00031238 flags r-x
    LOAD off    0x00032258 vaddr 0x00031258 paddr 0x000334fc align 2**12
         filesz 0x000022a4 memsz 0x000022a4 flags rw-
    LOAD off    0x000347a0 vaddr 0x000357a0 paddr 0x000357a0 align 2**12
         filesz 0x00000000 memsz 0x0000e1d0 flags rw-
    LOAD off    0x00035000 vaddr 0x05000000 paddr 0x05000000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  05000000  05000000  00035000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .text         0002c564  00000020  00000020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00004cd4  0002c584  0002c584  0002d584  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .rwdata       000022a4  00031258  000334fc  00032258  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  4 .bss          0000e1d0  000357a0  000357a0  000347a0  2**2
                  ALLOC, SMALL_DATA
  5 .comment      00000023  00000000  00000000  00035020  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 00001600  00000000  00000000  00035048  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0003dc27  00000000  00000000  00036648  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000d9af  00000000  00000000  0007426f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00012060  00000000  00000000  00081c1e  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00003e24  00000000  00000000  00093c80  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00007def  00000000  00000000  00097aa4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000142e9  00000000  00000000  0009f893  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_alt_sim_info 00000050  00000000  00000000  000b3b7c  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000a20  00000000  00000000  000b3bd0  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .thread_model 00000003  00000000  00000000  000bb2c7  2**0
                  CONTENTS, READONLY
 16 .cpu          00000003  00000000  00000000  000bb2ca  2**0
                  CONTENTS, READONLY
 17 .qsys         00000001  00000000  00000000  000bb2cd  2**0
                  CONTENTS, READONLY
 18 .simulation_enabled 00000001  00000000  00000000  000bb2ce  2**0
                  CONTENTS, READONLY
 19 .sysid_hash   00000004  00000000  00000000  000bb2cf  2**0
                  CONTENTS, READONLY
 20 .sysid_base   00000004  00000000  00000000  000bb2d3  2**0
                  CONTENTS, READONLY
 21 .sysid_time   00000004  00000000  00000000  000bb2d7  2**0
                  CONTENTS, READONLY
 22 .stderr_dev   00000009  00000000  00000000  000bb2db  2**0
                  CONTENTS, READONLY
 23 .stdin_dev    00000009  00000000  00000000  000bb2e4  2**0
                  CONTENTS, READONLY
 24 .stdout_dev   00000009  00000000  00000000  000bb2ed  2**0
                  CONTENTS, READONLY
 25 .sopc_system_name 0000000c  00000000  00000000  000bb2f6  2**0
                  CONTENTS, READONLY
 26 .quartus_project_dir 0000002e  00000000  00000000  000bb302  2**0
                  CONTENTS, READONLY
 27 .jdi          00005066  00000000  00000000  000bb330  2**0
                  CONTENTS, READONLY
 28 .sopcinfo     001a200d  00000000  00000000  000c0396  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
05000000 l    d  .entry	00000000 .entry
00000020 l    d  .text	00000000 .text
0002c584 l    d  .rodata	00000000 .rodata
00031258 l    d  .rwdata	00000000 .rwdata
000357a0 l    d  .bss	00000000 .bss
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../lwIP_NIOS_II_Example_bsp/obj/HAL/src/crt0.o
00000098 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alteraTseEthernetif.c
0000009c l     F .text	00000064 low_level_init
00000100 l     F .text	00000234 low_level_input
00000000 l    df *ABS*	00000000 fs.c
0002c638 l     O .rodata	00000345 data_img_sics_gif
0002c97d l     O .rodata	00000298 data_404_html
0002cc15 l     O .rodata	00000671 data_index_html
00000000 l    df *ABS*	00000000 fsdata.c
00000000 l    df *ABS*	00000000 httpd.c
00000624 l     F .text	00000040 conn_err
00000664 l     F .text	00000060 close_conn
000006c4 l     F .text	000000f4 send_data
000007b8 l     F .text	000000cc http_poll
00000884 l     F .text	00000070 http_sent
000008f4 l     F .text	0000024c http_recv
00000b40 l     F .text	000000cc http_accept
00000000 l    df *ABS*	00000000 lwip_tse_mac.c
00000000 l    df *ABS*	00000000 api_lib.c
00000000 l    df *ABS*	00000000 api_msg.c
00000000 l    df *ABS*	00000000 err.c
00031258 l     O .rwdata	0000003c err_strerr
00000000 l    df *ABS*	00000000 netbuf.c
00000000 l    df *ABS*	00000000 netdb.c
00000000 l    df *ABS*	00000000 netifapi.c
00000000 l    df *ABS*	00000000 sockets.c
00000000 l    df *ABS*	00000000 tcpip.c
00000000 l    df *ABS*	00000000 dhcp.c
00001968 l     F .text	00000080 dhcp_handle_nak
00003994 l     F .text	00000050 dhcp_set_state
00002ca4 l     F .text	000001d0 dhcp_discover
000019e8 l     F .text	00000098 dhcp_check
00001a80 l     F .text	00000100 dhcp_handle_offer
00004a74 l     F .text	00000234 dhcp_get_option_ptr
00004cd0 l     F .text	000000b8 dhcp_get_option_long
00001b80 l     F .text	00000268 dhcp_select
00004338 l     F .text	000004a0 dhcp_create_request
000039e4 l     F .text	000000e4 dhcp_option
00003ac8 l     F .text	0000009c dhcp_option_byte
00003b64 l     F .text	000000d8 dhcp_option_short
00003c3c l     F .text	0000014c dhcp_option_long
000048f0 l     F .text	00000184 dhcp_option_trailer
000047d8 l     F .text	00000118 dhcp_delete_request
00002164 l     F .text	00000078 dhcp_t2_timeout
000020ec l     F .text	00000078 dhcp_t1_timeout
00001f58 l     F .text	00000194 dhcp_timeout
00002e74 l     F .text	000003c0 dhcp_bind
00003398 l     F .text	00000164 dhcp_rebind
000034fc l     F .text	000001b8 dhcp_reboot
000021dc l     F .text	00000418 dhcp_handle_ack
00004ca8 l     F .text	00000028 dhcp_get_option_byte
00003fd8 l     F .text	00000360 dhcp_recv
00002b2c l     F .text	00000178 dhcp_decline
00003d88 l     F .text	000001d8 dhcp_unfold_reply
00003f60 l     F .text	00000078 dhcp_free_reply
00033480 l     O .rwdata	00000004 xid.3597
00000000 l    df *ABS*	00000000 dns.c
00000000 l    df *ABS*	00000000 init.c
00004d88 l     F .text	0000001c lwip_sanity_check
00000000 l    df *ABS*	00000000 autoip.c
00000000 l    df *ABS*	00000000 icmp.c
000054f4 l     F .text	00000270 icmp_send_response
00000000 l    df *ABS*	00000000 igmp.c
00000000 l    df *ABS*	00000000 inet.c
00035864 l     O .bss	00000010 str.2832
00000000 l    df *ABS*	00000000 inet_chksum.c
00005cf8 l     F .text	0000012c lwip_standard_chksum
00000000 l    df *ABS*	00000000 ip.c
000357a0 l     O .bss	00000002 ip_id.3627
00000000 l    df *ABS*	00000000 ip_addr.c
00000000 l    df *ABS*	00000000 ip_frag.c
000357ac l     O .bss	00000004 reassdatagrams
000357b0 l     O .bss	00000002 ip_reass_pbufcount
00006f3c l     F .text	000001ec ip_reass_free_complete_datagram
00007358 l     F .text	00000090 ip_reass_dequeue_datagram
00007128 l     F .text	00000154 ip_reass_remove_oldest_datagram
0000727c l     F .text	000000dc ip_reass_enqueue_new_datagram
000073e8 l     F .text	00000580 ip_reass_chain_frag_into_datagram_and_validate
00035874 l     O .bss	000005e0 buf
00000000 l    df *ABS*	00000000 mem.c
00035e54 l     O .bss	00000654 ram_heap
000357b4 l     O .bss	00000004 ram
000357b8 l     O .bss	00000004 ram_end
000357bc l     O .bss	00000004 lfree
000357c0 l     O .bss	00000001 mem_sem
0000818c l     F .text	000001f8 plug_holes
00000000 l    df *ABS*	00000000 memp.c
000364a8 l     O .bss	00000024 memp_tab
0002df40 l     O .rodata	00000012 memp_sizes
0002df52 l     O .rodata	00000012 memp_num
00031294 l     O .rwdata	00000024 memp_desc
000364cc l     O .bss	0000cf1b memp_memory
00000000 l    df *ABS*	00000000 netif.c
000357c4 l     O .bss	00000001 netifnum.3502
00000000 l    df *ABS*	00000000 pbuf.c
00000000 l    df *ABS*	00000000 raw.c
000357d0 l     O .bss	00000004 raw_pcbs
00000000 l    df *ABS*	00000000 asn1_dec.c
00000000 l    df *ABS*	00000000 asn1_enc.c
00000000 l    df *ABS*	00000000 mib2.c
00000000 l    df *ABS*	00000000 mib_structs.c
00000000 l    df *ABS*	00000000 msg_in.c
00000000 l    df *ABS*	00000000 msg_out.c
00000000 l    df *ABS*	00000000 stats.c
00000000 l    df *ABS*	00000000 sys.c
00000000 l    df *ABS*	00000000 tcp.c
000357d4 l     O .bss	00000001 tcp_timer
0000bc9c l     F .text	00000108 tcp_new_port
0000b8d8 l     F .text	00000030 tcp_accept_null
00033498 l     O .rwdata	00000002 port.3541
0000caf8 l     F .text	000000d8 tcp_kill_prio
0000cbd0 l     F .text	00000094 tcp_kill_timewait
00033494 l     O .rwdata	00000004 iss.3732
00000000 l    df *ABS*	00000000 tcp_in.c
000433e8 l     O .bss	00000014 inseg
000357f0 l     O .bss	00000004 tcphdr
000357f4 l     O .bss	00000004 iphdr
000357f8 l     O .bss	00000004 seqno
000357fc l     O .bss	00000004 ackno
00035800 l     O .bss	00000001 flags
00035802 l     O .bss	00000002 tcplen
00035804 l     O .bss	00000001 recv_flags
00035808 l     O .bss	00000004 recv_data
0000e2e4 l     F .text	00000138 tcp_timewait_input
0000e044 l     F .text	000002a0 tcp_listen_input
0000e41c l     F .text	00000ba0 tcp_process
00010dfc l     F .text	000001f8 tcp_parseopt
0000f1d8 l     F .text	00001c24 tcp_receive
0000efbc l     F .text	0000021c tcp_oos_insert_segment
00000000 l    df *ABS*	00000000 tcp_out.c
00010ff4 l     F .text	00000288 tcp_output_set_header
00012acc l     F .text	00000390 tcp_output_segment
00000000 l    df *ABS*	00000000 udp.c
00000000 l    df *ABS*	00000000 etharp.c
000433fc l     O .bss	00000118 arp_table
00035814 l     O .bss	00000001 etharp_cached_entry
0001468c l     F .text	000000ec free_etharp_q
000148fc l     F .text	0000050c find_entry
00014e08 l     F .text	000000fc etharp_send_ip
00014f04 l     F .text	0000023c update_arp_entry
00015d74 l     F .text	00000284 etharp_raw
00000000 l    df *ABS*	00000000 ethernetif.c
00000000 l    df *ABS*	00000000 loopif.c
00000000 l    df *ABS*	00000000 auth.c
00000000 l    df *ABS*	00000000 chap.c
00000000 l    df *ABS*	00000000 chpms.c
00000000 l    df *ABS*	00000000 fsm.c
00000000 l    df *ABS*	00000000 ipcp.c
00000000 l    df *ABS*	00000000 lcp.c
00000000 l    df *ABS*	00000000 magic.c
00000000 l    df *ABS*	00000000 md5.c
00000000 l    df *ABS*	00000000 pap.c
00000000 l    df *ABS*	00000000 ppp.c
00000000 l    df *ABS*	00000000 ppp_oe.c
00000000 l    df *ABS*	00000000 randm.c
00000000 l    df *ABS*	00000000 vj.c
00000000 l    df *ABS*	00000000 slipif.c
00000000 l    df *ABS*	00000000 main.c
00043514 l     O .bss	00000018 lwipAlarm
00035818 l     O .bss	00000004 lwipProcessTimerFlag
0003581c l     O .bss	00000004 lwipTicksPer250mS
00035820 l     O .bss	00000004 lwip250mStimer
00035824 l     O .bss	00000004 ip_zero.3879
00000000 l    df *ABS*	00000000 impure.c
000312e4 l     O .rwdata	00000400 impure_data
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 putchar.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 vfprintf.c
00016b90 l     F .text	00000034 __sprint_r
0002f06e l     O .rodata	00000010 blanks.3515
0002f07e l     O .rodata	00000010 zeroes.3516
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 dtoa.c
00018cac l     F .text	00000208 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
0001a6e8 l     F .text	00000008 __fp_lock
0001a6f0 l     F .text	00000008 __fp_unlock
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 locale.c
0002f0b0 l     O .rodata	00000030 lconv
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mprec.c
0002f1f8 l     O .rodata	0000000c p05.2435
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 s_isinfd.c
00000000 l    df *ABS*	00000000 s_isnand.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 fp-bit.c
0001e7b8 l     F .text	00000354 _fpadd_parts
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
0001f4f8 l     F .text	00000074 udivmodsi4
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_close.c
0001fd20 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dev.c
0001fe38 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_fstat.c
0001fe64 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_isatty.c
0001ff60 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_load.c
00020050 l     F .text	0000006c alt_load_section
00000000 l    df *ABS*	00000000 alt_lseek.c
0002013c l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
00000000 l    df *ABS*	00000000 alt_read.c
00020314 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_remap_uncached.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
000334d4 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_uncached_malloc.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
0002084c l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_sys_init.c
00020988 l     F .text	00000038 alt_dev_reg
00031ca0 l     O .rwdata	0000009c vic_0
00031d3c l     O .rwdata	000000d8 cfi_flash
00031e14 l     O .rwdata	00001060 jtag_uart
00032e74 l     O .rwdata	00000120 lcd
00032f94 l     O .rwdata	00000030 sgdma_rx
00032fc4 l     O .rwdata	00000030 sgdma_tx
00032ff4 l     O .rwdata	000000c4 rs232
000330b8 l     O .rwdata	000000c4 uart_0
0003317c l     O .rwdata	000000c4 uart_1
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash.c
00020b10 l     F .text	00000038 alt_flash_device_register
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_table.c
00021948 l     F .text	00000080 alt_read_16bit_query_entry
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
000229f8 l     F .text	00000204 altera_avalon_jtag_uart_irq
00022bfc l     F .text	000000a4 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_lcd_16207.c
000334e0 l     O .rwdata	00000004 colstart
00023290 l     F .text	000000b4 lcd_write_command
00023344 l     F .text	000000d0 lcd_write_data
00023414 l     F .text	000000cc lcd_clear_screen
000234e0 l     F .text	000001ec lcd_repaint_screen
000236cc l     F .text	000000cc lcd_scroll_up
00023798 l     F .text	000002bc lcd_handle_escape
00023f38 l     F .text	000000ac alt_lcd_16207_timeout
00000000 l    df *ABS*	00000000 altera_avalon_lcd_16207_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_sgdma.c
0002417c l     F .text	00000050 alt_get_errno
00024d20 l     F .text	000000e4 alt_avalon_sgdma_irq
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
00024ea8 l     F .text	000000a0 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_tse.c
0003585f l     O .bss	00000001 tse_system_count.3776
0003585e l     O .bss	00000001 is_init.3858
00000000 l    df *ABS*	00000000 altera_avalon_tse_system_info.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_init.c
0002a130 l     F .text	00000098 altera_avalon_uart_irq
0002a1c8 l     F .text	000000d8 altera_avalon_uart_rxirq
0002a2a0 l     F .text	0000013c altera_avalon_uart_txirq
00000000 l    df *ABS*	00000000 altera_avalon_uart_read.c
0002a430 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 altera_avalon_uart_write.c
0002a6dc l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 altera_vic_irq_init.c
00030fb4 l     O .rodata	00000020 VEC_SIZE_ARRAY.1688
00000000 l    df *ABS*	00000000 altera_vic_isr_register.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_dcache_flush.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
0002af40 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_flash_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
0002b260 l     F .text	000000c0 alt_open_fd
00000000 l    df *ABS*	00000000 alt_open.c
0002b398 l     F .text	00000050 alt_get_errno
0002b3e8 l     F .text	000000cc alt_file_locked
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_amd.c
0002b99c l     F .text	000000cc alt_write_word_amd
0002b880 l     F .text	0000011c alt_wait_for_command_to_complete_amd
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_intel.c
0002bc50 l     F .text	0000017c alt_unlock_block_intel
0002bdcc l     F .text	000000d4 alt_write_word_intel
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 ctype_.c
000310d5 l     O .rodata	00000180 _ctype_b
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 strcpy.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
00000000 l    df *ABS*	00000000 
000168b0 g     F .text	0000001c putchar
00006044 g     F .text	00000044 inet_chksum
0000ae70 g     F .text	00000054 raw_bind
0001ce6c g     F .text	00000074 _mprec_log10
00007968 g     F .text	00000520 ip_reass
00026238 g     F .text	000000d8 alt_tse_get_mac_info
00009cf0 g     F .text	00000284 pbuf_realloc
0001cf5c g     F .text	00000084 __any_on
0001db28 g     F .text	00000064 _isatty_r
0002f0e0 g     O .rodata	00000028 __mprec_tinytens
0002025c g     F .text	00000078 alt_main
0002c1e4 g     F .text	00000094 strcpy
0000d220 g     F .text	00000030 tcp_next_iss
0001fb70 g     F .text	00000044 __ashldi3
000168cc g     F .text	00000084 _puts_r
00021420 g     F .text	00000040 alt_read_query_entry_32bit
0000bacc g     F .text	000000ec tcp_update_rcv_ann_wnd
0001db8c g     F .text	0000006c _lseek_r
000357c8 g     O .bss	00000004 netif_list
00020bd8 g     F .text	000002ac alt_flash_cfi_write
0002d2a8 g     O .rodata	00000010 file_index_html
00029e10 g     F .text	000000f0 marvell_cfg_rgmii
000334fc g       *ABS*	00000000 __flash_rwdata_start
0001f058 g     F .text	0000005c __eqdf2
00012e5c g     F .text	000002a4 tcp_rst
00027420 g     F .text	00000210 alt_tse_phy_print_profile
00043970 g       *ABS*	00000000 __alt_heap_start
00029bb0 g     F .text	00000098 marvell_phy_cfg
00015ff8 g     F .text	00000074 etharp_request
000166c0 g     F .text	0000003c printf
000025f4 g     F .text	00000244 dhcp_start
000242f0 g     F .text	00000110 alt_avalon_sgdma_do_sync_transfer
0000cf00 g     F .text	00000030 tcp_err
00033484 g     O .rwdata	00000004 ip_addr_any
00005e24 g     F .text	00000220 inet_chksum_pseudo
000029cc g     F .text	000000b4 dhcp_network_changed
05000000 g       *ABS*	00000000 __alt_mem_sram
0001d780 g     F .text	0000005c __sseek
0001a778 g     F .text	0000010c __sinit
0001127c g     F .text	00000054 tcp_send_ctrl
00014598 g     F .text	0000009c udp_remove
000189e0 g     F .text	0000013c __swbuf_r
00006860 g     F .text	0000049c ip_output_if
0001b410 g     F .text	0000009c _setlocale_r
0001a704 g     F .text	00000064 __sfmoreglue
000090cc g     F .text	000000f8 memp_free
000202f4 g     F .text	00000020 __malloc_unlock
0000a16c g     F .text	000001cc pbuf_free
0000cea0 g     F .text	00000030 tcp_recv
0002647c g     F .text	00000a74 getPHYSpeed
0000a3c4 g     F .text	00000140 pbuf_cat
0004376c g     O .bss	00000034 alteraTseNetif
000249dc g     F .text	00000344 alt_avalon_sgdma_construct_descriptor_burst
0001bf10 g     F .text	00000128 memmove
00006cfc g     F .text	000000b4 ip_output
00013f00 g     F .text	00000094 udp_sendto
0001a768 g     F .text	00000010 _cleanup
0001c038 g     F .text	000000a8 _Balloc
000134ac g     F .text	00000184 tcp_keepalive
00014778 g     F .text	00000184 etharp_tmr
00028e24 g     F .text	000001bc alt_tse_phy_set_adv_1000
000334ec g     O .rwdata	00000001 max_mac_system
0000cc64 g     F .text	000001e0 tcp_alloc
000254f0 g     F .text	000009fc alt_tse_system_add_sys
0001f110 g     F .text	00000064 __gtdf2
00000000  w      *UND*	00000000 __errno
00013f94 g     F .text	000002e0 udp_sendto_if
000215ac g     F .text	0000004c alt_write_flash_command_32bit_device_16bit_mode
05000000 g     F .entry	0000001c __reset
0000ce70 g     F .text	00000030 tcp_arg
000152cc g     F .text	00000400 etharp_arp_input
000357d8 g     O .bss	00000004 tcp_active_pcbs
0002454c g     F .text	00000074 alt_avalon_sgdma_construct_stream_to_mem_desc_burst
00000020 g       *ABS*	00000000 __flash_exceptions_start
0001dac0 g     F .text	00000068 _fstat_r
00035810 g     O .bss	00000004 udp_pcbs
00033240 g     O .rwdata	00000240 tse_mac_device
000210cc g     F .text	000002d8 alt_flash_program_block
00035844 g     O .bss	00000004 errno
0001606c g     F .text	00000140 ethernet_input
000296f8 g     F .text	000004b8 alt_tse_phy_set_common_speed
0000a384 g     F .text	00000040 pbuf_ref
000437a0 g     O .bss	00000020 pmac_groups
00009638 g     F .text	00000050 netif_set_netmask
0003584c g     O .bss	00000004 alt_argv
0003b480 g       *ABS*	00000000 _gp
0000ca7c g     F .text	0000007c tcp_recv_null
0002081c g     F .text	00000030 usleep
000357a4 g     O .bss	00000004 current_netif
0000b278 g     F .text	000001f0 tcp_close
0000bbb8 g     F .text	000000e4 tcp_recved
000207c4 g     F .text	00000058 alt_uncached_malloc
0000cfa4 g     F .text	000000d4 tcp_pcb_purge
00024ffc g     F .text	00000060 tse_mac_initTransInfo2
00031b20 g     O .rwdata	00000180 alt_fd_list
0003348c g     O .rwdata	00000007 tcp_persist_backoff
000168a8 g     F .text	00000008 _putchar_r
0002a92c g       .text	00000000 VIC_0_VECTOR_TABLE
0002b0e8 g     F .text	00000090 alt_find_dev
000164c0 g     F .text	000000f8 memcpy
0000842c g     F .text	00000180 mem_free
00025268 g     F .text	00000054 tse_mac_setMIImode
000357dc g     O .bss	00000004 tcp_ticks
000357e0 g     O .bss	00000004 tcp_listen_pcbs
00026ef0 g     F .text	00000048 alt_tse_phy_rd_mdio_addr
00013100 g     F .text	000000b4 tcp_rexmit_rto
0001a6f8 g     F .text	0000000c _cleanup_r
0001f234 g     F .text	000000d4 __floatsidf
00006db0 g     F .text	000000f0 ip_addr_isbroadcast
0002505c g     F .text	000000e0 tse_mac_sTxWrite
0002b320 g     F .text	00000078 alt_io_redirect
0000ce44 g     F .text	0000002c tcp_new
0001f1d8 g     F .text	0000005c __ltdf2
000144f0 g     F .text	00000068 udp_disconnect
0000a934 g     F .text	0000019c pbuf_copy_partial
0002c584 g       *ABS*	00000000 __DTOR_END__
00016950 g     F .text	00000014 puts
000036b4 g     F .text	000001dc dhcp_release
0001cdc8 g     F .text	000000a4 __ratio
000312b8 g     O .rwdata	0000002c tcp_state_str
0000b0d0 g     F .text	00000044 raw_send
00006088 g     F .text	0000010c inet_chksum_pbuf
0000aad0 g     F .text	000001b8 pbuf_take
0002463c g     F .text	00000088 alt_avalon_sgdma_construct_mem_to_stream_desc_burst
00022dfc g     F .text	00000244 altera_avalon_jtag_uart_read
0002c140 g     F .text	00000014 malloc
00016694 g     F .text	0000002c _printf_r
0001f618 g     F .text	00000008 __udivsi3
00043554 g     O .bss	00000100 tse
0001ffb0 g     F .text	000000a0 isatty
00025eec g     F .text	00000164 alt_tse_sys_enable_mdio_sharing
00004dd4 g     F .text	00000698 icmp_input
0002f130 g     O .rodata	000000c8 __mprec_tens
000261b8 g     F .text	00000080 alt_tse_get_mac_info_index
000091c4 g     F .text	000000d8 netif_add
0001b4ac g     F .text	0000000c __locale_charset
0000c918 g     F .text	00000064 tcp_segs_free
0002c068 g     F .text	0000008c alt_icache_flush
00035840 g     O .bss	00000004 __malloc_top_pad
00000590 g     F .text	00000094 fs_open
000334b0 g     O .rwdata	00000004 __mb_cur_max
0001b4b8 g     F .text	0000000c _localeconv_r
00009490 g     F .text	00000158 netif_set_ipaddr
0001c438 g     F .text	0000003c __i2b
0001adcc g     F .text	000004e4 __sfvwrite_r
00024768 g     F .text	00000058 alt_avalon_sgdma_stop
00026f90 g     F .text	0000012c alt_tse_phy_wr_mdio_reg
0001d640 g     F .text	00000064 _sbrk_r
0002ba68 g     F .text	00000080 alt_program_intel
00027630 g     F .text	0000069c alt_tse_mac_group_init
000112d0 g     F .text	000000b8 tcp_write
00000c78 g     F .text	00000854 tse_mac_init
00015140 g     F .text	000000bc etharp_find_addr
0001dbf8 g     F .text	0000006c _read_r
0002af00 g     F .text	00000024 alt_dcache_flush
000316e4 g     O .rwdata	0000000c __lc_ctype
000334cc g     O .rwdata	00000004 alt_max_fd
000213a4 g     F .text	0000003c alt_read_query_entry_8bit
0001f958 g     F .text	00000104 __unpack_d
0001d970 g     F .text	0000013c _fclose_r
0002bae8 g     F .text	00000168 alt_erase_block_intel
0000b5fc g     F .text	000002dc tcp_bind
0001a6b8 g     F .text	00000030 fflush
0003583c g     O .bss	00000004 __malloc_max_sbrked_mem
000054b0 g     F .text	00000044 icmp_time_exceeded
00007e88 g     F .text	00000304 ip_frag
0001eb0c g     F .text	00000054 __adddf3
0002d288 g     O .rodata	00000010 file_img_sics_gif
0001cb3c g     F .text	00000148 __b2d
0001e22c g     F .text	0000058c __umoddi3
0002018c g     F .text	000000d0 lseek
0000af58 g     F .text	00000178 raw_sendto
00027188 g     F .text	00000298 alt_tse_phy_add_profile_default
0002888c g     F .text	00000598 alt_tse_phy_get_cap
000334a8 g     O .rwdata	00000004 _global_impure_ptr
0001cfe0 g     F .text	000005fc _realloc_r
00043970 g       *ABS*	00000000 __bss_end
000241cc g     F .text	00000124 alt_avalon_sgdma_do_async_transfer
000206c0 g     F .text	00000104 alt_tick
0001dc64 g     F .text	000005c8 __udivdi3
00003890 g     F .text	00000104 dhcp_stop
0002872c g     F .text	00000160 alt_tse_phy_check_link
0002f108 g     O .rodata	00000028 __mprec_bigtens
0001c21c g     F .text	00000104 __s2b
0001f3dc g     F .text	0000011c __floatunsidf
00029d2c g     F .text	000000e4 marvell_cfg_sgmii
0000a670 g     F .text	000002c4 pbuf_copy
00028568 g     F .text	000001c4 alt_tse_phy_restart_an
0001c8dc g     F .text	00000058 __mcmp
000131b4 g     F .text	000001d4 tcp_rexmit
0002a088 g     F .text	000000a8 altera_avalon_uart_init
000334f8 g     O .rwdata	00000004 __ctype_ptr
0001a990 g     F .text	00000018 __fp_lock_all
000437c0 g     O .bss	00000020 pphy_profiles
000096b0 g     F .text	0000007c netif_set_up
000205fc g     F .text	000000c4 alt_alarm_stop
02001000 g       *ABS*	00000000 __alt_mem_descriptor_memory
00031af8 g     O .rwdata	00000028 alt_dev_null
000357e4 g     O .bss	00000004 tcp_tmp_pcb
00028450 g     F .text	00000118 alt_tse_phy_init
000161ac g     F .text	0000002c lwipAlarmCallback
000218ac g     F .text	0000009c alt_set_flash_algorithm_func
000247c0 g     F .text	00000064 alt_avalon_sgdma_check_descriptor_status
0002af24 g     F .text	0000001c alt_dcache_flush_all
0001c320 g     F .text	00000068 __hi0bits
0001f308 g     F .text	000000d4 __fixdfsi
00001610 g     F .text	00000170 tse_mac_raw_send
00008384 g     F .text	000000a8 mem_init
0002ab2c g       .text	00000000 alt_shadow_non_preemptive_interrupt
00021460 g     F .text	00000044 alt_write_flash_command_8bit_device_8bit_mode
000334fc g       *ABS*	00000000 __ram_rwdata_end
00012238 g     F .text	00000894 tcp_output
000334c4 g     O .rwdata	00000008 alt_dev_list
0002089c g     F .text	000000ec write
000248fc g     F .text	00000080 alt_avalon_sgdma_enable_desc_poll
000166fc g     F .text	000000bc _putc_r
00031258 g       *ABS*	00000000 __ram_rodata_end
0001feb4 g     F .text	000000ac fstat
0001fb2c g     F .text	00000044 __lshrdi3
0003580c g     O .bss	00000004 tcp_input_pcb
0000ad40 g     F .text	00000130 raw_input
00029f00 g     F .text	00000078 DP83848C_link_status_read
000120dc g     F .text	0000015c tcp_send_empty_ack
00022700 g     F .text	000000d4 alt_check_primary_table
00013388 g     F .text	00000124 tcp_rexmit_fast
0001c654 g     F .text	0000012c __pow5mult
00035834 g     O .bss	00000004 __nlocale_changed
0001f620 g     F .text	00000008 __umodsi3
00020f10 g     F .text	00000064 alt_flash_cfi_read
00021644 g     F .text	00000038 alt_write_native_8bit
00005764 g     F .text	00000044 inet_addr
00009688 g     F .text	00000028 netif_set_default
00014558 g     F .text	00000040 udp_recv
000245c0 g     F .text	0000007c alt_avalon_sgdma_construct_mem_to_stream_desc
000246c4 g     F .text	00000050 alt_avalon_sgdma_register_callback
00043970 g       *ABS*	00000000 end
000214a4 g     F .text	00000074 alt_write_flash_command_16bit_device_8bit_mode
00023a54 g     F .text	000004e4 altera_avalon_lcd_16207_write
00000c0c g     F .text	0000006c httpd_init
0000972c g     F .text	00000050 netif_set_down
000097b0 g     F .text	00000540 pbuf_alloc
0002a72c g     F .text	00000200 altera_avalon_uart_write
0002530c g     F .text	000001e4 alt_tse_phy_add_profile
000219c8 g     F .text	000005c8 alt_read_cfi_table
00022938 g     F .text	000000c0 altera_avalon_jtag_uart_init
0002c584 g       *ABS*	00000000 __CTOR_LIST__
02000000 g       *ABS*	00000000 __alt_stack_pointer
0002497c g     F .text	00000060 alt_avalon_sgdma_disable_desc_poll
00024f48 g     F .text	00000088 alt_avalon_timer_sc_init
00029fd8 g     F .text	00000060 altera_avalon_uart_write_fd
0001f688 g     F .text	000000ac __clzsi2
0002a038 g     F .text	00000050 altera_avalon_uart_close_fd
00023040 g     F .text	00000250 altera_avalon_jtag_uart_write
00024400 g     F .text	00000070 alt_avalon_sgdma_construct_mem_to_mem_desc
00020b48 g     F .text	00000090 alt_flash_cfi_init
0001a980 g     F .text	00000004 __sfp_lock_acquire
0001be18 g     F .text	000000f8 memchr
00033488 g     O .rwdata	00000004 ip_addr_broadcast
00016bc4 g     F .text	00001df8 ___vfprintf_internal_r
00006ea0 g     F .text	0000009c ip_reass_tmr
000244f0 g     F .text	0000005c alt_avalon_sgdma_construct_stream_to_mem_desc
0002d298 g     O .rodata	00000010 file_404_html
0001aafc g     F .text	000002d0 _free_r
000143dc g     F .text	00000114 udp_connect
0002c3a8 g     F .text	000001a0 __call_exitprocs
000357a8 g     O .bss	00000004 current_header
0000157c g     F .text	00000094 tse_sgdmaRx_isr
000163fc g     F .text	000000c4 lwipProcessTimers
00035830 g     O .bss	00000004 __mlocale_changed
00001780 g     F .text	000001a4 tse_mac_rcv
0000929c g     F .text	00000058 netif_set_addr
00002a80 g     F .text	000000ac dhcp_arp_reply
000334b4 g     O .rwdata	00000004 __malloc_sbrk_base
00000020 g     F .text	0000007c _start
00035854 g     O .bss	00000004 _alt_tick_rate
00024824 g     F .text	00000050 alt_avalon_sgdma_open
00008ef0 g     F .text	000001dc memp_malloc
0001c780 g     F .text	0000015c __lshift
00013630 g     F .text	00000238 tcp_zero_window_probe
00035858 g     O .bss	00000004 _alt_nticks
000270bc g     F .text	000000cc alt_tse_phy_rd_mdio_reg
00020364 g     F .text	000000f0 read
00020a00 g     F .text	00000110 alt_sys_init
00001e9c g     F .text	000000bc dhcp_fine_tmr
0002c278 g     F .text	00000130 __register_exitproc
0003585c g     O .bss	00000001 phy_profile_count
00016a94 g     F .text	000000fc strncmp
00026144 g     F .text	00000074 alt_tse_get_mac_group_index
000213e0 g     F .text	00000040 alt_read_query_entry_16bit
000204b4 g     F .text	00000040 alt_remap_uncached
0001c474 g     F .text	000001e0 __multiply
00022ca0 g     F .text	00000068 altera_avalon_jtag_uart_close
00031258 g       *ABS*	00000000 __ram_rwdata_start
0002c584 g       *ABS*	00000000 __ram_rodata_start
0004352c g     O .bss	00000028 __malloc_current_mallinfo
000357e8 g     O .bss	00000004 tcp_bound_pcbs
000216e8 g     F .text	000001c4 alt_set_flash_width_func
0001cc84 g     F .text	00000144 __d2b
0000c97c g     F .text	00000064 tcp_seg_free
00026f38 g     F .text	00000058 alt_tse_phy_wr_mdio_addr
000227d4 g     F .text	00000060 altera_avalon_jtag_uart_read_fd
0002bfb4 g     F .text	000000b4 alt_get_fd
0002add8 g     F .text	00000128 alt_busy_sleep
0001fa5c g     F .text	000000d0 __fpcmp_parts_d
0000bda4 g     F .text	00000248 tcp_connect
0001d90c g     F .text	00000064 _close_r
000088d0 g     F .text	000003ec mem_malloc
000293d0 g     F .text	00000328 alt_tse_phy_get_common_speed
0002b670 g     F .text	00000210 alt_erase_block_amd
0002c168 g     F .text	0000007c memcmp
00022894 g     F .text	00000050 altera_avalon_jtag_uart_close_fd
00043970 g       *ABS*	00000000 __alt_stack_base
000228e4 g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
0003585d g     O .bss	00000001 mac_group_count
00003234 g     F .text	00000164 dhcp_renew
00018b38 g     F .text	00000174 __swsetup_r
00021f90 g     F .text	00000770 alt_read_cfi_width
000014cc g     F .text	000000b0 tse_sgdma_read_init
0001eea4 g     F .text	000001b4 __divdf3
0001a884 g     F .text	000000fc __sfp
0001cee0 g     F .text	0000007c __copybits
00011388 g     F .text	00000d54 tcp_enqueue
0000d250 g     F .text	00000084 tcp_eff_send_mss
000316f0 g     O .rwdata	00000408 __malloc_av_
0001a98c g     F .text	00000004 __sinit_lock_release
0001ebc0 g     F .text	000002e4 __muldf3
0001d6a4 g     F .text	00000054 __sread
00027ccc g     F .text	0000041c alt_tse_mac_get_phy
0002bea0 g     F .text	00000114 alt_find_file
0002af90 g     F .text	000000a0 alt_dev_llist_insert
000202d4 g     F .text	00000020 __malloc_lock
000204f4 g     F .text	00000108 sbrk
00024714 g     F .text	00000054 alt_avalon_sgdma_start
00002838 g     F .text	00000194 dhcp_inform
0001a4d0 g     F .text	000001e8 _fflush_r
000057a8 g     F .text	000003f8 inet_aton
000263f0 g     F .text	0000008c alt_tse_mac_set_duplex
0001d850 g     F .text	000000bc _calloc_r
0000aec4 g     F .text	00000054 raw_connect
000334f0 g     O .rwdata	00000008 alt_flash_dev_list
00021564 g     F .text	00000048 alt_write_flash_command_16bit_device_16bit_mode
000357a0 g       *ABS*	00000000 __bss_start
000165b8 g     F .text	000000dc memset
000161d8 g     F .text	00000224 main
00035850 g     O .bss	00000004 alt_envp
00035838 g     O .bss	00000004 __malloc_max_total_mem
00022834 g     F .text	00000060 altera_avalon_jtag_uart_write_fd
00018b1c g     F .text	0000001c __swbuf
0000546c g     F .text	00000044 icmp_dest_unreach
00023fe4 g     F .text	00000138 altera_avalon_lcd_16207_init
000334e4 g     O .rwdata	00000008 alt_sgdma_list
0000ced0 g     F .text	00000030 tcp_sent
0000977c g     F .text	00000034 netif_is_up
0001d7dc g     F .text	00000008 __sclose
02000000 g       *ABS*	00000000 __alt_heap_limit
0001daac g     F .text	00000014 fclose
00005ba0 g     F .text	00000158 inet_ntoa
000437e0 g     O .bss	00000190 _atexit0
00018eb4 g     F .text	0000161c _dtoa_r
0001b694 g     F .text	00000784 _malloc_r
0000b1b0 g     F .text	00000080 raw_new
000251e0 g     F .text	00000088 tse_mac_SwReset
00000334 g     F .text	000000e4 ethernetif_input
000334d0 g     O .rwdata	00000004 alt_errno
000215f8 g     F .text	0000004c alt_write_flash_command_32bit_device_32bit_mode
0001b2b0 g     F .text	000000a8 _fwalk
00001924 g     F .text	00000044 lwip_strerr
00020f74 g     F .text	00000158 alt_write_value_to_flash
0002167c g     F .text	00000038 alt_write_native_16bit
000167b8 g     F .text	000000f0 putc
0001f56c g     F .text	00000050 __divsi3
00026090 g     F .text	00000048 alt_tse_mac_set_common_speed
0000b114 g     F .text	0000009c raw_remove
04000000 g       *ABS*	00000000 __alt_mem_cfi_flash
0002f204 g     O .rodata	00000014 __thenan_df
0001a9c0 g     F .text	0000013c _malloc_trim_r
0002c584 g       *ABS*	00000000 __CTOR_END__
00014274 g     F .text	00000168 udp_bind
00035860 g     O .bss	00000004 alt_vic_dev_list
0000b230 g     F .text	00000048 tcp_tmr
0001593c g     F .text	00000438 etharp_query
00016964 g     F .text	000000a4 strcmp
00004da4 g     F .text	00000030 lwip_init
0002c584 g       *ABS*	00000000 __flash_rodata_start
0002c584 g       *ABS*	00000000 __DTOR_LIST__
000156cc g     F .text	00000270 etharp_output
0001f0b4 g     F .text	0000005c __nedf2
000209c0 g     F .text	00000040 alt_irq_init
00026050 g     F .text	00000040 alt_tse_mac_get_common_speed
00020454 g     F .text	00000060 alt_release_fd
000095e8 g     F .text	00000050 netif_set_gw
0002f218 g     O .rodata	00000100 __clz_tab
0000a338 g     F .text	0000004c pbuf_clen
0003582c g     O .bss	00000004 _PathLocale
0002c0f4 g     F .text	00000014 atexit
0001d7e4 g     F .text	0000006c _write_r
0000c9e0 g     F .text	00000034 tcp_setprio
00013eac g     F .text	00000054 udp_send
0001b4c4 g     F .text	0000001c setlocale
0000ac88 g     F .text	000000b8 pbuf_coalesce
0000af18 g     F .text	00000040 raw_recv
000092f4 g     F .text	000000bc netif_remove
000334ac g     O .rwdata	00000004 _impure_ptr
00035848 g     O .bss	00000004 alt_argc
0000bfec g     F .text	0000081c tcp_slowtmr
0002b08c g     F .text	0000005c _do_dtors
0002ab44 g     F .text	0000013c alt_vic_irq_init
0001cadc g     F .text	00000060 __ulp
0001d5dc g     F .text	00000038 __isinfd
0000cf30 g     F .text	00000030 tcp_accept
0001a9a8 g     F .text	00000018 __fp_unlock_all
0002411c g     F .text	00000060 altera_avalon_lcd_16207_write_fd
00000418 g     F .text	00000178 ethernetif_init
000334bc g     O .rwdata	00000008 alt_fs_list
00021518 g     F .text	0000004c alt_write_flash_command_32bit_device_8bit_mode
00000020 g       *ABS*	00000000 __ram_exceptions_start
0001b4e0 g     F .text	0000000c localeconv
0a000000 g       *ABS*	00000000 __alt_mem_onchip_memory2
000357ec g     O .bss	00000004 tcp_tw_pcbs
00029228 g     F .text	000001a8 alt_tse_phy_set_adv_10
0002ac80 g     F .text	00000158 alt_ic_isr_register
00013868 g     F .text	00000644 udp_input
000334fc g       *ABS*	00000000 _edata
00029f78 g     F .text	00000060 altera_avalon_uart_read_fd
00043970 g       *ABS*	00000000 _end
0002b178 g     F .text	00000068 alt_flash_open_dev
000280e8 g     F .text	00000240 alt_tse_mac_associate_phy
00000020 g       *ABS*	00000000 __ram_exceptions_end
00022d08 g     F .text	000000f4 altera_avalon_jtag_uart_ioctl
00006194 g     F .text	000000fc ip_route
0000b908 g     F .text	000001c4 tcp_listen_with_backlog
00043654 g     O .bss	00000118 lwip_stats
00009f74 g     F .text	000001f8 pbuf_header
000085ac g     F .text	00000324 mem_realloc
000357cc g     O .bss	00000004 netif_default
0000d078 g     F .text	000001a8 tcp_pcb_remove
00035828 g     O .bss	00000004 lwipStaticIp
00024874 g     F .text	00000088 alt_avalon_sgdma_construct_descriptor
0001d6f8 g     F .text	00000088 __swrite
000334b8 g     O .rwdata	00000004 __malloc_trim_threshold
0000a504 g     F .text	00000040 pbuf_chain
0002c108 g     F .text	00000038 exit
0000b468 g     F .text	00000194 tcp_abandon
0000d2d4 g     F .text	0000003c tcp_debug_state_str
0001b358 g     F .text	000000b8 _fwalk_reent
00008d34 g     F .text	000001bc memp_init
0001c934 g     F .text	000001a8 __mdiff
00008cbc g     F .text	00000078 mem_calloc
0000c808 g     F .text	00000110 tcp_fasttmr
0002b1e0 g     F .text	00000050 alt_flash_close_dev
0001f5bc g     F .text	0000005c __modsi3
000252bc g     F .text	00000050 tse_mac_setGMIImode
00029c48 g     F .text	000000e4 marvell_cfg_gmii
02000000 g       *ABS*	00000000 __alt_data_end
0001a984 g     F .text	00000004 __sfp_lock_release
00000000 g       *ABS*	00000000 __alt_mem_sdram
00028328 g     F .text	00000128 alt_tse_phy_cfg_pcs
000151fc g     F .text	000000d0 etharp_ip_input
00030fd4 g     O .rodata	00000101 _ctype_
0002a3dc g     F .text	00000054 altera_avalon_uart_close
0002c548 g     F .text	0000003c _exit
0001d614 g     F .text	0000002c __isnand
00001de8 g     F .text	000000b4 dhcp_coarse_tmr
0001fbb4 g     F .text	0000016c alt_alarm_start
0000ca14 g     F .text	00000068 tcp_seg_copy
0001f628 g     F .text	00000060 __muldi3
0001b4ec g     F .text	000001a8 __smakebuf_r
000216b4 g     F .text	00000034 alt_write_native_32bit
0000cf60 g     F .text	00000044 tcp_poll
00016a08 g     F .text	0000008c strlen
0002b4b4 g     F .text	00000154 open
0001f174 g     F .text	00000064 __gedf2
00014634 g     F .text	00000058 udp_new
00020e84 g     F .text	0000008c alt_flash_cfi_get_info
0002b230 g     F .text	00000030 alt_icache_flush_all
0002513c g     F .text	000000a4 tse_mac_aRxRead
0003349c g     O .rwdata	00000006 ethbroadcast
0002e5be g     O .rodata	0000000d tcp_backoff
000189bc g     F .text	00000024 __vfprintf_internal
0002a480 g     F .text	0000025c altera_avalon_uart_read
00026310 g     F .text	000000e0 alt_tse_mac_set_speed
00024470 g     F .text	00000080 alt_avalon_sgdma_construct_mem_to_mem_desc_burst
0001eb60 g     F .text	00000060 __subdf3
0001c388 g     F .text	000000b0 __lo0bits
000334d8 g     O .rwdata	00000008 alt_alarm_list
0002b030 g     F .text	0000005c _do_ctors
00028fe0 g     F .text	00000248 alt_tse_phy_set_adv_100
0000d310 g     F .text	00000d34 tcp_input
0001fd70 g     F .text	000000c8 close
0002b608 g     F .text	00000068 alt_program_amd
00006290 g     F .text	000005d0 ip_input
000200bc g     F .text	00000080 alt_load
000334a2 g     O .rwdata	00000006 ethzero
0001f734 g     F .text	00000224 __pack_d
000260d8 g     F .text	0000006c alt_tse_get_system_index
00024e04 g     F .text	000000a4 alt_avalon_sgdma_init
0002c154 g     F .text	00000014 free
000093b0 g     F .text	000000e0 netif_find
0001a988 g     F .text	00000004 __sinit_lock_acquire
0001c108 g     F .text	00000114 __multadd
0001c0e0 g     F .text	00000028 _Bfree
00024fd0 g     F .text	0000002c no_printf
0000a544 g     F .text	0000012c pbuf_dechain



Disassembly of section .entry:

05000000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && !defined(ALT_SIM_OPTIMIZE)
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
 5000000:	00840014 	movui	r2,4096
#endif

0:
    initi r2
 5000004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
 5000008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
 500000c:	00bffd16 	blt	zero,r2,5000004 <__reset+0x4>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
 5000010:	00400034 	movhi	at,0
    ori r1, r1, %lo(_start)
 5000014:	08400814 	ori	at,at,32
    jmp r1
 5000018:	0800683a 	jmp	at
 500001c:	00000000 	call	0 <__alt_mem_sdram>

Disassembly of section .text:

00000020 <_start>:
     * writing zero to SSTATUS register and executing an ERET instruction
     * to set STATUS.CRS to 0.
     */
    
    /* Get the current register set number (STATUS.CRS). */
    rdctl r2, status
      20:	0005303a 	rdctl	r2,status
    andi r2, r2, NIOS2_STATUS_CRS_MSK
      24:	10bf000c 	andi	r2,r2,64512
    
    /* Skip switching register set if STATUS.CRS is 0.  */
    beq r2, zero, 0f
      28:	10000426 	beq	r2,zero,3c <_start+0x1c>

    /* Set SSTATUS to 0 to get to set SSTATUS.PRS to 0. */
    .set nobreak
    movui sstatus, 0
      2c:	07800014 	movui	ba,0
    .set break

    /* Switch to register set 0 and jump to label. */
    movhi ea, %hi(0f)
      30:	07400034 	movhi	ea,0
    ori ea, ea, %lo(0f)
      34:	ef400f14 	ori	ea,ea,60
    eret
      38:	ef80083a 	eret

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
      3c:	06c08034 	movhi	sp,512
    ori sp, sp, %lo(__alt_stack_pointer)
      40:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
      44:	068000f4 	movhi	gp,3
    ori gp, gp, %lo(_gp)
      48:	d6ad2014 	ori	gp,gp,46208
    /* 
     * Setup registers in shadow register sets
     * from 1 to NIOS2_NUM_OF_SHADOW_REG_SETS.
     */

    movui r2, 0     /* Contains value written into STATUS */
      4c:	00800014 	movui	r2,0
    movui r3, NIOS2_NUM_OF_SHADOW_REG_SETS  /* counter */
      50:	00c00054 	movui	r3,1
    movhi r4, 1     /* Constant to increment STATUS.PRS */
      54:	01000074 	movhi	r4,1
    
.Linitialize_shadow_registers:
    /* Increment STATUS.PRS */
    add r2, r2, r4
      58:	1105883a 	add	r2,r2,r4
    wrctl status, r2
      5c:	1001703a 	wrctl	status,r2

    /* Clear r0 in the shadow register set (not done by hardware) */
    wrprs r0, r0
      60:	0000a03a 	wrprs	zero,zero

    /* Write the GP in previous register set */
    wrprs gp, gp
      64:	d034a03a 	wrprs	gp,gp
    wrprs r30, r0    /* ba */
    wrprs r31, r0    /* ra */
#endif /* NIOS2_ECC_PRESENT */

    /* Decrement shadow register set counter */
    addi r3, r3, -1
      68:	18ffffc4 	addi	r3,r3,-1

    /* Done if index is 0. */
    bne r3, zero, .Linitialize_shadow_registers
      6c:	183ffa1e 	bne	r3,zero,58 <_start+0x38>
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
      70:	008000f4 	movhi	r2,3
    ori r2, r2, %lo(__bss_start)
      74:	1095e814 	ori	r2,r2,22432

    movhi r3, %hi(__bss_end)
      78:	00c00134 	movhi	r3,4
    ori r3, r3, %lo(__bss_end)
      7c:	18ce5c14 	ori	r3,r3,14704

    beq r2, r3, 1f
      80:	10c00326 	beq	r2,r3,90 <_start+0x70>

0:
    stw zero, (r2)
      84:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
      88:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
      8c:	10fffd36 	bltu	r2,r3,84 <_start+0x64>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
      90:	00200bc0 	call	200bc <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
      94:	002025c0 	call	2025c <alt_main>

00000098 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
      98:	003fff06 	br	98 <alt_after_alt_main>

0000009c <low_level_init>:
 * @param netif the already initialized lwip network interface structure
 *        for this ethernetif
 */
static void
low_level_init(struct netif *netif)
{
      9c:	defffc04 	addi	sp,sp,-16
      a0:	dfc00315 	stw	ra,12(sp)
      a4:	df000215 	stw	fp,8(sp)
      a8:	df000204 	addi	fp,sp,8
      ac:	e13fff15 	stw	r4,-4(fp)
  struct ethernetif *ethernetif = netif->state;
      b0:	e0bfff17 	ldw	r2,-4(fp)
      b4:	10800717 	ldw	r2,28(r2)
      b8:	e0bffe15 	stw	r2,-8(fp)
  
  /* set MAC hardware address length */
  netif->hwaddr_len = ETHARP_HWADDR_LEN;
      bc:	e0bfff17 	ldw	r2,-4(fp)
      c0:	00c00184 	movi	r3,6
      c4:	10c00985 	stb	r3,38(r2)

  /* maximum transfer unit */
  netif->mtu = 1500;
      c8:	e0bfff17 	ldw	r2,-4(fp)
      cc:	00c17704 	movi	r3,1500
      d0:	10c0090d 	sth	r3,36(r2)
  
  /* device capabilities */
  /* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */
  netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP;
      d4:	e0bfff17 	ldw	r2,-4(fp)
      d8:	00c00c84 	movi	r3,50
      dc:	10c00b45 	stb	r3,45(r2)
  
  tse_mac_init(0, ethernetif) != 0;
      e0:	0009883a 	mov	r4,zero
      e4:	e17ffe17 	ldw	r5,-8(fp)
      e8:	0000c780 	call	c78 <tse_mac_init>
}
      ec:	e037883a 	mov	sp,fp
      f0:	dfc00117 	ldw	ra,4(sp)
      f4:	df000017 	ldw	fp,0(sp)
      f8:	dec00204 	addi	sp,sp,8
      fc:	f800283a 	ret

00000100 <low_level_input>:
 * @return a pbuf filled with the received packet (including MAC header)
 *         NULL on memory error
 */
static struct pbuf *
low_level_input(struct netif *netif)
{
     100:	defff604 	addi	sp,sp,-40
     104:	dfc00915 	stw	ra,36(sp)
     108:	df000815 	stw	fp,32(sp)
     10c:	df000804 	addi	fp,sp,32
     110:	e13fff15 	stw	r4,-4(fp)
  struct ethernetif *ethernetif = netif->state;
     114:	e0bfff17 	ldw	r2,-4(fp)
     118:	10800717 	ldw	r2,28(r2)
     11c:	e0bff915 	stw	r2,-28(fp)
  struct pbuf *p, *nextPkt;
  u32_t cpu_sr;

    if(ethernetif->lwipRxCount == 0)
     120:	e0bff917 	ldw	r2,-28(fp)
     124:	10801517 	ldw	r2,84(r2)
     128:	1000021e 	bne	r2,zero,134 <low_level_input+0x34>
        return NULL;
     12c:	0005883a 	mov	r2,zero
     130:	00007b06 	br	320 <low_level_input+0x220>
    //  Dump current packet if there is no memory for the next packet.
    //  The lwipRxPbuf must contain pointers to pbufs at all times.
    nextPkt = pbuf_alloc(PBUF_RAW,  PBUF_POOL_BUFSIZE, PBUF_POOL);
     134:	010000c4 	movi	r4,3
     138:	01417b04 	movi	r5,1516
     13c:	018000c4 	movi	r6,3
     140:	00097b00 	call	97b0 <pbuf_alloc>
     144:	e0bffa15 	stw	r2,-24(fp)
    if(nextPkt == NULL)
     148:	e0bffa17 	ldw	r2,-24(fp)
     14c:	1000121e 	bne	r2,zero,198 <low_level_input+0x98>
        {
        LINK_STATS_INC(link.memerr);
     150:	00800134 	movhi	r2,4
     154:	108d9504 	addi	r2,r2,13908
     158:	1080030b 	ldhu	r2,12(r2)
     15c:	10800044 	addi	r2,r2,1
     160:	1007883a 	mov	r3,r2
     164:	00800134 	movhi	r2,4
     168:	108d9504 	addi	r2,r2,13908
     16c:	10c0030d 	sth	r3,12(r2)
        LINK_STATS_INC(link.drop);
     170:	00800134 	movhi	r2,4
     174:	108d9504 	addi	r2,r2,13908
     178:	1080018b 	ldhu	r2,6(r2)
     17c:	10800044 	addi	r2,r2,1
     180:	1007883a 	mov	r3,r2
     184:	00800134 	movhi	r2,4
     188:	108d9504 	addi	r2,r2,13908
     18c:	10c0018d 	sth	r3,6(r2)
        return NULL;
     190:	0005883a 	mov	r2,zero
     194:	00006206 	br	320 <low_level_input+0x220>
        }
    nextPkt = (void *) alt_remap_uncached(nextPkt,sizeof *nextPkt);
     198:	e13ffa17 	ldw	r4,-24(fp)
     19c:	01400404 	movi	r5,16
     1a0:	00204b40 	call	204b4 <alt_remap_uncached>
     1a4:	e0bffa15 	stw	r2,-24(fp)
    nextPkt->payload = (void *) alt_remap_uncached(nextPkt->payload, PBUF_POOL_BUFSIZE);
     1a8:	e0bffa17 	ldw	r2,-24(fp)
     1ac:	10800117 	ldw	r2,4(r2)
     1b0:	1009883a 	mov	r4,r2
     1b4:	01417b04 	movi	r5,1516
     1b8:	00204b40 	call	204b4 <alt_remap_uncached>
     1bc:	e0fffa17 	ldw	r3,-24(fp)
     1c0:	18800115 	stw	r2,4(r3)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
     1c4:	0005303a 	rdctl	r2,status
     1c8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
     1cc:	e0fffc17 	ldw	r3,-16(fp)
     1d0:	00bfff84 	movi	r2,-2
     1d4:	1884703a 	and	r2,r3,r2
     1d8:	1001703a 	wrctl	status,r2
  
  return context;
     1dc:	e0bffc17 	ldw	r2,-16(fp)
    cpu_sr = alt_irq_disable_all();
     1e0:	e0bffb15 	stw	r2,-20(fp)
    --ethernetif->lwipRxCount;
     1e4:	e0bff917 	ldw	r2,-28(fp)
     1e8:	10801517 	ldw	r2,84(r2)
     1ec:	10ffffc4 	addi	r3,r2,-1
     1f0:	e0bff917 	ldw	r2,-28(fp)
     1f4:	10c01515 	stw	r3,84(r2)
    alt_irq_enable_all(cpu_sr);
     1f8:	e0bffb17 	ldw	r2,-20(fp)
     1fc:	e0bffd15 	stw	r2,-12(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
     200:	0005303a 	rdctl	r2,status
     204:	e0bffe15 	stw	r2,-8(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
     208:	e0fffe17 	ldw	r3,-8(fp)
     20c:	00bfff84 	movi	r2,-2
     210:	1884703a 	and	r2,r3,r2
     214:	e0bffe15 	stw	r2,-8(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
     218:	e0bffd17 	ldw	r2,-12(fp)
     21c:	1080004c 	andi	r2,r2,1
     220:	e0fffe17 	ldw	r3,-8(fp)
     224:	1884b03a 	or	r2,r3,r2
     228:	e0bffe15 	stw	r2,-8(fp)
  
  NIOS2_WRITE_STATUS (status);
     22c:	e0bffe17 	ldw	r2,-8(fp)
     230:	1001703a 	wrctl	status,r2
    p = ethernetif->lwipRxPbuf[ ethernetif->lwipRxIndex ];
     234:	e0bff917 	ldw	r2,-28(fp)
     238:	10801417 	ldw	r2,80(r2)
     23c:	e0fff917 	ldw	r3,-28(fp)
     240:	108001c4 	addi	r2,r2,7
     244:	1085883a 	add	r2,r2,r2
     248:	1085883a 	add	r2,r2,r2
     24c:	1885883a 	add	r2,r3,r2
     250:	10800017 	ldw	r2,0(r2)
     254:	e0bff815 	stw	r2,-32(fp)
    ethernetif->lwipRxPbuf[ ethernetif->lwipRxIndex ] = nextPkt;
     258:	e0bff917 	ldw	r2,-28(fp)
     25c:	10801417 	ldw	r2,80(r2)
     260:	e0fff917 	ldw	r3,-28(fp)
     264:	108001c4 	addi	r2,r2,7
     268:	1085883a 	add	r2,r2,r2
     26c:	1085883a 	add	r2,r2,r2
     270:	1885883a 	add	r2,r3,r2
     274:	e0fffa17 	ldw	r3,-24(fp)
     278:	10c00015 	stw	r3,0(r2)
    if(++ethernetif->lwipRxIndex >= LWIP_RX_ETH_BUFFER)
     27c:	e0bff917 	ldw	r2,-28(fp)
     280:	10801417 	ldw	r2,80(r2)
     284:	10c00044 	addi	r3,r2,1
     288:	e0bff917 	ldw	r2,-28(fp)
     28c:	10c01415 	stw	r3,80(r2)
     290:	e0bff917 	ldw	r2,-28(fp)
     294:	10801417 	ldw	r2,80(r2)
     298:	10800310 	cmplti	r2,r2,12
     29c:	1000021e 	bne	r2,zero,2a8 <low_level_input+0x1a8>
        ethernetif->lwipRxIndex = 0;
     2a0:	e0bff917 	ldw	r2,-28(fp)
     2a4:	10001415 	stw	zero,80(r2)
    LWIP_ASSERT("low_level_input: pbuf in rx buffer is NULL", p != NULL );
     2a8:	e0bff817 	ldw	r2,-32(fp)
     2ac:	1000091e 	bne	r2,zero,2d4 <low_level_input+0x1d4>
     2b0:	010000f4 	movhi	r4,3
     2b4:	21316104 	addi	r4,r4,-14972
     2b8:	014000f4 	movhi	r5,3
     2bc:	29716b04 	addi	r5,r5,-14932
     2c0:	01801e44 	movi	r6,121
     2c4:	01c000f4 	movhi	r7,3
     2c8:	39f17604 	addi	r7,r7,-14888
     2cc:	00166c00 	call	166c0 <printf>
     2d0:	003fff06 	br	2d0 <low_level_input+0x1d0>
    LWIP_ASSERT("low_level_input: pbuf->len in rx buffer is 0", p->len != 0 );
     2d4:	e0bff817 	ldw	r2,-32(fp)
     2d8:	1080028b 	ldhu	r2,10(r2)
     2dc:	10bfffcc 	andi	r2,r2,65535
     2e0:	1000091e 	bne	r2,zero,308 <low_level_input+0x208>
     2e4:	010000f4 	movhi	r4,3
     2e8:	21316104 	addi	r4,r4,-14972
     2ec:	014000f4 	movhi	r5,3
     2f0:	29717e04 	addi	r5,r5,-14856
     2f4:	01801e84 	movi	r6,122
     2f8:	01c000f4 	movhi	r7,3
     2fc:	39f17604 	addi	r7,r7,-14888
     300:	00166c00 	call	166c0 <printf>
     304:	003fff06 	br	304 <low_level_input+0x204>
    if( p->len == 0 )
     308:	e0bff817 	ldw	r2,-32(fp)
     30c:	1080028b 	ldhu	r2,10(r2)
     310:	10bfffcc 	andi	r2,r2,65535
     314:	1000011e 	bne	r2,zero,31c <low_level_input+0x21c>
        p = NULL;
     318:	e03ff815 	stw	zero,-32(fp)
    return p;  
     31c:	e0bff817 	ldw	r2,-32(fp)
}
     320:	e037883a 	mov	sp,fp
     324:	dfc00117 	ldw	ra,4(sp)
     328:	df000017 	ldw	fp,0(sp)
     32c:	dec00204 	addi	sp,sp,8
     330:	f800283a 	ret

00000334 <ethernetif_input>:
 *
 * @param netif the lwip network interface structure for this ethernetif
 */
void
ethernetif_input(struct netif *netif)
{
     334:	defffa04 	addi	sp,sp,-24
     338:	dfc00515 	stw	ra,20(sp)
     33c:	df000415 	stw	fp,16(sp)
     340:	df000404 	addi	fp,sp,16
     344:	e13fff15 	stw	r4,-4(fp)
  struct ethernetif *ethernetif;
  struct eth_hdr *ethhdr;
  struct pbuf *p;

  ethernetif = netif->state;
     348:	e0bfff17 	ldw	r2,-4(fp)
     34c:	10800717 	ldw	r2,28(r2)
     350:	e0bffc15 	stw	r2,-16(fp)

  /* move received packet into a new pbuf */
  p = low_level_input(netif);
     354:	e13fff17 	ldw	r4,-4(fp)
     358:	00001000 	call	100 <low_level_input>
     35c:	e0bffd15 	stw	r2,-12(fp)
  /* no packet could be read, silently ignore this */
  if (p == NULL) return;
     360:	e0bffd17 	ldw	r2,-12(fp)
     364:	10002426 	beq	r2,zero,3f8 <ethernetif_input+0xc4>
  /* points to packet payload, which starts with an Ethernet header */
  ethhdr = p->payload;
     368:	e0bffd17 	ldw	r2,-12(fp)
     36c:	10800117 	ldw	r2,4(r2)
     370:	e0bffe15 	stw	r2,-8(fp)

  switch (htons(ethhdr->type)) {
     374:	e0bffe17 	ldw	r2,-8(fp)
     378:	1080038b 	ldhu	r2,14(r2)
     37c:	10bfffcc 	andi	r2,r2,65535
     380:	1004d23a 	srli	r2,r2,8
     384:	10ffffcc 	andi	r3,r2,65535
     388:	e0bffe17 	ldw	r2,-8(fp)
     38c:	1080038b 	ldhu	r2,14(r2)
     390:	10bfffcc 	andi	r2,r2,65535
     394:	1004923a 	slli	r2,r2,8
     398:	10bfffcc 	andi	r2,r2,65535
     39c:	1884b03a 	or	r2,r3,r2
     3a0:	10c20020 	cmpeqi	r3,r2,2048
     3a4:	1800021e 	bne	r3,zero,3b0 <ethernetif_input+0x7c>
     3a8:	108201a0 	cmpeqi	r2,r2,2054
     3ac:	10000d26 	beq	r2,zero,3e4 <ethernetif_input+0xb0>
  /* PPPoE packet? */
  case ETHTYPE_PPPOEDISC:
  case ETHTYPE_PPPOE:
#endif /* PPPOE_SUPPORT */
    /* full packet send to tcpip_thread to process */
    if (netif->input(p, netif)!=ERR_OK)
     3b0:	e0bfff17 	ldw	r2,-4(fp)
     3b4:	10800417 	ldw	r2,16(r2)
     3b8:	e13ffd17 	ldw	r4,-12(fp)
     3bc:	e17fff17 	ldw	r5,-4(fp)
     3c0:	103ee83a 	callr	r2
     3c4:	10803fcc 	andi	r2,r2,255
     3c8:	1080201c 	xori	r2,r2,128
     3cc:	10bfe004 	addi	r2,r2,-128
     3d0:	10000b26 	beq	r2,zero,400 <ethernetif_input+0xcc>
     { LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: IP input error\n"));
       pbuf_free(p);
     3d4:	e13ffd17 	ldw	r4,-12(fp)
     3d8:	000a16c0 	call	a16c <pbuf_free>
       p = NULL;
     3dc:	e03ffd15 	stw	zero,-12(fp)
     }
    break;
     3e0:	00000706 	br	400 <ethernetif_input+0xcc>

  default:
    pbuf_free(p);
     3e4:	e13ffd17 	ldw	r4,-12(fp)
     3e8:	000a16c0 	call	a16c <pbuf_free>
    p = NULL;
     3ec:	e03ffd15 	stw	zero,-12(fp)
    break;
     3f0:	0001883a 	nop
     3f4:	00000306 	br	404 <ethernetif_input+0xd0>
  ethernetif = netif->state;

  /* move received packet into a new pbuf */
  p = low_level_input(netif);
  /* no packet could be read, silently ignore this */
  if (p == NULL) return;
     3f8:	0001883a 	nop
     3fc:	00000106 	br	404 <ethernetif_input+0xd0>
    if (netif->input(p, netif)!=ERR_OK)
     { LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: IP input error\n"));
       pbuf_free(p);
       p = NULL;
     }
    break;
     400:	0001883a 	nop
  default:
    pbuf_free(p);
    p = NULL;
    break;
  }
}
     404:	e037883a 	mov	sp,fp
     408:	dfc00117 	ldw	ra,4(sp)
     40c:	df000017 	ldw	fp,0(sp)
     410:	dec00204 	addi	sp,sp,8
     414:	f800283a 	ret

00000418 <ethernetif_init>:
 *         ERR_MEM if private data couldn't be allocated
 *         any other err_t on error
 */
err_t
ethernetif_init(struct netif *netif)
{
     418:	defffa04 	addi	sp,sp,-24
     41c:	dfc00515 	stw	ra,20(sp)
     420:	df000415 	stw	fp,16(sp)
     424:	df000404 	addi	fp,sp,16
     428:	e13fff15 	stw	r4,-4(fp)
  int idx;
  struct pbuf *p;
  struct ethernetif *ethernetif;
  err_t tse_mac_raw_send(struct netif *netif, struct pbuf *p);  

  LWIP_ASSERT("netif != NULL", (netif != NULL));
     42c:	e0bfff17 	ldw	r2,-4(fp)
     430:	1000091e 	bne	r2,zero,458 <ethernetif_init+0x40>
     434:	010000f4 	movhi	r4,3
     438:	21316104 	addi	r4,r4,-14972
     43c:	014000f4 	movhi	r5,3
     440:	29718a04 	addi	r5,r5,-14808
     444:	01803144 	movi	r6,197
     448:	01c000f4 	movhi	r7,3
     44c:	39f17604 	addi	r7,r7,-14888
     450:	00166c00 	call	166c0 <printf>
     454:	003fff06 	br	454 <ethernetif_init+0x3c>
    
  ethernetif = mem_malloc(sizeof(struct ethernetif));
     458:	01001704 	movi	r4,92
     45c:	00088d00 	call	88d0 <mem_malloc>
     460:	e0bffd15 	stw	r2,-12(fp)
  if (ethernetif == NULL) {
     464:	e0bffd17 	ldw	r2,-12(fp)
     468:	1000021e 	bne	r2,zero,474 <ethernetif_init+0x5c>
    LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_init: out of memory\n"));
    return ERR_MEM;
     46c:	00bfffc4 	movi	r2,-1
     470:	00004206 	br	57c <ethernetif_init+0x164>
   * The last argument should be replaced with your link speed, in units
   * of bits per second.
   */
  NETIF_INIT_SNMP(netif, snmp_ifType_ethernet_csmacd, LINK_SPEED_OF_YOUR_NETIF_IN_BPS);

  netif->state = ethernetif;
     474:	e0bfff17 	ldw	r2,-4(fp)
     478:	e0fffd17 	ldw	r3,-12(fp)
     47c:	10c00715 	stw	r3,28(r2)
  netif->name[0] = IFNAME0;
     480:	e0bfff17 	ldw	r2,-4(fp)
     484:	00c01944 	movi	r3,101
     488:	10c00b85 	stb	r3,46(r2)
  netif->name[1] = IFNAME1;
     48c:	e0bfff17 	ldw	r2,-4(fp)
     490:	00c01b84 	movi	r3,110
     494:	10c00bc5 	stb	r3,47(r2)
  /* We directly use etharp_output() here to save a function call.
   * You can instead declare your own function an call etharp_output()
   * from it if you have to do some checks before sending (e.g. if link
   * is available...) */
  netif->output = etharp_output;
     498:	e0bfff17 	ldw	r2,-4(fp)
     49c:	00c00074 	movhi	r3,1
     4a0:	18d5b304 	addi	r3,r3,22220
     4a4:	10c00515 	stw	r3,20(r2)
  netif->linkoutput = tse_mac_raw_send;
     4a8:	e0bfff17 	ldw	r2,-4(fp)
     4ac:	00c00034 	movhi	r3,0
     4b0:	18c58404 	addi	r3,r3,5648
     4b4:	10c00615 	stw	r3,24(r2)
  
  ethernetif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
     4b8:	e0bfff17 	ldw	r2,-4(fp)
     4bc:	10c009c4 	addi	r3,r2,39
     4c0:	e0bffd17 	ldw	r2,-12(fp)
     4c4:	10c00015 	stw	r3,0(r2)
  
  /* initialize the rx buffer for access by the TSE ISR */
  for(idx = 0; idx < LWIP_RX_ETH_BUFFER; ++idx)
     4c8:	e03ffc15 	stw	zero,-16(fp)
     4cc:	00001f06 	br	54c <ethernetif_init+0x134>
    {
    p = pbuf_alloc(PBUF_RAW, PBUF_POOL_BUFSIZE, PBUF_POOL);
     4d0:	010000c4 	movi	r4,3
     4d4:	01417b04 	movi	r5,1516
     4d8:	018000c4 	movi	r6,3
     4dc:	00097b00 	call	97b0 <pbuf_alloc>
     4e0:	e0bffe15 	stw	r2,-8(fp)
    if (p == NULL)
     4e4:	e0bffe17 	ldw	r2,-8(fp)
     4e8:	1000021e 	bne	r2,zero,4f4 <ethernetif_init+0xdc>
      return ERR_MEM;
     4ec:	00bfffc4 	movi	r2,-1
     4f0:	00002206 	br	57c <ethernetif_init+0x164>
    p = (void *) alt_remap_uncached(p,sizeof *p);
     4f4:	e13ffe17 	ldw	r4,-8(fp)
     4f8:	01400404 	movi	r5,16
     4fc:	00204b40 	call	204b4 <alt_remap_uncached>
     500:	e0bffe15 	stw	r2,-8(fp)
    p->payload = (void *) alt_remap_uncached(p->payload,PBUF_POOL_BUFSIZE);
     504:	e0bffe17 	ldw	r2,-8(fp)
     508:	10800117 	ldw	r2,4(r2)
     50c:	1009883a 	mov	r4,r2
     510:	01417b04 	movi	r5,1516
     514:	00204b40 	call	204b4 <alt_remap_uncached>
     518:	e0fffe17 	ldw	r3,-8(fp)
     51c:	18800115 	stw	r2,4(r3)
    ethernetif->lwipRxPbuf[idx] = p;
     520:	e0fffd17 	ldw	r3,-12(fp)
     524:	e0bffc17 	ldw	r2,-16(fp)
     528:	108001c4 	addi	r2,r2,7
     52c:	1085883a 	add	r2,r2,r2
     530:	1085883a 	add	r2,r2,r2
     534:	1885883a 	add	r2,r3,r2
     538:	e0fffe17 	ldw	r3,-8(fp)
     53c:	10c00015 	stw	r3,0(r2)
  netif->linkoutput = tse_mac_raw_send;
  
  ethernetif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
  
  /* initialize the rx buffer for access by the TSE ISR */
  for(idx = 0; idx < LWIP_RX_ETH_BUFFER; ++idx)
     540:	e0bffc17 	ldw	r2,-16(fp)
     544:	10800044 	addi	r2,r2,1
     548:	e0bffc15 	stw	r2,-16(fp)
     54c:	e0bffc17 	ldw	r2,-16(fp)
     550:	10800310 	cmplti	r2,r2,12
     554:	103fde1e 	bne	r2,zero,4d0 <ethernetif_init+0xb8>
      return ERR_MEM;
    p = (void *) alt_remap_uncached(p,sizeof *p);
    p->payload = (void *) alt_remap_uncached(p->payload,PBUF_POOL_BUFSIZE);
    ethernetif->lwipRxPbuf[idx] = p;
    }
  ethernetif->lwipRxCount = 0;
     558:	e0bffd17 	ldw	r2,-12(fp)
     55c:	10001515 	stw	zero,84(r2)
  ethernetif->lwipRxIndex = 0;
     560:	e0bffd17 	ldw	r2,-12(fp)
     564:	10001415 	stw	zero,80(r2)
  ethernetif->lwipRxIndexIsr = 0;
     568:	e0bffd17 	ldw	r2,-12(fp)
     56c:	10001315 	stw	zero,76(r2)
                  
  /* initialize the low level hardware */
  low_level_init(netif);
     570:	e13fff17 	ldw	r4,-4(fp)
     574:	000009c0 	call	9c <low_level_init>
  return ERR_OK;
     578:	0005883a 	mov	r2,zero
}
     57c:	e037883a 	mov	sp,fp
     580:	dfc00117 	ldw	ra,4(sp)
     584:	df000017 	ldw	fp,0(sp)
     588:	dec00204 	addi	sp,sp,8
     58c:	f800283a 	ret

00000590 <fs_open>:


/*-----------------------------------------------------------------------------------*/
int
fs_open(const char *name, struct fs_file *file)
{
     590:	defffb04 	addi	sp,sp,-20
     594:	dfc00415 	stw	ra,16(sp)
     598:	df000315 	stw	fp,12(sp)
     59c:	df000304 	addi	fp,sp,12
     5a0:	e13ffe15 	stw	r4,-8(fp)
     5a4:	e17fff15 	stw	r5,-4(fp)
  const struct fsdata_file *f;

  for(f = FS_ROOT;
     5a8:	008000f4 	movhi	r2,3
     5ac:	10b4aa04 	addi	r2,r2,-11608
     5b0:	e0bffd15 	stw	r2,-12(fp)
     5b4:	00001306 	br	604 <fs_open+0x74>
      f != NULL;
      f = f->next) {
    if (!strcmp(name, (const char*)f->name)) {
     5b8:	e0bffd17 	ldw	r2,-12(fp)
     5bc:	10800117 	ldw	r2,4(r2)
     5c0:	e13ffe17 	ldw	r4,-8(fp)
     5c4:	100b883a 	mov	r5,r2
     5c8:	00169640 	call	16964 <strcmp>
     5cc:	10000a1e 	bne	r2,zero,5f8 <fs_open+0x68>
      file->data = f->data;
     5d0:	e0bffd17 	ldw	r2,-12(fp)
     5d4:	10c00217 	ldw	r3,8(r2)
     5d8:	e0bfff17 	ldw	r2,-4(fp)
     5dc:	10c00015 	stw	r3,0(r2)
      file->len = f->len;
     5e0:	e0bffd17 	ldw	r2,-12(fp)
     5e4:	10c00317 	ldw	r3,12(r2)
     5e8:	e0bfff17 	ldw	r2,-4(fp)
     5ec:	10c00115 	stw	r3,4(r2)
      return 1;
     5f0:	00800044 	movi	r2,1
     5f4:	00000606 	br	610 <fs_open+0x80>
{
  const struct fsdata_file *f;

  for(f = FS_ROOT;
      f != NULL;
      f = f->next) {
     5f8:	e0bffd17 	ldw	r2,-12(fp)
     5fc:	10800017 	ldw	r2,0(r2)
     600:	e0bffd15 	stw	r2,-12(fp)
int
fs_open(const char *name, struct fs_file *file)
{
  const struct fsdata_file *f;

  for(f = FS_ROOT;
     604:	e0bffd17 	ldw	r2,-12(fp)
     608:	103feb1e 	bne	r2,zero,5b8 <fs_open+0x28>
      file->data = f->data;
      file->len = f->len;
      return 1;
    }
  }
  return 0;
     60c:	0005883a 	mov	r2,zero
}
     610:	e037883a 	mov	sp,fp
     614:	dfc00117 	ldw	ra,4(sp)
     618:	df000017 	ldw	fp,0(sp)
     61c:	dec00204 	addi	sp,sp,8
     620:	f800283a 	ret

00000624 <conn_err>:
};

/*-----------------------------------------------------------------------------------*/
static void
conn_err(void *arg, err_t err)
{
     624:	defffb04 	addi	sp,sp,-20
     628:	dfc00415 	stw	ra,16(sp)
     62c:	df000315 	stw	fp,12(sp)
     630:	df000304 	addi	fp,sp,12
     634:	e13ffe15 	stw	r4,-8(fp)
     638:	2805883a 	mov	r2,r5
     63c:	e0bfff05 	stb	r2,-4(fp)
  struct http_state *hs;

  LWIP_UNUSED_ARG(err);

  hs = arg;
     640:	e0bffe17 	ldw	r2,-8(fp)
     644:	e0bffd15 	stw	r2,-12(fp)
  mem_free(hs);
     648:	e13ffd17 	ldw	r4,-12(fp)
     64c:	000842c0 	call	842c <mem_free>
}
     650:	e037883a 	mov	sp,fp
     654:	dfc00117 	ldw	ra,4(sp)
     658:	df000017 	ldw	fp,0(sp)
     65c:	dec00204 	addi	sp,sp,8
     660:	f800283a 	ret

00000664 <close_conn>:
/*-----------------------------------------------------------------------------------*/
static void
close_conn(struct tcp_pcb *pcb, struct http_state *hs)
{
     664:	defffc04 	addi	sp,sp,-16
     668:	dfc00315 	stw	ra,12(sp)
     66c:	df000215 	stw	fp,8(sp)
     670:	df000204 	addi	fp,sp,8
     674:	e13ffe15 	stw	r4,-8(fp)
     678:	e17fff15 	stw	r5,-4(fp)
  tcp_arg(pcb, NULL);
     67c:	e13ffe17 	ldw	r4,-8(fp)
     680:	000b883a 	mov	r5,zero
     684:	000ce700 	call	ce70 <tcp_arg>
  tcp_sent(pcb, NULL);
     688:	e13ffe17 	ldw	r4,-8(fp)
     68c:	000b883a 	mov	r5,zero
     690:	000ced00 	call	ced0 <tcp_sent>
  tcp_recv(pcb, NULL);
     694:	e13ffe17 	ldw	r4,-8(fp)
     698:	000b883a 	mov	r5,zero
     69c:	000cea00 	call	cea0 <tcp_recv>
  mem_free(hs);
     6a0:	e13fff17 	ldw	r4,-4(fp)
     6a4:	000842c0 	call	842c <mem_free>
  tcp_close(pcb);
     6a8:	e13ffe17 	ldw	r4,-8(fp)
     6ac:	000b2780 	call	b278 <tcp_close>
}
     6b0:	e037883a 	mov	sp,fp
     6b4:	dfc00117 	ldw	ra,4(sp)
     6b8:	df000017 	ldw	fp,0(sp)
     6bc:	dec00204 	addi	sp,sp,8
     6c0:	f800283a 	ret

000006c4 <send_data>:
/*-----------------------------------------------------------------------------------*/
static void
send_data(struct tcp_pcb *pcb, struct http_state *hs)
{
     6c4:	defffa04 	addi	sp,sp,-24
     6c8:	dfc00515 	stw	ra,20(sp)
     6cc:	df000415 	stw	fp,16(sp)
     6d0:	df000404 	addi	fp,sp,16
     6d4:	e13ffe15 	stw	r4,-8(fp)
     6d8:	e17fff15 	stw	r5,-4(fp)
  err_t err;
  u32_t len;

  /* We cannot send more data than space available in the send
     buffer. */     
  if (tcp_sndbuf(pcb) < hs->left) {
     6dc:	e0bffe17 	ldw	r2,-8(fp)
     6e0:	10801c8b 	ldhu	r2,114(r2)
     6e4:	10ffffcc 	andi	r3,r2,65535
     6e8:	e0bfff17 	ldw	r2,-4(fp)
     6ec:	10800017 	ldw	r2,0(r2)
     6f0:	1880052e 	bgeu	r3,r2,708 <send_data+0x44>
    len = tcp_sndbuf(pcb);
     6f4:	e0bffe17 	ldw	r2,-8(fp)
     6f8:	10801c8b 	ldhu	r2,114(r2)
     6fc:	10bfffcc 	andi	r2,r2,65535
     700:	e0bffc15 	stw	r2,-16(fp)
     704:	00000306 	br	714 <send_data+0x50>
  } else {
    len = hs->left;
     708:	e0bfff17 	ldw	r2,-4(fp)
     70c:	10800017 	ldw	r2,0(r2)
     710:	e0bffc15 	stw	r2,-16(fp)
    LWIP_ASSERT((len == hs->left), "hs->left did not fit into u16_t!");
  }

  do {
    err = tcp_write(pcb, hs->file, len, 0);
     714:	e0bfff17 	ldw	r2,-4(fp)
     718:	10c00117 	ldw	r3,4(r2)
     71c:	e0bffc17 	ldw	r2,-16(fp)
     720:	10bfffcc 	andi	r2,r2,65535
     724:	e13ffe17 	ldw	r4,-8(fp)
     728:	180b883a 	mov	r5,r3
     72c:	100d883a 	mov	r6,r2
     730:	000f883a 	mov	r7,zero
     734:	00112d00 	call	112d0 <tcp_write>
     738:	e0bffd05 	stb	r2,-12(fp)
    if (err == ERR_MEM) {
     73c:	e0bffd07 	ldb	r2,-12(fp)
     740:	10bfffd8 	cmpnei	r2,r2,-1
     744:	1000031e 	bne	r2,zero,754 <send_data+0x90>
      len /= 2;
     748:	e0bffc17 	ldw	r2,-16(fp)
     74c:	1004d07a 	srli	r2,r2,1
     750:	e0bffc15 	stw	r2,-16(fp)
    }
  } while (err == ERR_MEM && len > 1);  
     754:	e0bffd07 	ldb	r2,-12(fp)
     758:	10bfffd8 	cmpnei	r2,r2,-1
     75c:	1000031e 	bne	r2,zero,76c <send_data+0xa8>
     760:	e0bffc17 	ldw	r2,-16(fp)
     764:	108000a8 	cmpgeui	r2,r2,2
     768:	103fea1e 	bne	r2,zero,714 <send_data+0x50>
  
  if (err == ERR_OK) {
     76c:	e0bffd07 	ldb	r2,-12(fp)
     770:	10000c1e 	bne	r2,zero,7a4 <send_data+0xe0>
    hs->file += len;
     774:	e0bfff17 	ldw	r2,-4(fp)
     778:	10c00117 	ldw	r3,4(r2)
     77c:	e0bffc17 	ldw	r2,-16(fp)
     780:	1887883a 	add	r3,r3,r2
     784:	e0bfff17 	ldw	r2,-4(fp)
     788:	10c00115 	stw	r3,4(r2)
    hs->left -= len;
     78c:	e0bfff17 	ldw	r2,-4(fp)
     790:	10c00017 	ldw	r3,0(r2)
     794:	e0bffc17 	ldw	r2,-16(fp)
     798:	1887c83a 	sub	r3,r3,r2
     79c:	e0bfff17 	ldw	r2,-4(fp)
     7a0:	10c00015 	stw	r3,0(r2)
    /*  } else {
    printf("send_data: error %s len %d %d\n", lwip_strerr(err), len, tcp_sndbuf(pcb));*/
  }
}
     7a4:	e037883a 	mov	sp,fp
     7a8:	dfc00117 	ldw	ra,4(sp)
     7ac:	df000017 	ldw	fp,0(sp)
     7b0:	dec00204 	addi	sp,sp,8
     7b4:	f800283a 	ret

000007b8 <http_poll>:
/*-----------------------------------------------------------------------------------*/
static err_t
http_poll(void *arg, struct tcp_pcb *pcb)
{
     7b8:	defffb04 	addi	sp,sp,-20
     7bc:	dfc00415 	stw	ra,16(sp)
     7c0:	df000315 	stw	fp,12(sp)
     7c4:	df000304 	addi	fp,sp,12
     7c8:	e13ffe15 	stw	r4,-8(fp)
     7cc:	e17fff15 	stw	r5,-4(fp)
  struct http_state *hs;

  hs = arg;
     7d0:	e0bffe17 	ldw	r2,-8(fp)
     7d4:	e0bffd15 	stw	r2,-12(fp)
  
  /*  printf("Polll\n");*/
  if ((hs == NULL) && (pcb->state == ESTABLISHED)) {
     7d8:	e0bffd17 	ldw	r2,-12(fp)
     7dc:	1000091e 	bne	r2,zero,804 <http_poll+0x4c>
     7e0:	e0bfff17 	ldw	r2,-4(fp)
     7e4:	10800417 	ldw	r2,16(r2)
     7e8:	10800118 	cmpnei	r2,r2,4
     7ec:	1000051e 	bne	r2,zero,804 <http_poll+0x4c>
    /*    printf("Null, close\n");*/
    tcp_abort(pcb);
     7f0:	e13fff17 	ldw	r4,-4(fp)
     7f4:	01400044 	movi	r5,1
     7f8:	000b4680 	call	b468 <tcp_abandon>
    return ERR_ABRT;
     7fc:	00bffec4 	movi	r2,-5
     800:	00001b06 	br	870 <http_poll+0xb8>
  } else if (hs != NULL) {
     804:	e0bffd17 	ldw	r2,-12(fp)
     808:	10001826 	beq	r2,zero,86c <http_poll+0xb4>
    ++hs->retries;
     80c:	e0bffd17 	ldw	r2,-12(fp)
     810:	10800203 	ldbu	r2,8(r2)
     814:	10800044 	addi	r2,r2,1
     818:	1007883a 	mov	r3,r2
     81c:	e0bffd17 	ldw	r2,-12(fp)
     820:	10c00205 	stb	r3,8(r2)
    if (hs->retries == 4) {
     824:	e0bffd17 	ldw	r2,-12(fp)
     828:	10800203 	ldbu	r2,8(r2)
     82c:	10803fcc 	andi	r2,r2,255
     830:	10800118 	cmpnei	r2,r2,4
     834:	10000a1e 	bne	r2,zero,860 <http_poll+0xa8>
      tcp_arg(pcb, NULL);
     838:	e13fff17 	ldw	r4,-4(fp)
     83c:	000b883a 	mov	r5,zero
     840:	000ce700 	call	ce70 <tcp_arg>
      mem_free(hs);
     844:	e13ffd17 	ldw	r4,-12(fp)
     848:	000842c0 	call	842c <mem_free>
      tcp_abort(pcb);
     84c:	e13fff17 	ldw	r4,-4(fp)
     850:	01400044 	movi	r5,1
     854:	000b4680 	call	b468 <tcp_abandon>
      return ERR_ABRT;
     858:	00bffec4 	movi	r2,-5
     85c:	00000406 	br	870 <http_poll+0xb8>
    }
    send_data(pcb, hs);
     860:	e13fff17 	ldw	r4,-4(fp)
     864:	e17ffd17 	ldw	r5,-12(fp)
     868:	00006c40 	call	6c4 <send_data>
  }

  return ERR_OK;
     86c:	0005883a 	mov	r2,zero
}
     870:	e037883a 	mov	sp,fp
     874:	dfc00117 	ldw	ra,4(sp)
     878:	df000017 	ldw	fp,0(sp)
     87c:	dec00204 	addi	sp,sp,8
     880:	f800283a 	ret

00000884 <http_sent>:
/*-----------------------------------------------------------------------------------*/
static err_t
http_sent(void *arg, struct tcp_pcb *pcb, u16_t len)
{
     884:	defffa04 	addi	sp,sp,-24
     888:	dfc00515 	stw	ra,20(sp)
     88c:	df000415 	stw	fp,16(sp)
     890:	df000404 	addi	fp,sp,16
     894:	e13ffd15 	stw	r4,-12(fp)
     898:	e17ffe15 	stw	r5,-8(fp)
     89c:	3005883a 	mov	r2,r6
     8a0:	e0bfff0d 	sth	r2,-4(fp)
  struct http_state *hs;

  LWIP_UNUSED_ARG(len);

  hs = arg;
     8a4:	e0bffd17 	ldw	r2,-12(fp)
     8a8:	e0bffc15 	stw	r2,-16(fp)

  hs->retries = 0;
     8ac:	e0bffc17 	ldw	r2,-16(fp)
     8b0:	10000205 	stb	zero,8(r2)
  
  if (hs->left > 0) {    
     8b4:	e0bffc17 	ldw	r2,-16(fp)
     8b8:	10800017 	ldw	r2,0(r2)
     8bc:	10000426 	beq	r2,zero,8d0 <http_sent+0x4c>
    send_data(pcb, hs);
     8c0:	e13ffe17 	ldw	r4,-8(fp)
     8c4:	e17ffc17 	ldw	r5,-16(fp)
     8c8:	00006c40 	call	6c4 <send_data>
     8cc:	00000306 	br	8dc <http_sent+0x58>
  } else {
    close_conn(pcb, hs);
     8d0:	e13ffe17 	ldw	r4,-8(fp)
     8d4:	e17ffc17 	ldw	r5,-16(fp)
     8d8:	00006640 	call	664 <close_conn>
  }

  return ERR_OK;
     8dc:	0005883a 	mov	r2,zero
}
     8e0:	e037883a 	mov	sp,fp
     8e4:	dfc00117 	ldw	ra,4(sp)
     8e8:	df000017 	ldw	fp,0(sp)
     8ec:	dec00204 	addi	sp,sp,8
     8f0:	f800283a 	ret

000008f4 <http_recv>:
/*-----------------------------------------------------------------------------------*/
static err_t
http_recv(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
     8f4:	defff504 	addi	sp,sp,-44
     8f8:	dfc00a15 	stw	ra,40(sp)
     8fc:	df000915 	stw	fp,36(sp)
     900:	df000904 	addi	fp,sp,36
     904:	e13ffc15 	stw	r4,-16(fp)
     908:	e17ffd15 	stw	r5,-12(fp)
     90c:	e1bffe15 	stw	r6,-8(fp)
     910:	3805883a 	mov	r2,r7
     914:	e0bfff05 	stb	r2,-4(fp)
  int i;
  char *data;
  struct fs_file file;
  struct http_state *hs;

  hs = arg;
     918:	e0bffc17 	ldw	r2,-16(fp)
     91c:	e0bff815 	stw	r2,-32(fp)

  if (err == ERR_OK && p != NULL) {
     920:	e0bfff07 	ldb	r2,-4(fp)
     924:	1000791e 	bne	r2,zero,b0c <http_recv+0x218>
     928:	e0bffe17 	ldw	r2,-8(fp)
     92c:	10007726 	beq	r2,zero,b0c <http_recv+0x218>

    /* Inform TCP that we have taken the data. */
    tcp_recved(pcb, p->tot_len);
     930:	e0bffe17 	ldw	r2,-8(fp)
     934:	1080020b 	ldhu	r2,8(r2)
     938:	10bfffcc 	andi	r2,r2,65535
     93c:	e13ffd17 	ldw	r4,-12(fp)
     940:	100b883a 	mov	r5,r2
     944:	000bbb80 	call	bbb8 <tcp_recved>
    
    if (hs->file == NULL) {
     948:	e0bff817 	ldw	r2,-32(fp)
     94c:	10800117 	ldw	r2,4(r2)
     950:	10006c1e 	bne	r2,zero,b04 <http_recv+0x210>
      data = p->payload;
     954:	e0bffe17 	ldw	r2,-8(fp)
     958:	10800117 	ldw	r2,4(r2)
     95c:	e0bff915 	stw	r2,-28(fp)
      
      if (strncmp(data, "GET ", 4) == 0) {
     960:	e13ff917 	ldw	r4,-28(fp)
     964:	014000f4 	movhi	r5,3
     968:	2974ae04 	addi	r5,r5,-11592
     96c:	01800104 	movi	r6,4
     970:	0016a940 	call	16a94 <strncmp>
     974:	10005d1e 	bne	r2,zero,aec <http_recv+0x1f8>
        for(i = 0; i < 40; i++) {
     978:	e03ff715 	stw	zero,-36(fp)
     97c:	00002606 	br	a18 <http_recv+0x124>
          if (((char *)data + 4)[i] == ' ' ||
     980:	e0bff717 	ldw	r2,-36(fp)
     984:	10800104 	addi	r2,r2,4
     988:	e0fff917 	ldw	r3,-28(fp)
     98c:	1885883a 	add	r2,r3,r2
     990:	10800003 	ldbu	r2,0(r2)
     994:	10803fcc 	andi	r2,r2,255
     998:	1080201c 	xori	r2,r2,128
     99c:	10bfe004 	addi	r2,r2,-128
     9a0:	10800820 	cmpeqi	r2,r2,32
     9a4:	1000141e 	bne	r2,zero,9f8 <http_recv+0x104>
             ((char *)data + 4)[i] == '\r' ||
     9a8:	e0bff717 	ldw	r2,-36(fp)
     9ac:	10800104 	addi	r2,r2,4
     9b0:	e0fff917 	ldw	r3,-28(fp)
     9b4:	1885883a 	add	r2,r3,r2
     9b8:	10800003 	ldbu	r2,0(r2)
    if (hs->file == NULL) {
      data = p->payload;
      
      if (strncmp(data, "GET ", 4) == 0) {
        for(i = 0; i < 40; i++) {
          if (((char *)data + 4)[i] == ' ' ||
     9bc:	10803fcc 	andi	r2,r2,255
     9c0:	1080201c 	xori	r2,r2,128
     9c4:	10bfe004 	addi	r2,r2,-128
     9c8:	10800360 	cmpeqi	r2,r2,13
     9cc:	10000a1e 	bne	r2,zero,9f8 <http_recv+0x104>
             ((char *)data + 4)[i] == '\r' ||
             ((char *)data + 4)[i] == '\n') {
     9d0:	e0bff717 	ldw	r2,-36(fp)
     9d4:	10800104 	addi	r2,r2,4
     9d8:	e0fff917 	ldw	r3,-28(fp)
     9dc:	1885883a 	add	r2,r3,r2
     9e0:	10800003 	ldbu	r2,0(r2)
      data = p->payload;
      
      if (strncmp(data, "GET ", 4) == 0) {
        for(i = 0; i < 40; i++) {
          if (((char *)data + 4)[i] == ' ' ||
             ((char *)data + 4)[i] == '\r' ||
     9e4:	10803fcc 	andi	r2,r2,255
     9e8:	1080201c 	xori	r2,r2,128
     9ec:	10bfe004 	addi	r2,r2,-128
     9f0:	10800298 	cmpnei	r2,r2,10
     9f4:	1000051e 	bne	r2,zero,a0c <http_recv+0x118>
             ((char *)data + 4)[i] == '\n') {
            ((char *)data + 4)[i] = 0;
     9f8:	e0bff717 	ldw	r2,-36(fp)
     9fc:	10800104 	addi	r2,r2,4
     a00:	e0fff917 	ldw	r3,-28(fp)
     a04:	1885883a 	add	r2,r3,r2
     a08:	10000005 	stb	zero,0(r2)
    
    if (hs->file == NULL) {
      data = p->payload;
      
      if (strncmp(data, "GET ", 4) == 0) {
        for(i = 0; i < 40; i++) {
     a0c:	e0bff717 	ldw	r2,-36(fp)
     a10:	10800044 	addi	r2,r2,1
     a14:	e0bff715 	stw	r2,-36(fp)
     a18:	e0bff717 	ldw	r2,-36(fp)
     a1c:	10800a10 	cmplti	r2,r2,40
     a20:	103fd71e 	bne	r2,zero,980 <http_recv+0x8c>
             ((char *)data + 4)[i] == '\n') {
            ((char *)data + 4)[i] = 0;
          }
        }

        if (*(char *)(data + 4) == '/' &&
     a24:	e0bff917 	ldw	r2,-28(fp)
     a28:	10800104 	addi	r2,r2,4
     a2c:	10800003 	ldbu	r2,0(r2)
     a30:	10803fcc 	andi	r2,r2,255
     a34:	1080201c 	xori	r2,r2,128
     a38:	10bfe004 	addi	r2,r2,-128
     a3c:	10800bd8 	cmpnei	r2,r2,47
     a40:	10000d1e 	bne	r2,zero,a78 <http_recv+0x184>
           *(char *)(data + 5) == 0) {
     a44:	e0bff917 	ldw	r2,-28(fp)
     a48:	10800144 	addi	r2,r2,5
     a4c:	10800003 	ldbu	r2,0(r2)
             ((char *)data + 4)[i] == '\n') {
            ((char *)data + 4)[i] = 0;
          }
        }

        if (*(char *)(data + 4) == '/' &&
     a50:	10803fcc 	andi	r2,r2,255
     a54:	1080201c 	xori	r2,r2,128
     a58:	10bfe004 	addi	r2,r2,-128
     a5c:	1000061e 	bne	r2,zero,a78 <http_recv+0x184>
           *(char *)(data + 5) == 0) {
          fs_open("/index.html", &file);
     a60:	e0bffa04 	addi	r2,fp,-24
     a64:	010000f4 	movhi	r4,3
     a68:	2134b004 	addi	r4,r4,-11584
     a6c:	100b883a 	mov	r5,r2
     a70:	00005900 	call	590 <fs_open>
     a74:	00000c06 	br	aa8 <http_recv+0x1b4>
        } else if (!fs_open((char *)data + 4, &file)) {
     a78:	e0bff917 	ldw	r2,-28(fp)
     a7c:	10c00104 	addi	r3,r2,4
     a80:	e0bffa04 	addi	r2,fp,-24
     a84:	1809883a 	mov	r4,r3
     a88:	100b883a 	mov	r5,r2
     a8c:	00005900 	call	590 <fs_open>
     a90:	1000051e 	bne	r2,zero,aa8 <http_recv+0x1b4>
          fs_open("/404.html", &file);
     a94:	e0bffa04 	addi	r2,fp,-24
     a98:	010000f4 	movhi	r4,3
     a9c:	2134b304 	addi	r4,r4,-11572
     aa0:	100b883a 	mov	r5,r2
     aa4:	00005900 	call	590 <fs_open>
        }

        hs->file = file.data;
     aa8:	e0fffa17 	ldw	r3,-24(fp)
     aac:	e0bff817 	ldw	r2,-32(fp)
     ab0:	10c00115 	stw	r3,4(r2)
        LWIP_ASSERT((file.len >= 0), "File length must be positive!");
        hs->left = file.len;
     ab4:	e0bffb17 	ldw	r2,-20(fp)
     ab8:	1007883a 	mov	r3,r2
     abc:	e0bff817 	ldw	r2,-32(fp)
     ac0:	10c00015 	stw	r3,0(r2)
        /* printf("data %p len %ld\n", hs->file, hs->left);*/

        pbuf_free(p);
     ac4:	e13ffe17 	ldw	r4,-8(fp)
     ac8:	000a16c0 	call	a16c <pbuf_free>
        send_data(pcb, hs);
     acc:	e13ffd17 	ldw	r4,-12(fp)
     ad0:	e17ff817 	ldw	r5,-32(fp)
     ad4:	00006c40 	call	6c4 <send_data>

        /* Tell TCP that we wish be to informed of data that has been
           successfully sent by a call to the http_sent() function. */
        tcp_sent(pcb, http_sent);
     ad8:	e13ffd17 	ldw	r4,-12(fp)
     adc:	01400034 	movhi	r5,0
     ae0:	29422104 	addi	r5,r5,2180
     ae4:	000ced00 	call	ced0 <tcp_sent>
     ae8:	00000806 	br	b0c <http_recv+0x218>
      } else {
        pbuf_free(p);
     aec:	e13ffe17 	ldw	r4,-8(fp)
     af0:	000a16c0 	call	a16c <pbuf_free>
        close_conn(pcb, hs);
     af4:	e13ffd17 	ldw	r4,-12(fp)
     af8:	e17ff817 	ldw	r5,-32(fp)
     afc:	00006640 	call	664 <close_conn>
     b00:	00000206 	br	b0c <http_recv+0x218>
      }
    } else {
      pbuf_free(p);
     b04:	e13ffe17 	ldw	r4,-8(fp)
     b08:	000a16c0 	call	a16c <pbuf_free>
    }
  }

  if (err == ERR_OK && p == NULL) {
     b0c:	e0bfff07 	ldb	r2,-4(fp)
     b10:	1000051e 	bne	r2,zero,b28 <http_recv+0x234>
     b14:	e0bffe17 	ldw	r2,-8(fp)
     b18:	1000031e 	bne	r2,zero,b28 <http_recv+0x234>
    close_conn(pcb, hs);
     b1c:	e13ffd17 	ldw	r4,-12(fp)
     b20:	e17ff817 	ldw	r5,-32(fp)
     b24:	00006640 	call	664 <close_conn>
  }
  return ERR_OK;
     b28:	0005883a 	mov	r2,zero
}
     b2c:	e037883a 	mov	sp,fp
     b30:	dfc00117 	ldw	ra,4(sp)
     b34:	df000017 	ldw	fp,0(sp)
     b38:	dec00204 	addi	sp,sp,8
     b3c:	f800283a 	ret

00000b40 <http_accept>:
/*-----------------------------------------------------------------------------------*/
static err_t
http_accept(void *arg, struct tcp_pcb *pcb, err_t err)
{
     b40:	defff904 	addi	sp,sp,-28
     b44:	dfc00615 	stw	ra,24(sp)
     b48:	df000515 	stw	fp,20(sp)
     b4c:	df000504 	addi	fp,sp,20
     b50:	e13ffd15 	stw	r4,-12(fp)
     b54:	e17ffe15 	stw	r5,-8(fp)
     b58:	3005883a 	mov	r2,r6
     b5c:	e0bfff05 	stb	r2,-4(fp)
  struct http_state *hs;
  struct tcp_pcb_listen *lpcb = (struct tcp_pcb_listen*)arg;
     b60:	e0bffd17 	ldw	r2,-12(fp)
     b64:	e0bffb15 	stw	r2,-20(fp)
  LWIP_UNUSED_ARG(err);

  /* Decrease the listen backlog counter */
  tcp_accepted(lpcb);

  tcp_setprio(pcb, TCP_PRIO_MIN);
     b68:	e13ffe17 	ldw	r4,-8(fp)
     b6c:	01400044 	movi	r5,1
     b70:	000c9e00 	call	c9e0 <tcp_setprio>
  
  /* Allocate memory for the structure that holds the state of the
     connection. */
  hs = (struct http_state *)mem_malloc(sizeof(struct http_state));
     b74:	01000304 	movi	r4,12
     b78:	00088d00 	call	88d0 <mem_malloc>
     b7c:	e0bffc15 	stw	r2,-16(fp)

  if (hs == NULL) {
     b80:	e0bffc17 	ldw	r2,-16(fp)
     b84:	1000051e 	bne	r2,zero,b9c <http_accept+0x5c>
    printf("http_accept: Out of memory\n");
     b88:	010000f4 	movhi	r4,3
     b8c:	2134b604 	addi	r4,r4,-11560
     b90:	00169500 	call	16950 <puts>
    return ERR_MEM;
     b94:	00bfffc4 	movi	r2,-1
     b98:	00001706 	br	bf8 <http_accept+0xb8>
  }
  
  /* Initialize the structure. */
  hs->file = NULL;
     b9c:	e0bffc17 	ldw	r2,-16(fp)
     ba0:	10000115 	stw	zero,4(r2)
  hs->left = 0;
     ba4:	e0bffc17 	ldw	r2,-16(fp)
     ba8:	10000015 	stw	zero,0(r2)
  hs->retries = 0;
     bac:	e0bffc17 	ldw	r2,-16(fp)
     bb0:	10000205 	stb	zero,8(r2)
  
  /* Tell TCP that this is the structure we wish to be passed for our
     callbacks. */
  tcp_arg(pcb, hs);
     bb4:	e13ffe17 	ldw	r4,-8(fp)
     bb8:	e17ffc17 	ldw	r5,-16(fp)
     bbc:	000ce700 	call	ce70 <tcp_arg>

  /* Tell TCP that we wish to be informed of incoming data by a call
     to the http_recv() function. */
  tcp_recv(pcb, http_recv);
     bc0:	e13ffe17 	ldw	r4,-8(fp)
     bc4:	01400034 	movhi	r5,0
     bc8:	29423d04 	addi	r5,r5,2292
     bcc:	000cea00 	call	cea0 <tcp_recv>

  tcp_err(pcb, conn_err);
     bd0:	e13ffe17 	ldw	r4,-8(fp)
     bd4:	01400034 	movhi	r5,0
     bd8:	29418904 	addi	r5,r5,1572
     bdc:	000cf000 	call	cf00 <tcp_err>
  
  tcp_poll(pcb, http_poll, 4);
     be0:	e13ffe17 	ldw	r4,-8(fp)
     be4:	01400034 	movhi	r5,0
     be8:	2941ee04 	addi	r5,r5,1976
     bec:	01800104 	movi	r6,4
     bf0:	000cf600 	call	cf60 <tcp_poll>

  return ERR_OK;
     bf4:	0005883a 	mov	r2,zero
}
     bf8:	e037883a 	mov	sp,fp
     bfc:	dfc00117 	ldw	ra,4(sp)
     c00:	df000017 	ldw	fp,0(sp)
     c04:	dec00204 	addi	sp,sp,8
     c08:	f800283a 	ret

00000c0c <httpd_init>:
/*-----------------------------------------------------------------------------------*/
void
httpd_init(void)
{
     c0c:	defffd04 	addi	sp,sp,-12
     c10:	dfc00215 	stw	ra,8(sp)
     c14:	df000115 	stw	fp,4(sp)
     c18:	df000104 	addi	fp,sp,4
  struct tcp_pcb *pcb;

  pcb = tcp_new();
     c1c:	000ce440 	call	ce44 <tcp_new>
     c20:	e0bfff15 	stw	r2,-4(fp)
  tcp_bind(pcb, IP_ADDR_ANY, 80);
     c24:	e13fff17 	ldw	r4,-4(fp)
     c28:	014000f4 	movhi	r5,3
     c2c:	294d2104 	addi	r5,r5,13444
     c30:	01801404 	movi	r6,80
     c34:	000b5fc0 	call	b5fc <tcp_bind>
  pcb = tcp_listen(pcb);
     c38:	e13fff17 	ldw	r4,-4(fp)
     c3c:	01403fc4 	movi	r5,255
     c40:	000b9080 	call	b908 <tcp_listen_with_backlog>
     c44:	e0bfff15 	stw	r2,-4(fp)
  tcp_arg(pcb, pcb);
     c48:	e13fff17 	ldw	r4,-4(fp)
     c4c:	e17fff17 	ldw	r5,-4(fp)
     c50:	000ce700 	call	ce70 <tcp_arg>
  tcp_accept(pcb, http_accept);
     c54:	e13fff17 	ldw	r4,-4(fp)
     c58:	01400034 	movhi	r5,0
     c5c:	2942d004 	addi	r5,r5,2880
     c60:	000cf300 	call	cf30 <tcp_accept>
}
     c64:	e037883a 	mov	sp,fp
     c68:	dfc00117 	ldw	ra,4(sp)
     c6c:	df000017 	ldw	fp,0(sp)
     c70:	dec00204 	addi	sp,sp,8
     c74:	f800283a 	ret

00000c78 <tse_mac_init>:
 * @API TYPE: Internal
 * @Param iface index of the NET structure associated with TSE instance
 * @Return 0 if ok, else -1 if error
 */
int tse_mac_init(int iface, struct ethernetif *ethernetif)
{
     c78:	defff004 	addi	sp,sp,-64
     c7c:	dfc00f15 	stw	ra,60(sp)
     c80:	df000e15 	stw	fp,56(sp)
     c84:	df000e04 	addi	fp,sp,56
     c88:	e13ffe15 	stw	r4,-8(fp)
     c8c:	e17fff15 	stw	r5,-4(fp)
   int speed, duplex, result;
   int x;
   
   alt_sgdma_dev *sgdma_tx_dev;
   alt_sgdma_dev *sgdma_rx_dev;
   alt_tse_system_info* tse_hw = (alt_tse_system_info *) tse[iface].tse;
     c90:	00c00134 	movhi	r3,4
     c94:	18cd5504 	addi	r3,r3,13652
     c98:	e0bffe17 	ldw	r2,-8(fp)
     c9c:	1004917a 	slli	r2,r2,5
     ca0:	1885883a 	add	r2,r3,r2
     ca4:	10800704 	addi	r2,r2,28
     ca8:	10800017 	ldw	r2,0(r2)
     cac:	e0bff715 	stw	r2,-36(fp)
   np_tse_mac *mi_base;
   alt_tse_mac_info *pmac_info;
   
   dprintf(("[tse_mac_init]\n"));
     cb0:	010000f4 	movhi	r4,3
     cb4:	2134bd04 	addi	r4,r4,-11532
     cb8:	00169500 	call	16950 <puts>
#ifdef PRINTIF
   dprintf(("tse_mac_init %d\n", iface));
#endif    
   // These lines were done in prep_tse_mac 
   tse_hw = &tse_mac_device[iface];	
     cbc:	e0bffe17 	ldw	r2,-8(fp)
     cc0:	10c01224 	muli	r3,r2,72
     cc4:	008000f4 	movhi	r2,3
     cc8:	108c9004 	addi	r2,r2,12864
     ccc:	1885883a 	add	r2,r3,r2
     cd0:	e0bff715 	stw	r2,-36(fp)
   tse[iface].tse = tse_hw;
     cd4:	00c00134 	movhi	r3,4
     cd8:	18cd5504 	addi	r3,r3,13652
     cdc:	e0bffe17 	ldw	r2,-8(fp)
     ce0:	1004917a 	slli	r2,r2,5
     ce4:	1885883a 	add	r2,r3,r2
     ce8:	10800704 	addi	r2,r2,28
     cec:	e0fff717 	ldw	r3,-36(fp)
     cf0:	10c00015 	stw	r3,0(r2)
	
   // Store ethernetif for access, and the tse in ethernetif for access in tse_mac_raw_send/tse_mac_rcv
   tse[iface].ethernetif = ethernetif;
     cf4:	00c00134 	movhi	r3,4
     cf8:	18cd5504 	addi	r3,r3,13652
     cfc:	e0bffe17 	ldw	r2,-8(fp)
     d00:	1004917a 	slli	r2,r2,5
     d04:	1885883a 	add	r2,r3,r2
     d08:	10800604 	addi	r2,r2,24
     d0c:	e0ffff17 	ldw	r3,-4(fp)
     d10:	10c00015 	stw	r3,0(r2)
   ethernetif->iface = iface;
     d14:	e0bfff17 	ldw	r2,-4(fp)
     d18:	e0fffe17 	ldw	r3,-8(fp)
     d1c:	10c00115 	stw	r3,4(r2)
   ethernetif->tse_info = &tse[iface];
     d20:	e0bffe17 	ldw	r2,-8(fp)
     d24:	1006917a 	slli	r3,r2,5
     d28:	00800134 	movhi	r2,4
     d2c:	108d5504 	addi	r2,r2,13652
     d30:	1887883a 	add	r3,r3,r2
     d34:	e0bfff17 	ldw	r2,-4(fp)
     d38:	10c01615 	stw	r3,88(r2)
	
   if (tse_hw->ext_desc_mem == 1)
     d3c:	e0bff717 	ldw	r2,-36(fp)
     d40:	10800783 	ldbu	r2,30(r2)
     d44:	10803fcc 	andi	r2,r2,255
     d48:	10800058 	cmpnei	r2,r2,1
     d4c:	10000b1e 	bne	r2,zero,d7c <tse_mac_init+0x104>
      tse[iface].desc = (alt_sgdma_descriptor *) tse_hw->desc_mem_base;
     d50:	e0bff717 	ldw	r2,-36(fp)
     d54:	10800817 	ldw	r2,32(r2)
     d58:	1007883a 	mov	r3,r2
     d5c:	01000134 	movhi	r4,4
     d60:	210d5504 	addi	r4,r4,13652
     d64:	e0bffe17 	ldw	r2,-8(fp)
     d68:	1004917a 	slli	r2,r2,5
     d6c:	2085883a 	add	r2,r4,r2
     d70:	10800504 	addi	r2,r2,20
     d74:	10c00015 	stw	r3,0(r2)
     d78:	00001206 	br	dc4 <tse_mac_init+0x14c>
   else
      {
      unsigned char *temp_desc = (unsigned char *)alt_uncached_malloc((4+ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE)*(sizeof(alt_sgdma_descriptor)));
     d7c:	01002804 	movi	r4,160
     d80:	00207c40 	call	207c4 <alt_uncached_malloc>
     d84:	e0bff615 	stw	r2,-40(fp)
    
      while ((((alt_u32)temp_desc) % ALTERA_AVALON_SGDMA_DESCRIPTOR_SIZE) != 0)
     d88:	00000306 	br	d98 <tse_mac_init+0x120>
         temp_desc++;
     d8c:	e0bff617 	ldw	r2,-40(fp)
     d90:	10800044 	addi	r2,r2,1
     d94:	e0bff615 	stw	r2,-40(fp)
      tse[iface].desc = (alt_sgdma_descriptor *) tse_hw->desc_mem_base;
   else
      {
      unsigned char *temp_desc = (unsigned char *)alt_uncached_malloc((4+ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE)*(sizeof(alt_sgdma_descriptor)));
    
      while ((((alt_u32)temp_desc) % ALTERA_AVALON_SGDMA_DESCRIPTOR_SIZE) != 0)
     d98:	e0bff617 	ldw	r2,-40(fp)
     d9c:	108007cc 	andi	r2,r2,31
     da0:	103ffa1e 	bne	r2,zero,d8c <tse_mac_init+0x114>
         temp_desc++;
      tse[iface].desc = (alt_sgdma_descriptor *) temp_desc;
     da4:	00c00134 	movhi	r3,4
     da8:	18cd5504 	addi	r3,r3,13652
     dac:	e0bffe17 	ldw	r2,-8(fp)
     db0:	1004917a 	slli	r2,r2,5
     db4:	1885883a 	add	r2,r3,r2
     db8:	10800504 	addi	r2,r2,20
     dbc:	e0fff617 	ldw	r3,-40(fp)
     dc0:	10c00015 	stw	r3,0(r2)
      }

   
   /* Get the Rx and Tx SGDMA addresses */
   sgdma_tx_dev = alt_avalon_sgdma_open(tse_hw->tse_sgdma_tx);
     dc4:	e0bff717 	ldw	r2,-36(fp)
     dc8:	10800517 	ldw	r2,20(r2)
     dcc:	1009883a 	mov	r4,r2
     dd0:	00248240 	call	24824 <alt_avalon_sgdma_open>
     dd4:	e0bff815 	stw	r2,-32(fp)
   
   if(!sgdma_tx_dev) 
     dd8:	e0bff817 	ldw	r2,-32(fp)
     ddc:	1000051e 	bne	r2,zero,df4 <tse_mac_init+0x17c>
      {
      dprintf(("[triple_speed_ethernet_init] Error opening TX SGDMA\n"));
     de0:	010000f4 	movhi	r4,3
     de4:	2134c104 	addi	r4,r4,-11516
     de8:	00169500 	call	16950 <puts>
      return ENP_RESOURCE;
     dec:	00bffa84 	movi	r2,-22
     df0:	0001b106 	br	14b8 <tse_mac_init+0x840>
      }
  
   sgdma_rx_dev = alt_avalon_sgdma_open(tse_hw->tse_sgdma_rx);
     df4:	e0bff717 	ldw	r2,-36(fp)
     df8:	10800617 	ldw	r2,24(r2)
     dfc:	1009883a 	mov	r4,r2
     e00:	00248240 	call	24824 <alt_avalon_sgdma_open>
     e04:	e0bff915 	stw	r2,-28(fp)
   if(!sgdma_rx_dev) 
     e08:	e0bff917 	ldw	r2,-28(fp)
     e0c:	1000051e 	bne	r2,zero,e24 <tse_mac_init+0x1ac>
      {
      dprintf(("[triple_speed_ethernet_init] Error opening RX SGDMA\n"));
     e10:	010000f4 	movhi	r4,3
     e14:	2134ce04 	addi	r4,r4,-11464
     e18:	00169500 	call	16950 <puts>
      return ENP_RESOURCE;
     e1c:	00bffa84 	movi	r2,-22
     e20:	0001a506 	br	14b8 <tse_mac_init+0x840>
      }

   /* Initialize mtip_mac_trans_info structure with values from <system.h>*/

   tse_mac_initTransInfo2(&tse[iface].mi, (int)tse_hw->tse_mac_base,
     e24:	e0bffe17 	ldw	r2,-8(fp)
     e28:	1006917a 	slli	r3,r2,5
     e2c:	00800134 	movhi	r2,4
     e30:	108d5504 	addi	r2,r2,13652
     e34:	1889883a 	add	r4,r3,r2
     e38:	e0bff717 	ldw	r2,-36(fp)
     e3c:	11400017 	ldw	r5,0(r2)
     e40:	e0fff817 	ldw	r3,-32(fp)
     e44:	e0bff917 	ldw	r2,-28(fp)
     e48:	d8000015 	stw	zero,0(sp)
     e4c:	180d883a 	mov	r6,r3
     e50:	100f883a 	mov	r7,r2
     e54:	0024ffc0 	call	24ffc <tse_mac_initTransInfo2>
                                   (unsigned int)sgdma_tx_dev,            
                                   (unsigned int)sgdma_rx_dev,
                                   0);
   mi_base = tse[iface].mi.base;
     e58:	00c00134 	movhi	r3,4
     e5c:	18cd5504 	addi	r3,r3,13652
     e60:	e0bffe17 	ldw	r2,-8(fp)
     e64:	1004917a 	slli	r2,r2,5
     e68:	1885883a 	add	r2,r3,r2
     e6c:	10800017 	ldw	r2,0(r2)
     e70:	e0bffa15 	stw	r2,-24(fp)

   IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma->base,ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
     e74:	00c00134 	movhi	r3,4
     e78:	18cd5504 	addi	r3,r3,13652
     e7c:	e0bffe17 	ldw	r2,-8(fp)
     e80:	1004917a 	slli	r2,r2,5
     e84:	1885883a 	add	r2,r3,r2
     e88:	10800204 	addi	r2,r2,8
     e8c:	10800017 	ldw	r2,0(r2)
     e90:	10800317 	ldw	r2,12(r2)
     e94:	10800404 	addi	r2,r2,16
     e98:	00c00074 	movhi	r3,1
     e9c:	10c00035 	stwio	r3,0(r2)
   IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma->base, 0x0);
     ea0:	00c00134 	movhi	r3,4
     ea4:	18cd5504 	addi	r3,r3,13652
     ea8:	e0bffe17 	ldw	r2,-8(fp)
     eac:	1004917a 	slli	r2,r2,5
     eb0:	1885883a 	add	r2,r3,r2
     eb4:	10800204 	addi	r2,r2,8
     eb8:	10800017 	ldw	r2,0(r2)
     ebc:	10800317 	ldw	r2,12(r2)
     ec0:	10800404 	addi	r2,r2,16
     ec4:	0007883a 	mov	r3,zero
     ec8:	10c00035 	stwio	r3,0(r2)
   
   /* reset the PHY if necessary */
   result = getPHYSpeed(tse[iface].mi.base);
     ecc:	00c00134 	movhi	r3,4
     ed0:	18cd5504 	addi	r3,r3,13652
     ed4:	e0bffe17 	ldw	r2,-8(fp)
     ed8:	1004917a 	slli	r2,r2,5
     edc:	1885883a 	add	r2,r3,r2
     ee0:	10800017 	ldw	r2,0(r2)
     ee4:	1009883a 	mov	r4,r2
     ee8:	002647c0 	call	2647c <getPHYSpeed>
     eec:	e0bffb15 	stw	r2,-20(fp)
   speed = (result >> 1) & 0x07;
     ef0:	e0bffb17 	ldw	r2,-20(fp)
     ef4:	1005d07a 	srai	r2,r2,1
     ef8:	108001cc 	andi	r2,r2,7
     efc:	e0bffc15 	stw	r2,-16(fp)
   duplex = result & 0x01;
     f00:	e0bffb17 	ldw	r2,-20(fp)
     f04:	1080004c 	andi	r2,r2,1
     f08:	e0bff415 	stw	r2,-48(fp)
    
   /* reset the mac */ 
   IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base,
     f0c:	00c00134 	movhi	r3,4
     f10:	18cd5504 	addi	r3,r3,13652
     f14:	e0bffe17 	ldw	r2,-8(fp)
     f18:	1004917a 	slli	r2,r2,5
     f1c:	1885883a 	add	r2,r3,r2
     f20:	10800017 	ldw	r2,0(r2)
     f24:	10800204 	addi	r2,r2,8
     f28:	00c800c4 	movi	r3,8195
     f2c:	10c00035 	stwio	r3,0(r2)
                             mmac_cc_SW_RESET_mask | 
                             mmac_cc_TX_ENA_mask | 
                             mmac_cc_RX_ENA_mask);
  
   x=0;
     f30:	e03ff515 	stw	zero,-44(fp)
   while(IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base) & 
     f34:	00000706 	br	f54 <tse_mac_init+0x2dc>
         ALTERA_TSEMAC_CMD_SW_RESET_MSK) 
      {
      if( x++ > 10000 ) 
     f38:	e0bff517 	ldw	r2,-44(fp)
     f3c:	1089c448 	cmpgei	r2,r2,10001
     f40:	e0fff517 	ldw	r3,-44(fp)
     f44:	18c00044 	addi	r3,r3,1
     f48:	e0fff515 	stw	r3,-44(fp)
     f4c:	10803fcc 	andi	r2,r2,255
     f50:	10000b1e 	bne	r2,zero,f80 <tse_mac_init+0x308>
                             mmac_cc_SW_RESET_mask | 
                             mmac_cc_TX_ENA_mask | 
                             mmac_cc_RX_ENA_mask);
  
   x=0;
   while(IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base) & 
     f54:	00c00134 	movhi	r3,4
     f58:	18cd5504 	addi	r3,r3,13652
     f5c:	e0bffe17 	ldw	r2,-8(fp)
     f60:	1004917a 	slli	r2,r2,5
     f64:	1885883a 	add	r2,r3,r2
     f68:	10800017 	ldw	r2,0(r2)
     f6c:	10800204 	addi	r2,r2,8
     f70:	10800037 	ldwio	r2,0(r2)
     f74:	1088000c 	andi	r2,r2,8192
     f78:	103fef1e 	bne	r2,zero,f38 <tse_mac_init+0x2c0>
     f7c:	00000106 	br	f84 <tse_mac_init+0x30c>
         ALTERA_TSEMAC_CMD_SW_RESET_MSK) 
      {
      if( x++ > 10000 ) 
         break;
     f80:	0001883a 	nop
      }
  
   if(x >= 10000)
     f84:	e0bff517 	ldw	r2,-44(fp)
     f88:	1089c410 	cmplti	r2,r2,10000
     f8c:	1000031e 	bne	r2,zero,f9c <tse_mac_init+0x324>
      dprintf(("TSEMAC SW reset bit never cleared!\n"));
     f90:	010000f4 	movhi	r4,3
     f94:	2134db04 	addi	r4,r4,-11412
     f98:	00169500 	call	16950 <puts>

   dat = IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base);
     f9c:	00c00134 	movhi	r3,4
     fa0:	18cd5504 	addi	r3,r3,13652
     fa4:	e0bffe17 	ldw	r2,-8(fp)
     fa8:	1004917a 	slli	r2,r2,5
     fac:	1885883a 	add	r2,r3,r2
     fb0:	10800017 	ldw	r2,0(r2)
     fb4:	10800204 	addi	r2,r2,8
     fb8:	10800037 	ldwio	r2,0(r2)
     fbc:	e0bff315 	stw	r2,-52(fp)
   if( (dat & 0x03) != 0 ) 
     fc0:	e0bff317 	ldw	r2,-52(fp)
     fc4:	108000cc 	andi	r2,r2,3
     fc8:	10000426 	beq	r2,zero,fdc <tse_mac_init+0x364>
      dprintf(("WARN: RX/TX not disabled after reset... missing PHY clock? CMD_CONFIG=0x%08x\n", dat));
     fcc:	e0bff317 	ldw	r2,-52(fp)
     fd0:	1009883a 	mov	r4,r2
     fd4:	00166c00 	call	166c0 <printf>
     fd8:	00000306 	br	fe8 <tse_mac_init+0x370>
   else
      dprintf(("OK, x=%d, CMD_CONFIG=0x%08x\n", x, dat));
     fdc:	e0bff317 	ldw	r2,-52(fp)
     fe0:	1009883a 	mov	r4,r2
     fe4:	00166c00 	call	166c0 <printf>
  
   /* Initialize MAC registers */
   IOWR_ALTERA_TSEMAC_FRM_LENGTH(mi_base, PBUF_POOL_BUFSIZE+ETH_PAD_SIZE); 
     fe8:	e0bffa17 	ldw	r2,-24(fp)
     fec:	10800504 	addi	r2,r2,20
     ff0:	00c17b84 	movi	r3,1518
     ff4:	10c00035 	stwio	r3,0(r2)
   IOWR_ALTERA_TSEMAC_RX_ALMOST_EMPTY(mi_base, 8);
     ff8:	e0bffa17 	ldw	r2,-24(fp)
     ffc:	10800b04 	addi	r2,r2,44
    1000:	00c00204 	movi	r3,8
    1004:	10c00035 	stwio	r3,0(r2)
   IOWR_ALTERA_TSEMAC_RX_ALMOST_FULL(mi_base, 8);
    1008:	e0bffa17 	ldw	r2,-24(fp)
    100c:	10800c04 	addi	r2,r2,48
    1010:	00c00204 	movi	r3,8
    1014:	10c00035 	stwio	r3,0(r2)
   IOWR_ALTERA_TSEMAC_TX_ALMOST_EMPTY(mi_base, 8);
    1018:	e0bffa17 	ldw	r2,-24(fp)
    101c:	10800d04 	addi	r2,r2,52
    1020:	00c00204 	movi	r3,8
    1024:	10c00035 	stwio	r3,0(r2)
   IOWR_ALTERA_TSEMAC_TX_ALMOST_FULL(mi_base,  3);
    1028:	e0bffa17 	ldw	r2,-24(fp)
    102c:	10800e04 	addi	r2,r2,56
    1030:	00c000c4 	movi	r3,3
    1034:	10c00035 	stwio	r3,0(r2)
   IOWR_ALTERA_TSEMAC_TX_SECTION_EMPTY(mi_base, tse_hw->tse_tx_depth - 16); //1024/4;  
    1038:	e0bffa17 	ldw	r2,-24(fp)
    103c:	10800904 	addi	r2,r2,36
    1040:	e0fff717 	ldw	r3,-36(fp)
    1044:	18c0010b 	ldhu	r3,4(r3)
    1048:	18ffffcc 	andi	r3,r3,65535
    104c:	18fffc04 	addi	r3,r3,-16
    1050:	10c00035 	stwio	r3,0(r2)
   IOWR_ALTERA_TSEMAC_TX_SECTION_FULL(mi_base,  0); //32/4; // start transmit when there are 48 bytes
    1054:	e0bffa17 	ldw	r2,-24(fp)
    1058:	10800a04 	addi	r2,r2,40
    105c:	0007883a 	mov	r3,zero
    1060:	10c00035 	stwio	r3,0(r2)
   IOWR_ALTERA_TSEMAC_RX_SECTION_EMPTY(mi_base, tse_hw->tse_rx_depth - 16); //4000/4);
    1064:	e0bffa17 	ldw	r2,-24(fp)
    1068:	10800704 	addi	r2,r2,28
    106c:	e0fff717 	ldw	r3,-36(fp)
    1070:	18c0018b 	ldhu	r3,6(r3)
    1074:	18ffffcc 	andi	r3,r3,65535
    1078:	18fffc04 	addi	r3,r3,-16
    107c:	10c00035 	stwio	r3,0(r2)
   IOWR_ALTERA_TSEMAC_RX_SECTION_FULL(mi_base,  0);
    1080:	e0bffa17 	ldw	r2,-24(fp)
    1084:	10800804 	addi	r2,r2,32
    1088:	0007883a 	mov	r3,zero
    108c:	10c00035 	stwio	r3,0(r2)

   /* Enable TX shift 16 for removing two bytes from the start of all transmitted frames */
   IOWR_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK);
    1090:	00c00134 	movhi	r3,4
    1094:	18cd5504 	addi	r3,r3,13652
    1098:	e0bffe17 	ldw	r2,-8(fp)
    109c:	1004917a 	slli	r2,r2,5
    10a0:	1885883a 	add	r2,r3,r2
    10a4:	10800017 	ldw	r2,0(r2)
    10a8:	10803a04 	addi	r2,r2,232
    10ac:	00c00134 	movhi	r3,4
    10b0:	10c00035 	stwio	r3,0(r2)
 
   /*
    * check if the MAC supports the 16-bit shift option allowing us
    * to send BIASed frames without copying. Used by the send function later.
    */
   if((IORD_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK) == 0)
    10b4:	00c00134 	movhi	r3,4
    10b8:	18cd5504 	addi	r3,r3,13652
    10bc:	e0bffe17 	ldw	r2,-8(fp)
    10c0:	1004917a 	slli	r2,r2,5
    10c4:	1885883a 	add	r2,r3,r2
    10c8:	10800017 	ldw	r2,0(r2)
    10cc:	10803a04 	addi	r2,r2,232
    10d0:	10800037 	ldwio	r2,0(r2)
    10d4:	1080012c 	andhi	r2,r2,4
    10d8:	1000041e 	bne	r2,zero,10ec <tse_mac_init+0x474>
      {
      dprintf(("[tse_mac_init] Error: Incompatible %d value with TX_CMD_STAT register return TxShift16 value. \n",ETH_PAD_SIZE));
    10dc:	01000084 	movi	r4,2
    10e0:	00166c00 	call	166c0 <printf>
      return ERR_IF;
    10e4:	00bffd04 	movi	r2,-12
    10e8:	0000f306 	br	14b8 <tse_mac_init+0x840>
      }
  
   /* Enable RX shift 16 for alignment of all received frames on 16-bit start address */
   IOWR_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK);
    10ec:	00c00134 	movhi	r3,4
    10f0:	18cd5504 	addi	r3,r3,13652
    10f4:	e0bffe17 	ldw	r2,-8(fp)
    10f8:	1004917a 	slli	r2,r2,5
    10fc:	1885883a 	add	r2,r3,r2
    1100:	10800017 	ldw	r2,0(r2)
    1104:	10803b04 	addi	r2,r2,236
    1108:	00c08034 	movhi	r3,512
    110c:	10c00035 	stwio	r3,0(r2)
 
   /* check if the MAC supports the 16-bit shift option at the RX CMD STATUS Register  */ 
   if((IORD_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK) == 0)
    1110:	00c00134 	movhi	r3,4
    1114:	18cd5504 	addi	r3,r3,13652
    1118:	e0bffe17 	ldw	r2,-8(fp)
    111c:	1004917a 	slli	r2,r2,5
    1120:	1885883a 	add	r2,r3,r2
    1124:	10800017 	ldw	r2,0(r2)
    1128:	10803b04 	addi	r2,r2,236
    112c:	10800037 	ldwio	r2,0(r2)
    1130:	1080802c 	andhi	r2,r2,512
    1134:	1000041e 	bne	r2,zero,1148 <tse_mac_init+0x4d0>
      {
      dprintf(("[tse_mac_init] Error: Incompatible %d value with RX_CMD_STAT register return RxShift16 value. \n",ETH_PAD_SIZE));
    1138:	01000084 	movi	r4,2
    113c:	00166c00 	call	166c0 <printf>
      return ERR_IF;
    1140:	00bffd04 	movi	r2,-12
    1144:	0000dc06 	br	14b8 <tse_mac_init+0x840>
      }
 
   /* Set the MAC address */  
   IOWR_ALTERA_TSEMAC_MAC_0(mi_base,
    1148:	e0bffa17 	ldw	r2,-24(fp)
    114c:	10800304 	addi	r2,r2,12
    1150:	e0ffff17 	ldw	r3,-4(fp)
    1154:	18c00017 	ldw	r3,0(r3)
    1158:	18c00003 	ldbu	r3,0(r3)
    115c:	19003fcc 	andi	r4,r3,255
    1160:	e0ffff17 	ldw	r3,-4(fp)
    1164:	18c00017 	ldw	r3,0(r3)
    1168:	18c00043 	ldbu	r3,1(r3)
    116c:	18c03fcc 	andi	r3,r3,255
    1170:	1806923a 	slli	r3,r3,8
    1174:	20c8b03a 	or	r4,r4,r3
    1178:	e0ffff17 	ldw	r3,-4(fp)
    117c:	18c00017 	ldw	r3,0(r3)
    1180:	18c00083 	ldbu	r3,2(r3)
    1184:	18c03fcc 	andi	r3,r3,255
    1188:	1806943a 	slli	r3,r3,16
    118c:	20c8b03a 	or	r4,r4,r3
    1190:	e0ffff17 	ldw	r3,-4(fp)
    1194:	18c00017 	ldw	r3,0(r3)
    1198:	18c000c3 	ldbu	r3,3(r3)
    119c:	18c03fcc 	andi	r3,r3,255
    11a0:	1806963a 	slli	r3,r3,24
    11a4:	20c6b03a 	or	r3,r4,r3
    11a8:	10c00035 	stwio	r3,0(r2)
                           ((int)((unsigned char) ethernetif->ethaddr->addr[0]) | 
                            (int)((unsigned char) ethernetif->ethaddr->addr[1] <<  8) |
                            (int)((unsigned char) ethernetif->ethaddr->addr[2] << 16) | 
                            (int)((unsigned char) ethernetif->ethaddr->addr[3] << 24)));
  
   IOWR_ALTERA_TSEMAC_MAC_1(mi_base, 
    11ac:	e0bffa17 	ldw	r2,-24(fp)
    11b0:	10800404 	addi	r2,r2,16
    11b4:	e0ffff17 	ldw	r3,-4(fp)
    11b8:	18c00017 	ldw	r3,0(r3)
    11bc:	18c00103 	ldbu	r3,4(r3)
    11c0:	19003fcc 	andi	r4,r3,255
    11c4:	e0ffff17 	ldw	r3,-4(fp)
    11c8:	18c00017 	ldw	r3,0(r3)
    11cc:	18c00143 	ldbu	r3,5(r3)
    11d0:	18c03fcc 	andi	r3,r3,255
    11d4:	1806923a 	slli	r3,r3,8
    11d8:	20c6b03a 	or	r3,r4,r3
    11dc:	18ffffcc 	andi	r3,r3,65535
    11e0:	10c00035 	stwio	r3,0(r2)
                           (((int)((unsigned char) ethernetif->ethaddr->addr[4]) | 
                             (int)((unsigned char) ethernetif->ethaddr->addr[5] <<  8)) & 0xFFFF));
   
   /* enable MAC */
   dat = ALTERA_TSEMAC_CMD_TX_ENA_MSK       |
    11e4:	00810034 	movhi	r2,1024
    11e8:	108080c4 	addi	r2,r2,515
    11ec:	e0bff315 	stw	r2,-52(fp)
         ALTERA_TSEMAC_CMD_LOOPBACK_MSK     |     // promiscuous mode
#endif
         ALTERA_TSEMAC_CMD_TX_ADDR_INS_MSK  |
         ALTERA_TSEMAC_CMD_RX_ERR_DISC_MSK;  /* automatically discard frames with CRC errors */
    
   if((result & ALT_TSE_E_AN_NOT_COMPLETE) == 0) 
    11f0:	e0bffb17 	ldw	r2,-20(fp)
    11f4:	1080022c 	andhi	r2,r2,8
    11f8:	1000461e 	bne	r2,zero,1314 <tse_mac_init+0x69c>
      {
	  speed = (result >> 1) & 0x07;
    11fc:	e0bffb17 	ldw	r2,-20(fp)
    1200:	1005d07a 	srai	r2,r2,1
    1204:	108001cc 	andi	r2,r2,7
    1208:	e0bffc15 	stw	r2,-16(fp)
	  duplex = result & 0x01;
    120c:	e0bffb17 	ldw	r2,-20(fp)
    1210:	1080004c 	andi	r2,r2,1
    1214:	e0bff415 	stw	r2,-48(fp)
  
      /* 1000 Mbps */
      if(speed == 0x01)
    1218:	e0bffc17 	ldw	r2,-16(fp)
    121c:	10800058 	cmpnei	r2,r2,1
    1220:	1000121e 	bne	r2,zero,126c <tse_mac_init+0x5f4>
         {
         dat |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
    1224:	e0bff317 	ldw	r2,-52(fp)
    1228:	10800214 	ori	r2,r2,8
    122c:	e0bff315 	stw	r2,-52(fp)
         dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
    1230:	e0fff317 	ldw	r3,-52(fp)
    1234:	00bf8034 	movhi	r2,65024
    1238:	10bfffc4 	addi	r2,r2,-1
    123c:	1884703a 	and	r2,r3,r2
    1240:	e0bff315 	stw	r2,-52(fp)
         tse[iface].ethernetif->link_speed = 1000;
    1244:	00c00134 	movhi	r3,4
    1248:	18cd5504 	addi	r3,r3,13652
    124c:	e0bffe17 	ldw	r2,-8(fp)
    1250:	1004917a 	slli	r2,r2,5
    1254:	1885883a 	add	r2,r3,r2
    1258:	10800604 	addi	r2,r2,24
    125c:	10800017 	ldw	r2,0(r2)
    1260:	00c0fa04 	movi	r3,1000
    1264:	10c00315 	stw	r3,12(r2)
    1268:	00003306 	br	1338 <tse_mac_init+0x6c0>
         }
      /* 100 Mbps */
      else if(speed == 0x02)
    126c:	e0bffc17 	ldw	r2,-16(fp)
    1270:	10800098 	cmpnei	r2,r2,2
    1274:	1000131e 	bne	r2,zero,12c4 <tse_mac_init+0x64c>
         {
         dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
    1278:	e0fff317 	ldw	r3,-52(fp)
    127c:	00bffdc4 	movi	r2,-9
    1280:	1884703a 	and	r2,r3,r2
    1284:	e0bff315 	stw	r2,-52(fp)
         dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
    1288:	e0fff317 	ldw	r3,-52(fp)
    128c:	00bf8034 	movhi	r2,65024
    1290:	10bfffc4 	addi	r2,r2,-1
    1294:	1884703a 	and	r2,r3,r2
    1298:	e0bff315 	stw	r2,-52(fp)
         tse[iface].ethernetif->link_speed = 100;
    129c:	00c00134 	movhi	r3,4
    12a0:	18cd5504 	addi	r3,r3,13652
    12a4:	e0bffe17 	ldw	r2,-8(fp)
    12a8:	1004917a 	slli	r2,r2,5
    12ac:	1885883a 	add	r2,r3,r2
    12b0:	10800604 	addi	r2,r2,24
    12b4:	10800017 	ldw	r2,0(r2)
    12b8:	00c01904 	movi	r3,100
    12bc:	10c00315 	stw	r3,12(r2)
    12c0:	00001d06 	br	1338 <tse_mac_init+0x6c0>
         }
      /* 10 Mbps */
      else if(speed == 0x04)
    12c4:	e0bffc17 	ldw	r2,-16(fp)
    12c8:	10800118 	cmpnei	r2,r2,4
    12cc:	10001a1e 	bne	r2,zero,1338 <tse_mac_init+0x6c0>
         {
         dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
    12d0:	e0fff317 	ldw	r3,-52(fp)
    12d4:	00bffdc4 	movi	r2,-9
    12d8:	1884703a 	and	r2,r3,r2
    12dc:	e0bff315 	stw	r2,-52(fp)
         dat |= ALTERA_TSEMAC_CMD_ENA_10_MSK;
    12e0:	e0bff317 	ldw	r2,-52(fp)
    12e4:	10808034 	orhi	r2,r2,512
    12e8:	e0bff315 	stw	r2,-52(fp)
         tse[iface].ethernetif->link_speed = 10;
    12ec:	00c00134 	movhi	r3,4
    12f0:	18cd5504 	addi	r3,r3,13652
    12f4:	e0bffe17 	ldw	r2,-8(fp)
    12f8:	1004917a 	slli	r2,r2,5
    12fc:	1885883a 	add	r2,r3,r2
    1300:	10800604 	addi	r2,r2,24
    1304:	10800017 	ldw	r2,0(r2)
    1308:	00c00284 	movi	r3,10
    130c:	10c00315 	stw	r3,12(r2)
    1310:	00000906 	br	1338 <tse_mac_init+0x6c0>
         }
      }
   /* default to 100 Mbps if returned invalid speed */
   else
      {
      dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
    1314:	e0fff317 	ldw	r3,-52(fp)
    1318:	00bffdc4 	movi	r2,-9
    131c:	1884703a 	and	r2,r3,r2
    1320:	e0bff315 	stw	r2,-52(fp)
      dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
    1324:	e0fff317 	ldw	r3,-52(fp)
    1328:	00bf8034 	movhi	r2,65024
    132c:	10bfffc4 	addi	r2,r2,-1
    1330:	1884703a 	and	r2,r3,r2
    1334:	e0bff315 	stw	r2,-52(fp)
      }
  
   /* Half Duplex */
   if(duplex == TSE_PHY_DUPLEX_HALF)
    1338:	e0bff417 	ldw	r2,-48(fp)
    133c:	10000c1e 	bne	r2,zero,1370 <tse_mac_init+0x6f8>
      {
      dat |= ALTERA_TSEMAC_CMD_HD_ENA_MSK;
    1340:	e0bff317 	ldw	r2,-52(fp)
    1344:	10810014 	ori	r2,r2,1024
    1348:	e0bff315 	stw	r2,-52(fp)
      tse[iface].ethernetif->full_duplex = 0;
    134c:	00c00134 	movhi	r3,4
    1350:	18cd5504 	addi	r3,r3,13652
    1354:	e0bffe17 	ldw	r2,-8(fp)
    1358:	1004917a 	slli	r2,r2,5
    135c:	1885883a 	add	r2,r3,r2
    1360:	10800604 	addi	r2,r2,24
    1364:	10800017 	ldw	r2,0(r2)
    1368:	10000415 	stw	zero,16(r2)
    136c:	00000d06 	br	13a4 <tse_mac_init+0x72c>
      }
   /* Full Duplex */
   else
      {
      dat &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
    1370:	e0fff317 	ldw	r3,-52(fp)
    1374:	00beffc4 	movi	r2,-1025
    1378:	1884703a 	and	r2,r3,r2
    137c:	e0bff315 	stw	r2,-52(fp)
      tse[iface].ethernetif->full_duplex = 1;
    1380:	00c00134 	movhi	r3,4
    1384:	18cd5504 	addi	r3,r3,13652
    1388:	e0bffe17 	ldw	r2,-8(fp)
    138c:	1004917a 	slli	r2,r2,5
    1390:	1885883a 	add	r2,r3,r2
    1394:	10800604 	addi	r2,r2,24
    1398:	10800017 	ldw	r2,0(r2)
    139c:	00c00044 	movi	r3,1
    13a0:	10c00415 	stw	r3,16(r2)
      }
          
   IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base, dat);
    13a4:	00c00134 	movhi	r3,4
    13a8:	18cd5504 	addi	r3,r3,13652
    13ac:	e0bffe17 	ldw	r2,-8(fp)
    13b0:	1004917a 	slli	r2,r2,5
    13b4:	1885883a 	add	r2,r3,r2
    13b8:	10800017 	ldw	r2,0(r2)
    13bc:	10800204 	addi	r2,r2,8
    13c0:	e0fff317 	ldw	r3,-52(fp)
    13c4:	10c00035 	stwio	r3,0(r2)
   dprintf(("\nMAC post-initialization: CMD_CONFIG=0x%08x\n", 
    13c8:	00c00134 	movhi	r3,4
    13cc:	18cd5504 	addi	r3,r3,13652
    13d0:	e0bffe17 	ldw	r2,-8(fp)
    13d4:	1004917a 	slli	r2,r2,5
    13d8:	1885883a 	add	r2,r3,r2
    13dc:	10800017 	ldw	r2,0(r2)
    13e0:	10800204 	addi	r2,r2,8
    13e4:	10800037 	ldwio	r2,0(r2)
    13e8:	1009883a 	mov	r4,r2
    13ec:	00166c00 	call	166c0 <printf>
    IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base)));
  
  
                                
   alt_avalon_sgdma_register_callback(tse[iface].mi.rx_sgdma,
    13f0:	00c00134 	movhi	r3,4
    13f4:	18cd5504 	addi	r3,r3,13652
    13f8:	e0bffe17 	ldw	r2,-8(fp)
    13fc:	1004917a 	slli	r2,r2,5
    1400:	1885883a 	add	r2,r3,r2
    1404:	10800204 	addi	r2,r2,8
    1408:	10c00017 	ldw	r3,0(r2)
#ifndef ALTERA_TSE_IRQ_R
        (alt_avalon_sgdma_callback)&tse_sgdmaRx_isr,
#else
        (alt_avalon_sgdma_callback)&ALTERA_TSE_IRQ_R,
#endif
        (alt_u16)ALTERA_TSE_SGDMA_INTR_MASK,(void*)(&tse[iface]));
    140c:	e0bffe17 	ldw	r2,-8(fp)
    1410:	1008917a 	slli	r4,r2,5
    1414:	00800134 	movhi	r2,4
    1418:	108d5504 	addi	r2,r2,13652
    141c:	2085883a 	add	r2,r4,r2
   dprintf(("\nMAC post-initialization: CMD_CONFIG=0x%08x\n", 
    IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base)));
  
  
                                
   alt_avalon_sgdma_register_callback(tse[iface].mi.rx_sgdma,
    1420:	1809883a 	mov	r4,r3
    1424:	01400034 	movhi	r5,0
    1428:	29455f04 	addi	r5,r5,5500
    142c:	01800604 	movi	r6,24
    1430:	100f883a 	mov	r7,r2
    1434:	00246c40 	call	246c4 <alt_avalon_sgdma_register_callback>
#else
        (alt_avalon_sgdma_callback)&ALTERA_TSE_IRQ_R,
#endif
        (alt_u16)ALTERA_TSE_SGDMA_INTR_MASK,(void*)(&tse[iface]));
    
   tse_sgdma_read_init(&tse[iface]);
    1438:	e0bffe17 	ldw	r2,-8(fp)
    143c:	1006917a 	slli	r3,r2,5
    1440:	00800134 	movhi	r2,4
    1444:	108d5504 	addi	r2,r2,13652
    1448:	1885883a 	add	r2,r3,r2
    144c:	1009883a 	mov	r4,r2
    1450:	00014cc0 	call	14cc <tse_sgdma_read_init>
   pmac_info = alt_tse_get_mac_info(mi_base);
    1454:	e13ffa17 	ldw	r4,-24(fp)
    1458:	00262380 	call	26238 <alt_tse_get_mac_info>
    145c:	e0bffd15 	stw	r2,-12(fp)
   alt_tse_phy_wr_mdio_addr(pmac_info->pphy_info, pmac_info->pphy_info->mdio_address);
    1460:	e0bffd17 	ldw	r2,-12(fp)
    1464:	10c00117 	ldw	r3,4(r2)
    1468:	e0bffd17 	ldw	r2,-12(fp)
    146c:	10800117 	ldw	r2,4(r2)
    1470:	10800003 	ldbu	r2,0(r2)
    1474:	10803fcc 	andi	r2,r2,255
    1478:	1809883a 	mov	r4,r3
    147c:	100b883a 	mov	r5,r2
    1480:	0026f380 	call	26f38 <alt_tse_phy_wr_mdio_addr>
   ethernetif->link_alive = alt_tse_phy_rd_mdio_reg(pmac_info->pphy_info, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) != 0;
    1484:	e0bffd17 	ldw	r2,-12(fp)
    1488:	10800117 	ldw	r2,4(r2)
    148c:	1009883a 	mov	r4,r2
    1490:	01400044 	movi	r5,1
    1494:	01800144 	movi	r6,5
    1498:	01c00044 	movi	r7,1
    149c:	00270bc0 	call	270bc <alt_tse_phy_rd_mdio_reg>
    14a0:	1004c03a 	cmpne	r2,r2,zero
    14a4:	10c03fcc 	andi	r3,r2,255
    14a8:	e0bfff17 	ldw	r2,-4(fp)
    14ac:	10c00215 	stw	r3,8(r2)
   return ethernetif->link_alive;
    14b0:	e0bfff17 	ldw	r2,-4(fp)
    14b4:	10800217 	ldw	r2,8(r2)
}
    14b8:	e037883a 	mov	sp,fp
    14bc:	dfc00117 	ldw	ra,4(sp)
    14c0:	df000017 	ldw	fp,0(sp)
    14c4:	dec00204 	addi	sp,sp,8
    14c8:	f800283a 	ret

000014cc <tse_sgdma_read_init>:
 * 
 * @API TYPE - Internal
 * @return SUCCESS on success 
 */
int tse_sgdma_read_init(lwip_tse_info* tse_ptr)
{     
    14cc:	defffb04 	addi	sp,sp,-20
    14d0:	dfc00415 	stw	ra,16(sp)
    14d4:	df000315 	stw	fp,12(sp)
    14d8:	df000304 	addi	fp,sp,12
    14dc:	e13fff15 	stw	r4,-4(fp)
   struct ethernetif *ethernetif;
  
   ethernetif = tse_ptr->ethernetif;
    14e0:	e0bfff17 	ldw	r2,-4(fp)
    14e4:	10800617 	ldw	r2,24(r2)
    14e8:	e0bffe15 	stw	r2,-8(fp)
  
   alt_avalon_sgdma_construct_stream_to_mem_desc(
         (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],  // descriptor I want to work with
    14ec:	e0bfff17 	ldw	r2,-4(fp)
    14f0:	10800517 	ldw	r2,20(r2)
{     
   struct ethernetif *ethernetif;
  
   ethernetif = tse_ptr->ethernetif;
  
   alt_avalon_sgdma_construct_stream_to_mem_desc(
    14f4:	11001004 	addi	r4,r2,64
         (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],  // descriptor I want to work with
         (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_RX_SGDMA_DESC_OFST],  // pointer to "next"
    14f8:	e0bfff17 	ldw	r2,-4(fp)
    14fc:	10800517 	ldw	r2,20(r2)
{     
   struct ethernetif *ethernetif;
  
   ethernetif = tse_ptr->ethernetif;
  
   alt_avalon_sgdma_construct_stream_to_mem_desc(
    1500:	10c01804 	addi	r3,r2,96
         (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],  // descriptor I want to work with
         (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_RX_SGDMA_DESC_OFST],  // pointer to "next"
         (alt_u32 *) ethernetif->lwipRxPbuf[tse_ptr->ethernetif->lwipRxIndexIsr]->payload,          // starting write_address
    1504:	e0bfff17 	ldw	r2,-4(fp)
    1508:	10800617 	ldw	r2,24(r2)
    150c:	10801317 	ldw	r2,76(r2)
    1510:	e17ffe17 	ldw	r5,-8(fp)
    1514:	108001c4 	addi	r2,r2,7
    1518:	1085883a 	add	r2,r2,r2
    151c:	1085883a 	add	r2,r2,r2
    1520:	2885883a 	add	r2,r5,r2
    1524:	10800017 	ldw	r2,0(r2)
    1528:	10800117 	ldw	r2,4(r2)
{     
   struct ethernetif *ethernetif;
  
   ethernetif = tse_ptr->ethernetif;
  
   alt_avalon_sgdma_construct_stream_to_mem_desc(
    152c:	d8000015 	stw	zero,0(sp)
    1530:	180b883a 	mov	r5,r3
    1534:	100d883a 	mov	r6,r2
    1538:	000f883a 	mov	r7,zero
    153c:	00244f00 	call	244f0 <alt_avalon_sgdma_construct_stream_to_mem_desc>
         (alt_u32 *) ethernetif->lwipRxPbuf[tse_ptr->ethernetif->lwipRxIndexIsr]->payload,          // starting write_address
         0,                                  // read until EOP
         0);          // don't write to constant address


   dprintf(("[tse_sgdma_read_init] RX descriptor chain desc (%d depth) created\n",0)); 
    1540:	0009883a 	mov	r4,zero
    1544:	00166c00 	call	166c0 <printf>
   
   tse_mac_aRxRead( &tse_ptr->mi, &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
    1548:	e0ffff17 	ldw	r3,-4(fp)
    154c:	e0bfff17 	ldw	r2,-4(fp)
    1550:	10800517 	ldw	r2,20(r2)
    1554:	10801004 	addi	r2,r2,64
    1558:	1809883a 	mov	r4,r3
    155c:	100b883a 	mov	r5,r2
    1560:	002513c0 	call	2513c <tse_mac_aRxRead>
  
   return SUCCESS;
    1564:	0005883a 	mov	r2,zero
}
    1568:	e037883a 	mov	sp,fp
    156c:	dfc00117 	ldw	ra,4(sp)
    1570:	df000017 	ldw	fp,0(sp)
    1574:	dec00204 	addi	sp,sp,8
    1578:	f800283a 	ret

0000157c <tse_sgdmaRx_isr>:
 * @API TYPE - callback
 * @param  context  - context of the TSE MAC instance
 * @param  intnum - temporary storage
 */
int tse_sgdmaRx_isr(void * context, u_long intnum)
{
    157c:	defffb04 	addi	sp,sp,-20
    1580:	dfc00415 	stw	ra,16(sp)
    1584:	df000315 	stw	fp,12(sp)
    1588:	df000304 	addi	fp,sp,12
    158c:	e13ffe15 	stw	r4,-8(fp)
    1590:	e17fff15 	stw	r5,-4(fp)
   lwip_tse_info* tse_ptr = (lwip_tse_info *) context;
    1594:	e0bffe17 	ldw	r2,-8(fp)
    1598:	e0bffd15 	stw	r2,-12(fp)

   IOWR_ALTERA_AVALON_SGDMA_CONTROL(&tse_ptr->mi.rx_sgdma->base,ALTERA_AVALON_SGDMA_CONTROL_CLEAR_INTERRUPT_MSK);
    159c:	e0bffd17 	ldw	r2,-12(fp)
    15a0:	10800217 	ldw	r2,8(r2)
    15a4:	10800304 	addi	r2,r2,12
    15a8:	10800404 	addi	r2,r2,16
    15ac:	00e00034 	movhi	r3,32768
    15b0:	10c00035 	stwio	r3,0(r2)
   tse_mac_rcv(tse_ptr->ethernetif);    
    15b4:	e0bffd17 	ldw	r2,-12(fp)
    15b8:	10800617 	ldw	r2,24(r2)
    15bc:	1009883a 	mov	r4,r2
    15c0:	00017800 	call	1780 <tse_mac_rcv>
   tse_mac_aRxRead( &tse_ptr->mi, &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
    15c4:	e0fffd17 	ldw	r3,-12(fp)
    15c8:	e0bffd17 	ldw	r2,-12(fp)
    15cc:	10800517 	ldw	r2,20(r2)
    15d0:	10801004 	addi	r2,r2,64
    15d4:	1809883a 	mov	r4,r3
    15d8:	100b883a 	mov	r5,r2
    15dc:	002513c0 	call	2513c <tse_mac_aRxRead>
   IOWR_ALTERA_AVALON_SGDMA_CONTROL(&tse_ptr->mi.rx_sgdma->base, ALTERA_TSE_SGDMA_INTR_MASK);
    15e0:	e0bffd17 	ldw	r2,-12(fp)
    15e4:	10800217 	ldw	r2,8(r2)
    15e8:	10800304 	addi	r2,r2,12
    15ec:	10800404 	addi	r2,r2,16
    15f0:	00c00604 	movi	r3,24
    15f4:	10c00035 	stwio	r3,0(r2)
  
   return SUCCESS;
    15f8:	0005883a 	mov	r2,zero
}
    15fc:	e037883a 	mov	sp,fp
    1600:	dfc00117 	ldw	ra,4(sp)
    1604:	df000017 	ldw	fp,0(sp)
    1608:	dec00204 	addi	sp,sp,8
    160c:	f800283a 	ret

00001610 <tse_mac_raw_send>:
 * @param  data_bytes - number of bytes of the data payload to be sent to the MAC
 * @return SUCCESS if success, else a negative value
 */

err_t tse_mac_raw_send(struct netif *netif, struct pbuf *pkt)
{
    1610:	defe6a04 	addi	sp,sp,-1624
    1614:	dfc19515 	stw	ra,1620(sp)
    1618:	df019415 	stw	fp,1616(sp)
    161c:	df019404 	addi	fp,sp,1616
    1620:	e13ffe15 	stw	r4,-8(fp)
    1624:	e17fff15 	stw	r5,-4(fp)
   unsigned int       *ActualData;

   /* Intermediate buffers used for temporary copy of frames that cannot be directrly DMA'ed*/
   char buf2[1560];

   ethernetif = netif->state;
    1628:	e0bffe17 	ldw	r2,-8(fp)
    162c:	10800717 	ldw	r2,28(r2)
    1630:	e0be7215 	stw	r2,-1592(fp)
   tse_ptr = ethernetif->tse_info;
    1634:	e0be7217 	ldw	r2,-1592(fp)
    1638:	10801617 	ldw	r2,88(r2)
    163c:	e0be7315 	stw	r2,-1588(fp)
   mi = &tse_ptr->mi;
    1640:	e0be7317 	ldw	r2,-1588(fp)
    1644:	e0be7415 	stw	r2,-1584(fp)
  
   for(p = pkt; p != NULL; p = p->next)
    1648:	e0bfff17 	ldw	r2,-4(fp)
    164c:	e0be7015 	stw	r2,-1600(fp)
    1650:	00003b06 	br	1740 <tse_mac_raw_send+0x130>
      {
      data = p->payload;
    1654:	e0be7017 	ldw	r2,-1600(fp)
    1658:	10800117 	ldw	r2,4(r2)
    165c:	e0be7115 	stw	r2,-1596(fp)
      len = p->len;
    1660:	e0be7017 	ldw	r2,-1600(fp)
    1664:	1080028b 	ldhu	r2,10(r2)
    1668:	10bfffcc 	andi	r2,r2,65535
    166c:	e0be7515 	stw	r2,-1580(fp)
       
      if(((unsigned long)data & 0x03) != 0) 
    1670:	e0be7117 	ldw	r2,-1596(fp)
    1674:	108000cc 	andi	r2,r2,3
    1678:	10000726 	beq	r2,zero,1698 <tse_mac_raw_send+0x88>
         /* 
          * Copy data to temporary buffer <buf2>. This is done because of allignment 
          * issues. The SGDMA cannot copy the data directly from (data + ETH_PAD_SIZE)
          * because it needs a 32-bit alligned address space. 
          */
         memcpy(buf2,data,len);
    167c:	e0be7804 	addi	r2,fp,-1568
    1680:	1009883a 	mov	r4,r2
    1684:	e17e7117 	ldw	r5,-1596(fp)
    1688:	e1be7517 	ldw	r6,-1580(fp)
    168c:	00164c00 	call	164c0 <memcpy>
         data = (alt_u32 *)buf2;
    1690:	e0be7804 	addi	r2,fp,-1568
    1694:	e0be7115 	stw	r2,-1596(fp)
         }  
       
      ActualData = (void *)alt_remap_uncached (data, len);
    1698:	e13e7117 	ldw	r4,-1596(fp)
    169c:	e17e7517 	ldw	r5,-1580(fp)
    16a0:	00204b40 	call	204b4 <alt_remap_uncached>
    16a4:	e0be7615 	stw	r2,-1576(fp)
      /* Write data to Tx FIFO using the DMA */
      alt_avalon_sgdma_construct_mem_to_stream_desc(
           (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_TX_SGDMA_DESC_OFST], // descriptor I want to work with
    16a8:	e0be7317 	ldw	r2,-1588(fp)
         data = (alt_u32 *)buf2;
         }  
       
      ActualData = (void *)alt_remap_uncached (data, len);
      /* Write data to Tx FIFO using the DMA */
      alt_avalon_sgdma_construct_mem_to_stream_desc(
    16ac:	11000517 	ldw	r4,20(r2)
           (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_TX_SGDMA_DESC_OFST], // descriptor I want to work with
           (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_TX_SGDMA_DESC_OFST],// pointer to "next"
    16b0:	e0be7317 	ldw	r2,-1588(fp)
    16b4:	10800517 	ldw	r2,20(r2)
         data = (alt_u32 *)buf2;
         }  
       
      ActualData = (void *)alt_remap_uncached (data, len);
      /* Write data to Tx FIFO using the DMA */
      alt_avalon_sgdma_construct_mem_to_stream_desc(
    16b8:	10c00804 	addi	r3,r2,32
    16bc:	e0be7517 	ldw	r2,-1580(fp)
    16c0:	10bfffcc 	andi	r2,r2,65535
    16c4:	e1be7017 	ldw	r6,-1600(fp)
    16c8:	e17fff17 	ldw	r5,-4(fp)
    16cc:	314b003a 	cmpeq	r5,r6,r5
    16d0:	29803fcc 	andi	r6,r5,255
           (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_TX_SGDMA_DESC_OFST],// pointer to "next"
           (alt_u32*)ActualData,                    // starting read address
           (len),                                   // # bytes
           0,                                       // don't read from constant address
           p == pkt,                                // generate sop
           p->next == NULL,                         // generate endofpacket signal
    16d4:	e17e7017 	ldw	r5,-1600(fp)
    16d8:	29400017 	ldw	r5,0(r5)
         data = (alt_u32 *)buf2;
         }  
       
      ActualData = (void *)alt_remap_uncached (data, len);
      /* Write data to Tx FIFO using the DMA */
      alt_avalon_sgdma_construct_mem_to_stream_desc(
    16dc:	280b003a 	cmpeq	r5,r5,zero
    16e0:	29403fcc 	andi	r5,r5,255
    16e4:	d8000015 	stw	zero,0(sp)
    16e8:	d9800115 	stw	r6,4(sp)
    16ec:	d9400215 	stw	r5,8(sp)
    16f0:	d8000315 	stw	zero,12(sp)
    16f4:	180b883a 	mov	r5,r3
    16f8:	e1be7617 	ldw	r6,-1576(fp)
    16fc:	100f883a 	mov	r7,r2
    1700:	00245c00 	call	245c0 <alt_avalon_sgdma_construct_mem_to_stream_desc>
           0,                                       // don't read from constant address
           p == pkt,                                // generate sop
           p->next == NULL,                         // generate endofpacket signal
           0);                                      // atlantic channel (don't know/don't care: set to 0)
                  
      tx_length = tse_mac_sTxWrite(mi,&tse_ptr->desc[ALTERA_TSE_FIRST_TX_SGDMA_DESC_OFST]);
    1704:	e0be7317 	ldw	r2,-1588(fp)
    1708:	10800517 	ldw	r2,20(r2)
    170c:	e13e7417 	ldw	r4,-1584(fp)
    1710:	100b883a 	mov	r5,r2
    1714:	002505c0 	call	2505c <tse_mac_sTxWrite>
    1718:	e0be7715 	stw	r2,-1572(fp)
      ethernetif->bytes_sent += tx_length;
    171c:	e0be7217 	ldw	r2,-1592(fp)
    1720:	10c00517 	ldw	r3,20(r2)
    1724:	e0be7717 	ldw	r2,-1572(fp)
    1728:	1887883a 	add	r3,r3,r2
    172c:	e0be7217 	ldw	r2,-1592(fp)
    1730:	10c00515 	stw	r3,20(r2)

   ethernetif = netif->state;
   tse_ptr = ethernetif->tse_info;
   mi = &tse_ptr->mi;
  
   for(p = pkt; p != NULL; p = p->next)
    1734:	e0be7017 	ldw	r2,-1600(fp)
    1738:	10800017 	ldw	r2,0(r2)
    173c:	e0be7015 	stw	r2,-1600(fp)
    1740:	e0be7017 	ldw	r2,-1600(fp)
    1744:	103fc31e 	bne	r2,zero,1654 <tse_mac_raw_send+0x44>
           0);                                      // atlantic channel (don't know/don't care: set to 0)
                  
      tx_length = tse_mac_sTxWrite(mi,&tse_ptr->desc[ALTERA_TSE_FIRST_TX_SGDMA_DESC_OFST]);
      ethernetif->bytes_sent += tx_length;
      }
   LINK_STATS_INC(link.xmit);
    1748:	00800134 	movhi	r2,4
    174c:	108d9504 	addi	r2,r2,13908
    1750:	1080000b 	ldhu	r2,0(r2)
    1754:	10800044 	addi	r2,r2,1
    1758:	1007883a 	mov	r3,r2
    175c:	00800134 	movhi	r2,4
    1760:	108d9504 	addi	r2,r2,13908
    1764:	10c0000d 	sth	r3,0(r2)
   return ERR_OK;
    1768:	0005883a 	mov	r2,zero
}
    176c:	e037883a 	mov	sp,fp
    1770:	dfc00117 	ldw	ra,4(sp)
    1774:	df000017 	ldw	fp,0(sp)
    1778:	dec00204 	addi	sp,sp,8
    177c:	f800283a 	ret

00001780 <tse_mac_rcv>:
 * 
 * @API TYPE        - callback internal function
 * @return SUCCESS on success
 */
int tse_mac_rcv(struct ethernetif *ethernetif)
{     
    1780:	defff804 	addi	sp,sp,-32
    1784:	dfc00715 	stw	ra,28(sp)
    1788:	df000615 	stw	fp,24(sp)
    178c:	df000604 	addi	fp,sp,24
    1790:	e13fff15 	stw	r4,-4(fp)
   int pklen;
   lwip_tse_info* tse_ptr;
   alt_u32 *uncached_packet_payload;
   struct pbuf *p;
  
   tse_ptr = ethernetif->tse_info;
    1794:	e0bfff17 	ldw	r2,-4(fp)
    1798:	10801617 	ldw	r2,88(r2)
    179c:	e0bffb15 	stw	r2,-20(fp)
   pklen = IORD_16DIRECT(&(tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST].actual_bytes_transferred),0);
    17a0:	e0bffb17 	ldw	r2,-20(fp)
    17a4:	10800517 	ldw	r2,20(r2)
    17a8:	10801004 	addi	r2,r2,64
    17ac:	10800704 	addi	r2,r2,28
    17b0:	1080002b 	ldhuio	r2,0(r2)
    17b4:	10bfffcc 	andi	r2,r2,65535
    17b8:	e0bffc15 	stw	r2,-16(fp)
   p = ethernetif->lwipRxPbuf[ethernetif->lwipRxIndexIsr];
    17bc:	e0bfff17 	ldw	r2,-4(fp)
    17c0:	10801317 	ldw	r2,76(r2)
    17c4:	e0ffff17 	ldw	r3,-4(fp)
    17c8:	108001c4 	addi	r2,r2,7
    17cc:	1085883a 	add	r2,r2,r2
    17d0:	1085883a 	add	r2,r2,r2
    17d4:	1885883a 	add	r2,r3,r2
    17d8:	10800017 	ldw	r2,0(r2)
    17dc:	e0bffd15 	stw	r2,-12(fp)
   p->tot_len = pklen;
    17e0:	e0bffc17 	ldw	r2,-16(fp)
    17e4:	1007883a 	mov	r3,r2
    17e8:	e0bffd17 	ldw	r2,-12(fp)
    17ec:	10c0020d 	sth	r3,8(r2)
   p->len = pklen;
    17f0:	e0bffc17 	ldw	r2,-16(fp)
    17f4:	1007883a 	mov	r3,r2
    17f8:	e0bffd17 	ldw	r2,-12(fp)
    17fc:	10c0028d 	sth	r3,10(r2)
   if ((IORD_ALTERA_TSE_SGDMA_DESC_STATUS(&tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]) & ( ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_CRC_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_PARITY_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_OVERFLOW_MSK |ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK )) == 0)
    1800:	e0bffb17 	ldw	r2,-20(fp)
    1804:	10800517 	ldw	r2,20(r2)
    1808:	10801704 	addi	r2,r2,92
    180c:	10800037 	ldwio	r2,0(r2)
    1810:	1005d43a 	srai	r2,r2,16
    1814:	10801fcc 	andi	r2,r2,127
    1818:	1000261e 	bne	r2,zero,18b4 <tse_mac_rcv+0x134>
      {
      if( ethernetif->lwipRxCount > LWIP_RX_ETH_BUFFER )
    181c:	e0bfff17 	ldw	r2,-4(fp)
    1820:	10801517 	ldw	r2,84(r2)
    1824:	10800350 	cmplti	r2,r2,13
    1828:	10000c1e 	bne	r2,zero,185c <tse_mac_rcv+0xdc>
         {    
         LINK_STATS_INC(link.drop);
    182c:	00800134 	movhi	r2,4
    1830:	108d9504 	addi	r2,r2,13908
    1834:	1080018b 	ldhu	r2,6(r2)
    1838:	10800044 	addi	r2,r2,1
    183c:	1007883a 	mov	r3,r2
    1840:	00800134 	movhi	r2,4
    1844:	108d9504 	addi	r2,r2,13908
    1848:	10c0018d 	sth	r3,6(r2)
         dprintf(("No free buffers for rx\n"));
    184c:	010000f4 	movhi	r4,3
    1850:	2134e404 	addi	r4,r4,-11376
    1854:	00169500 	call	16950 <puts>
    1858:	00001606 	br	18b4 <tse_mac_rcv+0x134>
         }
      else 
         {
         ethernetif->bytes_recv += pklen;
    185c:	e0bfff17 	ldw	r2,-4(fp)
    1860:	10c00617 	ldw	r3,24(r2)
    1864:	e0bffc17 	ldw	r2,-16(fp)
    1868:	1887883a 	add	r3,r3,r2
    186c:	e0bfff17 	ldw	r2,-4(fp)
    1870:	10c00615 	stw	r3,24(r2)
         //  Set up DMA for the next pbuf in the buffer
         ++ethernetif->lwipRxCount;
    1874:	e0bfff17 	ldw	r2,-4(fp)
    1878:	10801517 	ldw	r2,84(r2)
    187c:	10c00044 	addi	r3,r2,1
    1880:	e0bfff17 	ldw	r2,-4(fp)
    1884:	10c01515 	stw	r3,84(r2)
         if( ++ethernetif->lwipRxIndexIsr >= LWIP_RX_ETH_BUFFER )
    1888:	e0bfff17 	ldw	r2,-4(fp)
    188c:	10801317 	ldw	r2,76(r2)
    1890:	10c00044 	addi	r3,r2,1
    1894:	e0bfff17 	ldw	r2,-4(fp)
    1898:	10c01315 	stw	r3,76(r2)
    189c:	e0bfff17 	ldw	r2,-4(fp)
    18a0:	10801317 	ldw	r2,76(r2)
    18a4:	10800310 	cmplti	r2,r2,12
    18a8:	1000021e 	bne	r2,zero,18b4 <tse_mac_rcv+0x134>
            ethernetif->lwipRxIndexIsr = 0;
    18ac:	e0bfff17 	ldw	r2,-4(fp)
    18b0:	10001315 	stw	zero,76(r2)
         }
      }      

   uncached_packet_payload = (alt_u32 *) ethernetif->lwipRxPbuf[ethernetif->lwipRxIndexIsr]->payload;
    18b4:	e0bfff17 	ldw	r2,-4(fp)
    18b8:	10801317 	ldw	r2,76(r2)
    18bc:	e0ffff17 	ldw	r3,-4(fp)
    18c0:	108001c4 	addi	r2,r2,7
    18c4:	1085883a 	add	r2,r2,r2
    18c8:	1085883a 	add	r2,r2,r2
    18cc:	1885883a 	add	r2,r3,r2
    18d0:	10800017 	ldw	r2,0(r2)
    18d4:	10800117 	ldw	r2,4(r2)
    18d8:	e0bffe15 	stw	r2,-8(fp)
   alt_avalon_sgdma_construct_stream_to_mem_desc(
         (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],  // descriptor I want to work with
    18dc:	e0bffb17 	ldw	r2,-20(fp)
    18e0:	10800517 	ldw	r2,20(r2)
            ethernetif->lwipRxIndexIsr = 0;
         }
      }      

   uncached_packet_payload = (alt_u32 *) ethernetif->lwipRxPbuf[ethernetif->lwipRxIndexIsr]->payload;
   alt_avalon_sgdma_construct_stream_to_mem_desc(
    18e4:	10c01004 	addi	r3,r2,64
         (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],  // descriptor I want to work with
         (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_RX_SGDMA_DESC_OFST],  // pointer to "next"
    18e8:	e0bffb17 	ldw	r2,-20(fp)
    18ec:	10800517 	ldw	r2,20(r2)
            ethernetif->lwipRxIndexIsr = 0;
         }
      }      

   uncached_packet_payload = (alt_u32 *) ethernetif->lwipRxPbuf[ethernetif->lwipRxIndexIsr]->payload;
   alt_avalon_sgdma_construct_stream_to_mem_desc(
    18f0:	10801804 	addi	r2,r2,96
    18f4:	d8000015 	stw	zero,0(sp)
    18f8:	1809883a 	mov	r4,r3
    18fc:	100b883a 	mov	r5,r2
    1900:	e1bffe17 	ldw	r6,-8(fp)
    1904:	000f883a 	mov	r7,zero
    1908:	00244f00 	call	244f0 <alt_avalon_sgdma_construct_stream_to_mem_desc>
         (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_RX_SGDMA_DESC_OFST],  // pointer to "next"
         uncached_packet_payload,            // starting write_address
         0,                                  // read until EOP
         0);          // don't write to constant address

   return ERR_OK;
    190c:	0005883a 	mov	r2,zero
}
    1910:	e037883a 	mov	sp,fp
    1914:	dfc00117 	ldw	ra,4(sp)
    1918:	df000017 	ldw	fp,0(sp)
    191c:	dec00204 	addi	sp,sp,8
    1920:	f800283a 	ret

00001924 <lwip_strerr>:
 * @param err an lwip internal err_t
 * @return a string representation for err
 */
const char *
lwip_strerr(err_t err)
{
    1924:	defffe04 	addi	sp,sp,-8
    1928:	df000115 	stw	fp,4(sp)
    192c:	df000104 	addi	fp,sp,4
    1930:	2005883a 	mov	r2,r4
    1934:	e0bfff05 	stb	r2,-4(fp)
  return err_strerr[-err];
    1938:	e0bfff07 	ldb	r2,-4(fp)
    193c:	0085c83a 	sub	r2,zero,r2
    1940:	00c000f4 	movhi	r3,3
    1944:	18c49604 	addi	r3,r3,4696
    1948:	1085883a 	add	r2,r2,r2
    194c:	1085883a 	add	r2,r2,r2
    1950:	1885883a 	add	r2,r3,r2
    1954:	10800017 	ldw	r2,0(r2)

}
    1958:	e037883a 	mov	sp,fp
    195c:	df000017 	ldw	fp,0(sp)
    1960:	dec00104 	addi	sp,sp,4
    1964:	f800283a 	ret

00001968 <dhcp_handle_nak>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_nak(struct netif *netif)
{
    1968:	defffc04 	addi	sp,sp,-16
    196c:	dfc00315 	stw	ra,12(sp)
    1970:	df000215 	stw	fp,8(sp)
    1974:	df000204 	addi	fp,sp,8
    1978:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    197c:	e0bfff17 	ldw	r2,-4(fp)
    1980:	10800817 	ldw	r2,32(r2)
    1984:	e0bffe15 	stw	r2,-8(fp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n", 
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Set the interface down since the address must no longer be used, as per RFC2131 */
  netif_set_down(netif);
    1988:	e13fff17 	ldw	r4,-4(fp)
    198c:	000972c0 	call	972c <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
    1990:	e13fff17 	ldw	r4,-4(fp)
    1994:	014000f4 	movhi	r5,3
    1998:	294d2104 	addi	r5,r5,13444
    199c:	00094900 	call	9490 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
    19a0:	e13fff17 	ldw	r4,-4(fp)
    19a4:	014000f4 	movhi	r5,3
    19a8:	294d2104 	addi	r5,r5,13444
    19ac:	00095e80 	call	95e8 <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY); 
    19b0:	e13fff17 	ldw	r4,-4(fp)
    19b4:	014000f4 	movhi	r5,3
    19b8:	294d2104 	addi	r5,r5,13444
    19bc:	00096380 	call	9638 <netif_set_netmask>
  /* Change to a defined state */
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
    19c0:	e13ffe17 	ldw	r4,-8(fp)
    19c4:	01400304 	movi	r5,12
    19c8:	00039940 	call	3994 <dhcp_set_state>
  /* We can immediately restart discovery */
  dhcp_discover(netif);
    19cc:	e13fff17 	ldw	r4,-4(fp)
    19d0:	0002ca40 	call	2ca4 <dhcp_discover>
}
    19d4:	e037883a 	mov	sp,fp
    19d8:	dfc00117 	ldw	ra,4(sp)
    19dc:	df000017 	ldw	fp,0(sp)
    19e0:	dec00204 	addi	sp,sp,8
    19e4:	f800283a 	ret

000019e8 <dhcp_check>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_check(struct netif *netif)
{
    19e8:	defffb04 	addi	sp,sp,-20
    19ec:	dfc00415 	stw	ra,16(sp)
    19f0:	df000315 	stw	fp,12(sp)
    19f4:	df000304 	addi	fp,sp,12
    19f8:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    19fc:	e0bfff17 	ldw	r2,-4(fp)
    1a00:	10800817 	ldw	r2,32(r2)
    1a04:	e0bffd15 	stw	r2,-12(fp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0],
    (s16_t)netif->name[1]));
  dhcp_set_state(dhcp, DHCP_CHECKING);
    1a08:	e13ffd17 	ldw	r4,-12(fp)
    1a0c:	01400204 	movi	r5,8
    1a10:	00039940 	call	3994 <dhcp_set_state>
  /* create an ARP query for the offered IP address, expecting that no host
     responds, as the IP address should not be in use. */
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
    1a14:	e0bffd17 	ldw	r2,-12(fp)
    1a18:	10800a04 	addi	r2,r2,40
    1a1c:	e13fff17 	ldw	r4,-4(fp)
    1a20:	100b883a 	mov	r5,r2
    1a24:	000d883a 	mov	r6,zero
    1a28:	001593c0 	call	1593c <etharp_query>
    1a2c:	e0bffe05 	stb	r2,-8(fp)
  if (result != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("dhcp_check: could not perform ARP query\n"));
  }
  dhcp->tries++;
    1a30:	e0bffd17 	ldw	r2,-12(fp)
    1a34:	108004c3 	ldbu	r2,19(r2)
    1a38:	10800044 	addi	r2,r2,1
    1a3c:	1007883a 	mov	r3,r2
    1a40:	e0bffd17 	ldw	r2,-12(fp)
    1a44:	10c004c5 	stb	r3,19(r2)
  msecs = 500;
    1a48:	00807d04 	movi	r2,500
    1a4c:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    1a50:	e0bffe8b 	ldhu	r2,-6(fp)
    1a54:	10c07cc4 	addi	r3,r2,499
    1a58:	00807d04 	movi	r2,500
    1a5c:	1885283a 	div	r2,r3,r2
    1a60:	1007883a 	mov	r3,r2
    1a64:	e0bffd17 	ldw	r2,-12(fp)
    1a68:	10c0078d 	sth	r3,30(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_check(): set request timeout %"U16_F" msecs\n", msecs));
}
    1a6c:	e037883a 	mov	sp,fp
    1a70:	dfc00117 	ldw	ra,4(sp)
    1a74:	df000017 	ldw	fp,0(sp)
    1a78:	dec00204 	addi	sp,sp,8
    1a7c:	f800283a 	ret

00001a80 <dhcp_handle_offer>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_offer(struct netif *netif)
{
    1a80:	defffa04 	addi	sp,sp,-24
    1a84:	dfc00515 	stw	ra,20(sp)
    1a88:	df000415 	stw	fp,16(sp)
    1a8c:	dc000315 	stw	r16,12(sp)
    1a90:	df000304 	addi	fp,sp,12
    1a94:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    1a98:	e0bfff17 	ldw	r2,-4(fp)
    1a9c:	10800817 	ldw	r2,32(r2)
    1aa0:	e0bffd15 	stw	r2,-12(fp)
  /* obtain the server address */
  u8_t *option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SERVER_ID);
    1aa4:	e13ffd17 	ldw	r4,-12(fp)
    1aa8:	01400d84 	movi	r5,54
    1aac:	0004a740 	call	4a74 <dhcp_get_option_ptr>
    1ab0:	e0bffe15 	stw	r2,-8(fp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  if (option_ptr != NULL) {
    1ab4:	e0bffe17 	ldw	r2,-8(fp)
    1ab8:	10002b26 	beq	r2,zero,1b68 <dhcp_handle_offer+0xe8>
    dhcp->server_ip_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
    1abc:	e0bffe17 	ldw	r2,-8(fp)
    1ac0:	10800084 	addi	r2,r2,2
    1ac4:	1009883a 	mov	r4,r2
    1ac8:	0004cd00 	call	4cd0 <dhcp_get_option_long>
    1acc:	1020d63a 	srli	r16,r2,24
    1ad0:	e0bffe17 	ldw	r2,-8(fp)
    1ad4:	10800084 	addi	r2,r2,2
    1ad8:	1009883a 	mov	r4,r2
    1adc:	0004cd00 	call	4cd0 <dhcp_get_option_long>
    1ae0:	1004d23a 	srli	r2,r2,8
    1ae4:	10bfc00c 	andi	r2,r2,65280
    1ae8:	80a0b03a 	or	r16,r16,r2
    1aec:	e0bffe17 	ldw	r2,-8(fp)
    1af0:	10800084 	addi	r2,r2,2
    1af4:	1009883a 	mov	r4,r2
    1af8:	0004cd00 	call	4cd0 <dhcp_get_option_long>
    1afc:	10bfc00c 	andi	r2,r2,65280
    1b00:	1004923a 	slli	r2,r2,8
    1b04:	80a0b03a 	or	r16,r16,r2
    1b08:	e0bffe17 	ldw	r2,-8(fp)
    1b0c:	10800084 	addi	r2,r2,2
    1b10:	1009883a 	mov	r4,r2
    1b14:	0004cd00 	call	4cd0 <dhcp_get_option_long>
    1b18:	1004963a 	slli	r2,r2,24
    1b1c:	8086b03a 	or	r3,r16,r2
    1b20:	e0bffd17 	ldw	r2,-12(fp)
    1b24:	10c00915 	stw	r3,36(r2)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n", dhcp->server_ip_addr.addr));
    /* remember offered address */
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
    1b28:	e0bffd17 	ldw	r2,-12(fp)
    1b2c:	10800217 	ldw	r2,8(r2)
    1b30:	10800404 	addi	r2,r2,16
    1b34:	10000726 	beq	r2,zero,1b54 <dhcp_handle_offer+0xd4>
    1b38:	e0bffd17 	ldw	r2,-12(fp)
    1b3c:	10800217 	ldw	r2,8(r2)
    1b40:	10c0040b 	ldhu	r3,16(r2)
    1b44:	1080048b 	ldhu	r2,18(r2)
    1b48:	1004943a 	slli	r2,r2,16
    1b4c:	10c4b03a 	or	r2,r2,r3
    1b50:	00000106 	br	1b58 <dhcp_handle_offer+0xd8>
    1b54:	0005883a 	mov	r2,zero
    1b58:	e0fffd17 	ldw	r3,-12(fp)
    1b5c:	18800a15 	stw	r2,40(r3)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): offer for 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));

    dhcp_select(netif);
    1b60:	e13fff17 	ldw	r4,-4(fp)
    1b64:	0001b800 	call	1b80 <dhcp_select>
  }
}
    1b68:	e037883a 	mov	sp,fp
    1b6c:	dfc00217 	ldw	ra,8(sp)
    1b70:	df000117 	ldw	fp,4(sp)
    1b74:	dc000017 	ldw	r16,0(sp)
    1b78:	dec00304 	addi	sp,sp,12
    1b7c:	f800283a 	ret

00001b80 <dhcp_select>:
 * @param netif the netif under DHCP control
 * @return lwIP specific error (see error.h)
 */
static err_t
dhcp_select(struct netif *netif)
{
    1b80:	defffa04 	addi	sp,sp,-24
    1b84:	dfc00515 	stw	ra,20(sp)
    1b88:	df000415 	stw	fp,16(sp)
    1b8c:	df000404 	addi	fp,sp,16
    1b90:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    1b94:	e0bfff17 	ldw	r2,-4(fp)
    1b98:	10800817 	ldw	r2,32(r2)
    1b9c:	e0bffd15 	stw	r2,-12(fp)
#if LWIP_NETIF_HOSTNAME
  const char *p;
#endif /* LWIP_NETIF_HOSTNAME */

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_select(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  dhcp_set_state(dhcp, DHCP_REQUESTING);
    1ba0:	e13ffd17 	ldw	r4,-12(fp)
    1ba4:	01400044 	movi	r5,1
    1ba8:	00039940 	call	3994 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
    1bac:	e13fff17 	ldw	r4,-4(fp)
    1bb0:	00043380 	call	4338 <dhcp_create_request>
    1bb4:	e0bffe05 	stb	r2,-8(fp)
  if (result == ERR_OK) {
    1bb8:	e0bffe07 	ldb	r2,-8(fp)
    1bbc:	10006a1e 	bne	r2,zero,1d68 <dhcp_select+0x1e8>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
    1bc0:	e13ffd17 	ldw	r4,-12(fp)
    1bc4:	01400d44 	movi	r5,53
    1bc8:	01800044 	movi	r6,1
    1bcc:	00039e40 	call	39e4 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
    1bd0:	e13ffd17 	ldw	r4,-12(fp)
    1bd4:	014000c4 	movi	r5,3
    1bd8:	0003ac80 	call	3ac8 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    1bdc:	e13ffd17 	ldw	r4,-12(fp)
    1be0:	01400e44 	movi	r5,57
    1be4:	01800084 	movi	r6,2
    1be8:	00039e40 	call	39e4 <dhcp_option>
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
    1bec:	e0bfff17 	ldw	r2,-4(fp)
    1bf0:	1080090b 	ldhu	r2,36(r2)
    1bf4:	10bfffcc 	andi	r2,r2,65535
    1bf8:	e13ffd17 	ldw	r4,-12(fp)
    1bfc:	100b883a 	mov	r5,r2
    1c00:	0003b640 	call	3b64 <dhcp_option_short>

    /* MUST request the offered IP address */
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
    1c04:	e13ffd17 	ldw	r4,-12(fp)
    1c08:	01400c84 	movi	r5,50
    1c0c:	01800104 	movi	r6,4
    1c10:	00039e40 	call	39e4 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
    1c14:	e0bffd17 	ldw	r2,-12(fp)
    1c18:	10800a17 	ldw	r2,40(r2)
    1c1c:	1006d63a 	srli	r3,r2,24
    1c20:	e0bffd17 	ldw	r2,-12(fp)
    1c24:	10800a17 	ldw	r2,40(r2)
    1c28:	1004d23a 	srli	r2,r2,8
    1c2c:	10bfc00c 	andi	r2,r2,65280
    1c30:	1886b03a 	or	r3,r3,r2
    1c34:	e0bffd17 	ldw	r2,-12(fp)
    1c38:	10800a17 	ldw	r2,40(r2)
    1c3c:	10bfc00c 	andi	r2,r2,65280
    1c40:	1004923a 	slli	r2,r2,8
    1c44:	1886b03a 	or	r3,r3,r2
    1c48:	e0bffd17 	ldw	r2,-12(fp)
    1c4c:	10800a17 	ldw	r2,40(r2)
    1c50:	1004963a 	slli	r2,r2,24
    1c54:	1884b03a 	or	r2,r3,r2
    1c58:	e13ffd17 	ldw	r4,-12(fp)
    1c5c:	100b883a 	mov	r5,r2
    1c60:	0003c3c0 	call	3c3c <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    1c64:	e13ffd17 	ldw	r4,-12(fp)
    1c68:	01400d84 	movi	r5,54
    1c6c:	01800104 	movi	r6,4
    1c70:	00039e40 	call	39e4 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
    1c74:	e0bffd17 	ldw	r2,-12(fp)
    1c78:	10800917 	ldw	r2,36(r2)
    1c7c:	1006d63a 	srli	r3,r2,24
    1c80:	e0bffd17 	ldw	r2,-12(fp)
    1c84:	10800917 	ldw	r2,36(r2)
    1c88:	1004d23a 	srli	r2,r2,8
    1c8c:	10bfc00c 	andi	r2,r2,65280
    1c90:	1886b03a 	or	r3,r3,r2
    1c94:	e0bffd17 	ldw	r2,-12(fp)
    1c98:	10800917 	ldw	r2,36(r2)
    1c9c:	10bfc00c 	andi	r2,r2,65280
    1ca0:	1004923a 	slli	r2,r2,8
    1ca4:	1886b03a 	or	r3,r3,r2
    1ca8:	e0bffd17 	ldw	r2,-12(fp)
    1cac:	10800917 	ldw	r2,36(r2)
    1cb0:	1004963a 	slli	r2,r2,24
    1cb4:	1884b03a 	or	r2,r3,r2
    1cb8:	e13ffd17 	ldw	r4,-12(fp)
    1cbc:	100b883a 	mov	r5,r2
    1cc0:	0003c3c0 	call	3c3c <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
    1cc4:	e13ffd17 	ldw	r4,-12(fp)
    1cc8:	01400dc4 	movi	r5,55
    1ccc:	01800104 	movi	r6,4
    1cd0:	00039e40 	call	39e4 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
    1cd4:	e13ffd17 	ldw	r4,-12(fp)
    1cd8:	01400044 	movi	r5,1
    1cdc:	0003ac80 	call	3ac8 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
    1ce0:	e13ffd17 	ldw	r4,-12(fp)
    1ce4:	014000c4 	movi	r5,3
    1ce8:	0003ac80 	call	3ac8 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
    1cec:	e13ffd17 	ldw	r4,-12(fp)
    1cf0:	01400704 	movi	r5,28
    1cf4:	0003ac80 	call	3ac8 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
    1cf8:	e13ffd17 	ldw	r4,-12(fp)
    1cfc:	01400184 	movi	r5,6
    1d00:	0003ac80 	call	3ac8 <dhcp_option_byte>
        dhcp_option_byte(dhcp, *p++);
      }
    }
#endif /* LWIP_NETIF_HOSTNAME */

    dhcp_option_trailer(dhcp);
    1d04:	e13ffd17 	ldw	r4,-12(fp)
    1d08:	00048f00 	call	48f0 <dhcp_option_trailer>
    /* shrink the pbuf to the actual content length */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    1d0c:	e0bffd17 	ldw	r2,-12(fp)
    1d10:	10c00517 	ldw	r3,20(r2)
    1d14:	e0bffd17 	ldw	r2,-12(fp)
    1d18:	1080070b 	ldhu	r2,28(r2)
    1d1c:	10803c04 	addi	r2,r2,240
    1d20:	10bfffcc 	andi	r2,r2,65535
    1d24:	1809883a 	mov	r4,r3
    1d28:	100b883a 	mov	r5,r2
    1d2c:	0009cf00 	call	9cf0 <pbuf_realloc>

    /* send broadcast to any DHCP server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    1d30:	e0bffd17 	ldw	r2,-12(fp)
    1d34:	10c00117 	ldw	r3,4(r2)
    1d38:	e0bffd17 	ldw	r2,-12(fp)
    1d3c:	10800517 	ldw	r2,20(r2)
    1d40:	e13fff17 	ldw	r4,-4(fp)
    1d44:	d9000015 	stw	r4,0(sp)
    1d48:	1809883a 	mov	r4,r3
    1d4c:	100b883a 	mov	r5,r2
    1d50:	018000f4 	movhi	r6,3
    1d54:	318d2204 	addi	r6,r6,13448
    1d58:	01c010c4 	movi	r7,67
    1d5c:	0013f940 	call	13f94 <udp_sendto_if>
    dhcp_delete_request(netif);
    1d60:	e13fff17 	ldw	r4,-4(fp)
    1d64:	00047d80 	call	47d8 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("dhcp_select: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
    1d68:	e0bffd17 	ldw	r2,-12(fp)
    1d6c:	108004c3 	ldbu	r2,19(r2)
    1d70:	10800044 	addi	r2,r2,1
    1d74:	1007883a 	mov	r3,r2
    1d78:	e0bffd17 	ldw	r2,-12(fp)
    1d7c:	10c004c5 	stb	r3,19(r2)
  msecs = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
    1d80:	e0bffd17 	ldw	r2,-12(fp)
    1d84:	108004c3 	ldbu	r2,19(r2)
    1d88:	10803fcc 	andi	r2,r2,255
    1d8c:	108001a8 	cmpgeui	r2,r2,6
    1d90:	1000061e 	bne	r2,zero,1dac <dhcp_select+0x22c>
    1d94:	e0bffd17 	ldw	r2,-12(fp)
    1d98:	108004c3 	ldbu	r2,19(r2)
    1d9c:	10803fcc 	andi	r2,r2,255
    1da0:	00c0fa04 	movi	r3,1000
    1da4:	1884983a 	sll	r2,r3,r2
    1da8:	00000106 	br	1db0 <dhcp_select+0x230>
    1dac:	00ba9804 	movi	r2,-5536
    1db0:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    1db4:	e0bffe8b 	ldhu	r2,-6(fp)
    1db8:	10c07cc4 	addi	r3,r2,499
    1dbc:	00807d04 	movi	r2,500
    1dc0:	1885283a 	div	r2,r3,r2
    1dc4:	1007883a 	mov	r3,r2
    1dc8:	e0bffd17 	ldw	r2,-12(fp)
    1dcc:	10c0078d 	sth	r3,30(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
    1dd0:	e0bffe03 	ldbu	r2,-8(fp)
}
    1dd4:	e037883a 	mov	sp,fp
    1dd8:	dfc00117 	ldw	ra,4(sp)
    1ddc:	df000017 	ldw	fp,0(sp)
    1de0:	dec00204 	addi	sp,sp,8
    1de4:	f800283a 	ret

00001de8 <dhcp_coarse_tmr>:
 * The DHCP timer that checks for lease renewal/rebind timeouts.
 *
 */
void
dhcp_coarse_tmr()
{
    1de8:	defffd04 	addi	sp,sp,-12
    1dec:	dfc00215 	stw	ra,8(sp)
    1df0:	df000115 	stw	fp,4(sp)
    1df4:	df000104 	addi	fp,sp,4
  struct netif *netif = netif_list;
    1df8:	008000f4 	movhi	r2,3
    1dfc:	1095f204 	addi	r2,r2,22472
    1e00:	10800017 	ldw	r2,0(r2)
    1e04:	e0bfff15 	stw	r2,-4(fp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
    1e08:	00001d06 	br	1e80 <dhcp_coarse_tmr+0x98>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
    1e0c:	e0bfff17 	ldw	r2,-4(fp)
    1e10:	10800817 	ldw	r2,32(r2)
    1e14:	10001726 	beq	r2,zero,1e74 <dhcp_coarse_tmr+0x8c>
      /* timer is active (non zero), and triggers (zeroes) now? */
      if (netif->dhcp->t2_timeout-- == 1) {
    1e18:	e0bfff17 	ldw	r2,-4(fp)
    1e1c:	10800817 	ldw	r2,32(r2)
    1e20:	10c0088b 	ldhu	r3,34(r2)
    1e24:	193fffcc 	andi	r4,r3,65535
    1e28:	21000060 	cmpeqi	r4,r4,1
    1e2c:	18ffffc4 	addi	r3,r3,-1
    1e30:	10c0088d 	sth	r3,34(r2)
    1e34:	20803fcc 	andi	r2,r4,255
    1e38:	10000326 	beq	r2,zero,1e48 <dhcp_coarse_tmr+0x60>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
        /* this clients' rebind timeout triggered */
        dhcp_t2_timeout(netif);
    1e3c:	e13fff17 	ldw	r4,-4(fp)
    1e40:	00021640 	call	2164 <dhcp_t2_timeout>
    1e44:	00000b06 	br	1e74 <dhcp_coarse_tmr+0x8c>
      /* timer is active (non zero), and triggers (zeroes) now */
      } else if (netif->dhcp->t1_timeout-- == 1) {
    1e48:	e0bfff17 	ldw	r2,-4(fp)
    1e4c:	10800817 	ldw	r2,32(r2)
    1e50:	10c0080b 	ldhu	r3,32(r2)
    1e54:	193fffcc 	andi	r4,r3,65535
    1e58:	21000060 	cmpeqi	r4,r4,1
    1e5c:	18ffffc4 	addi	r3,r3,-1
    1e60:	10c0080d 	sth	r3,32(r2)
    1e64:	20803fcc 	andi	r2,r4,255
    1e68:	10000226 	beq	r2,zero,1e74 <dhcp_coarse_tmr+0x8c>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t1 timeout\n"));
        /* this clients' renewal timeout triggered */
        dhcp_t1_timeout(netif);
    1e6c:	e13fff17 	ldw	r4,-4(fp)
    1e70:	00020ec0 	call	20ec <dhcp_t1_timeout>
      }
    }
    /* proceed to next netif */
    netif = netif->next;
    1e74:	e0bfff17 	ldw	r2,-4(fp)
    1e78:	10800017 	ldw	r2,0(r2)
    1e7c:	e0bfff15 	stw	r2,-4(fp)
dhcp_coarse_tmr()
{
  struct netif *netif = netif_list;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
    1e80:	e0bfff17 	ldw	r2,-4(fp)
    1e84:	103fe11e 	bne	r2,zero,1e0c <dhcp_coarse_tmr+0x24>
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  }
}
    1e88:	e037883a 	mov	sp,fp
    1e8c:	dfc00117 	ldw	ra,4(sp)
    1e90:	df000017 	ldw	fp,0(sp)
    1e94:	dec00204 	addi	sp,sp,8
    1e98:	f800283a 	ret

00001e9c <dhcp_fine_tmr>:
 * This timer checks whether an outstanding DHCP request is timed out.
 * 
 */
void
dhcp_fine_tmr()
{
    1e9c:	defffd04 	addi	sp,sp,-12
    1ea0:	dfc00215 	stw	ra,8(sp)
    1ea4:	df000115 	stw	fp,4(sp)
    1ea8:	df000104 	addi	fp,sp,4
  struct netif *netif = netif_list;
    1eac:	008000f4 	movhi	r2,3
    1eb0:	1095f204 	addi	r2,r2,22472
    1eb4:	10800017 	ldw	r2,0(r2)
    1eb8:	e0bfff15 	stw	r2,-4(fp)
  /* loop through netif's */
  while (netif != NULL) {
    1ebc:	00001f06 	br	1f3c <dhcp_fine_tmr+0xa0>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
    1ec0:	e0bfff17 	ldw	r2,-4(fp)
    1ec4:	10800817 	ldw	r2,32(r2)
    1ec8:	10001926 	beq	r2,zero,1f30 <dhcp_fine_tmr+0x94>
      /* timer is active (non zero), and is about to trigger now */      
      if (netif->dhcp->request_timeout > 1) {
    1ecc:	e0bfff17 	ldw	r2,-4(fp)
    1ed0:	10800817 	ldw	r2,32(r2)
    1ed4:	1080078b 	ldhu	r2,30(r2)
    1ed8:	10bfffcc 	andi	r2,r2,65535
    1edc:	108000b0 	cmpltui	r2,r2,2
    1ee0:	1000061e 	bne	r2,zero,1efc <dhcp_fine_tmr+0x60>
        netif->dhcp->request_timeout--;
    1ee4:	e0bfff17 	ldw	r2,-4(fp)
    1ee8:	10800817 	ldw	r2,32(r2)
    1eec:	10c0078b 	ldhu	r3,30(r2)
    1ef0:	18ffffc4 	addi	r3,r3,-1
    1ef4:	10c0078d 	sth	r3,30(r2)
    1ef8:	00000d06 	br	1f30 <dhcp_fine_tmr+0x94>
      }
      else if (netif->dhcp->request_timeout == 1) {
    1efc:	e0bfff17 	ldw	r2,-4(fp)
    1f00:	10800817 	ldw	r2,32(r2)
    1f04:	1080078b 	ldhu	r2,30(r2)
    1f08:	10bfffcc 	andi	r2,r2,65535
    1f0c:	10800058 	cmpnei	r2,r2,1
    1f10:	1000071e 	bne	r2,zero,1f30 <dhcp_fine_tmr+0x94>
        netif->dhcp->request_timeout--;
    1f14:	e0bfff17 	ldw	r2,-4(fp)
    1f18:	10800817 	ldw	r2,32(r2)
    1f1c:	10c0078b 	ldhu	r3,30(r2)
    1f20:	18ffffc4 	addi	r3,r3,-1
    1f24:	10c0078d 	sth	r3,30(r2)
        /* { netif->dhcp->request_timeout == 0 } */
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_fine_tmr(): request timeout\n"));
        /* this clients' request timeout triggered */
        dhcp_timeout(netif);
    1f28:	e13fff17 	ldw	r4,-4(fp)
    1f2c:	0001f580 	call	1f58 <dhcp_timeout>
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
    1f30:	e0bfff17 	ldw	r2,-4(fp)
    1f34:	10800017 	ldw	r2,0(r2)
    1f38:	e0bfff15 	stw	r2,-4(fp)
void
dhcp_fine_tmr()
{
  struct netif *netif = netif_list;
  /* loop through netif's */
  while (netif != NULL) {
    1f3c:	e0bfff17 	ldw	r2,-4(fp)
    1f40:	103fdf1e 	bne	r2,zero,1ec0 <dhcp_fine_tmr+0x24>
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  }
}
    1f44:	e037883a 	mov	sp,fp
    1f48:	dfc00117 	ldw	ra,4(sp)
    1f4c:	df000017 	ldw	fp,0(sp)
    1f50:	dec00204 	addi	sp,sp,8
    1f54:	f800283a 	ret

00001f58 <dhcp_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_timeout(struct netif *netif)
{
    1f58:	defffc04 	addi	sp,sp,-16
    1f5c:	dfc00315 	stw	ra,12(sp)
    1f60:	df000215 	stw	fp,8(sp)
    1f64:	df000204 	addi	fp,sp,8
    1f68:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    1f6c:	e0bfff17 	ldw	r2,-4(fp)
    1f70:	10800817 	ldw	r2,32(r2)
    1f74:	e0bffe15 	stw	r2,-8(fp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout()\n"));
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
    1f78:	e0bffe17 	ldw	r2,-8(fp)
    1f7c:	10800483 	ldbu	r2,18(r2)
    1f80:	10803fcc 	andi	r2,r2,255
    1f84:	10800320 	cmpeqi	r2,r2,12
    1f88:	1000051e 	bne	r2,zero,1fa0 <dhcp_timeout+0x48>
    1f8c:	e0bffe17 	ldw	r2,-8(fp)
    1f90:	10800483 	ldbu	r2,18(r2)
    1f94:	10803fcc 	andi	r2,r2,255
    1f98:	10800198 	cmpnei	r2,r2,6
    1f9c:	1000031e 	bne	r2,zero,1fac <dhcp_timeout+0x54>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
    1fa0:	e13fff17 	ldw	r4,-4(fp)
    1fa4:	0002ca40 	call	2ca4 <dhcp_discover>
    1fa8:	00004b06 	br	20d8 <dhcp_timeout+0x180>
  /* receiving the requested lease timed out */
  } else if (dhcp->state == DHCP_REQUESTING) {
    1fac:	e0bffe17 	ldw	r2,-8(fp)
    1fb0:	10800483 	ldbu	r2,18(r2)
    1fb4:	10803fcc 	andi	r2,r2,255
    1fb8:	10800058 	cmpnei	r2,r2,1
    1fbc:	10000d1e 	bne	r2,zero,1ff4 <dhcp_timeout+0x9c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
    if (dhcp->tries <= 5) {
    1fc0:	e0bffe17 	ldw	r2,-8(fp)
    1fc4:	108004c3 	ldbu	r2,19(r2)
    1fc8:	10803fcc 	andi	r2,r2,255
    1fcc:	108001a8 	cmpgeui	r2,r2,6
    1fd0:	1000031e 	bne	r2,zero,1fe0 <dhcp_timeout+0x88>
      dhcp_select(netif);
    1fd4:	e13fff17 	ldw	r4,-4(fp)
    1fd8:	0001b800 	call	1b80 <dhcp_select>
    1fdc:	00003e06 	br	20d8 <dhcp_timeout+0x180>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, releasing, restarting\n"));
      dhcp_release(netif);
    1fe0:	e13fff17 	ldw	r4,-4(fp)
    1fe4:	00036b40 	call	36b4 <dhcp_release>
      dhcp_discover(netif);
    1fe8:	e13fff17 	ldw	r4,-4(fp)
    1fec:	0002ca40 	call	2ca4 <dhcp_discover>
    1ff0:	00003906 	br	20d8 <dhcp_timeout+0x180>
    }
#if DHCP_DOES_ARP_CHECK
  /* received no ARP reply for the offered address (which is good) */
  } else if (dhcp->state == DHCP_CHECKING) {
    1ff4:	e0bffe17 	ldw	r2,-8(fp)
    1ff8:	10800483 	ldbu	r2,18(r2)
    1ffc:	10803fcc 	andi	r2,r2,255
    2000:	10800218 	cmpnei	r2,r2,8
    2004:	10000b1e 	bne	r2,zero,2034 <dhcp_timeout+0xdc>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): CHECKING, ARP request timed out\n"));
    if (dhcp->tries <= 1) {
    2008:	e0bffe17 	ldw	r2,-8(fp)
    200c:	108004c3 	ldbu	r2,19(r2)
    2010:	10803fcc 	andi	r2,r2,255
    2014:	108000a8 	cmpgeui	r2,r2,2
    2018:	1000031e 	bne	r2,zero,2028 <dhcp_timeout+0xd0>
      dhcp_check(netif);
    201c:	e13fff17 	ldw	r4,-4(fp)
    2020:	00019e80 	call	19e8 <dhcp_check>
    2024:	00002c06 	br	20d8 <dhcp_timeout+0x180>
    /* no ARP replies on the offered address,
       looks like the IP address is indeed free */
    } else {
      /* bind the interface to the offered address */
      dhcp_bind(netif);
    2028:	e13fff17 	ldw	r4,-4(fp)
    202c:	0002e740 	call	2e74 <dhcp_bind>
    2030:	00002906 	br	20d8 <dhcp_timeout+0x180>
    }
#endif /* DHCP_DOES_ARP_CHECK */
  }
  /* did not get response to renew request? */
  else if (dhcp->state == DHCP_RENEWING) {
    2034:	e0bffe17 	ldw	r2,-8(fp)
    2038:	10800483 	ldbu	r2,18(r2)
    203c:	10803fcc 	andi	r2,r2,255
    2040:	10800158 	cmpnei	r2,r2,5
    2044:	1000031e 	bne	r2,zero,2054 <dhcp_timeout+0xfc>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RENEWING, DHCP request timed out\n"));
    /* just retry renewal */
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
    2048:	e13fff17 	ldw	r4,-4(fp)
    204c:	00032340 	call	3234 <dhcp_renew>
    2050:	00002106 	br	20d8 <dhcp_timeout+0x180>
  /* did not get response to rebind request? */
  } else if (dhcp->state == DHCP_REBINDING) {
    2054:	e0bffe17 	ldw	r2,-8(fp)
    2058:	10800483 	ldbu	r2,18(r2)
    205c:	10803fcc 	andi	r2,r2,255
    2060:	10800118 	cmpnei	r2,r2,4
    2064:	10000d1e 	bne	r2,zero,209c <dhcp_timeout+0x144>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
    if (dhcp->tries <= 8) {
    2068:	e0bffe17 	ldw	r2,-8(fp)
    206c:	108004c3 	ldbu	r2,19(r2)
    2070:	10803fcc 	andi	r2,r2,255
    2074:	10800268 	cmpgeui	r2,r2,9
    2078:	1000031e 	bne	r2,zero,2088 <dhcp_timeout+0x130>
      dhcp_rebind(netif);
    207c:	e13fff17 	ldw	r4,-4(fp)
    2080:	00033980 	call	3398 <dhcp_rebind>
    2084:	00001406 	br	20d8 <dhcp_timeout+0x180>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
    2088:	e13fff17 	ldw	r4,-4(fp)
    208c:	00036b40 	call	36b4 <dhcp_release>
      dhcp_discover(netif);
    2090:	e13fff17 	ldw	r4,-4(fp)
    2094:	0002ca40 	call	2ca4 <dhcp_discover>
    2098:	00000f06 	br	20d8 <dhcp_timeout+0x180>
    }
  } else if (dhcp->state == DHCP_REBOOTING) {
    209c:	e0bffe17 	ldw	r2,-8(fp)
    20a0:	10800483 	ldbu	r2,18(r2)
    20a4:	10803fcc 	andi	r2,r2,255
    20a8:	108000d8 	cmpnei	r2,r2,3
    20ac:	10000a1e 	bne	r2,zero,20d8 <dhcp_timeout+0x180>
    if (dhcp->tries < REBOOT_TRIES) {
    20b0:	e0bffe17 	ldw	r2,-8(fp)
    20b4:	108004c3 	ldbu	r2,19(r2)
    20b8:	10803fcc 	andi	r2,r2,255
    20bc:	108000a8 	cmpgeui	r2,r2,2
    20c0:	1000031e 	bne	r2,zero,20d0 <dhcp_timeout+0x178>
      dhcp_reboot(netif);
    20c4:	e13fff17 	ldw	r4,-4(fp)
    20c8:	00034fc0 	call	34fc <dhcp_reboot>
    20cc:	00000206 	br	20d8 <dhcp_timeout+0x180>
    } else {
      dhcp_discover(netif);
    20d0:	e13fff17 	ldw	r4,-4(fp)
    20d4:	0002ca40 	call	2ca4 <dhcp_discover>
    }
  }
}
    20d8:	e037883a 	mov	sp,fp
    20dc:	dfc00117 	ldw	ra,4(sp)
    20e0:	df000017 	ldw	fp,0(sp)
    20e4:	dec00204 	addi	sp,sp,8
    20e8:	f800283a 	ret

000020ec <dhcp_t1_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_t1_timeout(struct netif *netif)
{
    20ec:	defffc04 	addi	sp,sp,-16
    20f0:	dfc00315 	stw	ra,12(sp)
    20f4:	df000215 	stw	fp,8(sp)
    20f8:	df000204 	addi	fp,sp,8
    20fc:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    2100:	e0bfff17 	ldw	r2,-4(fp)
    2104:	10800817 	ldw	r2,32(r2)
    2108:	e0bffe15 	stw	r2,-8(fp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
    210c:	e0bffe17 	ldw	r2,-8(fp)
    2110:	10800483 	ldbu	r2,18(r2)
    2114:	10803fcc 	andi	r2,r2,255
    2118:	10800060 	cmpeqi	r2,r2,1
    211c:	10000a1e 	bne	r2,zero,2148 <dhcp_t1_timeout+0x5c>
    2120:	e0bffe17 	ldw	r2,-8(fp)
    2124:	10800483 	ldbu	r2,18(r2)
    2128:	10803fcc 	andi	r2,r2,255
    212c:	108002a0 	cmpeqi	r2,r2,10
    2130:	1000051e 	bne	r2,zero,2148 <dhcp_t1_timeout+0x5c>
    2134:	e0bffe17 	ldw	r2,-8(fp)
    2138:	10800483 	ldbu	r2,18(r2)
    213c:	10803fcc 	andi	r2,r2,255
    2140:	10800158 	cmpnei	r2,r2,5
    2144:	1000021e 	bne	r2,zero,2150 <dhcp_t1_timeout+0x64>
    /* just retry to renew - note that the rebind timer (t2) will
     * eventually time-out if renew tries fail. */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t1_timeout(): must renew\n"));
    dhcp_renew(netif);
    2148:	e13fff17 	ldw	r4,-4(fp)
    214c:	00032340 	call	3234 <dhcp_renew>
  }
}
    2150:	e037883a 	mov	sp,fp
    2154:	dfc00117 	ldw	ra,4(sp)
    2158:	df000017 	ldw	fp,0(sp)
    215c:	dec00204 	addi	sp,sp,8
    2160:	f800283a 	ret

00002164 <dhcp_t2_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_t2_timeout(struct netif *netif)
{
    2164:	defffc04 	addi	sp,sp,-16
    2168:	dfc00315 	stw	ra,12(sp)
    216c:	df000215 	stw	fp,8(sp)
    2170:	df000204 	addi	fp,sp,8
    2174:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    2178:	e0bfff17 	ldw	r2,-4(fp)
    217c:	10800817 	ldw	r2,32(r2)
    2180:	e0bffe15 	stw	r2,-8(fp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
    2184:	e0bffe17 	ldw	r2,-8(fp)
    2188:	10800483 	ldbu	r2,18(r2)
    218c:	10803fcc 	andi	r2,r2,255
    2190:	10800060 	cmpeqi	r2,r2,1
    2194:	10000a1e 	bne	r2,zero,21c0 <dhcp_t2_timeout+0x5c>
    2198:	e0bffe17 	ldw	r2,-8(fp)
    219c:	10800483 	ldbu	r2,18(r2)
    21a0:	10803fcc 	andi	r2,r2,255
    21a4:	108002a0 	cmpeqi	r2,r2,10
    21a8:	1000051e 	bne	r2,zero,21c0 <dhcp_t2_timeout+0x5c>
    21ac:	e0bffe17 	ldw	r2,-8(fp)
    21b0:	10800483 	ldbu	r2,18(r2)
    21b4:	10803fcc 	andi	r2,r2,255
    21b8:	10800158 	cmpnei	r2,r2,5
    21bc:	1000021e 	bne	r2,zero,21c8 <dhcp_t2_timeout+0x64>
    /* just retry to rebind */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout(): must rebind\n"));
    dhcp_rebind(netif);
    21c0:	e13fff17 	ldw	r4,-4(fp)
    21c4:	00033980 	call	3398 <dhcp_rebind>
  }
}
    21c8:	e037883a 	mov	sp,fp
    21cc:	dfc00117 	ldw	ra,4(sp)
    21d0:	df000017 	ldw	fp,0(sp)
    21d4:	dec00204 	addi	sp,sp,8
    21d8:	f800283a 	ret

000021dc <dhcp_handle_ack>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_ack(struct netif *netif)
{
    21dc:	defff804 	addi	sp,sp,-32
    21e0:	dfc00715 	stw	ra,28(sp)
    21e4:	df000615 	stw	fp,24(sp)
    21e8:	dc400515 	stw	r17,20(sp)
    21ec:	dc000415 	stw	r16,16(sp)
    21f0:	df000404 	addi	fp,sp,16
    21f4:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    21f8:	e0bfff17 	ldw	r2,-4(fp)
    21fc:	10800817 	ldw	r2,32(r2)
    2200:	e0bffd15 	stw	r2,-12(fp)
  u8_t *option_ptr;
  /* clear options we might not get from the ACK */
  dhcp->offered_sn_mask.addr = 0;
    2204:	e0bffd17 	ldw	r2,-12(fp)
    2208:	10000b15 	stw	zero,44(r2)
  dhcp->offered_gw_addr.addr = 0;
    220c:	e0bffd17 	ldw	r2,-12(fp)
    2210:	10000c15 	stw	zero,48(r2)
  dhcp->offered_bc_addr.addr = 0;
    2214:	e0bffd17 	ldw	r2,-12(fp)
    2218:	10000d15 	stw	zero,52(r2)

  /* lease time given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_LEASE_TIME);
    221c:	e13ffd17 	ldw	r4,-12(fp)
    2220:	01400cc4 	movi	r5,51
    2224:	0004a740 	call	4a74 <dhcp_get_option_ptr>
    2228:	e0bffe15 	stw	r2,-8(fp)
  if (option_ptr != NULL) {
    222c:	e0bffe17 	ldw	r2,-8(fp)
    2230:	10000626 	beq	r2,zero,224c <dhcp_handle_ack+0x70>
    /* remember offered lease time */
    dhcp->offered_t0_lease = dhcp_get_option_long(option_ptr + 2);
    2234:	e0bffe17 	ldw	r2,-8(fp)
    2238:	10800084 	addi	r2,r2,2
    223c:	1009883a 	mov	r4,r2
    2240:	0004cd00 	call	4cd0 <dhcp_get_option_long>
    2244:	e0fffd17 	ldw	r3,-12(fp)
    2248:	18801115 	stw	r2,68(r3)
  }
  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T1);
    224c:	e13ffd17 	ldw	r4,-12(fp)
    2250:	01400e84 	movi	r5,58
    2254:	0004a740 	call	4a74 <dhcp_get_option_ptr>
    2258:	e0bffe15 	stw	r2,-8(fp)
  if (option_ptr != NULL) {
    225c:	e0bffe17 	ldw	r2,-8(fp)
    2260:	10000726 	beq	r2,zero,2280 <dhcp_handle_ack+0xa4>
    /* remember given renewal period */
    dhcp->offered_t1_renew = dhcp_get_option_long(option_ptr + 2);
    2264:	e0bffe17 	ldw	r2,-8(fp)
    2268:	10800084 	addi	r2,r2,2
    226c:	1009883a 	mov	r4,r2
    2270:	0004cd00 	call	4cd0 <dhcp_get_option_long>
    2274:	e0fffd17 	ldw	r3,-12(fp)
    2278:	18801215 	stw	r2,72(r3)
    227c:	00000506 	br	2294 <dhcp_handle_ack+0xb8>
  } else {
    /* calculate safe periods for renewal */
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
    2280:	e0bffd17 	ldw	r2,-12(fp)
    2284:	10801117 	ldw	r2,68(r2)
    2288:	1006d07a 	srli	r3,r2,1
    228c:	e0bffd17 	ldw	r2,-12(fp)
    2290:	10c01215 	stw	r3,72(r2)
  }

  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T2);
    2294:	e13ffd17 	ldw	r4,-12(fp)
    2298:	01400ec4 	movi	r5,59
    229c:	0004a740 	call	4a74 <dhcp_get_option_ptr>
    22a0:	e0bffe15 	stw	r2,-8(fp)
  if (option_ptr != NULL) {
    22a4:	e0bffe17 	ldw	r2,-8(fp)
    22a8:	10000726 	beq	r2,zero,22c8 <dhcp_handle_ack+0xec>
    /* remember given rebind period */
    dhcp->offered_t2_rebind = dhcp_get_option_long(option_ptr + 2);
    22ac:	e0bffe17 	ldw	r2,-8(fp)
    22b0:	10800084 	addi	r2,r2,2
    22b4:	1009883a 	mov	r4,r2
    22b8:	0004cd00 	call	4cd0 <dhcp_get_option_long>
    22bc:	e0fffd17 	ldw	r3,-12(fp)
    22c0:	18801315 	stw	r2,76(r3)
    22c4:	00000406 	br	22d8 <dhcp_handle_ack+0xfc>
  } else {
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
    22c8:	e0bffd17 	ldw	r2,-12(fp)
    22cc:	10c01117 	ldw	r3,68(r2)
    22d0:	e0bffd17 	ldw	r2,-12(fp)
    22d4:	10c01315 	stw	r3,76(r2)
  }

  /* (y)our internet address */
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
    22d8:	e0bffd17 	ldw	r2,-12(fp)
    22dc:	10800217 	ldw	r2,8(r2)
    22e0:	10800404 	addi	r2,r2,16
    22e4:	10000726 	beq	r2,zero,2304 <dhcp_handle_ack+0x128>
    22e8:	e0bffd17 	ldw	r2,-12(fp)
    22ec:	10800217 	ldw	r2,8(r2)
    22f0:	10c0040b 	ldhu	r3,16(r2)
    22f4:	1080048b 	ldhu	r2,18(r2)
    22f8:	1004943a 	slli	r2,r2,16
    22fc:	10c4b03a 	or	r2,r2,r3
    2300:	00000106 	br	2308 <dhcp_handle_ack+0x12c>
    2304:	0005883a 	mov	r2,zero
    2308:	e0fffd17 	ldw	r3,-12(fp)
    230c:	18800a15 	stw	r2,40(r3)
    strcpy(dhcp->boot_file_name, dhcp->msg_in->file);
  }
#endif

  /* subnet mask */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SUBNET_MASK);
    2310:	e13ffd17 	ldw	r4,-12(fp)
    2314:	01400044 	movi	r5,1
    2318:	0004a740 	call	4a74 <dhcp_get_option_ptr>
    231c:	e0bffe15 	stw	r2,-8(fp)
  /* subnet mask given? */
  if (option_ptr != NULL) {
    2320:	e0bffe17 	ldw	r2,-8(fp)
    2324:	10001b26 	beq	r2,zero,2394 <dhcp_handle_ack+0x1b8>
    dhcp->offered_sn_mask.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
    2328:	e0bffe17 	ldw	r2,-8(fp)
    232c:	10800084 	addi	r2,r2,2
    2330:	1009883a 	mov	r4,r2
    2334:	0004cd00 	call	4cd0 <dhcp_get_option_long>
    2338:	1020d63a 	srli	r16,r2,24
    233c:	e0bffe17 	ldw	r2,-8(fp)
    2340:	10800084 	addi	r2,r2,2
    2344:	1009883a 	mov	r4,r2
    2348:	0004cd00 	call	4cd0 <dhcp_get_option_long>
    234c:	1004d23a 	srli	r2,r2,8
    2350:	10bfc00c 	andi	r2,r2,65280
    2354:	80a0b03a 	or	r16,r16,r2
    2358:	e0bffe17 	ldw	r2,-8(fp)
    235c:	10800084 	addi	r2,r2,2
    2360:	1009883a 	mov	r4,r2
    2364:	0004cd00 	call	4cd0 <dhcp_get_option_long>
    2368:	10bfc00c 	andi	r2,r2,65280
    236c:	1004923a 	slli	r2,r2,8
    2370:	80a0b03a 	or	r16,r16,r2
    2374:	e0bffe17 	ldw	r2,-8(fp)
    2378:	10800084 	addi	r2,r2,2
    237c:	1009883a 	mov	r4,r2
    2380:	0004cd00 	call	4cd0 <dhcp_get_option_long>
    2384:	1004963a 	slli	r2,r2,24
    2388:	8086b03a 	or	r3,r16,r2
    238c:	e0bffd17 	ldw	r2,-12(fp)
    2390:	10c00b15 	stw	r3,44(r2)
  }

  /* gateway router */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_ROUTER);
    2394:	e13ffd17 	ldw	r4,-12(fp)
    2398:	014000c4 	movi	r5,3
    239c:	0004a740 	call	4a74 <dhcp_get_option_ptr>
    23a0:	e0bffe15 	stw	r2,-8(fp)
  if (option_ptr != NULL) {
    23a4:	e0bffe17 	ldw	r2,-8(fp)
    23a8:	10001b26 	beq	r2,zero,2418 <dhcp_handle_ack+0x23c>
    dhcp->offered_gw_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
    23ac:	e0bffe17 	ldw	r2,-8(fp)
    23b0:	10800084 	addi	r2,r2,2
    23b4:	1009883a 	mov	r4,r2
    23b8:	0004cd00 	call	4cd0 <dhcp_get_option_long>
    23bc:	1020d63a 	srli	r16,r2,24
    23c0:	e0bffe17 	ldw	r2,-8(fp)
    23c4:	10800084 	addi	r2,r2,2
    23c8:	1009883a 	mov	r4,r2
    23cc:	0004cd00 	call	4cd0 <dhcp_get_option_long>
    23d0:	1004d23a 	srli	r2,r2,8
    23d4:	10bfc00c 	andi	r2,r2,65280
    23d8:	80a0b03a 	or	r16,r16,r2
    23dc:	e0bffe17 	ldw	r2,-8(fp)
    23e0:	10800084 	addi	r2,r2,2
    23e4:	1009883a 	mov	r4,r2
    23e8:	0004cd00 	call	4cd0 <dhcp_get_option_long>
    23ec:	10bfc00c 	andi	r2,r2,65280
    23f0:	1004923a 	slli	r2,r2,8
    23f4:	80a0b03a 	or	r16,r16,r2
    23f8:	e0bffe17 	ldw	r2,-8(fp)
    23fc:	10800084 	addi	r2,r2,2
    2400:	1009883a 	mov	r4,r2
    2404:	0004cd00 	call	4cd0 <dhcp_get_option_long>
    2408:	1004963a 	slli	r2,r2,24
    240c:	8086b03a 	or	r3,r16,r2
    2410:	e0bffd17 	ldw	r2,-12(fp)
    2414:	10c00c15 	stw	r3,48(r2)
  }

  /* broadcast address */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_BROADCAST);
    2418:	e13ffd17 	ldw	r4,-12(fp)
    241c:	01400704 	movi	r5,28
    2420:	0004a740 	call	4a74 <dhcp_get_option_ptr>
    2424:	e0bffe15 	stw	r2,-8(fp)
  if (option_ptr != NULL) {
    2428:	e0bffe17 	ldw	r2,-8(fp)
    242c:	10001b26 	beq	r2,zero,249c <dhcp_handle_ack+0x2c0>
    dhcp->offered_bc_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
    2430:	e0bffe17 	ldw	r2,-8(fp)
    2434:	10800084 	addi	r2,r2,2
    2438:	1009883a 	mov	r4,r2
    243c:	0004cd00 	call	4cd0 <dhcp_get_option_long>
    2440:	1020d63a 	srli	r16,r2,24
    2444:	e0bffe17 	ldw	r2,-8(fp)
    2448:	10800084 	addi	r2,r2,2
    244c:	1009883a 	mov	r4,r2
    2450:	0004cd00 	call	4cd0 <dhcp_get_option_long>
    2454:	1004d23a 	srli	r2,r2,8
    2458:	10bfc00c 	andi	r2,r2,65280
    245c:	80a0b03a 	or	r16,r16,r2
    2460:	e0bffe17 	ldw	r2,-8(fp)
    2464:	10800084 	addi	r2,r2,2
    2468:	1009883a 	mov	r4,r2
    246c:	0004cd00 	call	4cd0 <dhcp_get_option_long>
    2470:	10bfc00c 	andi	r2,r2,65280
    2474:	1004923a 	slli	r2,r2,8
    2478:	80a0b03a 	or	r16,r16,r2
    247c:	e0bffe17 	ldw	r2,-8(fp)
    2480:	10800084 	addi	r2,r2,2
    2484:	1009883a 	mov	r4,r2
    2488:	0004cd00 	call	4cd0 <dhcp_get_option_long>
    248c:	1004963a 	slli	r2,r2,24
    2490:	8086b03a 	or	r3,r16,r2
    2494:	e0bffd17 	ldw	r2,-12(fp)
    2498:	10c00d15 	stw	r3,52(r2)
  }
  
  /* DNS servers */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_DNS_SERVER);
    249c:	e13ffd17 	ldw	r4,-12(fp)
    24a0:	01400184 	movi	r5,6
    24a4:	0004a740 	call	4a74 <dhcp_get_option_ptr>
    24a8:	e0bffe15 	stw	r2,-8(fp)
  if (option_ptr != NULL) {
    24ac:	e0bffe17 	ldw	r2,-8(fp)
    24b0:	10004926 	beq	r2,zero,25d8 <dhcp_handle_ack+0x3fc>
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
    24b4:	e0bffe17 	ldw	r2,-8(fp)
    24b8:	10800044 	addi	r2,r2,1
    24bc:	1009883a 	mov	r4,r2
    24c0:	0004ca80 	call	4ca8 <dhcp_get_option_byte>
    24c4:	10803fcc 	andi	r2,r2,255
    24c8:	1004d0ba 	srli	r2,r2,2
    24cc:	10c03fcc 	andi	r3,r2,255
    24d0:	e0bffd17 	ldw	r2,-12(fp)
    24d4:	10c00e15 	stw	r3,56(r2)
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
    24d8:	e0bffd17 	ldw	r2,-12(fp)
    24dc:	10800e17 	ldw	r2,56(r2)
    24e0:	108000f0 	cmpltui	r2,r2,3
    24e4:	1000031e 	bne	r2,zero,24f4 <dhcp_handle_ack+0x318>
      dhcp->dns_count = DHCP_MAX_DNS;
    24e8:	e0bffd17 	ldw	r2,-12(fp)
    24ec:	00c00084 	movi	r3,2
    24f0:	10c00e15 	stw	r3,56(r2)
    for (n = 0; n < dhcp->dns_count; n++) {
    24f4:	e03ffc05 	stb	zero,-16(fp)
    24f8:	00003306 	br	25c8 <dhcp_handle_ack+0x3ec>
      dhcp->offered_dns_addr[n].addr = htonl(dhcp_get_option_long(&option_ptr[2 + n * 4]));
    24fc:	e43ffc03 	ldbu	r16,-16(fp)
    2500:	e0bffc03 	ldbu	r2,-16(fp)
    2504:	1085883a 	add	r2,r2,r2
    2508:	1085883a 	add	r2,r2,r2
    250c:	10800084 	addi	r2,r2,2
    2510:	e0fffe17 	ldw	r3,-8(fp)
    2514:	1885883a 	add	r2,r3,r2
    2518:	1009883a 	mov	r4,r2
    251c:	0004cd00 	call	4cd0 <dhcp_get_option_long>
    2520:	1022d63a 	srli	r17,r2,24
    2524:	e0bffc03 	ldbu	r2,-16(fp)
    2528:	1085883a 	add	r2,r2,r2
    252c:	1085883a 	add	r2,r2,r2
    2530:	10800084 	addi	r2,r2,2
    2534:	e0fffe17 	ldw	r3,-8(fp)
    2538:	1885883a 	add	r2,r3,r2
    253c:	1009883a 	mov	r4,r2
    2540:	0004cd00 	call	4cd0 <dhcp_get_option_long>
    2544:	1004d23a 	srli	r2,r2,8
    2548:	10bfc00c 	andi	r2,r2,65280
    254c:	88a2b03a 	or	r17,r17,r2
    2550:	e0bffc03 	ldbu	r2,-16(fp)
    2554:	1085883a 	add	r2,r2,r2
    2558:	1085883a 	add	r2,r2,r2
    255c:	10800084 	addi	r2,r2,2
    2560:	e0fffe17 	ldw	r3,-8(fp)
    2564:	1885883a 	add	r2,r3,r2
    2568:	1009883a 	mov	r4,r2
    256c:	0004cd00 	call	4cd0 <dhcp_get_option_long>
    2570:	10bfc00c 	andi	r2,r2,65280
    2574:	1004923a 	slli	r2,r2,8
    2578:	88a2b03a 	or	r17,r17,r2
    257c:	e0bffc03 	ldbu	r2,-16(fp)
    2580:	1085883a 	add	r2,r2,r2
    2584:	1085883a 	add	r2,r2,r2
    2588:	10800084 	addi	r2,r2,2
    258c:	e0fffe17 	ldw	r3,-8(fp)
    2590:	1885883a 	add	r2,r3,r2
    2594:	1009883a 	mov	r4,r2
    2598:	0004cd00 	call	4cd0 <dhcp_get_option_long>
    259c:	1004963a 	slli	r2,r2,24
    25a0:	8886b03a 	or	r3,r17,r2
    25a4:	e13ffd17 	ldw	r4,-12(fp)
    25a8:	808003c4 	addi	r2,r16,15
    25ac:	1085883a 	add	r2,r2,r2
    25b0:	1085883a 	add	r2,r2,r2
    25b4:	2085883a 	add	r2,r4,r2
    25b8:	10c00015 	stw	r3,0(r2)
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
    for (n = 0; n < dhcp->dns_count; n++) {
    25bc:	e0bffc03 	ldbu	r2,-16(fp)
    25c0:	10800044 	addi	r2,r2,1
    25c4:	e0bffc05 	stb	r2,-16(fp)
    25c8:	e0fffc03 	ldbu	r3,-16(fp)
    25cc:	e0bffd17 	ldw	r2,-12(fp)
    25d0:	10800e17 	ldw	r2,56(r2)
    25d4:	18bfc936 	bltu	r3,r2,24fc <dhcp_handle_ack+0x320>
    }
#if LWIP_DNS
    dns_setserver( n, (struct ip_addr *)(&ip_addr_any));
#endif /* LWIP_DNS */
  }
}
    25d8:	e037883a 	mov	sp,fp
    25dc:	dfc00317 	ldw	ra,12(sp)
    25e0:	df000217 	ldw	fp,8(sp)
    25e4:	dc400117 	ldw	r17,4(sp)
    25e8:	dc000017 	ldw	r16,0(sp)
    25ec:	dec00404 	addi	sp,sp,16
    25f0:	f800283a 	ret

000025f4 <dhcp_start>:
 * - ERR_OK - No error
 * - ERR_MEM - Out of memory
 */
err_t
dhcp_start(struct netif *netif)
{
    25f4:	defffb04 	addi	sp,sp,-20
    25f8:	dfc00415 	stw	ra,16(sp)
    25fc:	df000315 	stw	fp,12(sp)
    2600:	df000304 	addi	fp,sp,12
    2604:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp;
  err_t result = ERR_OK;
    2608:	e03ffe05 	stb	zero,-8(fp)

  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
    260c:	e0bfff17 	ldw	r2,-4(fp)
    2610:	1000091e 	bne	r2,zero,2638 <dhcp_start+0x44>
    2614:	010000f4 	movhi	r4,3
    2618:	21352e04 	addi	r4,r4,-11080
    261c:	014000f4 	movhi	r5,3
    2620:	29753804 	addi	r5,r5,-11040
    2624:	01809304 	movi	r6,588
    2628:	01c000f4 	movhi	r7,3
    262c:	39f53c04 	addi	r7,r7,-11024
    2630:	00166c00 	call	166c0 <printf>
    2634:	003fff06 	br	2634 <dhcp_start+0x40>
  dhcp = netif->dhcp;
    2638:	e0bfff17 	ldw	r2,-4(fp)
    263c:	10800817 	ldw	r2,32(r2)
    2640:	e0bffd15 	stw	r2,-12(fp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Remove the flag that says this netif is handled by DHCP,
     it is set when we succeeded starting. */
  netif->flags &= ~NETIF_FLAG_DHCP;
    2644:	e0bfff17 	ldw	r2,-4(fp)
    2648:	10c00b43 	ldbu	r3,45(r2)
    264c:	00bffdc4 	movi	r2,-9
    2650:	1884703a 	and	r2,r3,r2
    2654:	1007883a 	mov	r3,r2
    2658:	e0bfff17 	ldw	r2,-4(fp)
    265c:	10c00b45 	stb	r3,45(r2)

  /* check MTU of the netif */
  if (netif->mtu < DHCP_MAX_MSG_LEN_MIN_REQUIRED) {
    2660:	e0bfff17 	ldw	r2,-4(fp)
    2664:	1080090b 	ldhu	r2,36(r2)
    2668:	10bfffcc 	andi	r2,r2,65535
    266c:	10809028 	cmpgeui	r2,r2,576
    2670:	1000021e 	bne	r2,zero,267c <dhcp_start+0x88>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): Cannot use this netif with DHCP: MTU is too small\n"));
    return ERR_MEM;
    2674:	00bfffc4 	movi	r2,-1
    2678:	00006a06 	br	2824 <dhcp_start+0x230>
  }

  /* no DHCP client attached yet? */
  if (dhcp == NULL) {
    267c:	e0bffd17 	ldw	r2,-12(fp)
    2680:	10000b1e 	bne	r2,zero,26b0 <dhcp_start+0xbc>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = mem_malloc(sizeof(struct dhcp));
    2684:	01001404 	movi	r4,80
    2688:	00088d00 	call	88d0 <mem_malloc>
    268c:	e0bffd15 	stw	r2,-12(fp)
    if (dhcp == NULL) {
    2690:	e0bffd17 	ldw	r2,-12(fp)
    2694:	1000021e 	bne	r2,zero,26a0 <dhcp_start+0xac>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
    2698:	00bfffc4 	movi	r2,-1
    269c:	00006106 	br	2824 <dhcp_start+0x230>
    }
    /* store this dhcp client in the netif */
    netif->dhcp = dhcp;
    26a0:	e0bfff17 	ldw	r2,-4(fp)
    26a4:	e0fffd17 	ldw	r3,-12(fp)
    26a8:	10c00815 	stw	r3,32(r2)
    26ac:	00002606 	br	2748 <dhcp_start+0x154>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): allocated dhcp"));
  /* already has DHCP client attached */
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(): restarting DHCP configuration\n"));
    if (dhcp->pcb != NULL) {
    26b0:	e0bffd17 	ldw	r2,-12(fp)
    26b4:	10800117 	ldw	r2,4(r2)
    26b8:	10000426 	beq	r2,zero,26cc <dhcp_start+0xd8>
      udp_remove(dhcp->pcb);
    26bc:	e0bffd17 	ldw	r2,-12(fp)
    26c0:	10800117 	ldw	r2,4(r2)
    26c4:	1009883a 	mov	r4,r2
    26c8:	00145980 	call	14598 <udp_remove>
    }
    LWIP_ASSERT("pbuf p_out wasn't freed", dhcp->p_out == NULL);
    26cc:	e0bffd17 	ldw	r2,-12(fp)
    26d0:	10800517 	ldw	r2,20(r2)
    26d4:	10000926 	beq	r2,zero,26fc <dhcp_start+0x108>
    26d8:	010000f4 	movhi	r4,3
    26dc:	21352e04 	addi	r4,r4,-11080
    26e0:	014000f4 	movhi	r5,3
    26e4:	29754204 	addi	r5,r5,-11000
    26e8:	01809a84 	movi	r6,618
    26ec:	01c000f4 	movhi	r7,3
    26f0:	39f53c04 	addi	r7,r7,-11024
    26f4:	00166c00 	call	166c0 <printf>
    26f8:	003fff06 	br	26f8 <dhcp_start+0x104>
    LWIP_ASSERT("reply wasn't freed", dhcp->msg_in == NULL &&
    26fc:	e0bffd17 	ldw	r2,-12(fp)
    2700:	10800217 	ldw	r2,8(r2)
    2704:	1000071e 	bne	r2,zero,2724 <dhcp_start+0x130>
    2708:	e0bffd17 	ldw	r2,-12(fp)
    270c:	10800317 	ldw	r2,12(r2)
    2710:	1000041e 	bne	r2,zero,2724 <dhcp_start+0x130>
    2714:	e0bffd17 	ldw	r2,-12(fp)
    2718:	1080040b 	ldhu	r2,16(r2)
    271c:	10bfffcc 	andi	r2,r2,65535
    2720:	10000926 	beq	r2,zero,2748 <dhcp_start+0x154>
    2724:	010000f4 	movhi	r4,3
    2728:	21352e04 	addi	r4,r4,-11080
    272c:	014000f4 	movhi	r5,3
    2730:	29754804 	addi	r5,r5,-10976
    2734:	01809b04 	movi	r6,620
    2738:	01c000f4 	movhi	r7,3
    273c:	39f53c04 	addi	r7,r7,-11024
    2740:	00166c00 	call	166c0 <printf>
    2744:	003fff06 	br	2744 <dhcp_start+0x150>
      dhcp->options_in == NULL && dhcp->options_in_len == 0);
  }
    
  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
    2748:	e13ffd17 	ldw	r4,-12(fp)
    274c:	000b883a 	mov	r5,zero
    2750:	01801404 	movi	r6,80
    2754:	00165b80 	call	165b8 <memset>
  /* allocate UDP PCB */
  dhcp->pcb = udp_new();
    2758:	00146340 	call	14634 <udp_new>
    275c:	e0fffd17 	ldw	r3,-12(fp)
    2760:	18800115 	stw	r2,4(r3)
  if (dhcp->pcb == NULL) {
    2764:	e0bffd17 	ldw	r2,-12(fp)
    2768:	10800117 	ldw	r2,4(r2)
    276c:	1000081e 	bne	r2,zero,2790 <dhcp_start+0x19c>
    LWIP_DEBUGF(DHCP_DEBUG  | LWIP_DBG_TRACE, ("dhcp_start(): could not obtain pcb\n"));
    mem_free((void *)dhcp);
    2770:	e13ffd17 	ldw	r4,-12(fp)
    2774:	000842c0 	call	842c <mem_free>
    netif->dhcp = dhcp = NULL;
    2778:	e03ffd15 	stw	zero,-12(fp)
    277c:	e0bfff17 	ldw	r2,-4(fp)
    2780:	e0fffd17 	ldw	r3,-12(fp)
    2784:	10c00815 	stw	r3,32(r2)
    return ERR_MEM;
    2788:	00bfffc4 	movi	r2,-1
    278c:	00002506 	br	2824 <dhcp_start+0x230>
  }
#if IP_SOF_BROADCAST
  dhcp->pcb->so_options|=SOF_BROADCAST;
#endif /* IP_SOF_BROADCAST */
  /* set up local and remote port for the pcb */
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
    2790:	e0bffd17 	ldw	r2,-12(fp)
    2794:	10800117 	ldw	r2,4(r2)
    2798:	1009883a 	mov	r4,r2
    279c:	014000f4 	movhi	r5,3
    27a0:	294d2104 	addi	r5,r5,13444
    27a4:	01801104 	movi	r6,68
    27a8:	00142740 	call	14274 <udp_bind>
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
    27ac:	e0bffd17 	ldw	r2,-12(fp)
    27b0:	10800117 	ldw	r2,4(r2)
    27b4:	1009883a 	mov	r4,r2
    27b8:	014000f4 	movhi	r5,3
    27bc:	294d2104 	addi	r5,r5,13444
    27c0:	018010c4 	movi	r6,67
    27c4:	00143dc0 	call	143dc <udp_connect>
  /* set up the recv callback and argument */
  udp_recv(dhcp->pcb, dhcp_recv, netif);
    27c8:	e0bffd17 	ldw	r2,-12(fp)
    27cc:	10800117 	ldw	r2,4(r2)
    27d0:	1009883a 	mov	r4,r2
    27d4:	01400034 	movhi	r5,0
    27d8:	294ff604 	addi	r5,r5,16344
    27dc:	e1bfff17 	ldw	r6,-4(fp)
    27e0:	00145580 	call	14558 <udp_recv>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));
  /* (re)start the DHCP negotiation */
  result = dhcp_discover(netif);
    27e4:	e13fff17 	ldw	r4,-4(fp)
    27e8:	0002ca40 	call	2ca4 <dhcp_discover>
    27ec:	e0bffe05 	stb	r2,-8(fp)
  if (result != ERR_OK) {
    27f0:	e0bffe07 	ldb	r2,-8(fp)
    27f4:	10000426 	beq	r2,zero,2808 <dhcp_start+0x214>
    /* free resources allocated above */
    dhcp_stop(netif);
    27f8:	e13fff17 	ldw	r4,-4(fp)
    27fc:	00038900 	call	3890 <dhcp_stop>
    return ERR_MEM;
    2800:	00bfffc4 	movi	r2,-1
    2804:	00000706 	br	2824 <dhcp_start+0x230>
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
    2808:	e0bfff17 	ldw	r2,-4(fp)
    280c:	10800b43 	ldbu	r2,45(r2)
    2810:	10800214 	ori	r2,r2,8
    2814:	1007883a 	mov	r3,r2
    2818:	e0bfff17 	ldw	r2,-4(fp)
    281c:	10c00b45 	stb	r3,45(r2)
  return result;
    2820:	e0bffe03 	ldbu	r2,-8(fp)
}
    2824:	e037883a 	mov	sp,fp
    2828:	dfc00117 	ldw	ra,4(sp)
    282c:	df000017 	ldw	fp,0(sp)
    2830:	dec00204 	addi	sp,sp,8
    2834:	f800283a 	ret

00002838 <dhcp_inform>:
 *
 * @param netif The lwIP network interface
 */
void
dhcp_inform(struct netif *netif)
{
    2838:	defff904 	addi	sp,sp,-28
    283c:	dfc00615 	stw	ra,24(sp)
    2840:	df000515 	stw	fp,20(sp)
    2844:	df000504 	addi	fp,sp,20
    2848:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp, *old_dhcp;
  err_t result = ERR_OK;
    284c:	e03ffc05 	stb	zero,-16(fp)
  dhcp = mem_malloc(sizeof(struct dhcp));
    2850:	01001404 	movi	r4,80
    2854:	00088d00 	call	88d0 <mem_malloc>
    2858:	e0bffd15 	stw	r2,-12(fp)
  if (dhcp == NULL) {
    285c:	e0bffd17 	ldw	r2,-12(fp)
    2860:	10005426 	beq	r2,zero,29b4 <dhcp_inform+0x17c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_inform(): could not allocate dhcp\n"));
    return;
  }
  memset(dhcp, 0, sizeof(struct dhcp));
    2864:	e13ffd17 	ldw	r4,-12(fp)
    2868:	000b883a 	mov	r5,zero
    286c:	01801404 	movi	r6,80
    2870:	00165b80 	call	165b8 <memset>

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): allocated dhcp\n"));
  dhcp->pcb = udp_new();
    2874:	00146340 	call	14634 <udp_new>
    2878:	e0fffd17 	ldw	r3,-12(fp)
    287c:	18800115 	stw	r2,4(r3)
  if (dhcp->pcb == NULL) {
    2880:	e0bffd17 	ldw	r2,-12(fp)
    2884:	10800117 	ldw	r2,4(r2)
    2888:	10004626 	beq	r2,zero,29a4 <dhcp_inform+0x16c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_inform(): could not obtain pcb"));
    goto free_dhcp_and_return;
  }
  old_dhcp = netif->dhcp;
    288c:	e0bfff17 	ldw	r2,-4(fp)
    2890:	10800817 	ldw	r2,32(r2)
    2894:	e0bffe15 	stw	r2,-8(fp)
  netif->dhcp = dhcp;
    2898:	e0bfff17 	ldw	r2,-4(fp)
    289c:	e0fffd17 	ldw	r3,-12(fp)
    28a0:	10c00815 	stw	r3,32(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): created new udp pcb\n"));
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
    28a4:	e13fff17 	ldw	r4,-4(fp)
    28a8:	00043380 	call	4338 <dhcp_create_request>
    28ac:	e0bffc05 	stb	r2,-16(fp)
  if (result == ERR_OK) {
    28b0:	e0bffc07 	ldb	r2,-16(fp)
    28b4:	1000311e 	bne	r2,zero,297c <dhcp_inform+0x144>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
    28b8:	e13ffd17 	ldw	r4,-12(fp)
    28bc:	01400d44 	movi	r5,53
    28c0:	01800044 	movi	r6,1
    28c4:	00039e40 	call	39e4 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_INFORM);
    28c8:	e13ffd17 	ldw	r4,-12(fp)
    28cc:	01400204 	movi	r5,8
    28d0:	0003ac80 	call	3ac8 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    28d4:	e13ffd17 	ldw	r4,-12(fp)
    28d8:	01400e44 	movi	r5,57
    28dc:	01800084 	movi	r6,2
    28e0:	00039e40 	call	39e4 <dhcp_option>
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
    28e4:	e0bfff17 	ldw	r2,-4(fp)
    28e8:	1080090b 	ldhu	r2,36(r2)
    28ec:	10bfffcc 	andi	r2,r2,65535
    28f0:	e13ffd17 	ldw	r4,-12(fp)
    28f4:	100b883a 	mov	r5,r2
    28f8:	0003b640 	call	3b64 <dhcp_option_short>

    dhcp_option_trailer(dhcp);
    28fc:	e13ffd17 	ldw	r4,-12(fp)
    2900:	00048f00 	call	48f0 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    2904:	e0bffd17 	ldw	r2,-12(fp)
    2908:	10c00517 	ldw	r3,20(r2)
    290c:	e0bffd17 	ldw	r2,-12(fp)
    2910:	1080070b 	ldhu	r2,28(r2)
    2914:	10803c04 	addi	r2,r2,240
    2918:	10bfffcc 	andi	r2,r2,65535
    291c:	1809883a 	mov	r4,r3
    2920:	100b883a 	mov	r5,r2
    2924:	0009cf00 	call	9cf0 <pbuf_realloc>

#if IP_SOF_BROADCAST
    dhcp->pcb->so_options|=SOF_BROADCAST;
#endif /* IP_SOF_BROADCAST */
    udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
    2928:	e0bffd17 	ldw	r2,-12(fp)
    292c:	10800117 	ldw	r2,4(r2)
    2930:	1009883a 	mov	r4,r2
    2934:	014000f4 	movhi	r5,3
    2938:	294d2104 	addi	r5,r5,13444
    293c:	01801104 	movi	r6,68
    2940:	00142740 	call	14274 <udp_bind>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_inform: INFORMING\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    2944:	e0bffd17 	ldw	r2,-12(fp)
    2948:	10c00117 	ldw	r3,4(r2)
    294c:	e0bffd17 	ldw	r2,-12(fp)
    2950:	10800517 	ldw	r2,20(r2)
    2954:	e13fff17 	ldw	r4,-4(fp)
    2958:	d9000015 	stw	r4,0(sp)
    295c:	1809883a 	mov	r4,r3
    2960:	100b883a 	mov	r5,r2
    2964:	018000f4 	movhi	r6,3
    2968:	318d2204 	addi	r6,r6,13448
    296c:	01c010c4 	movi	r7,67
    2970:	0013f940 	call	13f94 <udp_sendto_if>
    dhcp_delete_request(netif);
    2974:	e13fff17 	ldw	r4,-4(fp)
    2978:	00047d80 	call	47d8 <dhcp_delete_request>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  udp_remove(dhcp->pcb);
    297c:	e0bffd17 	ldw	r2,-12(fp)
    2980:	10800117 	ldw	r2,4(r2)
    2984:	1009883a 	mov	r4,r2
    2988:	00145980 	call	14598 <udp_remove>
  dhcp->pcb = NULL;
    298c:	e0bffd17 	ldw	r2,-12(fp)
    2990:	10000115 	stw	zero,4(r2)
  netif->dhcp = old_dhcp;
    2994:	e0bfff17 	ldw	r2,-4(fp)
    2998:	e0fffe17 	ldw	r3,-8(fp)
    299c:	10c00815 	stw	r3,32(r2)
    29a0:	00000106 	br	29a8 <dhcp_inform+0x170>

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): allocated dhcp\n"));
  dhcp->pcb = udp_new();
  if (dhcp->pcb == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_inform(): could not obtain pcb"));
    goto free_dhcp_and_return;
    29a4:	0001883a 	nop

  udp_remove(dhcp->pcb);
  dhcp->pcb = NULL;
  netif->dhcp = old_dhcp;
free_dhcp_and_return:
  mem_free((void *)dhcp);
    29a8:	e13ffd17 	ldw	r4,-12(fp)
    29ac:	000842c0 	call	842c <mem_free>
    29b0:	00000106 	br	29b8 <dhcp_inform+0x180>
  struct dhcp *dhcp, *old_dhcp;
  err_t result = ERR_OK;
  dhcp = mem_malloc(sizeof(struct dhcp));
  if (dhcp == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_inform(): could not allocate dhcp\n"));
    return;
    29b4:	0001883a 	nop
  udp_remove(dhcp->pcb);
  dhcp->pcb = NULL;
  netif->dhcp = old_dhcp;
free_dhcp_and_return:
  mem_free((void *)dhcp);
}
    29b8:	e037883a 	mov	sp,fp
    29bc:	dfc00117 	ldw	ra,4(sp)
    29c0:	df000017 	ldw	fp,0(sp)
    29c4:	dec00204 	addi	sp,sp,8
    29c8:	f800283a 	ret

000029cc <dhcp_network_changed>:
 * This enters the REBOOTING state to verify that the currently bound
 * address is still valid.
 */
void
dhcp_network_changed(struct netif *netif)
{
    29cc:	defffc04 	addi	sp,sp,-16
    29d0:	dfc00315 	stw	ra,12(sp)
    29d4:	df000215 	stw	fp,8(sp)
    29d8:	df000204 	addi	fp,sp,8
    29dc:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    29e0:	e0bfff17 	ldw	r2,-4(fp)
    29e4:	10800817 	ldw	r2,32(r2)
    29e8:	e0bffe15 	stw	r2,-8(fp)
  if (!dhcp)
    29ec:	e0bffe17 	ldw	r2,-8(fp)
    29f0:	10001b26 	beq	r2,zero,2a60 <dhcp_network_changed+0x94>
    return;
  switch (dhcp->state) {
    29f4:	e0bffe17 	ldw	r2,-8(fp)
    29f8:	10800483 	ldbu	r2,18(r2)
    29fc:	10803fcc 	andi	r2,r2,255
    2a00:	10c002a0 	cmpeqi	r3,r2,10
    2a04:	1800091e 	bne	r3,zero,2a2c <dhcp_network_changed+0x60>
    2a08:	10c002c8 	cmpgei	r3,r2,11
    2a0c:	1800041e 	bne	r3,zero,2a20 <dhcp_network_changed+0x54>
    2a10:	10bfff44 	addi	r2,r2,-3
    2a14:	108000e8 	cmpgeui	r2,r2,3
    2a18:	10000b1e 	bne	r2,zero,2a48 <dhcp_network_changed+0x7c>
    2a1c:	00000306 	br	2a2c <dhcp_network_changed+0x60>
    2a20:	10800360 	cmpeqi	r2,r2,13
    2a24:	1000101e 	bne	r2,zero,2a68 <dhcp_network_changed+0x9c>
    2a28:	00000706 	br	2a48 <dhcp_network_changed+0x7c>
  case DHCP_REBINDING:
  case DHCP_RENEWING:
  case DHCP_BOUND:
  case DHCP_REBOOTING:
    netif_set_down(netif);
    2a2c:	e13fff17 	ldw	r4,-4(fp)
    2a30:	000972c0 	call	972c <netif_set_down>
    dhcp->tries = 0;
    2a34:	e0bffe17 	ldw	r2,-8(fp)
    2a38:	100004c5 	stb	zero,19(r2)
    dhcp_reboot(netif);
    2a3c:	e13fff17 	ldw	r4,-4(fp)
    2a40:	00034fc0 	call	34fc <dhcp_reboot>
    break;
    2a44:	00000906 	br	2a6c <dhcp_network_changed+0xa0>
  case DHCP_OFF:
    /* stay off */
    break;
  default:
    dhcp->tries = 0;
    2a48:	e0bffe17 	ldw	r2,-8(fp)
    2a4c:	100004c5 	stb	zero,19(r2)
    dhcp_discover(netif);
    2a50:	e13fff17 	ldw	r4,-4(fp)
    2a54:	0002ca40 	call	2ca4 <dhcp_discover>
    break;
    2a58:	0001883a 	nop
    2a5c:	00000306 	br	2a6c <dhcp_network_changed+0xa0>
void
dhcp_network_changed(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  if (!dhcp)
    return;
    2a60:	0001883a 	nop
    2a64:	00000106 	br	2a6c <dhcp_network_changed+0xa0>
    dhcp->tries = 0;
    dhcp_reboot(netif);
    break;
  case DHCP_OFF:
    /* stay off */
    break;
    2a68:	0001883a 	nop
  default:
    dhcp->tries = 0;
    dhcp_discover(netif);
    break;
  }
}
    2a6c:	e037883a 	mov	sp,fp
    2a70:	dfc00117 	ldw	ra,4(sp)
    2a74:	df000017 	ldw	fp,0(sp)
    2a78:	dec00204 	addi	sp,sp,8
    2a7c:	f800283a 	ret

00002a80 <dhcp_arp_reply>:
 *
 * @param netif the network interface on which the reply was received
 * @param addr The IP address we received a reply from
 */
void dhcp_arp_reply(struct netif *netif, struct ip_addr *addr)
{
    2a80:	defffc04 	addi	sp,sp,-16
    2a84:	dfc00315 	stw	ra,12(sp)
    2a88:	df000215 	stw	fp,8(sp)
    2a8c:	df000204 	addi	fp,sp,8
    2a90:	e13ffe15 	stw	r4,-8(fp)
    2a94:	e17fff15 	stw	r5,-4(fp)
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
    2a98:	e0bffe17 	ldw	r2,-8(fp)
    2a9c:	1000091e 	bne	r2,zero,2ac4 <dhcp_arp_reply+0x44>
    2aa0:	010000f4 	movhi	r4,3
    2aa4:	21352e04 	addi	r4,r4,-11080
    2aa8:	014000f4 	movhi	r5,3
    2aac:	29753804 	addi	r5,r5,-11040
    2ab0:	0180bcc4 	movi	r6,755
    2ab4:	01c000f4 	movhi	r7,3
    2ab8:	39f53c04 	addi	r7,r7,-11024
    2abc:	00166c00 	call	166c0 <printf>
    2ac0:	003fff06 	br	2ac0 <dhcp_arp_reply+0x40>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_arp_reply()\n"));
  /* is a DHCP client doing an ARP check? */
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
    2ac4:	e0bffe17 	ldw	r2,-8(fp)
    2ac8:	10800817 	ldw	r2,32(r2)
    2acc:	10001226 	beq	r2,zero,2b18 <dhcp_arp_reply+0x98>
    2ad0:	e0bffe17 	ldw	r2,-8(fp)
    2ad4:	10800817 	ldw	r2,32(r2)
    2ad8:	10800483 	ldbu	r2,18(r2)
    2adc:	10803fcc 	andi	r2,r2,255
    2ae0:	10800218 	cmpnei	r2,r2,8
    2ae4:	10000c1e 	bne	r2,zero,2b18 <dhcp_arp_reply+0x98>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08"X32_F"\n", addr->addr));
    /* did a host respond with the address we
       were offered by the DHCP server? */
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
    2ae8:	e0bfff17 	ldw	r2,-4(fp)
    2aec:	10c0000b 	ldhu	r3,0(r2)
    2af0:	1080008b 	ldhu	r2,2(r2)
    2af4:	1004943a 	slli	r2,r2,16
    2af8:	10c4b03a 	or	r2,r2,r3
    2afc:	1007883a 	mov	r3,r2
    2b00:	e0bffe17 	ldw	r2,-8(fp)
    2b04:	10800817 	ldw	r2,32(r2)
    2b08:	10800a17 	ldw	r2,40(r2)
    2b0c:	1880021e 	bne	r3,r2,2b18 <dhcp_arp_reply+0x98>
      /* we will not accept the offered address */
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | LWIP_DBG_LEVEL_WARNING,
        ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));
      dhcp_decline(netif);
    2b10:	e13ffe17 	ldw	r4,-8(fp)
    2b14:	0002b2c0 	call	2b2c <dhcp_decline>
    }
  }
}
    2b18:	e037883a 	mov	sp,fp
    2b1c:	dfc00117 	ldw	ra,4(sp)
    2b20:	df000017 	ldw	fp,0(sp)
    2b24:	dec00204 	addi	sp,sp,8
    2b28:	f800283a 	ret

00002b2c <dhcp_decline>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_decline(struct netif *netif)
{
    2b2c:	defffa04 	addi	sp,sp,-24
    2b30:	dfc00515 	stw	ra,20(sp)
    2b34:	df000415 	stw	fp,16(sp)
    2b38:	df000404 	addi	fp,sp,16
    2b3c:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    2b40:	e0bfff17 	ldw	r2,-4(fp)
    2b44:	10800817 	ldw	r2,32(r2)
    2b48:	e0bffd15 	stw	r2,-12(fp)
  err_t result = ERR_OK;
    2b4c:	e03ffe05 	stb	zero,-8(fp)
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline()\n"));
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
    2b50:	e13ffd17 	ldw	r4,-12(fp)
    2b54:	01400304 	movi	r5,12
    2b58:	00039940 	call	3994 <dhcp_set_state>
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
    2b5c:	e13fff17 	ldw	r4,-4(fp)
    2b60:	00043380 	call	4338 <dhcp_create_request>
    2b64:	e0bffe05 	stb	r2,-8(fp)
  if (result == ERR_OK) {
    2b68:	e0bffe07 	ldb	r2,-8(fp)
    2b6c:	1000381e 	bne	r2,zero,2c50 <dhcp_decline+0x124>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
    2b70:	e13ffd17 	ldw	r4,-12(fp)
    2b74:	01400d44 	movi	r5,53
    2b78:	01800044 	movi	r6,1
    2b7c:	00039e40 	call	39e4 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DECLINE);
    2b80:	e13ffd17 	ldw	r4,-12(fp)
    2b84:	01400104 	movi	r5,4
    2b88:	0003ac80 	call	3ac8 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
    2b8c:	e13ffd17 	ldw	r4,-12(fp)
    2b90:	01400c84 	movi	r5,50
    2b94:	01800104 	movi	r6,4
    2b98:	00039e40 	call	39e4 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
    2b9c:	e0bffd17 	ldw	r2,-12(fp)
    2ba0:	10800a17 	ldw	r2,40(r2)
    2ba4:	1006d63a 	srli	r3,r2,24
    2ba8:	e0bffd17 	ldw	r2,-12(fp)
    2bac:	10800a17 	ldw	r2,40(r2)
    2bb0:	1004d23a 	srli	r2,r2,8
    2bb4:	10bfc00c 	andi	r2,r2,65280
    2bb8:	1886b03a 	or	r3,r3,r2
    2bbc:	e0bffd17 	ldw	r2,-12(fp)
    2bc0:	10800a17 	ldw	r2,40(r2)
    2bc4:	10bfc00c 	andi	r2,r2,65280
    2bc8:	1004923a 	slli	r2,r2,8
    2bcc:	1886b03a 	or	r3,r3,r2
    2bd0:	e0bffd17 	ldw	r2,-12(fp)
    2bd4:	10800a17 	ldw	r2,40(r2)
    2bd8:	1004963a 	slli	r2,r2,24
    2bdc:	1884b03a 	or	r2,r3,r2
    2be0:	e13ffd17 	ldw	r4,-12(fp)
    2be4:	100b883a 	mov	r5,r2
    2be8:	0003c3c0 	call	3c3c <dhcp_option_long>

    dhcp_option_trailer(dhcp);
    2bec:	e13ffd17 	ldw	r4,-12(fp)
    2bf0:	00048f00 	call	48f0 <dhcp_option_trailer>
    /* resize pbuf to reflect true size of options */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    2bf4:	e0bffd17 	ldw	r2,-12(fp)
    2bf8:	10c00517 	ldw	r3,20(r2)
    2bfc:	e0bffd17 	ldw	r2,-12(fp)
    2c00:	1080070b 	ldhu	r2,28(r2)
    2c04:	10803c04 	addi	r2,r2,240
    2c08:	10bfffcc 	andi	r2,r2,65535
    2c0c:	1809883a 	mov	r4,r3
    2c10:	100b883a 	mov	r5,r2
    2c14:	0009cf00 	call	9cf0 <pbuf_realloc>

    /* per section 4.4.4, broadcast DECLINE messages */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    2c18:	e0bffd17 	ldw	r2,-12(fp)
    2c1c:	10c00117 	ldw	r3,4(r2)
    2c20:	e0bffd17 	ldw	r2,-12(fp)
    2c24:	10800517 	ldw	r2,20(r2)
    2c28:	e13fff17 	ldw	r4,-4(fp)
    2c2c:	d9000015 	stw	r4,0(sp)
    2c30:	1809883a 	mov	r4,r3
    2c34:	100b883a 	mov	r5,r2
    2c38:	018000f4 	movhi	r6,3
    2c3c:	318d2204 	addi	r6,r6,13448
    2c40:	01c010c4 	movi	r7,67
    2c44:	0013f940 	call	13f94 <udp_sendto_if>
    dhcp_delete_request(netif);
    2c48:	e13fff17 	ldw	r4,-4(fp)
    2c4c:	00047d80 	call	47d8 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("dhcp_decline: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
    2c50:	e0bffd17 	ldw	r2,-12(fp)
    2c54:	108004c3 	ldbu	r2,19(r2)
    2c58:	10800044 	addi	r2,r2,1
    2c5c:	1007883a 	mov	r3,r2
    2c60:	e0bffd17 	ldw	r2,-12(fp)
    2c64:	10c004c5 	stb	r3,19(r2)
  msecs = 10*1000;
    2c68:	0089c404 	movi	r2,10000
    2c6c:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    2c70:	e0bffe8b 	ldhu	r2,-6(fp)
    2c74:	10c07cc4 	addi	r3,r2,499
    2c78:	00807d04 	movi	r2,500
    2c7c:	1885283a 	div	r2,r3,r2
    2c80:	1007883a 	mov	r3,r2
    2c84:	e0bffd17 	ldw	r2,-12(fp)
    2c88:	10c0078d 	sth	r3,30(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
    2c8c:	e0bffe03 	ldbu	r2,-8(fp)
}
    2c90:	e037883a 	mov	sp,fp
    2c94:	dfc00117 	ldw	ra,4(sp)
    2c98:	df000017 	ldw	fp,0(sp)
    2c9c:	dec00204 	addi	sp,sp,8
    2ca0:	f800283a 	ret

00002ca4 <dhcp_discover>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
    2ca4:	defffa04 	addi	sp,sp,-24
    2ca8:	dfc00515 	stw	ra,20(sp)
    2cac:	df000415 	stw	fp,16(sp)
    2cb0:	df000404 	addi	fp,sp,16
    2cb4:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    2cb8:	e0bfff17 	ldw	r2,-4(fp)
    2cbc:	10800817 	ldw	r2,32(r2)
    2cc0:	e0bffd15 	stw	r2,-12(fp)
  err_t result = ERR_OK;
    2cc4:	e03ffe05 	stb	zero,-8(fp)
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover()\n"));
  ip_addr_set(&dhcp->offered_ip_addr, IP_ADDR_ANY);
    2cc8:	008000f4 	movhi	r2,3
    2ccc:	108d2104 	addi	r2,r2,13444
    2cd0:	10c0000b 	ldhu	r3,0(r2)
    2cd4:	1080008b 	ldhu	r2,2(r2)
    2cd8:	1004943a 	slli	r2,r2,16
    2cdc:	10c4b03a 	or	r2,r2,r3
    2ce0:	1007883a 	mov	r3,r2
    2ce4:	e0bffd17 	ldw	r2,-12(fp)
    2ce8:	10c00a15 	stw	r3,40(r2)
  dhcp_set_state(dhcp, DHCP_SELECTING);
    2cec:	e13ffd17 	ldw	r4,-12(fp)
    2cf0:	01400184 	movi	r5,6
    2cf4:	00039940 	call	3994 <dhcp_set_state>
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
    2cf8:	e13fff17 	ldw	r4,-4(fp)
    2cfc:	00043380 	call	4338 <dhcp_create_request>
    2d00:	e0bffe05 	stb	r2,-8(fp)
  if (result == ERR_OK) {
    2d04:	e0bffe07 	ldb	r2,-8(fp)
    2d08:	10003a1e 	bne	r2,zero,2df4 <dhcp_discover+0x150>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
    2d0c:	e13ffd17 	ldw	r4,-12(fp)
    2d10:	01400d44 	movi	r5,53
    2d14:	01800044 	movi	r6,1
    2d18:	00039e40 	call	39e4 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DISCOVER);
    2d1c:	e13ffd17 	ldw	r4,-12(fp)
    2d20:	01400044 	movi	r5,1
    2d24:	0003ac80 	call	3ac8 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    2d28:	e13ffd17 	ldw	r4,-12(fp)
    2d2c:	01400e44 	movi	r5,57
    2d30:	01800084 	movi	r6,2
    2d34:	00039e40 	call	39e4 <dhcp_option>
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
    2d38:	e0bfff17 	ldw	r2,-4(fp)
    2d3c:	1080090b 	ldhu	r2,36(r2)
    2d40:	10bfffcc 	andi	r2,r2,65535
    2d44:	e13ffd17 	ldw	r4,-12(fp)
    2d48:	100b883a 	mov	r5,r2
    2d4c:	0003b640 	call	3b64 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
    2d50:	e13ffd17 	ldw	r4,-12(fp)
    2d54:	01400dc4 	movi	r5,55
    2d58:	01800104 	movi	r6,4
    2d5c:	00039e40 	call	39e4 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
    2d60:	e13ffd17 	ldw	r4,-12(fp)
    2d64:	01400044 	movi	r5,1
    2d68:	0003ac80 	call	3ac8 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
    2d6c:	e13ffd17 	ldw	r4,-12(fp)
    2d70:	014000c4 	movi	r5,3
    2d74:	0003ac80 	call	3ac8 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
    2d78:	e13ffd17 	ldw	r4,-12(fp)
    2d7c:	01400704 	movi	r5,28
    2d80:	0003ac80 	call	3ac8 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
    2d84:	e13ffd17 	ldw	r4,-12(fp)
    2d88:	01400184 	movi	r5,6
    2d8c:	0003ac80 	call	3ac8 <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
    2d90:	e13ffd17 	ldw	r4,-12(fp)
    2d94:	00048f00 	call	48f0 <dhcp_option_trailer>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: realloc()ing\n"));
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    2d98:	e0bffd17 	ldw	r2,-12(fp)
    2d9c:	10c00517 	ldw	r3,20(r2)
    2da0:	e0bffd17 	ldw	r2,-12(fp)
    2da4:	1080070b 	ldhu	r2,28(r2)
    2da8:	10803c04 	addi	r2,r2,240
    2dac:	10bfffcc 	andi	r2,r2,65535
    2db0:	1809883a 	mov	r4,r3
    2db4:	100b883a 	mov	r5,r2
    2db8:	0009cf00 	call	9cf0 <pbuf_realloc>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, DHCP_SERVER_PORT)\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    2dbc:	e0bffd17 	ldw	r2,-12(fp)
    2dc0:	10c00117 	ldw	r3,4(r2)
    2dc4:	e0bffd17 	ldw	r2,-12(fp)
    2dc8:	10800517 	ldw	r2,20(r2)
    2dcc:	e13fff17 	ldw	r4,-4(fp)
    2dd0:	d9000015 	stw	r4,0(sp)
    2dd4:	1809883a 	mov	r4,r3
    2dd8:	100b883a 	mov	r5,r2
    2ddc:	018000f4 	movhi	r6,3
    2de0:	318d2204 	addi	r6,r6,13448
    2de4:	01c010c4 	movi	r7,67
    2de8:	0013f940 	call	13f94 <udp_sendto_if>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()ing\n"));
    dhcp_delete_request(netif);
    2dec:	e13fff17 	ldw	r4,-4(fp)
    2df0:	00047d80 	call	47d8 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_discover: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
    2df4:	e0bffd17 	ldw	r2,-12(fp)
    2df8:	108004c3 	ldbu	r2,19(r2)
    2dfc:	10800044 	addi	r2,r2,1
    2e00:	1007883a 	mov	r3,r2
    2e04:	e0bffd17 	ldw	r2,-12(fp)
    2e08:	10c004c5 	stb	r3,19(r2)
  if(dhcp->tries >= LWIP_DHCP_AUTOIP_COOP_TRIES && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */
  msecs = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
    2e0c:	e0bffd17 	ldw	r2,-12(fp)
    2e10:	108004c3 	ldbu	r2,19(r2)
    2e14:	10803fcc 	andi	r2,r2,255
    2e18:	108001a8 	cmpgeui	r2,r2,6
    2e1c:	1000061e 	bne	r2,zero,2e38 <dhcp_discover+0x194>
    2e20:	e0bffd17 	ldw	r2,-12(fp)
    2e24:	108004c3 	ldbu	r2,19(r2)
    2e28:	10803fcc 	andi	r2,r2,255
    2e2c:	00c0fa04 	movi	r3,1000
    2e30:	1884983a 	sll	r2,r3,r2
    2e34:	00000106 	br	2e3c <dhcp_discover+0x198>
    2e38:	00ba9804 	movi	r2,-5536
    2e3c:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    2e40:	e0bffe8b 	ldhu	r2,-6(fp)
    2e44:	10c07cc4 	addi	r3,r2,499
    2e48:	00807d04 	movi	r2,500
    2e4c:	1885283a 	div	r2,r3,r2
    2e50:	1007883a 	mov	r3,r2
    2e54:	e0bffd17 	ldw	r2,-12(fp)
    2e58:	10c0078d 	sth	r3,30(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
    2e5c:	e0bffe03 	ldbu	r2,-8(fp)
}
    2e60:	e037883a 	mov	sp,fp
    2e64:	dfc00117 	ldw	ra,4(sp)
    2e68:	df000017 	ldw	fp,0(sp)
    2e6c:	dec00204 	addi	sp,sp,8
    2e70:	f800283a 	ret

00002e74 <dhcp_bind>:
 *
 * @param netif network interface to bind to the offered address
 */
static void
dhcp_bind(struct netif *netif)
{
    2e74:	defff804 	addi	sp,sp,-32
    2e78:	dfc00715 	stw	ra,28(sp)
    2e7c:	df000615 	stw	fp,24(sp)
    2e80:	df000604 	addi	fp,sp,24
    2e84:	e13fff15 	stw	r4,-4(fp)
  u32_t timeout;
  struct dhcp *dhcp;
  struct ip_addr sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
    2e88:	e0bfff17 	ldw	r2,-4(fp)
    2e8c:	1000091e 	bne	r2,zero,2eb4 <dhcp_bind+0x40>
    2e90:	010000f4 	movhi	r4,3
    2e94:	21352e04 	addi	r4,r4,-11080
    2e98:	014000f4 	movhi	r5,3
    2e9c:	29754d04 	addi	r5,r5,-10956
    2ea0:	0180dd84 	movi	r6,886
    2ea4:	01c000f4 	movhi	r7,3
    2ea8:	39f53c04 	addi	r7,r7,-11024
    2eac:	00166c00 	call	166c0 <printf>
    2eb0:	003fff06 	br	2eb0 <dhcp_bind+0x3c>
  dhcp = netif->dhcp;
    2eb4:	e0bfff17 	ldw	r2,-4(fp)
    2eb8:	10800817 	ldw	r2,32(r2)
    2ebc:	e0bffb15 	stw	r2,-20(fp)
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
    2ec0:	e0bffb17 	ldw	r2,-20(fp)
    2ec4:	1000091e 	bne	r2,zero,2eec <dhcp_bind+0x78>
    2ec8:	010000f4 	movhi	r4,3
    2ecc:	21352e04 	addi	r4,r4,-11080
    2ed0:	014000f4 	movhi	r5,3
    2ed4:	29755404 	addi	r5,r5,-10928
    2ed8:	0180de04 	movi	r6,888
    2edc:	01c000f4 	movhi	r7,3
    2ee0:	39f53c04 	addi	r7,r7,-11024
    2ee4:	00166c00 	call	166c0 <printf>
    2ee8:	003fff06 	br	2ee8 <dhcp_bind+0x74>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* temporary DHCP lease? */
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
    2eec:	e0bffb17 	ldw	r2,-20(fp)
    2ef0:	10801217 	ldw	r2,72(r2)
    2ef4:	10bfffe0 	cmpeqi	r2,r2,-1
    2ef8:	1000161e 	bne	r2,zero,2f54 <dhcp_bind+0xe0>
    /* set renewal period timer */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t1 renewal timer %"U32_F" secs\n", dhcp->offered_t1_renew));
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
    2efc:	e0bffb17 	ldw	r2,-20(fp)
    2f00:	10801217 	ldw	r2,72(r2)
    2f04:	10c00784 	addi	r3,r2,30
    2f08:	00800f04 	movi	r2,60
    2f0c:	1885203a 	divu	r2,r3,r2
    2f10:	e0bffa15 	stw	r2,-24(fp)
    if(timeout > 0xffff) {
    2f14:	e0bffa17 	ldw	r2,-24(fp)
    2f18:	00ffffd4 	movui	r3,65535
    2f1c:	1880022e 	bgeu	r3,r2,2f28 <dhcp_bind+0xb4>
      timeout = 0xffff;
    2f20:	00bfffd4 	movui	r2,65535
    2f24:	e0bffa15 	stw	r2,-24(fp)
    }
    dhcp->t1_timeout = (u16_t)timeout;
    2f28:	e0bffa17 	ldw	r2,-24(fp)
    2f2c:	1007883a 	mov	r3,r2
    2f30:	e0bffb17 	ldw	r2,-20(fp)
    2f34:	10c0080d 	sth	r3,32(r2)
    if (dhcp->t1_timeout == 0) {
    2f38:	e0bffb17 	ldw	r2,-20(fp)
    2f3c:	1080080b 	ldhu	r2,32(r2)
    2f40:	10bfffcc 	andi	r2,r2,65535
    2f44:	1000031e 	bne	r2,zero,2f54 <dhcp_bind+0xe0>
      dhcp->t1_timeout = 1;
    2f48:	e0bffb17 	ldw	r2,-20(fp)
    2f4c:	00c00044 	movi	r3,1
    2f50:	10c0080d 	sth	r3,32(r2)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew*1000));
  }
  /* set renewal period timer */
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
    2f54:	e0bffb17 	ldw	r2,-20(fp)
    2f58:	10801317 	ldw	r2,76(r2)
    2f5c:	10bfffe0 	cmpeqi	r2,r2,-1
    2f60:	1000161e 	bne	r2,zero,2fbc <dhcp_bind+0x148>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
    2f64:	e0bffb17 	ldw	r2,-20(fp)
    2f68:	10801317 	ldw	r2,76(r2)
    2f6c:	10c00784 	addi	r3,r2,30
    2f70:	00800f04 	movi	r2,60
    2f74:	1885203a 	divu	r2,r3,r2
    2f78:	e0bffa15 	stw	r2,-24(fp)
    if(timeout > 0xffff) {
    2f7c:	e0bffa17 	ldw	r2,-24(fp)
    2f80:	00ffffd4 	movui	r3,65535
    2f84:	1880022e 	bgeu	r3,r2,2f90 <dhcp_bind+0x11c>
      timeout = 0xffff;
    2f88:	00bfffd4 	movui	r2,65535
    2f8c:	e0bffa15 	stw	r2,-24(fp)
    }
    dhcp->t2_timeout = (u16_t)timeout;
    2f90:	e0bffa17 	ldw	r2,-24(fp)
    2f94:	1007883a 	mov	r3,r2
    2f98:	e0bffb17 	ldw	r2,-20(fp)
    2f9c:	10c0088d 	sth	r3,34(r2)
    if (dhcp->t2_timeout == 0) {
    2fa0:	e0bffb17 	ldw	r2,-20(fp)
    2fa4:	1080088b 	ldhu	r2,34(r2)
    2fa8:	10bfffcc 	andi	r2,r2,65535
    2fac:	1000031e 	bne	r2,zero,2fbc <dhcp_bind+0x148>
      dhcp->t2_timeout = 1;
    2fb0:	e0bffb17 	ldw	r2,-20(fp)
    2fb4:	00c00044 	movi	r3,1
    2fb8:	10c0088d 	sth	r3,34(r2)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
    2fbc:	e0bffb17 	ldw	r2,-20(fp)
    2fc0:	10800b04 	addi	r2,r2,44
    2fc4:	10000326 	beq	r2,zero,2fd4 <dhcp_bind+0x160>
    2fc8:	e0bffb17 	ldw	r2,-20(fp)
    2fcc:	10800b17 	ldw	r2,44(r2)
    2fd0:	00000106 	br	2fd8 <dhcp_bind+0x164>
    2fd4:	0005883a 	mov	r2,zero
    2fd8:	10ffffcc 	andi	r3,r2,65535
    2fdc:	e13ffc8b 	ldhu	r4,-14(fp)
    2fe0:	2008703a 	and	r4,r4,zero
    2fe4:	20c6b03a 	or	r3,r4,r3
    2fe8:	e0fffc8d 	sth	r3,-14(fp)
    2fec:	1004d43a 	srli	r2,r2,16
    2ff0:	e0fffd0b 	ldhu	r3,-12(fp)
    2ff4:	1806703a 	and	r3,r3,zero
    2ff8:	1884b03a 	or	r2,r3,r2
    2ffc:	e0bffd0d 	sth	r2,-12(fp)

  /* subnet mask not given? */
  /* TODO: this is not a valid check. what if the network mask is 0? */
  if (sn_mask.addr == 0) {
    3000:	e0bffc8b 	ldhu	r2,-14(fp)
    3004:	e0fffd0b 	ldhu	r3,-12(fp)
    3008:	1806943a 	slli	r3,r3,16
    300c:	1884b03a 	or	r2,r3,r2
    3010:	10003b1e 	bne	r2,zero,3100 <dhcp_bind+0x28c>
    /* choose a safe subnet mask given the network class */
    u8_t first_octet = ip4_addr1(&sn_mask);
    3014:	e0bffc8b 	ldhu	r2,-14(fp)
    3018:	e0fffd0b 	ldhu	r3,-12(fp)
    301c:	1806943a 	slli	r3,r3,16
    3020:	1884b03a 	or	r2,r3,r2
    3024:	1006d63a 	srli	r3,r2,24
    3028:	e0bffc8b 	ldhu	r2,-14(fp)
    302c:	e13ffd0b 	ldhu	r4,-12(fp)
    3030:	2008943a 	slli	r4,r4,16
    3034:	2084b03a 	or	r2,r4,r2
    3038:	1004d23a 	srli	r2,r2,8
    303c:	10bfc00c 	andi	r2,r2,65280
    3040:	1886b03a 	or	r3,r3,r2
    3044:	e0bffc8b 	ldhu	r2,-14(fp)
    3048:	e13ffd0b 	ldhu	r4,-12(fp)
    304c:	2008943a 	slli	r4,r4,16
    3050:	2084b03a 	or	r2,r4,r2
    3054:	10bfc00c 	andi	r2,r2,65280
    3058:	1004923a 	slli	r2,r2,8
    305c:	1886b03a 	or	r3,r3,r2
    3060:	e0bffc8b 	ldhu	r2,-14(fp)
    3064:	e13ffd0b 	ldhu	r4,-12(fp)
    3068:	2008943a 	slli	r4,r4,16
    306c:	2084b03a 	or	r2,r4,r2
    3070:	1004963a 	slli	r2,r2,24
    3074:	1884b03a 	or	r2,r3,r2
    3078:	1004d63a 	srli	r2,r2,24
    307c:	e0bffc05 	stb	r2,-16(fp)
    if (first_octet <= 127) {
    3080:	e0bffc03 	ldbu	r2,-16(fp)
    3084:	10803fcc 	andi	r2,r2,255
    3088:	1080201c 	xori	r2,r2,128
    308c:	10bfe004 	addi	r2,r2,-128
    3090:	10000816 	blt	r2,zero,30b4 <dhcp_bind+0x240>
      sn_mask.addr = htonl(0xff000000);
    3094:	e0bffc8b 	ldhu	r2,-14(fp)
    3098:	1004703a 	and	r2,r2,zero
    309c:	10803fd4 	ori	r2,r2,255
    30a0:	e0bffc8d 	sth	r2,-14(fp)
    30a4:	e0bffd0b 	ldhu	r2,-12(fp)
    30a8:	1004703a 	and	r2,r2,zero
    30ac:	e0bffd0d 	sth	r2,-12(fp)
    30b0:	00001306 	br	3100 <dhcp_bind+0x28c>
    } else if (first_octet >= 192) {
    30b4:	e0bffc03 	ldbu	r2,-16(fp)
    30b8:	10803030 	cmpltui	r2,r2,192
    30bc:	1000091e 	bne	r2,zero,30e4 <dhcp_bind+0x270>
      sn_mask.addr = htonl(0xffffff00);
    30c0:	e0fffc8b 	ldhu	r3,-14(fp)
    30c4:	00bfffc4 	movi	r2,-1
    30c8:	1884b03a 	or	r2,r3,r2
    30cc:	e0bffc8d 	sth	r2,-14(fp)
    30d0:	e0bffd0b 	ldhu	r2,-12(fp)
    30d4:	1004703a 	and	r2,r2,zero
    30d8:	10803fd4 	ori	r2,r2,255
    30dc:	e0bffd0d 	sth	r2,-12(fp)
    30e0:	00000706 	br	3100 <dhcp_bind+0x28c>
    } else {
      sn_mask.addr = htonl(0xffff0000);
    30e4:	e0fffc8b 	ldhu	r3,-14(fp)
    30e8:	00bfffc4 	movi	r2,-1
    30ec:	1884b03a 	or	r2,r3,r2
    30f0:	e0bffc8d 	sth	r2,-14(fp)
    30f4:	e0bffd0b 	ldhu	r2,-12(fp)
    30f8:	1004703a 	and	r2,r2,zero
    30fc:	e0bffd0d 	sth	r2,-12(fp)
    }
  }

  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
    3100:	e0bffb17 	ldw	r2,-20(fp)
    3104:	10800c04 	addi	r2,r2,48
    3108:	10000326 	beq	r2,zero,3118 <dhcp_bind+0x2a4>
    310c:	e0bffb17 	ldw	r2,-20(fp)
    3110:	10800c17 	ldw	r2,48(r2)
    3114:	00000106 	br	311c <dhcp_bind+0x2a8>
    3118:	0005883a 	mov	r2,zero
    311c:	10ffffcc 	andi	r3,r2,65535
    3120:	e13ffd8b 	ldhu	r4,-10(fp)
    3124:	2008703a 	and	r4,r4,zero
    3128:	20c6b03a 	or	r3,r4,r3
    312c:	e0fffd8d 	sth	r3,-10(fp)
    3130:	1004d43a 	srli	r2,r2,16
    3134:	e0fffe0b 	ldhu	r3,-8(fp)
    3138:	1806703a 	and	r3,r3,zero
    313c:	1884b03a 	or	r2,r3,r2
    3140:	e0bffe0d 	sth	r2,-8(fp)
  /* gateway address not given? */
  if (gw_addr.addr == 0) {
    3144:	e0bffd8b 	ldhu	r2,-10(fp)
    3148:	e0fffe0b 	ldhu	r3,-8(fp)
    314c:	1806943a 	slli	r3,r3,16
    3150:	1884b03a 	or	r2,r3,r2
    3154:	1000201e 	bne	r2,zero,31d8 <dhcp_bind+0x364>
    /* copy network address */
    gw_addr.addr = (dhcp->offered_ip_addr.addr & sn_mask.addr);
    3158:	e0bffb17 	ldw	r2,-20(fp)
    315c:	10c00a17 	ldw	r3,40(r2)
    3160:	e0bffc8b 	ldhu	r2,-14(fp)
    3164:	e13ffd0b 	ldhu	r4,-12(fp)
    3168:	2008943a 	slli	r4,r4,16
    316c:	2084b03a 	or	r2,r4,r2
    3170:	1884703a 	and	r2,r3,r2
    3174:	10ffffcc 	andi	r3,r2,65535
    3178:	e13ffd8b 	ldhu	r4,-10(fp)
    317c:	2008703a 	and	r4,r4,zero
    3180:	20c6b03a 	or	r3,r4,r3
    3184:	e0fffd8d 	sth	r3,-10(fp)
    3188:	1004d43a 	srli	r2,r2,16
    318c:	e0fffe0b 	ldhu	r3,-8(fp)
    3190:	1806703a 	and	r3,r3,zero
    3194:	1884b03a 	or	r2,r3,r2
    3198:	e0bffe0d 	sth	r2,-8(fp)
    /* use first host address on network as gateway */
    gw_addr.addr |= htonl(0x00000001);
    319c:	e0bffd8b 	ldhu	r2,-10(fp)
    31a0:	e0fffe0b 	ldhu	r3,-8(fp)
    31a4:	1806943a 	slli	r3,r3,16
    31a8:	1884b03a 	or	r2,r3,r2
    31ac:	10804034 	orhi	r2,r2,256
    31b0:	10ffffcc 	andi	r3,r2,65535
    31b4:	e13ffd8b 	ldhu	r4,-10(fp)
    31b8:	2008703a 	and	r4,r4,zero
    31bc:	20c6b03a 	or	r3,r4,r3
    31c0:	e0fffd8d 	sth	r3,-10(fp)
    31c4:	1004d43a 	srli	r2,r2,16
    31c8:	e0fffe0b 	ldhu	r3,-8(fp)
    31cc:	1806703a 	and	r3,r3,zero
    31d0:	1884b03a 	or	r2,r3,r2
    31d4:	e0bffe0d 	sth	r2,-8(fp)
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_OFF;
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): IP: 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
    31d8:	e0bffb17 	ldw	r2,-20(fp)
    31dc:	10800a04 	addi	r2,r2,40
    31e0:	e13fff17 	ldw	r4,-4(fp)
    31e4:	100b883a 	mov	r5,r2
    31e8:	00094900 	call	9490 <netif_set_ipaddr>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): SN: 0x%08"X32_F"\n", sn_mask.addr));
  netif_set_netmask(netif, &sn_mask);
    31ec:	e0bffc84 	addi	r2,fp,-14
    31f0:	e13fff17 	ldw	r4,-4(fp)
    31f4:	100b883a 	mov	r5,r2
    31f8:	00096380 	call	9638 <netif_set_netmask>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): GW: 0x%08"X32_F"\n", gw_addr.addr));
  netif_set_gw(netif, &gw_addr);
    31fc:	e0bffd84 	addi	r2,fp,-10
    3200:	e13fff17 	ldw	r4,-4(fp)
    3204:	100b883a 	mov	r5,r2
    3208:	00095e80 	call	95e8 <netif_set_gw>
  /* bring the interface up */
  netif_set_up(netif);
    320c:	e13fff17 	ldw	r4,-4(fp)
    3210:	00096b00 	call	96b0 <netif_set_up>
  /* netif is now bound to DHCP leased address */
  dhcp_set_state(dhcp, DHCP_BOUND);
    3214:	e13ffb17 	ldw	r4,-20(fp)
    3218:	01400284 	movi	r5,10
    321c:	00039940 	call	3994 <dhcp_set_state>
}
    3220:	e037883a 	mov	sp,fp
    3224:	dfc00117 	ldw	ra,4(sp)
    3228:	df000017 	ldw	fp,0(sp)
    322c:	dec00204 	addi	sp,sp,8
    3230:	f800283a 	ret

00003234 <dhcp_renew>:
 *
 * @param netif network interface which must renew its lease
 */
err_t
dhcp_renew(struct netif *netif)
{
    3234:	defffa04 	addi	sp,sp,-24
    3238:	dfc00515 	stw	ra,20(sp)
    323c:	df000415 	stw	fp,16(sp)
    3240:	df000404 	addi	fp,sp,16
    3244:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    3248:	e0bfff17 	ldw	r2,-4(fp)
    324c:	10800817 	ldw	r2,32(r2)
    3250:	e0bffd15 	stw	r2,-12(fp)
  u16_t msecs;
#if LWIP_NETIF_HOSTNAME
  const char *p;
#endif /* LWIP_NETIF_HOSTNAME */
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_renew()\n"));
  dhcp_set_state(dhcp, DHCP_RENEWING);
    3254:	e13ffd17 	ldw	r4,-12(fp)
    3258:	01400144 	movi	r5,5
    325c:	00039940 	call	3994 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
    3260:	e13fff17 	ldw	r4,-4(fp)
    3264:	00043380 	call	4338 <dhcp_create_request>
    3268:	e0bffe05 	stb	r2,-8(fp)
  if (result == ERR_OK) {
    326c:	e0bffe07 	ldb	r2,-8(fp)
    3270:	10002a1e 	bne	r2,zero,331c <dhcp_renew+0xe8>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
    3274:	e13ffd17 	ldw	r4,-12(fp)
    3278:	01400d44 	movi	r5,53
    327c:	01800044 	movi	r6,1
    3280:	00039e40 	call	39e4 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
    3284:	e13ffd17 	ldw	r4,-12(fp)
    3288:	014000c4 	movi	r5,3
    328c:	0003ac80 	call	3ac8 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    3290:	e13ffd17 	ldw	r4,-12(fp)
    3294:	01400e44 	movi	r5,57
    3298:	01800084 	movi	r6,2
    329c:	00039e40 	call	39e4 <dhcp_option>
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
    32a0:	e0bfff17 	ldw	r2,-4(fp)
    32a4:	1080090b 	ldhu	r2,36(r2)
    32a8:	10bfffcc 	andi	r2,r2,65535
    32ac:	e13ffd17 	ldw	r4,-12(fp)
    32b0:	100b883a 	mov	r5,r2
    32b4:	0003b640 	call	3b64 <dhcp_option_short>
#if 0
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif
    /* append DHCP message trailer */
    dhcp_option_trailer(dhcp);
    32b8:	e13ffd17 	ldw	r4,-12(fp)
    32bc:	00048f00 	call	48f0 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    32c0:	e0bffd17 	ldw	r2,-12(fp)
    32c4:	10c00517 	ldw	r3,20(r2)
    32c8:	e0bffd17 	ldw	r2,-12(fp)
    32cc:	1080070b 	ldhu	r2,28(r2)
    32d0:	10803c04 	addi	r2,r2,240
    32d4:	10bfffcc 	andi	r2,r2,65535
    32d8:	1809883a 	mov	r4,r3
    32dc:	100b883a 	mov	r5,r2
    32e0:	0009cf00 	call	9cf0 <pbuf_realloc>

    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
    32e4:	e0bffd17 	ldw	r2,-12(fp)
    32e8:	11000117 	ldw	r4,4(r2)
    32ec:	e0bffd17 	ldw	r2,-12(fp)
    32f0:	10c00517 	ldw	r3,20(r2)
    32f4:	e0bffd17 	ldw	r2,-12(fp)
    32f8:	10800904 	addi	r2,r2,36
    32fc:	e17fff17 	ldw	r5,-4(fp)
    3300:	d9400015 	stw	r5,0(sp)
    3304:	180b883a 	mov	r5,r3
    3308:	100d883a 	mov	r6,r2
    330c:	01c010c4 	movi	r7,67
    3310:	0013f940 	call	13f94 <udp_sendto_if>
    dhcp_delete_request(netif);
    3314:	e13fff17 	ldw	r4,-4(fp)
    3318:	00047d80 	call	47d8 <dhcp_delete_request>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_renew: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
    331c:	e0bffd17 	ldw	r2,-12(fp)
    3320:	108004c3 	ldbu	r2,19(r2)
    3324:	10800044 	addi	r2,r2,1
    3328:	1007883a 	mov	r3,r2
    332c:	e0bffd17 	ldw	r2,-12(fp)
    3330:	10c004c5 	stb	r3,19(r2)
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
    3334:	e0bffd17 	ldw	r2,-12(fp)
    3338:	108004c3 	ldbu	r2,19(r2)
    333c:	10803fcc 	andi	r2,r2,255
    3340:	108002a8 	cmpgeui	r2,r2,10
    3344:	1000051e 	bne	r2,zero,335c <dhcp_renew+0x128>
    3348:	e0bffd17 	ldw	r2,-12(fp)
    334c:	108004c3 	ldbu	r2,19(r2)
    3350:	10803fcc 	andi	r2,r2,255
    3354:	1081f424 	muli	r2,r2,2000
    3358:	00000106 	br	3360 <dhcp_renew+0x12c>
    335c:	00938804 	movi	r2,20000
    3360:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    3364:	e0bffe8b 	ldhu	r2,-6(fp)
    3368:	10c07cc4 	addi	r3,r2,499
    336c:	00807d04 	movi	r2,500
    3370:	1885283a 	div	r2,r3,r2
    3374:	1007883a 	mov	r3,r2
    3378:	e0bffd17 	ldw	r2,-12(fp)
    337c:	10c0078d 	sth	r3,30(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
    3380:	e0bffe03 	ldbu	r2,-8(fp)
}
    3384:	e037883a 	mov	sp,fp
    3388:	dfc00117 	ldw	ra,4(sp)
    338c:	df000017 	ldw	fp,0(sp)
    3390:	dec00204 	addi	sp,sp,8
    3394:	f800283a 	ret

00003398 <dhcp_rebind>:
 *
 * @param netif network interface which must rebind with a DHCP server
 */
static err_t
dhcp_rebind(struct netif *netif)
{
    3398:	defffa04 	addi	sp,sp,-24
    339c:	dfc00515 	stw	ra,20(sp)
    33a0:	df000415 	stw	fp,16(sp)
    33a4:	df000404 	addi	fp,sp,16
    33a8:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    33ac:	e0bfff17 	ldw	r2,-4(fp)
    33b0:	10800817 	ldw	r2,32(r2)
    33b4:	e0bffd15 	stw	r2,-12(fp)
  u16_t msecs;
#if LWIP_NETIF_HOSTNAME
  const char *p;
#endif /* LWIP_NETIF_HOSTNAME */
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind()\n"));
  dhcp_set_state(dhcp, DHCP_REBINDING);
    33b8:	e13ffd17 	ldw	r4,-12(fp)
    33bc:	01400104 	movi	r5,4
    33c0:	00039940 	call	3994 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
    33c4:	e13fff17 	ldw	r4,-4(fp)
    33c8:	00043380 	call	4338 <dhcp_create_request>
    33cc:	e0bffe05 	stb	r2,-8(fp)
  if (result == ERR_OK) {
    33d0:	e0bffe07 	ldb	r2,-8(fp)
    33d4:	10002a1e 	bne	r2,zero,3480 <dhcp_rebind+0xe8>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
    33d8:	e13ffd17 	ldw	r4,-12(fp)
    33dc:	01400d44 	movi	r5,53
    33e0:	01800044 	movi	r6,1
    33e4:	00039e40 	call	39e4 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
    33e8:	e13ffd17 	ldw	r4,-12(fp)
    33ec:	014000c4 	movi	r5,3
    33f0:	0003ac80 	call	3ac8 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    33f4:	e13ffd17 	ldw	r4,-12(fp)
    33f8:	01400e44 	movi	r5,57
    33fc:	01800084 	movi	r6,2
    3400:	00039e40 	call	39e4 <dhcp_option>
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
    3404:	e0bfff17 	ldw	r2,-4(fp)
    3408:	1080090b 	ldhu	r2,36(r2)
    340c:	10bfffcc 	andi	r2,r2,65535
    3410:	e13ffd17 	ldw	r4,-12(fp)
    3414:	100b883a 	mov	r5,r2
    3418:	0003b640 	call	3b64 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif

    dhcp_option_trailer(dhcp);
    341c:	e13ffd17 	ldw	r4,-12(fp)
    3420:	00048f00 	call	48f0 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    3424:	e0bffd17 	ldw	r2,-12(fp)
    3428:	10c00517 	ldw	r3,20(r2)
    342c:	e0bffd17 	ldw	r2,-12(fp)
    3430:	1080070b 	ldhu	r2,28(r2)
    3434:	10803c04 	addi	r2,r2,240
    3438:	10bfffcc 	andi	r2,r2,65535
    343c:	1809883a 	mov	r4,r3
    3440:	100b883a 	mov	r5,r2
    3444:	0009cf00 	call	9cf0 <pbuf_realloc>

    /* broadcast to server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    3448:	e0bffd17 	ldw	r2,-12(fp)
    344c:	10c00117 	ldw	r3,4(r2)
    3450:	e0bffd17 	ldw	r2,-12(fp)
    3454:	10800517 	ldw	r2,20(r2)
    3458:	e13fff17 	ldw	r4,-4(fp)
    345c:	d9000015 	stw	r4,0(sp)
    3460:	1809883a 	mov	r4,r3
    3464:	100b883a 	mov	r5,r2
    3468:	018000f4 	movhi	r6,3
    346c:	318d2204 	addi	r6,r6,13448
    3470:	01c010c4 	movi	r7,67
    3474:	0013f940 	call	13f94 <udp_sendto_if>
    dhcp_delete_request(netif);
    3478:	e13fff17 	ldw	r4,-4(fp)
    347c:	00047d80 	call	47d8 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_rebind: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
    3480:	e0bffd17 	ldw	r2,-12(fp)
    3484:	108004c3 	ldbu	r2,19(r2)
    3488:	10800044 	addi	r2,r2,1
    348c:	1007883a 	mov	r3,r2
    3490:	e0bffd17 	ldw	r2,-12(fp)
    3494:	10c004c5 	stb	r3,19(r2)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    3498:	e0bffd17 	ldw	r2,-12(fp)
    349c:	108004c3 	ldbu	r2,19(r2)
    34a0:	10803fcc 	andi	r2,r2,255
    34a4:	108002a8 	cmpgeui	r2,r2,10
    34a8:	1000051e 	bne	r2,zero,34c0 <dhcp_rebind+0x128>
    34ac:	e0bffd17 	ldw	r2,-12(fp)
    34b0:	108004c3 	ldbu	r2,19(r2)
    34b4:	10803fcc 	andi	r2,r2,255
    34b8:	1080fa24 	muli	r2,r2,1000
    34bc:	00000106 	br	34c4 <dhcp_rebind+0x12c>
    34c0:	0089c404 	movi	r2,10000
    34c4:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    34c8:	e0bffe8b 	ldhu	r2,-6(fp)
    34cc:	10c07cc4 	addi	r3,r2,499
    34d0:	00807d04 	movi	r2,500
    34d4:	1885283a 	div	r2,r3,r2
    34d8:	1007883a 	mov	r3,r2
    34dc:	e0bffd17 	ldw	r2,-12(fp)
    34e0:	10c0078d 	sth	r3,30(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
    34e4:	e0bffe03 	ldbu	r2,-8(fp)
}
    34e8:	e037883a 	mov	sp,fp
    34ec:	dfc00117 	ldw	ra,4(sp)
    34f0:	df000017 	ldw	fp,0(sp)
    34f4:	dec00204 	addi	sp,sp,8
    34f8:	f800283a 	ret

000034fc <dhcp_reboot>:
 *
 * @param netif network interface which must reboot
 */
static err_t
dhcp_reboot(struct netif *netif)
{
    34fc:	defffa04 	addi	sp,sp,-24
    3500:	dfc00515 	stw	ra,20(sp)
    3504:	df000415 	stw	fp,16(sp)
    3508:	df000404 	addi	fp,sp,16
    350c:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    3510:	e0bfff17 	ldw	r2,-4(fp)
    3514:	10800817 	ldw	r2,32(r2)
    3518:	e0bffd15 	stw	r2,-12(fp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot()\n"));
  dhcp_set_state(dhcp, DHCP_REBOOTING);
    351c:	e13ffd17 	ldw	r4,-12(fp)
    3520:	014000c4 	movi	r5,3
    3524:	00039940 	call	3994 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
    3528:	e13fff17 	ldw	r4,-4(fp)
    352c:	00043380 	call	4338 <dhcp_create_request>
    3530:	e0bffe05 	stb	r2,-8(fp)
  if (result == ERR_OK) {
    3534:	e0bffe07 	ldb	r2,-8(fp)
    3538:	10003f1e 	bne	r2,zero,3638 <dhcp_reboot+0x13c>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
    353c:	e13ffd17 	ldw	r4,-12(fp)
    3540:	01400d44 	movi	r5,53
    3544:	01800044 	movi	r6,1
    3548:	00039e40 	call	39e4 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
    354c:	e13ffd17 	ldw	r4,-12(fp)
    3550:	014000c4 	movi	r5,3
    3554:	0003ac80 	call	3ac8 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    3558:	e13ffd17 	ldw	r4,-12(fp)
    355c:	01400e44 	movi	r5,57
    3560:	01800084 	movi	r6,2
    3564:	00039e40 	call	39e4 <dhcp_option>
    dhcp_option_short(dhcp, 576);
    3568:	e13ffd17 	ldw	r4,-12(fp)
    356c:	01409004 	movi	r5,576
    3570:	0003b640 	call	3b64 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
    3574:	e13ffd17 	ldw	r4,-12(fp)
    3578:	01400c84 	movi	r5,50
    357c:	01800104 	movi	r6,4
    3580:	00039e40 	call	39e4 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
    3584:	e0bffd17 	ldw	r2,-12(fp)
    3588:	10800a17 	ldw	r2,40(r2)
    358c:	1006d63a 	srli	r3,r2,24
    3590:	e0bffd17 	ldw	r2,-12(fp)
    3594:	10800a17 	ldw	r2,40(r2)
    3598:	1004d23a 	srli	r2,r2,8
    359c:	10bfc00c 	andi	r2,r2,65280
    35a0:	1886b03a 	or	r3,r3,r2
    35a4:	e0bffd17 	ldw	r2,-12(fp)
    35a8:	10800a17 	ldw	r2,40(r2)
    35ac:	10bfc00c 	andi	r2,r2,65280
    35b0:	1004923a 	slli	r2,r2,8
    35b4:	1886b03a 	or	r3,r3,r2
    35b8:	e0bffd17 	ldw	r2,-12(fp)
    35bc:	10800a17 	ldw	r2,40(r2)
    35c0:	1004963a 	slli	r2,r2,24
    35c4:	1884b03a 	or	r2,r3,r2
    35c8:	e13ffd17 	ldw	r4,-12(fp)
    35cc:	100b883a 	mov	r5,r2
    35d0:	0003c3c0 	call	3c3c <dhcp_option_long>

    dhcp_option_trailer(dhcp);
    35d4:	e13ffd17 	ldw	r4,-12(fp)
    35d8:	00048f00 	call	48f0 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    35dc:	e0bffd17 	ldw	r2,-12(fp)
    35e0:	10c00517 	ldw	r3,20(r2)
    35e4:	e0bffd17 	ldw	r2,-12(fp)
    35e8:	1080070b 	ldhu	r2,28(r2)
    35ec:	10803c04 	addi	r2,r2,240
    35f0:	10bfffcc 	andi	r2,r2,65535
    35f4:	1809883a 	mov	r4,r3
    35f8:	100b883a 	mov	r5,r2
    35fc:	0009cf00 	call	9cf0 <pbuf_realloc>

    /* broadcast to server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    3600:	e0bffd17 	ldw	r2,-12(fp)
    3604:	10c00117 	ldw	r3,4(r2)
    3608:	e0bffd17 	ldw	r2,-12(fp)
    360c:	10800517 	ldw	r2,20(r2)
    3610:	e13fff17 	ldw	r4,-4(fp)
    3614:	d9000015 	stw	r4,0(sp)
    3618:	1809883a 	mov	r4,r3
    361c:	100b883a 	mov	r5,r2
    3620:	018000f4 	movhi	r6,3
    3624:	318d2204 	addi	r6,r6,13448
    3628:	01c010c4 	movi	r7,67
    362c:	0013f940 	call	13f94 <udp_sendto_if>
    dhcp_delete_request(netif);
    3630:	e13fff17 	ldw	r4,-4(fp)
    3634:	00047d80 	call	47d8 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot: REBOOTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_reboot: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
    3638:	e0bffd17 	ldw	r2,-12(fp)
    363c:	108004c3 	ldbu	r2,19(r2)
    3640:	10800044 	addi	r2,r2,1
    3644:	1007883a 	mov	r3,r2
    3648:	e0bffd17 	ldw	r2,-12(fp)
    364c:	10c004c5 	stb	r3,19(r2)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    3650:	e0bffd17 	ldw	r2,-12(fp)
    3654:	108004c3 	ldbu	r2,19(r2)
    3658:	10803fcc 	andi	r2,r2,255
    365c:	108002a8 	cmpgeui	r2,r2,10
    3660:	1000051e 	bne	r2,zero,3678 <dhcp_reboot+0x17c>
    3664:	e0bffd17 	ldw	r2,-12(fp)
    3668:	108004c3 	ldbu	r2,19(r2)
    366c:	10803fcc 	andi	r2,r2,255
    3670:	1080fa24 	muli	r2,r2,1000
    3674:	00000106 	br	367c <dhcp_reboot+0x180>
    3678:	0089c404 	movi	r2,10000
    367c:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    3680:	e0bffe8b 	ldhu	r2,-6(fp)
    3684:	10c07cc4 	addi	r3,r2,499
    3688:	00807d04 	movi	r2,500
    368c:	1885283a 	div	r2,r3,r2
    3690:	1007883a 	mov	r3,r2
    3694:	e0bffd17 	ldw	r2,-12(fp)
    3698:	10c0078d 	sth	r3,30(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
    369c:	e0bffe03 	ldbu	r2,-8(fp)
}
    36a0:	e037883a 	mov	sp,fp
    36a4:	dfc00117 	ldw	ra,4(sp)
    36a8:	df000017 	ldw	fp,0(sp)
    36ac:	dec00204 	addi	sp,sp,8
    36b0:	f800283a 	ret

000036b4 <dhcp_release>:
 *
 * @param netif network interface which must release its lease
 */
err_t
dhcp_release(struct netif *netif)
{
    36b4:	defffa04 	addi	sp,sp,-24
    36b8:	dfc00515 	stw	ra,20(sp)
    36bc:	df000415 	stw	fp,16(sp)
    36c0:	df000404 	addi	fp,sp,16
    36c4:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    36c8:	e0bfff17 	ldw	r2,-4(fp)
    36cc:	10800817 	ldw	r2,32(r2)
    36d0:	e0bffd15 	stw	r2,-12(fp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_release()\n"));

  /* idle DHCP client */
  dhcp_set_state(dhcp, DHCP_OFF);
    36d4:	e13ffd17 	ldw	r4,-12(fp)
    36d8:	01400344 	movi	r5,13
    36dc:	00039940 	call	3994 <dhcp_set_state>
  /* clean old DHCP offer */
  dhcp->server_ip_addr.addr = 0;
    36e0:	e0bffd17 	ldw	r2,-12(fp)
    36e4:	10000915 	stw	zero,36(r2)
  dhcp->offered_ip_addr.addr = dhcp->offered_sn_mask.addr = 0;
    36e8:	e0bffd17 	ldw	r2,-12(fp)
    36ec:	10000b15 	stw	zero,44(r2)
    36f0:	e0bffd17 	ldw	r2,-12(fp)
    36f4:	10c00b17 	ldw	r3,44(r2)
    36f8:	e0bffd17 	ldw	r2,-12(fp)
    36fc:	10c00a15 	stw	r3,40(r2)
  dhcp->offered_gw_addr.addr = dhcp->offered_bc_addr.addr = 0;
    3700:	e0bffd17 	ldw	r2,-12(fp)
    3704:	10000d15 	stw	zero,52(r2)
    3708:	e0bffd17 	ldw	r2,-12(fp)
    370c:	10c00d17 	ldw	r3,52(r2)
    3710:	e0bffd17 	ldw	r2,-12(fp)
    3714:	10c00c15 	stw	r3,48(r2)
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
    3718:	e0bffd17 	ldw	r2,-12(fp)
    371c:	10001315 	stw	zero,76(r2)
    3720:	e0bffd17 	ldw	r2,-12(fp)
    3724:	10c01317 	ldw	r3,76(r2)
    3728:	e0bffd17 	ldw	r2,-12(fp)
    372c:	10c01215 	stw	r3,72(r2)
    3730:	e0bffd17 	ldw	r2,-12(fp)
    3734:	10c01217 	ldw	r3,72(r2)
    3738:	e0bffd17 	ldw	r2,-12(fp)
    373c:	10c01115 	stw	r3,68(r2)
  dhcp->dns_count = 0;
    3740:	e0bffd17 	ldw	r2,-12(fp)
    3744:	10000e15 	stw	zero,56(r2)
  
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
    3748:	e13fff17 	ldw	r4,-4(fp)
    374c:	00043380 	call	4338 <dhcp_create_request>
    3750:	e0bffe05 	stb	r2,-8(fp)
  if (result == ERR_OK) {
    3754:	e0bffe07 	ldb	r2,-8(fp)
    3758:	1000201e 	bne	r2,zero,37dc <dhcp_release+0x128>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
    375c:	e13ffd17 	ldw	r4,-12(fp)
    3760:	01400d44 	movi	r5,53
    3764:	01800044 	movi	r6,1
    3768:	00039e40 	call	39e4 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_RELEASE);
    376c:	e13ffd17 	ldw	r4,-12(fp)
    3770:	014001c4 	movi	r5,7
    3774:	0003ac80 	call	3ac8 <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
    3778:	e13ffd17 	ldw	r4,-12(fp)
    377c:	00048f00 	call	48f0 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    3780:	e0bffd17 	ldw	r2,-12(fp)
    3784:	10c00517 	ldw	r3,20(r2)
    3788:	e0bffd17 	ldw	r2,-12(fp)
    378c:	1080070b 	ldhu	r2,28(r2)
    3790:	10803c04 	addi	r2,r2,240
    3794:	10bfffcc 	andi	r2,r2,65535
    3798:	1809883a 	mov	r4,r3
    379c:	100b883a 	mov	r5,r2
    37a0:	0009cf00 	call	9cf0 <pbuf_realloc>

    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
    37a4:	e0bffd17 	ldw	r2,-12(fp)
    37a8:	11000117 	ldw	r4,4(r2)
    37ac:	e0bffd17 	ldw	r2,-12(fp)
    37b0:	10c00517 	ldw	r3,20(r2)
    37b4:	e0bffd17 	ldw	r2,-12(fp)
    37b8:	10800904 	addi	r2,r2,36
    37bc:	e17fff17 	ldw	r5,-4(fp)
    37c0:	d9400015 	stw	r5,0(sp)
    37c4:	180b883a 	mov	r5,r3
    37c8:	100d883a 	mov	r6,r2
    37cc:	01c010c4 	movi	r7,67
    37d0:	0013f940 	call	13f94 <udp_sendto_if>
    dhcp_delete_request(netif);
    37d4:	e13fff17 	ldw	r4,-4(fp)
    37d8:	00047d80 	call	47d8 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_release: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
    37dc:	e0bffd17 	ldw	r2,-12(fp)
    37e0:	108004c3 	ldbu	r2,19(r2)
    37e4:	10800044 	addi	r2,r2,1
    37e8:	1007883a 	mov	r3,r2
    37ec:	e0bffd17 	ldw	r2,-12(fp)
    37f0:	10c004c5 	stb	r3,19(r2)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    37f4:	e0bffd17 	ldw	r2,-12(fp)
    37f8:	108004c3 	ldbu	r2,19(r2)
    37fc:	10803fcc 	andi	r2,r2,255
    3800:	108002a8 	cmpgeui	r2,r2,10
    3804:	1000051e 	bne	r2,zero,381c <dhcp_release+0x168>
    3808:	e0bffd17 	ldw	r2,-12(fp)
    380c:	108004c3 	ldbu	r2,19(r2)
    3810:	10803fcc 	andi	r2,r2,255
    3814:	1080fa24 	muli	r2,r2,1000
    3818:	00000106 	br	3820 <dhcp_release+0x16c>
    381c:	0089c404 	movi	r2,10000
    3820:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    3824:	e0bffe8b 	ldhu	r2,-6(fp)
    3828:	10c07cc4 	addi	r3,r2,499
    382c:	00807d04 	movi	r2,500
    3830:	1885283a 	div	r2,r3,r2
    3834:	1007883a 	mov	r3,r2
    3838:	e0bffd17 	ldw	r2,-12(fp)
    383c:	10c0078d 	sth	r3,30(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release(): set request timeout %"U16_F" msecs\n", msecs));
  /* bring the interface down */
  netif_set_down(netif);
    3840:	e13fff17 	ldw	r4,-4(fp)
    3844:	000972c0 	call	972c <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
    3848:	e13fff17 	ldw	r4,-4(fp)
    384c:	014000f4 	movhi	r5,3
    3850:	294d2104 	addi	r5,r5,13444
    3854:	00094900 	call	9490 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
    3858:	e13fff17 	ldw	r4,-4(fp)
    385c:	014000f4 	movhi	r5,3
    3860:	294d2104 	addi	r5,r5,13444
    3864:	00095e80 	call	95e8 <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY);
    3868:	e13fff17 	ldw	r4,-4(fp)
    386c:	014000f4 	movhi	r5,3
    3870:	294d2104 	addi	r5,r5,13444
    3874:	00096380 	call	9638 <netif_set_netmask>
  
  /* TODO: netif_down(netif); */
  return result;
    3878:	e0bffe03 	ldbu	r2,-8(fp)
}
    387c:	e037883a 	mov	sp,fp
    3880:	dfc00117 	ldw	ra,4(sp)
    3884:	df000017 	ldw	fp,0(sp)
    3888:	dec00204 	addi	sp,sp,8
    388c:	f800283a 	ret

00003890 <dhcp_stop>:
 *
 * @param netif The network interface to stop DHCP on
 */
void
dhcp_stop(struct netif *netif)
{
    3890:	defffc04 	addi	sp,sp,-16
    3894:	dfc00315 	stw	ra,12(sp)
    3898:	df000215 	stw	fp,8(sp)
    389c:	df000204 	addi	fp,sp,8
    38a0:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    38a4:	e0bfff17 	ldw	r2,-4(fp)
    38a8:	10800817 	ldw	r2,32(r2)
    38ac:	e0bffe15 	stw	r2,-8(fp)
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
    38b0:	e0bfff17 	ldw	r2,-4(fp)
    38b4:	1000091e 	bne	r2,zero,38dc <dhcp_stop+0x4c>
    38b8:	010000f4 	movhi	r4,3
    38bc:	21352e04 	addi	r4,r4,-11080
    38c0:	014000f4 	movhi	r5,3
    38c4:	29755a04 	addi	r5,r5,-10904
    38c8:	01812c04 	movi	r6,1200
    38cc:	01c000f4 	movhi	r7,3
    38d0:	39f53c04 	addi	r7,r7,-11024
    38d4:	00166c00 	call	166c0 <printf>
    38d8:	003fff06 	br	38d8 <dhcp_stop+0x48>
  /* Remove the flag that says this netif is handled by DHCP. */
  netif->flags &= ~NETIF_FLAG_DHCP;
    38dc:	e0bfff17 	ldw	r2,-4(fp)
    38e0:	10c00b43 	ldbu	r3,45(r2)
    38e4:	00bffdc4 	movi	r2,-9
    38e8:	1884703a 	and	r2,r3,r2
    38ec:	1007883a 	mov	r3,r2
    38f0:	e0bfff17 	ldw	r2,-4(fp)
    38f4:	10c00b45 	stb	r3,45(r2)

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_stop()\n"));
  /* netif is DHCP configured? */
  if (dhcp != NULL) {
    38f8:	e0bffe17 	ldw	r2,-8(fp)
    38fc:	10002026 	beq	r2,zero,3980 <dhcp_stop+0xf0>
    autoip_stop(netif);
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_OFF;
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */

    if (dhcp->pcb != NULL) {
    3900:	e0bffe17 	ldw	r2,-8(fp)
    3904:	10800117 	ldw	r2,4(r2)
    3908:	10000626 	beq	r2,zero,3924 <dhcp_stop+0x94>
      udp_remove(dhcp->pcb);
    390c:	e0bffe17 	ldw	r2,-8(fp)
    3910:	10800117 	ldw	r2,4(r2)
    3914:	1009883a 	mov	r4,r2
    3918:	00145980 	call	14598 <udp_remove>
      dhcp->pcb = NULL;
    391c:	e0bffe17 	ldw	r2,-8(fp)
    3920:	10000115 	stw	zero,4(r2)
    }
    LWIP_ASSERT("reply wasn't freed", dhcp->msg_in == NULL &&
    3924:	e0bffe17 	ldw	r2,-8(fp)
    3928:	10800217 	ldw	r2,8(r2)
    392c:	1000071e 	bne	r2,zero,394c <dhcp_stop+0xbc>
    3930:	e0bffe17 	ldw	r2,-8(fp)
    3934:	10800317 	ldw	r2,12(r2)
    3938:	1000041e 	bne	r2,zero,394c <dhcp_stop+0xbc>
    393c:	e0bffe17 	ldw	r2,-8(fp)
    3940:	1080040b 	ldhu	r2,16(r2)
    3944:	10bfffcc 	andi	r2,r2,65535
    3948:	10000926 	beq	r2,zero,3970 <dhcp_stop+0xe0>
    394c:	010000f4 	movhi	r4,3
    3950:	21352e04 	addi	r4,r4,-11080
    3954:	014000f4 	movhi	r5,3
    3958:	29754804 	addi	r5,r5,-10976
    395c:	018130c4 	movi	r6,1219
    3960:	01c000f4 	movhi	r7,3
    3964:	39f53c04 	addi	r7,r7,-11024
    3968:	00166c00 	call	166c0 <printf>
    396c:	003fff06 	br	396c <dhcp_stop+0xdc>
      dhcp->options_in == NULL && dhcp->options_in_len == 0);
    mem_free((void *)dhcp);
    3970:	e13ffe17 	ldw	r4,-8(fp)
    3974:	000842c0 	call	842c <mem_free>
    netif->dhcp = NULL;
    3978:	e0bfff17 	ldw	r2,-4(fp)
    397c:	10000815 	stw	zero,32(r2)
  }
}
    3980:	e037883a 	mov	sp,fp
    3984:	dfc00117 	ldw	ra,4(sp)
    3988:	df000017 	ldw	fp,0(sp)
    398c:	dec00204 	addi	sp,sp,8
    3990:	f800283a 	ret

00003994 <dhcp_set_state>:
 *
 * TODO: we might also want to reset the timeout here?
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
    3994:	defffd04 	addi	sp,sp,-12
    3998:	df000215 	stw	fp,8(sp)
    399c:	df000204 	addi	fp,sp,8
    39a0:	e13ffe15 	stw	r4,-8(fp)
    39a4:	2805883a 	mov	r2,r5
    39a8:	e0bfff05 	stb	r2,-4(fp)
  if (new_state != dhcp->state) {
    39ac:	e0bffe17 	ldw	r2,-8(fp)
    39b0:	10800483 	ldbu	r2,18(r2)
    39b4:	10c03fcc 	andi	r3,r2,255
    39b8:	e0bfff03 	ldbu	r2,-4(fp)
    39bc:	18800526 	beq	r3,r2,39d4 <dhcp_set_state+0x40>
    dhcp->state = new_state;
    39c0:	e0bffe17 	ldw	r2,-8(fp)
    39c4:	e0ffff03 	ldbu	r3,-4(fp)
    39c8:	10c00485 	stb	r3,18(r2)
    dhcp->tries = 0;
    39cc:	e0bffe17 	ldw	r2,-8(fp)
    39d0:	100004c5 	stb	zero,19(r2)
  }
}
    39d4:	e037883a 	mov	sp,fp
    39d8:	df000017 	ldw	fp,0(sp)
    39dc:	dec00104 	addi	sp,sp,4
    39e0:	f800283a 	ret

000039e4 <dhcp_option>:
 * DHCP message.
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
    39e4:	defffb04 	addi	sp,sp,-20
    39e8:	dfc00415 	stw	ra,16(sp)
    39ec:	df000315 	stw	fp,12(sp)
    39f0:	df000304 	addi	fp,sp,12
    39f4:	e13ffd15 	stw	r4,-12(fp)
    39f8:	2807883a 	mov	r3,r5
    39fc:	3005883a 	mov	r2,r6
    3a00:	e0fffe05 	stb	r3,-8(fp)
    3a04:	e0bfff05 	stb	r2,-4(fp)
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
    3a08:	e0bffd17 	ldw	r2,-12(fp)
    3a0c:	1080070b 	ldhu	r2,28(r2)
    3a10:	10ffffcc 	andi	r3,r2,65535
    3a14:	e0bfff03 	ldbu	r2,-4(fp)
    3a18:	1885883a 	add	r2,r3,r2
    3a1c:	10800084 	addi	r2,r2,2
    3a20:	10801170 	cmpltui	r2,r2,69
    3a24:	1000091e 	bne	r2,zero,3a4c <dhcp_option+0x68>
    3a28:	010000f4 	movhi	r4,3
    3a2c:	21352e04 	addi	r4,r4,-11080
    3a30:	014000f4 	movhi	r5,3
    3a34:	29756104 	addi	r5,r5,-10876
    3a38:	01813844 	movi	r6,1249
    3a3c:	01c000f4 	movhi	r7,3
    3a40:	39f53c04 	addi	r7,r7,-11024
    3a44:	00166c00 	call	166c0 <printf>
    3a48:	003fff06 	br	3a48 <dhcp_option+0x64>
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
    3a4c:	e0bffd17 	ldw	r2,-12(fp)
    3a50:	11000617 	ldw	r4,24(r2)
    3a54:	e0bffd17 	ldw	r2,-12(fp)
    3a58:	1080070b 	ldhu	r2,28(r2)
    3a5c:	10ffffcc 	andi	r3,r2,65535
    3a60:	20c7883a 	add	r3,r4,r3
    3a64:	18c03c04 	addi	r3,r3,240
    3a68:	e13ffe03 	ldbu	r4,-8(fp)
    3a6c:	19000005 	stb	r4,0(r3)
    3a70:	10800044 	addi	r2,r2,1
    3a74:	1007883a 	mov	r3,r2
    3a78:	e0bffd17 	ldw	r2,-12(fp)
    3a7c:	10c0070d 	sth	r3,28(r2)
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
    3a80:	e0bffd17 	ldw	r2,-12(fp)
    3a84:	11000617 	ldw	r4,24(r2)
    3a88:	e0bffd17 	ldw	r2,-12(fp)
    3a8c:	1080070b 	ldhu	r2,28(r2)
    3a90:	10ffffcc 	andi	r3,r2,65535
    3a94:	20c7883a 	add	r3,r4,r3
    3a98:	18c03c04 	addi	r3,r3,240
    3a9c:	e13fff03 	ldbu	r4,-4(fp)
    3aa0:	19000005 	stb	r4,0(r3)
    3aa4:	10800044 	addi	r2,r2,1
    3aa8:	1007883a 	mov	r3,r2
    3aac:	e0bffd17 	ldw	r2,-12(fp)
    3ab0:	10c0070d 	sth	r3,28(r2)
}
    3ab4:	e037883a 	mov	sp,fp
    3ab8:	dfc00117 	ldw	ra,4(sp)
    3abc:	df000017 	ldw	fp,0(sp)
    3ac0:	dec00204 	addi	sp,sp,8
    3ac4:	f800283a 	ret

00003ac8 <dhcp_option_byte>:
 * Concatenate a single byte to the outgoing DHCP message.
 *
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
    3ac8:	defffc04 	addi	sp,sp,-16
    3acc:	dfc00315 	stw	ra,12(sp)
    3ad0:	df000215 	stw	fp,8(sp)
    3ad4:	df000204 	addi	fp,sp,8
    3ad8:	e13ffe15 	stw	r4,-8(fp)
    3adc:	2805883a 	mov	r2,r5
    3ae0:	e0bfff05 	stb	r2,-4(fp)
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
    3ae4:	e0bffe17 	ldw	r2,-8(fp)
    3ae8:	1080070b 	ldhu	r2,28(r2)
    3aec:	10bfffcc 	andi	r2,r2,65535
    3af0:	10801130 	cmpltui	r2,r2,68
    3af4:	1000091e 	bne	r2,zero,3b1c <dhcp_option_byte+0x54>
    3af8:	010000f4 	movhi	r4,3
    3afc:	21352e04 	addi	r4,r4,-11080
    3b00:	014000f4 	movhi	r5,3
    3b04:	29757304 	addi	r5,r5,-10804
    3b08:	01813b04 	movi	r6,1260
    3b0c:	01c000f4 	movhi	r7,3
    3b10:	39f53c04 	addi	r7,r7,-11024
    3b14:	00166c00 	call	166c0 <printf>
    3b18:	003fff06 	br	3b18 <dhcp_option_byte+0x50>
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
    3b1c:	e0bffe17 	ldw	r2,-8(fp)
    3b20:	11000617 	ldw	r4,24(r2)
    3b24:	e0bffe17 	ldw	r2,-8(fp)
    3b28:	1080070b 	ldhu	r2,28(r2)
    3b2c:	10ffffcc 	andi	r3,r2,65535
    3b30:	20c7883a 	add	r3,r4,r3
    3b34:	18c03c04 	addi	r3,r3,240
    3b38:	e13fff03 	ldbu	r4,-4(fp)
    3b3c:	19000005 	stb	r4,0(r3)
    3b40:	10800044 	addi	r2,r2,1
    3b44:	1007883a 	mov	r3,r2
    3b48:	e0bffe17 	ldw	r2,-8(fp)
    3b4c:	10c0070d 	sth	r3,28(r2)
}
    3b50:	e037883a 	mov	sp,fp
    3b54:	dfc00117 	ldw	ra,4(sp)
    3b58:	df000017 	ldw	fp,0(sp)
    3b5c:	dec00204 	addi	sp,sp,8
    3b60:	f800283a 	ret

00003b64 <dhcp_option_short>:

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
    3b64:	defffc04 	addi	sp,sp,-16
    3b68:	dfc00315 	stw	ra,12(sp)
    3b6c:	df000215 	stw	fp,8(sp)
    3b70:	df000204 	addi	fp,sp,8
    3b74:	e13ffe15 	stw	r4,-8(fp)
    3b78:	2805883a 	mov	r2,r5
    3b7c:	e0bfff0d 	sth	r2,-4(fp)
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
    3b80:	e0bffe17 	ldw	r2,-8(fp)
    3b84:	1080070b 	ldhu	r2,28(r2)
    3b88:	10bfffcc 	andi	r2,r2,65535
    3b8c:	10800084 	addi	r2,r2,2
    3b90:	10801170 	cmpltui	r2,r2,69
    3b94:	1000091e 	bne	r2,zero,3bbc <dhcp_option_short+0x58>
    3b98:	010000f4 	movhi	r4,3
    3b9c:	21352e04 	addi	r4,r4,-11080
    3ba0:	014000f4 	movhi	r5,3
    3ba4:	29758204 	addi	r5,r5,-10744
    3ba8:	01813cc4 	movi	r6,1267
    3bac:	01c000f4 	movhi	r7,3
    3bb0:	39f53c04 	addi	r7,r7,-11024
    3bb4:	00166c00 	call	166c0 <printf>
    3bb8:	003fff06 	br	3bb8 <dhcp_option_short+0x54>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
    3bbc:	e0bffe17 	ldw	r2,-8(fp)
    3bc0:	11400617 	ldw	r5,24(r2)
    3bc4:	e0bffe17 	ldw	r2,-8(fp)
    3bc8:	1080070b 	ldhu	r2,28(r2)
    3bcc:	10ffffcc 	andi	r3,r2,65535
    3bd0:	e13fff0b 	ldhu	r4,-4(fp)
    3bd4:	2008d23a 	srli	r4,r4,8
    3bd8:	28c7883a 	add	r3,r5,r3
    3bdc:	18c03c04 	addi	r3,r3,240
    3be0:	19000005 	stb	r4,0(r3)
    3be4:	10800044 	addi	r2,r2,1
    3be8:	1007883a 	mov	r3,r2
    3bec:	e0bffe17 	ldw	r2,-8(fp)
    3bf0:	10c0070d 	sth	r3,28(r2)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
    3bf4:	e0bffe17 	ldw	r2,-8(fp)
    3bf8:	11400617 	ldw	r5,24(r2)
    3bfc:	e0bffe17 	ldw	r2,-8(fp)
    3c00:	1080070b 	ldhu	r2,28(r2)
    3c04:	10ffffcc 	andi	r3,r2,65535
    3c08:	e13fff0b 	ldhu	r4,-4(fp)
    3c0c:	28c7883a 	add	r3,r5,r3
    3c10:	18c03c04 	addi	r3,r3,240
    3c14:	19000005 	stb	r4,0(r3)
    3c18:	10800044 	addi	r2,r2,1
    3c1c:	1007883a 	mov	r3,r2
    3c20:	e0bffe17 	ldw	r2,-8(fp)
    3c24:	10c0070d 	sth	r3,28(r2)
}
    3c28:	e037883a 	mov	sp,fp
    3c2c:	dfc00117 	ldw	ra,4(sp)
    3c30:	df000017 	ldw	fp,0(sp)
    3c34:	dec00204 	addi	sp,sp,8
    3c38:	f800283a 	ret

00003c3c <dhcp_option_long>:

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
    3c3c:	defffc04 	addi	sp,sp,-16
    3c40:	dfc00315 	stw	ra,12(sp)
    3c44:	df000215 	stw	fp,8(sp)
    3c48:	df000204 	addi	fp,sp,8
    3c4c:	e13ffe15 	stw	r4,-8(fp)
    3c50:	e17fff15 	stw	r5,-4(fp)
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
    3c54:	e0bffe17 	ldw	r2,-8(fp)
    3c58:	1080070b 	ldhu	r2,28(r2)
    3c5c:	10bfffcc 	andi	r2,r2,65535
    3c60:	10800104 	addi	r2,r2,4
    3c64:	10801170 	cmpltui	r2,r2,69
    3c68:	1000091e 	bne	r2,zero,3c90 <dhcp_option_long+0x54>
    3c6c:	010000f4 	movhi	r4,3
    3c70:	21352e04 	addi	r4,r4,-11080
    3c74:	014000f4 	movhi	r5,3
    3c78:	29759304 	addi	r5,r5,-10676
    3c7c:	01813ec4 	movi	r6,1275
    3c80:	01c000f4 	movhi	r7,3
    3c84:	39f53c04 	addi	r7,r7,-11024
    3c88:	00166c00 	call	166c0 <printf>
    3c8c:	003fff06 	br	3c8c <dhcp_option_long+0x50>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
    3c90:	e0bffe17 	ldw	r2,-8(fp)
    3c94:	11400617 	ldw	r5,24(r2)
    3c98:	e0bffe17 	ldw	r2,-8(fp)
    3c9c:	1080070b 	ldhu	r2,28(r2)
    3ca0:	10ffffcc 	andi	r3,r2,65535
    3ca4:	e13fff17 	ldw	r4,-4(fp)
    3ca8:	2008d63a 	srli	r4,r4,24
    3cac:	28c7883a 	add	r3,r5,r3
    3cb0:	18c03c04 	addi	r3,r3,240
    3cb4:	19000005 	stb	r4,0(r3)
    3cb8:	10800044 	addi	r2,r2,1
    3cbc:	1007883a 	mov	r3,r2
    3cc0:	e0bffe17 	ldw	r2,-8(fp)
    3cc4:	10c0070d 	sth	r3,28(r2)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
    3cc8:	e0bffe17 	ldw	r2,-8(fp)
    3ccc:	11400617 	ldw	r5,24(r2)
    3cd0:	e0bffe17 	ldw	r2,-8(fp)
    3cd4:	1080070b 	ldhu	r2,28(r2)
    3cd8:	10ffffcc 	andi	r3,r2,65535
    3cdc:	e13fff17 	ldw	r4,-4(fp)
    3ce0:	21003fec 	andhi	r4,r4,255
    3ce4:	2008d43a 	srli	r4,r4,16
    3ce8:	28c7883a 	add	r3,r5,r3
    3cec:	18c03c04 	addi	r3,r3,240
    3cf0:	19000005 	stb	r4,0(r3)
    3cf4:	10800044 	addi	r2,r2,1
    3cf8:	1007883a 	mov	r3,r2
    3cfc:	e0bffe17 	ldw	r2,-8(fp)
    3d00:	10c0070d 	sth	r3,28(r2)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
    3d04:	e0bffe17 	ldw	r2,-8(fp)
    3d08:	11400617 	ldw	r5,24(r2)
    3d0c:	e0bffe17 	ldw	r2,-8(fp)
    3d10:	1080070b 	ldhu	r2,28(r2)
    3d14:	10ffffcc 	andi	r3,r2,65535
    3d18:	e13fff17 	ldw	r4,-4(fp)
    3d1c:	213fc00c 	andi	r4,r4,65280
    3d20:	2008d23a 	srli	r4,r4,8
    3d24:	28c7883a 	add	r3,r5,r3
    3d28:	18c03c04 	addi	r3,r3,240
    3d2c:	19000005 	stb	r4,0(r3)
    3d30:	10800044 	addi	r2,r2,1
    3d34:	1007883a 	mov	r3,r2
    3d38:	e0bffe17 	ldw	r2,-8(fp)
    3d3c:	10c0070d 	sth	r3,28(r2)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
    3d40:	e0bffe17 	ldw	r2,-8(fp)
    3d44:	11400617 	ldw	r5,24(r2)
    3d48:	e0bffe17 	ldw	r2,-8(fp)
    3d4c:	1080070b 	ldhu	r2,28(r2)
    3d50:	10ffffcc 	andi	r3,r2,65535
    3d54:	e13fff17 	ldw	r4,-4(fp)
    3d58:	28c7883a 	add	r3,r5,r3
    3d5c:	18c03c04 	addi	r3,r3,240
    3d60:	19000005 	stb	r4,0(r3)
    3d64:	10800044 	addi	r2,r2,1
    3d68:	1007883a 	mov	r3,r2
    3d6c:	e0bffe17 	ldw	r2,-8(fp)
    3d70:	10c0070d 	sth	r3,28(r2)
}
    3d74:	e037883a 	mov	sp,fp
    3d78:	dfc00117 	ldw	ra,4(sp)
    3d7c:	df000017 	ldw	fp,0(sp)
    3d80:	dec00204 	addi	sp,sp,8
    3d84:	f800283a 	ret

00003d88 <dhcp_unfold_reply>:
 * use that further on.
 *
 */
static err_t
dhcp_unfold_reply(struct dhcp *dhcp, struct pbuf *p)
{
    3d88:	defffb04 	addi	sp,sp,-20
    3d8c:	dfc00415 	stw	ra,16(sp)
    3d90:	df000315 	stw	fp,12(sp)
    3d94:	df000304 	addi	fp,sp,12
    3d98:	e13ffe15 	stw	r4,-8(fp)
    3d9c:	e17fff15 	stw	r5,-4(fp)
  u16_t ret;
  LWIP_ERROR("dhcp != NULL", (dhcp != NULL), return ERR_ARG;);
    3da0:	e0bffe17 	ldw	r2,-8(fp)
    3da4:	1000091e 	bne	r2,zero,3dcc <dhcp_unfold_reply+0x44>
    3da8:	010000f4 	movhi	r4,3
    3dac:	21352e04 	addi	r4,r4,-11080
    3db0:	014000f4 	movhi	r5,3
    3db4:	2975a304 	addi	r5,r5,-10612
    3db8:	01814404 	movi	r6,1296
    3dbc:	01c000f4 	movhi	r7,3
    3dc0:	39f53c04 	addi	r7,r7,-11024
    3dc4:	00166c00 	call	166c0 <printf>
    3dc8:	003fff06 	br	3dc8 <dhcp_unfold_reply+0x40>
  /* free any left-overs from previous unfolds */
  dhcp_free_reply(dhcp);
    3dcc:	e13ffe17 	ldw	r4,-8(fp)
    3dd0:	0003f600 	call	3f60 <dhcp_free_reply>
  /* options present? */
  if (p->tot_len > (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN)) {
    3dd4:	e0bfff17 	ldw	r2,-4(fp)
    3dd8:	1080020b 	ldhu	r2,8(r2)
    3ddc:	10bfffcc 	andi	r2,r2,65535
    3de0:	10803c70 	cmpltui	r2,r2,241
    3de4:	1000141e 	bne	r2,zero,3e38 <dhcp_unfold_reply+0xb0>
    dhcp->options_in_len = p->tot_len - (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
    3de8:	e0bfff17 	ldw	r2,-4(fp)
    3dec:	1080020b 	ldhu	r2,8(r2)
    3df0:	10bfc404 	addi	r2,r2,-240
    3df4:	1007883a 	mov	r3,r2
    3df8:	e0bffe17 	ldw	r2,-8(fp)
    3dfc:	10c0040d 	sth	r3,16(r2)
    dhcp->options_in = mem_malloc(dhcp->options_in_len);
    3e00:	e0bffe17 	ldw	r2,-8(fp)
    3e04:	1080040b 	ldhu	r2,16(r2)
    3e08:	10bfffcc 	andi	r2,r2,65535
    3e0c:	1009883a 	mov	r4,r2
    3e10:	00088d00 	call	88d0 <mem_malloc>
    3e14:	e0fffe17 	ldw	r3,-8(fp)
    3e18:	18800315 	stw	r2,12(r3)
    if (dhcp->options_in == NULL) {
    3e1c:	e0bffe17 	ldw	r2,-8(fp)
    3e20:	10800317 	ldw	r2,12(r2)
    3e24:	1000041e 	bne	r2,zero,3e38 <dhcp_unfold_reply+0xb0>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
        ("dhcp_unfold_reply(): could not allocate dhcp->options\n"));
      dhcp->options_in_len = 0;
    3e28:	e0bffe17 	ldw	r2,-8(fp)
    3e2c:	1000040d 	sth	zero,16(r2)
      return ERR_MEM;
    3e30:	00bfffc4 	movi	r2,-1
    3e34:	00004506 	br	3f4c <dhcp_unfold_reply+0x1c4>
    }
  }
  dhcp->msg_in = mem_malloc(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
    3e38:	01003c04 	movi	r4,240
    3e3c:	00088d00 	call	88d0 <mem_malloc>
    3e40:	e0fffe17 	ldw	r3,-8(fp)
    3e44:	18800215 	stw	r2,8(r3)
  if (dhcp->msg_in == NULL) {
    3e48:	e0bffe17 	ldw	r2,-8(fp)
    3e4c:	10800217 	ldw	r2,8(r2)
    3e50:	10000d1e 	bne	r2,zero,3e88 <dhcp_unfold_reply+0x100>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("dhcp_unfold_reply(): could not allocate dhcp->msg_in\n"));
    if (dhcp->options_in != NULL) {
    3e54:	e0bffe17 	ldw	r2,-8(fp)
    3e58:	10800317 	ldw	r2,12(r2)
    3e5c:	10000826 	beq	r2,zero,3e80 <dhcp_unfold_reply+0xf8>
      mem_free(dhcp->options_in);
    3e60:	e0bffe17 	ldw	r2,-8(fp)
    3e64:	10800317 	ldw	r2,12(r2)
    3e68:	1009883a 	mov	r4,r2
    3e6c:	000842c0 	call	842c <mem_free>
      dhcp->options_in = NULL;
    3e70:	e0bffe17 	ldw	r2,-8(fp)
    3e74:	10000315 	stw	zero,12(r2)
      dhcp->options_in_len = 0;
    3e78:	e0bffe17 	ldw	r2,-8(fp)
    3e7c:	1000040d 	sth	zero,16(r2)
    }
    return ERR_MEM;
    3e80:	00bfffc4 	movi	r2,-1
    3e84:	00003106 	br	3f4c <dhcp_unfold_reply+0x1c4>
  }

  /** copy the DHCP message without options */
  ret = pbuf_copy_partial(p, dhcp->msg_in, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN, 0);
    3e88:	e0bffe17 	ldw	r2,-8(fp)
    3e8c:	10800217 	ldw	r2,8(r2)
    3e90:	e13fff17 	ldw	r4,-4(fp)
    3e94:	100b883a 	mov	r5,r2
    3e98:	01803c04 	movi	r6,240
    3e9c:	000f883a 	mov	r7,zero
    3ea0:	000a9340 	call	a934 <pbuf_copy_partial>
    3ea4:	e0bffd0d 	sth	r2,-12(fp)
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
    3ea8:	e0bffd0b 	ldhu	r2,-12(fp)
    3eac:	10803c20 	cmpeqi	r2,r2,240
    3eb0:	1000091e 	bne	r2,zero,3ed8 <dhcp_unfold_reply+0x150>
    3eb4:	010000f4 	movhi	r4,3
    3eb8:	21352e04 	addi	r4,r4,-11080
    3ebc:	014000f4 	movhi	r5,3
    3ec0:	2975a704 	addi	r5,r5,-10596
    3ec4:	01814b04 	movi	r6,1324
    3ec8:	01c000f4 	movhi	r7,3
    3ecc:	39f53c04 	addi	r7,r7,-11024
    3ed0:	00166c00 	call	166c0 <printf>
    3ed4:	003fff06 	br	3ed4 <dhcp_unfold_reply+0x14c>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_unfold_reply(): copied %"U16_F" bytes into dhcp->msg_in[]\n",
     sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN));

  if (dhcp->options_in != NULL) {
    3ed8:	e0bffe17 	ldw	r2,-8(fp)
    3edc:	10800317 	ldw	r2,12(r2)
    3ee0:	10001926 	beq	r2,zero,3f48 <dhcp_unfold_reply+0x1c0>
    /** copy the DHCP options */
    ret = pbuf_copy_partial(p, dhcp->options_in, dhcp->options_in_len, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
    3ee4:	e0bffe17 	ldw	r2,-8(fp)
    3ee8:	10c00317 	ldw	r3,12(r2)
    3eec:	e0bffe17 	ldw	r2,-8(fp)
    3ef0:	1080040b 	ldhu	r2,16(r2)
    3ef4:	10bfffcc 	andi	r2,r2,65535
    3ef8:	e13fff17 	ldw	r4,-4(fp)
    3efc:	180b883a 	mov	r5,r3
    3f00:	100d883a 	mov	r6,r2
    3f04:	01c03c04 	movi	r7,240
    3f08:	000a9340 	call	a934 <pbuf_copy_partial>
    3f0c:	e0bffd0d 	sth	r2,-12(fp)
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
    3f10:	e0bffe17 	ldw	r2,-8(fp)
    3f14:	1080040b 	ldhu	r2,16(r2)
    3f18:	10ffffcc 	andi	r3,r2,65535
    3f1c:	e0bffd0b 	ldhu	r2,-12(fp)
    3f20:	18800926 	beq	r3,r2,3f48 <dhcp_unfold_reply+0x1c0>
    3f24:	010000f4 	movhi	r4,3
    3f28:	21352e04 	addi	r4,r4,-11080
    3f2c:	014000f4 	movhi	r5,3
    3f30:	2975b404 	addi	r5,r5,-10544
    3f34:	01814cc4 	movi	r6,1331
    3f38:	01c000f4 	movhi	r7,3
    3f3c:	39f53c04 	addi	r7,r7,-11024
    3f40:	00166c00 	call	166c0 <printf>
    3f44:	003fff06 	br	3f44 <dhcp_unfold_reply+0x1bc>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_unfold_reply(): copied %"U16_F" bytes to dhcp->options_in[]\n",
      dhcp->options_in_len));
  }
  LWIP_UNUSED_ARG(ret);
  return ERR_OK;
    3f48:	0005883a 	mov	r2,zero
}
    3f4c:	e037883a 	mov	sp,fp
    3f50:	dfc00117 	ldw	ra,4(sp)
    3f54:	df000017 	ldw	fp,0(sp)
    3f58:	dec00204 	addi	sp,sp,8
    3f5c:	f800283a 	ret

00003f60 <dhcp_free_reply>:
/**
 * Free the incoming DHCP message including contiguous copy of
 * its DHCP options.
 */
static void dhcp_free_reply(struct dhcp *dhcp)
{
    3f60:	defffd04 	addi	sp,sp,-12
    3f64:	dfc00215 	stw	ra,8(sp)
    3f68:	df000115 	stw	fp,4(sp)
    3f6c:	df000104 	addi	fp,sp,4
    3f70:	e13fff15 	stw	r4,-4(fp)
  if (dhcp->msg_in != NULL) {
    3f74:	e0bfff17 	ldw	r2,-4(fp)
    3f78:	10800217 	ldw	r2,8(r2)
    3f7c:	10000626 	beq	r2,zero,3f98 <dhcp_free_reply+0x38>
    mem_free((void *)dhcp->msg_in);
    3f80:	e0bfff17 	ldw	r2,-4(fp)
    3f84:	10800217 	ldw	r2,8(r2)
    3f88:	1009883a 	mov	r4,r2
    3f8c:	000842c0 	call	842c <mem_free>
    dhcp->msg_in = NULL;
    3f90:	e0bfff17 	ldw	r2,-4(fp)
    3f94:	10000215 	stw	zero,8(r2)
  }
  if (dhcp->options_in) {
    3f98:	e0bfff17 	ldw	r2,-4(fp)
    3f9c:	10800317 	ldw	r2,12(r2)
    3fa0:	10000826 	beq	r2,zero,3fc4 <dhcp_free_reply+0x64>
    mem_free(dhcp->options_in);
    3fa4:	e0bfff17 	ldw	r2,-4(fp)
    3fa8:	10800317 	ldw	r2,12(r2)
    3fac:	1009883a 	mov	r4,r2
    3fb0:	000842c0 	call	842c <mem_free>
    dhcp->options_in = NULL;
    3fb4:	e0bfff17 	ldw	r2,-4(fp)
    3fb8:	10000315 	stw	zero,12(r2)
    dhcp->options_in_len = 0;
    3fbc:	e0bfff17 	ldw	r2,-4(fp)
    3fc0:	1000040d 	sth	zero,16(r2)
  }
  LWIP_DEBUGF(DHCP_DEBUG, ("dhcp_free_reply(): free'd\n"));
}
    3fc4:	e037883a 	mov	sp,fp
    3fc8:	dfc00117 	ldw	ra,4(sp)
    3fcc:	df000017 	ldw	fp,0(sp)
    3fd0:	dec00204 	addi	sp,sp,8
    3fd4:	f800283a 	ret

00003fd8 <dhcp_recv>:

/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, struct ip_addr *addr, u16_t port)
{
    3fd8:	defff304 	addi	sp,sp,-52
    3fdc:	dfc00c15 	stw	ra,48(sp)
    3fe0:	df000b15 	stw	fp,44(sp)
    3fe4:	df000b04 	addi	fp,sp,44
    3fe8:	e13ffb15 	stw	r4,-20(fp)
    3fec:	e17ffc15 	stw	r5,-16(fp)
    3ff0:	e1bffd15 	stw	r6,-12(fp)
    3ff4:	e1fffe15 	stw	r7,-8(fp)
    3ff8:	e0800217 	ldw	r2,8(fp)
    3ffc:	e0bfff0d 	sth	r2,-4(fp)
  struct netif *netif = (struct netif *)arg;
    4000:	e0bffb17 	ldw	r2,-20(fp)
    4004:	e0bff615 	stw	r2,-40(fp)
  struct dhcp *dhcp = netif->dhcp;
    4008:	e0bff617 	ldw	r2,-40(fp)
    400c:	10800817 	ldw	r2,32(r2)
    4010:	e0bff715 	stw	r2,-36(fp)
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
    4014:	e0bffd17 	ldw	r2,-12(fp)
    4018:	10800117 	ldw	r2,4(r2)
    401c:	e0bff815 	stw	r2,-32(fp)
  /* prevent warnings about unused arguments */
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);

  LWIP_ASSERT("reply wasn't freed", dhcp->msg_in == NULL &&
    4020:	e0bff717 	ldw	r2,-36(fp)
    4024:	10800217 	ldw	r2,8(r2)
    4028:	1000071e 	bne	r2,zero,4048 <dhcp_recv+0x70>
    402c:	e0bff717 	ldw	r2,-36(fp)
    4030:	10800317 	ldw	r2,12(r2)
    4034:	1000041e 	bne	r2,zero,4048 <dhcp_recv+0x70>
    4038:	e0bff717 	ldw	r2,-36(fp)
    403c:	1080040b 	ldhu	r2,16(r2)
    4040:	10bfffcc 	andi	r2,r2,65535
    4044:	10000926 	beq	r2,zero,406c <dhcp_recv+0x94>
    4048:	010000f4 	movhi	r4,3
    404c:	21352e04 	addi	r4,r4,-11080
    4050:	014000f4 	movhi	r5,3
    4054:	29754804 	addi	r5,r5,-10976
    4058:	018158c4 	movi	r6,1379
    405c:	01c000f4 	movhi	r7,3
    4060:	39f53c04 	addi	r7,r7,-11024
    4064:	00166c00 	call	166c0 <printf>
    4068:	003fff06 	br	4068 <dhcp_recv+0x90>
    dhcp->options_in == NULL && dhcp->options_in_len == 0);

  if (p->len < DHCP_MIN_REPLY_LEN) {
    406c:	e0bffd17 	ldw	r2,-12(fp)
    4070:	1080028b 	ldhu	r2,10(r2)
    4074:	10bfffcc 	andi	r2,r2,65535
    4078:	10800b28 	cmpgeui	r2,r2,44
    407c:	10009a26 	beq	r2,zero,42e8 <dhcp_recv+0x310>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP reply message too short\n"));
    goto free_pbuf_and_return;
  }

  if (reply_msg->op != DHCP_BOOTREPLY) {
    4080:	e0bff817 	ldw	r2,-32(fp)
    4084:	10800003 	ldbu	r2,0(r2)
    4088:	10803fcc 	andi	r2,r2,255
    408c:	108000a0 	cmpeqi	r2,r2,2
    4090:	10009726 	beq	r2,zero,42f0 <dhcp_recv+0x318>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
    4094:	e03ff505 	stb	zero,-44(fp)
    4098:	00001006 	br	40dc <dhcp_recv+0x104>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
    409c:	e0bff503 	ldbu	r2,-44(fp)
    40a0:	e0fff617 	ldw	r3,-40(fp)
    40a4:	1885883a 	add	r2,r3,r2
    40a8:	10800904 	addi	r2,r2,36
    40ac:	10c000c3 	ldbu	r3,3(r2)
    40b0:	e0bff503 	ldbu	r2,-44(fp)
    40b4:	e13ff817 	ldw	r4,-32(fp)
    40b8:	2085883a 	add	r2,r4,r2
    40bc:	10800704 	addi	r2,r2,28
    40c0:	10800003 	ldbu	r2,0(r2)
    40c4:	18c03fcc 	andi	r3,r3,255
    40c8:	10803fcc 	andi	r2,r2,255
    40cc:	18808a1e 	bne	r3,r2,42f8 <dhcp_recv+0x320>
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
    40d0:	e0bff503 	ldbu	r2,-44(fp)
    40d4:	10800044 	addi	r2,r2,1
    40d8:	e0bff505 	stb	r2,-44(fp)
    40dc:	e0bff617 	ldw	r2,-40(fp)
    40e0:	10800983 	ldbu	r2,38(r2)
    40e4:	10803fcc 	andi	r2,r2,255
    40e8:	e0fff503 	ldbu	r3,-44(fp)
    40ec:	18bfeb36 	bltu	r3,r2,409c <dhcp_recv+0xc4>
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
    }
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
    40f0:	e0bff817 	ldw	r2,-32(fp)
    40f4:	10c0010b 	ldhu	r3,4(r2)
    40f8:	1080018b 	ldhu	r2,6(r2)
    40fc:	1004943a 	slli	r2,r2,16
    4100:	10c4b03a 	or	r2,r2,r3
    4104:	1006d63a 	srli	r3,r2,24
    4108:	e0bff817 	ldw	r2,-32(fp)
    410c:	1100010b 	ldhu	r4,4(r2)
    4110:	1080018b 	ldhu	r2,6(r2)
    4114:	1004943a 	slli	r2,r2,16
    4118:	1104b03a 	or	r2,r2,r4
    411c:	1004d23a 	srli	r2,r2,8
    4120:	10bfc00c 	andi	r2,r2,65280
    4124:	1886b03a 	or	r3,r3,r2
    4128:	e0bff817 	ldw	r2,-32(fp)
    412c:	1100010b 	ldhu	r4,4(r2)
    4130:	1080018b 	ldhu	r2,6(r2)
    4134:	1004943a 	slli	r2,r2,16
    4138:	1104b03a 	or	r2,r2,r4
    413c:	10bfc00c 	andi	r2,r2,65280
    4140:	1004923a 	slli	r2,r2,8
    4144:	1886b03a 	or	r3,r3,r2
    4148:	e0bff817 	ldw	r2,-32(fp)
    414c:	1100010b 	ldhu	r4,4(r2)
    4150:	1080018b 	ldhu	r2,6(r2)
    4154:	1004943a 	slli	r2,r2,16
    4158:	1104b03a 	or	r2,r2,r4
    415c:	1004963a 	slli	r2,r2,24
    4160:	1886b03a 	or	r3,r3,r2
    4164:	e0bff717 	ldw	r2,-36(fp)
    4168:	10800017 	ldw	r2,0(r2)
    416c:	1880641e 	bne	r3,r2,4300 <dhcp_recv+0x328>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("transaction id mismatch reply_msg->xid(%"X32_F")!=dhcp->xid(%"X32_F")\n",ntohl(reply_msg->xid),dhcp->xid));
    goto free_pbuf_and_return;
  }
  /* option fields could be unfold? */
  if (dhcp_unfold_reply(dhcp, p) != ERR_OK) {
    4170:	e13ff717 	ldw	r4,-36(fp)
    4174:	e17ffd17 	ldw	r5,-12(fp)
    4178:	0003d880 	call	3d88 <dhcp_unfold_reply>
    417c:	10803fcc 	andi	r2,r2,255
    4180:	1080201c 	xori	r2,r2,128
    4184:	10bfe004 	addi	r2,r2,-128
    4188:	10005f1e 	bne	r2,zero,4308 <dhcp_recv+0x330>
    goto free_pbuf_and_return;
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
    418c:	e13ff717 	ldw	r4,-36(fp)
    4190:	01400d44 	movi	r5,53
    4194:	0004a740 	call	4a74 <dhcp_get_option_ptr>
    4198:	e0bff915 	stw	r2,-28(fp)
  if (options_ptr == NULL) {
    419c:	e0bff917 	ldw	r2,-28(fp)
    41a0:	10005b26 	beq	r2,zero,4310 <dhcp_recv+0x338>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
    goto free_pbuf_and_return;
  }

  /* read DHCP message type */
  msg_type = dhcp_get_option_byte(options_ptr + 2);
    41a4:	e0bff917 	ldw	r2,-28(fp)
    41a8:	10800084 	addi	r2,r2,2
    41ac:	1009883a 	mov	r4,r2
    41b0:	0004ca80 	call	4ca8 <dhcp_get_option_byte>
    41b4:	e0bffa05 	stb	r2,-24(fp)
  /* message type is DHCP ACK? */
  if (msg_type == DHCP_ACK) {
    41b8:	e0bffa03 	ldbu	r2,-24(fp)
    41bc:	10800158 	cmpnei	r2,r2,5
    41c0:	1000201e 	bne	r2,zero,4244 <dhcp_recv+0x26c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
    41c4:	e0bff717 	ldw	r2,-36(fp)
    41c8:	10800483 	ldbu	r2,18(r2)
    41cc:	10803fcc 	andi	r2,r2,255
    41d0:	10800058 	cmpnei	r2,r2,1
    41d4:	1000071e 	bne	r2,zero,41f4 <dhcp_recv+0x21c>
      dhcp_handle_ack(netif);
    41d8:	e13ff617 	ldw	r4,-40(fp)
    41dc:	00021dc0 	call	21dc <dhcp_handle_ack>
      dhcp->request_timeout = 0;
    41e0:	e0bff717 	ldw	r2,-36(fp)
    41e4:	1000078d 	sth	zero,30(r2)
#if DHCP_DOES_ARP_CHECK
      /* check if the acknowledged lease address is already in use */
      dhcp_check(netif);
    41e8:	e13ff617 	ldw	r4,-40(fp)
    41ec:	00019e80 	call	19e8 <dhcp_check>
    41f0:	00004806 	br	4314 <dhcp_recv+0x33c>
      /* bind interface to the acknowledged lease address */
      dhcp_bind(netif);
#endif
    }
    /* already bound to the given lease address? */
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
    41f4:	e0bff717 	ldw	r2,-36(fp)
    41f8:	10800483 	ldbu	r2,18(r2)
    41fc:	10803fcc 	andi	r2,r2,255
    4200:	108000e0 	cmpeqi	r2,r2,3
    4204:	10000a1e 	bne	r2,zero,4230 <dhcp_recv+0x258>
    4208:	e0bff717 	ldw	r2,-36(fp)
    420c:	10800483 	ldbu	r2,18(r2)
    4210:	10803fcc 	andi	r2,r2,255
    4214:	10800120 	cmpeqi	r2,r2,4
    4218:	1000051e 	bne	r2,zero,4230 <dhcp_recv+0x258>
    421c:	e0bff717 	ldw	r2,-36(fp)
    4220:	10800483 	ldbu	r2,18(r2)
    4224:	10803fcc 	andi	r2,r2,255
    4228:	10800158 	cmpnei	r2,r2,5
    422c:	1000391e 	bne	r2,zero,4314 <dhcp_recv+0x33c>
      dhcp->request_timeout = 0;
    4230:	e0bff717 	ldw	r2,-36(fp)
    4234:	1000078d 	sth	zero,30(r2)
      dhcp_bind(netif);
    4238:	e13ff617 	ldw	r4,-40(fp)
    423c:	0002e740 	call	2e74 <dhcp_bind>
    4240:	00003406 	br	4314 <dhcp_recv+0x33c>
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
    4244:	e0bffa03 	ldbu	r2,-24(fp)
    4248:	10800198 	cmpnei	r2,r2,6
    424c:	1000191e 	bne	r2,zero,42b4 <dhcp_recv+0x2dc>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
    4250:	e0bff717 	ldw	r2,-36(fp)
    4254:	10800483 	ldbu	r2,18(r2)
      dhcp->request_timeout = 0;
      dhcp_bind(netif);
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
    4258:	10803fcc 	andi	r2,r2,255
    425c:	108000e0 	cmpeqi	r2,r2,3
    4260:	10000f1e 	bne	r2,zero,42a0 <dhcp_recv+0x2c8>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
    4264:	e0bff717 	ldw	r2,-36(fp)
    4268:	10800483 	ldbu	r2,18(r2)
    426c:	10803fcc 	andi	r2,r2,255
    4270:	10800060 	cmpeqi	r2,r2,1
    4274:	10000a1e 	bne	r2,zero,42a0 <dhcp_recv+0x2c8>
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
    4278:	e0bff717 	ldw	r2,-36(fp)
    427c:	10800483 	ldbu	r2,18(r2)
      dhcp_bind(netif);
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
    4280:	10803fcc 	andi	r2,r2,255
    4284:	10800120 	cmpeqi	r2,r2,4
    4288:	1000051e 	bne	r2,zero,42a0 <dhcp_recv+0x2c8>
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
    428c:	e0bff717 	ldw	r2,-36(fp)
    4290:	10800483 	ldbu	r2,18(r2)
    4294:	10803fcc 	andi	r2,r2,255
    4298:	10800158 	cmpnei	r2,r2,5
    429c:	1000051e 	bne	r2,zero,42b4 <dhcp_recv+0x2dc>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
    42a0:	e0bff717 	ldw	r2,-36(fp)
    42a4:	1000078d 	sth	zero,30(r2)
    dhcp_handle_nak(netif);
    42a8:	e13ff617 	ldw	r4,-40(fp)
    42ac:	00019680 	call	1968 <dhcp_handle_nak>
    42b0:	00001806 	br	4314 <dhcp_recv+0x33c>
  }
  /* received a DHCP_OFFER in DHCP_SELECTING state? */
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
    42b4:	e0bffa03 	ldbu	r2,-24(fp)
    42b8:	10800098 	cmpnei	r2,r2,2
    42bc:	1000151e 	bne	r2,zero,4314 <dhcp_recv+0x33c>
    42c0:	e0bff717 	ldw	r2,-36(fp)
    42c4:	10800483 	ldbu	r2,18(r2)
    42c8:	10803fcc 	andi	r2,r2,255
    42cc:	10800198 	cmpnei	r2,r2,6
    42d0:	1000101e 	bne	r2,zero,4314 <dhcp_recv+0x33c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_OFFER received in DHCP_SELECTING state\n"));
    dhcp->request_timeout = 0;
    42d4:	e0bff717 	ldw	r2,-36(fp)
    42d8:	1000078d 	sth	zero,30(r2)
    /* remember offered lease */
    dhcp_handle_offer(netif);
    42dc:	e13ff617 	ldw	r4,-40(fp)
    42e0:	0001a800 	call	1a80 <dhcp_handle_offer>
    42e4:	00000b06 	br	4314 <dhcp_recv+0x33c>
  LWIP_ASSERT("reply wasn't freed", dhcp->msg_in == NULL &&
    dhcp->options_in == NULL && dhcp->options_in_len == 0);

  if (p->len < DHCP_MIN_REPLY_LEN) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP reply message too short\n"));
    goto free_pbuf_and_return;
    42e8:	0001883a 	nop
    42ec:	00000906 	br	4314 <dhcp_recv+0x33c>
  }

  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
    42f0:	0001883a 	nop
    42f4:	00000706 	br	4314 <dhcp_recv+0x33c>
  for (i = 0; i < netif->hwaddr_len; i++) {
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
        ("netif->hwaddr[%"U16_F"]==%02"X16_F" != reply_msg->chaddr[%"U16_F"]==%02"X16_F"\n",
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
    42f8:	0001883a 	nop
    42fc:	00000506 	br	4314 <dhcp_recv+0x33c>
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("transaction id mismatch reply_msg->xid(%"X32_F")!=dhcp->xid(%"X32_F")\n",ntohl(reply_msg->xid),dhcp->xid));
    goto free_pbuf_and_return;
    4300:	0001883a 	nop
    4304:	00000306 	br	4314 <dhcp_recv+0x33c>
  }
  /* option fields could be unfold? */
  if (dhcp_unfold_reply(dhcp, p) != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("problem unfolding DHCP message - too short on memory?\n"));
    goto free_pbuf_and_return;
    4308:	0001883a 	nop
    430c:	00000106 	br	4314 <dhcp_recv+0x33c>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
  if (options_ptr == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
    goto free_pbuf_and_return;
    4310:	0001883a 	nop
    dhcp->request_timeout = 0;
    /* remember offered lease */
    dhcp_handle_offer(netif);
  }
free_pbuf_and_return:
  dhcp_free_reply(dhcp);
    4314:	e13ff717 	ldw	r4,-36(fp)
    4318:	0003f600 	call	3f60 <dhcp_free_reply>
  pbuf_free(p);
    431c:	e13ffd17 	ldw	r4,-12(fp)
    4320:	000a16c0 	call	a16c <pbuf_free>
}
    4324:	e037883a 	mov	sp,fp
    4328:	dfc00117 	ldw	ra,4(sp)
    432c:	df000017 	ldw	fp,0(sp)
    4330:	dec00204 	addi	sp,sp,8
    4334:	f800283a 	ret

00004338 <dhcp_create_request>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_create_request(struct netif *netif)
{
    4338:	defffb04 	addi	sp,sp,-20
    433c:	dfc00415 	stw	ra,16(sp)
    4340:	df000315 	stw	fp,12(sp)
    4344:	df000304 	addi	fp,sp,12
    4348:	e13fff15 	stw	r4,-4(fp)
  if (!xid_initialised) {
    xid = DHCP_GLOBAL_XID;
    xid_initialised = !xid_initialised;
  }
#endif
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
    434c:	e0bfff17 	ldw	r2,-4(fp)
    4350:	1000091e 	bne	r2,zero,4378 <dhcp_create_request+0x40>
    4354:	010000f4 	movhi	r4,3
    4358:	21352e04 	addi	r4,r4,-11080
    435c:	014000f4 	movhi	r5,3
    4360:	2975bb04 	addi	r5,r5,-10516
    4364:	018173c4 	movi	r6,1487
    4368:	01c000f4 	movhi	r7,3
    436c:	39f53c04 	addi	r7,r7,-11024
    4370:	00166c00 	call	166c0 <printf>
    4374:	003fff06 	br	4374 <dhcp_create_request+0x3c>
  dhcp = netif->dhcp;
    4378:	e0bfff17 	ldw	r2,-4(fp)
    437c:	10800817 	ldw	r2,32(r2)
    4380:	e0bffe15 	stw	r2,-8(fp)
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
    4384:	e0bffe17 	ldw	r2,-8(fp)
    4388:	1000091e 	bne	r2,zero,43b0 <dhcp_create_request+0x78>
    438c:	010000f4 	movhi	r4,3
    4390:	21352e04 	addi	r4,r4,-11080
    4394:	014000f4 	movhi	r5,3
    4398:	2975c404 	addi	r5,r5,-10480
    439c:	01817444 	movi	r6,1489
    43a0:	01c000f4 	movhi	r7,3
    43a4:	39f53c04 	addi	r7,r7,-11024
    43a8:	00166c00 	call	166c0 <printf>
    43ac:	003fff06 	br	43ac <dhcp_create_request+0x74>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
    43b0:	e0bffe17 	ldw	r2,-8(fp)
    43b4:	10800517 	ldw	r2,20(r2)
    43b8:	10000926 	beq	r2,zero,43e0 <dhcp_create_request+0xa8>
    43bc:	010000f4 	movhi	r4,3
    43c0:	21352e04 	addi	r4,r4,-11080
    43c4:	014000f4 	movhi	r5,3
    43c8:	2975cd04 	addi	r5,r5,-10444
    43cc:	01817484 	movi	r6,1490
    43d0:	01c000f4 	movhi	r7,3
    43d4:	39f53c04 	addi	r7,r7,-11024
    43d8:	00166c00 	call	166c0 <printf>
    43dc:	003fff06 	br	43dc <dhcp_create_request+0xa4>
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
    43e0:	e0bffe17 	ldw	r2,-8(fp)
    43e4:	10800617 	ldw	r2,24(r2)
    43e8:	10000926 	beq	r2,zero,4410 <dhcp_create_request+0xd8>
    43ec:	010000f4 	movhi	r4,3
    43f0:	21352e04 	addi	r4,r4,-11080
    43f4:	014000f4 	movhi	r5,3
    43f8:	2975d804 	addi	r5,r5,-10400
    43fc:	018174c4 	movi	r6,1491
    4400:	01c000f4 	movhi	r7,3
    4404:	39f53c04 	addi	r7,r7,-11024
    4408:	00166c00 	call	166c0 <printf>
    440c:	003fff06 	br	440c <dhcp_create_request+0xd4>
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
    4410:	0009883a 	mov	r4,zero
    4414:	01404d04 	movi	r5,308
    4418:	000d883a 	mov	r6,zero
    441c:	00097b00 	call	97b0 <pbuf_alloc>
    4420:	e0fffe17 	ldw	r3,-8(fp)
    4424:	18800515 	stw	r2,20(r3)
  if (dhcp->p_out == NULL) {
    4428:	e0bffe17 	ldw	r2,-8(fp)
    442c:	10800517 	ldw	r2,20(r2)
    4430:	1000021e 	bne	r2,zero,443c <dhcp_create_request+0x104>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("dhcp_create_request(): could not allocate pbuf\n"));
    return ERR_MEM;
    4434:	00bfffc4 	movi	r2,-1
    4438:	0000e206 	br	47c4 <dhcp_create_request+0x48c>
  }
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
    443c:	e0bffe17 	ldw	r2,-8(fp)
    4440:	10800517 	ldw	r2,20(r2)
    4444:	1080028b 	ldhu	r2,10(r2)
    4448:	10bfffcc 	andi	r2,r2,65535
    444c:	10804d28 	cmpgeui	r2,r2,308
    4450:	1000091e 	bne	r2,zero,4478 <dhcp_create_request+0x140>
    4454:	010000f4 	movhi	r4,3
    4458:	21352e04 	addi	r4,r4,-11080
    445c:	014000f4 	movhi	r5,3
    4460:	2975e304 	addi	r5,r5,-10356
    4464:	018176c4 	movi	r6,1499
    4468:	01c000f4 	movhi	r7,3
    446c:	39f53c04 	addi	r7,r7,-11024
    4470:	00166c00 	call	166c0 <printf>
    4474:	003fff06 	br	4474 <dhcp_create_request+0x13c>
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* reuse transaction identifier in retransmissions */
  if (dhcp->tries==0)
    4478:	e0bffe17 	ldw	r2,-8(fp)
    447c:	108004c3 	ldbu	r2,19(r2)
    4480:	10803fcc 	andi	r2,r2,255
    4484:	1000031e 	bne	r2,zero,4494 <dhcp_create_request+0x15c>
      xid++;
    4488:	d0a00017 	ldw	r2,-32768(gp)
    448c:	10800044 	addi	r2,r2,1
    4490:	d0a00015 	stw	r2,-32768(gp)
  dhcp->xid = xid;
    4494:	d0e00017 	ldw	r3,-32768(gp)
    4498:	e0bffe17 	ldw	r2,-8(fp)
    449c:	10c00015 	stw	r3,0(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
              ("transaction id xid(%"X32_F")\n", xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
    44a0:	e0bffe17 	ldw	r2,-8(fp)
    44a4:	10800517 	ldw	r2,20(r2)
    44a8:	10c00117 	ldw	r3,4(r2)
    44ac:	e0bffe17 	ldw	r2,-8(fp)
    44b0:	10c00615 	stw	r3,24(r2)

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
    44b4:	e0bffe17 	ldw	r2,-8(fp)
    44b8:	10800617 	ldw	r2,24(r2)
    44bc:	00c00044 	movi	r3,1
    44c0:	10c00005 	stb	r3,0(r2)
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
    44c4:	e0bffe17 	ldw	r2,-8(fp)
    44c8:	10800617 	ldw	r2,24(r2)
    44cc:	00c00044 	movi	r3,1
    44d0:	10c00045 	stb	r3,1(r2)
  /* TODO: make link layer independent */
  dhcp->msg_out->hlen = DHCP_HLEN_ETH;
    44d4:	e0bffe17 	ldw	r2,-8(fp)
    44d8:	10800617 	ldw	r2,24(r2)
    44dc:	00c00184 	movi	r3,6
    44e0:	10c00085 	stb	r3,2(r2)
  dhcp->msg_out->hops = 0;
    44e4:	e0bffe17 	ldw	r2,-8(fp)
    44e8:	10800617 	ldw	r2,24(r2)
    44ec:	100000c5 	stb	zero,3(r2)
  dhcp->msg_out->xid = htonl(dhcp->xid);
    44f0:	e0bffe17 	ldw	r2,-8(fp)
    44f4:	10800617 	ldw	r2,24(r2)
    44f8:	e0fffe17 	ldw	r3,-8(fp)
    44fc:	18c00017 	ldw	r3,0(r3)
    4500:	1808d63a 	srli	r4,r3,24
    4504:	e0fffe17 	ldw	r3,-8(fp)
    4508:	18c00017 	ldw	r3,0(r3)
    450c:	1806d23a 	srli	r3,r3,8
    4510:	18ffc00c 	andi	r3,r3,65280
    4514:	20c8b03a 	or	r4,r4,r3
    4518:	e0fffe17 	ldw	r3,-8(fp)
    451c:	18c00017 	ldw	r3,0(r3)
    4520:	18ffc00c 	andi	r3,r3,65280
    4524:	1806923a 	slli	r3,r3,8
    4528:	20c8b03a 	or	r4,r4,r3
    452c:	e0fffe17 	ldw	r3,-8(fp)
    4530:	18c00017 	ldw	r3,0(r3)
    4534:	1806963a 	slli	r3,r3,24
    4538:	20c6b03a 	or	r3,r4,r3
    453c:	193fffcc 	andi	r4,r3,65535
    4540:	1140010b 	ldhu	r5,4(r2)
    4544:	280a703a 	and	r5,r5,zero
    4548:	2908b03a 	or	r4,r5,r4
    454c:	1100010d 	sth	r4,4(r2)
    4550:	1806d43a 	srli	r3,r3,16
    4554:	1100018b 	ldhu	r4,6(r2)
    4558:	2008703a 	and	r4,r4,zero
    455c:	20c6b03a 	or	r3,r4,r3
    4560:	10c0018d 	sth	r3,6(r2)
  dhcp->msg_out->secs = 0;
    4564:	e0bffe17 	ldw	r2,-8(fp)
    4568:	10800617 	ldw	r2,24(r2)
    456c:	1000020d 	sth	zero,8(r2)
  dhcp->msg_out->flags = 0;
    4570:	e0bffe17 	ldw	r2,-8(fp)
    4574:	10800617 	ldw	r2,24(r2)
    4578:	1000028d 	sth	zero,10(r2)
  dhcp->msg_out->ciaddr.addr = 0;
    457c:	e0bffe17 	ldw	r2,-8(fp)
    4580:	10800617 	ldw	r2,24(r2)
    4584:	10c0030b 	ldhu	r3,12(r2)
    4588:	1806703a 	and	r3,r3,zero
    458c:	10c0030d 	sth	r3,12(r2)
    4590:	10c0038b 	ldhu	r3,14(r2)
    4594:	1806703a 	and	r3,r3,zero
    4598:	10c0038d 	sth	r3,14(r2)
  if (dhcp->state==DHCP_BOUND || dhcp->state==DHCP_RENEWING || dhcp->state==DHCP_REBINDING) {
    459c:	e0bffe17 	ldw	r2,-8(fp)
    45a0:	10800483 	ldbu	r2,18(r2)
    45a4:	10803fcc 	andi	r2,r2,255
    45a8:	108002a0 	cmpeqi	r2,r2,10
    45ac:	10000a1e 	bne	r2,zero,45d8 <dhcp_create_request+0x2a0>
    45b0:	e0bffe17 	ldw	r2,-8(fp)
    45b4:	10800483 	ldbu	r2,18(r2)
    45b8:	10803fcc 	andi	r2,r2,255
    45bc:	10800160 	cmpeqi	r2,r2,5
    45c0:	1000051e 	bne	r2,zero,45d8 <dhcp_create_request+0x2a0>
    45c4:	e0bffe17 	ldw	r2,-8(fp)
    45c8:	10800483 	ldbu	r2,18(r2)
    45cc:	10803fcc 	andi	r2,r2,255
    45d0:	10800118 	cmpnei	r2,r2,4
    45d4:	10000e1e 	bne	r2,zero,4610 <dhcp_create_request+0x2d8>
    dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
    45d8:	e0bffe17 	ldw	r2,-8(fp)
    45dc:	10800617 	ldw	r2,24(r2)
    45e0:	e0ffff17 	ldw	r3,-4(fp)
    45e4:	18c00117 	ldw	r3,4(r3)
    45e8:	193fffcc 	andi	r4,r3,65535
    45ec:	1140030b 	ldhu	r5,12(r2)
    45f0:	280a703a 	and	r5,r5,zero
    45f4:	2908b03a 	or	r4,r5,r4
    45f8:	1100030d 	sth	r4,12(r2)
    45fc:	1806d43a 	srli	r3,r3,16
    4600:	1100038b 	ldhu	r4,14(r2)
    4604:	2008703a 	and	r4,r4,zero
    4608:	20c6b03a 	or	r3,r4,r3
    460c:	10c0038d 	sth	r3,14(r2)
  }
  dhcp->msg_out->yiaddr.addr = 0;
    4610:	e0bffe17 	ldw	r2,-8(fp)
    4614:	10800617 	ldw	r2,24(r2)
    4618:	10c0040b 	ldhu	r3,16(r2)
    461c:	1806703a 	and	r3,r3,zero
    4620:	10c0040d 	sth	r3,16(r2)
    4624:	10c0048b 	ldhu	r3,18(r2)
    4628:	1806703a 	and	r3,r3,zero
    462c:	10c0048d 	sth	r3,18(r2)
  dhcp->msg_out->siaddr.addr = 0;
    4630:	e0bffe17 	ldw	r2,-8(fp)
    4634:	10800617 	ldw	r2,24(r2)
    4638:	10c0050b 	ldhu	r3,20(r2)
    463c:	1806703a 	and	r3,r3,zero
    4640:	10c0050d 	sth	r3,20(r2)
    4644:	10c0058b 	ldhu	r3,22(r2)
    4648:	1806703a 	and	r3,r3,zero
    464c:	10c0058d 	sth	r3,22(r2)
  dhcp->msg_out->giaddr.addr = 0;
    4650:	e0bffe17 	ldw	r2,-8(fp)
    4654:	10800617 	ldw	r2,24(r2)
    4658:	10c0060b 	ldhu	r3,24(r2)
    465c:	1806703a 	and	r3,r3,zero
    4660:	10c0060d 	sth	r3,24(r2)
    4664:	10c0068b 	ldhu	r3,26(r2)
    4668:	1806703a 	and	r3,r3,zero
    466c:	10c0068d 	sth	r3,26(r2)
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    4670:	e03ffd0d 	sth	zero,-12(fp)
    4674:	00001606 	br	46d0 <dhcp_create_request+0x398>
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
    4678:	e0bffe17 	ldw	r2,-8(fp)
    467c:	11000617 	ldw	r4,24(r2)
    4680:	e0fffd0b 	ldhu	r3,-12(fp)
    4684:	e0bfff17 	ldw	r2,-4(fp)
    4688:	10800983 	ldbu	r2,38(r2)
    468c:	10803fcc 	andi	r2,r2,255
    4690:	10bfffcc 	andi	r2,r2,65535
    4694:	e17ffd0b 	ldhu	r5,-12(fp)
    4698:	2880062e 	bgeu	r5,r2,46b4 <dhcp_create_request+0x37c>
    469c:	e0bffd0b 	ldhu	r2,-12(fp)
    46a0:	e17fff17 	ldw	r5,-4(fp)
    46a4:	2885883a 	add	r2,r5,r2
    46a8:	10800904 	addi	r2,r2,36
    46ac:	108000c3 	ldbu	r2,3(r2)
    46b0:	00000106 	br	46b8 <dhcp_create_request+0x380>
    46b4:	0005883a 	mov	r2,zero
    46b8:	20c7883a 	add	r3,r4,r3
    46bc:	18c00704 	addi	r3,r3,28
    46c0:	18800005 	stb	r2,0(r3)
    dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  }
  dhcp->msg_out->yiaddr.addr = 0;
  dhcp->msg_out->siaddr.addr = 0;
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    46c4:	e0bffd0b 	ldhu	r2,-12(fp)
    46c8:	10800044 	addi	r2,r2,1
    46cc:	e0bffd0d 	sth	r2,-12(fp)
    46d0:	e0bffd0b 	ldhu	r2,-12(fp)
    46d4:	10800430 	cmpltui	r2,r2,16
    46d8:	103fe71e 	bne	r2,zero,4678 <dhcp_create_request+0x340>
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    46dc:	e03ffd0d 	sth	zero,-12(fp)
    46e0:	00000906 	br	4708 <dhcp_create_request+0x3d0>
    dhcp->msg_out->sname[i] = 0;
    46e4:	e0bffe17 	ldw	r2,-8(fp)
    46e8:	10c00617 	ldw	r3,24(r2)
    46ec:	e0bffd0b 	ldhu	r2,-12(fp)
    46f0:	1885883a 	add	r2,r3,r2
    46f4:	10800b04 	addi	r2,r2,44
    46f8:	10000005 	stb	zero,0(r2)
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    46fc:	e0bffd0b 	ldhu	r2,-12(fp)
    4700:	10800044 	addi	r2,r2,1
    4704:	e0bffd0d 	sth	r2,-12(fp)
    4708:	e0bffd0b 	ldhu	r2,-12(fp)
    470c:	10801030 	cmpltui	r2,r2,64
    4710:	103ff41e 	bne	r2,zero,46e4 <dhcp_create_request+0x3ac>
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
    4714:	e03ffd0d 	sth	zero,-12(fp)
    4718:	00000906 	br	4740 <dhcp_create_request+0x408>
    dhcp->msg_out->file[i] = 0;
    471c:	e0bffe17 	ldw	r2,-8(fp)
    4720:	10c00617 	ldw	r3,24(r2)
    4724:	e0bffd0b 	ldhu	r2,-12(fp)
    4728:	1885883a 	add	r2,r3,r2
    472c:	10801b04 	addi	r2,r2,108
    4730:	10000005 	stb	zero,0(r2)
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
    4734:	e0bffd0b 	ldhu	r2,-12(fp)
    4738:	10800044 	addi	r2,r2,1
    473c:	e0bffd0d 	sth	r2,-12(fp)
    4740:	e0bffd0b 	ldhu	r2,-12(fp)
    4744:	10802030 	cmpltui	r2,r2,128
    4748:	103ff41e 	bne	r2,zero,471c <dhcp_create_request+0x3e4>
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
    474c:	e0bffe17 	ldw	r2,-8(fp)
    4750:	10800617 	ldw	r2,24(r2)
    4754:	10c03b0b 	ldhu	r3,236(r2)
    4758:	1806703a 	and	r3,r3,zero
    475c:	1809883a 	mov	r4,r3
    4760:	00e098c4 	movi	r3,-32157
    4764:	20c6b03a 	or	r3,r4,r3
    4768:	10c03b0d 	sth	r3,236(r2)
    476c:	10c03b8b 	ldhu	r3,238(r2)
    4770:	1806703a 	and	r3,r3,zero
    4774:	18d8d4d4 	ori	r3,r3,25427
    4778:	10c03b8d 	sth	r3,238(r2)
  dhcp->options_out_len = 0;
    477c:	e0bffe17 	ldw	r2,-8(fp)
    4780:	1000070d 	sth	zero,28(r2)
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    4784:	e03ffd0d 	sth	zero,-12(fp)
    4788:	00000a06 	br	47b4 <dhcp_create_request+0x47c>
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
    478c:	e0bffe17 	ldw	r2,-8(fp)
    4790:	11000617 	ldw	r4,24(r2)
    4794:	e0bffd0b 	ldhu	r2,-12(fp)
    4798:	e0fffd0b 	ldhu	r3,-12(fp)
    479c:	2085883a 	add	r2,r4,r2
    47a0:	10803c04 	addi	r2,r2,240
    47a4:	10c00005 	stb	r3,0(r2)
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  dhcp->options_out_len = 0;
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    47a8:	e0bffd0b 	ldhu	r2,-12(fp)
    47ac:	10800044 	addi	r2,r2,1
    47b0:	e0bffd0d 	sth	r2,-12(fp)
    47b4:	e0bffd0b 	ldhu	r2,-12(fp)
    47b8:	10801130 	cmpltui	r2,r2,68
    47bc:	103ff31e 	bne	r2,zero,478c <dhcp_create_request+0x454>
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  }
  return ERR_OK;
    47c0:	0005883a 	mov	r2,zero
}
    47c4:	e037883a 	mov	sp,fp
    47c8:	dfc00117 	ldw	ra,4(sp)
    47cc:	df000017 	ldw	fp,0(sp)
    47d0:	dec00204 	addi	sp,sp,8
    47d4:	f800283a 	ret

000047d8 <dhcp_delete_request>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_delete_request(struct netif *netif)
{
    47d8:	defffc04 	addi	sp,sp,-16
    47dc:	dfc00315 	stw	ra,12(sp)
    47e0:	df000215 	stw	fp,8(sp)
    47e4:	df000204 	addi	fp,sp,8
    47e8:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp;
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
    47ec:	e0bfff17 	ldw	r2,-4(fp)
    47f0:	1000091e 	bne	r2,zero,4818 <dhcp_delete_request+0x40>
    47f4:	010000f4 	movhi	r4,3
    47f8:	21352e04 	addi	r4,r4,-11080
    47fc:	014000f4 	movhi	r5,3
    4800:	2975f404 	addi	r5,r5,-10288
    4804:	01818484 	movi	r6,1554
    4808:	01c000f4 	movhi	r7,3
    480c:	39f53c04 	addi	r7,r7,-11024
    4810:	00166c00 	call	166c0 <printf>
    4814:	003fff06 	br	4814 <dhcp_delete_request+0x3c>
  dhcp = netif->dhcp;
    4818:	e0bfff17 	ldw	r2,-4(fp)
    481c:	10800817 	ldw	r2,32(r2)
    4820:	e0bffe15 	stw	r2,-8(fp)
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
    4824:	e0bffe17 	ldw	r2,-8(fp)
    4828:	1000091e 	bne	r2,zero,4850 <dhcp_delete_request+0x78>
    482c:	010000f4 	movhi	r4,3
    4830:	21352e04 	addi	r4,r4,-11080
    4834:	014000f4 	movhi	r5,3
    4838:	2975fd04 	addi	r5,r5,-10252
    483c:	01818504 	movi	r6,1556
    4840:	01c000f4 	movhi	r7,3
    4844:	39f53c04 	addi	r7,r7,-11024
    4848:	00166c00 	call	166c0 <printf>
    484c:	003fff06 	br	484c <dhcp_delete_request+0x74>
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
    4850:	e0bffe17 	ldw	r2,-8(fp)
    4854:	10800517 	ldw	r2,20(r2)
    4858:	1000091e 	bne	r2,zero,4880 <dhcp_delete_request+0xa8>
    485c:	010000f4 	movhi	r4,3
    4860:	21352e04 	addi	r4,r4,-11080
    4864:	014000f4 	movhi	r5,3
    4868:	29760604 	addi	r5,r5,-10216
    486c:	01818544 	movi	r6,1557
    4870:	01c000f4 	movhi	r7,3
    4874:	39f53c04 	addi	r7,r7,-11024
    4878:	00166c00 	call	166c0 <printf>
    487c:	003fff06 	br	487c <dhcp_delete_request+0xa4>
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
    4880:	e0bffe17 	ldw	r2,-8(fp)
    4884:	10800617 	ldw	r2,24(r2)
    4888:	1000091e 	bne	r2,zero,48b0 <dhcp_delete_request+0xd8>
    488c:	010000f4 	movhi	r4,3
    4890:	21352e04 	addi	r4,r4,-11080
    4894:	014000f4 	movhi	r5,3
    4898:	29761104 	addi	r5,r5,-10172
    489c:	01818584 	movi	r6,1558
    48a0:	01c000f4 	movhi	r7,3
    48a4:	39f53c04 	addi	r7,r7,-11024
    48a8:	00166c00 	call	166c0 <printf>
    48ac:	003fff06 	br	48ac <dhcp_delete_request+0xd4>
  if (dhcp->p_out != NULL) {
    48b0:	e0bffe17 	ldw	r2,-8(fp)
    48b4:	10800517 	ldw	r2,20(r2)
    48b8:	10000426 	beq	r2,zero,48cc <dhcp_delete_request+0xf4>
    pbuf_free(dhcp->p_out);
    48bc:	e0bffe17 	ldw	r2,-8(fp)
    48c0:	10800517 	ldw	r2,20(r2)
    48c4:	1009883a 	mov	r4,r2
    48c8:	000a16c0 	call	a16c <pbuf_free>
  }
  dhcp->p_out = NULL;
    48cc:	e0bffe17 	ldw	r2,-8(fp)
    48d0:	10000515 	stw	zero,20(r2)
  dhcp->msg_out = NULL;
    48d4:	e0bffe17 	ldw	r2,-8(fp)
    48d8:	10000615 	stw	zero,24(r2)
}
    48dc:	e037883a 	mov	sp,fp
    48e0:	dfc00117 	ldw	ra,4(sp)
    48e4:	df000017 	ldw	fp,0(sp)
    48e8:	dec00204 	addi	sp,sp,8
    48ec:	f800283a 	ret

000048f0 <dhcp_option_trailer>:
 *
 * @param dhcp DHCP state structure
 */
static void
dhcp_option_trailer(struct dhcp *dhcp)
{
    48f0:	defffd04 	addi	sp,sp,-12
    48f4:	dfc00215 	stw	ra,8(sp)
    48f8:	df000115 	stw	fp,4(sp)
    48fc:	df000104 	addi	fp,sp,4
    4900:	e13fff15 	stw	r4,-4(fp)
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
    4904:	e0bfff17 	ldw	r2,-4(fp)
    4908:	1000091e 	bne	r2,zero,4930 <dhcp_option_trailer+0x40>
    490c:	010000f4 	movhi	r4,3
    4910:	21352e04 	addi	r4,r4,-11080
    4914:	014000f4 	movhi	r5,3
    4918:	29761c04 	addi	r5,r5,-10128
    491c:	01818a44 	movi	r6,1577
    4920:	01c000f4 	movhi	r7,3
    4924:	39f53c04 	addi	r7,r7,-11024
    4928:	00166c00 	call	166c0 <printf>
    492c:	003fff06 	br	492c <dhcp_option_trailer+0x3c>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
    4930:	e0bfff17 	ldw	r2,-4(fp)
    4934:	10800617 	ldw	r2,24(r2)
    4938:	1000091e 	bne	r2,zero,4960 <dhcp_option_trailer+0x70>
    493c:	010000f4 	movhi	r4,3
    4940:	21352e04 	addi	r4,r4,-11080
    4944:	014000f4 	movhi	r5,3
    4948:	29762504 	addi	r5,r5,-10092
    494c:	01818a84 	movi	r6,1578
    4950:	01c000f4 	movhi	r7,3
    4954:	39f53c04 	addi	r7,r7,-11024
    4958:	00166c00 	call	166c0 <printf>
    495c:	003fff06 	br	495c <dhcp_option_trailer+0x6c>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
    4960:	e0bfff17 	ldw	r2,-4(fp)
    4964:	1080070b 	ldhu	r2,28(r2)
    4968:	10bfffcc 	andi	r2,r2,65535
    496c:	10801130 	cmpltui	r2,r2,68
    4970:	1000091e 	bne	r2,zero,4998 <dhcp_option_trailer+0xa8>
    4974:	010000f4 	movhi	r4,3
    4978:	21352e04 	addi	r4,r4,-11080
    497c:	014000f4 	movhi	r5,3
    4980:	29763004 	addi	r5,r5,-10048
    4984:	01818ac4 	movi	r6,1579
    4988:	01c000f4 	movhi	r7,3
    498c:	39f53c04 	addi	r7,r7,-11024
    4990:	00166c00 	call	166c0 <printf>
    4994:	003fff06 	br	4994 <dhcp_option_trailer+0xa4>
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
    4998:	e0bfff17 	ldw	r2,-4(fp)
    499c:	11000617 	ldw	r4,24(r2)
    49a0:	e0bfff17 	ldw	r2,-4(fp)
    49a4:	1080070b 	ldhu	r2,28(r2)
    49a8:	10ffffcc 	andi	r3,r2,65535
    49ac:	20c7883a 	add	r3,r4,r3
    49b0:	18c03c04 	addi	r3,r3,240
    49b4:	013fffc4 	movi	r4,-1
    49b8:	19000005 	stb	r4,0(r3)
    49bc:	10800044 	addi	r2,r2,1
    49c0:	1007883a 	mov	r3,r2
    49c4:	e0bfff17 	ldw	r2,-4(fp)
    49c8:	10c0070d 	sth	r3,28(r2)
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
    49cc:	00001a06 	br	4a38 <dhcp_option_trailer+0x148>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
    49d0:	e0bfff17 	ldw	r2,-4(fp)
    49d4:	1080070b 	ldhu	r2,28(r2)
    49d8:	10bfffcc 	andi	r2,r2,65535
    49dc:	10801130 	cmpltui	r2,r2,68
    49e0:	1000091e 	bne	r2,zero,4a08 <dhcp_option_trailer+0x118>
    49e4:	010000f4 	movhi	r4,3
    49e8:	21352e04 	addi	r4,r4,-11080
    49ec:	014000f4 	movhi	r5,3
    49f0:	29763004 	addi	r5,r5,-10048
    49f4:	01818c04 	movi	r6,1584
    49f8:	01c000f4 	movhi	r7,3
    49fc:	39f53c04 	addi	r7,r7,-11024
    4a00:	00166c00 	call	166c0 <printf>
    4a04:	003fff06 	br	4a04 <dhcp_option_trailer+0x114>
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
    4a08:	e0bfff17 	ldw	r2,-4(fp)
    4a0c:	11000617 	ldw	r4,24(r2)
    4a10:	e0bfff17 	ldw	r2,-4(fp)
    4a14:	1080070b 	ldhu	r2,28(r2)
    4a18:	10ffffcc 	andi	r3,r2,65535
    4a1c:	20c7883a 	add	r3,r4,r3
    4a20:	18c03c04 	addi	r3,r3,240
    4a24:	18000005 	stb	zero,0(r3)
    4a28:	10800044 	addi	r2,r2,1
    4a2c:	1007883a 	mov	r3,r2
    4a30:	e0bfff17 	ldw	r2,-4(fp)
    4a34:	10c0070d 	sth	r3,28(r2)
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
    4a38:	e0bfff17 	ldw	r2,-4(fp)
    4a3c:	1080070b 	ldhu	r2,28(r2)
    4a40:	10bfffcc 	andi	r2,r2,65535
    4a44:	10801130 	cmpltui	r2,r2,68
    4a48:	103fe11e 	bne	r2,zero,49d0 <dhcp_option_trailer+0xe0>
    4a4c:	e0bfff17 	ldw	r2,-4(fp)
    4a50:	1080070b 	ldhu	r2,28(r2)
    4a54:	10bfffcc 	andi	r2,r2,65535
    4a58:	108000cc 	andi	r2,r2,3
    4a5c:	103fdc1e 	bne	r2,zero,49d0 <dhcp_option_trailer+0xe0>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  }
}
    4a60:	e037883a 	mov	sp,fp
    4a64:	dfc00117 	ldw	ra,4(sp)
    4a68:	df000017 	ldw	fp,0(sp)
    4a6c:	dec00204 	addi	sp,sp,8
    4a70:	f800283a 	ret

00004a74 <dhcp_get_option_ptr>:
 *
 * @return a byte offset into the UDP message where the option was found, or
 * zero if the given option was not found.
 */
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
    4a74:	defffa04 	addi	sp,sp,-24
    4a78:	df000515 	stw	fp,20(sp)
    4a7c:	df000504 	addi	fp,sp,20
    4a80:	e13ffe15 	stw	r4,-8(fp)
    4a84:	2805883a 	mov	r2,r5
    4a88:	e0bfff05 	stb	r2,-4(fp)
  u8_t overload = DHCP_OVERLOAD_NONE;
    4a8c:	e03ffb05 	stb	zero,-20(fp)

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
    4a90:	e0bffe17 	ldw	r2,-8(fp)
    4a94:	10800317 	ldw	r2,12(r2)
    4a98:	10007e26 	beq	r2,zero,4c94 <dhcp_get_option_ptr+0x220>
    4a9c:	e0bffe17 	ldw	r2,-8(fp)
    4aa0:	1080040b 	ldhu	r2,16(r2)
    4aa4:	10bfffcc 	andi	r2,r2,65535
    4aa8:	10007a26 	beq	r2,zero,4c94 <dhcp_get_option_ptr+0x220>
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    4aac:	e0bffe17 	ldw	r2,-8(fp)
    4ab0:	10800317 	ldw	r2,12(r2)
    4ab4:	e0bffc15 	stw	r2,-16(fp)
    u16_t offset = 0;
    4ab8:	e03ffd0d 	sth	zero,-12(fp)
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
    4abc:	00002a06 	br	4b68 <dhcp_get_option_ptr+0xf4>
      /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
      /* are the sname and/or file field overloaded with options? */
      if (options[offset] == DHCP_OPTION_OVERLOAD) {
    4ac0:	e0bffd0b 	ldhu	r2,-12(fp)
    4ac4:	e0fffc17 	ldw	r3,-16(fp)
    4ac8:	1885883a 	add	r2,r3,r2
    4acc:	10800003 	ldbu	r2,0(r2)
    4ad0:	10803fcc 	andi	r2,r2,255
    4ad4:	10800d18 	cmpnei	r2,r2,52
    4ad8:	10000c1e 	bne	r2,zero,4b0c <dhcp_get_option_ptr+0x98>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded message detected\n"));
        /* skip option type and length */
        offset += 2;
    4adc:	e0bffd0b 	ldhu	r2,-12(fp)
    4ae0:	10800084 	addi	r2,r2,2
    4ae4:	e0bffd0d 	sth	r2,-12(fp)
        overload = options[offset++];
    4ae8:	e0bffd0b 	ldhu	r2,-12(fp)
    4aec:	e0fffc17 	ldw	r3,-16(fp)
    4af0:	1885883a 	add	r2,r3,r2
    4af4:	10800003 	ldbu	r2,0(r2)
    4af8:	e0bffb05 	stb	r2,-20(fp)
    4afc:	e0bffd0b 	ldhu	r2,-12(fp)
    4b00:	10800044 	addi	r2,r2,1
    4b04:	e0bffd0d 	sth	r2,-12(fp)
    4b08:	00001706 	br	4b68 <dhcp_get_option_ptr+0xf4>
      }
      /* requested option found */
      else if (options[offset] == option_type) {
    4b0c:	e0bffd0b 	ldhu	r2,-12(fp)
    4b10:	e0fffc17 	ldw	r3,-16(fp)
    4b14:	1885883a 	add	r2,r3,r2
    4b18:	10800003 	ldbu	r2,0(r2)
    4b1c:	10c03fcc 	andi	r3,r2,255
    4b20:	e0bfff03 	ldbu	r2,-4(fp)
    4b24:	1880041e 	bne	r3,r2,4b38 <dhcp_get_option_ptr+0xc4>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("option found at offset %"U16_F" in options\n", offset));
        return &options[offset];
    4b28:	e0bffd0b 	ldhu	r2,-12(fp)
    4b2c:	e0fffc17 	ldw	r3,-16(fp)
    4b30:	1885883a 	add	r2,r3,r2
    4b34:	00005806 	br	4c98 <dhcp_get_option_ptr+0x224>
      /* skip option */
      } else {
         LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", options[offset]));
        /* skip option type */
        offset++;
    4b38:	e0bffd0b 	ldhu	r2,-12(fp)
    4b3c:	10800044 	addi	r2,r2,1
    4b40:	e0bffd0d 	sth	r2,-12(fp)
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
    4b44:	e0bffd0b 	ldhu	r2,-12(fp)
    4b48:	e0fffc17 	ldw	r3,-16(fp)
    4b4c:	1885883a 	add	r2,r3,r2
    4b50:	10800003 	ldbu	r2,0(r2)
    4b54:	10c03fcc 	andi	r3,r2,255
    4b58:	e0bffd0b 	ldhu	r2,-12(fp)
    4b5c:	1885883a 	add	r2,r3,r2
    4b60:	10800044 	addi	r2,r2,1
    4b64:	e0bffd0d 	sth	r2,-12(fp)
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
    4b68:	e0bffe17 	ldw	r2,-8(fp)
    4b6c:	1080040b 	ldhu	r2,16(r2)
    4b70:	10bfffcc 	andi	r2,r2,65535
    4b74:	e0fffd0b 	ldhu	r3,-12(fp)
    4b78:	1880072e 	bgeu	r3,r2,4b98 <dhcp_get_option_ptr+0x124>
    4b7c:	e0bffd0b 	ldhu	r2,-12(fp)
    4b80:	e0fffc17 	ldw	r3,-16(fp)
    4b84:	1885883a 	add	r2,r3,r2
    4b88:	10800003 	ldbu	r2,0(r2)
    4b8c:	10803fcc 	andi	r2,r2,255
    4b90:	10803fd8 	cmpnei	r2,r2,255
    4b94:	103fca1e 	bne	r2,zero,4ac0 <dhcp_get_option_ptr+0x4c>
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
      }
    }
    /* is this an overloaded message? */
    if (overload != DHCP_OVERLOAD_NONE) {
    4b98:	e0bffb03 	ldbu	r2,-20(fp)
    4b9c:	10003d26 	beq	r2,zero,4c94 <dhcp_get_option_ptr+0x220>
      u16_t field_len;
      if (overload == DHCP_OVERLOAD_FILE) {
    4ba0:	e0bffb03 	ldbu	r2,-20(fp)
    4ba4:	10800058 	cmpnei	r2,r2,1
    4ba8:	1000071e 	bne	r2,zero,4bc8 <dhcp_get_option_ptr+0x154>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded file field\n"));
        options = (u8_t *)&dhcp->msg_in->file;
    4bac:	e0bffe17 	ldw	r2,-8(fp)
    4bb0:	10800217 	ldw	r2,8(r2)
    4bb4:	10801b04 	addi	r2,r2,108
    4bb8:	e0bffc15 	stw	r2,-16(fp)
        field_len = DHCP_FILE_LEN;
    4bbc:	00802004 	movi	r2,128
    4bc0:	e0bffd8d 	sth	r2,-10(fp)
    4bc4:	00001006 	br	4c08 <dhcp_get_option_ptr+0x194>
      } else if (overload == DHCP_OVERLOAD_SNAME) {
    4bc8:	e0bffb03 	ldbu	r2,-20(fp)
    4bcc:	10800098 	cmpnei	r2,r2,2
    4bd0:	1000071e 	bne	r2,zero,4bf0 <dhcp_get_option_ptr+0x17c>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded sname field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
    4bd4:	e0bffe17 	ldw	r2,-8(fp)
    4bd8:	10800217 	ldw	r2,8(r2)
    4bdc:	10800b04 	addi	r2,r2,44
    4be0:	e0bffc15 	stw	r2,-16(fp)
        field_len = DHCP_SNAME_LEN;
    4be4:	00801004 	movi	r2,64
    4be8:	e0bffd8d 	sth	r2,-10(fp)
    4bec:	00000606 	br	4c08 <dhcp_get_option_ptr+0x194>
      /* TODO: check if else if () is necessary */
      } else {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded sname and file field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
    4bf0:	e0bffe17 	ldw	r2,-8(fp)
    4bf4:	10800217 	ldw	r2,8(r2)
    4bf8:	10800b04 	addi	r2,r2,44
    4bfc:	e0bffc15 	stw	r2,-16(fp)
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
    4c00:	00803004 	movi	r2,192
    4c04:	e0bffd8d 	sth	r2,-10(fp)
      }
      offset = 0;
    4c08:	e03ffd0d 	sth	zero,-12(fp)

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
    4c0c:	00001706 	br	4c6c <dhcp_get_option_ptr+0x1f8>
        if (options[offset] == option_type) {
    4c10:	e0bffd0b 	ldhu	r2,-12(fp)
    4c14:	e0fffc17 	ldw	r3,-16(fp)
    4c18:	1885883a 	add	r2,r3,r2
    4c1c:	10800003 	ldbu	r2,0(r2)
    4c20:	10c03fcc 	andi	r3,r2,255
    4c24:	e0bfff03 	ldbu	r2,-4(fp)
    4c28:	1880041e 	bne	r3,r2,4c3c <dhcp_get_option_ptr+0x1c8>
           LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("option found at offset=%"U16_F"\n", offset));
          return &options[offset];
    4c2c:	e0bffd0b 	ldhu	r2,-12(fp)
    4c30:	e0fffc17 	ldw	r3,-16(fp)
    4c34:	1885883a 	add	r2,r3,r2
    4c38:	00001706 	br	4c98 <dhcp_get_option_ptr+0x224>
        /* skip option */
        } else {
          LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("skipping option %"U16_F"\n", options[offset]));
          /* skip option type */
          offset++;
    4c3c:	e0bffd0b 	ldhu	r2,-12(fp)
    4c40:	10800044 	addi	r2,r2,1
    4c44:	e0bffd0d 	sth	r2,-12(fp)
          offset += 1 + options[offset];
    4c48:	e0bffd0b 	ldhu	r2,-12(fp)
    4c4c:	e0fffc17 	ldw	r3,-16(fp)
    4c50:	1885883a 	add	r2,r3,r2
    4c54:	10800003 	ldbu	r2,0(r2)
    4c58:	10c03fcc 	andi	r3,r2,255
    4c5c:	e0bffd0b 	ldhu	r2,-12(fp)
    4c60:	1885883a 	add	r2,r3,r2
    4c64:	10800044 	addi	r2,r2,1
    4c68:	e0bffd0d 	sth	r2,-12(fp)
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
      }
      offset = 0;

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
    4c6c:	e0fffd0b 	ldhu	r3,-12(fp)
    4c70:	e0bffd8b 	ldhu	r2,-10(fp)
    4c74:	1880072e 	bgeu	r3,r2,4c94 <dhcp_get_option_ptr+0x220>
    4c78:	e0bffd0b 	ldhu	r2,-12(fp)
    4c7c:	e0fffc17 	ldw	r3,-16(fp)
    4c80:	1885883a 	add	r2,r3,r2
    4c84:	10800003 	ldbu	r2,0(r2)
    4c88:	10803fcc 	andi	r2,r2,255
    4c8c:	10803fd8 	cmpnei	r2,r2,255
    4c90:	103fdf1e 	bne	r2,zero,4c10 <dhcp_get_option_ptr+0x19c>
          offset += 1 + options[offset];
        }
      }
    }
  }
  return NULL;
    4c94:	0005883a 	mov	r2,zero
}
    4c98:	e037883a 	mov	sp,fp
    4c9c:	df000017 	ldw	fp,0(sp)
    4ca0:	dec00104 	addi	sp,sp,4
    4ca4:	f800283a 	ret

00004ca8 <dhcp_get_option_byte>:
 *
 * @return byte value at the given address.
 */
static u8_t
dhcp_get_option_byte(u8_t *ptr)
{
    4ca8:	defffe04 	addi	sp,sp,-8
    4cac:	df000115 	stw	fp,4(sp)
    4cb0:	df000104 	addi	fp,sp,4
    4cb4:	e13fff15 	stw	r4,-4(fp)
  LWIP_DEBUGF(DHCP_DEBUG, ("option byte value=%"U16_F"\n", (u16_t)(*ptr)));
  return *ptr;
    4cb8:	e0bfff17 	ldw	r2,-4(fp)
    4cbc:	10800003 	ldbu	r2,0(r2)
}
    4cc0:	e037883a 	mov	sp,fp
    4cc4:	df000017 	ldw	fp,0(sp)
    4cc8:	dec00104 	addi	sp,sp,4
    4ccc:	f800283a 	ret

00004cd0 <dhcp_get_option_long>:
 * @param ptr pointer obtained by dhcp_get_option_ptr().
 *
 * @return byte value at the given address.
 */
static u32_t dhcp_get_option_long(u8_t *ptr)
{
    4cd0:	defffd04 	addi	sp,sp,-12
    4cd4:	df000215 	stw	fp,8(sp)
    4cd8:	df000204 	addi	fp,sp,8
    4cdc:	e13fff15 	stw	r4,-4(fp)
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
    4ce0:	e0bfff17 	ldw	r2,-4(fp)
    4ce4:	10800003 	ldbu	r2,0(r2)
    4ce8:	10803fcc 	andi	r2,r2,255
    4cec:	1004963a 	slli	r2,r2,24
    4cf0:	e0bffe15 	stw	r2,-8(fp)
    4cf4:	e0bfff17 	ldw	r2,-4(fp)
    4cf8:	10800044 	addi	r2,r2,1
    4cfc:	e0bfff15 	stw	r2,-4(fp)
  value |= (u32_t)(*ptr++) << 16;
    4d00:	e0bfff17 	ldw	r2,-4(fp)
    4d04:	10800003 	ldbu	r2,0(r2)
    4d08:	10803fcc 	andi	r2,r2,255
    4d0c:	1004943a 	slli	r2,r2,16
    4d10:	e0fffe17 	ldw	r3,-8(fp)
    4d14:	1884b03a 	or	r2,r3,r2
    4d18:	e0bffe15 	stw	r2,-8(fp)
    4d1c:	e0bfff17 	ldw	r2,-4(fp)
    4d20:	10800044 	addi	r2,r2,1
    4d24:	e0bfff15 	stw	r2,-4(fp)
  value |= (u32_t)(*ptr++) << 8;
    4d28:	e0bfff17 	ldw	r2,-4(fp)
    4d2c:	10800003 	ldbu	r2,0(r2)
    4d30:	10803fcc 	andi	r2,r2,255
    4d34:	1004923a 	slli	r2,r2,8
    4d38:	e0fffe17 	ldw	r3,-8(fp)
    4d3c:	1884b03a 	or	r2,r3,r2
    4d40:	e0bffe15 	stw	r2,-8(fp)
    4d44:	e0bfff17 	ldw	r2,-4(fp)
    4d48:	10800044 	addi	r2,r2,1
    4d4c:	e0bfff15 	stw	r2,-4(fp)
  value |= (u32_t)(*ptr++);
    4d50:	e0bfff17 	ldw	r2,-4(fp)
    4d54:	10800003 	ldbu	r2,0(r2)
    4d58:	10803fcc 	andi	r2,r2,255
    4d5c:	e0fffe17 	ldw	r3,-8(fp)
    4d60:	1884b03a 	or	r2,r3,r2
    4d64:	e0bffe15 	stw	r2,-8(fp)
    4d68:	e0bfff17 	ldw	r2,-4(fp)
    4d6c:	10800044 	addi	r2,r2,1
    4d70:	e0bfff15 	stw	r2,-4(fp)
  LWIP_DEBUGF(DHCP_DEBUG, ("option long value=%"U32_F"\n", value));
  return value;
    4d74:	e0bffe17 	ldw	r2,-8(fp)
}
    4d78:	e037883a 	mov	sp,fp
    4d7c:	df000017 	ldw	fp,0(sp)
    4d80:	dec00104 	addi	sp,sp,4
    4d84:	f800283a 	ret

00004d88 <lwip_sanity_check>:
#endif

#ifdef LWIP_DEBUG
static void
lwip_sanity_check(void)
{
    4d88:	deffff04 	addi	sp,sp,-4
    4d8c:	df000015 	stw	fp,0(sp)
    4d90:	d839883a 	mov	fp,sp
  if (TCP_WND > (PBUF_POOL_SIZE*PBUF_POOL_BUFSIZE))
    LWIP_PLATFORM_DIAG(("lwip_sanity_check: WARNING: TCP_WND is larger than space provided by PBUF_POOL_SIZE*PBUF_POOL_BUFSIZE\n"));
  if (TCP_WND < TCP_MSS)
    LWIP_PLATFORM_DIAG(("lwip_sanity_check: WARNING: TCP_WND is smaller than MSS\n"));
#endif /* LWIP_TCP */
}
    4d94:	e037883a 	mov	sp,fp
    4d98:	df000017 	ldw	fp,0(sp)
    4d9c:	dec00104 	addi	sp,sp,4
    4da0:	f800283a 	ret

00004da4 <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
    4da4:	defffe04 	addi	sp,sp,-8
    4da8:	dfc00115 	stw	ra,4(sp)
    4dac:	df000015 	stw	fp,0(sp)
    4db0:	d839883a 	mov	fp,sp
  /* Sanity check user-configurable values */
  lwip_sanity_check();
    4db4:	0004d880 	call	4d88 <lwip_sanity_check>

  /* Modules initialization */
  stats_init();
  sys_init();
  mem_init();
    4db8:	00083840 	call	8384 <mem_init>
  memp_init();
    4dbc:	0008d340 	call	8d34 <memp_init>
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */
}
    4dc0:	e037883a 	mov	sp,fp
    4dc4:	dfc00117 	ldw	ra,4(sp)
    4dc8:	df000017 	ldw	fp,0(sp)
    4dcc:	dec00204 	addi	sp,sp,8
    4dd0:	f800283a 	ret

00004dd4 <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
    4dd4:	defff204 	addi	sp,sp,-56
    4dd8:	dfc00d15 	stw	ra,52(sp)
    4ddc:	df000c15 	stw	fp,48(sp)
    4de0:	df000c04 	addi	fp,sp,48
    4de4:	e13ffe15 	stw	r4,-8(fp)
    4de8:	e17fff15 	stw	r5,-4(fp)
  struct icmp_echo_hdr *iecho;
  struct ip_hdr *iphdr;
  struct ip_addr tmpaddr;
  s16_t hlen;

  ICMP_STATS_INC(icmp.recv);
    4dec:	00800134 	movhi	r2,4
    4df0:	108d9504 	addi	r2,r2,13908
    4df4:	1080188b 	ldhu	r2,98(r2)
    4df8:	10800044 	addi	r2,r2,1
    4dfc:	1007883a 	mov	r3,r2
    4e00:	00800134 	movhi	r2,4
    4e04:	108d9504 	addi	r2,r2,13908
    4e08:	10c0188d 	sth	r3,98(r2)
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
    4e0c:	e0bffe17 	ldw	r2,-8(fp)
    4e10:	10800117 	ldw	r2,4(r2)
    4e14:	e0bff715 	stw	r2,-36(fp)
  hlen = IPH_HL(iphdr) * 4;
    4e18:	e0bff717 	ldw	r2,-36(fp)
    4e1c:	1080000b 	ldhu	r2,0(r2)
    4e20:	10bfffcc 	andi	r2,r2,65535
    4e24:	1004d23a 	srli	r2,r2,8
    4e28:	10ffffcc 	andi	r3,r2,65535
    4e2c:	e0bff717 	ldw	r2,-36(fp)
    4e30:	1080000b 	ldhu	r2,0(r2)
    4e34:	10bfffcc 	andi	r2,r2,65535
    4e38:	1004923a 	slli	r2,r2,8
    4e3c:	10bfffcc 	andi	r2,r2,65535
    4e40:	1884b03a 	or	r2,r3,r2
    4e44:	1005d23a 	srai	r2,r2,8
    4e48:	108003cc 	andi	r2,r2,15
    4e4c:	1085883a 	add	r2,r2,r2
    4e50:	1085883a 	add	r2,r2,r2
    4e54:	e0bff90d 	sth	r2,-28(fp)
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
    4e58:	e0bff90b 	ldhu	r2,-28(fp)
    4e5c:	0085c83a 	sub	r2,zero,r2
    4e60:	10bfffcc 	andi	r2,r2,65535
    4e64:	10a0001c 	xori	r2,r2,32768
    4e68:	10a00004 	addi	r2,r2,-32768
    4e6c:	e13ffe17 	ldw	r4,-8(fp)
    4e70:	100b883a 	mov	r5,r2
    4e74:	0009f740 	call	9f74 <pbuf_header>
    4e78:	10803fcc 	andi	r2,r2,255
    4e7c:	1000051e 	bne	r2,zero,4e94 <icmp_input+0xc0>
    4e80:	e0bffe17 	ldw	r2,-8(fp)
    4e84:	1080020b 	ldhu	r2,8(r2)
    4e88:	10bfffcc 	andi	r2,r2,65535
    4e8c:	10800128 	cmpgeui	r2,r2,4
    4e90:	1000061e 	bne	r2,zero,4eac <icmp_input+0xd8>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    4e94:	e0bffe17 	ldw	r2,-8(fp)
    4e98:	1080020b 	ldhu	r2,8(r2)
    4e9c:	10bfffcc 	andi	r2,r2,65535
    4ea0:	1009883a 	mov	r4,r2
    4ea4:	00166c00 	call	166c0 <printf>
    goto lenerr;
    4ea8:	00016106 	br	5430 <icmp_input+0x65c>
  }

  type = *((u8_t *)p->payload);
    4eac:	e0bffe17 	ldw	r2,-8(fp)
    4eb0:	10800117 	ldw	r2,4(r2)
    4eb4:	10800003 	ldbu	r2,0(r2)
    4eb8:	e0bff985 	stb	r2,-26(fp)
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
    4ebc:	e0bffe17 	ldw	r2,-8(fp)
    4ec0:	10800117 	ldw	r2,4(r2)
    4ec4:	10800043 	ldbu	r2,1(r2)
    4ec8:	e0bff9c5 	stb	r2,-25(fp)
#endif /* LWIP_DEBUG */
  switch (type) {
    4ecc:	e0bff983 	ldbu	r2,-26(fp)
    4ed0:	10800220 	cmpeqi	r2,r2,8
    4ed4:	10013e26 	beq	r2,zero,53d0 <icmp_input+0x5fc>
  case ICMP_ECHO:
#if !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING
    {
      int accepted = 1;
    4ed8:	00800044 	movi	r2,1
    4edc:	e0bff815 	stw	r2,-32(fp)
#if !LWIP_MULTICAST_PING
      /* multicast destination address? */
      if (ip_addr_ismulticast(&iphdr->dest)) {
    4ee0:	e0bff717 	ldw	r2,-36(fp)
    4ee4:	10c0040b 	ldhu	r3,16(r2)
    4ee8:	1080048b 	ldhu	r2,18(r2)
    4eec:	1004943a 	slli	r2,r2,16
    4ef0:	10c4b03a 	or	r2,r2,r3
    4ef4:	10803c0c 	andi	r2,r2,240
    4ef8:	10803818 	cmpnei	r2,r2,224
    4efc:	1000011e 	bne	r2,zero,4f04 <icmp_input+0x130>
        accepted = 0;
    4f00:	e03ff815 	stw	zero,-32(fp)
      }
#endif /* LWIP_MULTICAST_PING */
#if !LWIP_BROADCAST_PING
      /* broadcast destination address? */
      if (ip_addr_isbroadcast(&iphdr->dest, inp)) {
    4f04:	e0bff717 	ldw	r2,-36(fp)
    4f08:	10800404 	addi	r2,r2,16
    4f0c:	1009883a 	mov	r4,r2
    4f10:	e17fff17 	ldw	r5,-4(fp)
    4f14:	0006db00 	call	6db0 <ip_addr_isbroadcast>
    4f18:	10803fcc 	andi	r2,r2,255
    4f1c:	10000126 	beq	r2,zero,4f24 <icmp_input+0x150>
        accepted = 0;
    4f20:	e03ff815 	stw	zero,-32(fp)
      }
#endif /* LWIP_BROADCAST_PING */
      /* broadcast or multicast destination address not acceptd? */
      if (!accepted) {
    4f24:	e0bff817 	ldw	r2,-32(fp)
    4f28:	10000e1e 	bne	r2,zero,4f64 <icmp_input+0x190>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
    4f2c:	010000f4 	movhi	r4,3
    4f30:	21364004 	addi	r4,r4,-9984
    4f34:	00169500 	call	16950 <puts>
        ICMP_STATS_INC(icmp.err);
    4f38:	00800134 	movhi	r2,4
    4f3c:	108d9504 	addi	r2,r2,13908
    4f40:	10801d0b 	ldhu	r2,116(r2)
    4f44:	10800044 	addi	r2,r2,1
    4f48:	1007883a 	mov	r3,r2
    4f4c:	00800134 	movhi	r2,4
    4f50:	108d9504 	addi	r2,r2,13908
    4f54:	10c01d0d 	sth	r3,116(r2)
        pbuf_free(p);
    4f58:	e13ffe17 	ldw	r4,-8(fp)
    4f5c:	000a16c0 	call	a16c <pbuf_free>
    4f60:	00013d06 	br	5458 <icmp_input+0x684>
        return;
      }
    }
#endif /* !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    4f64:	010000f4 	movhi	r4,3
    4f68:	21364e04 	addi	r4,r4,-9928
    4f6c:	00169500 	call	16950 <puts>
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
    4f70:	e0bffe17 	ldw	r2,-8(fp)
    4f74:	1080020b 	ldhu	r2,8(r2)
    4f78:	10bfffcc 	andi	r2,r2,65535
    4f7c:	10800228 	cmpgeui	r2,r2,8
    4f80:	1000041e 	bne	r2,zero,4f94 <icmp_input+0x1c0>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
    4f84:	010000f4 	movhi	r4,3
    4f88:	21365304 	addi	r4,r4,-9908
    4f8c:	00169500 	call	16950 <puts>
      goto lenerr;
    4f90:	00012706 	br	5430 <icmp_input+0x65c>
    }
    if (inet_chksum_pbuf(p) != 0) {
    4f94:	e13ffe17 	ldw	r4,-8(fp)
    4f98:	00060880 	call	6088 <inet_chksum_pbuf>
    4f9c:	10bfffcc 	andi	r2,r2,65535
    4fa0:	10000e26 	beq	r2,zero,4fdc <icmp_input+0x208>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
    4fa4:	010000f4 	movhi	r4,3
    4fa8:	21365c04 	addi	r4,r4,-9872
    4fac:	00169500 	call	16950 <puts>
      pbuf_free(p);
    4fb0:	e13ffe17 	ldw	r4,-8(fp)
    4fb4:	000a16c0 	call	a16c <pbuf_free>
      ICMP_STATS_INC(icmp.chkerr);
    4fb8:	00800134 	movhi	r2,4
    4fbc:	108d9504 	addi	r2,r2,13908
    4fc0:	10801a0b 	ldhu	r2,104(r2)
    4fc4:	10800044 	addi	r2,r2,1
    4fc8:	1007883a 	mov	r3,r2
    4fcc:	00800134 	movhi	r2,4
    4fd0:	108d9504 	addi	r2,r2,13908
    4fd4:	10c01a0d 	sth	r3,104(r2)
    4fd8:	00011f06 	br	5458 <icmp_input+0x684>
      snmp_inc_icmpinerrors();
      return;
    }
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
    4fdc:	e13ffe17 	ldw	r4,-8(fp)
    4fe0:	01400884 	movi	r5,34
    4fe4:	0009f740 	call	9f74 <pbuf_header>
    4fe8:	10803fcc 	andi	r2,r2,255
    4fec:	10006226 	beq	r2,zero,5178 <icmp_input+0x3a4>
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
    4ff0:	e0bff90f 	ldh	r2,-28(fp)
    4ff4:	e13ffe17 	ldw	r4,-8(fp)
    4ff8:	100b883a 	mov	r5,r2
    4ffc:	0009f740 	call	9f74 <pbuf_header>
    5000:	10803fcc 	andi	r2,r2,255
    5004:	10000926 	beq	r2,zero,502c <icmp_input+0x258>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
    5008:	010000f4 	movhi	r4,3
    500c:	21366904 	addi	r4,r4,-9820
    5010:	014000f4 	movhi	r5,3
    5014:	29767304 	addi	r5,r5,-9780
    5018:	01802584 	movi	r6,150
    501c:	01c000f4 	movhi	r7,3
    5020:	39f68004 	addi	r7,r7,-9728
    5024:	00166c00 	call	166c0 <printf>
    5028:	003fff06 	br	5028 <icmp_input+0x254>
        goto memerr;
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
    502c:	e0bffe17 	ldw	r2,-8(fp)
    5030:	1080020b 	ldhu	r2,8(r2)
    5034:	10bfffcc 	andi	r2,r2,65535
    5038:	01000084 	movi	r4,2
    503c:	100b883a 	mov	r5,r2
    5040:	000d883a 	mov	r6,zero
    5044:	00097b00 	call	97b0 <pbuf_alloc>
    5048:	e0bffa15 	stw	r2,-24(fp)
      if (r == NULL) {
    504c:	e0bffa17 	ldw	r2,-24(fp)
    5050:	10000f1e 	bne	r2,zero,5090 <icmp_input+0x2bc>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
    5054:	010000f4 	movhi	r4,3
    5058:	21368704 	addi	r4,r4,-9700
    505c:	00169500 	call	16950 <puts>
        goto memerr;
    5060:	0001883a 	nop
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
memerr:
  pbuf_free(p);
    5064:	e13ffe17 	ldw	r4,-8(fp)
    5068:	000a16c0 	call	a16c <pbuf_free>
  ICMP_STATS_INC(icmp.err);
    506c:	00800134 	movhi	r2,4
    5070:	108d9504 	addi	r2,r2,13908
    5074:	10801d0b 	ldhu	r2,116(r2)
    5078:	10800044 	addi	r2,r2,1
    507c:	1007883a 	mov	r3,r2
    5080:	00800134 	movhi	r2,4
    5084:	108d9504 	addi	r2,r2,13908
    5088:	10c01d0d 	sth	r3,116(r2)
    508c:	0000f206 	br	5458 <icmp_input+0x684>
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
      if (r == NULL) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
    5090:	e0bffa17 	ldw	r2,-24(fp)
    5094:	1080028b 	ldhu	r2,10(r2)
    5098:	10ffffcc 	andi	r3,r2,65535
    509c:	e0bff90f 	ldh	r2,-28(fp)
    50a0:	10800204 	addi	r2,r2,8
    50a4:	1880092e 	bgeu	r3,r2,50cc <icmp_input+0x2f8>
    50a8:	010000f4 	movhi	r4,3
    50ac:	21366904 	addi	r4,r4,-9820
    50b0:	014000f4 	movhi	r5,3
    50b4:	29769104 	addi	r5,r5,-9660
    50b8:	01802804 	movi	r6,160
    50bc:	01c000f4 	movhi	r7,3
    50c0:	39f68004 	addi	r7,r7,-9728
    50c4:	00166c00 	call	166c0 <printf>
    50c8:	003fff06 	br	50c8 <icmp_input+0x2f4>
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
    50cc:	e13ffa17 	ldw	r4,-24(fp)
    50d0:	e17ffe17 	ldw	r5,-8(fp)
    50d4:	000a6700 	call	a670 <pbuf_copy>
    50d8:	10803fcc 	andi	r2,r2,255
    50dc:	1080201c 	xori	r2,r2,128
    50e0:	10bfe004 	addi	r2,r2,-128
    50e4:	10000926 	beq	r2,zero,510c <icmp_input+0x338>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
    50e8:	010000f4 	movhi	r4,3
    50ec:	21366904 	addi	r4,r4,-9820
    50f0:	014000f4 	movhi	r5,3
    50f4:	29769f04 	addi	r5,r5,-9604
    50f8:	018028c4 	movi	r6,163
    50fc:	01c000f4 	movhi	r7,3
    5100:	39f68004 	addi	r7,r7,-9728
    5104:	00166c00 	call	166c0 <printf>
    5108:	003fff06 	br	5108 <icmp_input+0x334>
        goto memerr;
      }
      iphdr = r->payload;
    510c:	e0bffa17 	ldw	r2,-24(fp)
    5110:	10800117 	ldw	r2,4(r2)
    5114:	e0bff715 	stw	r2,-36(fp)
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
    5118:	e0bff90b 	ldhu	r2,-28(fp)
    511c:	0085c83a 	sub	r2,zero,r2
    5120:	10bfffcc 	andi	r2,r2,65535
    5124:	10a0001c 	xori	r2,r2,32768
    5128:	10a00004 	addi	r2,r2,-32768
    512c:	e13ffa17 	ldw	r4,-24(fp)
    5130:	100b883a 	mov	r5,r2
    5134:	0009f740 	call	9f74 <pbuf_header>
    5138:	10803fcc 	andi	r2,r2,255
    513c:	10000926 	beq	r2,zero,5164 <icmp_input+0x390>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
    5140:	010000f4 	movhi	r4,3
    5144:	21366904 	addi	r4,r4,-9820
    5148:	014000f4 	movhi	r5,3
    514c:	2976a904 	addi	r5,r5,-9564
    5150:	01802a44 	movi	r6,169
    5154:	01c000f4 	movhi	r7,3
    5158:	39f68004 	addi	r7,r7,-9728
    515c:	00166c00 	call	166c0 <printf>
    5160:	003fff06 	br	5160 <icmp_input+0x38c>
        goto memerr;
      }
      /* free the original p */
      pbuf_free(p);
    5164:	e13ffe17 	ldw	r4,-8(fp)
    5168:	000a16c0 	call	a16c <pbuf_free>
      /* we now have an identical copy of p that has room for link headers */
      p = r;
    516c:	e0bffa17 	ldw	r2,-24(fp)
    5170:	e0bffe15 	stw	r2,-8(fp)
    5174:	00000e06 	br	51b0 <icmp_input+0x3dc>
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
    5178:	e13ffe17 	ldw	r4,-8(fp)
    517c:	017ff784 	movi	r5,-34
    5180:	0009f740 	call	9f74 <pbuf_header>
    5184:	10803fcc 	andi	r2,r2,255
    5188:	10000926 	beq	r2,zero,51b0 <icmp_input+0x3dc>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
    518c:	010000f4 	movhi	r4,3
    5190:	21366904 	addi	r4,r4,-9820
    5194:	014000f4 	movhi	r5,3
    5198:	2976a904 	addi	r5,r5,-9564
    519c:	01802cc4 	movi	r6,179
    51a0:	01c000f4 	movhi	r7,3
    51a4:	39f68004 	addi	r7,r7,-9728
    51a8:	00166c00 	call	166c0 <printf>
    51ac:	003fff06 	br	51ac <icmp_input+0x3d8>
    }
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = p->payload;
    51b0:	e0bffe17 	ldw	r2,-8(fp)
    51b4:	10800117 	ldw	r2,4(r2)
    51b8:	e0bffb15 	stw	r2,-20(fp)
    tmpaddr.addr = iphdr->src.addr;
    51bc:	e0bff717 	ldw	r2,-36(fp)
    51c0:	10c0030b 	ldhu	r3,12(r2)
    51c4:	1080038b 	ldhu	r2,14(r2)
    51c8:	1004943a 	slli	r2,r2,16
    51cc:	10c4b03a 	or	r2,r2,r3
    51d0:	10ffffcc 	andi	r3,r2,65535
    51d4:	e13ffc8b 	ldhu	r4,-14(fp)
    51d8:	2008703a 	and	r4,r4,zero
    51dc:	20c6b03a 	or	r3,r4,r3
    51e0:	e0fffc8d 	sth	r3,-14(fp)
    51e4:	1004d43a 	srli	r2,r2,16
    51e8:	e0fffd0b 	ldhu	r3,-12(fp)
    51ec:	1806703a 	and	r3,r3,zero
    51f0:	1884b03a 	or	r2,r3,r2
    51f4:	e0bffd0d 	sth	r2,-12(fp)
    iphdr->src.addr = iphdr->dest.addr;
    51f8:	e0bff717 	ldw	r2,-36(fp)
    51fc:	10c0040b 	ldhu	r3,16(r2)
    5200:	1080048b 	ldhu	r2,18(r2)
    5204:	1004943a 	slli	r2,r2,16
    5208:	10c4b03a 	or	r2,r2,r3
    520c:	1007883a 	mov	r3,r2
    5210:	e0bff717 	ldw	r2,-36(fp)
    5214:	193fffcc 	andi	r4,r3,65535
    5218:	1140030b 	ldhu	r5,12(r2)
    521c:	280a703a 	and	r5,r5,zero
    5220:	2908b03a 	or	r4,r5,r4
    5224:	1100030d 	sth	r4,12(r2)
    5228:	1806d43a 	srli	r3,r3,16
    522c:	1100038b 	ldhu	r4,14(r2)
    5230:	2008703a 	and	r4,r4,zero
    5234:	20c6b03a 	or	r3,r4,r3
    5238:	10c0038d 	sth	r3,14(r2)
    iphdr->dest.addr = tmpaddr.addr;
    523c:	e0bffc8b 	ldhu	r2,-14(fp)
    5240:	e0fffd0b 	ldhu	r3,-12(fp)
    5244:	1806943a 	slli	r3,r3,16
    5248:	1884b03a 	or	r2,r3,r2
    524c:	1007883a 	mov	r3,r2
    5250:	e0bff717 	ldw	r2,-36(fp)
    5254:	193fffcc 	andi	r4,r3,65535
    5258:	1140040b 	ldhu	r5,16(r2)
    525c:	280a703a 	and	r5,r5,zero
    5260:	2908b03a 	or	r4,r5,r4
    5264:	1100040d 	sth	r4,16(r2)
    5268:	1806d43a 	srli	r3,r3,16
    526c:	1100048b 	ldhu	r4,18(r2)
    5270:	2008703a 	and	r4,r4,zero
    5274:	20c6b03a 	or	r3,r4,r3
    5278:	10c0048d 	sth	r3,18(r2)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
    527c:	e0bffb17 	ldw	r2,-20(fp)
    5280:	10000005 	stb	zero,0(r2)
    /* adjust the checksum */
    if (iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {
    5284:	e0bffb17 	ldw	r2,-20(fp)
    5288:	1080008b 	ldhu	r2,2(r2)
    528c:	10bfffcc 	andi	r2,r2,65535
    5290:	10bffdf0 	cmpltui	r2,r2,65527
    5294:	1000071e 	bne	r2,zero,52b4 <icmp_input+0x4e0>
      iecho->chksum += htons(ICMP_ECHO << 8) + 1;
    5298:	e0bffb17 	ldw	r2,-20(fp)
    529c:	1080008b 	ldhu	r2,2(r2)
    52a0:	10800244 	addi	r2,r2,9
    52a4:	1007883a 	mov	r3,r2
    52a8:	e0bffb17 	ldw	r2,-20(fp)
    52ac:	10c0008d 	sth	r3,2(r2)
    52b0:	00000606 	br	52cc <icmp_input+0x4f8>
    } else {
      iecho->chksum += htons(ICMP_ECHO << 8);
    52b4:	e0bffb17 	ldw	r2,-20(fp)
    52b8:	1080008b 	ldhu	r2,2(r2)
    52bc:	10800204 	addi	r2,r2,8
    52c0:	1007883a 	mov	r3,r2
    52c4:	e0bffb17 	ldw	r2,-20(fp)
    52c8:	10c0008d 	sth	r3,2(r2)
    }

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
    52cc:	e0bff717 	ldw	r2,-36(fp)
    52d0:	1080020b 	ldhu	r2,8(r2)
    52d4:	10bfffcc 	andi	r2,r2,65535
    52d8:	1004d23a 	srli	r2,r2,8
    52dc:	10ffffcc 	andi	r3,r2,65535
    52e0:	e0bff717 	ldw	r2,-36(fp)
    52e4:	1080020b 	ldhu	r2,8(r2)
    52e8:	10bfffcc 	andi	r2,r2,65535
    52ec:	1004923a 	slli	r2,r2,8
    52f0:	10bfffcc 	andi	r2,r2,65535
    52f4:	1884b03a 	or	r2,r3,r2
    52f8:	1004923a 	slli	r2,r2,8
    52fc:	10803fd4 	ori	r2,r2,255
    5300:	1007883a 	mov	r3,r2
    5304:	e0bff717 	ldw	r2,-36(fp)
    5308:	10c0020d 	sth	r3,8(r2)
    IPH_CHKSUM_SET(iphdr, 0);
    530c:	e0bff717 	ldw	r2,-36(fp)
    5310:	1000028d 	sth	zero,10(r2)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
    5314:	e13ff717 	ldw	r4,-36(fp)
    5318:	01400504 	movi	r5,20
    531c:	00060440 	call	6044 <inet_chksum>
    5320:	e0fff717 	ldw	r3,-36(fp)
    5324:	1880028d 	sth	r2,10(r3)
#endif /* CHECKSUM_GEN_IP */

    ICMP_STATS_INC(icmp.xmit);
    5328:	00800134 	movhi	r2,4
    532c:	108d9504 	addi	r2,r2,13908
    5330:	1080180b 	ldhu	r2,96(r2)
    5334:	10800044 	addi	r2,r2,1
    5338:	1007883a 	mov	r3,r2
    533c:	00800134 	movhi	r2,4
    5340:	108d9504 	addi	r2,r2,13908
    5344:	10c0180d 	sth	r3,96(r2)
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
    5348:	e0bff90f 	ldh	r2,-28(fp)
    534c:	e13ffe17 	ldw	r4,-8(fp)
    5350:	100b883a 	mov	r5,r2
    5354:	0009f740 	call	9f74 <pbuf_header>
    5358:	10803fcc 	andi	r2,r2,255
    535c:	10000926 	beq	r2,zero,5384 <icmp_input+0x5b0>
      LWIP_ASSERT("Can't move over header in packet", 0);
    5360:	010000f4 	movhi	r4,3
    5364:	21366904 	addi	r4,r4,-9820
    5368:	014000f4 	movhi	r5,3
    536c:	2976b604 	addi	r5,r5,-9512
    5370:	01803544 	movi	r6,213
    5374:	01c000f4 	movhi	r7,3
    5378:	39f68004 	addi	r7,r7,-9728
    537c:	00166c00 	call	166c0 <printf>
    5380:	003fff06 	br	5380 <icmp_input+0x5ac>
    } else {
      err_t ret;
      ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,
    5384:	e0bff717 	ldw	r2,-36(fp)
    5388:	10800304 	addi	r2,r2,12
    538c:	d8000015 	stw	zero,0(sp)
    5390:	00c00044 	movi	r3,1
    5394:	d8c00115 	stw	r3,4(sp)
    5398:	e0ffff17 	ldw	r3,-4(fp)
    539c:	d8c00215 	stw	r3,8(sp)
    53a0:	e13ffe17 	ldw	r4,-8(fp)
    53a4:	100b883a 	mov	r5,r2
    53a8:	000d883a 	mov	r6,zero
    53ac:	01c03fc4 	movi	r7,255
    53b0:	00068600 	call	6860 <ip_output_if>
    53b4:	e0bffc05 	stb	r2,-16(fp)
                   ICMP_TTL, 0, IP_PROTO_ICMP, inp);
      if (ret != ERR_OK) {
    53b8:	e0bffc07 	ldb	r2,-16(fp)
    53bc:	10001826 	beq	r2,zero,5420 <icmp_input+0x64c>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %c.\n", ret));
    53c0:	e0bffc07 	ldb	r2,-16(fp)
    53c4:	1009883a 	mov	r4,r2
    53c8:	00166c00 	call	166c0 <printf>
      }
    }
    break;
    53cc:	00001406 	br	5420 <icmp_input+0x64c>
  default:
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
    53d0:	e0bff9c3 	ldbu	r2,-25(fp)
    53d4:	1009883a 	mov	r4,r2
    53d8:	00166c00 	call	166c0 <printf>
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    53dc:	00800134 	movhi	r2,4
    53e0:	108d9504 	addi	r2,r2,13908
    53e4:	10801c0b 	ldhu	r2,112(r2)
    53e8:	10800044 	addi	r2,r2,1
    53ec:	1007883a 	mov	r3,r2
    53f0:	00800134 	movhi	r2,4
    53f4:	108d9504 	addi	r2,r2,13908
    53f8:	10c01c0d 	sth	r3,112(r2)
    ICMP_STATS_INC(icmp.drop);
    53fc:	00800134 	movhi	r2,4
    5400:	108d9504 	addi	r2,r2,13908
    5404:	1080198b 	ldhu	r2,102(r2)
    5408:	10800044 	addi	r2,r2,1
    540c:	1007883a 	mov	r3,r2
    5410:	00800134 	movhi	r2,4
    5414:	108d9504 	addi	r2,r2,13908
    5418:	10c0198d 	sth	r3,102(r2)
    541c:	00000106 	br	5424 <icmp_input+0x650>
                   ICMP_TTL, 0, IP_PROTO_ICMP, inp);
      if (ret != ERR_OK) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %c.\n", ret));
      }
    }
    break;
    5420:	0001883a 	nop
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
    5424:	e13ffe17 	ldw	r4,-8(fp)
    5428:	000a16c0 	call	a16c <pbuf_free>
    542c:	00000a06 	br	5458 <icmp_input+0x684>
  return;
lenerr:
  pbuf_free(p);
    5430:	e13ffe17 	ldw	r4,-8(fp)
    5434:	000a16c0 	call	a16c <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
    5438:	00800134 	movhi	r2,4
    543c:	108d9504 	addi	r2,r2,13908
    5440:	10801a8b 	ldhu	r2,106(r2)
    5444:	10800044 	addi	r2,r2,1
    5448:	1007883a 	mov	r3,r2
    544c:	00800134 	movhi	r2,4
    5450:	108d9504 	addi	r2,r2,13908
    5454:	10c01a8d 	sth	r3,106(r2)
  pbuf_free(p);
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
}
    5458:	e037883a 	mov	sp,fp
    545c:	dfc00117 	ldw	ra,4(sp)
    5460:	df000017 	ldw	fp,0(sp)
    5464:	dec00204 	addi	sp,sp,8
    5468:	f800283a 	ret

0000546c <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
    546c:	defffc04 	addi	sp,sp,-16
    5470:	dfc00315 	stw	ra,12(sp)
    5474:	df000215 	stw	fp,8(sp)
    5478:	df000204 	addi	fp,sp,8
    547c:	e13ffe15 	stw	r4,-8(fp)
    5480:	e17fff15 	stw	r5,-4(fp)
  icmp_send_response(p, ICMP_DUR, t);
    5484:	e0bfff17 	ldw	r2,-4(fp)
    5488:	10803fcc 	andi	r2,r2,255
    548c:	e13ffe17 	ldw	r4,-8(fp)
    5490:	014000c4 	movi	r5,3
    5494:	100d883a 	mov	r6,r2
    5498:	00054f40 	call	54f4 <icmp_send_response>
}
    549c:	e037883a 	mov	sp,fp
    54a0:	dfc00117 	ldw	ra,4(sp)
    54a4:	df000017 	ldw	fp,0(sp)
    54a8:	dec00204 	addi	sp,sp,8
    54ac:	f800283a 	ret

000054b0 <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
    54b0:	defffc04 	addi	sp,sp,-16
    54b4:	dfc00315 	stw	ra,12(sp)
    54b8:	df000215 	stw	fp,8(sp)
    54bc:	df000204 	addi	fp,sp,8
    54c0:	e13ffe15 	stw	r4,-8(fp)
    54c4:	e17fff15 	stw	r5,-4(fp)
  icmp_send_response(p, ICMP_TE, t);
    54c8:	e0bfff17 	ldw	r2,-4(fp)
    54cc:	10803fcc 	andi	r2,r2,255
    54d0:	e13ffe17 	ldw	r4,-8(fp)
    54d4:	014002c4 	movi	r5,11
    54d8:	100d883a 	mov	r6,r2
    54dc:	00054f40 	call	54f4 <icmp_send_response>
}
    54e0:	e037883a 	mov	sp,fp
    54e4:	dfc00117 	ldw	ra,4(sp)
    54e8:	df000017 	ldw	fp,0(sp)
    54ec:	dec00204 	addi	sp,sp,8
    54f0:	f800283a 	ret

000054f4 <icmp_send_response>:
 * @param type Type of the ICMP header
 * @param code Code of the ICMP header
 */
static void
icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
{
    54f4:	defff604 	addi	sp,sp,-40
    54f8:	dfc00915 	stw	ra,36(sp)
    54fc:	df000815 	stw	fp,32(sp)
    5500:	df000804 	addi	fp,sp,32
    5504:	e13ffd15 	stw	r4,-12(fp)
    5508:	2807883a 	mov	r3,r5
    550c:	3005883a 	mov	r2,r6
    5510:	e0fffe05 	stb	r3,-8(fp)
    5514:	e0bfff05 	stb	r2,-4(fp)
  struct ip_hdr *iphdr;
  /* we can use the echo header here */
  struct icmp_echo_hdr *icmphdr;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
    5518:	01000044 	movi	r4,1
    551c:	01400904 	movi	r5,36
    5520:	000d883a 	mov	r6,zero
    5524:	00097b00 	call	97b0 <pbuf_alloc>
    5528:	e0bffa15 	stw	r2,-24(fp)
                 PBUF_RAM);
  if (q == NULL) {
    552c:	e0bffa17 	ldw	r2,-24(fp)
    5530:	1000041e 	bne	r2,zero,5544 <icmp_send_response+0x50>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    5534:	010000f4 	movhi	r4,3
    5538:	2136bf04 	addi	r4,r4,-9476
    553c:	00169500 	call	16950 <puts>
    return;
    5540:	00008306 	br	5750 <icmp_send_response+0x25c>
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
    5544:	e0bffa17 	ldw	r2,-24(fp)
    5548:	1080028b 	ldhu	r2,10(r2)
    554c:	10bfffcc 	andi	r2,r2,65535
    5550:	10800928 	cmpgeui	r2,r2,36
    5554:	1000091e 	bne	r2,zero,557c <icmp_send_response+0x88>
    5558:	010000f4 	movhi	r4,3
    555c:	21366904 	addi	r4,r4,-9820
    5560:	014000f4 	movhi	r5,3
    5564:	2976cf04 	addi	r5,r5,-9412
    5568:	01804b04 	movi	r6,300
    556c:	01c000f4 	movhi	r7,3
    5570:	39f68004 	addi	r7,r7,-9728
    5574:	00166c00 	call	166c0 <printf>
    5578:	003fff06 	br	5578 <icmp_send_response+0x84>
             (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
    557c:	e0bffd17 	ldw	r2,-12(fp)
    5580:	10800117 	ldw	r2,4(r2)
    5584:	e0bffb15 	stw	r2,-20(fp)
  LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded from "));
    5588:	010000f4 	movhi	r4,3
    558c:	2136da04 	addi	r4,r4,-9368
    5590:	00166c00 	call	166c0 <printf>
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
    5594:	e0bffb17 	ldw	r2,-20(fp)
    5598:	10800304 	addi	r2,r2,12
    559c:	10001526 	beq	r2,zero,55f4 <icmp_send_response+0x100>
    55a0:	e0bffb17 	ldw	r2,-20(fp)
    55a4:	10c0030b 	ldhu	r3,12(r2)
    55a8:	1080038b 	ldhu	r2,14(r2)
    55ac:	1004943a 	slli	r2,r2,16
    55b0:	10c4b03a 	or	r2,r2,r3
    55b4:	1004d63a 	srli	r2,r2,24
    55b8:	10803fcc 	andi	r2,r2,255
    55bc:	1007883a 	mov	r3,r2
    55c0:	e0bffb17 	ldw	r2,-20(fp)
    55c4:	1100030b 	ldhu	r4,12(r2)
    55c8:	1080038b 	ldhu	r2,14(r2)
    55cc:	1004943a 	slli	r2,r2,16
    55d0:	1104b03a 	or	r2,r2,r4
    55d4:	1004d23a 	srli	r2,r2,8
    55d8:	1009883a 	mov	r4,r2
    55dc:	00bfc004 	movi	r2,-256
    55e0:	2084703a 	and	r2,r4,r2
    55e4:	1884b03a 	or	r2,r3,r2
    55e8:	10bfffcc 	andi	r2,r2,65535
    55ec:	10803fcc 	andi	r2,r2,255
    55f0:	00000106 	br	55f8 <icmp_send_response+0x104>
    55f4:	0005883a 	mov	r2,zero
    55f8:	1009883a 	mov	r4,r2
    55fc:	00166c00 	call	166c0 <printf>
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
    5600:	010000f4 	movhi	r4,3
    5604:	2136e104 	addi	r4,r4,-9340
    5608:	00166c00 	call	166c0 <printf>
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
    560c:	e0bffb17 	ldw	r2,-20(fp)
    5610:	10800404 	addi	r2,r2,16
    5614:	10001526 	beq	r2,zero,566c <icmp_send_response+0x178>
    5618:	e0bffb17 	ldw	r2,-20(fp)
    561c:	10c0040b 	ldhu	r3,16(r2)
    5620:	1080048b 	ldhu	r2,18(r2)
    5624:	1004943a 	slli	r2,r2,16
    5628:	10c4b03a 	or	r2,r2,r3
    562c:	1004d63a 	srli	r2,r2,24
    5630:	10803fcc 	andi	r2,r2,255
    5634:	1007883a 	mov	r3,r2
    5638:	e0bffb17 	ldw	r2,-20(fp)
    563c:	1100040b 	ldhu	r4,16(r2)
    5640:	1080048b 	ldhu	r2,18(r2)
    5644:	1004943a 	slli	r2,r2,16
    5648:	1104b03a 	or	r2,r2,r4
    564c:	1004d23a 	srli	r2,r2,8
    5650:	1009883a 	mov	r4,r2
    5654:	00bfc004 	movi	r2,-256
    5658:	2084703a 	and	r2,r4,r2
    565c:	1884b03a 	or	r2,r3,r2
    5660:	10bfffcc 	andi	r2,r2,65535
    5664:	10803fcc 	andi	r2,r2,255
    5668:	00000106 	br	5670 <icmp_send_response+0x17c>
    566c:	0005883a 	mov	r2,zero
    5670:	1009883a 	mov	r4,r2
    5674:	00166c00 	call	166c0 <printf>
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));
    5678:	01000284 	movi	r4,10
    567c:	00168b00 	call	168b0 <putchar>

  icmphdr = q->payload;
    5680:	e0bffa17 	ldw	r2,-24(fp)
    5684:	10800117 	ldw	r2,4(r2)
    5688:	e0bffc15 	stw	r2,-16(fp)
  icmphdr->type = type;
    568c:	e0bffc17 	ldw	r2,-16(fp)
    5690:	e0fffe03 	ldbu	r3,-8(fp)
    5694:	10c00005 	stb	r3,0(r2)
  icmphdr->code = code;
    5698:	e0bffc17 	ldw	r2,-16(fp)
    569c:	e0ffff03 	ldbu	r3,-4(fp)
    56a0:	10c00045 	stb	r3,1(r2)
  icmphdr->id = 0;
    56a4:	e0bffc17 	ldw	r2,-16(fp)
    56a8:	1000010d 	sth	zero,4(r2)
  icmphdr->seqno = 0;
    56ac:	e0bffc17 	ldw	r2,-16(fp)
    56b0:	1000018d 	sth	zero,6(r2)

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
    56b4:	e0bffa17 	ldw	r2,-24(fp)
    56b8:	10800117 	ldw	r2,4(r2)
    56bc:	10c00204 	addi	r3,r2,8
    56c0:	e0bffd17 	ldw	r2,-12(fp)
    56c4:	10800117 	ldw	r2,4(r2)
    56c8:	1809883a 	mov	r4,r3
    56cc:	100b883a 	mov	r5,r2
    56d0:	01800704 	movi	r6,28
    56d4:	00164c00 	call	164c0 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  icmphdr->chksum = 0;
    56d8:	e0bffc17 	ldw	r2,-16(fp)
    56dc:	1000008d 	sth	zero,2(r2)
  icmphdr->chksum = inet_chksum(icmphdr, q->len);
    56e0:	e0bffa17 	ldw	r2,-24(fp)
    56e4:	1080028b 	ldhu	r2,10(r2)
    56e8:	10bfffcc 	andi	r2,r2,65535
    56ec:	e13ffc17 	ldw	r4,-16(fp)
    56f0:	100b883a 	mov	r5,r2
    56f4:	00060440 	call	6044 <inet_chksum>
    56f8:	e0fffc17 	ldw	r3,-16(fp)
    56fc:	1880008d 	sth	r2,2(r3)
  ICMP_STATS_INC(icmp.xmit);
    5700:	00800134 	movhi	r2,4
    5704:	108d9504 	addi	r2,r2,13908
    5708:	1080180b 	ldhu	r2,96(r2)
    570c:	10800044 	addi	r2,r2,1
    5710:	1007883a 	mov	r3,r2
    5714:	00800134 	movhi	r2,4
    5718:	108d9504 	addi	r2,r2,13908
    571c:	10c0180d 	sth	r3,96(r2)
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
    5720:	e0bffb17 	ldw	r2,-20(fp)
    5724:	10800304 	addi	r2,r2,12
    5728:	d8000015 	stw	zero,0(sp)
    572c:	00c00044 	movi	r3,1
    5730:	d8c00115 	stw	r3,4(sp)
    5734:	e13ffa17 	ldw	r4,-24(fp)
    5738:	000b883a 	mov	r5,zero
    573c:	100d883a 	mov	r6,r2
    5740:	01c03fc4 	movi	r7,255
    5744:	0006cfc0 	call	6cfc <ip_output>
  pbuf_free(q);
    5748:	e13ffa17 	ldw	r4,-24(fp)
    574c:	000a16c0 	call	a16c <pbuf_free>
}
    5750:	e037883a 	mov	sp,fp
    5754:	dfc00117 	ldw	ra,4(sp)
    5758:	df000017 	ldw	fp,0(sp)
    575c:	dec00204 	addi	sp,sp,8
    5760:	f800283a 	ret

00005764 <inet_addr>:
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @return ip address in network order
 */
u32_t
inet_addr(const char *cp)
{
    5764:	defffc04 	addi	sp,sp,-16
    5768:	dfc00315 	stw	ra,12(sp)
    576c:	df000215 	stw	fp,8(sp)
    5770:	df000204 	addi	fp,sp,8
    5774:	e13fff15 	stw	r4,-4(fp)
  struct in_addr val;

  if (inet_aton(cp, &val)) {
    5778:	e13fff17 	ldw	r4,-4(fp)
    577c:	e17ffe04 	addi	r5,fp,-8
    5780:	00057a80 	call	57a8 <inet_aton>
    5784:	10000226 	beq	r2,zero,5790 <inet_addr+0x2c>
    return (val.s_addr);
    5788:	e0bffe17 	ldw	r2,-8(fp)
    578c:	00000106 	br	5794 <inet_addr+0x30>
  }
  return (INADDR_NONE);
    5790:	00bfffc4 	movi	r2,-1
}
    5794:	e037883a 	mov	sp,fp
    5798:	dfc00117 	ldw	ra,4(sp)
    579c:	df000017 	ldw	fp,0(sp)
    57a0:	dec00204 	addi	sp,sp,8
    57a4:	f800283a 	ret

000057a8 <inet_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
inet_aton(const char *cp, struct in_addr *addr)
{
    57a8:	defff604 	addi	sp,sp,-40
    57ac:	df000915 	stw	fp,36(sp)
    57b0:	df000904 	addi	fp,sp,36
    57b4:	e13ffe15 	stw	r4,-8(fp)
    57b8:	e17fff15 	stw	r5,-4(fp)
  u32_t val;
  u8_t base;
  char c;
  u32_t parts[4];
  u32_t *pp = parts;
    57bc:	e0bffa04 	addi	r2,fp,-24
    57c0:	e0bff915 	stw	r2,-28(fp)

  c = *cp;
    57c4:	e0bffe17 	ldw	r2,-8(fp)
    57c8:	10800003 	ldbu	r2,0(r2)
    57cc:	e0bff845 	stb	r2,-31(fp)
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
    57d0:	e0bff843 	ldbu	r2,-31(fp)
    57d4:	10803fcc 	andi	r2,r2,255
    57d8:	10800c30 	cmpltui	r2,r2,48
    57dc:	1000041e 	bne	r2,zero,57f0 <inet_aton+0x48>
    57e0:	e0bff843 	ldbu	r2,-31(fp)
    57e4:	10803fcc 	andi	r2,r2,255
    57e8:	10800eb0 	cmpltui	r2,r2,58
    57ec:	1000021e 	bne	r2,zero,57f8 <inet_aton+0x50>
      return (0);
    57f0:	0005883a 	mov	r2,zero
    57f4:	0000e606 	br	5b90 <inet_aton+0x3e8>
    val = 0;
    57f8:	e03ff715 	stw	zero,-36(fp)
    base = 10;
    57fc:	00800284 	movi	r2,10
    5800:	e0bff805 	stb	r2,-32(fp)
    if (c == '0') {
    5804:	e0bff847 	ldb	r2,-31(fp)
    5808:	10800c18 	cmpnei	r2,r2,48
    580c:	1000171e 	bne	r2,zero,586c <inet_aton+0xc4>
      c = *++cp;
    5810:	e0bffe17 	ldw	r2,-8(fp)
    5814:	10800044 	addi	r2,r2,1
    5818:	e0bffe15 	stw	r2,-8(fp)
    581c:	e0bffe17 	ldw	r2,-8(fp)
    5820:	10800003 	ldbu	r2,0(r2)
    5824:	e0bff845 	stb	r2,-31(fp)
      if (c == 'x' || c == 'X') {
    5828:	e0bff847 	ldb	r2,-31(fp)
    582c:	10801e20 	cmpeqi	r2,r2,120
    5830:	1000031e 	bne	r2,zero,5840 <inet_aton+0x98>
    5834:	e0bff847 	ldb	r2,-31(fp)
    5838:	10801618 	cmpnei	r2,r2,88
    583c:	1000091e 	bne	r2,zero,5864 <inet_aton+0xbc>
        base = 16;
    5840:	00800404 	movi	r2,16
    5844:	e0bff805 	stb	r2,-32(fp)
        c = *++cp;
    5848:	e0bffe17 	ldw	r2,-8(fp)
    584c:	10800044 	addi	r2,r2,1
    5850:	e0bffe15 	stw	r2,-8(fp)
    5854:	e0bffe17 	ldw	r2,-8(fp)
    5858:	10800003 	ldbu	r2,0(r2)
    585c:	e0bff845 	stb	r2,-31(fp)
    5860:	00000206 	br	586c <inet_aton+0xc4>
      } else
        base = 8;
    5864:	00800204 	movi	r2,8
    5868:	e0bff805 	stb	r2,-32(fp)
    }
    for (;;) {
      if (isdigit(c)) {
    586c:	e0bff843 	ldbu	r2,-31(fp)
    5870:	10803fcc 	andi	r2,r2,255
    5874:	10800c30 	cmpltui	r2,r2,48
    5878:	1000121e 	bne	r2,zero,58c4 <inet_aton+0x11c>
    587c:	e0bff843 	ldbu	r2,-31(fp)
    5880:	10803fcc 	andi	r2,r2,255
    5884:	10800ea8 	cmpgeui	r2,r2,58
    5888:	10000e1e 	bne	r2,zero,58c4 <inet_aton+0x11c>
        val = (val * base) + (int)(c - '0');
    588c:	e0fff803 	ldbu	r3,-32(fp)
    5890:	e0bff717 	ldw	r2,-36(fp)
    5894:	1887383a 	mul	r3,r3,r2
    5898:	e0bff847 	ldb	r2,-31(fp)
    589c:	1885883a 	add	r2,r3,r2
    58a0:	10bff404 	addi	r2,r2,-48
    58a4:	e0bff715 	stw	r2,-36(fp)
        c = *++cp;
    58a8:	e0bffe17 	ldw	r2,-8(fp)
    58ac:	10800044 	addi	r2,r2,1
    58b0:	e0bffe15 	stw	r2,-8(fp)
    58b4:	e0bffe17 	ldw	r2,-8(fp)
    58b8:	10800003 	ldbu	r2,0(r2)
    58bc:	e0bff845 	stb	r2,-31(fp)
      } else if (base == 16 && isxdigit(c)) {
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
        c = *++cp;
      } else
        break;
    }
    58c0:	003fea06 	br	586c <inet_aton+0xc4>
    }
    for (;;) {
      if (isdigit(c)) {
        val = (val * base) + (int)(c - '0');
        c = *++cp;
      } else if (base == 16 && isxdigit(c)) {
    58c4:	e0bff803 	ldbu	r2,-32(fp)
    58c8:	10800418 	cmpnei	r2,r2,16
    58cc:	1000311e 	bne	r2,zero,5994 <inet_aton+0x1ec>
    58d0:	e0bff843 	ldbu	r2,-31(fp)
    58d4:	10803fcc 	andi	r2,r2,255
    58d8:	10800c30 	cmpltui	r2,r2,48
    58dc:	1000041e 	bne	r2,zero,58f0 <inet_aton+0x148>
    58e0:	e0bff843 	ldbu	r2,-31(fp)
    58e4:	10803fcc 	andi	r2,r2,255
    58e8:	10800eb0 	cmpltui	r2,r2,58
    58ec:	1000101e 	bne	r2,zero,5930 <inet_aton+0x188>
    58f0:	e0bff843 	ldbu	r2,-31(fp)
    58f4:	10803fcc 	andi	r2,r2,255
    58f8:	10801870 	cmpltui	r2,r2,97
    58fc:	1000041e 	bne	r2,zero,5910 <inet_aton+0x168>
    5900:	e0bff843 	ldbu	r2,-31(fp)
    5904:	10803fcc 	andi	r2,r2,255
    5908:	108019f0 	cmpltui	r2,r2,103
    590c:	1000081e 	bne	r2,zero,5930 <inet_aton+0x188>
    5910:	e0bff843 	ldbu	r2,-31(fp)
    5914:	10803fcc 	andi	r2,r2,255
    5918:	10801070 	cmpltui	r2,r2,65
    591c:	10001d1e 	bne	r2,zero,5994 <inet_aton+0x1ec>
    5920:	e0bff843 	ldbu	r2,-31(fp)
    5924:	10803fcc 	andi	r2,r2,255
    5928:	108011e8 	cmpgeui	r2,r2,71
    592c:	1000191e 	bne	r2,zero,5994 <inet_aton+0x1ec>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
    5930:	e0bff717 	ldw	r2,-36(fp)
    5934:	1006913a 	slli	r3,r2,4
    5938:	e0bff847 	ldb	r2,-31(fp)
    593c:	11000284 	addi	r4,r2,10
    5940:	e0bff843 	ldbu	r2,-31(fp)
    5944:	10803fcc 	andi	r2,r2,255
    5948:	10801870 	cmpltui	r2,r2,97
    594c:	1000061e 	bne	r2,zero,5968 <inet_aton+0x1c0>
    5950:	e0bff843 	ldbu	r2,-31(fp)
    5954:	10803fcc 	andi	r2,r2,255
    5958:	10801ee8 	cmpgeui	r2,r2,123
    595c:	1000021e 	bne	r2,zero,5968 <inet_aton+0x1c0>
    5960:	00801844 	movi	r2,97
    5964:	00000106 	br	596c <inet_aton+0x1c4>
    5968:	00801044 	movi	r2,65
    596c:	2085c83a 	sub	r2,r4,r2
    5970:	1884b03a 	or	r2,r3,r2
    5974:	e0bff715 	stw	r2,-36(fp)
        c = *++cp;
    5978:	e0bffe17 	ldw	r2,-8(fp)
    597c:	10800044 	addi	r2,r2,1
    5980:	e0bffe15 	stw	r2,-8(fp)
    5984:	e0bffe17 	ldw	r2,-8(fp)
    5988:	10800003 	ldbu	r2,0(r2)
    598c:	e0bff845 	stb	r2,-31(fp)
      } else
        break;
    }
    5990:	003fb606 	br	586c <inet_aton+0xc4>
    if (c == '.') {
    5994:	e0bff847 	ldb	r2,-31(fp)
    5998:	10800b98 	cmpnei	r2,r2,46
    599c:	1000131e 	bne	r2,zero,59ec <inet_aton+0x244>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
    59a0:	e0bffa04 	addi	r2,fp,-24
    59a4:	10800304 	addi	r2,r2,12
    59a8:	e0fff917 	ldw	r3,-28(fp)
    59ac:	18800236 	bltu	r3,r2,59b8 <inet_aton+0x210>
        return (0);
    59b0:	0005883a 	mov	r2,zero
    59b4:	00007606 	br	5b90 <inet_aton+0x3e8>
      *pp++ = val;
    59b8:	e0bff917 	ldw	r2,-28(fp)
    59bc:	e0fff717 	ldw	r3,-36(fp)
    59c0:	10c00015 	stw	r3,0(r2)
    59c4:	e0bff917 	ldw	r2,-28(fp)
    59c8:	10800104 	addi	r2,r2,4
    59cc:	e0bff915 	stw	r2,-28(fp)
      c = *++cp;
    59d0:	e0bffe17 	ldw	r2,-8(fp)
    59d4:	10800044 	addi	r2,r2,1
    59d8:	e0bffe15 	stw	r2,-8(fp)
    59dc:	e0bffe17 	ldw	r2,-8(fp)
    59e0:	10800003 	ldbu	r2,0(r2)
    59e4:	e0bff845 	stb	r2,-31(fp)
    } else
      break;
  }
    59e8:	003f7906 	br	57d0 <inet_aton+0x28>
      if (pp >= parts + 3)
        return (0);
      *pp++ = val;
      c = *++cp;
    } else
      break;
    59ec:	0001883a 	nop
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && !isspace(c))
    59f0:	e0bff847 	ldb	r2,-31(fp)
    59f4:	10001426 	beq	r2,zero,5a48 <inet_aton+0x2a0>
    59f8:	e0bff847 	ldb	r2,-31(fp)
    59fc:	10800820 	cmpeqi	r2,r2,32
    5a00:	1000111e 	bne	r2,zero,5a48 <inet_aton+0x2a0>
    5a04:	e0bff847 	ldb	r2,-31(fp)
    5a08:	10800320 	cmpeqi	r2,r2,12
    5a0c:	10000e1e 	bne	r2,zero,5a48 <inet_aton+0x2a0>
    5a10:	e0bff847 	ldb	r2,-31(fp)
    5a14:	108002a0 	cmpeqi	r2,r2,10
    5a18:	10000b1e 	bne	r2,zero,5a48 <inet_aton+0x2a0>
    5a1c:	e0bff847 	ldb	r2,-31(fp)
    5a20:	10800360 	cmpeqi	r2,r2,13
    5a24:	1000081e 	bne	r2,zero,5a48 <inet_aton+0x2a0>
    5a28:	e0bff847 	ldb	r2,-31(fp)
    5a2c:	10800260 	cmpeqi	r2,r2,9
    5a30:	1000051e 	bne	r2,zero,5a48 <inet_aton+0x2a0>
    5a34:	e0bff847 	ldb	r2,-31(fp)
    5a38:	108002e0 	cmpeqi	r2,r2,11
    5a3c:	1000021e 	bne	r2,zero,5a48 <inet_aton+0x2a0>
    return (0);
    5a40:	0005883a 	mov	r2,zero
    5a44:	00005206 	br	5b90 <inet_aton+0x3e8>
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  switch (pp - parts + 1) {
    5a48:	e0fff917 	ldw	r3,-28(fp)
    5a4c:	e0bffa04 	addi	r2,fp,-24
    5a50:	1885c83a 	sub	r2,r3,r2
    5a54:	1005d0ba 	srai	r2,r2,2
    5a58:	10800044 	addi	r2,r2,1
    5a5c:	10c00168 	cmpgeui	r3,r2,5
    5a60:	1800391e 	bne	r3,zero,5b48 <inet_aton+0x3a0>
    5a64:	1085883a 	add	r2,r2,r2
    5a68:	1087883a 	add	r3,r2,r2
    5a6c:	00800034 	movhi	r2,0
    5a70:	1096a004 	addi	r2,r2,23168
    5a74:	1885883a 	add	r2,r3,r2
    5a78:	10800017 	ldw	r2,0(r2)
    5a7c:	1000683a 	jmp	r2
    5a80:	00005a94 	movui	zero,362
    5a84:	00005b44 	movi	zero,365
    5a88:	00005a9c 	xori	zero,zero,362
    5a8c:	00005ac8 	cmpgei	zero,zero,363
    5a90:	00005b00 	call	5b0 <fs_open+0x20>

  case 0:
    return (0);       /* initial nondigit */
    5a94:	0005883a 	mov	r2,zero
    5a98:	00003d06 	br	5b90 <inet_aton+0x3e8>

  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL)
    5a9c:	e0fff717 	ldw	r3,-36(fp)
    5aa0:	00804034 	movhi	r2,256
    5aa4:	18800236 	bltu	r3,r2,5ab0 <inet_aton+0x308>
      return (0);
    5aa8:	0005883a 	mov	r2,zero
    5aac:	00003806 	br	5b90 <inet_aton+0x3e8>
    val |= parts[0] << 24;
    5ab0:	e0bffa17 	ldw	r2,-24(fp)
    5ab4:	1004963a 	slli	r2,r2,24
    5ab8:	e0fff717 	ldw	r3,-36(fp)
    5abc:	1884b03a 	or	r2,r3,r2
    5ac0:	e0bff715 	stw	r2,-36(fp)
    break;
    5ac4:	00002006 	br	5b48 <inet_aton+0x3a0>

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff)
    5ac8:	e0bff717 	ldw	r2,-36(fp)
    5acc:	00ffffd4 	movui	r3,65535
    5ad0:	1880022e 	bgeu	r3,r2,5adc <inet_aton+0x334>
      return (0);
    5ad4:	0005883a 	mov	r2,zero
    5ad8:	00002d06 	br	5b90 <inet_aton+0x3e8>
    val |= (parts[0] << 24) | (parts[1] << 16);
    5adc:	e0bffa17 	ldw	r2,-24(fp)
    5ae0:	1006963a 	slli	r3,r2,24
    5ae4:	e0bffb17 	ldw	r2,-20(fp)
    5ae8:	1004943a 	slli	r2,r2,16
    5aec:	1884b03a 	or	r2,r3,r2
    5af0:	e0fff717 	ldw	r3,-36(fp)
    5af4:	1884b03a 	or	r2,r3,r2
    5af8:	e0bff715 	stw	r2,-36(fp)
    break;
    5afc:	00001206 	br	5b48 <inet_aton+0x3a0>

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff)
    5b00:	e0bff717 	ldw	r2,-36(fp)
    5b04:	10804030 	cmpltui	r2,r2,256
    5b08:	1000021e 	bne	r2,zero,5b14 <inet_aton+0x36c>
      return (0);
    5b0c:	0005883a 	mov	r2,zero
    5b10:	00001f06 	br	5b90 <inet_aton+0x3e8>
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
    5b14:	e0bffa17 	ldw	r2,-24(fp)
    5b18:	1006963a 	slli	r3,r2,24
    5b1c:	e0bffb17 	ldw	r2,-20(fp)
    5b20:	1004943a 	slli	r2,r2,16
    5b24:	1886b03a 	or	r3,r3,r2
    5b28:	e0bffc17 	ldw	r2,-16(fp)
    5b2c:	1004923a 	slli	r2,r2,8
    5b30:	1884b03a 	or	r2,r3,r2
    5b34:	e0fff717 	ldw	r3,-36(fp)
    5b38:	1884b03a 	or	r2,r3,r2
    5b3c:	e0bff715 	stw	r2,-36(fp)
    break;
    5b40:	00000106 	br	5b48 <inet_aton+0x3a0>

  case 0:
    return (0);       /* initial nondigit */

  case 1:             /* a -- 32 bits */
    break;
    5b44:	0001883a 	nop
    if (val > 0xff)
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
    break;
  }
  if (addr)
    5b48:	e0bfff17 	ldw	r2,-4(fp)
    5b4c:	10000f26 	beq	r2,zero,5b8c <inet_aton+0x3e4>
    addr->s_addr = htonl(val);
    5b50:	e0bff717 	ldw	r2,-36(fp)
    5b54:	1006d63a 	srli	r3,r2,24
    5b58:	e0bff717 	ldw	r2,-36(fp)
    5b5c:	1004d23a 	srli	r2,r2,8
    5b60:	10bfc00c 	andi	r2,r2,65280
    5b64:	1886b03a 	or	r3,r3,r2
    5b68:	e0bff717 	ldw	r2,-36(fp)
    5b6c:	10bfc00c 	andi	r2,r2,65280
    5b70:	1004923a 	slli	r2,r2,8
    5b74:	1886b03a 	or	r3,r3,r2
    5b78:	e0bff717 	ldw	r2,-36(fp)
    5b7c:	1004963a 	slli	r2,r2,24
    5b80:	1886b03a 	or	r3,r3,r2
    5b84:	e0bfff17 	ldw	r2,-4(fp)
    5b88:	10c00015 	stw	r3,0(r2)
  return (1);
    5b8c:	00800044 	movi	r2,1
}
    5b90:	e037883a 	mov	sp,fp
    5b94:	df000017 	ldw	fp,0(sp)
    5b98:	dec00104 	addi	sp,sp,4
    5b9c:	f800283a 	ret

00005ba0 <inet_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
{
    5ba0:	defff904 	addi	sp,sp,-28
    5ba4:	df000615 	stw	fp,24(sp)
    5ba8:	df000604 	addi	fp,sp,24
    5bac:	e13fff15 	stw	r4,-4(fp)
  static char str[16];
  u32_t s_addr = addr.s_addr;
    5bb0:	e0bfff17 	ldw	r2,-4(fp)
    5bb4:	e0bffd15 	stw	r2,-12(fp)
  u8_t *ap;
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
    5bb8:	008000f4 	movhi	r2,3
    5bbc:	10961904 	addi	r2,r2,22628
    5bc0:	e0bffa15 	stw	r2,-24(fp)
  ap = (u8_t *)&s_addr;
    5bc4:	e0bffd04 	addi	r2,fp,-12
    5bc8:	e0bffb15 	stw	r2,-20(fp)
  for(n = 0; n < 4; n++) {
    5bcc:	e03ffc05 	stb	zero,-16(fp)
    5bd0:	00003b06 	br	5cc0 <inet_ntoa+0x120>
    i = 0;
    5bd4:	e03ffc45 	stb	zero,-15(fp)
    do {
      rem = *ap % (u8_t)10;
    5bd8:	e0bffb17 	ldw	r2,-20(fp)
    5bdc:	10800003 	ldbu	r2,0(r2)
    5be0:	10803fcc 	andi	r2,r2,255
    5be4:	00c00284 	movi	r3,10
    5be8:	10c7203a 	divu	r3,r2,r3
    5bec:	18c002a4 	muli	r3,r3,10
    5bf0:	10c5c83a 	sub	r2,r2,r3
    5bf4:	e0bffc85 	stb	r2,-14(fp)
      *ap /= (u8_t)10;
    5bf8:	e0bffb17 	ldw	r2,-20(fp)
    5bfc:	10800003 	ldbu	r2,0(r2)
    5c00:	10c03fcc 	andi	r3,r2,255
    5c04:	00800284 	movi	r2,10
    5c08:	1885203a 	divu	r2,r3,r2
    5c0c:	1007883a 	mov	r3,r2
    5c10:	e0bffb17 	ldw	r2,-20(fp)
    5c14:	10c00005 	stb	r3,0(r2)
      inv[i++] = '0' + rem;
    5c18:	e0bffc43 	ldbu	r2,-15(fp)
    5c1c:	e0fffc83 	ldbu	r3,-14(fp)
    5c20:	18c00c04 	addi	r3,r3,48
    5c24:	e13ffe04 	addi	r4,fp,-8
    5c28:	2085883a 	add	r2,r4,r2
    5c2c:	10c00005 	stb	r3,0(r2)
    5c30:	e0bffc43 	ldbu	r2,-15(fp)
    5c34:	10800044 	addi	r2,r2,1
    5c38:	e0bffc45 	stb	r2,-15(fp)
    } while(*ap);
    5c3c:	e0bffb17 	ldw	r2,-20(fp)
    5c40:	10800003 	ldbu	r2,0(r2)
    5c44:	10803fcc 	andi	r2,r2,255
    5c48:	103fe31e 	bne	r2,zero,5bd8 <inet_ntoa+0x38>
    while(i--)
    5c4c:	00000906 	br	5c74 <inet_ntoa+0xd4>
      *rp++ = inv[i];
    5c50:	e0bffc43 	ldbu	r2,-15(fp)
    5c54:	e0fffe04 	addi	r3,fp,-8
    5c58:	1885883a 	add	r2,r3,r2
    5c5c:	10c00003 	ldbu	r3,0(r2)
    5c60:	e0bffa17 	ldw	r2,-24(fp)
    5c64:	10c00005 	stb	r3,0(r2)
    5c68:	e0bffa17 	ldw	r2,-24(fp)
    5c6c:	10800044 	addi	r2,r2,1
    5c70:	e0bffa15 	stw	r2,-24(fp)
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
    5c74:	e0bffc43 	ldbu	r2,-15(fp)
    5c78:	1004c03a 	cmpne	r2,r2,zero
    5c7c:	e0fffc43 	ldbu	r3,-15(fp)
    5c80:	18ffffc4 	addi	r3,r3,-1
    5c84:	e0fffc45 	stb	r3,-15(fp)
    5c88:	10803fcc 	andi	r2,r2,255
    5c8c:	103ff01e 	bne	r2,zero,5c50 <inet_ntoa+0xb0>
      *rp++ = inv[i];
    *rp++ = '.';
    5c90:	e0bffa17 	ldw	r2,-24(fp)
    5c94:	00c00b84 	movi	r3,46
    5c98:	10c00005 	stb	r3,0(r2)
    5c9c:	e0bffa17 	ldw	r2,-24(fp)
    5ca0:	10800044 	addi	r2,r2,1
    5ca4:	e0bffa15 	stw	r2,-24(fp)
    ap++;
    5ca8:	e0bffb17 	ldw	r2,-20(fp)
    5cac:	10800044 	addi	r2,r2,1
    5cb0:	e0bffb15 	stw	r2,-20(fp)
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
    5cb4:	e0bffc03 	ldbu	r2,-16(fp)
    5cb8:	10800044 	addi	r2,r2,1
    5cbc:	e0bffc05 	stb	r2,-16(fp)
    5cc0:	e0bffc03 	ldbu	r2,-16(fp)
    5cc4:	10800130 	cmpltui	r2,r2,4
    5cc8:	103fc21e 	bne	r2,zero,5bd4 <inet_ntoa+0x34>
    while(i--)
      *rp++ = inv[i];
    *rp++ = '.';
    ap++;
  }
  *--rp = 0;
    5ccc:	e0bffa17 	ldw	r2,-24(fp)
    5cd0:	10bfffc4 	addi	r2,r2,-1
    5cd4:	e0bffa15 	stw	r2,-24(fp)
    5cd8:	e0bffa17 	ldw	r2,-24(fp)
    5cdc:	10000005 	stb	zero,0(r2)
  return str;
    5ce0:	008000f4 	movhi	r2,3
    5ce4:	10961904 	addi	r2,r2,22628
}
    5ce8:	e037883a 	mov	sp,fp
    5cec:	df000017 	ldw	fp,0(sp)
    5cf0:	dec00104 	addi	sp,sp,4
    5cf4:	f800283a 	ret

00005cf8 <lwip_standard_chksum>:
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
{
    5cf8:	defffa04 	addi	sp,sp,-24
    5cfc:	df000515 	stw	fp,20(sp)
    5d00:	df000504 	addi	fp,sp,20
    5d04:	e13ffe15 	stw	r4,-8(fp)
    5d08:	2805883a 	mov	r2,r5
    5d0c:	e0bfff0d 	sth	r2,-4(fp)
  u32_t acc;
  u16_t src;
  u8_t *octetptr;

  acc = 0;
    5d10:	e03ffb15 	stw	zero,-20(fp)
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
    5d14:	e0bffe17 	ldw	r2,-8(fp)
    5d18:	e0bffc15 	stw	r2,-16(fp)
  while (len > 1) {
    5d1c:	00001806 	br	5d80 <lwip_standard_chksum+0x88>
    /* declare first octet as most significant
       thus assume network order, ignoring host order */
    src = (*octetptr) << 8;
    5d20:	e0bffc17 	ldw	r2,-16(fp)
    5d24:	10800003 	ldbu	r2,0(r2)
    5d28:	10803fcc 	andi	r2,r2,255
    5d2c:	1004923a 	slli	r2,r2,8
    5d30:	e0bffd0d 	sth	r2,-12(fp)
    octetptr++;
    5d34:	e0bffc17 	ldw	r2,-16(fp)
    5d38:	10800044 	addi	r2,r2,1
    5d3c:	e0bffc15 	stw	r2,-16(fp)
    /* declare second octet as least significant */
    src |= (*octetptr);
    5d40:	e0bffc17 	ldw	r2,-16(fp)
    5d44:	10800003 	ldbu	r2,0(r2)
    5d48:	10c03fcc 	andi	r3,r2,255
    5d4c:	e0bffd0b 	ldhu	r2,-12(fp)
    5d50:	1884b03a 	or	r2,r3,r2
    5d54:	e0bffd0d 	sth	r2,-12(fp)
    octetptr++;
    5d58:	e0bffc17 	ldw	r2,-16(fp)
    5d5c:	10800044 	addi	r2,r2,1
    5d60:	e0bffc15 	stw	r2,-16(fp)
    acc += src;
    5d64:	e0bffd0b 	ldhu	r2,-12(fp)
    5d68:	e0fffb17 	ldw	r3,-20(fp)
    5d6c:	1885883a 	add	r2,r3,r2
    5d70:	e0bffb15 	stw	r2,-20(fp)
    len -= 2;
    5d74:	e0bfff0b 	ldhu	r2,-4(fp)
    5d78:	10bfff84 	addi	r2,r2,-2
    5d7c:	e0bfff0d 	sth	r2,-4(fp)
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
    5d80:	e0bfff0b 	ldhu	r2,-4(fp)
    5d84:	108000a8 	cmpgeui	r2,r2,2
    5d88:	103fe51e 	bne	r2,zero,5d20 <lwip_standard_chksum+0x28>
    src |= (*octetptr);
    octetptr++;
    acc += src;
    len -= 2;
  }
  if (len > 0) {
    5d8c:	e0bfff0b 	ldhu	r2,-4(fp)
    5d90:	10000926 	beq	r2,zero,5db8 <lwip_standard_chksum+0xc0>
    /* accumulate remaining octet */
    src = (*octetptr) << 8;
    5d94:	e0bffc17 	ldw	r2,-16(fp)
    5d98:	10800003 	ldbu	r2,0(r2)
    5d9c:	10803fcc 	andi	r2,r2,255
    5da0:	1004923a 	slli	r2,r2,8
    5da4:	e0bffd0d 	sth	r2,-12(fp)
    acc += src;
    5da8:	e0bffd0b 	ldhu	r2,-12(fp)
    5dac:	e0fffb17 	ldw	r3,-20(fp)
    5db0:	1885883a 	add	r2,r3,r2
    5db4:	e0bffb15 	stw	r2,-20(fp)
  }
  /* add deferred carry bits */
  acc = (acc >> 16) + (acc & 0x0000ffffUL);
    5db8:	e0bffb17 	ldw	r2,-20(fp)
    5dbc:	1006d43a 	srli	r3,r2,16
    5dc0:	e0bffb17 	ldw	r2,-20(fp)
    5dc4:	10bfffcc 	andi	r2,r2,65535
    5dc8:	1885883a 	add	r2,r3,r2
    5dcc:	e0bffb15 	stw	r2,-20(fp)
  if ((acc & 0xffff0000UL) != 0) {
    5dd0:	e0bffb17 	ldw	r2,-20(fp)
    5dd4:	10bfffec 	andhi	r2,r2,65535
    5dd8:	10000626 	beq	r2,zero,5df4 <lwip_standard_chksum+0xfc>
    acc = (acc >> 16) + (acc & 0x0000ffffUL);
    5ddc:	e0bffb17 	ldw	r2,-20(fp)
    5de0:	1006d43a 	srli	r3,r2,16
    5de4:	e0bffb17 	ldw	r2,-20(fp)
    5de8:	10bfffcc 	andi	r2,r2,65535
    5dec:	1885883a 	add	r2,r3,r2
    5df0:	e0bffb15 	stw	r2,-20(fp)
  }
  /* This maybe a little confusing: reorder sum using htons()
     instead of ntohs() since it has a little less call overhead.
     The caller must invert bits for Internet sum ! */
  return htons((u16_t)acc);
    5df4:	e0bffb17 	ldw	r2,-20(fp)
    5df8:	10bfffcc 	andi	r2,r2,65535
    5dfc:	1004d23a 	srli	r2,r2,8
    5e00:	1007883a 	mov	r3,r2
    5e04:	e0bffb17 	ldw	r2,-20(fp)
    5e08:	10bfffcc 	andi	r2,r2,65535
    5e0c:	1004923a 	slli	r2,r2,8
    5e10:	1884b03a 	or	r2,r3,r2
}
    5e14:	e037883a 	mov	sp,fp
    5e18:	df000017 	ldw	fp,0(sp)
    5e1c:	dec00104 	addi	sp,sp,4
    5e20:	f800283a 	ret

00005e24 <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len)
{
    5e24:	defff604 	addi	sp,sp,-40
    5e28:	dfc00915 	stw	ra,36(sp)
    5e2c:	df000815 	stw	fp,32(sp)
    5e30:	df000804 	addi	fp,sp,32
    5e34:	e13ffb15 	stw	r4,-20(fp)
    5e38:	e17ffc15 	stw	r5,-16(fp)
    5e3c:	e1bffd15 	stw	r6,-12(fp)
    5e40:	3805883a 	mov	r2,r7
    5e44:	e0c00217 	ldw	r3,8(fp)
    5e48:	e0bffe05 	stb	r2,-8(fp)
    5e4c:	e0ffff0d 	sth	r3,-4(fp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
    5e50:	e03ff815 	stw	zero,-32(fp)
  swapped = 0;
    5e54:	e03ffa05 	stb	zero,-24(fp)
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
    5e58:	e0bffb17 	ldw	r2,-20(fp)
    5e5c:	e0bff915 	stw	r2,-28(fp)
    5e60:	00002606 	br	5efc <inet_chksum_pseudo+0xd8>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
    5e64:	e0bff917 	ldw	r2,-28(fp)
    5e68:	10c00117 	ldw	r3,4(r2)
    5e6c:	e0bff917 	ldw	r2,-28(fp)
    5e70:	1080028b 	ldhu	r2,10(r2)
    5e74:	10bfffcc 	andi	r2,r2,65535
    5e78:	1809883a 	mov	r4,r3
    5e7c:	100b883a 	mov	r5,r2
    5e80:	0005cf80 	call	5cf8 <lwip_standard_chksum>
    5e84:	10bfffcc 	andi	r2,r2,65535
    5e88:	e0fff817 	ldw	r3,-32(fp)
    5e8c:	1885883a 	add	r2,r3,r2
    5e90:	e0bff815 	stw	r2,-32(fp)
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
    5e94:	e0bff817 	ldw	r2,-32(fp)
    5e98:	1006d43a 	srli	r3,r2,16
    5e9c:	e0bff817 	ldw	r2,-32(fp)
    5ea0:	10bfffcc 	andi	r2,r2,65535
    5ea4:	1885883a 	add	r2,r3,r2
    5ea8:	e0bff815 	stw	r2,-32(fp)
    if (q->len % 2 != 0) {
    5eac:	e0bff917 	ldw	r2,-28(fp)
    5eb0:	1080028b 	ldhu	r2,10(r2)
    5eb4:	1080004c 	andi	r2,r2,1
    5eb8:	10bfffcc 	andi	r2,r2,65535
    5ebc:	10000c26 	beq	r2,zero,5ef0 <inet_chksum_pseudo+0xcc>
      swapped = 1 - swapped;
    5ec0:	e0bffa03 	ldbu	r2,-24(fp)
    5ec4:	00c00044 	movi	r3,1
    5ec8:	1885c83a 	sub	r2,r3,r2
    5ecc:	e0bffa05 	stb	r2,-24(fp)
      acc = SWAP_BYTES_IN_WORD(acc);
    5ed0:	e0bff817 	ldw	r2,-32(fp)
    5ed4:	10bfc00c 	andi	r2,r2,65280
    5ed8:	1006d23a 	srli	r3,r2,8
    5edc:	e0bff817 	ldw	r2,-32(fp)
    5ee0:	1004923a 	slli	r2,r2,8
    5ee4:	10bfffcc 	andi	r2,r2,65535
    5ee8:	1884b03a 	or	r2,r3,r2
    5eec:	e0bff815 	stw	r2,-32(fp)
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
    5ef0:	e0bff917 	ldw	r2,-28(fp)
    5ef4:	10800017 	ldw	r2,0(r2)
    5ef8:	e0bff915 	stw	r2,-28(fp)
    5efc:	e0bff917 	ldw	r2,-28(fp)
    5f00:	103fd81e 	bne	r2,zero,5e64 <inet_chksum_pseudo+0x40>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
    5f04:	e0bffa03 	ldbu	r2,-24(fp)
    5f08:	10000826 	beq	r2,zero,5f2c <inet_chksum_pseudo+0x108>
    acc = SWAP_BYTES_IN_WORD(acc);
    5f0c:	e0bff817 	ldw	r2,-32(fp)
    5f10:	10bfc00c 	andi	r2,r2,65280
    5f14:	1006d23a 	srli	r3,r2,8
    5f18:	e0bff817 	ldw	r2,-32(fp)
    5f1c:	1004923a 	slli	r2,r2,8
    5f20:	10bfffcc 	andi	r2,r2,65535
    5f24:	1884b03a 	or	r2,r3,r2
    5f28:	e0bff815 	stw	r2,-32(fp)
  }
  acc += (src->addr & 0xffffUL);
    5f2c:	e0bffc17 	ldw	r2,-16(fp)
    5f30:	10c0000b 	ldhu	r3,0(r2)
    5f34:	1080008b 	ldhu	r2,2(r2)
    5f38:	1004943a 	slli	r2,r2,16
    5f3c:	10c4b03a 	or	r2,r2,r3
    5f40:	10bfffcc 	andi	r2,r2,65535
    5f44:	e0fff817 	ldw	r3,-32(fp)
    5f48:	1885883a 	add	r2,r3,r2
    5f4c:	e0bff815 	stw	r2,-32(fp)
  acc += ((src->addr >> 16) & 0xffffUL);
    5f50:	e0bffc17 	ldw	r2,-16(fp)
    5f54:	10c0000b 	ldhu	r3,0(r2)
    5f58:	1080008b 	ldhu	r2,2(r2)
    5f5c:	1004943a 	slli	r2,r2,16
    5f60:	10c4b03a 	or	r2,r2,r3
    5f64:	1004d43a 	srli	r2,r2,16
    5f68:	e0fff817 	ldw	r3,-32(fp)
    5f6c:	1885883a 	add	r2,r3,r2
    5f70:	e0bff815 	stw	r2,-32(fp)
  acc += (dest->addr & 0xffffUL);
    5f74:	e0bffd17 	ldw	r2,-12(fp)
    5f78:	10c0000b 	ldhu	r3,0(r2)
    5f7c:	1080008b 	ldhu	r2,2(r2)
    5f80:	1004943a 	slli	r2,r2,16
    5f84:	10c4b03a 	or	r2,r2,r3
    5f88:	10bfffcc 	andi	r2,r2,65535
    5f8c:	e0fff817 	ldw	r3,-32(fp)
    5f90:	1885883a 	add	r2,r3,r2
    5f94:	e0bff815 	stw	r2,-32(fp)
  acc += ((dest->addr >> 16) & 0xffffUL);
    5f98:	e0bffd17 	ldw	r2,-12(fp)
    5f9c:	10c0000b 	ldhu	r3,0(r2)
    5fa0:	1080008b 	ldhu	r2,2(r2)
    5fa4:	1004943a 	slli	r2,r2,16
    5fa8:	10c4b03a 	or	r2,r2,r3
    5fac:	1004d43a 	srli	r2,r2,16
    5fb0:	e0fff817 	ldw	r3,-32(fp)
    5fb4:	1885883a 	add	r2,r3,r2
    5fb8:	e0bff815 	stw	r2,-32(fp)
  acc += (u32_t)htons((u16_t)proto);
    5fbc:	e0bffe03 	ldbu	r2,-8(fp)
    5fc0:	1004923a 	slli	r2,r2,8
    5fc4:	e0fff817 	ldw	r3,-32(fp)
    5fc8:	1885883a 	add	r2,r3,r2
    5fcc:	e0bff815 	stw	r2,-32(fp)
  acc += (u32_t)htons(proto_len);
    5fd0:	e0bfff0b 	ldhu	r2,-4(fp)
    5fd4:	1004d23a 	srli	r2,r2,8
    5fd8:	10ffffcc 	andi	r3,r2,65535
    5fdc:	e0bfff0b 	ldhu	r2,-4(fp)
    5fe0:	1004923a 	slli	r2,r2,8
    5fe4:	10bfffcc 	andi	r2,r2,65535
    5fe8:	1884b03a 	or	r2,r3,r2
    5fec:	e0fff817 	ldw	r3,-32(fp)
    5ff0:	1885883a 	add	r2,r3,r2
    5ff4:	e0bff815 	stw	r2,-32(fp)

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
    5ff8:	e0bff817 	ldw	r2,-32(fp)
    5ffc:	1006d43a 	srli	r3,r2,16
    6000:	e0bff817 	ldw	r2,-32(fp)
    6004:	10bfffcc 	andi	r2,r2,65535
    6008:	1885883a 	add	r2,r3,r2
    600c:	e0bff815 	stw	r2,-32(fp)
  acc = FOLD_U32T(acc);
    6010:	e0bff817 	ldw	r2,-32(fp)
    6014:	1006d43a 	srli	r3,r2,16
    6018:	e0bff817 	ldw	r2,-32(fp)
    601c:	10bfffcc 	andi	r2,r2,65535
    6020:	1885883a 	add	r2,r3,r2
    6024:	e0bff815 	stw	r2,-32(fp)
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
    6028:	e0bff817 	ldw	r2,-32(fp)
    602c:	0084303a 	nor	r2,zero,r2
}
    6030:	e037883a 	mov	sp,fp
    6034:	dfc00117 	ldw	ra,4(sp)
    6038:	df000017 	ldw	fp,0(sp)
    603c:	dec00204 	addi	sp,sp,8
    6040:	f800283a 	ret

00006044 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
    6044:	defffc04 	addi	sp,sp,-16
    6048:	dfc00315 	stw	ra,12(sp)
    604c:	df000215 	stw	fp,8(sp)
    6050:	df000204 	addi	fp,sp,8
    6054:	e13ffe15 	stw	r4,-8(fp)
    6058:	2805883a 	mov	r2,r5
    605c:	e0bfff0d 	sth	r2,-4(fp)
  return ~LWIP_CHKSUM(dataptr, len);
    6060:	e0bfff0b 	ldhu	r2,-4(fp)
    6064:	e13ffe17 	ldw	r4,-8(fp)
    6068:	100b883a 	mov	r5,r2
    606c:	0005cf80 	call	5cf8 <lwip_standard_chksum>
    6070:	0084303a 	nor	r2,zero,r2
}
    6074:	e037883a 	mov	sp,fp
    6078:	dfc00117 	ldw	ra,4(sp)
    607c:	df000017 	ldw	fp,0(sp)
    6080:	dec00204 	addi	sp,sp,8
    6084:	f800283a 	ret

00006088 <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
    6088:	defffa04 	addi	sp,sp,-24
    608c:	dfc00515 	stw	ra,20(sp)
    6090:	df000415 	stw	fp,16(sp)
    6094:	df000404 	addi	fp,sp,16
    6098:	e13fff15 	stw	r4,-4(fp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
    609c:	e03ffc15 	stw	zero,-16(fp)
  swapped = 0;
    60a0:	e03ffe05 	stb	zero,-8(fp)
  for(q = p; q != NULL; q = q->next) {
    60a4:	e0bfff17 	ldw	r2,-4(fp)
    60a8:	e0bffd15 	stw	r2,-12(fp)
    60ac:	00002606 	br	6148 <inet_chksum_pbuf+0xc0>
    acc += LWIP_CHKSUM(q->payload, q->len);
    60b0:	e0bffd17 	ldw	r2,-12(fp)
    60b4:	10c00117 	ldw	r3,4(r2)
    60b8:	e0bffd17 	ldw	r2,-12(fp)
    60bc:	1080028b 	ldhu	r2,10(r2)
    60c0:	10bfffcc 	andi	r2,r2,65535
    60c4:	1809883a 	mov	r4,r3
    60c8:	100b883a 	mov	r5,r2
    60cc:	0005cf80 	call	5cf8 <lwip_standard_chksum>
    60d0:	10bfffcc 	andi	r2,r2,65535
    60d4:	e0fffc17 	ldw	r3,-16(fp)
    60d8:	1885883a 	add	r2,r3,r2
    60dc:	e0bffc15 	stw	r2,-16(fp)
    acc = FOLD_U32T(acc);
    60e0:	e0bffc17 	ldw	r2,-16(fp)
    60e4:	1006d43a 	srli	r3,r2,16
    60e8:	e0bffc17 	ldw	r2,-16(fp)
    60ec:	10bfffcc 	andi	r2,r2,65535
    60f0:	1885883a 	add	r2,r3,r2
    60f4:	e0bffc15 	stw	r2,-16(fp)
    if (q->len % 2 != 0) {
    60f8:	e0bffd17 	ldw	r2,-12(fp)
    60fc:	1080028b 	ldhu	r2,10(r2)
    6100:	1080004c 	andi	r2,r2,1
    6104:	10bfffcc 	andi	r2,r2,65535
    6108:	10000c26 	beq	r2,zero,613c <inet_chksum_pbuf+0xb4>
      swapped = 1 - swapped;
    610c:	e0bffe03 	ldbu	r2,-8(fp)
    6110:	00c00044 	movi	r3,1
    6114:	1885c83a 	sub	r2,r3,r2
    6118:	e0bffe05 	stb	r2,-8(fp)
      acc = SWAP_BYTES_IN_WORD(acc);
    611c:	e0bffc17 	ldw	r2,-16(fp)
    6120:	10bfc00c 	andi	r2,r2,65280
    6124:	1006d23a 	srli	r3,r2,8
    6128:	e0bffc17 	ldw	r2,-16(fp)
    612c:	1004923a 	slli	r2,r2,8
    6130:	10bfffcc 	andi	r2,r2,65535
    6134:	1884b03a 	or	r2,r3,r2
    6138:	e0bffc15 	stw	r2,-16(fp)
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
    613c:	e0bffd17 	ldw	r2,-12(fp)
    6140:	10800017 	ldw	r2,0(r2)
    6144:	e0bffd15 	stw	r2,-12(fp)
    6148:	e0bffd17 	ldw	r2,-12(fp)
    614c:	103fd81e 	bne	r2,zero,60b0 <inet_chksum_pbuf+0x28>
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    }
  }

  if (swapped) {
    6150:	e0bffe03 	ldbu	r2,-8(fp)
    6154:	10000826 	beq	r2,zero,6178 <inet_chksum_pbuf+0xf0>
    acc = SWAP_BYTES_IN_WORD(acc);
    6158:	e0bffc17 	ldw	r2,-16(fp)
    615c:	10bfc00c 	andi	r2,r2,65280
    6160:	1006d23a 	srli	r3,r2,8
    6164:	e0bffc17 	ldw	r2,-16(fp)
    6168:	1004923a 	slli	r2,r2,8
    616c:	10bfffcc 	andi	r2,r2,65535
    6170:	1884b03a 	or	r2,r3,r2
    6174:	e0bffc15 	stw	r2,-16(fp)
  }
  return (u16_t)~(acc & 0xffffUL);
    6178:	e0bffc17 	ldw	r2,-16(fp)
    617c:	0084303a 	nor	r2,zero,r2
}
    6180:	e037883a 	mov	sp,fp
    6184:	dfc00117 	ldw	ra,4(sp)
    6188:	df000017 	ldw	fp,0(sp)
    618c:	dec00204 	addi	sp,sp,8
    6190:	f800283a 	ret

00006194 <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(struct ip_addr *dest)
{
    6194:	defffc04 	addi	sp,sp,-16
    6198:	dfc00315 	stw	ra,12(sp)
    619c:	df000215 	stw	fp,8(sp)
    61a0:	df000204 	addi	fp,sp,8
    61a4:	e13fff15 	stw	r4,-4(fp)
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
    61a8:	008000f4 	movhi	r2,3
    61ac:	1095f204 	addi	r2,r2,22472
    61b0:	10800017 	ldw	r2,0(r2)
    61b4:	e0bffe15 	stw	r2,-8(fp)
    61b8:	00001606 	br	6214 <ip_route+0x80>
    /* network mask matches? */
    if (netif_is_up(netif)) {
    61bc:	e13ffe17 	ldw	r4,-8(fp)
    61c0:	000977c0 	call	977c <netif_is_up>
    61c4:	10803fcc 	andi	r2,r2,255
    61c8:	10000f26 	beq	r2,zero,6208 <ip_route+0x74>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
    61cc:	e0bfff17 	ldw	r2,-4(fp)
    61d0:	10c0000b 	ldhu	r3,0(r2)
    61d4:	1080008b 	ldhu	r2,2(r2)
    61d8:	1004943a 	slli	r2,r2,16
    61dc:	10c4b03a 	or	r2,r2,r3
    61e0:	1007883a 	mov	r3,r2
    61e4:	e0bffe17 	ldw	r2,-8(fp)
    61e8:	10800117 	ldw	r2,4(r2)
    61ec:	1886f03a 	xor	r3,r3,r2
    61f0:	e0bffe17 	ldw	r2,-8(fp)
    61f4:	10800217 	ldw	r2,8(r2)
    61f8:	1884703a 	and	r2,r3,r2
    61fc:	1000021e 	bne	r2,zero,6208 <ip_route+0x74>
        /* return netif on which to forward IP packet */
        return netif;
    6200:	e0bffe17 	ldw	r2,-8(fp)
    6204:	00001d06 	br	627c <ip_route+0xe8>
ip_route(struct ip_addr *dest)
{
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
    6208:	e0bffe17 	ldw	r2,-8(fp)
    620c:	10800017 	ldw	r2,0(r2)
    6210:	e0bffe15 	stw	r2,-8(fp)
    6214:	e0bffe17 	ldw	r2,-8(fp)
    6218:	103fe81e 	bne	r2,zero,61bc <ip_route+0x28>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
    621c:	008000f4 	movhi	r2,3
    6220:	1095f304 	addi	r2,r2,22476
    6224:	10800017 	ldw	r2,0(r2)
    6228:	10000726 	beq	r2,zero,6248 <ip_route+0xb4>
    622c:	008000f4 	movhi	r2,3
    6230:	1095f304 	addi	r2,r2,22476
    6234:	10800017 	ldw	r2,0(r2)
    6238:	1009883a 	mov	r4,r2
    623c:	000977c0 	call	977c <netif_is_up>
    6240:	10803fcc 	andi	r2,r2,255
    6244:	10000a1e 	bne	r2,zero,6270 <ip_route+0xdc>
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_route: No route to 0x%"X32_F"\n", dest->addr));
    IP_STATS_INC(ip.rterr);
    6248:	00800134 	movhi	r2,4
    624c:	108d9504 	addi	r2,r2,13908
    6250:	1080158b 	ldhu	r2,86(r2)
    6254:	10800044 	addi	r2,r2,1
    6258:	1007883a 	mov	r3,r2
    625c:	00800134 	movhi	r2,4
    6260:	108d9504 	addi	r2,r2,13908
    6264:	10c0158d 	sth	r3,86(r2)
    snmp_inc_ipoutnoroutes();
    return NULL;
    6268:	0005883a 	mov	r2,zero
    626c:	00000306 	br	627c <ip_route+0xe8>
  }
  /* no matching netif found, use default netif */
  return netif_default;
    6270:	008000f4 	movhi	r2,3
    6274:	1095f304 	addi	r2,r2,22476
    6278:	10800017 	ldw	r2,0(r2)
}
    627c:	e037883a 	mov	sp,fp
    6280:	dfc00117 	ldw	ra,4(sp)
    6284:	df000017 	ldw	fp,0(sp)
    6288:	dec00204 	addi	sp,sp,8
    628c:	f800283a 	ret

00006290 <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
    6290:	defff704 	addi	sp,sp,-36
    6294:	dfc00815 	stw	ra,32(sp)
    6298:	df000715 	stw	fp,28(sp)
    629c:	df000704 	addi	fp,sp,28
    62a0:	e13ffe15 	stw	r4,-8(fp)
    62a4:	e17fff15 	stw	r5,-4(fp)
  struct ip_hdr *iphdr;
  struct netif *netif;
  u16_t iphdr_hlen;
  u16_t iphdr_len;
#if LWIP_DHCP
  int check_ip_src=1;
    62a8:	00800044 	movi	r2,1
    62ac:	e0bffb15 	stw	r2,-20(fp)
#endif /* LWIP_DHCP */

  IP_STATS_INC(ip.recv);
    62b0:	00800134 	movhi	r2,4
    62b4:	108d9504 	addi	r2,r2,13908
    62b8:	1080128b 	ldhu	r2,74(r2)
    62bc:	10800044 	addi	r2,r2,1
    62c0:	1007883a 	mov	r3,r2
    62c4:	00800134 	movhi	r2,4
    62c8:	108d9504 	addi	r2,r2,13908
    62cc:	10c0128d 	sth	r3,74(r2)
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
    62d0:	e0bffe17 	ldw	r2,-8(fp)
    62d4:	10800117 	ldw	r2,4(r2)
    62d8:	e0bff915 	stw	r2,-28(fp)
  if (IPH_V(iphdr) != 4) {
    62dc:	e0bff917 	ldw	r2,-28(fp)
    62e0:	1080000b 	ldhu	r2,0(r2)
    62e4:	10bfffcc 	andi	r2,r2,65535
    62e8:	1004d23a 	srli	r2,r2,8
    62ec:	10ffffcc 	andi	r3,r2,65535
    62f0:	e0bff917 	ldw	r2,-28(fp)
    62f4:	1080000b 	ldhu	r2,0(r2)
    62f8:	10bfffcc 	andi	r2,r2,65535
    62fc:	1004923a 	slli	r2,r2,8
    6300:	10bfffcc 	andi	r2,r2,65535
    6304:	1884b03a 	or	r2,r3,r2
    6308:	1005d33a 	srai	r2,r2,12
    630c:	10800120 	cmpeqi	r2,r2,4
    6310:	1000141e 	bne	r2,zero,6364 <ip_input+0xd4>
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
    6314:	e13ffe17 	ldw	r4,-8(fp)
    6318:	000a16c0 	call	a16c <pbuf_free>
    IP_STATS_INC(ip.err);
    631c:	00800134 	movhi	r2,4
    6320:	108d9504 	addi	r2,r2,13908
    6324:	1080170b 	ldhu	r2,92(r2)
    6328:	10800044 	addi	r2,r2,1
    632c:	1007883a 	mov	r3,r2
    6330:	00800134 	movhi	r2,4
    6334:	108d9504 	addi	r2,r2,13908
    6338:	10c0170d 	sth	r3,92(r2)
    IP_STATS_INC(ip.drop);
    633c:	00800134 	movhi	r2,4
    6340:	108d9504 	addi	r2,r2,13908
    6344:	1080138b 	ldhu	r2,78(r2)
    6348:	10800044 	addi	r2,r2,1
    634c:	1007883a 	mov	r3,r2
    6350:	00800134 	movhi	r2,4
    6354:	108d9504 	addi	r2,r2,13908
    6358:	10c0138d 	sth	r3,78(r2)
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
    635c:	0005883a 	mov	r2,zero
    6360:	00013a06 	br	684c <ip_input+0x5bc>
  }

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
    6364:	e0bff917 	ldw	r2,-28(fp)
    6368:	1080000b 	ldhu	r2,0(r2)
    636c:	10bfffcc 	andi	r2,r2,65535
    6370:	1004d23a 	srli	r2,r2,8
    6374:	10ffffcc 	andi	r3,r2,65535
    6378:	e0bff917 	ldw	r2,-28(fp)
    637c:	1080000b 	ldhu	r2,0(r2)
    6380:	10bfffcc 	andi	r2,r2,65535
    6384:	1004923a 	slli	r2,r2,8
    6388:	10bfffcc 	andi	r2,r2,65535
    638c:	1884b03a 	or	r2,r3,r2
    6390:	1005d23a 	srai	r2,r2,8
    6394:	108003cc 	andi	r2,r2,15
    6398:	e0bffd0d 	sth	r2,-12(fp)
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
    639c:	e0bffd0b 	ldhu	r2,-12(fp)
    63a0:	1085883a 	add	r2,r2,r2
    63a4:	1085883a 	add	r2,r2,r2
    63a8:	e0bffd0d 	sth	r2,-12(fp)
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
    63ac:	e0bff917 	ldw	r2,-28(fp)
    63b0:	1080008b 	ldhu	r2,2(r2)
    63b4:	10bfffcc 	andi	r2,r2,65535
    63b8:	1004d23a 	srli	r2,r2,8
    63bc:	1007883a 	mov	r3,r2
    63c0:	e0bff917 	ldw	r2,-28(fp)
    63c4:	1080008b 	ldhu	r2,2(r2)
    63c8:	10bfffcc 	andi	r2,r2,65535
    63cc:	1004923a 	slli	r2,r2,8
    63d0:	1884b03a 	or	r2,r3,r2
    63d4:	e0bffd8d 	sth	r2,-10(fp)

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
    63d8:	e0bffe17 	ldw	r2,-8(fp)
    63dc:	1080028b 	ldhu	r2,10(r2)
    63e0:	10ffffcc 	andi	r3,r2,65535
    63e4:	e0bffd0b 	ldhu	r2,-12(fp)
    63e8:	18800536 	bltu	r3,r2,6400 <ip_input+0x170>
    63ec:	e0bffe17 	ldw	r2,-8(fp)
    63f0:	1080020b 	ldhu	r2,8(r2)
    63f4:	10ffffcc 	andi	r3,r2,65535
    63f8:	e0bffd8b 	ldhu	r2,-10(fp)
    63fc:	1880142e 	bgeu	r3,r2,6450 <ip_input+0x1c0>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
        ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), IP packet dropped.\n",
        iphdr_len, p->tot_len));
    }
    /* free (drop) packet pbufs */
    pbuf_free(p);
    6400:	e13ffe17 	ldw	r4,-8(fp)
    6404:	000a16c0 	call	a16c <pbuf_free>
    IP_STATS_INC(ip.lenerr);
    6408:	00800134 	movhi	r2,4
    640c:	108d9504 	addi	r2,r2,13908
    6410:	1080148b 	ldhu	r2,82(r2)
    6414:	10800044 	addi	r2,r2,1
    6418:	1007883a 	mov	r3,r2
    641c:	00800134 	movhi	r2,4
    6420:	108d9504 	addi	r2,r2,13908
    6424:	10c0148d 	sth	r3,82(r2)
    IP_STATS_INC(ip.drop);
    6428:	00800134 	movhi	r2,4
    642c:	108d9504 	addi	r2,r2,13908
    6430:	1080138b 	ldhu	r2,78(r2)
    6434:	10800044 	addi	r2,r2,1
    6438:	1007883a 	mov	r3,r2
    643c:	00800134 	movhi	r2,4
    6440:	108d9504 	addi	r2,r2,13908
    6444:	10c0138d 	sth	r3,78(r2)
    snmp_inc_ipindiscards();
    return ERR_OK;
    6448:	0005883a 	mov	r2,zero
    644c:	0000ff06 	br	684c <ip_input+0x5bc>
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
    6450:	e0bffd0b 	ldhu	r2,-12(fp)
    6454:	e13ff917 	ldw	r4,-28(fp)
    6458:	100b883a 	mov	r5,r2
    645c:	00060440 	call	6044 <inet_chksum>
    6460:	10bfffcc 	andi	r2,r2,65535
    6464:	10001426 	beq	r2,zero,64b8 <ip_input+0x228>

    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
      ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
    ip_debug_print(p);
    pbuf_free(p);
    6468:	e13ffe17 	ldw	r4,-8(fp)
    646c:	000a16c0 	call	a16c <pbuf_free>
    IP_STATS_INC(ip.chkerr);
    6470:	00800134 	movhi	r2,4
    6474:	108d9504 	addi	r2,r2,13908
    6478:	1080140b 	ldhu	r2,80(r2)
    647c:	10800044 	addi	r2,r2,1
    6480:	1007883a 	mov	r3,r2
    6484:	00800134 	movhi	r2,4
    6488:	108d9504 	addi	r2,r2,13908
    648c:	10c0140d 	sth	r3,80(r2)
    IP_STATS_INC(ip.drop);
    6490:	00800134 	movhi	r2,4
    6494:	108d9504 	addi	r2,r2,13908
    6498:	1080138b 	ldhu	r2,78(r2)
    649c:	10800044 	addi	r2,r2,1
    64a0:	1007883a 	mov	r3,r2
    64a4:	00800134 	movhi	r2,4
    64a8:	108d9504 	addi	r2,r2,13908
    64ac:	10c0138d 	sth	r3,78(r2)
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
    64b0:	0005883a 	mov	r2,zero
    64b4:	0000e506 	br	684c <ip_input+0x5bc>
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
    64b8:	e0bffd8b 	ldhu	r2,-10(fp)
    64bc:	e13ffe17 	ldw	r4,-8(fp)
    64c0:	100b883a 	mov	r5,r2
    64c4:	0009cf00 	call	9cf0 <pbuf_realloc>
#endif /* LWIP_IGMP */
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
    64c8:	00800044 	movi	r2,1
    64cc:	e0bffc15 	stw	r2,-16(fp)
    netif = inp;
    64d0:	e0bfff17 	ldw	r2,-4(fp)
    64d4:	e0bffa15 	stw	r2,-24(fp)
          iphdr->dest.addr & netif->netmask.addr,
          netif->ip_addr.addr & netif->netmask.addr,
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
    64d8:	e13ffa17 	ldw	r4,-24(fp)
    64dc:	000977c0 	call	977c <netif_is_up>
    64e0:	10803fcc 	andi	r2,r2,255
    64e4:	10001626 	beq	r2,zero,6540 <ip_input+0x2b0>
    64e8:	e0bffa17 	ldw	r2,-24(fp)
    64ec:	10800104 	addi	r2,r2,4
    64f0:	10001326 	beq	r2,zero,6540 <ip_input+0x2b0>
    64f4:	e0bffa17 	ldw	r2,-24(fp)
    64f8:	10800117 	ldw	r2,4(r2)
    64fc:	10001026 	beq	r2,zero,6540 <ip_input+0x2b0>
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
    6500:	e0bff917 	ldw	r2,-28(fp)
    6504:	10c0040b 	ldhu	r3,16(r2)
    6508:	1080048b 	ldhu	r2,18(r2)
    650c:	1004943a 	slli	r2,r2,16
    6510:	10c4b03a 	or	r2,r2,r3
    6514:	1007883a 	mov	r3,r2
    6518:	e0bffa17 	ldw	r2,-24(fp)
    651c:	10800117 	ldw	r2,4(r2)
    6520:	18801b26 	beq	r3,r2,6590 <ip_input+0x300>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
    6524:	e0bff917 	ldw	r2,-28(fp)
    6528:	10800404 	addi	r2,r2,16
    652c:	1009883a 	mov	r4,r2
    6530:	e17ffa17 	ldw	r5,-24(fp)
    6534:	0006db00 	call	6db0 <ip_addr_isbroadcast>
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
    6538:	10803fcc 	andi	r2,r2,255
    653c:	1000141e 	bne	r2,zero,6590 <ip_input+0x300>
              netif->name[0], netif->name[1]));
          /* break out of for loop */
          break;
        }
      }
      if (first) {
    6540:	e0bffc17 	ldw	r2,-16(fp)
    6544:	10000626 	beq	r2,zero,6560 <ip_input+0x2d0>
        first = 0;
    6548:	e03ffc15 	stw	zero,-16(fp)
        netif = netif_list;
    654c:	008000f4 	movhi	r2,3
    6550:	1095f204 	addi	r2,r2,22472
    6554:	10800017 	ldw	r2,0(r2)
    6558:	e0bffa15 	stw	r2,-24(fp)
    655c:	00000306 	br	656c <ip_input+0x2dc>
      } else {
        netif = netif->next;
    6560:	e0bffa17 	ldw	r2,-24(fp)
    6564:	10800017 	ldw	r2,0(r2)
    6568:	e0bffa15 	stw	r2,-24(fp)
      }
      if (netif == inp) {
    656c:	e0fffa17 	ldw	r3,-24(fp)
    6570:	e0bfff17 	ldw	r2,-4(fp)
    6574:	1880031e 	bne	r3,r2,6584 <ip_input+0x2f4>
        netif = netif->next;
    6578:	e0bffa17 	ldw	r2,-24(fp)
    657c:	10800017 	ldw	r2,0(r2)
    6580:	e0bffa15 	stw	r2,-24(fp)
      }
    } while(netif != NULL);
    6584:	e0bffa17 	ldw	r2,-24(fp)
    6588:	103fd31e 	bne	r2,zero,64d8 <ip_input+0x248>
    658c:	00000106 	br	6594 <ip_input+0x304>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
          LWIP_DEBUGF(IP_DEBUG, ("ip_input: packet accepted on interface %c%c\n",
              netif->name[0], netif->name[1]));
          /* break out of for loop */
          break;
    6590:	0001883a 	nop
#if LWIP_DHCP
  /* Pass DHCP messages regardless of destination address. DHCP traffic is addressed
   * using link layer addressing (such as Ethernet MAC) so we must not filter on IP.
   * According to RFC 1542 section 3.1.1, referred by RFC 2131).
   */
  if (netif == NULL) {
    6594:	e0bffa17 	ldw	r2,-24(fp)
    6598:	1000221e 	bne	r2,zero,6624 <ip_input+0x394>
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
    659c:	e0bff917 	ldw	r2,-28(fp)
    65a0:	1080020b 	ldhu	r2,8(r2)
    65a4:	10bfffcc 	andi	r2,r2,65535
    65a8:	1004d23a 	srli	r2,r2,8
    65ac:	10ffffcc 	andi	r3,r2,65535
    65b0:	e0bff917 	ldw	r2,-28(fp)
    65b4:	1080020b 	ldhu	r2,8(r2)
    65b8:	10bfffcc 	andi	r2,r2,65535
    65bc:	1004923a 	slli	r2,r2,8
    65c0:	10bfffcc 	andi	r2,r2,65535
    65c4:	1884b03a 	or	r2,r3,r2
    65c8:	10803fcc 	andi	r2,r2,255
    65cc:	10800458 	cmpnei	r2,r2,17
    65d0:	1000141e 	bne	r2,zero,6624 <ip_input+0x394>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest)));
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
    65d4:	e0bffd0b 	ldhu	r2,-12(fp)
    65d8:	e0fff917 	ldw	r3,-28(fp)
    65dc:	1885883a 	add	r2,r3,r2
    65e0:	1080008b 	ldhu	r2,2(r2)
    65e4:	10bfffcc 	andi	r2,r2,65535
    65e8:	1004d23a 	srli	r2,r2,8
    65ec:	10ffffcc 	andi	r3,r2,65535
    65f0:	e0bffd0b 	ldhu	r2,-12(fp)
    65f4:	e13ff917 	ldw	r4,-28(fp)
    65f8:	2085883a 	add	r2,r4,r2
    65fc:	1080008b 	ldhu	r2,2(r2)
    6600:	10bfffcc 	andi	r2,r2,65535
    6604:	1004923a 	slli	r2,r2,8
    6608:	10bfffcc 	andi	r2,r2,65535
    660c:	1884b03a 	or	r2,r3,r2
    6610:	10801118 	cmpnei	r2,r2,68
    6614:	1000031e 	bne	r2,zero,6624 <ip_input+0x394>
        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip_input: DHCP packet accepted.\n"));
        netif = inp;
    6618:	e0bfff17 	ldw	r2,-4(fp)
    661c:	e0bffa15 	stw	r2,-24(fp)
        check_ip_src = 0;
    6620:	e03ffb15 	stw	zero,-20(fp)
#endif /* LWIP_DHCP */

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  /* DHCP servers need 0.0.0.0 to be allowed as source address (RFC 1.1.2.2: 3.2.1.3/a) */
  if (check_ip_src && (iphdr->src.addr != 0))
    6624:	e0bffb17 	ldw	r2,-20(fp)
    6628:	10002126 	beq	r2,zero,66b0 <ip_input+0x420>
    662c:	e0bff917 	ldw	r2,-28(fp)
    6630:	10c0030b 	ldhu	r3,12(r2)
    6634:	1080038b 	ldhu	r2,14(r2)
    6638:	1004943a 	slli	r2,r2,16
    663c:	10c4b03a 	or	r2,r2,r3
    6640:	10001b26 	beq	r2,zero,66b0 <ip_input+0x420>
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
    6644:	e0bff917 	ldw	r2,-28(fp)
    6648:	10800304 	addi	r2,r2,12
    664c:	1009883a 	mov	r4,r2
    6650:	e17fff17 	ldw	r5,-4(fp)
    6654:	0006db00 	call	6db0 <ip_addr_isbroadcast>
    6658:	10803fcc 	andi	r2,r2,255
    665c:	1000081e 	bne	r2,zero,6680 <ip_input+0x3f0>
         (ip_addr_ismulticast(&(iphdr->src)))) {
    6660:	e0bff917 	ldw	r2,-28(fp)
    6664:	10c0030b 	ldhu	r3,12(r2)
    6668:	1080038b 	ldhu	r2,14(r2)
    666c:	1004943a 	slli	r2,r2,16
    6670:	10c4b03a 	or	r2,r2,r3
    6674:	10803c0c 	andi	r2,r2,240
  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  /* DHCP servers need 0.0.0.0 to be allowed as source address (RFC 1.1.2.2: 3.2.1.3/a) */
  if (check_ip_src && (iphdr->src.addr != 0))
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
    6678:	10803818 	cmpnei	r2,r2,224
    667c:	10000c1e 	bne	r2,zero,66b0 <ip_input+0x420>
         (ip_addr_ismulticast(&(iphdr->src)))) {
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("ip_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
    6680:	e13ffe17 	ldw	r4,-8(fp)
    6684:	000a16c0 	call	a16c <pbuf_free>
      IP_STATS_INC(ip.drop);
    6688:	00800134 	movhi	r2,4
    668c:	108d9504 	addi	r2,r2,13908
    6690:	1080138b 	ldhu	r2,78(r2)
    6694:	10800044 	addi	r2,r2,1
    6698:	1007883a 	mov	r3,r2
    669c:	00800134 	movhi	r2,4
    66a0:	108d9504 	addi	r2,r2,13908
    66a4:	10c0138d 	sth	r3,78(r2)
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
      return ERR_OK;
    66a8:	0005883a 	mov	r2,zero
    66ac:	00006706 	br	684c <ip_input+0x5bc>
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
    66b0:	e0bffa17 	ldw	r2,-24(fp)
    66b4:	1000041e 	bne	r2,zero,66c8 <ip_input+0x438>
#endif /* IP_FORWARD */
    {
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
    }
    pbuf_free(p);
    66b8:	e13ffe17 	ldw	r4,-8(fp)
    66bc:	000a16c0 	call	a16c <pbuf_free>
    return ERR_OK;
    66c0:	0005883a 	mov	r2,zero
    66c4:	00006106 	br	684c <ip_input+0x5bc>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
    66c8:	e0bff917 	ldw	r2,-28(fp)
    66cc:	1080018b 	ldhu	r2,6(r2)
    66d0:	10bfffcc 	andi	r2,r2,65535
    66d4:	10bfcfcc 	andi	r2,r2,65343
    66d8:	10000a26 	beq	r2,zero,6704 <ip_input+0x474>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & htons(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    /* reassemble the packet*/
    p = ip_reass(p);
    66dc:	e13ffe17 	ldw	r4,-8(fp)
    66e0:	00079680 	call	7968 <ip_reass>
    66e4:	e0bffe15 	stw	r2,-8(fp)
    /* packet not fully reassembled yet? */
    if (p == NULL) {
    66e8:	e0bffe17 	ldw	r2,-8(fp)
    66ec:	1000021e 	bne	r2,zero,66f8 <ip_input+0x468>
      return ERR_OK;
    66f0:	0005883a 	mov	r2,zero
    66f4:	00005506 	br	684c <ip_input+0x5bc>
    }
    iphdr = p->payload;
    66f8:	e0bffe17 	ldw	r2,-8(fp)
    66fc:	10800117 	ldw	r2,4(r2)
    6700:	e0bff915 	stw	r2,-28(fp)
  /* send to upper layers */
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: \n"));
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

  current_netif = inp;
    6704:	e0bfff17 	ldw	r2,-4(fp)
    6708:	d0a8c915 	stw	r2,-23772(gp)
  current_header = iphdr;
    670c:	e0bff917 	ldw	r2,-28(fp)
    6710:	d0a8ca15 	stw	r2,-23768(gp)

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
    6714:	e13ffe17 	ldw	r4,-8(fp)
    6718:	e17fff17 	ldw	r5,-4(fp)
    671c:	000ad400 	call	ad40 <raw_input>
    6720:	10803fcc 	andi	r2,r2,255
    6724:	1000461e 	bne	r2,zero,6840 <ip_input+0x5b0>
#endif /* LWIP_RAW */
  {

    switch (IPH_PROTO(iphdr)) {
    6728:	e0bff917 	ldw	r2,-28(fp)
    672c:	1080020b 	ldhu	r2,8(r2)
    6730:	10bfffcc 	andi	r2,r2,65535
    6734:	1004d23a 	srli	r2,r2,8
    6738:	10ffffcc 	andi	r3,r2,65535
    673c:	e0bff917 	ldw	r2,-28(fp)
    6740:	1080020b 	ldhu	r2,8(r2)
    6744:	10bfffcc 	andi	r2,r2,65535
    6748:	1004923a 	slli	r2,r2,8
    674c:	10bfffcc 	andi	r2,r2,65535
    6750:	1884b03a 	or	r2,r3,r2
    6754:	10803fcc 	andi	r2,r2,255
    6758:	10c001a0 	cmpeqi	r3,r2,6
    675c:	1800091e 	bne	r3,zero,6784 <ip_input+0x4f4>
    6760:	10c00460 	cmpeqi	r3,r2,17
    6764:	1800031e 	bne	r3,zero,6774 <ip_input+0x4e4>
    6768:	10800060 	cmpeqi	r2,r2,1
    676c:	1000091e 	bne	r2,zero,6794 <ip_input+0x504>
    6770:	00000c06 	br	67a4 <ip_input+0x514>
    case IP_PROTO_UDP:
#if LWIP_UDPLITE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      snmp_inc_ipindelivers();
      udp_input(p, inp);
    6774:	e13ffe17 	ldw	r4,-8(fp)
    6778:	e17fff17 	ldw	r5,-4(fp)
    677c:	00138680 	call	13868 <udp_input>
      break;
    6780:	00002f06 	br	6840 <ip_input+0x5b0>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case IP_PROTO_TCP:
      snmp_inc_ipindelivers();
      tcp_input(p, inp);
    6784:	e13ffe17 	ldw	r4,-8(fp)
    6788:	e17fff17 	ldw	r5,-4(fp)
    678c:	000d3100 	call	d310 <tcp_input>
      break;
    6790:	00002b06 	br	6840 <ip_input+0x5b0>
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      snmp_inc_ipindelivers();
      icmp_input(p, inp);
    6794:	e13ffe17 	ldw	r4,-8(fp)
    6798:	e17fff17 	ldw	r5,-4(fp)
    679c:	0004dd40 	call	4dd4 <icmp_input>
      break;
    67a0:	00002706 	br	6840 <ip_input+0x5b0>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
    67a4:	e0bff917 	ldw	r2,-28(fp)
    67a8:	10800404 	addi	r2,r2,16
    67ac:	1009883a 	mov	r4,r2
    67b0:	e17fff17 	ldw	r5,-4(fp)
    67b4:	0006db00 	call	6db0 <ip_addr_isbroadcast>
    67b8:	10803fcc 	andi	r2,r2,255
    67bc:	10000e1e 	bne	r2,zero,67f8 <ip_input+0x568>
          !ip_addr_ismulticast(&(iphdr->dest))) {
    67c0:	e0bff917 	ldw	r2,-28(fp)
    67c4:	10c0040b 	ldhu	r3,16(r2)
    67c8:	1080048b 	ldhu	r2,18(r2)
    67cc:	1004943a 	slli	r2,r2,16
    67d0:	10c4b03a 	or	r2,r2,r3
    67d4:	10803c0c 	andi	r2,r2,240
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
    67d8:	10803820 	cmpeqi	r2,r2,224
    67dc:	1000061e 	bne	r2,zero,67f8 <ip_input+0x568>
          !ip_addr_ismulticast(&(iphdr->dest))) {
        p->payload = iphdr;
    67e0:	e0bffe17 	ldw	r2,-8(fp)
    67e4:	e0fff917 	ldw	r3,-28(fp)
    67e8:	10c00115 	stw	r3,4(r2)
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
    67ec:	e13ffe17 	ldw	r4,-8(fp)
    67f0:	01400084 	movi	r5,2
    67f4:	000546c0 	call	546c <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      pbuf_free(p);
    67f8:	e13ffe17 	ldw	r4,-8(fp)
    67fc:	000a16c0 	call	a16c <pbuf_free>

      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("Unsupported transport protocol %"U16_F"\n", IPH_PROTO(iphdr)));

      IP_STATS_INC(ip.proterr);
    6800:	00800134 	movhi	r2,4
    6804:	108d9504 	addi	r2,r2,13908
    6808:	1080160b 	ldhu	r2,88(r2)
    680c:	10800044 	addi	r2,r2,1
    6810:	1007883a 	mov	r3,r2
    6814:	00800134 	movhi	r2,4
    6818:	108d9504 	addi	r2,r2,13908
    681c:	10c0160d 	sth	r3,88(r2)
      IP_STATS_INC(ip.drop);
    6820:	00800134 	movhi	r2,4
    6824:	108d9504 	addi	r2,r2,13908
    6828:	1080138b 	ldhu	r2,78(r2)
    682c:	10800044 	addi	r2,r2,1
    6830:	1007883a 	mov	r3,r2
    6834:	00800134 	movhi	r2,4
    6838:	108d9504 	addi	r2,r2,13908
    683c:	10c0138d 	sth	r3,78(r2)
      snmp_inc_ipinunknownprotos();
    }
  }

  current_netif = NULL;
    6840:	d028c915 	stw	zero,-23772(gp)
  current_header = NULL;
    6844:	d028ca15 	stw	zero,-23768(gp)

  return ERR_OK;
    6848:	0005883a 	mov	r2,zero
}
    684c:	e037883a 	mov	sp,fp
    6850:	dfc00117 	ldw	ra,4(sp)
    6854:	df000017 	ldw	fp,0(sp)
    6858:	dec00204 	addi	sp,sp,8
    685c:	f800283a 	ret

00006860 <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
    6860:	defff604 	addi	sp,sp,-40
    6864:	dfc00915 	stw	ra,36(sp)
    6868:	df000815 	stw	fp,32(sp)
    686c:	df000804 	addi	fp,sp,32
    6870:	e13ffa15 	stw	r4,-24(fp)
    6874:	e17ffb15 	stw	r5,-20(fp)
    6878:	e1bffc15 	stw	r6,-16(fp)
    687c:	3805883a 	mov	r2,r7
    6880:	e1000217 	ldw	r4,8(fp)
    6884:	e0c00317 	ldw	r3,12(fp)
    6888:	e0bffd05 	stb	r2,-12(fp)
    688c:	e13ffe05 	stb	r4,-8(fp)
    6890:	e0ffff05 	stb	r3,-4(fp)
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
    6894:	e0bffc17 	ldw	r2,-16(fp)
    6898:	1000ef26 	beq	r2,zero,6c58 <ip_output_if+0x3f8>
    u16_t ip_hlen = IP_HLEN;
    689c:	00800504 	movi	r2,20
    68a0:	e0bff80d 	sth	r2,-32(fp)
        memset(((char*)p->payload) + optlen, 0, optlen_aligned - optlen);
      }
    }
#endif /* IP_OPTIONS_SEND */
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
    68a4:	e13ffa17 	ldw	r4,-24(fp)
    68a8:	01400504 	movi	r5,20
    68ac:	0009f740 	call	9f74 <pbuf_header>
    68b0:	10803fcc 	andi	r2,r2,255
    68b4:	10000a26 	beq	r2,zero,68e0 <ip_output_if+0x80>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
    68b8:	00800134 	movhi	r2,4
    68bc:	108d9504 	addi	r2,r2,13908
    68c0:	1080170b 	ldhu	r2,92(r2)
    68c4:	10800044 	addi	r2,r2,1
    68c8:	1007883a 	mov	r3,r2
    68cc:	00800134 	movhi	r2,4
    68d0:	108d9504 	addi	r2,r2,13908
    68d4:	10c0170d 	sth	r3,92(r2)
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    68d8:	00bfff84 	movi	r2,-2
    68dc:	00010206 	br	6ce8 <ip_output_if+0x488>
    }

    iphdr = p->payload;
    68e0:	e0bffa17 	ldw	r2,-24(fp)
    68e4:	10800117 	ldw	r2,4(r2)
    68e8:	e0bff915 	stw	r2,-28(fp)
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
    68ec:	e0bffa17 	ldw	r2,-24(fp)
    68f0:	1080028b 	ldhu	r2,10(r2)
    68f4:	10bfffcc 	andi	r2,r2,65535
    68f8:	10800528 	cmpgeui	r2,r2,20
    68fc:	1000091e 	bne	r2,zero,6924 <ip_output_if+0xc4>
    6900:	010000f4 	movhi	r4,3
    6904:	2136e304 	addi	r4,r4,-9332
    6908:	014000f4 	movhi	r5,3
    690c:	2976ed04 	addi	r5,r5,-9292
    6910:	01808a84 	movi	r6,554
    6914:	01c000f4 	movhi	r7,3
    6918:	39f6f904 	addi	r7,r7,-9244
    691c:	00166c00 	call	166c0 <printf>
    6920:	003fff06 	br	6920 <ip_output_if+0xc0>
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
    6924:	e0bff917 	ldw	r2,-28(fp)
    6928:	1080020b 	ldhu	r2,8(r2)
    692c:	10bfffcc 	andi	r2,r2,65535
    6930:	1004d23a 	srli	r2,r2,8
    6934:	10ffffcc 	andi	r3,r2,65535
    6938:	e0bff917 	ldw	r2,-28(fp)
    693c:	1080020b 	ldhu	r2,8(r2)
    6940:	10bfffcc 	andi	r2,r2,65535
    6944:	1004923a 	slli	r2,r2,8
    6948:	10bfffcc 	andi	r2,r2,65535
    694c:	1884b03a 	or	r2,r3,r2
    6950:	10c03fcc 	andi	r3,r2,255
    6954:	e0bffd03 	ldbu	r2,-12(fp)
    6958:	1004923a 	slli	r2,r2,8
    695c:	1884b03a 	or	r2,r3,r2
    6960:	10bfc00c 	andi	r2,r2,65280
    6964:	1005d23a 	srai	r2,r2,8
    6968:	1007883a 	mov	r3,r2
    696c:	e0bff917 	ldw	r2,-28(fp)
    6970:	1080020b 	ldhu	r2,8(r2)
    6974:	10bfffcc 	andi	r2,r2,65535
    6978:	1004d23a 	srli	r2,r2,8
    697c:	113fffcc 	andi	r4,r2,65535
    6980:	e0bff917 	ldw	r2,-28(fp)
    6984:	1080020b 	ldhu	r2,8(r2)
    6988:	10bfffcc 	andi	r2,r2,65535
    698c:	1004923a 	slli	r2,r2,8
    6990:	10bfffcc 	andi	r2,r2,65535
    6994:	2084b03a 	or	r2,r4,r2
    6998:	11003fcc 	andi	r4,r2,255
    699c:	e0bffd03 	ldbu	r2,-12(fp)
    69a0:	1004923a 	slli	r2,r2,8
    69a4:	2084b03a 	or	r2,r4,r2
    69a8:	1004923a 	slli	r2,r2,8
    69ac:	1884b03a 	or	r2,r3,r2
    69b0:	1007883a 	mov	r3,r2
    69b4:	e0bff917 	ldw	r2,-28(fp)
    69b8:	10c0020d 	sth	r3,8(r2)
    IPH_PROTO_SET(iphdr, proto);
    69bc:	e0ffff03 	ldbu	r3,-4(fp)
    69c0:	e0bff917 	ldw	r2,-28(fp)
    69c4:	1080020b 	ldhu	r2,8(r2)
    69c8:	10bfffcc 	andi	r2,r2,65535
    69cc:	1004d23a 	srli	r2,r2,8
    69d0:	113fffcc 	andi	r4,r2,65535
    69d4:	e0bff917 	ldw	r2,-28(fp)
    69d8:	1080020b 	ldhu	r2,8(r2)
    69dc:	10bfffcc 	andi	r2,r2,65535
    69e0:	1004923a 	slli	r2,r2,8
    69e4:	10bfffcc 	andi	r2,r2,65535
    69e8:	2088b03a 	or	r4,r4,r2
    69ec:	00bfc004 	movi	r2,-256
    69f0:	2084703a 	and	r2,r4,r2
    69f4:	1884b03a 	or	r2,r3,r2
    69f8:	10bfc00c 	andi	r2,r2,65280
    69fc:	1005d23a 	srai	r2,r2,8
    6a00:	1007883a 	mov	r3,r2
    6a04:	e13fff03 	ldbu	r4,-4(fp)
    6a08:	e0bff917 	ldw	r2,-28(fp)
    6a0c:	1080020b 	ldhu	r2,8(r2)
    6a10:	10bfffcc 	andi	r2,r2,65535
    6a14:	1004d23a 	srli	r2,r2,8
    6a18:	117fffcc 	andi	r5,r2,65535
    6a1c:	e0bff917 	ldw	r2,-28(fp)
    6a20:	1080020b 	ldhu	r2,8(r2)
    6a24:	10bfffcc 	andi	r2,r2,65535
    6a28:	1004923a 	slli	r2,r2,8
    6a2c:	10bfffcc 	andi	r2,r2,65535
    6a30:	288ab03a 	or	r5,r5,r2
    6a34:	00bfc004 	movi	r2,-256
    6a38:	2884703a 	and	r2,r5,r2
    6a3c:	2084b03a 	or	r2,r4,r2
    6a40:	1004923a 	slli	r2,r2,8
    6a44:	1884b03a 	or	r2,r3,r2
    6a48:	1007883a 	mov	r3,r2
    6a4c:	e0bff917 	ldw	r2,-28(fp)
    6a50:	10c0020d 	sth	r3,8(r2)

    ip_addr_set(&(iphdr->dest), dest);
    6a54:	e0bffc17 	ldw	r2,-16(fp)
    6a58:	10000726 	beq	r2,zero,6a78 <ip_output_if+0x218>
    6a5c:	e0bffc17 	ldw	r2,-16(fp)
    6a60:	10c0000b 	ldhu	r3,0(r2)
    6a64:	1080008b 	ldhu	r2,2(r2)
    6a68:	1004943a 	slli	r2,r2,16
    6a6c:	10c4b03a 	or	r2,r2,r3
    6a70:	1007883a 	mov	r3,r2
    6a74:	00000106 	br	6a7c <ip_output_if+0x21c>
    6a78:	0007883a 	mov	r3,zero
    6a7c:	e0bff917 	ldw	r2,-28(fp)
    6a80:	193fffcc 	andi	r4,r3,65535
    6a84:	1140040b 	ldhu	r5,16(r2)
    6a88:	280a703a 	and	r5,r5,zero
    6a8c:	2908b03a 	or	r4,r5,r4
    6a90:	1100040d 	sth	r4,16(r2)
    6a94:	1806d43a 	srli	r3,r3,16
    6a98:	1100048b 	ldhu	r4,18(r2)
    6a9c:	2008703a 	and	r4,r4,zero
    6aa0:	20c6b03a 	or	r3,r4,r3
    6aa4:	10c0048d 	sth	r3,18(r2)

    IPH_VHLTOS_SET(iphdr, 4, ip_hlen / 4, tos);
    6aa8:	e0bff80b 	ldhu	r2,-32(fp)
    6aac:	1004d0ba 	srli	r2,r2,2
    6ab0:	10bfffcc 	andi	r2,r2,65535
    6ab4:	1004923a 	slli	r2,r2,8
    6ab8:	10d00014 	ori	r3,r2,16384
    6abc:	e0bffe03 	ldbu	r2,-8(fp)
    6ac0:	1884b03a 	or	r2,r3,r2
    6ac4:	10bfc00c 	andi	r2,r2,65280
    6ac8:	1005d23a 	srai	r2,r2,8
    6acc:	1007883a 	mov	r3,r2
    6ad0:	e0bff80b 	ldhu	r2,-32(fp)
    6ad4:	1004d0ba 	srli	r2,r2,2
    6ad8:	10bfffcc 	andi	r2,r2,65535
    6adc:	1004923a 	slli	r2,r2,8
    6ae0:	11100014 	ori	r4,r2,16384
    6ae4:	e0bffe03 	ldbu	r2,-8(fp)
    6ae8:	2084b03a 	or	r2,r4,r2
    6aec:	1004923a 	slli	r2,r2,8
    6af0:	1884b03a 	or	r2,r3,r2
    6af4:	1007883a 	mov	r3,r2
    6af8:	e0bff917 	ldw	r2,-28(fp)
    6afc:	10c0000d 	sth	r3,0(r2)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
    6b00:	e0bffa17 	ldw	r2,-24(fp)
    6b04:	1080020b 	ldhu	r2,8(r2)
    6b08:	10bfffcc 	andi	r2,r2,65535
    6b0c:	1004d23a 	srli	r2,r2,8
    6b10:	1007883a 	mov	r3,r2
    6b14:	e0bffa17 	ldw	r2,-24(fp)
    6b18:	1080020b 	ldhu	r2,8(r2)
    6b1c:	10bfffcc 	andi	r2,r2,65535
    6b20:	1004923a 	slli	r2,r2,8
    6b24:	1884b03a 	or	r2,r3,r2
    6b28:	1007883a 	mov	r3,r2
    6b2c:	e0bff917 	ldw	r2,-28(fp)
    6b30:	10c0008d 	sth	r3,2(r2)
    IPH_OFFSET_SET(iphdr, 0);
    6b34:	e0bff917 	ldw	r2,-28(fp)
    6b38:	1000018d 	sth	zero,6(r2)
    IPH_ID_SET(iphdr, htons(ip_id));
    6b3c:	d0a8c80b 	ldhu	r2,-23776(gp)
    6b40:	10bfffcc 	andi	r2,r2,65535
    6b44:	1004d23a 	srli	r2,r2,8
    6b48:	1007883a 	mov	r3,r2
    6b4c:	d0a8c80b 	ldhu	r2,-23776(gp)
    6b50:	10bfffcc 	andi	r2,r2,65535
    6b54:	1004923a 	slli	r2,r2,8
    6b58:	1884b03a 	or	r2,r3,r2
    6b5c:	1007883a 	mov	r3,r2
    6b60:	e0bff917 	ldw	r2,-28(fp)
    6b64:	10c0010d 	sth	r3,4(r2)
    ++ip_id;
    6b68:	d0a8c80b 	ldhu	r2,-23776(gp)
    6b6c:	10800044 	addi	r2,r2,1
    6b70:	d0a8c80d 	sth	r2,-23776(gp)

    if (ip_addr_isany(src)) {
    6b74:	e0bffb17 	ldw	r2,-20(fp)
    6b78:	10000626 	beq	r2,zero,6b94 <ip_output_if+0x334>
    6b7c:	e0bffb17 	ldw	r2,-20(fp)
    6b80:	10c0000b 	ldhu	r3,0(r2)
    6b84:	1080008b 	ldhu	r2,2(r2)
    6b88:	1004943a 	slli	r2,r2,16
    6b8c:	10c4b03a 	or	r2,r2,r3
    6b90:	1000131e 	bne	r2,zero,6be0 <ip_output_if+0x380>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
    6b94:	e0800417 	ldw	r2,16(fp)
    6b98:	10800104 	addi	r2,r2,4
    6b9c:	10000326 	beq	r2,zero,6bac <ip_output_if+0x34c>
    6ba0:	e0800417 	ldw	r2,16(fp)
    6ba4:	10c00117 	ldw	r3,4(r2)
    6ba8:	00000106 	br	6bb0 <ip_output_if+0x350>
    6bac:	0007883a 	mov	r3,zero
    6bb0:	e0bff917 	ldw	r2,-28(fp)
    6bb4:	193fffcc 	andi	r4,r3,65535
    6bb8:	1140030b 	ldhu	r5,12(r2)
    6bbc:	280a703a 	and	r5,r5,zero
    6bc0:	2908b03a 	or	r4,r5,r4
    6bc4:	1100030d 	sth	r4,12(r2)
    6bc8:	1806d43a 	srli	r3,r3,16
    6bcc:	1100038b 	ldhu	r4,14(r2)
    6bd0:	2008703a 	and	r4,r4,zero
    6bd4:	20c6b03a 	or	r3,r4,r3
    6bd8:	10c0038d 	sth	r3,14(r2)
    6bdc:	00001506 	br	6c34 <ip_output_if+0x3d4>
    } else {
      ip_addr_set(&(iphdr->src), src);
    6be0:	e0bffb17 	ldw	r2,-20(fp)
    6be4:	10000726 	beq	r2,zero,6c04 <ip_output_if+0x3a4>
    6be8:	e0bffb17 	ldw	r2,-20(fp)
    6bec:	10c0000b 	ldhu	r3,0(r2)
    6bf0:	1080008b 	ldhu	r2,2(r2)
    6bf4:	1004943a 	slli	r2,r2,16
    6bf8:	10c4b03a 	or	r2,r2,r3
    6bfc:	1007883a 	mov	r3,r2
    6c00:	00000106 	br	6c08 <ip_output_if+0x3a8>
    6c04:	0007883a 	mov	r3,zero
    6c08:	e0bff917 	ldw	r2,-28(fp)
    6c0c:	193fffcc 	andi	r4,r3,65535
    6c10:	1140030b 	ldhu	r5,12(r2)
    6c14:	280a703a 	and	r5,r5,zero
    6c18:	2908b03a 	or	r4,r5,r4
    6c1c:	1100030d 	sth	r4,12(r2)
    6c20:	1806d43a 	srli	r3,r3,16
    6c24:	1100038b 	ldhu	r4,14(r2)
    6c28:	2008703a 	and	r4,r4,zero
    6c2c:	20c6b03a 	or	r3,r4,r3
    6c30:	10c0038d 	sth	r3,14(r2)
    }

    IPH_CHKSUM_SET(iphdr, 0);
    6c34:	e0bff917 	ldw	r2,-28(fp)
    6c38:	1000028d 	sth	zero,10(r2)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, ip_hlen));
    6c3c:	e0bff80b 	ldhu	r2,-32(fp)
    6c40:	e13ff917 	ldw	r4,-28(fp)
    6c44:	100b883a 	mov	r5,r2
    6c48:	00060440 	call	6044 <inet_chksum>
    6c4c:	e0fff917 	ldw	r3,-28(fp)
    6c50:	1880028d 	sth	r2,10(r3)
    6c54:	00000606 	br	6c70 <ip_output_if+0x410>
#endif
  } else {
    /* IP header already included in p */
    iphdr = p->payload;
    6c58:	e0bffa17 	ldw	r2,-24(fp)
    6c5c:	10800117 	ldw	r2,4(r2)
    6c60:	e0bff915 	stw	r2,-28(fp)
    dest = &(iphdr->dest);
    6c64:	e0bff917 	ldw	r2,-28(fp)
    6c68:	10800404 	addi	r2,r2,16
    6c6c:	e0bffc15 	stw	r2,-16(fp)
  }

  IP_STATS_INC(ip.xmit);
    6c70:	00800134 	movhi	r2,4
    6c74:	108d9504 	addi	r2,r2,13908
    6c78:	1080120b 	ldhu	r2,72(r2)
    6c7c:	10800044 	addi	r2,r2,1
    6c80:	1007883a 	mov	r3,r2
    6c84:	00800134 	movhi	r2,4
    6c88:	108d9504 	addi	r2,r2,13908
    6c8c:	10c0120d 	sth	r3,72(r2)
    return netif_loop_output(netif, p, dest);
  }
#endif /* ENABLE_LOOPBACK */
#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu)) {
    6c90:	e0800417 	ldw	r2,16(fp)
    6c94:	1080090b 	ldhu	r2,36(r2)
    6c98:	10bfffcc 	andi	r2,r2,65535
    6c9c:	10000c26 	beq	r2,zero,6cd0 <ip_output_if+0x470>
    6ca0:	e0bffa17 	ldw	r2,-24(fp)
    6ca4:	1080020b 	ldhu	r2,8(r2)
    6ca8:	e0c00417 	ldw	r3,16(fp)
    6cac:	18c0090b 	ldhu	r3,36(r3)
    6cb0:	10bfffcc 	andi	r2,r2,65535
    6cb4:	18ffffcc 	andi	r3,r3,65535
    6cb8:	1880052e 	bgeu	r3,r2,6cd0 <ip_output_if+0x470>
    return ip_frag(p,netif,dest);
    6cbc:	e13ffa17 	ldw	r4,-24(fp)
    6cc0:	e1400417 	ldw	r5,16(fp)
    6cc4:	e1bffc17 	ldw	r6,-16(fp)
    6cc8:	0007e880 	call	7e88 <ip_frag>
    6ccc:	00000606 	br	6ce8 <ip_output_if+0x488>
  }
#endif

  LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));
  return netif->output(netif, p, dest);
    6cd0:	e0800417 	ldw	r2,16(fp)
    6cd4:	10800517 	ldw	r2,20(r2)
    6cd8:	e1000417 	ldw	r4,16(fp)
    6cdc:	e17ffa17 	ldw	r5,-24(fp)
    6ce0:	e1bffc17 	ldw	r6,-16(fp)
    6ce4:	103ee83a 	callr	r2
}
    6ce8:	e037883a 	mov	sp,fp
    6cec:	dfc00117 	ldw	ra,4(sp)
    6cf0:	df000017 	ldw	fp,0(sp)
    6cf4:	dec00204 	addi	sp,sp,8
    6cf8:	f800283a 	ret

00006cfc <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
    6cfc:	defff404 	addi	sp,sp,-48
    6d00:	dfc00b15 	stw	ra,44(sp)
    6d04:	df000a15 	stw	fp,40(sp)
    6d08:	df000a04 	addi	fp,sp,40
    6d0c:	e13ffa15 	stw	r4,-24(fp)
    6d10:	e17ffb15 	stw	r5,-20(fp)
    6d14:	e1bffc15 	stw	r6,-16(fp)
    6d18:	3805883a 	mov	r2,r7
    6d1c:	e1000217 	ldw	r4,8(fp)
    6d20:	e0c00317 	ldw	r3,12(fp)
    6d24:	e0bffd05 	stb	r2,-12(fp)
    6d28:	e13ffe05 	stb	r4,-8(fp)
    6d2c:	e0ffff05 	stb	r3,-4(fp)
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
    6d30:	e13ffc17 	ldw	r4,-16(fp)
    6d34:	00061940 	call	6194 <ip_route>
    6d38:	e0bff915 	stw	r2,-28(fp)
    6d3c:	e0bff917 	ldw	r2,-28(fp)
    6d40:	10000a1e 	bne	r2,zero,6d6c <ip_output+0x70>
    LWIP_DEBUGF(IP_DEBUG, ("ip_output: No route to 0x%"X32_F"\n", dest->addr));
    IP_STATS_INC(ip.rterr);
    6d44:	00800134 	movhi	r2,4
    6d48:	108d9504 	addi	r2,r2,13908
    6d4c:	1080158b 	ldhu	r2,86(r2)
    6d50:	10800044 	addi	r2,r2,1
    6d54:	1007883a 	mov	r3,r2
    6d58:	00800134 	movhi	r2,4
    6d5c:	108d9504 	addi	r2,r2,13908
    6d60:	10c0158d 	sth	r3,86(r2)
    return ERR_RTE;
    6d64:	00bfff04 	movi	r2,-4
    6d68:	00000c06 	br	6d9c <ip_output+0xa0>
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
    6d6c:	e0bffd03 	ldbu	r2,-12(fp)
    6d70:	e13ffe03 	ldbu	r4,-8(fp)
    6d74:	e0ffff03 	ldbu	r3,-4(fp)
    6d78:	d9000015 	stw	r4,0(sp)
    6d7c:	d8c00115 	stw	r3,4(sp)
    6d80:	e0fff917 	ldw	r3,-28(fp)
    6d84:	d8c00215 	stw	r3,8(sp)
    6d88:	e13ffa17 	ldw	r4,-24(fp)
    6d8c:	e17ffb17 	ldw	r5,-20(fp)
    6d90:	e1bffc17 	ldw	r6,-16(fp)
    6d94:	100f883a 	mov	r7,r2
    6d98:	00068600 	call	6860 <ip_output_if>
}
    6d9c:	e037883a 	mov	sp,fp
    6da0:	dfc00117 	ldw	ra,4(sp)
    6da4:	df000017 	ldw	fp,0(sp)
    6da8:	dec00204 	addi	sp,sp,8
    6dac:	f800283a 	ret

00006db0 <ip_addr_isbroadcast>:
 * @param addr address to be checked
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
{
    6db0:	defffc04 	addi	sp,sp,-16
    6db4:	df000315 	stw	fp,12(sp)
    6db8:	df000304 	addi	fp,sp,12
    6dbc:	e13ffe15 	stw	r4,-8(fp)
    6dc0:	e17fff15 	stw	r5,-4(fp)
  u32_t addr2test;

  addr2test = addr->addr;
    6dc4:	e0bffe17 	ldw	r2,-8(fp)
    6dc8:	10c0000b 	ldhu	r3,0(r2)
    6dcc:	1080008b 	ldhu	r2,2(r2)
    6dd0:	1004943a 	slli	r2,r2,16
    6dd4:	10c4b03a 	or	r2,r2,r3
    6dd8:	e0bffd15 	stw	r2,-12(fp)
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
    6ddc:	e0bffd17 	ldw	r2,-12(fp)
    6de0:	10bfffe0 	cmpeqi	r2,r2,-1
    6de4:	1000021e 	bne	r2,zero,6df0 <ip_addr_isbroadcast+0x40>
    6de8:	e0bffd17 	ldw	r2,-12(fp)
    6dec:	1000021e 	bne	r2,zero,6df8 <ip_addr_isbroadcast+0x48>
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
    6df0:	00800044 	movi	r2,1
    6df4:	00002606 	br	6e90 <ip_addr_isbroadcast+0xe0>
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
    6df8:	e0bfff17 	ldw	r2,-4(fp)
    6dfc:	10800b43 	ldbu	r2,45(r2)
    6e00:	10803fcc 	andi	r2,r2,255
    6e04:	1080008c 	andi	r2,r2,2
    6e08:	1000021e 	bne	r2,zero,6e14 <ip_addr_isbroadcast+0x64>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
    6e0c:	0005883a 	mov	r2,zero
    6e10:	00001f06 	br	6e90 <ip_addr_isbroadcast+0xe0>
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
    6e14:	e0bfff17 	ldw	r2,-4(fp)
    6e18:	10c00117 	ldw	r3,4(r2)
    6e1c:	e0bffd17 	ldw	r2,-12(fp)
    6e20:	1880021e 	bne	r3,r2,6e2c <ip_addr_isbroadcast+0x7c>
    return 0;
    6e24:	0005883a 	mov	r2,zero
    6e28:	00001906 	br	6e90 <ip_addr_isbroadcast+0xe0>
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
    6e2c:	e0bffe17 	ldw	r2,-8(fp)
    6e30:	10c0000b 	ldhu	r3,0(r2)
    6e34:	1080008b 	ldhu	r2,2(r2)
    6e38:	1004943a 	slli	r2,r2,16
    6e3c:	10c4b03a 	or	r2,r2,r3
    6e40:	1007883a 	mov	r3,r2
    6e44:	e0bfff17 	ldw	r2,-4(fp)
    6e48:	10800117 	ldw	r2,4(r2)
    6e4c:	1886f03a 	xor	r3,r3,r2
    6e50:	e0bfff17 	ldw	r2,-4(fp)
    6e54:	10800217 	ldw	r2,8(r2)
    6e58:	1884703a 	and	r2,r3,r2
    6e5c:	10000b1e 	bne	r2,zero,6e8c <ip_addr_isbroadcast+0xdc>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
    6e60:	e0bfff17 	ldw	r2,-4(fp)
    6e64:	10800217 	ldw	r2,8(r2)
    6e68:	0086303a 	nor	r3,zero,r2
    6e6c:	e0bffd17 	ldw	r2,-12(fp)
    6e70:	1886703a 	and	r3,r3,r2
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    6e74:	e0bfff17 	ldw	r2,-4(fp)
    6e78:	10800217 	ldw	r2,8(r2)
    6e7c:	0084303a 	nor	r2,zero,r2
  else if (addr2test == netif->ip_addr.addr)
    return 0;
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
    6e80:	1880021e 	bne	r3,r2,6e8c <ip_addr_isbroadcast+0xdc>
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
    6e84:	00800044 	movi	r2,1
    6e88:	00000106 	br	6e90 <ip_addr_isbroadcast+0xe0>
  else
    return 0;
    6e8c:	0005883a 	mov	r2,zero
}
    6e90:	e037883a 	mov	sp,fp
    6e94:	df000017 	ldw	fp,0(sp)
    6e98:	dec00104 	addi	sp,sp,4
    6e9c:	f800283a 	ret

00006ea0 <ip_reass_tmr>:
 *
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
    6ea0:	defffb04 	addi	sp,sp,-20
    6ea4:	dfc00415 	stw	ra,16(sp)
    6ea8:	df000315 	stw	fp,12(sp)
    6eac:	df000304 	addi	fp,sp,12
  struct ip_reassdata *r, *prev = NULL;
    6eb0:	e03ffe15 	stw	zero,-8(fp)

  r = reassdatagrams;
    6eb4:	d0a8cb17 	ldw	r2,-23764(gp)
    6eb8:	e0bffd15 	stw	r2,-12(fp)
  while (r != NULL) {
    6ebc:	00001806 	br	6f20 <ip_reass_tmr+0x80>
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
    6ec0:	e0bffd17 	ldw	r2,-12(fp)
    6ec4:	108007c3 	ldbu	r2,31(r2)
    6ec8:	10803fcc 	andi	r2,r2,255
    6ecc:	10000c26 	beq	r2,zero,6f00 <ip_reass_tmr+0x60>
      r->timer--;
    6ed0:	e0bffd17 	ldw	r2,-12(fp)
    6ed4:	108007c3 	ldbu	r2,31(r2)
    6ed8:	10bfffc4 	addi	r2,r2,-1
    6edc:	1007883a 	mov	r3,r2
    6ee0:	e0bffd17 	ldw	r2,-12(fp)
    6ee4:	10c007c5 	stb	r3,31(r2)
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
      prev = r;
    6ee8:	e0bffd17 	ldw	r2,-12(fp)
    6eec:	e0bffe15 	stw	r2,-8(fp)
      r = r->next;
    6ef0:	e0bffd17 	ldw	r2,-12(fp)
    6ef4:	10800017 	ldw	r2,0(r2)
    6ef8:	e0bffd15 	stw	r2,-12(fp)
    6efc:	00000806 	br	6f20 <ip_reass_tmr+0x80>
    } else {
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
    6f00:	e0bffd17 	ldw	r2,-12(fp)
    6f04:	e0bfff15 	stw	r2,-4(fp)
      /* get the next pointer before freeing */
      r = r->next;
    6f08:	e0bffd17 	ldw	r2,-12(fp)
    6f0c:	10800017 	ldw	r2,0(r2)
    6f10:	e0bffd15 	stw	r2,-12(fp)
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
    6f14:	e13fff17 	ldw	r4,-4(fp)
    6f18:	e17ffe17 	ldw	r5,-8(fp)
    6f1c:	0006f3c0 	call	6f3c <ip_reass_free_complete_datagram>
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  while (r != NULL) {
    6f20:	e0bffd17 	ldw	r2,-12(fp)
    6f24:	103fe61e 	bne	r2,zero,6ec0 <ip_reass_tmr+0x20>
      r = r->next;
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
     }
   }
}
    6f28:	e037883a 	mov	sp,fp
    6f2c:	dfc00117 	ldw	ra,4(sp)
    6f30:	df000017 	ldw	fp,0(sp)
    6f34:	dec00204 	addi	sp,sp,8
    6f38:	f800283a 	ret

00006f3c <ip_reass_free_complete_datagram>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
    6f3c:	defff804 	addi	sp,sp,-32
    6f40:	dfc00715 	stw	ra,28(sp)
    6f44:	df000615 	stw	fp,24(sp)
    6f48:	df000604 	addi	fp,sp,24
    6f4c:	e13ffe15 	stw	r4,-8(fp)
    6f50:	e17fff15 	stw	r5,-4(fp)
  int pbufs_freed = 0;
    6f54:	e03ffa15 	stw	zero,-24(fp)
  struct pbuf *p;
  struct ip_reass_helper *iprh;

  LWIP_ASSERT("prev != ipr", prev != ipr);
    6f58:	e0ffff17 	ldw	r3,-4(fp)
    6f5c:	e0bffe17 	ldw	r2,-8(fp)
    6f60:	1880091e 	bne	r3,r2,6f88 <ip_reass_free_complete_datagram+0x4c>
    6f64:	010000f4 	movhi	r4,3
    6f68:	2136ff04 	addi	r4,r4,-9220
    6f6c:	014000f4 	movhi	r5,3
    6f70:	29770904 	addi	r5,r5,-9180
    6f74:	01802884 	movi	r6,162
    6f78:	01c000f4 	movhi	r7,3
    6f7c:	39f70c04 	addi	r7,r7,-9168
    6f80:	00166c00 	call	166c0 <printf>
    6f84:	003fff06 	br	6f84 <ip_reass_free_complete_datagram+0x48>
  if (prev != NULL) {
    6f88:	e0bfff17 	ldw	r2,-4(fp)
    6f8c:	10000d26 	beq	r2,zero,6fc4 <ip_reass_free_complete_datagram+0x88>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
    6f90:	e0bfff17 	ldw	r2,-4(fp)
    6f94:	10c00017 	ldw	r3,0(r2)
    6f98:	e0bffe17 	ldw	r2,-8(fp)
    6f9c:	18800926 	beq	r3,r2,6fc4 <ip_reass_free_complete_datagram+0x88>
    6fa0:	010000f4 	movhi	r4,3
    6fa4:	2136ff04 	addi	r4,r4,-9220
    6fa8:	014000f4 	movhi	r5,3
    6fac:	29771404 	addi	r5,r5,-9136
    6fb0:	01802904 	movi	r6,164
    6fb4:	01c000f4 	movhi	r7,3
    6fb8:	39f70c04 	addi	r7,r7,-9168
    6fbc:	00166c00 	call	166c0 <printf>
    6fc0:	003fff06 	br	6fc0 <ip_reass_free_complete_datagram+0x84>
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
    6fc4:	e0bffe17 	ldw	r2,-8(fp)
    6fc8:	10800117 	ldw	r2,4(r2)
    6fcc:	10800117 	ldw	r2,4(r2)
    6fd0:	e0bffc15 	stw	r2,-16(fp)
  if (iprh->start == 0) {
    6fd4:	e0bffc17 	ldw	r2,-16(fp)
    6fd8:	1080010b 	ldhu	r2,4(r2)
    6fdc:	10bfffcc 	andi	r2,r2,65535
    6fe0:	10001e1e 	bne	r2,zero,705c <ip_reass_free_complete_datagram+0x120>
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
    6fe4:	e0bffe17 	ldw	r2,-8(fp)
    6fe8:	10800117 	ldw	r2,4(r2)
    6fec:	e0bffb15 	stw	r2,-20(fp)
    ipr->p = iprh->next_pbuf;
    6ff0:	e0bffc17 	ldw	r2,-16(fp)
    6ff4:	10c0000b 	ldhu	r3,0(r2)
    6ff8:	1080008b 	ldhu	r2,2(r2)
    6ffc:	1004943a 	slli	r2,r2,16
    7000:	10c4b03a 	or	r2,r2,r3
    7004:	1007883a 	mov	r3,r2
    7008:	e0bffe17 	ldw	r2,-8(fp)
    700c:	10c00115 	stw	r3,4(r2)
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
    7010:	e0bffb17 	ldw	r2,-20(fp)
    7014:	10c00117 	ldw	r3,4(r2)
    7018:	e0bffe17 	ldw	r2,-8(fp)
    701c:	10800204 	addi	r2,r2,8
    7020:	1809883a 	mov	r4,r3
    7024:	100b883a 	mov	r5,r2
    7028:	01800504 	movi	r6,20
    702c:	00164c00 	call	164c0 <memcpy>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
    7030:	e13ffb17 	ldw	r4,-20(fp)
    7034:	01400044 	movi	r5,1
    7038:	00054b00 	call	54b0 <icmp_time_exceeded>
    pbufs_freed += pbuf_clen(p);
    703c:	e13ffb17 	ldw	r4,-20(fp)
    7040:	000a3380 	call	a338 <pbuf_clen>
    7044:	10803fcc 	andi	r2,r2,255
    7048:	e0fffa17 	ldw	r3,-24(fp)
    704c:	1885883a 	add	r2,r3,r2
    7050:	e0bffa15 	stw	r2,-24(fp)
    pbuf_free(p);
    7054:	e13ffb17 	ldw	r4,-20(fp)
    7058:	000a16c0 	call	a16c <pbuf_free>
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
    705c:	e0bffe17 	ldw	r2,-8(fp)
    7060:	10800117 	ldw	r2,4(r2)
    7064:	e0bffb15 	stw	r2,-20(fp)
  while (p != NULL) {
    7068:	00001306 	br	70b8 <ip_reass_free_complete_datagram+0x17c>
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
    706c:	e0bffb17 	ldw	r2,-20(fp)
    7070:	10800117 	ldw	r2,4(r2)
    7074:	e0bffc15 	stw	r2,-16(fp)
    pcur = p;
    7078:	e0bffb17 	ldw	r2,-20(fp)
    707c:	e0bffd15 	stw	r2,-12(fp)
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
    7080:	e0bffc17 	ldw	r2,-16(fp)
    7084:	10c0000b 	ldhu	r3,0(r2)
    7088:	1080008b 	ldhu	r2,2(r2)
    708c:	1004943a 	slli	r2,r2,16
    7090:	10c4b03a 	or	r2,r2,r3
    7094:	e0bffb15 	stw	r2,-20(fp)
    pbufs_freed += pbuf_clen(pcur);
    7098:	e13ffd17 	ldw	r4,-12(fp)
    709c:	000a3380 	call	a338 <pbuf_clen>
    70a0:	10803fcc 	andi	r2,r2,255
    70a4:	e0fffa17 	ldw	r3,-24(fp)
    70a8:	1885883a 	add	r2,r3,r2
    70ac:	e0bffa15 	stw	r2,-24(fp)
    pbuf_free(pcur);    
    70b0:	e13ffd17 	ldw	r4,-12(fp)
    70b4:	000a16c0 	call	a16c <pbuf_free>
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
    70b8:	e0bffb17 	ldw	r2,-20(fp)
    70bc:	103feb1e 	bne	r2,zero,706c <ip_reass_free_complete_datagram+0x130>
    p = iprh->next_pbuf;
    pbufs_freed += pbuf_clen(pcur);
    pbuf_free(pcur);    
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
    70c0:	e13ffe17 	ldw	r4,-8(fp)
    70c4:	e17fff17 	ldw	r5,-4(fp)
    70c8:	00073580 	call	7358 <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
    70cc:	d0a8cc0b 	ldhu	r2,-23760(gp)
    70d0:	10ffffcc 	andi	r3,r2,65535
    70d4:	e0bffa17 	ldw	r2,-24(fp)
    70d8:	1880090e 	bge	r3,r2,7100 <ip_reass_free_complete_datagram+0x1c4>
    70dc:	010000f4 	movhi	r4,3
    70e0:	2136ff04 	addi	r4,r4,-9220
    70e4:	014000f4 	movhi	r5,3
    70e8:	29771904 	addi	r5,r5,-9116
    70ec:	01803144 	movi	r6,197
    70f0:	01c000f4 	movhi	r7,3
    70f4:	39f70c04 	addi	r7,r7,-9168
    70f8:	00166c00 	call	166c0 <printf>
    70fc:	003fff06 	br	70fc <ip_reass_free_complete_datagram+0x1c0>
  ip_reass_pbufcount -= pbufs_freed;
    7100:	d0e8cc0b 	ldhu	r3,-23760(gp)
    7104:	e0bffa17 	ldw	r2,-24(fp)
    7108:	1885c83a 	sub	r2,r3,r2
    710c:	d0a8cc0d 	sth	r2,-23760(gp)

  return pbufs_freed;
    7110:	e0bffa17 	ldw	r2,-24(fp)
}
    7114:	e037883a 	mov	sp,fp
    7118:	dfc00117 	ldw	ra,4(sp)
    711c:	df000017 	ldw	fp,0(sp)
    7120:	dec00204 	addi	sp,sp,8
    7124:	f800283a 	ret

00007128 <ip_reass_remove_oldest_datagram>:
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
    7128:	defff604 	addi	sp,sp,-40
    712c:	dfc00915 	stw	ra,36(sp)
    7130:	df000815 	stw	fp,32(sp)
    7134:	df000804 	addi	fp,sp,32
    7138:	e13ffe15 	stw	r4,-8(fp)
    713c:	e17fff15 	stw	r5,-4(fp)
  /* @todo Can't we simply remove the last datagram in the
   *       linked list behind reassdatagrams?
   */
  struct ip_reassdata *r, *oldest, *prev;
  int pbufs_freed = 0, pbufs_freed_current;
    7140:	e03ffb15 	stw	zero,-20(fp)
  int other_datagrams;

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    7144:	e03ff915 	stw	zero,-28(fp)
    prev = NULL;
    7148:	e03ffa15 	stw	zero,-24(fp)
    other_datagrams = 0;
    714c:	e03ffc15 	stw	zero,-16(fp)
    r = reassdatagrams;
    7150:	d0a8cb17 	ldw	r2,-23764(gp)
    7154:	e0bff815 	stw	r2,-32(fp)
    while (r != NULL) {
    7158:	00003006 	br	721c <ip_reass_remove_oldest_datagram+0xf4>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
    715c:	e0bff817 	ldw	r2,-32(fp)
    7160:	10c00517 	ldw	r3,20(r2)
    7164:	e0bffe17 	ldw	r2,-8(fp)
    7168:	1100030b 	ldhu	r4,12(r2)
    716c:	1080038b 	ldhu	r2,14(r2)
    7170:	1004943a 	slli	r2,r2,16
    7174:	1104b03a 	or	r2,r2,r4
    7178:	18800f1e 	bne	r3,r2,71b8 <ip_reass_remove_oldest_datagram+0x90>
    717c:	e0bff817 	ldw	r2,-32(fp)
    7180:	10c00617 	ldw	r3,24(r2)
    7184:	e0bffe17 	ldw	r2,-8(fp)
    7188:	1100040b 	ldhu	r4,16(r2)
    718c:	1080048b 	ldhu	r2,18(r2)
    7190:	1004943a 	slli	r2,r2,16
    7194:	1104b03a 	or	r2,r2,r4
    7198:	1880071e 	bne	r3,r2,71b8 <ip_reass_remove_oldest_datagram+0x90>
    719c:	e0bff817 	ldw	r2,-32(fp)
    71a0:	10c0030b 	ldhu	r3,12(r2)
    71a4:	e0bffe17 	ldw	r2,-8(fp)
    71a8:	1080010b 	ldhu	r2,4(r2)
    71ac:	18ffffcc 	andi	r3,r3,65535
    71b0:	10bfffcc 	andi	r2,r2,65535
    71b4:	18801126 	beq	r3,r2,71fc <ip_reass_remove_oldest_datagram+0xd4>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
    71b8:	e0bffc17 	ldw	r2,-16(fp)
    71bc:	10800044 	addi	r2,r2,1
    71c0:	e0bffc15 	stw	r2,-16(fp)
        if (oldest == NULL) {
    71c4:	e0bff917 	ldw	r2,-28(fp)
    71c8:	1000031e 	bne	r2,zero,71d8 <ip_reass_remove_oldest_datagram+0xb0>
          oldest = r;
    71cc:	e0bff817 	ldw	r2,-32(fp)
    71d0:	e0bff915 	stw	r2,-28(fp)
    71d4:	00000906 	br	71fc <ip_reass_remove_oldest_datagram+0xd4>
        } else if (r->timer <= oldest->timer) {
    71d8:	e0bff817 	ldw	r2,-32(fp)
    71dc:	108007c3 	ldbu	r2,31(r2)
    71e0:	e0fff917 	ldw	r3,-28(fp)
    71e4:	18c007c3 	ldbu	r3,31(r3)
    71e8:	10803fcc 	andi	r2,r2,255
    71ec:	18c03fcc 	andi	r3,r3,255
    71f0:	18800236 	bltu	r3,r2,71fc <ip_reass_remove_oldest_datagram+0xd4>
          /* older than the previous oldest */
          oldest = r;
    71f4:	e0bff817 	ldw	r2,-32(fp)
    71f8:	e0bff915 	stw	r2,-28(fp)
        }
      }
      if (r->next != NULL) {
    71fc:	e0bff817 	ldw	r2,-32(fp)
    7200:	10800017 	ldw	r2,0(r2)
    7204:	10000226 	beq	r2,zero,7210 <ip_reass_remove_oldest_datagram+0xe8>
        prev = r;
    7208:	e0bff817 	ldw	r2,-32(fp)
    720c:	e0bffa15 	stw	r2,-24(fp)
      }
      r = r->next;
    7210:	e0bff817 	ldw	r2,-32(fp)
    7214:	10800017 	ldw	r2,0(r2)
    7218:	e0bff815 	stw	r2,-32(fp)
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
    721c:	e0bff817 	ldw	r2,-32(fp)
    7220:	103fce1e 	bne	r2,zero,715c <ip_reass_remove_oldest_datagram+0x34>
      if (r->next != NULL) {
        prev = r;
      }
      r = r->next;
    }
    if (oldest != NULL) {
    7224:	e0bff917 	ldw	r2,-28(fp)
    7228:	10000826 	beq	r2,zero,724c <ip_reass_remove_oldest_datagram+0x124>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
    722c:	e13ff917 	ldw	r4,-28(fp)
    7230:	e17ffa17 	ldw	r5,-24(fp)
    7234:	0006f3c0 	call	6f3c <ip_reass_free_complete_datagram>
    7238:	e0bffd15 	stw	r2,-12(fp)
      pbufs_freed += pbufs_freed_current;
    723c:	e0fffb17 	ldw	r3,-20(fp)
    7240:	e0bffd17 	ldw	r2,-12(fp)
    7244:	1885883a 	add	r2,r3,r2
    7248:	e0bffb15 	stw	r2,-20(fp)
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
    724c:	e0fffb17 	ldw	r3,-20(fp)
    7250:	e0bfff17 	ldw	r2,-4(fp)
    7254:	1880030e 	bge	r3,r2,7264 <ip_reass_remove_oldest_datagram+0x13c>
    7258:	e0bffc17 	ldw	r2,-16(fp)
    725c:	10800088 	cmpgei	r2,r2,2
    7260:	103fb81e 	bne	r2,zero,7144 <ip_reass_remove_oldest_datagram+0x1c>
  return pbufs_freed;
    7264:	e0bffb17 	ldw	r2,-20(fp)
}
    7268:	e037883a 	mov	sp,fp
    726c:	dfc00117 	ldw	ra,4(sp)
    7270:	df000017 	ldw	fp,0(sp)
    7274:	dec00204 	addi	sp,sp,8
    7278:	f800283a 	ret

0000727c <ip_reass_enqueue_new_datagram>:
 * @param clen number of pbufs needed to enqueue (used for freeing other datagrams if not enough space)
 * @return A pointer to the queue location into which the fragment was enqueued
 */
static struct ip_reassdata*
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
    727c:	defffb04 	addi	sp,sp,-20
    7280:	dfc00415 	stw	ra,16(sp)
    7284:	df000315 	stw	fp,12(sp)
    7288:	df000304 	addi	fp,sp,12
    728c:	e13ffe15 	stw	r4,-8(fp)
    7290:	e17fff15 	stw	r5,-4(fp)
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = memp_malloc(MEMP_REASSDATA);
    7294:	01000144 	movi	r4,5
    7298:	0008ef00 	call	8ef0 <memp_malloc>
    729c:	e0bffd15 	stw	r2,-12(fp)
  if (ipr == NULL) {
    72a0:	e0bffd17 	ldw	r2,-12(fp)
    72a4:	1000141e 	bne	r2,zero,72f8 <ip_reass_enqueue_new_datagram+0x7c>
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
    72a8:	e13ffe17 	ldw	r4,-8(fp)
    72ac:	e17fff17 	ldw	r5,-4(fp)
    72b0:	00071280 	call	7128 <ip_reass_remove_oldest_datagram>
    72b4:	e0ffff17 	ldw	r3,-4(fp)
    72b8:	10c00316 	blt	r2,r3,72c8 <ip_reass_enqueue_new_datagram+0x4c>
      ipr = memp_malloc(MEMP_REASSDATA);
    72bc:	01000144 	movi	r4,5
    72c0:	0008ef00 	call	8ef0 <memp_malloc>
    72c4:	e0bffd15 	stw	r2,-12(fp)
    }
    if (ipr == NULL)
    72c8:	e0bffd17 	ldw	r2,-12(fp)
    72cc:	10000a1e 	bne	r2,zero,72f8 <ip_reass_enqueue_new_datagram+0x7c>
#endif /* IP_REASS_FREE_OLDEST */
    {
      IPFRAG_STATS_INC(ip_frag.memerr);
    72d0:	00800134 	movhi	r2,4
    72d4:	108d9504 	addi	r2,r2,13908
    72d8:	10800f0b 	ldhu	r2,60(r2)
    72dc:	10800044 	addi	r2,r2,1
    72e0:	1007883a 	mov	r3,r2
    72e4:	00800134 	movhi	r2,4
    72e8:	108d9504 	addi	r2,r2,13908
    72ec:	10c00f0d 	sth	r3,60(r2)
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
    72f0:	0005883a 	mov	r2,zero
    72f4:	00001306 	br	7344 <ip_reass_enqueue_new_datagram+0xc8>
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
    72f8:	e13ffd17 	ldw	r4,-12(fp)
    72fc:	000b883a 	mov	r5,zero
    7300:	01800804 	movi	r6,32
    7304:	00165b80 	call	165b8 <memset>
  ipr->timer = IP_REASS_MAXAGE;
    7308:	e0bffd17 	ldw	r2,-12(fp)
    730c:	00c000c4 	movi	r3,3
    7310:	10c007c5 	stb	r3,31(r2)

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
    7314:	d0e8cb17 	ldw	r3,-23764(gp)
    7318:	e0bffd17 	ldw	r2,-12(fp)
    731c:	10c00015 	stw	r3,0(r2)
  reassdatagrams = ipr;
    7320:	e0bffd17 	ldw	r2,-12(fp)
    7324:	d0a8cb15 	stw	r2,-23764(gp)
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
    7328:	e0bffd17 	ldw	r2,-12(fp)
    732c:	10800204 	addi	r2,r2,8
    7330:	1009883a 	mov	r4,r2
    7334:	e17ffe17 	ldw	r5,-8(fp)
    7338:	01800504 	movi	r6,20
    733c:	00164c00 	call	164c0 <memcpy>
  return ipr;
    7340:	e0bffd17 	ldw	r2,-12(fp)
}
    7344:	e037883a 	mov	sp,fp
    7348:	dfc00117 	ldw	ra,4(sp)
    734c:	df000017 	ldw	fp,0(sp)
    7350:	dec00204 	addi	sp,sp,8
    7354:	f800283a 	ret

00007358 <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
    7358:	defffc04 	addi	sp,sp,-16
    735c:	dfc00315 	stw	ra,12(sp)
    7360:	df000215 	stw	fp,8(sp)
    7364:	df000204 	addi	fp,sp,8
    7368:	e13ffe15 	stw	r4,-8(fp)
    736c:	e17fff15 	stw	r5,-4(fp)
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
    7370:	d0e8cb17 	ldw	r3,-23764(gp)
    7374:	e0bffe17 	ldw	r2,-8(fp)
    7378:	1880041e 	bne	r3,r2,738c <ip_reass_dequeue_datagram+0x34>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
    737c:	e0bffe17 	ldw	r2,-8(fp)
    7380:	10800017 	ldw	r2,0(r2)
    7384:	d0a8cb15 	stw	r2,-23764(gp)
    7388:	00000f06 	br	73c8 <ip_reass_dequeue_datagram+0x70>
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
    738c:	e0bfff17 	ldw	r2,-4(fp)
    7390:	1000091e 	bne	r2,zero,73b8 <ip_reass_dequeue_datagram+0x60>
    7394:	010000f4 	movhi	r4,3
    7398:	2136ff04 	addi	r4,r4,-9220
    739c:	014000f4 	movhi	r5,3
    73a0:	29772004 	addi	r5,r5,-9088
    73a4:	01804c84 	movi	r6,306
    73a8:	01c000f4 	movhi	r7,3
    73ac:	39f70c04 	addi	r7,r7,-9168
    73b0:	00166c00 	call	166c0 <printf>
    73b4:	003fff06 	br	73b4 <ip_reass_dequeue_datagram+0x5c>
    prev->next = ipr->next;
    73b8:	e0bffe17 	ldw	r2,-8(fp)
    73bc:	10c00017 	ldw	r3,0(r2)
    73c0:	e0bfff17 	ldw	r2,-4(fp)
    73c4:	10c00015 	stw	r3,0(r2)
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
    73c8:	01000144 	movi	r4,5
    73cc:	e17ffe17 	ldw	r5,-8(fp)
    73d0:	00090cc0 	call	90cc <memp_free>
}
    73d4:	e037883a 	mov	sp,fp
    73d8:	dfc00117 	ldw	ra,4(sp)
    73dc:	df000017 	ldw	fp,0(sp)
    73e0:	dec00204 	addi	sp,sp,8
    73e4:	f800283a 	ret

000073e8 <ip_reass_chain_frag_into_datagram_and_validate>:
 * @param new_p points to the pbuf for the current fragment
 * @return 0 if invalid, >0 otherwise
 */
static int
ip_reass_chain_frag_into_datagram_and_validate(struct ip_reassdata *ipr, struct pbuf *new_p)
{
    73e8:	defff404 	addi	sp,sp,-48
    73ec:	dfc00b15 	stw	ra,44(sp)
    73f0:	df000a15 	stw	fp,40(sp)
    73f4:	dc000915 	stw	r16,36(sp)
    73f8:	df000904 	addi	fp,sp,36
    73fc:	e13ffe15 	stw	r4,-8(fp)
    7400:	e17fff15 	stw	r5,-4(fp)
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
    7404:	e03ff815 	stw	zero,-32(fp)
  struct pbuf *q;
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;
    7408:	00800044 	movi	r2,1
    740c:	e0bffa15 	stw	r2,-24(fp)

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
    7410:	e0bfff17 	ldw	r2,-4(fp)
    7414:	10800117 	ldw	r2,4(r2)
    7418:	e0bffb15 	stw	r2,-20(fp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    741c:	e0bffb17 	ldw	r2,-20(fp)
    7420:	1080008b 	ldhu	r2,2(r2)
    7424:	10bfffcc 	andi	r2,r2,65535
    7428:	1004d23a 	srli	r2,r2,8
    742c:	1007883a 	mov	r3,r2
    7430:	e0bffb17 	ldw	r2,-20(fp)
    7434:	1080008b 	ldhu	r2,2(r2)
    7438:	10bfffcc 	andi	r2,r2,65535
    743c:	1004923a 	slli	r2,r2,8
    7440:	1884b03a 	or	r2,r3,r2
    7444:	1007883a 	mov	r3,r2
    7448:	e0bffb17 	ldw	r2,-20(fp)
    744c:	1080000b 	ldhu	r2,0(r2)
    7450:	10bfffcc 	andi	r2,r2,65535
    7454:	1004d23a 	srli	r2,r2,8
    7458:	113fffcc 	andi	r4,r2,65535
    745c:	e0bffb17 	ldw	r2,-20(fp)
    7460:	1080000b 	ldhu	r2,0(r2)
    7464:	10bfffcc 	andi	r2,r2,65535
    7468:	1004923a 	slli	r2,r2,8
    746c:	10bfffcc 	andi	r2,r2,65535
    7470:	2084b03a 	or	r2,r4,r2
    7474:	1005d23a 	srai	r2,r2,8
    7478:	108003cc 	andi	r2,r2,15
    747c:	10bfff24 	muli	r2,r2,-4
    7480:	1885883a 	add	r2,r3,r2
    7484:	e0bffc0d 	sth	r2,-16(fp)
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
    7488:	e0bffb17 	ldw	r2,-20(fp)
    748c:	1080018b 	ldhu	r2,6(r2)
    7490:	10bfffcc 	andi	r2,r2,65535
    7494:	1004d23a 	srli	r2,r2,8
    7498:	10ffffcc 	andi	r3,r2,65535
    749c:	e0bffb17 	ldw	r2,-20(fp)
    74a0:	1080018b 	ldhu	r2,6(r2)
    74a4:	10bfffcc 	andi	r2,r2,65535
    74a8:	1004923a 	slli	r2,r2,8
    74ac:	10bfffcc 	andi	r2,r2,65535
    74b0:	1884b03a 	or	r2,r3,r2
    74b4:	1087ffcc 	andi	r2,r2,8191
    74b8:	100490fa 	slli	r2,r2,3
    74bc:	e0bffc8d 	sth	r2,-14(fp)
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
    74c0:	e0bfff17 	ldw	r2,-4(fp)
    74c4:	10800117 	ldw	r2,4(r2)
    74c8:	e0bff715 	stw	r2,-36(fp)
  iprh->next_pbuf = NULL;
    74cc:	e0bff717 	ldw	r2,-36(fp)
    74d0:	10c0000b 	ldhu	r3,0(r2)
    74d4:	1806703a 	and	r3,r3,zero
    74d8:	10c0000d 	sth	r3,0(r2)
    74dc:	10c0008b 	ldhu	r3,2(r2)
    74e0:	1806703a 	and	r3,r3,zero
    74e4:	10c0008d 	sth	r3,2(r2)
  iprh->start = offset;
    74e8:	e0bff717 	ldw	r2,-36(fp)
    74ec:	e0fffc8b 	ldhu	r3,-14(fp)
    74f0:	10c0010d 	sth	r3,4(r2)
  iprh->end = offset + len;
    74f4:	e0fffc8b 	ldhu	r3,-14(fp)
    74f8:	e0bffc0b 	ldhu	r2,-16(fp)
    74fc:	1885883a 	add	r2,r3,r2
    7500:	1007883a 	mov	r3,r2
    7504:	e0bff717 	ldw	r2,-36(fp)
    7508:	10c0018d 	sth	r3,6(r2)

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    750c:	e0bffe17 	ldw	r2,-8(fp)
    7510:	10800117 	ldw	r2,4(r2)
    7514:	e0bff915 	stw	r2,-28(fp)
    7518:	00005906 	br	7680 <ip_reass_chain_frag_into_datagram_and_validate+0x298>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
    751c:	e0bff917 	ldw	r2,-28(fp)
    7520:	10800117 	ldw	r2,4(r2)
    7524:	e0bffd15 	stw	r2,-12(fp)
    if (iprh->start < iprh_tmp->start) {
    7528:	e0bff717 	ldw	r2,-36(fp)
    752c:	10c0010b 	ldhu	r3,4(r2)
    7530:	e0bffd17 	ldw	r2,-12(fp)
    7534:	1080010b 	ldhu	r2,4(r2)
    7538:	18ffffcc 	andi	r3,r3,65535
    753c:	10bfffcc 	andi	r2,r2,65535
    7540:	18802f2e 	bgeu	r3,r2,7600 <ip_reass_chain_frag_into_datagram_and_validate+0x218>
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
    7544:	e0bff717 	ldw	r2,-36(fp)
    7548:	e0fff917 	ldw	r3,-28(fp)
    754c:	18ffffcc 	andi	r3,r3,65535
    7550:	1100000b 	ldhu	r4,0(r2)
    7554:	2008703a 	and	r4,r4,zero
    7558:	20c6b03a 	or	r3,r4,r3
    755c:	10c0000d 	sth	r3,0(r2)
    7560:	e0fff917 	ldw	r3,-28(fp)
    7564:	1806d43a 	srli	r3,r3,16
    7568:	1100008b 	ldhu	r4,2(r2)
    756c:	2008703a 	and	r4,r4,zero
    7570:	20c6b03a 	or	r3,r4,r3
    7574:	10c0008d 	sth	r3,2(r2)
      if (iprh_prev != NULL) {
    7578:	e0bff817 	ldw	r2,-32(fp)
    757c:	10001c26 	beq	r2,zero,75f0 <ip_reass_chain_frag_into_datagram_and_validate+0x208>
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
    7580:	e0bff717 	ldw	r2,-36(fp)
    7584:	10c0010b 	ldhu	r3,4(r2)
    7588:	e0bff817 	ldw	r2,-32(fp)
    758c:	1080018b 	ldhu	r2,6(r2)
    7590:	18ffffcc 	andi	r3,r3,65535
    7594:	10bfffcc 	andi	r2,r2,65535
    7598:	1880e436 	bltu	r3,r2,792c <ip_reass_chain_frag_into_datagram_and_validate+0x544>
    759c:	e0bff717 	ldw	r2,-36(fp)
    75a0:	1080018b 	ldhu	r2,6(r2)
    75a4:	e0fffd17 	ldw	r3,-12(fp)
    75a8:	18c0010b 	ldhu	r3,4(r3)
    75ac:	10bfffcc 	andi	r2,r2,65535
    75b0:	18ffffcc 	andi	r3,r3,65535
    75b4:	1880dd36 	bltu	r3,r2,792c <ip_reass_chain_frag_into_datagram_and_validate+0x544>
          /* fragment overlaps with previous or following, throw away */
          goto freepbuf;
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
    75b8:	e0bff817 	ldw	r2,-32(fp)
    75bc:	e0ffff17 	ldw	r3,-4(fp)
    75c0:	18ffffcc 	andi	r3,r3,65535
    75c4:	1100000b 	ldhu	r4,0(r2)
    75c8:	2008703a 	and	r4,r4,zero
    75cc:	20c6b03a 	or	r3,r4,r3
    75d0:	10c0000d 	sth	r3,0(r2)
    75d4:	e0ffff17 	ldw	r3,-4(fp)
    75d8:	1806d43a 	srli	r3,r3,16
    75dc:	1100008b 	ldhu	r4,2(r2)
    75e0:	2008703a 	and	r4,r4,zero
    75e4:	20c6b03a 	or	r3,r4,r3
    75e8:	10c0008d 	sth	r3,2(r2)
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
    75ec:	00002606 	br	7688 <ip_reass_chain_frag_into_datagram_and_validate+0x2a0>
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
    75f0:	e0bffe17 	ldw	r2,-8(fp)
    75f4:	e0ffff17 	ldw	r3,-4(fp)
    75f8:	10c00115 	stw	r3,4(r2)
      }
      break;
    75fc:	00002206 	br	7688 <ip_reass_chain_frag_into_datagram_and_validate+0x2a0>
    } else if(iprh->start == iprh_tmp->start) {
    7600:	e0bff717 	ldw	r2,-36(fp)
    7604:	10c0010b 	ldhu	r3,4(r2)
    7608:	e0bffd17 	ldw	r2,-12(fp)
    760c:	1080010b 	ldhu	r2,4(r2)
    7610:	18ffffcc 	andi	r3,r3,65535
    7614:	10bfffcc 	andi	r2,r2,65535
    7618:	1880c126 	beq	r3,r2,7920 <ip_reass_chain_frag_into_datagram_and_validate+0x538>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
    761c:	e0bff717 	ldw	r2,-36(fp)
    7620:	10c0010b 	ldhu	r3,4(r2)
    7624:	e0bffd17 	ldw	r2,-12(fp)
    7628:	1080018b 	ldhu	r2,6(r2)
    762c:	18ffffcc 	andi	r3,r3,65535
    7630:	10bfffcc 	andi	r2,r2,65535
    7634:	1880bc36 	bltu	r3,r2,7928 <ip_reass_chain_frag_into_datagram_and_validate+0x540>
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
    7638:	e0bff817 	ldw	r2,-32(fp)
    763c:	10000826 	beq	r2,zero,7660 <ip_reass_chain_frag_into_datagram_and_validate+0x278>
        if (iprh_prev->end != iprh_tmp->start) {
    7640:	e0bff817 	ldw	r2,-32(fp)
    7644:	10c0018b 	ldhu	r3,6(r2)
    7648:	e0bffd17 	ldw	r2,-12(fp)
    764c:	1080010b 	ldhu	r2,4(r2)
    7650:	18ffffcc 	andi	r3,r3,65535
    7654:	10bfffcc 	andi	r2,r2,65535
    7658:	18800126 	beq	r3,r2,7660 <ip_reass_chain_frag_into_datagram_and_validate+0x278>
          /* There is a fragment missing between the current
           * and the previous fragment */
          valid = 0;
    765c:	e03ffa15 	stw	zero,-24(fp)
        }
      }
    }
    q = iprh_tmp->next_pbuf;
    7660:	e0bffd17 	ldw	r2,-12(fp)
    7664:	10c0000b 	ldhu	r3,0(r2)
    7668:	1080008b 	ldhu	r2,2(r2)
    766c:	1004943a 	slli	r2,r2,16
    7670:	10c4b03a 	or	r2,r2,r3
    7674:	e0bff915 	stw	r2,-28(fp)
    iprh_prev = iprh_tmp;
    7678:	e0bffd17 	ldw	r2,-12(fp)
    767c:	e0bff815 	stw	r2,-32(fp)
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    7680:	e0bff917 	ldw	r2,-28(fp)
    7684:	103fa51e 	bne	r2,zero,751c <ip_reass_chain_frag_into_datagram_and_validate+0x134>
    q = iprh_tmp->next_pbuf;
    iprh_prev = iprh_tmp;
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
    7688:	e0bff917 	ldw	r2,-28(fp)
    768c:	1000371e 	bne	r2,zero,776c <ip_reass_chain_frag_into_datagram_and_validate+0x384>
    if (iprh_prev != NULL) {
    7690:	e0bff817 	ldw	r2,-32(fp)
    7694:	10002626 	beq	r2,zero,7730 <ip_reass_chain_frag_into_datagram_and_validate+0x348>
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
    7698:	e0bff817 	ldw	r2,-32(fp)
    769c:	1080018b 	ldhu	r2,6(r2)
    76a0:	e0fff717 	ldw	r3,-36(fp)
    76a4:	18c0010b 	ldhu	r3,4(r3)
    76a8:	10bfffcc 	andi	r2,r2,65535
    76ac:	18ffffcc 	andi	r3,r3,65535
    76b0:	1880092e 	bgeu	r3,r2,76d8 <ip_reass_chain_frag_into_datagram_and_validate+0x2f0>
    76b4:	010000f4 	movhi	r4,3
    76b8:	2136ff04 	addi	r4,r4,-9220
    76bc:	014000f4 	movhi	r5,3
    76c0:	29772704 	addi	r5,r5,-9060
    76c4:	01806304 	movi	r6,396
    76c8:	01c000f4 	movhi	r7,3
    76cc:	39f70c04 	addi	r7,r7,-9168
    76d0:	00166c00 	call	166c0 <printf>
    76d4:	003fff06 	br	76d4 <ip_reass_chain_frag_into_datagram_and_validate+0x2ec>
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
    76d8:	e0bff817 	ldw	r2,-32(fp)
    76dc:	e0ffff17 	ldw	r3,-4(fp)
    76e0:	18ffffcc 	andi	r3,r3,65535
    76e4:	1100000b 	ldhu	r4,0(r2)
    76e8:	2008703a 	and	r4,r4,zero
    76ec:	20c6b03a 	or	r3,r4,r3
    76f0:	10c0000d 	sth	r3,0(r2)
    76f4:	e0ffff17 	ldw	r3,-4(fp)
    76f8:	1806d43a 	srli	r3,r3,16
    76fc:	1100008b 	ldhu	r4,2(r2)
    7700:	2008703a 	and	r4,r4,zero
    7704:	20c6b03a 	or	r3,r4,r3
    7708:	10c0008d 	sth	r3,2(r2)
      if (iprh_prev->end != iprh->start) {
    770c:	e0bff817 	ldw	r2,-32(fp)
    7710:	10c0018b 	ldhu	r3,6(r2)
    7714:	e0bff717 	ldw	r2,-36(fp)
    7718:	1080010b 	ldhu	r2,4(r2)
    771c:	18ffffcc 	andi	r3,r3,65535
    7720:	10bfffcc 	andi	r2,r2,65535
    7724:	18801126 	beq	r3,r2,776c <ip_reass_chain_frag_into_datagram_and_validate+0x384>
        valid = 0;
    7728:	e03ffa15 	stw	zero,-24(fp)
    772c:	00000f06 	br	776c <ip_reass_chain_frag_into_datagram_and_validate+0x384>
      }
    } else {
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
    7730:	e0bffe17 	ldw	r2,-8(fp)
    7734:	10800117 	ldw	r2,4(r2)
    7738:	10000926 	beq	r2,zero,7760 <ip_reass_chain_frag_into_datagram_and_validate+0x378>
    773c:	010000f4 	movhi	r4,3
    7740:	2136ff04 	addi	r4,r4,-9220
    7744:	014000f4 	movhi	r5,3
    7748:	29772f04 	addi	r5,r5,-9028
    774c:	01806544 	movi	r6,405
    7750:	01c000f4 	movhi	r7,3
    7754:	39f70c04 	addi	r7,r7,-9168
    7758:	00166c00 	call	166c0 <printf>
    775c:	003fff06 	br	775c <ip_reass_chain_frag_into_datagram_and_validate+0x374>
        ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
    7760:	e0bffe17 	ldw	r2,-8(fp)
    7764:	e0ffff17 	ldw	r3,-4(fp)
    7768:	10c00115 	stw	r3,4(r2)
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
    776c:	e0bffe17 	ldw	r2,-8(fp)
    7770:	10800783 	ldbu	r2,30(r2)
    7774:	10803fcc 	andi	r2,r2,255
    7778:	1080004c 	andi	r2,r2,1
    777c:	10006626 	beq	r2,zero,7918 <ip_reass_chain_frag_into_datagram_and_validate+0x530>
    /* and had no wholes so far */
    if (valid) {
    7780:	e0bffa17 	ldw	r2,-24(fp)
    7784:	10006226 	beq	r2,zero,7910 <ip_reass_chain_frag_into_datagram_and_validate+0x528>
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
    7788:	e0bffe17 	ldw	r2,-8(fp)
    778c:	10800117 	ldw	r2,4(r2)
    7790:	10800117 	ldw	r2,4(r2)
    7794:	1080010b 	ldhu	r2,4(r2)
    7798:	10bfffcc 	andi	r2,r2,65535
    779c:	10000226 	beq	r2,zero,77a8 <ip_reass_chain_frag_into_datagram_and_validate+0x3c0>
        valid = 0;
    77a0:	e03ffa15 	stw	zero,-24(fp)
    77a4:	00005a06 	br	7910 <ip_reass_chain_frag_into_datagram_and_validate+0x528>
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
    77a8:	e0bff717 	ldw	r2,-36(fp)
    77ac:	e0bff815 	stw	r2,-32(fp)
        q = iprh->next_pbuf;
    77b0:	e0bff717 	ldw	r2,-36(fp)
    77b4:	10c0000b 	ldhu	r3,0(r2)
    77b8:	1080008b 	ldhu	r2,2(r2)
    77bc:	1004943a 	slli	r2,r2,16
    77c0:	10c4b03a 	or	r2,r2,r3
    77c4:	e0bff915 	stw	r2,-28(fp)
        while (q != NULL) {
    77c8:	00001406 	br	781c <ip_reass_chain_frag_into_datagram_and_validate+0x434>
          iprh = (struct ip_reass_helper*)q->payload;
    77cc:	e0bff917 	ldw	r2,-28(fp)
    77d0:	10800117 	ldw	r2,4(r2)
    77d4:	e0bff715 	stw	r2,-36(fp)
          if (iprh_prev->end != iprh->start) {
    77d8:	e0bff817 	ldw	r2,-32(fp)
    77dc:	10c0018b 	ldhu	r3,6(r2)
    77e0:	e0bff717 	ldw	r2,-36(fp)
    77e4:	1080010b 	ldhu	r2,4(r2)
    77e8:	18ffffcc 	andi	r3,r3,65535
    77ec:	10bfffcc 	andi	r2,r2,65535
    77f0:	18800226 	beq	r3,r2,77fc <ip_reass_chain_frag_into_datagram_and_validate+0x414>
            valid = 0;
    77f4:	e03ffa15 	stw	zero,-24(fp)
            break;
    77f8:	00000a06 	br	7824 <ip_reass_chain_frag_into_datagram_and_validate+0x43c>
          }
          iprh_prev = iprh;
    77fc:	e0bff717 	ldw	r2,-36(fp)
    7800:	e0bff815 	stw	r2,-32(fp)
          q = iprh->next_pbuf;
    7804:	e0bff717 	ldw	r2,-36(fp)
    7808:	10c0000b 	ldhu	r3,0(r2)
    780c:	1080008b 	ldhu	r2,2(r2)
    7810:	1004943a 	slli	r2,r2,16
    7814:	10c4b03a 	or	r2,r2,r3
    7818:	e0bff915 	stw	r2,-28(fp)
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
    781c:	e0bff917 	ldw	r2,-28(fp)
    7820:	103fea1e 	bne	r2,zero,77cc <ip_reass_chain_frag_into_datagram_and_validate+0x3e4>
          iprh_prev = iprh;
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
    7824:	e0bffa17 	ldw	r2,-24(fp)
    7828:	10003926 	beq	r2,zero,7910 <ip_reass_chain_frag_into_datagram_and_validate+0x528>
          LWIP_ASSERT("sanity check", ipr->p != NULL);
    782c:	e0bffe17 	ldw	r2,-8(fp)
    7830:	10800117 	ldw	r2,4(r2)
    7834:	1000091e 	bne	r2,zero,785c <ip_reass_chain_frag_into_datagram_and_validate+0x474>
    7838:	010000f4 	movhi	r4,3
    783c:	2136ff04 	addi	r4,r4,-9220
    7840:	014000f4 	movhi	r5,3
    7844:	29773d04 	addi	r5,r5,-8972
    7848:	01806d44 	movi	r6,437
    784c:	01c000f4 	movhi	r7,3
    7850:	39f70c04 	addi	r7,r7,-9168
    7854:	00166c00 	call	166c0 <printf>
    7858:	003fff06 	br	7858 <ip_reass_chain_frag_into_datagram_and_validate+0x470>
          LWIP_ASSERT("sanity check",
    785c:	e0bffe17 	ldw	r2,-8(fp)
    7860:	10800117 	ldw	r2,4(r2)
    7864:	10c00117 	ldw	r3,4(r2)
    7868:	e0bff717 	ldw	r2,-36(fp)
    786c:	1880091e 	bne	r3,r2,7894 <ip_reass_chain_frag_into_datagram_and_validate+0x4ac>
    7870:	010000f4 	movhi	r4,3
    7874:	2136ff04 	addi	r4,r4,-9220
    7878:	014000f4 	movhi	r5,3
    787c:	29773d04 	addi	r5,r5,-8972
    7880:	01806dc4 	movi	r6,439
    7884:	01c000f4 	movhi	r7,3
    7888:	39f70c04 	addi	r7,r7,-9168
    788c:	00166c00 	call	166c0 <printf>
    7890:	003fff06 	br	7890 <ip_reass_chain_frag_into_datagram_and_validate+0x4a8>
            ((struct ip_reass_helper*)ipr->p->payload) != iprh);
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
    7894:	e0bff717 	ldw	r2,-36(fp)
    7898:	10c0000b 	ldhu	r3,0(r2)
    789c:	1080008b 	ldhu	r2,2(r2)
    78a0:	1004943a 	slli	r2,r2,16
    78a4:	10c4b03a 	or	r2,r2,r3
    78a8:	10000926 	beq	r2,zero,78d0 <ip_reass_chain_frag_into_datagram_and_validate+0x4e8>
    78ac:	010000f4 	movhi	r4,3
    78b0:	2136ff04 	addi	r4,r4,-9220
    78b4:	014000f4 	movhi	r5,3
    78b8:	29774104 	addi	r5,r5,-8956
    78bc:	01806e44 	movi	r6,441
    78c0:	01c000f4 	movhi	r7,3
    78c4:	39f70c04 	addi	r7,r7,-9168
    78c8:	00166c00 	call	166c0 <printf>
    78cc:	003fff06 	br	78cc <ip_reass_chain_frag_into_datagram_and_validate+0x4e4>
            iprh->next_pbuf == NULL);
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
    78d0:	e0bff717 	ldw	r2,-36(fp)
    78d4:	10c0018b 	ldhu	r3,6(r2)
    78d8:	e0bffe17 	ldw	r2,-8(fp)
    78dc:	1080070b 	ldhu	r2,28(r2)
    78e0:	18ffffcc 	andi	r3,r3,65535
    78e4:	10bfffcc 	andi	r2,r2,65535
    78e8:	18800926 	beq	r3,r2,7910 <ip_reass_chain_frag_into_datagram_and_validate+0x528>
    78ec:	010000f4 	movhi	r4,3
    78f0:	2136ff04 	addi	r4,r4,-9220
    78f4:	014000f4 	movhi	r5,3
    78f8:	29774a04 	addi	r5,r5,-8920
    78fc:	01806ec4 	movi	r6,443
    7900:	01c000f4 	movhi	r7,3
    7904:	39f70c04 	addi	r7,r7,-9168
    7908:	00166c00 	call	166c0 <printf>
    790c:	003fff06 	br	790c <ip_reass_chain_frag_into_datagram_and_validate+0x524>
      }
    }
    /* If valid is 0 here, there are some fragments missing in the middle
     * (since MF == 0 has already arrived). Such datagrams simply time out if
     * no more fragments are received... */
    return valid;
    7910:	e0bffa17 	ldw	r2,-24(fp)
    7914:	00000e06 	br	7950 <ip_reass_chain_frag_into_datagram_and_validate+0x568>
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
    7918:	0005883a 	mov	r2,zero
    791c:	00000c06 	br	7950 <ip_reass_chain_frag_into_datagram_and_validate+0x568>
        ipr->p = new_p;
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
    7920:	0001883a 	nop
    7924:	00000106 	br	792c <ip_reass_chain_frag_into_datagram_and_validate+0x544>
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
    7928:	0001883a 	nop
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
    792c:	d428cc0b 	ldhu	r16,-23760(gp)
    7930:	e13fff17 	ldw	r4,-4(fp)
    7934:	000a3380 	call	a338 <pbuf_clen>
    7938:	10803fcc 	andi	r2,r2,255
    793c:	8085c83a 	sub	r2,r16,r2
    7940:	d0a8cc0d 	sth	r2,-23760(gp)
  pbuf_free(new_p);
    7944:	e13fff17 	ldw	r4,-4(fp)
    7948:	000a16c0 	call	a16c <pbuf_free>
  return 0;
    794c:	0005883a 	mov	r2,zero
#endif /* IP_REASS_CHECK_OVERLAP */
}
    7950:	e037883a 	mov	sp,fp
    7954:	dfc00217 	ldw	ra,8(sp)
    7958:	df000117 	ldw	fp,4(sp)
    795c:	dc000017 	ldw	r16,0(sp)
    7960:	dec00304 	addi	sp,sp,12
    7964:	f800283a 	ret

00007968 <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
    7968:	defff504 	addi	sp,sp,-44
    796c:	dfc00a15 	stw	ra,40(sp)
    7970:	df000915 	stw	fp,36(sp)
    7974:	dc000815 	stw	r16,32(sp)
    7978:	df000804 	addi	fp,sp,32
    797c:	e13fff15 	stw	r4,-4(fp)
  struct ip_hdr *fraghdr;
  struct ip_reassdata *ipr;
  struct ip_reass_helper *iprh;
  u16_t offset, len;
  u8_t clen;
  struct ip_reassdata *ipr_prev = NULL;
    7980:	e03ffa15 	stw	zero,-24(fp)

  IPFRAG_STATS_INC(ip_frag.recv);
    7984:	00800134 	movhi	r2,4
    7988:	108d9504 	addi	r2,r2,13908
    798c:	10800c8b 	ldhu	r2,50(r2)
    7990:	10800044 	addi	r2,r2,1
    7994:	1007883a 	mov	r3,r2
    7998:	00800134 	movhi	r2,4
    799c:	108d9504 	addi	r2,r2,13908
    79a0:	10c00c8d 	sth	r3,50(r2)
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
    79a4:	e0bfff17 	ldw	r2,-4(fp)
    79a8:	10800117 	ldw	r2,4(r2)
    79ac:	e0bffb15 	stw	r2,-20(fp)

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
    79b0:	e0bffb17 	ldw	r2,-20(fp)
    79b4:	1080000b 	ldhu	r2,0(r2)
    79b8:	10bfffcc 	andi	r2,r2,65535
    79bc:	1004d23a 	srli	r2,r2,8
    79c0:	10ffffcc 	andi	r3,r2,65535
    79c4:	e0bffb17 	ldw	r2,-20(fp)
    79c8:	1080000b 	ldhu	r2,0(r2)
    79cc:	10bfffcc 	andi	r2,r2,65535
    79d0:	1004923a 	slli	r2,r2,8
    79d4:	10bfffcc 	andi	r2,r2,65535
    79d8:	1884b03a 	or	r2,r3,r2
    79dc:	1005d23a 	srai	r2,r2,8
    79e0:	108003cc 	andi	r2,r2,15
    79e4:	1085883a 	add	r2,r2,r2
    79e8:	1085883a 	add	r2,r2,r2
    79ec:	10800520 	cmpeqi	r2,r2,20
    79f0:	1000091e 	bne	r2,zero,7a18 <ip_reass+0xb0>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    79f4:	00800134 	movhi	r2,4
    79f8:	108d9504 	addi	r2,r2,13908
    79fc:	1080110b 	ldhu	r2,68(r2)
    7a00:	10800044 	addi	r2,r2,1
    7a04:	1007883a 	mov	r3,r2
    7a08:	00800134 	movhi	r2,4
    7a0c:	108d9504 	addi	r2,r2,13908
    7a10:	10c0110d 	sth	r3,68(r2)
    goto nullreturn;
    7a14:	00010b06 	br	7e44 <ip_reass+0x4dc>
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
    7a18:	e0bffb17 	ldw	r2,-20(fp)
    7a1c:	1080018b 	ldhu	r2,6(r2)
    7a20:	10bfffcc 	andi	r2,r2,65535
    7a24:	1004d23a 	srli	r2,r2,8
    7a28:	10ffffcc 	andi	r3,r2,65535
    7a2c:	e0bffb17 	ldw	r2,-20(fp)
    7a30:	1080018b 	ldhu	r2,6(r2)
    7a34:	10bfffcc 	andi	r2,r2,65535
    7a38:	1004923a 	slli	r2,r2,8
    7a3c:	10bfffcc 	andi	r2,r2,65535
    7a40:	1884b03a 	or	r2,r3,r2
    7a44:	1087ffcc 	andi	r2,r2,8191
    7a48:	100490fa 	slli	r2,r2,3
    7a4c:	e0bffc0d 	sth	r2,-16(fp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    7a50:	e0bffb17 	ldw	r2,-20(fp)
    7a54:	1080008b 	ldhu	r2,2(r2)
    7a58:	10bfffcc 	andi	r2,r2,65535
    7a5c:	1004d23a 	srli	r2,r2,8
    7a60:	1007883a 	mov	r3,r2
    7a64:	e0bffb17 	ldw	r2,-20(fp)
    7a68:	1080008b 	ldhu	r2,2(r2)
    7a6c:	10bfffcc 	andi	r2,r2,65535
    7a70:	1004923a 	slli	r2,r2,8
    7a74:	1884b03a 	or	r2,r3,r2
    7a78:	1007883a 	mov	r3,r2
    7a7c:	e0bffb17 	ldw	r2,-20(fp)
    7a80:	1080000b 	ldhu	r2,0(r2)
    7a84:	10bfffcc 	andi	r2,r2,65535
    7a88:	1004d23a 	srli	r2,r2,8
    7a8c:	113fffcc 	andi	r4,r2,65535
    7a90:	e0bffb17 	ldw	r2,-20(fp)
    7a94:	1080000b 	ldhu	r2,0(r2)
    7a98:	10bfffcc 	andi	r2,r2,65535
    7a9c:	1004923a 	slli	r2,r2,8
    7aa0:	10bfffcc 	andi	r2,r2,65535
    7aa4:	2084b03a 	or	r2,r4,r2
    7aa8:	1005d23a 	srai	r2,r2,8
    7aac:	108003cc 	andi	r2,r2,15
    7ab0:	10bfff24 	muli	r2,r2,-4
    7ab4:	1885883a 	add	r2,r3,r2
    7ab8:	e0bffc8d 	sth	r2,-14(fp)

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
    7abc:	e13fff17 	ldw	r4,-4(fp)
    7ac0:	000a3380 	call	a338 <pbuf_clen>
    7ac4:	e0bffd05 	stb	r2,-12(fp)
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
    7ac8:	d0a8cc0b 	ldhu	r2,-23760(gp)
    7acc:	10ffffcc 	andi	r3,r2,65535
    7ad0:	e0bffd03 	ldbu	r2,-12(fp)
    7ad4:	1885883a 	add	r2,r3,r2
    7ad8:	108002d0 	cmplti	r2,r2,11
    7adc:	1000141e 	bne	r2,zero,7b30 <ip_reass+0x1c8>
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
    7ae0:	e0bffd03 	ldbu	r2,-12(fp)
    7ae4:	e13ffb17 	ldw	r4,-20(fp)
    7ae8:	100b883a 	mov	r5,r2
    7aec:	00071280 	call	7128 <ip_reass_remove_oldest_datagram>
    7af0:	10000626 	beq	r2,zero,7b0c <ip_reass+0x1a4>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
    7af4:	d0a8cc0b 	ldhu	r2,-23760(gp)
    7af8:	10ffffcc 	andi	r3,r2,65535
    7afc:	e0bffd03 	ldbu	r2,-12(fp)
    7b00:	1885883a 	add	r2,r3,r2

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
    7b04:	108002d0 	cmplti	r2,r2,11
    7b08:	1000091e 	bne	r2,zero,7b30 <ip_reass+0x1c8>
#endif /* IP_REASS_FREE_OLDEST */
    {
      /* No datagram could be freed and still too many pbufs enqueued */
      LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: Overflow condition: pbufct=%d, clen=%d, MAX=%d\n",
        ip_reass_pbufcount, clen, IP_REASS_MAX_PBUFS));
      IPFRAG_STATS_INC(ip_frag.memerr);
    7b0c:	00800134 	movhi	r2,4
    7b10:	108d9504 	addi	r2,r2,13908
    7b14:	10800f0b 	ldhu	r2,60(r2)
    7b18:	10800044 	addi	r2,r2,1
    7b1c:	1007883a 	mov	r3,r2
    7b20:	00800134 	movhi	r2,4
    7b24:	108d9504 	addi	r2,r2,13908
    7b28:	10c00f0d 	sth	r3,60(r2)
      /* @todo: send ICMP time exceeded here? */
      /* drop this pbuf */
      goto nullreturn;
    7b2c:	0000c506 	br	7e44 <ip_reass+0x4dc>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
    7b30:	d0a8cb17 	ldw	r2,-23764(gp)
    7b34:	e0bff915 	stw	r2,-28(fp)
    7b38:	00002506 	br	7bd0 <ip_reass+0x268>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
    7b3c:	e0bff917 	ldw	r2,-28(fp)
    7b40:	10c00517 	ldw	r3,20(r2)
    7b44:	e0bffb17 	ldw	r2,-20(fp)
    7b48:	1100030b 	ldhu	r4,12(r2)
    7b4c:	1080038b 	ldhu	r2,14(r2)
    7b50:	1004943a 	slli	r2,r2,16
    7b54:	1104b03a 	or	r2,r2,r4
    7b58:	1880181e 	bne	r3,r2,7bbc <ip_reass+0x254>
    7b5c:	e0bff917 	ldw	r2,-28(fp)
    7b60:	10c00617 	ldw	r3,24(r2)
    7b64:	e0bffb17 	ldw	r2,-20(fp)
    7b68:	1100040b 	ldhu	r4,16(r2)
    7b6c:	1080048b 	ldhu	r2,18(r2)
    7b70:	1004943a 	slli	r2,r2,16
    7b74:	1104b03a 	or	r2,r2,r4
    7b78:	1880101e 	bne	r3,r2,7bbc <ip_reass+0x254>
    7b7c:	e0bff917 	ldw	r2,-28(fp)
    7b80:	10c0030b 	ldhu	r3,12(r2)
    7b84:	e0bffb17 	ldw	r2,-20(fp)
    7b88:	1080010b 	ldhu	r2,4(r2)
    7b8c:	18ffffcc 	andi	r3,r3,65535
    7b90:	10bfffcc 	andi	r2,r2,65535
    7b94:	1880091e 	bne	r3,r2,7bbc <ip_reass+0x254>
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass: matching previous fragment ID=%"X16_F"\n",
        ntohs(IPH_ID(fraghdr))));
      IPFRAG_STATS_INC(ip_frag.cachehit);
    7b98:	00800134 	movhi	r2,4
    7b9c:	108d9504 	addi	r2,r2,13908
    7ba0:	1080118b 	ldhu	r2,70(r2)
    7ba4:	10800044 	addi	r2,r2,1
    7ba8:	1007883a 	mov	r3,r2
    7bac:	00800134 	movhi	r2,4
    7bb0:	108d9504 	addi	r2,r2,13908
    7bb4:	10c0118d 	sth	r3,70(r2)
      break;
    7bb8:	00000706 	br	7bd8 <ip_reass+0x270>
    }
    ipr_prev = ipr;
    7bbc:	e0bff917 	ldw	r2,-28(fp)
    7bc0:	e0bffa15 	stw	r2,-24(fp)
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
    7bc4:	e0bff917 	ldw	r2,-28(fp)
    7bc8:	10800017 	ldw	r2,0(r2)
    7bcc:	e0bff915 	stw	r2,-28(fp)
    7bd0:	e0bff917 	ldw	r2,-28(fp)
    7bd4:	103fd91e 	bne	r2,zero,7b3c <ip_reass+0x1d4>
      break;
    }
    ipr_prev = ipr;
  }

  if (ipr == NULL) {
    7bd8:	e0bff917 	ldw	r2,-28(fp)
    7bdc:	1000081e 	bne	r2,zero,7c00 <ip_reass+0x298>
  /* Enqueue a new datagram into the datagram queue */
    ipr = ip_reass_enqueue_new_datagram(fraghdr, clen);
    7be0:	e0bffd03 	ldbu	r2,-12(fp)
    7be4:	e13ffb17 	ldw	r4,-20(fp)
    7be8:	100b883a 	mov	r5,r2
    7bec:	000727c0 	call	727c <ip_reass_enqueue_new_datagram>
    7bf0:	e0bff915 	stw	r2,-28(fp)
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
    7bf4:	e0bff917 	ldw	r2,-28(fp)
    7bf8:	1000211e 	bne	r2,zero,7c80 <ip_reass+0x318>
      goto nullreturn;
    7bfc:	00009106 	br	7e44 <ip_reass+0x4dc>
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
    7c00:	e0bffb17 	ldw	r2,-20(fp)
    7c04:	1080018b 	ldhu	r2,6(r2)
    7c08:	10bfffcc 	andi	r2,r2,65535
    7c0c:	1004d23a 	srli	r2,r2,8
    7c10:	10ffffcc 	andi	r3,r2,65535
    7c14:	e0bffb17 	ldw	r2,-20(fp)
    7c18:	1080018b 	ldhu	r2,6(r2)
    7c1c:	10bfffcc 	andi	r2,r2,65535
    7c20:	1004923a 	slli	r2,r2,8
    7c24:	10bfffcc 	andi	r2,r2,65535
    7c28:	1884b03a 	or	r2,r3,r2
    7c2c:	1087ffcc 	andi	r2,r2,8191
    7c30:	1000131e 	bne	r2,zero,7c80 <ip_reass+0x318>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
    7c34:	e0bff917 	ldw	r2,-28(fp)
    7c38:	1080038b 	ldhu	r2,14(r2)
    7c3c:	10bfffcc 	andi	r2,r2,65535
    7c40:	1004d23a 	srli	r2,r2,8
    7c44:	10ffffcc 	andi	r3,r2,65535
    7c48:	e0bff917 	ldw	r2,-28(fp)
    7c4c:	1080038b 	ldhu	r2,14(r2)
    7c50:	10bfffcc 	andi	r2,r2,65535
    7c54:	1004923a 	slli	r2,r2,8
    7c58:	10bfffcc 	andi	r2,r2,65535
    7c5c:	1884b03a 	or	r2,r3,r2
    7c60:	1087ffcc 	andi	r2,r2,8191
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
    7c64:	10000626 	beq	r2,zero,7c80 <ip_reass+0x318>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
    7c68:	e0bff917 	ldw	r2,-28(fp)
    7c6c:	10800204 	addi	r2,r2,8
    7c70:	1009883a 	mov	r4,r2
    7c74:	e17ffb17 	ldw	r5,-20(fp)
    7c78:	01800504 	movi	r6,20
    7c7c:	00164c00 	call	164c0 <memcpy>
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
    7c80:	e0fffd03 	ldbu	r3,-12(fp)
    7c84:	d0a8cc0b 	ldhu	r2,-23760(gp)
    7c88:	1885883a 	add	r2,r3,r2
    7c8c:	d0a8cc0d 	sth	r2,-23760(gp)

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
    7c90:	e0bffb17 	ldw	r2,-20(fp)
    7c94:	1080018b 	ldhu	r2,6(r2)
    7c98:	10bfffcc 	andi	r2,r2,65535
    7c9c:	1004d23a 	srli	r2,r2,8
    7ca0:	10ffffcc 	andi	r3,r2,65535
    7ca4:	e0bffb17 	ldw	r2,-20(fp)
    7ca8:	1080018b 	ldhu	r2,6(r2)
    7cac:	10bfffcc 	andi	r2,r2,65535
    7cb0:	1004923a 	slli	r2,r2,8
    7cb4:	10bfffcc 	andi	r2,r2,65535
    7cb8:	1884b03a 	or	r2,r3,r2
    7cbc:	1088000c 	andi	r2,r2,8192
    7cc0:	10000c1e 	bne	r2,zero,7cf4 <ip_reass+0x38c>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
    7cc4:	e0bff917 	ldw	r2,-28(fp)
    7cc8:	10800783 	ldbu	r2,30(r2)
    7ccc:	10800054 	ori	r2,r2,1
    7cd0:	1007883a 	mov	r3,r2
    7cd4:	e0bff917 	ldw	r2,-28(fp)
    7cd8:	10c00785 	stb	r3,30(r2)
    ipr->datagram_len = offset + len;
    7cdc:	e0fffc0b 	ldhu	r3,-16(fp)
    7ce0:	e0bffc8b 	ldhu	r2,-14(fp)
    7ce4:	1885883a 	add	r2,r3,r2
    7ce8:	1007883a 	mov	r3,r2
    7cec:	e0bff917 	ldw	r2,-28(fp)
    7cf0:	10c0070d 	sth	r3,28(r2)
     ("ip_reass: last fragment seen, total len %"S16_F"\n",
      ipr->datagram_len));
  }
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
    7cf4:	e13ff917 	ldw	r4,-28(fp)
    7cf8:	e17fff17 	ldw	r5,-4(fp)
    7cfc:	00073e80 	call	73e8 <ip_reass_chain_frag_into_datagram_and_validate>
    7d00:	10004e26 	beq	r2,zero,7e3c <ip_reass+0x4d4>
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
    7d04:	e0bff917 	ldw	r2,-28(fp)
    7d08:	1080070b 	ldhu	r2,28(r2)
    7d0c:	10800504 	addi	r2,r2,20
    7d10:	1007883a 	mov	r3,r2
    7d14:	e0bff917 	ldw	r2,-28(fp)
    7d18:	10c0070d 	sth	r3,28(r2)

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
    7d1c:	e0bff917 	ldw	r2,-28(fp)
    7d20:	10800117 	ldw	r2,4(r2)
    7d24:	10800117 	ldw	r2,4(r2)
    7d28:	10c0000b 	ldhu	r3,0(r2)
    7d2c:	1080008b 	ldhu	r2,2(r2)
    7d30:	1004943a 	slli	r2,r2,16
    7d34:	10c4b03a 	or	r2,r2,r3
    7d38:	e0bff815 	stw	r2,-32(fp)

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
    7d3c:	e0bff917 	ldw	r2,-28(fp)
    7d40:	10800117 	ldw	r2,4(r2)
    7d44:	10800117 	ldw	r2,4(r2)
    7d48:	e0bffb15 	stw	r2,-20(fp)
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
    7d4c:	e0bff917 	ldw	r2,-28(fp)
    7d50:	10800204 	addi	r2,r2,8
    7d54:	e13ffb17 	ldw	r4,-20(fp)
    7d58:	100b883a 	mov	r5,r2
    7d5c:	01800504 	movi	r6,20
    7d60:	00164c00 	call	164c0 <memcpy>
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
    7d64:	e0bff917 	ldw	r2,-28(fp)
    7d68:	1080070b 	ldhu	r2,28(r2)
    7d6c:	10bfffcc 	andi	r2,r2,65535
    7d70:	1004d23a 	srli	r2,r2,8
    7d74:	1007883a 	mov	r3,r2
    7d78:	e0bff917 	ldw	r2,-28(fp)
    7d7c:	1080070b 	ldhu	r2,28(r2)
    7d80:	10bfffcc 	andi	r2,r2,65535
    7d84:	1004923a 	slli	r2,r2,8
    7d88:	1884b03a 	or	r2,r3,r2
    7d8c:	1007883a 	mov	r3,r2
    7d90:	e0bffb17 	ldw	r2,-20(fp)
    7d94:	10c0008d 	sth	r3,2(r2)
    IPH_OFFSET_SET(fraghdr, 0);
    7d98:	e0bffb17 	ldw	r2,-20(fp)
    7d9c:	1000018d 	sth	zero,6(r2)
    IPH_CHKSUM_SET(fraghdr, 0);
    7da0:	e0bffb17 	ldw	r2,-20(fp)
    7da4:	1000028d 	sth	zero,10(r2)
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
    7da8:	e13ffb17 	ldw	r4,-20(fp)
    7dac:	01400504 	movi	r5,20
    7db0:	00060440 	call	6044 <inet_chksum>
    7db4:	e0fffb17 	ldw	r3,-20(fp)
    7db8:	1880028d 	sth	r2,10(r3)

    p = ipr->p;
    7dbc:	e0bff917 	ldw	r2,-28(fp)
    7dc0:	10800117 	ldw	r2,4(r2)
    7dc4:	e0bfff15 	stw	r2,-4(fp)

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
    7dc8:	00000f06 	br	7e08 <ip_reass+0x4a0>
      iprh = (struct ip_reass_helper*)r->payload;
    7dcc:	e0bff817 	ldw	r2,-32(fp)
    7dd0:	10800117 	ldw	r2,4(r2)
    7dd4:	e0bffe15 	stw	r2,-8(fp)

      /* hide the ip header for every succeding fragment */
      pbuf_header(r, -IP_HLEN);
    7dd8:	e13ff817 	ldw	r4,-32(fp)
    7ddc:	017ffb04 	movi	r5,-20
    7de0:	0009f740 	call	9f74 <pbuf_header>
      pbuf_cat(p, r);
    7de4:	e13fff17 	ldw	r4,-4(fp)
    7de8:	e17ff817 	ldw	r5,-32(fp)
    7dec:	000a3c40 	call	a3c4 <pbuf_cat>
      r = iprh->next_pbuf;
    7df0:	e0bffe17 	ldw	r2,-8(fp)
    7df4:	10c0000b 	ldhu	r3,0(r2)
    7df8:	1080008b 	ldhu	r2,2(r2)
    7dfc:	1004943a 	slli	r2,r2,16
    7e00:	10c4b03a 	or	r2,r2,r3
    7e04:	e0bff815 	stw	r2,-32(fp)
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
    7e08:	e0bff817 	ldw	r2,-32(fp)
    7e0c:	103fef1e 	bne	r2,zero,7dcc <ip_reass+0x464>
      pbuf_header(r, -IP_HLEN);
      pbuf_cat(p, r);
      r = iprh->next_pbuf;
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
    7e10:	e13ff917 	ldw	r4,-28(fp)
    7e14:	e17ffa17 	ldw	r5,-24(fp)
    7e18:	00073580 	call	7358 <ip_reass_dequeue_datagram>

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
    7e1c:	d428cc0b 	ldhu	r16,-23760(gp)
    7e20:	e13fff17 	ldw	r4,-4(fp)
    7e24:	000a3380 	call	a338 <pbuf_clen>
    7e28:	10803fcc 	andi	r2,r2,255
    7e2c:	8085c83a 	sub	r2,r16,r2
    7e30:	d0a8cc0d 	sth	r2,-23760(gp)

    /* Return the pbuf chain */
    return p;
    7e34:	e0bfff17 	ldw	r2,-4(fp)
    7e38:	00000d06 	br	7e70 <ip_reass+0x508>
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
    7e3c:	0005883a 	mov	r2,zero
    7e40:	00000b06 	br	7e70 <ip_reass+0x508>

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
    7e44:	00800134 	movhi	r2,4
    7e48:	108d9504 	addi	r2,r2,13908
    7e4c:	10800d8b 	ldhu	r2,54(r2)
    7e50:	10800044 	addi	r2,r2,1
    7e54:	1007883a 	mov	r3,r2
    7e58:	00800134 	movhi	r2,4
    7e5c:	108d9504 	addi	r2,r2,13908
    7e60:	10c00d8d 	sth	r3,54(r2)
  pbuf_free(p);
    7e64:	e13fff17 	ldw	r4,-4(fp)
    7e68:	000a16c0 	call	a16c <pbuf_free>
  return NULL;
    7e6c:	0005883a 	mov	r2,zero
}
    7e70:	e037883a 	mov	sp,fp
    7e74:	dfc00217 	ldw	ra,8(sp)
    7e78:	df000117 	ldw	fp,4(sp)
    7e7c:	dc000017 	ldw	r16,0(sp)
    7e80:	dec00304 	addi	sp,sp,12
    7e84:	f800283a 	ret

00007e88 <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
    7e88:	defff304 	addi	sp,sp,-52
    7e8c:	dfc00c15 	stw	ra,48(sp)
    7e90:	df000b15 	stw	fp,44(sp)
    7e94:	df000b04 	addi	fp,sp,44
    7e98:	e13ffd15 	stw	r4,-12(fp)
    7e9c:	e17ffe15 	stw	r5,-8(fp)
    7ea0:	e1bfff15 	stw	r6,-4(fp)
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
    7ea4:	e0bffe17 	ldw	r2,-8(fp)
    7ea8:	1080090b 	ldhu	r2,36(r2)
    7eac:	e0bff70d 	sth	r2,-36(fp)
  u16_t ofo, omf;
  u16_t last;
  u16_t poff = IP_HLEN;
    7eb0:	00800504 	movi	r2,20
    7eb4:	e0bff60d 	sth	r2,-40(fp)
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
    7eb8:	01000084 	movi	r4,2
    7ebc:	000b883a 	mov	r5,zero
    7ec0:	01800084 	movi	r6,2
    7ec4:	00097b00 	call	97b0 <pbuf_alloc>
    7ec8:	e0bff815 	stw	r2,-32(fp)
  if (rambuf == NULL) {
    7ecc:	e0bff817 	ldw	r2,-32(fp)
    7ed0:	1000021e 	bne	r2,zero,7edc <ip_frag+0x54>
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
    7ed4:	00bfffc4 	movi	r2,-1
    7ed8:	0000a706 	br	8178 <ip_frag+0x2f0>
  }
  rambuf->tot_len = rambuf->len = mtu;
    7edc:	e0bff817 	ldw	r2,-32(fp)
    7ee0:	e0fff70b 	ldhu	r3,-36(fp)
    7ee4:	10c0028d 	sth	r3,10(r2)
    7ee8:	e0bff817 	ldw	r2,-32(fp)
    7eec:	10c0028b 	ldhu	r3,10(r2)
    7ef0:	e0bff817 	ldw	r2,-32(fp)
    7ef4:	10c0020d 	sth	r3,8(r2)
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
    7ef8:	008000f4 	movhi	r2,3
    7efc:	10961d04 	addi	r2,r2,22644
    7f00:	10c000c4 	addi	r3,r2,3
    7f04:	00bfff04 	movi	r2,-4
    7f08:	1884703a 	and	r2,r3,r2
    7f0c:	1007883a 	mov	r3,r2
    7f10:	e0bff817 	ldw	r2,-32(fp)
    7f14:	10c00115 	stw	r3,4(r2)

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
    7f18:	e0bff817 	ldw	r2,-32(fp)
    7f1c:	10800117 	ldw	r2,4(r2)
    7f20:	e0bff915 	stw	r2,-28(fp)
  SMEMCPY(iphdr, p->payload, IP_HLEN);
    7f24:	e0bffd17 	ldw	r2,-12(fp)
    7f28:	10800117 	ldw	r2,4(r2)
    7f2c:	e13ff917 	ldw	r4,-28(fp)
    7f30:	100b883a 	mov	r5,r2
    7f34:	01800504 	movi	r6,20
    7f38:	00164c00 	call	164c0 <memcpy>
  original_iphdr = p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
    7f3c:	e0bff917 	ldw	r2,-28(fp)
    7f40:	1080018b 	ldhu	r2,6(r2)
    7f44:	10bfffcc 	andi	r2,r2,65535
    7f48:	1004d23a 	srli	r2,r2,8
    7f4c:	1007883a 	mov	r3,r2
    7f50:	e0bff917 	ldw	r2,-28(fp)
    7f54:	1080018b 	ldhu	r2,6(r2)
    7f58:	10bfffcc 	andi	r2,r2,65535
    7f5c:	1004923a 	slli	r2,r2,8
    7f60:	1884b03a 	or	r2,r3,r2
    7f64:	e0bff68d 	sth	r2,-38(fp)
  ofo = tmp & IP_OFFMASK;
    7f68:	e0bff68b 	ldhu	r2,-38(fp)
    7f6c:	1087ffcc 	andi	r2,r2,8191
    7f70:	e0bff58d 	sth	r2,-42(fp)
  omf = tmp & IP_MF;
    7f74:	e0bff68b 	ldhu	r2,-38(fp)
    7f78:	1088000c 	andi	r2,r2,8192
    7f7c:	e0bffa0d 	sth	r2,-24(fp)

  left = p->tot_len - IP_HLEN;
    7f80:	e0bffd17 	ldw	r2,-12(fp)
    7f84:	1080020b 	ldhu	r2,8(r2)
    7f88:	10bffb04 	addi	r2,r2,-20
    7f8c:	e0bff50d 	sth	r2,-44(fp)

  nfb = (mtu - IP_HLEN) / 8;
    7f90:	e0bff70b 	ldhu	r2,-36(fp)
    7f94:	10bffb04 	addi	r2,r2,-20
    7f98:	1000010e 	bge	r2,zero,7fa0 <ip_frag+0x118>
    7f9c:	108001c4 	addi	r2,r2,7
    7fa0:	1005d0fa 	srai	r2,r2,3
    7fa4:	e0bffa8d 	sth	r2,-22(fp)

  while (left) {
    7fa8:	00006e06 	br	8164 <ip_frag+0x2dc>
    last = (left <= mtu - IP_HLEN);
    7fac:	e0bff50b 	ldhu	r2,-44(fp)
    7fb0:	e0fff70b 	ldhu	r3,-36(fp)
    7fb4:	18fffb04 	addi	r3,r3,-20
    7fb8:	1884403a 	cmpge	r2,r3,r2
    7fbc:	10803fcc 	andi	r2,r2,255
    7fc0:	e0bffb0d 	sth	r2,-20(fp)

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
    7fc4:	e0bff58b 	ldhu	r2,-42(fp)
    7fc8:	1087ffcc 	andi	r2,r2,8191
    7fcc:	1007883a 	mov	r3,r2
    7fd0:	e0bffa0b 	ldhu	r2,-24(fp)
    7fd4:	1884b03a 	or	r2,r3,r2
    7fd8:	e0bff68d 	sth	r2,-38(fp)
    if (!last)
    7fdc:	e0bffb0b 	ldhu	r2,-20(fp)
    7fe0:	1000031e 	bne	r2,zero,7ff0 <ip_frag+0x168>
      tmp = tmp | IP_MF;
    7fe4:	e0bff68b 	ldhu	r2,-38(fp)
    7fe8:	10880014 	ori	r2,r2,8192
    7fec:	e0bff68d 	sth	r2,-38(fp)

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
    7ff0:	e0bffb0b 	ldhu	r2,-20(fp)
    7ff4:	1000031e 	bne	r2,zero,8004 <ip_frag+0x17c>
    7ff8:	e0bffa8b 	ldhu	r2,-22(fp)
    7ffc:	100490fa 	slli	r2,r2,3
    8000:	00000106 	br	8008 <ip_frag+0x180>
    8004:	e0bff50b 	ldhu	r2,-44(fp)
    8008:	e0bffb8d 	sth	r2,-18(fp)

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
    800c:	e0bff917 	ldw	r2,-28(fp)
    8010:	11400504 	addi	r5,r2,20
    8014:	e0fffb8b 	ldhu	r3,-18(fp)
    8018:	e0bff60b 	ldhu	r2,-40(fp)
    801c:	e13ffd17 	ldw	r4,-12(fp)
    8020:	180d883a 	mov	r6,r3
    8024:	100f883a 	mov	r7,r2
    8028:	000a9340 	call	a934 <pbuf_copy_partial>
    802c:	e0fff60b 	ldhu	r3,-40(fp)
    8030:	10c5883a 	add	r2,r2,r3
    8034:	e0bff60d 	sth	r2,-40(fp)
    }
    poff = newpbuflen;
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
    8038:	e0bff68b 	ldhu	r2,-38(fp)
    803c:	1004d23a 	srli	r2,r2,8
    8040:	1007883a 	mov	r3,r2
    8044:	e0bff68b 	ldhu	r2,-38(fp)
    8048:	1004923a 	slli	r2,r2,8
    804c:	1884b03a 	or	r2,r3,r2
    8050:	1007883a 	mov	r3,r2
    8054:	e0bff917 	ldw	r2,-28(fp)
    8058:	10c0018d 	sth	r3,6(r2)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
    805c:	e0bffb8b 	ldhu	r2,-18(fp)
    8060:	10800504 	addi	r2,r2,20
    8064:	10bfc00c 	andi	r2,r2,65280
    8068:	1005d23a 	srai	r2,r2,8
    806c:	1007883a 	mov	r3,r2
    8070:	e0bffb8b 	ldhu	r2,-18(fp)
    8074:	10800504 	addi	r2,r2,20
    8078:	1004923a 	slli	r2,r2,8
    807c:	1884b03a 	or	r2,r3,r2
    8080:	1007883a 	mov	r3,r2
    8084:	e0bff917 	ldw	r2,-28(fp)
    8088:	10c0008d 	sth	r3,2(r2)
    IPH_CHKSUM_SET(iphdr, 0);
    808c:	e0bff917 	ldw	r2,-28(fp)
    8090:	1000028d 	sth	zero,10(r2)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
    8094:	e13ff917 	ldw	r4,-28(fp)
    8098:	01400504 	movi	r5,20
    809c:	00060440 	call	6044 <inet_chksum>
    80a0:	e0fff917 	ldw	r3,-28(fp)
    80a4:	1880028d 	sth	r2,10(r3)

#if IP_FRAG_USES_STATIC_BUF
    if (last)
    80a8:	e0bffb0b 	ldhu	r2,-20(fp)
    80ac:	10000626 	beq	r2,zero,80c8 <ip_frag+0x240>
      pbuf_realloc(rambuf, left + IP_HLEN);
    80b0:	e0bff50b 	ldhu	r2,-44(fp)
    80b4:	10800504 	addi	r2,r2,20
    80b8:	10bfffcc 	andi	r2,r2,65535
    80bc:	e13ff817 	ldw	r4,-32(fp)
    80c0:	100b883a 	mov	r5,r2
    80c4:	0009cf00 	call	9cf0 <pbuf_realloc>
    /* This part is ugly: we alloc a RAM based pbuf for 
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
    80c8:	01000084 	movi	r4,2
    80cc:	000b883a 	mov	r5,zero
    80d0:	000d883a 	mov	r6,zero
    80d4:	00097b00 	call	97b0 <pbuf_alloc>
    80d8:	e0bffc15 	stw	r2,-16(fp)
    if (header != NULL) {
    80dc:	e0bffc17 	ldw	r2,-16(fp)
    80e0:	10001c26 	beq	r2,zero,8154 <ip_frag+0x2cc>
      pbuf_chain(header, rambuf);
    80e4:	e13ffc17 	ldw	r4,-16(fp)
    80e8:	e17ff817 	ldw	r5,-32(fp)
    80ec:	000a5040 	call	a504 <pbuf_chain>
      netif->output(netif, header, dest);
    80f0:	e0bffe17 	ldw	r2,-8(fp)
    80f4:	10800517 	ldw	r2,20(r2)
    80f8:	e13ffe17 	ldw	r4,-8(fp)
    80fc:	e17ffc17 	ldw	r5,-16(fp)
    8100:	e1bfff17 	ldw	r6,-4(fp)
    8104:	103ee83a 	callr	r2
      IPFRAG_STATS_INC(ip_frag.xmit);
    8108:	00800134 	movhi	r2,4
    810c:	108d9504 	addi	r2,r2,13908
    8110:	10800c0b 	ldhu	r2,48(r2)
    8114:	10800044 	addi	r2,r2,1
    8118:	1007883a 	mov	r3,r2
    811c:	00800134 	movhi	r2,4
    8120:	108d9504 	addi	r2,r2,13908
    8124:	10c00c0d 	sth	r3,48(r2)
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    8128:	e13ffc17 	ldw	r4,-16(fp)
    812c:	000a16c0 	call	a16c <pbuf_free>
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    8130:	e0fff50b 	ldhu	r3,-44(fp)
    8134:	e0bffb8b 	ldhu	r2,-18(fp)
    8138:	1885c83a 	sub	r2,r3,r2
    813c:	e0bff50d 	sth	r2,-44(fp)
    ofo += nfb;
    8140:	e0fff58b 	ldhu	r3,-42(fp)
    8144:	e0bffa8b 	ldhu	r2,-22(fp)
    8148:	1885883a 	add	r2,r3,r2
    814c:	e0bff58d 	sth	r2,-42(fp)
    8150:	00000406 	br	8164 <ip_frag+0x2dc>
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
    8154:	e13ff817 	ldw	r4,-32(fp)
    8158:	000a16c0 	call	a16c <pbuf_free>
      return ERR_MEM;
    815c:	00bfffc4 	movi	r2,-1
    8160:	00000506 	br	8178 <ip_frag+0x2f0>

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
    8164:	e0bff50b 	ldhu	r2,-44(fp)
    8168:	103f901e 	bne	r2,zero,7fac <ip_frag+0x124>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
    816c:	e13ff817 	ldw	r4,-32(fp)
    8170:	000a16c0 	call	a16c <pbuf_free>
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
    8174:	0005883a 	mov	r2,zero
}
    8178:	e037883a 	mov	sp,fp
    817c:	dfc00117 	ldw	ra,4(sp)
    8180:	df000017 	ldw	fp,0(sp)
    8184:	dec00204 	addi	sp,sp,8
    8188:	f800283a 	ret

0000818c <plug_holes>:
 * This assumes access to the heap is protected by the calling function
 * already.
 */
static void
plug_holes(struct mem *mem)
{
    818c:	defffb04 	addi	sp,sp,-20
    8190:	dfc00415 	stw	ra,16(sp)
    8194:	df000315 	stw	fp,12(sp)
    8198:	df000304 	addi	fp,sp,12
    819c:	e13fff15 	stw	r4,-4(fp)
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
    81a0:	d0a8cd17 	ldw	r2,-23756(gp)
    81a4:	e0ffff17 	ldw	r3,-4(fp)
    81a8:	1880092e 	bgeu	r3,r2,81d0 <plug_holes+0x44>
    81ac:	010000f4 	movhi	r4,3
    81b0:	21375604 	addi	r4,r4,-8872
    81b4:	014000f4 	movhi	r5,3
    81b8:	29776004 	addi	r5,r5,-8832
    81bc:	01803944 	movi	r6,229
    81c0:	01c000f4 	movhi	r7,3
    81c4:	39f76604 	addi	r7,r7,-8808
    81c8:	00166c00 	call	166c0 <printf>
    81cc:	003fff06 	br	81cc <plug_holes+0x40>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
    81d0:	d0a8ce17 	ldw	r2,-23752(gp)
    81d4:	e0ffff17 	ldw	r3,-4(fp)
    81d8:	18800936 	bltu	r3,r2,8200 <plug_holes+0x74>
    81dc:	010000f4 	movhi	r4,3
    81e0:	21375604 	addi	r4,r4,-8872
    81e4:	014000f4 	movhi	r5,3
    81e8:	29776b04 	addi	r5,r5,-8788
    81ec:	01803984 	movi	r6,230
    81f0:	01c000f4 	movhi	r7,3
    81f4:	39f76604 	addi	r7,r7,-8808
    81f8:	00166c00 	call	166c0 <printf>
    81fc:	003fff06 	br	81fc <plug_holes+0x70>
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);
    8200:	e0bfff17 	ldw	r2,-4(fp)
    8204:	10800103 	ldbu	r2,4(r2)
    8208:	10803fcc 	andi	r2,r2,255
    820c:	10000926 	beq	r2,zero,8234 <plug_holes+0xa8>
    8210:	010000f4 	movhi	r4,3
    8214:	21375604 	addi	r4,r4,-8872
    8218:	014000f4 	movhi	r5,3
    821c:	29777204 	addi	r5,r5,-8760
    8220:	018039c4 	movi	r6,231
    8224:	01c000f4 	movhi	r7,3
    8228:	39f76604 	addi	r7,r7,-8808
    822c:	00166c00 	call	166c0 <printf>
    8230:	003fff06 	br	8230 <plug_holes+0xa4>

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
    8234:	e0bfff17 	ldw	r2,-4(fp)
    8238:	1080000b 	ldhu	r2,0(r2)
    823c:	10bfffcc 	andi	r2,r2,65535
    8240:	10819070 	cmpltui	r2,r2,1601
    8244:	1000091e 	bne	r2,zero,826c <plug_holes+0xe0>
    8248:	010000f4 	movhi	r4,3
    824c:	21375604 	addi	r4,r4,-8872
    8250:	014000f4 	movhi	r5,3
    8254:	29777904 	addi	r5,r5,-8732
    8258:	01803a84 	movi	r6,234
    825c:	01c000f4 	movhi	r7,3
    8260:	39f76604 	addi	r7,r7,-8808
    8264:	00166c00 	call	166c0 <printf>
    8268:	003fff06 	br	8268 <plug_holes+0xdc>

  nmem = (struct mem *)&ram[mem->next];
    826c:	d0e8cd17 	ldw	r3,-23756(gp)
    8270:	e0bfff17 	ldw	r2,-4(fp)
    8274:	1080000b 	ldhu	r2,0(r2)
    8278:	10bfffcc 	andi	r2,r2,65535
    827c:	1885883a 	add	r2,r3,r2
    8280:	e0bffd15 	stw	r2,-12(fp)
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
    8284:	e0ffff17 	ldw	r3,-4(fp)
    8288:	e0bffd17 	ldw	r2,-12(fp)
    828c:	18801926 	beq	r3,r2,82f4 <plug_holes+0x168>
    8290:	e0bffd17 	ldw	r2,-12(fp)
    8294:	10800103 	ldbu	r2,4(r2)
    8298:	10803fcc 	andi	r2,r2,255
    829c:	1000151e 	bne	r2,zero,82f4 <plug_holes+0x168>
    82a0:	d0a8ce17 	ldw	r2,-23752(gp)
    82a4:	e0fffd17 	ldw	r3,-12(fp)
    82a8:	18801226 	beq	r3,r2,82f4 <plug_holes+0x168>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
    82ac:	d0e8cf17 	ldw	r3,-23748(gp)
    82b0:	e0bffd17 	ldw	r2,-12(fp)
    82b4:	1880021e 	bne	r3,r2,82c0 <plug_holes+0x134>
      lfree = mem;
    82b8:	e0bfff17 	ldw	r2,-4(fp)
    82bc:	d0a8cf15 	stw	r2,-23748(gp)
    }
    mem->next = nmem->next;
    82c0:	e0bffd17 	ldw	r2,-12(fp)
    82c4:	10c0000b 	ldhu	r3,0(r2)
    82c8:	e0bfff17 	ldw	r2,-4(fp)
    82cc:	10c0000d 	sth	r3,0(r2)
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
    82d0:	d0e8cd17 	ldw	r3,-23756(gp)
    82d4:	e0bffd17 	ldw	r2,-12(fp)
    82d8:	1080000b 	ldhu	r2,0(r2)
    82dc:	10bfffcc 	andi	r2,r2,65535
    82e0:	1885883a 	add	r2,r3,r2
    82e4:	e13fff17 	ldw	r4,-4(fp)
    82e8:	d0e8cd17 	ldw	r3,-23756(gp)
    82ec:	20c7c83a 	sub	r3,r4,r3
    82f0:	10c0008d 	sth	r3,2(r2)
  }

  /* plug hole backward */
  pmem = (struct mem *)&ram[mem->prev];
    82f4:	d0e8cd17 	ldw	r3,-23756(gp)
    82f8:	e0bfff17 	ldw	r2,-4(fp)
    82fc:	1080008b 	ldhu	r2,2(r2)
    8300:	10bfffcc 	andi	r2,r2,65535
    8304:	1885883a 	add	r2,r3,r2
    8308:	e0bffe15 	stw	r2,-8(fp)
  if (pmem != mem && pmem->used == 0) {
    830c:	e0fffe17 	ldw	r3,-8(fp)
    8310:	e0bfff17 	ldw	r2,-4(fp)
    8314:	18801626 	beq	r3,r2,8370 <plug_holes+0x1e4>
    8318:	e0bffe17 	ldw	r2,-8(fp)
    831c:	10800103 	ldbu	r2,4(r2)
    8320:	10803fcc 	andi	r2,r2,255
    8324:	1000121e 	bne	r2,zero,8370 <plug_holes+0x1e4>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
    8328:	d0e8cf17 	ldw	r3,-23748(gp)
    832c:	e0bfff17 	ldw	r2,-4(fp)
    8330:	1880021e 	bne	r3,r2,833c <plug_holes+0x1b0>
      lfree = pmem;
    8334:	e0bffe17 	ldw	r2,-8(fp)
    8338:	d0a8cf15 	stw	r2,-23748(gp)
    }
    pmem->next = mem->next;
    833c:	e0bfff17 	ldw	r2,-4(fp)
    8340:	10c0000b 	ldhu	r3,0(r2)
    8344:	e0bffe17 	ldw	r2,-8(fp)
    8348:	10c0000d 	sth	r3,0(r2)
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
    834c:	d0e8cd17 	ldw	r3,-23756(gp)
    8350:	e0bfff17 	ldw	r2,-4(fp)
    8354:	1080000b 	ldhu	r2,0(r2)
    8358:	10bfffcc 	andi	r2,r2,65535
    835c:	1885883a 	add	r2,r3,r2
    8360:	e13ffe17 	ldw	r4,-8(fp)
    8364:	d0e8cd17 	ldw	r3,-23756(gp)
    8368:	20c7c83a 	sub	r3,r4,r3
    836c:	10c0008d 	sth	r3,2(r2)
  }
}
    8370:	e037883a 	mov	sp,fp
    8374:	dfc00117 	ldw	ra,4(sp)
    8378:	df000017 	ldw	fp,0(sp)
    837c:	dec00204 	addi	sp,sp,8
    8380:	f800283a 	ret

00008384 <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
    8384:	defffe04 	addi	sp,sp,-8
    8388:	df000115 	stw	fp,4(sp)
    838c:	df000104 	addi	fp,sp,4

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
    8390:	008000f4 	movhi	r2,3
    8394:	10979504 	addi	r2,r2,24148
    8398:	10c000c4 	addi	r3,r2,3
    839c:	00bfff04 	movi	r2,-4
    83a0:	1884703a 	and	r2,r3,r2
    83a4:	d0a8cd15 	stw	r2,-23756(gp)
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
    83a8:	d0a8cd17 	ldw	r2,-23756(gp)
    83ac:	e0bfff15 	stw	r2,-4(fp)
  mem->next = MEM_SIZE_ALIGNED;
    83b0:	e0bfff17 	ldw	r2,-4(fp)
    83b4:	00c19004 	movi	r3,1600
    83b8:	10c0000d 	sth	r3,0(r2)
  mem->prev = 0;
    83bc:	e0bfff17 	ldw	r2,-4(fp)
    83c0:	1000008d 	sth	zero,2(r2)
  mem->used = 0;
    83c4:	e0bfff17 	ldw	r2,-4(fp)
    83c8:	10000105 	stb	zero,4(r2)
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
    83cc:	d0a8cd17 	ldw	r2,-23756(gp)
    83d0:	10819004 	addi	r2,r2,1600
    83d4:	d0a8ce15 	stw	r2,-23752(gp)
  ram_end->used = 1;
    83d8:	d0a8ce17 	ldw	r2,-23752(gp)
    83dc:	00c00044 	movi	r3,1
    83e0:	10c00105 	stb	r3,4(r2)
  ram_end->next = MEM_SIZE_ALIGNED;
    83e4:	d0a8ce17 	ldw	r2,-23752(gp)
    83e8:	00c19004 	movi	r3,1600
    83ec:	10c0000d 	sth	r3,0(r2)
  ram_end->prev = MEM_SIZE_ALIGNED;
    83f0:	d0a8ce17 	ldw	r2,-23752(gp)
    83f4:	00c19004 	movi	r3,1600
    83f8:	10c0008d 	sth	r3,2(r2)

  mem_sem = sys_sem_new(1);
    83fc:	00800044 	movi	r2,1
    8400:	d0a8d005 	stb	r2,-23744(gp)

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)ram;
    8404:	d0a8cd17 	ldw	r2,-23756(gp)
    8408:	d0a8cf15 	stw	r2,-23748(gp)

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
    840c:	00800134 	movhi	r2,4
    8410:	108d9504 	addi	r2,r2,13908
    8414:	00c19004 	movi	r3,1600
    8418:	10c02a0d 	sth	r3,168(r2)
}
    841c:	e037883a 	mov	sp,fp
    8420:	df000017 	ldw	fp,0(sp)
    8424:	dec00104 	addi	sp,sp,4
    8428:	f800283a 	ret

0000842c <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
    842c:	defffc04 	addi	sp,sp,-16
    8430:	dfc00315 	stw	ra,12(sp)
    8434:	df000215 	stw	fp,8(sp)
    8438:	df000204 	addi	fp,sp,8
    843c:	e13fff15 	stw	r4,-4(fp)
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
    8440:	e0bfff17 	ldw	r2,-4(fp)
    8444:	10005326 	beq	r2,zero,8594 <mem_free+0x168>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
    8448:	e0bfff17 	ldw	r2,-4(fp)
    844c:	108000cc 	andi	r2,r2,3
    8450:	10000926 	beq	r2,zero,8478 <mem_free+0x4c>
    8454:	010000f4 	movhi	r4,3
    8458:	21375604 	addi	r4,r4,-8872
    845c:	014000f4 	movhi	r5,3
    8460:	29778404 	addi	r5,r5,-8688
    8464:	01804c84 	movi	r6,306
    8468:	01c000f4 	movhi	r7,3
    846c:	39f76604 	addi	r7,r7,-8808
    8470:	00166c00 	call	166c0 <printf>
    8474:	003fff06 	br	8474 <mem_free+0x48>

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
    8478:	d0a8cd17 	ldw	r2,-23756(gp)
    847c:	e0ffff17 	ldw	r3,-4(fp)
    8480:	18800336 	bltu	r3,r2,8490 <mem_free+0x64>
    8484:	d0a8ce17 	ldw	r2,-23752(gp)
    8488:	e0ffff17 	ldw	r3,-4(fp)
    848c:	18800936 	bltu	r3,r2,84b4 <mem_free+0x88>
    8490:	010000f4 	movhi	r4,3
    8494:	21375604 	addi	r4,r4,-8872
    8498:	014000f4 	movhi	r5,3
    849c:	29778d04 	addi	r5,r5,-8652
    84a0:	01804d44 	movi	r6,309
    84a4:	01c000f4 	movhi	r7,3
    84a8:	39f76604 	addi	r7,r7,-8808
    84ac:	00166c00 	call	166c0 <printf>
    84b0:	003fff06 	br	84b0 <mem_free+0x84>
    (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
    84b4:	d0a8cd17 	ldw	r2,-23756(gp)
    84b8:	e0ffff17 	ldw	r3,-4(fp)
    84bc:	18800336 	bltu	r3,r2,84cc <mem_free+0xa0>
    84c0:	d0a8ce17 	ldw	r2,-23752(gp)
    84c4:	e0ffff17 	ldw	r3,-4(fp)
    84c8:	18800936 	bltu	r3,r2,84f0 <mem_free+0xc4>
    SYS_ARCH_DECL_PROTECT(lev);
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
    MEM_STATS_INC(illegal);
    84cc:	00800134 	movhi	r2,4
    84d0:	108d9504 	addi	r2,r2,13908
    84d4:	10802c0b 	ldhu	r2,176(r2)
    84d8:	10800044 	addi	r2,r2,1
    84dc:	1007883a 	mov	r3,r2
    84e0:	00800134 	movhi	r2,4
    84e4:	108d9504 	addi	r2,r2,13908
    84e8:	10c02c0d 	sth	r3,176(r2)
    SYS_ARCH_UNPROTECT(lev);
    return;
    84ec:	00002a06 	br	8598 <mem_free+0x16c>
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
    84f0:	e0bfff17 	ldw	r2,-4(fp)
    84f4:	10bffe04 	addi	r2,r2,-8
    84f8:	e0bffe15 	stw	r2,-8(fp)
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
    84fc:	e0bffe17 	ldw	r2,-8(fp)
    8500:	10800103 	ldbu	r2,4(r2)
    8504:	10803fcc 	andi	r2,r2,255
    8508:	1000091e 	bne	r2,zero,8530 <mem_free+0x104>
    850c:	010000f4 	movhi	r4,3
    8510:	21375604 	addi	r4,r4,-8872
    8514:	014000f4 	movhi	r5,3
    8518:	29779304 	addi	r5,r5,-8628
    851c:	01805144 	movi	r6,325
    8520:	01c000f4 	movhi	r7,3
    8524:	39f76604 	addi	r7,r7,-8808
    8528:	00166c00 	call	166c0 <printf>
    852c:	003fff06 	br	852c <mem_free+0x100>
  /* ... and is now unused. */
  mem->used = 0;
    8530:	e0bffe17 	ldw	r2,-8(fp)
    8534:	10000105 	stb	zero,4(r2)

  if (mem < lfree) {
    8538:	d0a8cf17 	ldw	r2,-23748(gp)
    853c:	e0fffe17 	ldw	r3,-8(fp)
    8540:	1880022e 	bgeu	r3,r2,854c <mem_free+0x120>
    /* the newly freed struct is now the lowest */
    lfree = mem;
    8544:	e0bffe17 	ldw	r2,-8(fp)
    8548:	d0a8cf15 	stw	r2,-23748(gp)
  }

  MEM_STATS_DEC_USED(used, mem->next - ((u8_t *)mem - ram));
    854c:	00800134 	movhi	r2,4
    8550:	108d9504 	addi	r2,r2,13908
    8554:	10c02a8b 	ldhu	r3,170(r2)
    8558:	e13ffe17 	ldw	r4,-8(fp)
    855c:	d0a8cd17 	ldw	r2,-23756(gp)
    8560:	2085c83a 	sub	r2,r4,r2
    8564:	1009883a 	mov	r4,r2
    8568:	e0bffe17 	ldw	r2,-8(fp)
    856c:	1080000b 	ldhu	r2,0(r2)
    8570:	2085c83a 	sub	r2,r4,r2
    8574:	1885883a 	add	r2,r3,r2
    8578:	1007883a 	mov	r3,r2
    857c:	00800134 	movhi	r2,4
    8580:	108d9504 	addi	r2,r2,13908
    8584:	10c02a8d 	sth	r3,170(r2)

  /* finally, see if prev or next are free also */
  plug_holes(mem);
    8588:	e13ffe17 	ldw	r4,-8(fp)
    858c:	000818c0 	call	818c <plug_holes>
    8590:	00000106 	br	8598 <mem_free+0x16c>
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
    8594:	0001883a 	nop
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
}
    8598:	e037883a 	mov	sp,fp
    859c:	dfc00117 	ldw	ra,4(sp)
    85a0:	df000017 	ldw	fp,0(sp)
    85a4:	dec00204 	addi	sp,sp,8
    85a8:	f800283a 	ret

000085ac <mem_realloc>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_realloc(void *rmem, mem_size_t newsize)
{
    85ac:	defff804 	addi	sp,sp,-32
    85b0:	dfc00715 	stw	ra,28(sp)
    85b4:	df000615 	stw	fp,24(sp)
    85b8:	df000604 	addi	fp,sp,24
    85bc:	e13ffe15 	stw	r4,-8(fp)
    85c0:	2805883a 	mov	r2,r5
    85c4:	e0bfff0d 	sth	r2,-4(fp)
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
    85c8:	e0bfff0b 	ldhu	r2,-4(fp)
    85cc:	108000c4 	addi	r2,r2,3
    85d0:	1007883a 	mov	r3,r2
    85d4:	00bfff04 	movi	r2,-4
    85d8:	1884703a 	and	r2,r3,r2
    85dc:	e0bfff0d 	sth	r2,-4(fp)

  if(newsize < MIN_SIZE_ALIGNED) {
    85e0:	e0bfff0b 	ldhu	r2,-4(fp)
    85e4:	10800328 	cmpgeui	r2,r2,12
    85e8:	1000021e 	bne	r2,zero,85f4 <mem_realloc+0x48>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
    85ec:	00800304 	movi	r2,12
    85f0:	e0bfff0d 	sth	r2,-4(fp)
  }

  if (newsize > MEM_SIZE_ALIGNED) {
    85f4:	e0bfff0b 	ldhu	r2,-4(fp)
    85f8:	10819070 	cmpltui	r2,r2,1601
    85fc:	1000021e 	bne	r2,zero,8608 <mem_realloc+0x5c>
    return NULL;
    8600:	0005883a 	mov	r2,zero
    8604:	0000ad06 	br	88bc <mem_realloc+0x310>
  }

  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
    8608:	d0a8cd17 	ldw	r2,-23756(gp)
    860c:	e0fffe17 	ldw	r3,-8(fp)
    8610:	18800336 	bltu	r3,r2,8620 <mem_realloc+0x74>
    8614:	d0a8ce17 	ldw	r2,-23752(gp)
    8618:	e0fffe17 	ldw	r3,-8(fp)
    861c:	18800936 	bltu	r3,r2,8644 <mem_realloc+0x98>
    8620:	010000f4 	movhi	r4,3
    8624:	21375604 	addi	r4,r4,-8872
    8628:	014000f4 	movhi	r5,3
    862c:	29779804 	addi	r5,r5,-8608
    8630:	01805ec4 	movi	r6,379
    8634:	01c000f4 	movhi	r7,3
    8638:	39f76604 	addi	r7,r7,-8808
    863c:	00166c00 	call	166c0 <printf>
    8640:	003fff06 	br	8640 <mem_realloc+0x94>
   (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
    8644:	d0a8cd17 	ldw	r2,-23756(gp)
    8648:	e0fffe17 	ldw	r3,-8(fp)
    864c:	18800336 	bltu	r3,r2,865c <mem_realloc+0xb0>
    8650:	d0a8ce17 	ldw	r2,-23752(gp)
    8654:	e0fffe17 	ldw	r3,-8(fp)
    8658:	18800a36 	bltu	r3,r2,8684 <mem_realloc+0xd8>
    SYS_ARCH_DECL_PROTECT(lev);
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_realloc: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
    MEM_STATS_INC(illegal);
    865c:	00800134 	movhi	r2,4
    8660:	108d9504 	addi	r2,r2,13908
    8664:	10802c0b 	ldhu	r2,176(r2)
    8668:	10800044 	addi	r2,r2,1
    866c:	1007883a 	mov	r3,r2
    8670:	00800134 	movhi	r2,4
    8674:	108d9504 	addi	r2,r2,13908
    8678:	10c02c0d 	sth	r3,176(r2)
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
    867c:	e0bffe17 	ldw	r2,-8(fp)
    8680:	00008e06 	br	88bc <mem_realloc+0x310>
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
    8684:	e0bffe17 	ldw	r2,-8(fp)
    8688:	10bffe04 	addi	r2,r2,-8
    868c:	e0bffa15 	stw	r2,-24(fp)
  /* ... and its offset pointer */
  ptr = (u8_t *)mem - ram;
    8690:	e0fffa17 	ldw	r3,-24(fp)
    8694:	d0a8cd17 	ldw	r2,-23756(gp)
    8698:	1885c83a 	sub	r2,r3,r2
    869c:	e0bffb0d 	sth	r2,-20(fp)

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
    86a0:	e0bffa17 	ldw	r2,-24(fp)
    86a4:	10c0000b 	ldhu	r3,0(r2)
    86a8:	e0bffb0b 	ldhu	r2,-20(fp)
    86ac:	1885c83a 	sub	r2,r3,r2
    86b0:	10bffe04 	addi	r2,r2,-8
    86b4:	e0bffb8d 	sth	r2,-18(fp)
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
    86b8:	e0bfff0b 	ldhu	r2,-4(fp)
    86bc:	e0fffb8b 	ldhu	r3,-18(fp)
    86c0:	1880092e 	bgeu	r3,r2,86e8 <mem_realloc+0x13c>
    86c4:	010000f4 	movhi	r4,3
    86c8:	21375604 	addi	r4,r4,-8872
    86cc:	014000f4 	movhi	r5,3
    86d0:	29779f04 	addi	r5,r5,-8580
    86d4:	01806304 	movi	r6,396
    86d8:	01c000f4 	movhi	r7,3
    86dc:	39f76604 	addi	r7,r7,-8808
    86e0:	00166c00 	call	166c0 <printf>
    86e4:	003fff06 	br	86e4 <mem_realloc+0x138>
  if (newsize > size) {
    86e8:	e0bfff0b 	ldhu	r2,-4(fp)
    86ec:	e0fffb8b 	ldhu	r3,-18(fp)
    86f0:	1880022e 	bgeu	r3,r2,86fc <mem_realloc+0x150>
    /* not supported */
    return NULL;
    86f4:	0005883a 	mov	r2,zero
    86f8:	00007006 	br	88bc <mem_realloc+0x310>
  }
  if (newsize == size) {
    86fc:	e0ffff0b 	ldhu	r3,-4(fp)
    8700:	e0bffb8b 	ldhu	r2,-18(fp)
    8704:	1880021e 	bne	r3,r2,8710 <mem_realloc+0x164>
    /* No change in size, simply return */
    return rmem;
    8708:	e0bffe17 	ldw	r2,-8(fp)
    870c:	00006b06 	br	88bc <mem_realloc+0x310>
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();

  MEM_STATS_DEC_USED(used, (size - newsize));
    8710:	00800134 	movhi	r2,4
    8714:	108d9504 	addi	r2,r2,13908
    8718:	10c02a8b 	ldhu	r3,170(r2)
    871c:	e13fff0b 	ldhu	r4,-4(fp)
    8720:	e0bffb8b 	ldhu	r2,-18(fp)
    8724:	2085c83a 	sub	r2,r4,r2
    8728:	1885883a 	add	r2,r3,r2
    872c:	1007883a 	mov	r3,r2
    8730:	00800134 	movhi	r2,4
    8734:	108d9504 	addi	r2,r2,13908
    8738:	10c02a8d 	sth	r3,170(r2)

  mem2 = (struct mem *)&ram[mem->next];
    873c:	d0e8cd17 	ldw	r3,-23756(gp)
    8740:	e0bffa17 	ldw	r2,-24(fp)
    8744:	1080000b 	ldhu	r2,0(r2)
    8748:	10bfffcc 	andi	r2,r2,65535
    874c:	1885883a 	add	r2,r3,r2
    8750:	e0bffc15 	stw	r2,-16(fp)
  if(mem2->used == 0) {
    8754:	e0bffc17 	ldw	r2,-16(fp)
    8758:	10800103 	ldbu	r2,4(r2)
    875c:	10803fcc 	andi	r2,r2,255
    8760:	10002b1e 	bne	r2,zero,8810 <mem_realloc+0x264>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
    8764:	e0bffc17 	ldw	r2,-16(fp)
    8768:	1080000b 	ldhu	r2,0(r2)
    876c:	e0bffd0d 	sth	r2,-12(fp)
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    8770:	e0fffb0b 	ldhu	r3,-20(fp)
    8774:	e0bfff0b 	ldhu	r2,-4(fp)
    8778:	1885883a 	add	r2,r3,r2
    877c:	10800204 	addi	r2,r2,8
    8780:	e0bffd8d 	sth	r2,-10(fp)
    if (lfree == mem2) {
    8784:	d0e8cf17 	ldw	r3,-23748(gp)
    8788:	e0bffc17 	ldw	r2,-16(fp)
    878c:	1880041e 	bne	r3,r2,87a0 <mem_realloc+0x1f4>
      lfree = (struct mem *)&ram[ptr2];
    8790:	d0e8cd17 	ldw	r3,-23756(gp)
    8794:	e0bffd8b 	ldhu	r2,-10(fp)
    8798:	1885883a 	add	r2,r3,r2
    879c:	d0a8cf15 	stw	r2,-23748(gp)
    }
    mem2 = (struct mem *)&ram[ptr2];
    87a0:	d0e8cd17 	ldw	r3,-23756(gp)
    87a4:	e0bffd8b 	ldhu	r2,-10(fp)
    87a8:	1885883a 	add	r2,r3,r2
    87ac:	e0bffc15 	stw	r2,-16(fp)
    mem2->used = 0;
    87b0:	e0bffc17 	ldw	r2,-16(fp)
    87b4:	10000105 	stb	zero,4(r2)
    /* restore the next pointer */
    mem2->next = next;
    87b8:	e0bffc17 	ldw	r2,-16(fp)
    87bc:	e0fffd0b 	ldhu	r3,-12(fp)
    87c0:	10c0000d 	sth	r3,0(r2)
    /* link it back to mem */
    mem2->prev = ptr;
    87c4:	e0bffc17 	ldw	r2,-16(fp)
    87c8:	e0fffb0b 	ldhu	r3,-20(fp)
    87cc:	10c0008d 	sth	r3,2(r2)
    /* link mem to it */
    mem->next = ptr2;
    87d0:	e0bffa17 	ldw	r2,-24(fp)
    87d4:	e0fffd8b 	ldhu	r3,-10(fp)
    87d8:	10c0000d 	sth	r3,0(r2)
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
    87dc:	e0bffc17 	ldw	r2,-16(fp)
    87e0:	1080000b 	ldhu	r2,0(r2)
    87e4:	10bfffcc 	andi	r2,r2,65535
    87e8:	10819020 	cmpeqi	r2,r2,1600
    87ec:	1000321e 	bne	r2,zero,88b8 <mem_realloc+0x30c>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
    87f0:	d0e8cd17 	ldw	r3,-23756(gp)
    87f4:	e0bffc17 	ldw	r2,-16(fp)
    87f8:	1080000b 	ldhu	r2,0(r2)
    87fc:	10bfffcc 	andi	r2,r2,65535
    8800:	1885883a 	add	r2,r3,r2
    8804:	e0fffd8b 	ldhu	r3,-10(fp)
    8808:	10c0008d 	sth	r3,2(r2)
    880c:	00002a06 	br	88b8 <mem_realloc+0x30c>
    }
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
    8810:	e0bfff0b 	ldhu	r2,-4(fp)
    8814:	10800504 	addi	r2,r2,20
    8818:	e0fffb8b 	ldhu	r3,-18(fp)
    881c:	18802636 	bltu	r3,r2,88b8 <mem_realloc+0x30c>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    8820:	e0fffb0b 	ldhu	r3,-20(fp)
    8824:	e0bfff0b 	ldhu	r2,-4(fp)
    8828:	1885883a 	add	r2,r3,r2
    882c:	10800204 	addi	r2,r2,8
    8830:	e0bffd8d 	sth	r2,-10(fp)
    mem2 = (struct mem *)&ram[ptr2];
    8834:	d0e8cd17 	ldw	r3,-23756(gp)
    8838:	e0bffd8b 	ldhu	r2,-10(fp)
    883c:	1885883a 	add	r2,r3,r2
    8840:	e0bffc15 	stw	r2,-16(fp)
    if (mem2 < lfree) {
    8844:	d0a8cf17 	ldw	r2,-23748(gp)
    8848:	e0fffc17 	ldw	r3,-16(fp)
    884c:	1880022e 	bgeu	r3,r2,8858 <mem_realloc+0x2ac>
      lfree = mem2;
    8850:	e0bffc17 	ldw	r2,-16(fp)
    8854:	d0a8cf15 	stw	r2,-23748(gp)
    }
    mem2->used = 0;
    8858:	e0bffc17 	ldw	r2,-16(fp)
    885c:	10000105 	stb	zero,4(r2)
    mem2->next = mem->next;
    8860:	e0bffa17 	ldw	r2,-24(fp)
    8864:	10c0000b 	ldhu	r3,0(r2)
    8868:	e0bffc17 	ldw	r2,-16(fp)
    886c:	10c0000d 	sth	r3,0(r2)
    mem2->prev = ptr;
    8870:	e0bffc17 	ldw	r2,-16(fp)
    8874:	e0fffb0b 	ldhu	r3,-20(fp)
    8878:	10c0008d 	sth	r3,2(r2)
    mem->next = ptr2;
    887c:	e0bffa17 	ldw	r2,-24(fp)
    8880:	e0fffd8b 	ldhu	r3,-10(fp)
    8884:	10c0000d 	sth	r3,0(r2)
    if (mem2->next != MEM_SIZE_ALIGNED) {
    8888:	e0bffc17 	ldw	r2,-16(fp)
    888c:	1080000b 	ldhu	r2,0(r2)
    8890:	10bfffcc 	andi	r2,r2,65535
    8894:	10819020 	cmpeqi	r2,r2,1600
    8898:	1000071e 	bne	r2,zero,88b8 <mem_realloc+0x30c>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
    889c:	d0e8cd17 	ldw	r3,-23756(gp)
    88a0:	e0bffc17 	ldw	r2,-16(fp)
    88a4:	1080000b 	ldhu	r2,0(r2)
    88a8:	10bfffcc 	andi	r2,r2,65535
    88ac:	1885883a 	add	r2,r3,r2
    88b0:	e0fffd8b 	ldhu	r3,-10(fp)
    88b4:	10c0008d 	sth	r3,2(r2)
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  return rmem;
    88b8:	e0bffe17 	ldw	r2,-8(fp)
}
    88bc:	e037883a 	mov	sp,fp
    88c0:	dfc00117 	ldw	ra,4(sp)
    88c4:	df000017 	ldw	fp,0(sp)
    88c8:	dec00204 	addi	sp,sp,8
    88cc:	f800283a 	ret

000088d0 <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
    88d0:	defff904 	addi	sp,sp,-28
    88d4:	dfc00615 	stw	ra,24(sp)
    88d8:	df000515 	stw	fp,20(sp)
    88dc:	df000504 	addi	fp,sp,20
    88e0:	2005883a 	mov	r2,r4
    88e4:	e0bfff0d 	sth	r2,-4(fp)
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
    88e8:	e0bfff0b 	ldhu	r2,-4(fp)
    88ec:	1000021e 	bne	r2,zero,88f8 <mem_malloc+0x28>
    return NULL;
    88f0:	0005883a 	mov	r2,zero
    88f4:	0000ec06 	br	8ca8 <mem_malloc+0x3d8>
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
    88f8:	e0bfff0b 	ldhu	r2,-4(fp)
    88fc:	108000c4 	addi	r2,r2,3
    8900:	1007883a 	mov	r3,r2
    8904:	00bfff04 	movi	r2,-4
    8908:	1884703a 	and	r2,r3,r2
    890c:	e0bfff0d 	sth	r2,-4(fp)

  if(size < MIN_SIZE_ALIGNED) {
    8910:	e0bfff0b 	ldhu	r2,-4(fp)
    8914:	10800328 	cmpgeui	r2,r2,12
    8918:	1000021e 	bne	r2,zero,8924 <mem_malloc+0x54>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
    891c:	00800304 	movi	r2,12
    8920:	e0bfff0d 	sth	r2,-4(fp)
  }

  if (size > MEM_SIZE_ALIGNED) {
    8924:	e0bfff0b 	ldhu	r2,-4(fp)
    8928:	10819070 	cmpltui	r2,r2,1601
    892c:	1000021e 	bne	r2,zero,8938 <mem_malloc+0x68>
    return NULL;
    8930:	0005883a 	mov	r2,zero
    8934:	0000dc06 	br	8ca8 <mem_malloc+0x3d8>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
    8938:	d0a8cf17 	ldw	r2,-23748(gp)
    893c:	1007883a 	mov	r3,r2
    8940:	d0a8cd17 	ldw	r2,-23756(gp)
    8944:	1885c83a 	sub	r2,r3,r2
    8948:	e0bffb0d 	sth	r2,-20(fp)
    894c:	0000c806 	br	8c70 <mem_malloc+0x3a0>
         ptr = ((struct mem *)&ram[ptr])->next) {
      mem = (struct mem *)&ram[ptr];
    8950:	d0e8cd17 	ldw	r3,-23756(gp)
    8954:	e0bffb0b 	ldhu	r2,-20(fp)
    8958:	1885883a 	add	r2,r3,r2
    895c:	e0bffc15 	stw	r2,-16(fp)
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
    8960:	e0bffc17 	ldw	r2,-16(fp)
    8964:	10800103 	ldbu	r2,4(r2)
    8968:	10803fcc 	andi	r2,r2,255
    896c:	1000bb1e 	bne	r2,zero,8c5c <mem_malloc+0x38c>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
    8970:	e0bffc17 	ldw	r2,-16(fp)
    8974:	1080000b 	ldhu	r2,0(r2)
    8978:	10ffffcc 	andi	r3,r2,65535
    897c:	e0bffb0b 	ldhu	r2,-20(fp)
    8980:	1885c83a 	sub	r2,r3,r2
    8984:	10fffe04 	addi	r3,r2,-8
    8988:	e0bfff0b 	ldhu	r2,-4(fp)
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
    898c:	1880b336 	bltu	r3,r2,8c5c <mem_malloc+0x38c>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
    8990:	e0bffc17 	ldw	r2,-16(fp)
    8994:	1080000b 	ldhu	r2,0(r2)
    8998:	10ffffcc 	andi	r3,r2,65535
    899c:	e0bffb0b 	ldhu	r2,-20(fp)
    89a0:	1885c83a 	sub	r2,r3,r2
    89a4:	10fffe04 	addi	r3,r2,-8
    89a8:	e0bfff0b 	ldhu	r2,-4(fp)
    89ac:	10800504 	addi	r2,r2,20
    89b0:	18803e36 	bltu	r3,r2,8aac <mem_malloc+0x1dc>
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
    89b4:	e0fffb0b 	ldhu	r3,-20(fp)
    89b8:	e0bfff0b 	ldhu	r2,-4(fp)
    89bc:	1885883a 	add	r2,r3,r2
    89c0:	10800204 	addi	r2,r2,8
    89c4:	e0bffd0d 	sth	r2,-12(fp)
          /* create mem2 struct */
          mem2 = (struct mem *)&ram[ptr2];
    89c8:	d0e8cd17 	ldw	r3,-23756(gp)
    89cc:	e0bffd0b 	ldhu	r2,-12(fp)
    89d0:	1885883a 	add	r2,r3,r2
    89d4:	e0bffe15 	stw	r2,-8(fp)
          mem2->used = 0;
    89d8:	e0bffe17 	ldw	r2,-8(fp)
    89dc:	10000105 	stb	zero,4(r2)
          mem2->next = mem->next;
    89e0:	e0bffc17 	ldw	r2,-16(fp)
    89e4:	10c0000b 	ldhu	r3,0(r2)
    89e8:	e0bffe17 	ldw	r2,-8(fp)
    89ec:	10c0000d 	sth	r3,0(r2)
          mem2->prev = ptr;
    89f0:	e0bffe17 	ldw	r2,-8(fp)
    89f4:	e0fffb0b 	ldhu	r3,-20(fp)
    89f8:	10c0008d 	sth	r3,2(r2)
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
    89fc:	e0bffc17 	ldw	r2,-16(fp)
    8a00:	e0fffd0b 	ldhu	r3,-12(fp)
    8a04:	10c0000d 	sth	r3,0(r2)
          mem->used = 1;
    8a08:	e0bffc17 	ldw	r2,-16(fp)
    8a0c:	00c00044 	movi	r3,1
    8a10:	10c00105 	stb	r3,4(r2)

          if (mem2->next != MEM_SIZE_ALIGNED) {
    8a14:	e0bffe17 	ldw	r2,-8(fp)
    8a18:	1080000b 	ldhu	r2,0(r2)
    8a1c:	10bfffcc 	andi	r2,r2,65535
    8a20:	10819020 	cmpeqi	r2,r2,1600
    8a24:	1000071e 	bne	r2,zero,8a44 <mem_malloc+0x174>
            ((struct mem *)&ram[mem2->next])->prev = ptr2;
    8a28:	d0e8cd17 	ldw	r3,-23756(gp)
    8a2c:	e0bffe17 	ldw	r2,-8(fp)
    8a30:	1080000b 	ldhu	r2,0(r2)
    8a34:	10bfffcc 	andi	r2,r2,65535
    8a38:	1885883a 	add	r2,r3,r2
    8a3c:	e0fffd0b 	ldhu	r3,-12(fp)
    8a40:	10c0008d 	sth	r3,2(r2)
          }
          MEM_STATS_INC_USED(used, (size + SIZEOF_STRUCT_MEM));
    8a44:	00800134 	movhi	r2,4
    8a48:	108d9504 	addi	r2,r2,13908
    8a4c:	10c02a8b 	ldhu	r3,170(r2)
    8a50:	e0bfff0b 	ldhu	r2,-4(fp)
    8a54:	1885883a 	add	r2,r3,r2
    8a58:	10800204 	addi	r2,r2,8
    8a5c:	1007883a 	mov	r3,r2
    8a60:	00800134 	movhi	r2,4
    8a64:	108d9504 	addi	r2,r2,13908
    8a68:	10c02a8d 	sth	r3,170(r2)
    8a6c:	00800134 	movhi	r2,4
    8a70:	108d9504 	addi	r2,r2,13908
    8a74:	10c02b0b 	ldhu	r3,172(r2)
    8a78:	00800134 	movhi	r2,4
    8a7c:	108d9504 	addi	r2,r2,13908
    8a80:	10802a8b 	ldhu	r2,170(r2)
    8a84:	18ffffcc 	andi	r3,r3,65535
    8a88:	10bfffcc 	andi	r2,r2,65535
    8a8c:	1880282e 	bgeu	r3,r2,8b30 <mem_malloc+0x260>
    8a90:	00800134 	movhi	r2,4
    8a94:	108d9504 	addi	r2,r2,13908
    8a98:	10c02a8b 	ldhu	r3,170(r2)
    8a9c:	00800134 	movhi	r2,4
    8aa0:	108d9504 	addi	r2,r2,13908
    8aa4:	10c02b0d 	sth	r3,172(r2)
    8aa8:	00002106 	br	8b30 <mem_malloc+0x260>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
    8aac:	e0bffc17 	ldw	r2,-16(fp)
    8ab0:	00c00044 	movi	r3,1
    8ab4:	10c00105 	stb	r3,4(r2)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
    8ab8:	00800134 	movhi	r2,4
    8abc:	108d9504 	addi	r2,r2,13908
    8ac0:	10c02a8b 	ldhu	r3,170(r2)
    8ac4:	e0bffc17 	ldw	r2,-16(fp)
    8ac8:	1100000b 	ldhu	r4,0(r2)
    8acc:	d0a8cd17 	ldw	r2,-23756(gp)
    8ad0:	100b883a 	mov	r5,r2
    8ad4:	e0bffc17 	ldw	r2,-16(fp)
    8ad8:	2885c83a 	sub	r2,r5,r2
    8adc:	2085883a 	add	r2,r4,r2
    8ae0:	1885883a 	add	r2,r3,r2
    8ae4:	1007883a 	mov	r3,r2
    8ae8:	00800134 	movhi	r2,4
    8aec:	108d9504 	addi	r2,r2,13908
    8af0:	10c02a8d 	sth	r3,170(r2)
    8af4:	00800134 	movhi	r2,4
    8af8:	108d9504 	addi	r2,r2,13908
    8afc:	10c02b0b 	ldhu	r3,172(r2)
    8b00:	00800134 	movhi	r2,4
    8b04:	108d9504 	addi	r2,r2,13908
    8b08:	10802a8b 	ldhu	r2,170(r2)
    8b0c:	18ffffcc 	andi	r3,r3,65535
    8b10:	10bfffcc 	andi	r2,r2,65535
    8b14:	1880062e 	bgeu	r3,r2,8b30 <mem_malloc+0x260>
    8b18:	00800134 	movhi	r2,4
    8b1c:	108d9504 	addi	r2,r2,13908
    8b20:	10c02a8b 	ldhu	r3,170(r2)
    8b24:	00800134 	movhi	r2,4
    8b28:	108d9504 	addi	r2,r2,13908
    8b2c:	10c02b0d 	sth	r3,172(r2)
        }

        if (mem == lfree) {
    8b30:	d0a8cf17 	ldw	r2,-23748(gp)
    8b34:	e0fffc17 	ldw	r3,-16(fp)
    8b38:	18801e1e 	bne	r3,r2,8bb4 <mem_malloc+0x2e4>
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
    8b3c:	00000606 	br	8b58 <mem_malloc+0x288>
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
    8b40:	d0e8cd17 	ldw	r3,-23756(gp)
    8b44:	d0a8cf17 	ldw	r2,-23748(gp)
    8b48:	1080000b 	ldhu	r2,0(r2)
    8b4c:	10bfffcc 	andi	r2,r2,65535
    8b50:	1885883a 	add	r2,r3,r2
    8b54:	d0a8cf15 	stw	r2,-23748(gp)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
    8b58:	d0a8cf17 	ldw	r2,-23748(gp)
    8b5c:	10800103 	ldbu	r2,4(r2)
    8b60:	10803fcc 	andi	r2,r2,255
    8b64:	10000326 	beq	r2,zero,8b74 <mem_malloc+0x2a4>
    8b68:	d0e8cf17 	ldw	r3,-23748(gp)
    8b6c:	d0a8ce17 	ldw	r2,-23752(gp)
    8b70:	18bff31e 	bne	r3,r2,8b40 <mem_malloc+0x270>
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
          }
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
    8b74:	d0e8cf17 	ldw	r3,-23748(gp)
    8b78:	d0a8ce17 	ldw	r2,-23752(gp)
    8b7c:	18800d26 	beq	r3,r2,8bb4 <mem_malloc+0x2e4>
    8b80:	d0a8cf17 	ldw	r2,-23748(gp)
    8b84:	10800103 	ldbu	r2,4(r2)
    8b88:	10803fcc 	andi	r2,r2,255
    8b8c:	10000926 	beq	r2,zero,8bb4 <mem_malloc+0x2e4>
    8b90:	010000f4 	movhi	r4,3
    8b94:	21375604 	addi	r4,r4,-8872
    8b98:	014000f4 	movhi	r5,3
    8b9c:	2977a804 	addi	r5,r5,-8544
    8ba0:	01809204 	movi	r6,584
    8ba4:	01c000f4 	movhi	r7,3
    8ba8:	39f76604 	addi	r7,r7,-8808
    8bac:	00166c00 	call	166c0 <printf>
    8bb0:	003fff06 	br	8bb0 <mem_malloc+0x2e0>
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_sem_signal(mem_sem);
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
    8bb4:	e0ffff0b 	ldhu	r3,-4(fp)
    8bb8:	e0bffc17 	ldw	r2,-16(fp)
    8bbc:	1885883a 	add	r2,r3,r2
    8bc0:	10800204 	addi	r2,r2,8
    8bc4:	d0e8ce17 	ldw	r3,-23752(gp)
    8bc8:	1880092e 	bgeu	r3,r2,8bf0 <mem_malloc+0x320>
    8bcc:	010000f4 	movhi	r4,3
    8bd0:	21375604 	addi	r4,r4,-8872
    8bd4:	014000f4 	movhi	r5,3
    8bd8:	2977af04 	addi	r5,r5,-8516
    8bdc:	01809344 	movi	r6,589
    8be0:	01c000f4 	movhi	r7,3
    8be4:	39f76604 	addi	r7,r7,-8808
    8be8:	00166c00 	call	166c0 <printf>
    8bec:	003fff06 	br	8bec <mem_malloc+0x31c>
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
    8bf0:	e0bffc17 	ldw	r2,-16(fp)
    8bf4:	108000cc 	andi	r2,r2,3
    8bf8:	10000926 	beq	r2,zero,8c20 <mem_malloc+0x350>
    8bfc:	010000f4 	movhi	r4,3
    8c00:	21375604 	addi	r4,r4,-8872
    8c04:	014000f4 	movhi	r5,3
    8c08:	2977bb04 	addi	r5,r5,-8468
    8c0c:	018093c4 	movi	r6,591
    8c10:	01c000f4 	movhi	r7,3
    8c14:	39f76604 	addi	r7,r7,-8808
    8c18:	00166c00 	call	166c0 <printf>
    8c1c:	003fff06 	br	8c1c <mem_malloc+0x34c>
         ((mem_ptr_t)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
    8c20:	e0bffc17 	ldw	r2,-16(fp)
    8c24:	108000cc 	andi	r2,r2,3
    8c28:	10000926 	beq	r2,zero,8c50 <mem_malloc+0x380>
    8c2c:	010000f4 	movhi	r4,3
    8c30:	21375604 	addi	r4,r4,-8872
    8c34:	014000f4 	movhi	r5,3
    8c38:	2977c704 	addi	r5,r5,-8420
    8c3c:	01809444 	movi	r6,593
    8c40:	01c000f4 	movhi	r7,3
    8c44:	39f76604 	addi	r7,r7,-8808
    8c48:	00166c00 	call	166c0 <printf>
    8c4c:	003fff06 	br	8c4c <mem_malloc+0x37c>
          (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);

        return (u8_t *)mem + SIZEOF_STRUCT_MEM;
    8c50:	e0bffc17 	ldw	r2,-16(fp)
    8c54:	10800204 	addi	r2,r2,8
    8c58:	00001306 	br	8ca8 <mem_malloc+0x3d8>

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
         ptr = ((struct mem *)&ram[ptr])->next) {
    8c5c:	d0e8cd17 	ldw	r3,-23756(gp)
    8c60:	e0bffb0b 	ldhu	r2,-20(fp)
    8c64:	1885883a 	add	r2,r3,r2
    8c68:	1080000b 	ldhu	r2,0(r2)
    8c6c:	e0bffb0d 	sth	r2,-20(fp)
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
    8c70:	e0fffb0b 	ldhu	r3,-20(fp)
    8c74:	e0bfff0b 	ldhu	r2,-4(fp)
    8c78:	01019004 	movi	r4,1600
    8c7c:	2085c83a 	sub	r2,r4,r2
    8c80:	18bf3316 	blt	r3,r2,8950 <mem_malloc+0x80>
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
    /* if we got interrupted by a mem_free, try again */
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
    8c84:	00800134 	movhi	r2,4
    8c88:	108d9504 	addi	r2,r2,13908
    8c8c:	10802b8b 	ldhu	r2,174(r2)
    8c90:	10800044 	addi	r2,r2,1
    8c94:	1007883a 	mov	r3,r2
    8c98:	00800134 	movhi	r2,4
    8c9c:	108d9504 	addi	r2,r2,13908
    8ca0:	10c02b8d 	sth	r3,174(r2)
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  return NULL;
    8ca4:	0005883a 	mov	r2,zero
}
    8ca8:	e037883a 	mov	sp,fp
    8cac:	dfc00117 	ldw	ra,4(sp)
    8cb0:	df000017 	ldw	fp,0(sp)
    8cb4:	dec00204 	addi	sp,sp,8
    8cb8:	f800283a 	ret

00008cbc <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
    8cbc:	defffb04 	addi	sp,sp,-20
    8cc0:	dfc00415 	stw	ra,16(sp)
    8cc4:	df000315 	stw	fp,12(sp)
    8cc8:	df000304 	addi	fp,sp,12
    8ccc:	2007883a 	mov	r3,r4
    8cd0:	2805883a 	mov	r2,r5
    8cd4:	e0fffe0d 	sth	r3,-8(fp)
    8cd8:	e0bfff0d 	sth	r2,-4(fp)
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
    8cdc:	e0fffe0b 	ldhu	r3,-8(fp)
    8ce0:	e0bfff0b 	ldhu	r2,-4(fp)
    8ce4:	1885383a 	mul	r2,r3,r2
    8ce8:	10bfffcc 	andi	r2,r2,65535
    8cec:	1009883a 	mov	r4,r2
    8cf0:	00088d00 	call	88d0 <mem_malloc>
    8cf4:	e0bffd15 	stw	r2,-12(fp)
  if (p) {
    8cf8:	e0bffd17 	ldw	r2,-12(fp)
    8cfc:	10000726 	beq	r2,zero,8d1c <mem_calloc+0x60>
    /* zero the memory */
    memset(p, 0, count * size);
    8d00:	e0fffe0b 	ldhu	r3,-8(fp)
    8d04:	e0bfff0b 	ldhu	r2,-4(fp)
    8d08:	1885383a 	mul	r2,r3,r2
    8d0c:	e13ffd17 	ldw	r4,-12(fp)
    8d10:	000b883a 	mov	r5,zero
    8d14:	100d883a 	mov	r6,r2
    8d18:	00165b80 	call	165b8 <memset>
  }
  return p;
    8d1c:	e0bffd17 	ldw	r2,-12(fp)
}
    8d20:	e037883a 	mov	sp,fp
    8d24:	dfc00117 	ldw	ra,4(sp)
    8d28:	df000017 	ldw	fp,0(sp)
    8d2c:	dec00204 	addi	sp,sp,8
    8d30:	f800283a 	ret

00008d34 <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
    8d34:	defffd04 	addi	sp,sp,-12
    8d38:	df000215 	stw	fp,8(sp)
    8d3c:	df000204 	addi	fp,sp,8
  struct memp *memp;
  u16_t i, j;

  for (i = 0; i < MEMP_MAX; ++i) {
    8d40:	e03fff0d 	sth	zero,-4(fp)
    8d44:	00002506 	br	8ddc <memp_init+0xa8>
    MEMP_STATS_AVAIL(used, i, 0);
    8d48:	e0bfff0b 	ldhu	r2,-4(fp)
    8d4c:	00c00134 	movhi	r3,4
    8d50:	18cd9504 	addi	r3,r3,13908
    8d54:	108002a4 	muli	r2,r2,10
    8d58:	1885883a 	add	r2,r3,r2
    8d5c:	10802d04 	addi	r2,r2,180
    8d60:	1000000d 	sth	zero,0(r2)
    MEMP_STATS_AVAIL(max, i, 0);
    8d64:	e0bfff0b 	ldhu	r2,-4(fp)
    8d68:	00c00134 	movhi	r3,4
    8d6c:	18cd9504 	addi	r3,r3,13908
    8d70:	108002a4 	muli	r2,r2,10
    8d74:	1885883a 	add	r2,r3,r2
    8d78:	10802d84 	addi	r2,r2,182
    8d7c:	1000000d 	sth	zero,0(r2)
    MEMP_STATS_AVAIL(err, i, 0);
    8d80:	e0bfff0b 	ldhu	r2,-4(fp)
    8d84:	00c00134 	movhi	r3,4
    8d88:	18cd9504 	addi	r3,r3,13908
    8d8c:	108002a4 	muli	r2,r2,10
    8d90:	1885883a 	add	r2,r3,r2
    8d94:	10802e04 	addi	r2,r2,184
    8d98:	1000000d 	sth	zero,0(r2)
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
    8d9c:	e17fff0b 	ldhu	r5,-4(fp)
    8da0:	e0bfff0b 	ldhu	r2,-4(fp)
    8da4:	00c000f4 	movhi	r3,3
    8da8:	18f7d484 	addi	r3,r3,-8366
    8dac:	1085883a 	add	r2,r2,r2
    8db0:	1885883a 	add	r2,r3,r2
    8db4:	10c0000b 	ldhu	r3,0(r2)
    8db8:	01000134 	movhi	r4,4
    8dbc:	210d9504 	addi	r4,r4,13908
    8dc0:	288002a4 	muli	r2,r5,10
    8dc4:	2085883a 	add	r2,r4,r2
    8dc8:	10802c84 	addi	r2,r2,178
    8dcc:	10c0000d 	sth	r3,0(r2)
memp_init(void)
{
  struct memp *memp;
  u16_t i, j;

  for (i = 0; i < MEMP_MAX; ++i) {
    8dd0:	e0bfff0b 	ldhu	r2,-4(fp)
    8dd4:	10800044 	addi	r2,r2,1
    8dd8:	e0bfff0d 	sth	r2,-4(fp)
    8ddc:	e0bfff0b 	ldhu	r2,-4(fp)
    8de0:	10800270 	cmpltui	r2,r2,9
    8de4:	103fd81e 	bne	r2,zero,8d48 <memp_init+0x14>
    MEMP_STATS_AVAIL(max, i, 0);
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
    8de8:	008000f4 	movhi	r2,3
    8dec:	10993304 	addi	r2,r2,25804
    8df0:	10c000c4 	addi	r3,r2,3
    8df4:	00bfff04 	movi	r2,-4
    8df8:	1884703a 	and	r2,r3,r2
    8dfc:	e0bffe15 	stw	r2,-8(fp)
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    8e00:	e03fff0d 	sth	zero,-4(fp)
    8e04:	00003306 	br	8ed4 <memp_init+0x1a0>
    memp_tab[i] = NULL;
    8e08:	e0bfff0b 	ldhu	r2,-4(fp)
    8e0c:	00c000f4 	movhi	r3,3
    8e10:	18d92a04 	addi	r3,r3,25768
    8e14:	1085883a 	add	r2,r2,r2
    8e18:	1085883a 	add	r2,r2,r2
    8e1c:	1885883a 	add	r2,r3,r2
    8e20:	10000015 	stw	zero,0(r2)
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
    8e24:	e03fff8d 	sth	zero,-2(fp)
    8e28:	00001e06 	br	8ea4 <memp_init+0x170>
      memp->next = memp_tab[i];
    8e2c:	e0bfff0b 	ldhu	r2,-4(fp)
    8e30:	00c000f4 	movhi	r3,3
    8e34:	18d92a04 	addi	r3,r3,25768
    8e38:	1085883a 	add	r2,r2,r2
    8e3c:	1085883a 	add	r2,r2,r2
    8e40:	1885883a 	add	r2,r3,r2
    8e44:	10c00017 	ldw	r3,0(r2)
    8e48:	e0bffe17 	ldw	r2,-8(fp)
    8e4c:	10c00015 	stw	r3,0(r2)
      memp_tab[i] = memp;
    8e50:	e0bfff0b 	ldhu	r2,-4(fp)
    8e54:	00c000f4 	movhi	r3,3
    8e58:	18d92a04 	addi	r3,r3,25768
    8e5c:	1085883a 	add	r2,r2,r2
    8e60:	1085883a 	add	r2,r2,r2
    8e64:	1885883a 	add	r2,r3,r2
    8e68:	e0fffe17 	ldw	r3,-8(fp)
    8e6c:	10c00015 	stw	r3,0(r2)
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
    8e70:	e0bfff0b 	ldhu	r2,-4(fp)
    8e74:	00c000f4 	movhi	r3,3
    8e78:	18f7d004 	addi	r3,r3,-8384
    8e7c:	1085883a 	add	r2,r2,r2
    8e80:	1885883a 	add	r2,r3,r2
    8e84:	1080000b 	ldhu	r2,0(r2)
    8e88:	10bfffcc 	andi	r2,r2,65535
    8e8c:	e0fffe17 	ldw	r3,-8(fp)
    8e90:	1885883a 	add	r2,r3,r2
    8e94:	e0bffe15 	stw	r2,-8(fp)
  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
    8e98:	e0bfff8b 	ldhu	r2,-2(fp)
    8e9c:	10800044 	addi	r2,r2,1
    8ea0:	e0bfff8d 	sth	r2,-2(fp)
    8ea4:	e0bfff0b 	ldhu	r2,-4(fp)
    8ea8:	00c000f4 	movhi	r3,3
    8eac:	18f7d484 	addi	r3,r3,-8366
    8eb0:	1085883a 	add	r2,r2,r2
    8eb4:	1885883a 	add	r2,r3,r2
    8eb8:	1080000b 	ldhu	r2,0(r2)
    8ebc:	10bfffcc 	andi	r2,r2,65535
    8ec0:	e0ffff8b 	ldhu	r3,-2(fp)
    8ec4:	18bfd936 	bltu	r3,r2,8e2c <memp_init+0xf8>
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    8ec8:	e0bfff0b 	ldhu	r2,-4(fp)
    8ecc:	10800044 	addi	r2,r2,1
    8ed0:	e0bfff0d 	sth	r2,-4(fp)
    8ed4:	e0bfff0b 	ldhu	r2,-4(fp)
    8ed8:	10800270 	cmpltui	r2,r2,9
    8edc:	103fca1e 	bne	r2,zero,8e08 <memp_init+0xd4>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
    8ee0:	e037883a 	mov	sp,fp
    8ee4:	df000017 	ldw	fp,0(sp)
    8ee8:	dec00104 	addi	sp,sp,4
    8eec:	f800283a 	ret

00008ef0 <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
    8ef0:	defffc04 	addi	sp,sp,-16
    8ef4:	dfc00315 	stw	ra,12(sp)
    8ef8:	df000215 	stw	fp,8(sp)
    8efc:	df000204 	addi	fp,sp,8
    8f00:	e13fff15 	stw	r4,-4(fp)
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
    8f04:	e0bfff17 	ldw	r2,-4(fp)
    8f08:	10800270 	cmpltui	r2,r2,9
    8f0c:	1000091e 	bne	r2,zero,8f34 <memp_malloc+0x44>
    8f10:	010000f4 	movhi	r4,3
    8f14:	2137f204 	addi	r4,r4,-8248
    8f18:	014000f4 	movhi	r5,3
    8f1c:	2977fc04 	addi	r5,r5,-8208
    8f20:	01804ec4 	movi	r6,315
    8f24:	01c000f4 	movhi	r7,3
    8f28:	39f80404 	addi	r7,r7,-8176
    8f2c:	00166c00 	call	166c0 <printf>
    8f30:	003fff06 	br	8f30 <memp_malloc+0x40>
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
    8f34:	00c000f4 	movhi	r3,3
    8f38:	18d92a04 	addi	r3,r3,25768
    8f3c:	e0bfff17 	ldw	r2,-4(fp)
    8f40:	1085883a 	add	r2,r2,r2
    8f44:	1085883a 	add	r2,r2,r2
    8f48:	1885883a 	add	r2,r3,r2
    8f4c:	10800017 	ldw	r2,0(r2)
    8f50:	e0bffe15 	stw	r2,-8(fp)
  
  if (memp != NULL) {
    8f54:	e0bffe17 	ldw	r2,-8(fp)
    8f58:	10004426 	beq	r2,zero,906c <memp_malloc+0x17c>
    memp_tab[type] = memp->next;
    8f5c:	e0bffe17 	ldw	r2,-8(fp)
    8f60:	10c00017 	ldw	r3,0(r2)
    8f64:	010000f4 	movhi	r4,3
    8f68:	21192a04 	addi	r4,r4,25768
    8f6c:	e0bfff17 	ldw	r2,-4(fp)
    8f70:	1085883a 	add	r2,r2,r2
    8f74:	1085883a 	add	r2,r2,r2
    8f78:	2085883a 	add	r2,r4,r2
    8f7c:	10c00015 	stw	r3,0(r2)
#if MEMP_OVERFLOW_CHECK
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    8f80:	00c00134 	movhi	r3,4
    8f84:	18cd9504 	addi	r3,r3,13908
    8f88:	e0bfff17 	ldw	r2,-4(fp)
    8f8c:	108002a4 	muli	r2,r2,10
    8f90:	1885883a 	add	r2,r3,r2
    8f94:	10802d04 	addi	r2,r2,180
    8f98:	1080000b 	ldhu	r2,0(r2)
    8f9c:	10800044 	addi	r2,r2,1
    8fa0:	1007883a 	mov	r3,r2
    8fa4:	01000134 	movhi	r4,4
    8fa8:	210d9504 	addi	r4,r4,13908
    8fac:	e0bfff17 	ldw	r2,-4(fp)
    8fb0:	108002a4 	muli	r2,r2,10
    8fb4:	2085883a 	add	r2,r4,r2
    8fb8:	10802d04 	addi	r2,r2,180
    8fbc:	10c0000d 	sth	r3,0(r2)
    8fc0:	00c00134 	movhi	r3,4
    8fc4:	18cd9504 	addi	r3,r3,13908
    8fc8:	e0bfff17 	ldw	r2,-4(fp)
    8fcc:	108002a4 	muli	r2,r2,10
    8fd0:	1885883a 	add	r2,r3,r2
    8fd4:	10802d84 	addi	r2,r2,182
    8fd8:	10c0000b 	ldhu	r3,0(r2)
    8fdc:	01000134 	movhi	r4,4
    8fe0:	210d9504 	addi	r4,r4,13908
    8fe4:	e0bfff17 	ldw	r2,-4(fp)
    8fe8:	108002a4 	muli	r2,r2,10
    8fec:	2085883a 	add	r2,r4,r2
    8ff0:	10802d04 	addi	r2,r2,180
    8ff4:	1080000b 	ldhu	r2,0(r2)
    8ff8:	18ffffcc 	andi	r3,r3,65535
    8ffc:	10bfffcc 	andi	r2,r2,65535
    9000:	18800e2e 	bgeu	r3,r2,903c <memp_malloc+0x14c>
    9004:	00c00134 	movhi	r3,4
    9008:	18cd9504 	addi	r3,r3,13908
    900c:	e0bfff17 	ldw	r2,-4(fp)
    9010:	108002a4 	muli	r2,r2,10
    9014:	1885883a 	add	r2,r3,r2
    9018:	10802d04 	addi	r2,r2,180
    901c:	10c0000b 	ldhu	r3,0(r2)
    9020:	01000134 	movhi	r4,4
    9024:	210d9504 	addi	r4,r4,13908
    9028:	e0bfff17 	ldw	r2,-4(fp)
    902c:	108002a4 	muli	r2,r2,10
    9030:	2085883a 	add	r2,r4,r2
    9034:	10802d84 	addi	r2,r2,182
    9038:	10c0000d 	sth	r3,0(r2)
    LWIP_ASSERT("memp_malloc: memp properly aligned",
    903c:	e0bffe17 	ldw	r2,-8(fp)
    9040:	108000cc 	andi	r2,r2,3
    9044:	10001a26 	beq	r2,zero,90b0 <memp_malloc+0x1c0>
    9048:	010000f4 	movhi	r4,3
    904c:	2137f204 	addi	r4,r4,-8248
    9050:	014000f4 	movhi	r5,3
    9054:	29780a04 	addi	r5,r5,-8152
    9058:	01805344 	movi	r6,333
    905c:	01c000f4 	movhi	r7,3
    9060:	39f80404 	addi	r7,r7,-8176
    9064:	00166c00 	call	166c0 <printf>
    9068:	003fff06 	br	9068 <memp_malloc+0x178>
                ((mem_ptr_t)memp % MEM_ALIGNMENT) == 0);
    memp = (struct memp*)((u8_t*)memp + MEMP_SIZE);
  } else {
    LWIP_DEBUGF(MEMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("memp_malloc: out of memory in pool %s\n", memp_desc[type]));
    MEMP_STATS_INC(err, type);
    906c:	00c00134 	movhi	r3,4
    9070:	18cd9504 	addi	r3,r3,13908
    9074:	e0bfff17 	ldw	r2,-4(fp)
    9078:	108002a4 	muli	r2,r2,10
    907c:	1885883a 	add	r2,r3,r2
    9080:	10802e04 	addi	r2,r2,184
    9084:	1080000b 	ldhu	r2,0(r2)
    9088:	10800044 	addi	r2,r2,1
    908c:	1007883a 	mov	r3,r2
    9090:	01000134 	movhi	r4,4
    9094:	210d9504 	addi	r4,r4,13908
    9098:	e0bfff17 	ldw	r2,-4(fp)
    909c:	108002a4 	muli	r2,r2,10
    90a0:	2085883a 	add	r2,r4,r2
    90a4:	10802e04 	addi	r2,r2,184
    90a8:	10c0000d 	sth	r3,0(r2)
    90ac:	00000106 	br	90b4 <memp_malloc+0x1c4>
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    LWIP_ASSERT("memp_malloc: memp properly aligned",
                ((mem_ptr_t)memp % MEM_ALIGNMENT) == 0);
    memp = (struct memp*)((u8_t*)memp + MEMP_SIZE);
    90b0:	0001883a 	nop
    MEMP_STATS_INC(err, type);
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
    90b4:	e0bffe17 	ldw	r2,-8(fp)
}
    90b8:	e037883a 	mov	sp,fp
    90bc:	dfc00117 	ldw	ra,4(sp)
    90c0:	df000017 	ldw	fp,0(sp)
    90c4:	dec00204 	addi	sp,sp,8
    90c8:	f800283a 	ret

000090cc <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
    90cc:	defffb04 	addi	sp,sp,-20
    90d0:	dfc00415 	stw	ra,16(sp)
    90d4:	df000315 	stw	fp,12(sp)
    90d8:	df000304 	addi	fp,sp,12
    90dc:	e13ffe15 	stw	r4,-8(fp)
    90e0:	e17fff15 	stw	r5,-4(fp)
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
    90e4:	e0bfff17 	ldw	r2,-4(fp)
    90e8:	10003026 	beq	r2,zero,91ac <memp_free+0xe0>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
    90ec:	e0bfff17 	ldw	r2,-4(fp)
    90f0:	108000cc 	andi	r2,r2,3
    90f4:	10000926 	beq	r2,zero,911c <memp_free+0x50>
    90f8:	010000f4 	movhi	r4,3
    90fc:	2137f204 	addi	r4,r4,-8248
    9100:	014000f4 	movhi	r5,3
    9104:	29781304 	addi	r5,r5,-8116
    9108:	01805a44 	movi	r6,361
    910c:	01c000f4 	movhi	r7,3
    9110:	39f80404 	addi	r7,r7,-8176
    9114:	00166c00 	call	166c0 <printf>
    9118:	003fff06 	br	9118 <memp_free+0x4c>
                ((mem_ptr_t)mem % MEM_ALIGNMENT) == 0);

  memp = (struct memp *)((u8_t*)mem - MEMP_SIZE);
    911c:	e0bfff17 	ldw	r2,-4(fp)
    9120:	e0bffd15 	stw	r2,-12(fp)
#else
  memp_overflow_check_element(memp, memp_sizes[type]);
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
    9124:	00c00134 	movhi	r3,4
    9128:	18cd9504 	addi	r3,r3,13908
    912c:	e0bffe17 	ldw	r2,-8(fp)
    9130:	108002a4 	muli	r2,r2,10
    9134:	1885883a 	add	r2,r3,r2
    9138:	10802d04 	addi	r2,r2,180
    913c:	1080000b 	ldhu	r2,0(r2)
    9140:	10bfffc4 	addi	r2,r2,-1
    9144:	1007883a 	mov	r3,r2
    9148:	01000134 	movhi	r4,4
    914c:	210d9504 	addi	r4,r4,13908
    9150:	e0bffe17 	ldw	r2,-8(fp)
    9154:	108002a4 	muli	r2,r2,10
    9158:	2085883a 	add	r2,r4,r2
    915c:	10802d04 	addi	r2,r2,180
    9160:	10c0000d 	sth	r3,0(r2)
  
  memp->next = memp_tab[type]; 
    9164:	00c000f4 	movhi	r3,3
    9168:	18d92a04 	addi	r3,r3,25768
    916c:	e0bffe17 	ldw	r2,-8(fp)
    9170:	1085883a 	add	r2,r2,r2
    9174:	1085883a 	add	r2,r2,r2
    9178:	1885883a 	add	r2,r3,r2
    917c:	10c00017 	ldw	r3,0(r2)
    9180:	e0bffd17 	ldw	r2,-12(fp)
    9184:	10c00015 	stw	r3,0(r2)
  memp_tab[type] = memp;
    9188:	00c000f4 	movhi	r3,3
    918c:	18d92a04 	addi	r3,r3,25768
    9190:	e0bffe17 	ldw	r2,-8(fp)
    9194:	1085883a 	add	r2,r2,r2
    9198:	1085883a 	add	r2,r2,r2
    919c:	1885883a 	add	r2,r3,r2
    91a0:	e0fffd17 	ldw	r3,-12(fp)
    91a4:	10c00015 	stw	r3,0(r2)
    91a8:	00000106 	br	91b0 <memp_free+0xe4>
{
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
    return;
    91ac:	0001883a 	nop
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
    91b0:	e037883a 	mov	sp,fp
    91b4:	dfc00117 	ldw	ra,4(sp)
    91b8:	df000017 	ldw	fp,0(sp)
    91bc:	dec00204 	addi	sp,sp,8
    91c0:	f800283a 	ret

000091c4 <netif_add>:
netif_add(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
  struct ip_addr *gw,
  void *state,
  err_t (* init)(struct netif *netif),
  err_t (* input)(struct pbuf *p, struct netif *netif))
{
    91c4:	defffa04 	addi	sp,sp,-24
    91c8:	dfc00515 	stw	ra,20(sp)
    91cc:	df000415 	stw	fp,16(sp)
    91d0:	df000404 	addi	fp,sp,16
    91d4:	e13ffc15 	stw	r4,-16(fp)
    91d8:	e17ffd15 	stw	r5,-12(fp)
    91dc:	e1bffe15 	stw	r6,-8(fp)
    91e0:	e1ffff15 	stw	r7,-4(fp)
  static u8_t netifnum = 0;

  /* reset new interface configuration state */
  netif->ip_addr.addr = 0;
    91e4:	e0bffc17 	ldw	r2,-16(fp)
    91e8:	10000115 	stw	zero,4(r2)
  netif->netmask.addr = 0;
    91ec:	e0bffc17 	ldw	r2,-16(fp)
    91f0:	10000215 	stw	zero,8(r2)
  netif->gw.addr = 0;
    91f4:	e0bffc17 	ldw	r2,-16(fp)
    91f8:	10000315 	stw	zero,12(r2)
  netif->flags = 0;
    91fc:	e0bffc17 	ldw	r2,-16(fp)
    9200:	10000b45 	stb	zero,45(r2)
#if LWIP_DHCP
  /* netif not under DHCP control by default */
  netif->dhcp = NULL;
    9204:	e0bffc17 	ldw	r2,-16(fp)
    9208:	10000815 	stw	zero,32(r2)
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
    920c:	e0bffc17 	ldw	r2,-16(fp)
    9210:	e0c00217 	ldw	r3,8(fp)
    9214:	10c00715 	stw	r3,28(r2)
  netif->num = netifnum++;
    9218:	d0a8d103 	ldbu	r2,-23740(gp)
    921c:	e0fffc17 	ldw	r3,-16(fp)
    9220:	18800c05 	stb	r2,48(r3)
    9224:	10800044 	addi	r2,r2,1
    9228:	d0a8d105 	stb	r2,-23740(gp)
  netif->input = input;
    922c:	e0bffc17 	ldw	r2,-16(fp)
    9230:	e0c00417 	ldw	r3,16(fp)
    9234:	10c00415 	stw	r3,16(r2)
#endif /* LWIP_NETIF_HWADDRHINT*/
#if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
  netif->loop_cnt_current = 0;
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

  netif_set_addr(netif, ipaddr, netmask, gw);
    9238:	e13ffc17 	ldw	r4,-16(fp)
    923c:	e17ffd17 	ldw	r5,-12(fp)
    9240:	e1bffe17 	ldw	r6,-8(fp)
    9244:	e1ffff17 	ldw	r7,-4(fp)
    9248:	000929c0 	call	929c <netif_set_addr>

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
    924c:	e0800317 	ldw	r2,12(fp)
    9250:	e13ffc17 	ldw	r4,-16(fp)
    9254:	103ee83a 	callr	r2
    9258:	10803fcc 	andi	r2,r2,255
    925c:	1080201c 	xori	r2,r2,128
    9260:	10bfe004 	addi	r2,r2,-128
    9264:	10000226 	beq	r2,zero,9270 <netif_add+0xac>
    return NULL;
    9268:	0005883a 	mov	r2,zero
    926c:	00000606 	br	9288 <netif_add+0xc4>
  }

  /* add this netif to the list */
  netif->next = netif_list;
    9270:	d0e8d217 	ldw	r3,-23736(gp)
    9274:	e0bffc17 	ldw	r2,-16(fp)
    9278:	10c00015 	stw	r3,0(r2)
  netif_list = netif;
    927c:	e0bffc17 	ldw	r2,-16(fp)
    9280:	d0a8d215 	stw	r2,-23736(gp)
  LWIP_DEBUGF(NETIF_DEBUG, (" netmask "));
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
    9284:	e0bffc17 	ldw	r2,-16(fp)
}
    9288:	e037883a 	mov	sp,fp
    928c:	dfc00117 	ldw	ra,4(sp)
    9290:	df000017 	ldw	fp,0(sp)
    9294:	dec00204 	addi	sp,sp,8
    9298:	f800283a 	ret

0000929c <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
    struct ip_addr *gw)
{
    929c:	defffa04 	addi	sp,sp,-24
    92a0:	dfc00515 	stw	ra,20(sp)
    92a4:	df000415 	stw	fp,16(sp)
    92a8:	df000404 	addi	fp,sp,16
    92ac:	e13ffc15 	stw	r4,-16(fp)
    92b0:	e17ffd15 	stw	r5,-12(fp)
    92b4:	e1bffe15 	stw	r6,-8(fp)
    92b8:	e1ffff15 	stw	r7,-4(fp)
  netif_set_ipaddr(netif, ipaddr);
    92bc:	e13ffc17 	ldw	r4,-16(fp)
    92c0:	e17ffd17 	ldw	r5,-12(fp)
    92c4:	00094900 	call	9490 <netif_set_ipaddr>
  netif_set_netmask(netif, netmask);
    92c8:	e13ffc17 	ldw	r4,-16(fp)
    92cc:	e17ffe17 	ldw	r5,-8(fp)
    92d0:	00096380 	call	9638 <netif_set_netmask>
  netif_set_gw(netif, gw);
    92d4:	e13ffc17 	ldw	r4,-16(fp)
    92d8:	e17fff17 	ldw	r5,-4(fp)
    92dc:	00095e80 	call	95e8 <netif_set_gw>
}
    92e0:	e037883a 	mov	sp,fp
    92e4:	dfc00117 	ldw	ra,4(sp)
    92e8:	df000017 	ldw	fp,0(sp)
    92ec:	dec00204 	addi	sp,sp,8
    92f0:	f800283a 	ret

000092f4 <netif_remove>:
 * Remove a network interface from the list of lwIP netifs.
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
    92f4:	defffc04 	addi	sp,sp,-16
    92f8:	dfc00315 	stw	ra,12(sp)
    92fc:	df000215 	stw	fp,8(sp)
    9300:	df000204 	addi	fp,sp,8
    9304:	e13fff15 	stw	r4,-4(fp)
  if ( netif == NULL ) return;
    9308:	e0bfff17 	ldw	r2,-4(fp)
    930c:	10002026 	beq	r2,zero,9390 <netif_remove+0x9c>
#endif /* LWIP_IGMP */

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
    9310:	d0e8d217 	ldw	r3,-23736(gp)
    9314:	e0bfff17 	ldw	r2,-4(fp)
    9318:	1880041e 	bne	r3,r2,932c <netif_remove+0x38>
    netif_list = netif->next;
    931c:	e0bfff17 	ldw	r2,-4(fp)
    9320:	10800017 	ldw	r2,0(r2)
    9324:	d0a8d215 	stw	r2,-23736(gp)
    9328:	00001306 	br	9378 <netif_remove+0x84>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
    932c:	d0a8d217 	ldw	r2,-23736(gp)
    9330:	e0bffe15 	stw	r2,-8(fp)
    9334:	00000c06 	br	9368 <netif_remove+0x74>
      if (tmpNetif->next == netif) {
    9338:	e0bffe17 	ldw	r2,-8(fp)
    933c:	10c00017 	ldw	r3,0(r2)
    9340:	e0bfff17 	ldw	r2,-4(fp)
    9344:	1880051e 	bne	r3,r2,935c <netif_remove+0x68>
        tmpNetif->next = netif->next;
    9348:	e0bfff17 	ldw	r2,-4(fp)
    934c:	10c00017 	ldw	r3,0(r2)
    9350:	e0bffe17 	ldw	r2,-8(fp)
    9354:	10c00015 	stw	r3,0(r2)
        snmp_dec_iflist();
        break;
    9358:	00000506 	br	9370 <netif_remove+0x7c>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
    935c:	e0bffe17 	ldw	r2,-8(fp)
    9360:	10800017 	ldw	r2,0(r2)
    9364:	e0bffe15 	stw	r2,-8(fp)
    9368:	e0bffe17 	ldw	r2,-8(fp)
    936c:	103ff21e 	bne	r2,zero,9338 <netif_remove+0x44>
        tmpNetif->next = netif->next;
        snmp_dec_iflist();
        break;
      }
    }
    if (tmpNetif == NULL)
    9370:	e0bffe17 	ldw	r2,-8(fp)
    9374:	10000826 	beq	r2,zero,9398 <netif_remove+0xa4>
      return; /*  we didn't find any netif today */
  }
  /* this netif is default? */
  if (netif_default == netif)
    9378:	d0e8d317 	ldw	r3,-23732(gp)
    937c:	e0bfff17 	ldw	r2,-4(fp)
    9380:	1880061e 	bne	r3,r2,939c <netif_remove+0xa8>
    /* reset default netif */
    netif_set_default(NULL);
    9384:	0009883a 	mov	r4,zero
    9388:	00096880 	call	9688 <netif_set_default>
    938c:	00000306 	br	939c <netif_remove+0xa8>
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  if ( netif == NULL ) return;
    9390:	0001883a 	nop
    9394:	00000106 	br	939c <netif_remove+0xa8>
        snmp_dec_iflist();
        break;
      }
    }
    if (tmpNetif == NULL)
      return; /*  we didn't find any netif today */
    9398:	0001883a 	nop
  /* this netif is default? */
  if (netif_default == netif)
    /* reset default netif */
    netif_set_default(NULL);
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
    939c:	e037883a 	mov	sp,fp
    93a0:	dfc00117 	ldw	ra,4(sp)
    93a4:	df000017 	ldw	fp,0(sp)
    93a8:	dec00204 	addi	sp,sp,8
    93ac:	f800283a 	ret

000093b0 <netif_find>:
 * @param name the name of the netif (like netif->name) plus concatenated number
 * in ascii representation (e.g. 'en0')
 */
struct netif *
netif_find(char *name)
{
    93b0:	defffc04 	addi	sp,sp,-16
    93b4:	df000315 	stw	fp,12(sp)
    93b8:	df000304 	addi	fp,sp,12
    93bc:	e13fff15 	stw	r4,-4(fp)
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
    93c0:	e0bfff17 	ldw	r2,-4(fp)
    93c4:	1000021e 	bne	r2,zero,93d0 <netif_find+0x20>
    return NULL;
    93c8:	0005883a 	mov	r2,zero
    93cc:	00002c06 	br	9480 <netif_find+0xd0>
  }

  num = name[2] - '0';
    93d0:	e0bfff17 	ldw	r2,-4(fp)
    93d4:	10800084 	addi	r2,r2,2
    93d8:	10800003 	ldbu	r2,0(r2)
    93dc:	10bff404 	addi	r2,r2,-48
    93e0:	e0bffe05 	stb	r2,-8(fp)

  for(netif = netif_list; netif != NULL; netif = netif->next) {
    93e4:	d0a8d217 	ldw	r2,-23736(gp)
    93e8:	e0bffd15 	stw	r2,-12(fp)
    93ec:	00002106 	br	9474 <netif_find+0xc4>
    if (num == netif->num &&
    93f0:	e0bffd17 	ldw	r2,-12(fp)
    93f4:	10800c03 	ldbu	r2,48(r2)
    93f8:	10c03fcc 	andi	r3,r2,255
    93fc:	e0bffe03 	ldbu	r2,-8(fp)
    9400:	1880191e 	bne	r3,r2,9468 <netif_find+0xb8>
       name[0] == netif->name[0] &&
    9404:	e0bfff17 	ldw	r2,-4(fp)
    9408:	10c00003 	ldbu	r3,0(r2)
    940c:	e0bffd17 	ldw	r2,-12(fp)
    9410:	10800b83 	ldbu	r2,46(r2)
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
    if (num == netif->num &&
    9414:	18c03fcc 	andi	r3,r3,255
    9418:	18c0201c 	xori	r3,r3,128
    941c:	18ffe004 	addi	r3,r3,-128
    9420:	10803fcc 	andi	r2,r2,255
    9424:	1080201c 	xori	r2,r2,128
    9428:	10bfe004 	addi	r2,r2,-128
    942c:	18800e1e 	bne	r3,r2,9468 <netif_find+0xb8>
       name[0] == netif->name[0] &&
       name[1] == netif->name[1]) {
    9430:	e0bfff17 	ldw	r2,-4(fp)
    9434:	10800044 	addi	r2,r2,1
    9438:	10c00003 	ldbu	r3,0(r2)
    943c:	e0bffd17 	ldw	r2,-12(fp)
    9440:	10800bc3 	ldbu	r2,47(r2)

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
    if (num == netif->num &&
       name[0] == netif->name[0] &&
    9444:	18c03fcc 	andi	r3,r3,255
    9448:	18c0201c 	xori	r3,r3,128
    944c:	18ffe004 	addi	r3,r3,-128
    9450:	10803fcc 	andi	r2,r2,255
    9454:	1080201c 	xori	r2,r2,128
    9458:	10bfe004 	addi	r2,r2,-128
    945c:	1880021e 	bne	r3,r2,9468 <netif_find+0xb8>
       name[1] == netif->name[1]) {
      LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
      return netif;
    9460:	e0bffd17 	ldw	r2,-12(fp)
    9464:	00000606 	br	9480 <netif_find+0xd0>
    return NULL;
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
    9468:	e0bffd17 	ldw	r2,-12(fp)
    946c:	10800017 	ldw	r2,0(r2)
    9470:	e0bffd15 	stw	r2,-12(fp)
    9474:	e0bffd17 	ldw	r2,-12(fp)
    9478:	103fdd1e 	bne	r2,zero,93f0 <netif_find+0x40>
      LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
      return netif;
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
    947c:	0005883a 	mov	r2,zero
}
    9480:	e037883a 	mov	sp,fp
    9484:	df000017 	ldw	fp,0(sp)
    9488:	dec00104 	addi	sp,sp,4
    948c:	f800283a 	ret

00009490 <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, struct ip_addr *ipaddr)
{
    9490:	defff904 	addi	sp,sp,-28
    9494:	dfc00615 	stw	ra,24(sp)
    9498:	df000515 	stw	fp,20(sp)
    949c:	df000504 	addi	fp,sp,20
    94a0:	e13ffe15 	stw	r4,-8(fp)
    94a4:	e17fff15 	stw	r5,-4(fp)
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
    94a8:	e0bfff17 	ldw	r2,-4(fp)
    94ac:	10c0000b 	ldhu	r3,0(r2)
    94b0:	1080008b 	ldhu	r2,2(r2)
    94b4:	1004943a 	slli	r2,r2,16
    94b8:	10c4b03a 	or	r2,r2,r3
    94bc:	1007883a 	mov	r3,r2
    94c0:	e0bffe17 	ldw	r2,-8(fp)
    94c4:	10800117 	ldw	r2,4(r2)
    94c8:	18803726 	beq	r3,r2,95a8 <netif_set_ipaddr+0x118>
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    94cc:	008000f4 	movhi	r2,3
    94d0:	1095f604 	addi	r2,r2,22488
    94d4:	10800017 	ldw	r2,0(r2)
    94d8:	e0bffb15 	stw	r2,-20(fp)
    while (pcb != NULL) {
    94dc:	00001106 	br	9524 <netif_set_ipaddr+0x94>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
    94e0:	e0bffb17 	ldw	r2,-20(fp)
    94e4:	10c00017 	ldw	r3,0(r2)
    94e8:	e0bffe17 	ldw	r2,-8(fp)
    94ec:	10800117 	ldw	r2,4(r2)
    94f0:	1880091e 	bne	r3,r2,9518 <netif_set_ipaddr+0x88>
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
    94f4:	e0bffb17 	ldw	r2,-20(fp)
    94f8:	10800317 	ldw	r2,12(r2)
    94fc:	e0bffd15 	stw	r2,-12(fp)
        LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
    9500:	e13ffb17 	ldw	r4,-20(fp)
    9504:	01400044 	movi	r5,1
    9508:	000b4680 	call	b468 <tcp_abandon>
        pcb = next;
    950c:	e0bffd17 	ldw	r2,-12(fp)
    9510:	e0bffb15 	stw	r2,-20(fp)
    9514:	00000306 	br	9524 <netif_set_ipaddr+0x94>
      } else {
        pcb = pcb->next;
    9518:	e0bffb17 	ldw	r2,-20(fp)
    951c:	10800317 	ldw	r2,12(r2)
    9520:	e0bffb15 	stw	r2,-20(fp)
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
    9524:	e0bffb17 	ldw	r2,-20(fp)
    9528:	103fed1e 	bne	r2,zero,94e0 <netif_set_ipaddr+0x50>
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    952c:	008000f4 	movhi	r2,3
    9530:	1095f804 	addi	r2,r2,22496
    9534:	10800017 	ldw	r2,0(r2)
    9538:	e0bffc15 	stw	r2,-16(fp)
    953c:	00001806 	br	95a0 <netif_set_ipaddr+0x110>
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
    9540:	e0bffc17 	ldw	r2,-16(fp)
    9544:	10001326 	beq	r2,zero,9594 <netif_set_ipaddr+0x104>
    9548:	e0bffc17 	ldw	r2,-16(fp)
    954c:	10800017 	ldw	r2,0(r2)
    9550:	10001026 	beq	r2,zero,9594 <netif_set_ipaddr+0x104>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
    9554:	e0bffc17 	ldw	r2,-16(fp)
    9558:	10c00017 	ldw	r3,0(r2)
    955c:	e0bffe17 	ldw	r2,-8(fp)
    9560:	10800117 	ldw	r2,4(r2)
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
    9564:	18800b1e 	bne	r3,r2,9594 <netif_set_ipaddr+0x104>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
    9568:	e0bfff17 	ldw	r2,-4(fp)
    956c:	10000626 	beq	r2,zero,9588 <netif_set_ipaddr+0xf8>
    9570:	e0bfff17 	ldw	r2,-4(fp)
    9574:	10c0000b 	ldhu	r3,0(r2)
    9578:	1080008b 	ldhu	r2,2(r2)
    957c:	1004943a 	slli	r2,r2,16
    9580:	10c4b03a 	or	r2,r2,r3
    9584:	00000106 	br	958c <netif_set_ipaddr+0xfc>
    9588:	0005883a 	mov	r2,zero
    958c:	e0fffc17 	ldw	r3,-16(fp)
    9590:	18800015 	stw	r2,0(r3)
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    9594:	e0bffc17 	ldw	r2,-16(fp)
    9598:	10800317 	ldw	r2,12(r2)
    959c:	e0bffc15 	stw	r2,-16(fp)
    95a0:	e0bffc17 	ldw	r2,-16(fp)
    95a4:	103fe61e 	bne	r2,zero,9540 <netif_set_ipaddr+0xb0>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
    95a8:	e0bfff17 	ldw	r2,-4(fp)
    95ac:	10000626 	beq	r2,zero,95c8 <netif_set_ipaddr+0x138>
    95b0:	e0bfff17 	ldw	r2,-4(fp)
    95b4:	10c0000b 	ldhu	r3,0(r2)
    95b8:	1080008b 	ldhu	r2,2(r2)
    95bc:	1004943a 	slli	r2,r2,16
    95c0:	10c4b03a 	or	r2,r2,r3
    95c4:	00000106 	br	95cc <netif_set_ipaddr+0x13c>
    95c8:	0005883a 	mov	r2,zero
    95cc:	e0fffe17 	ldw	r3,-8(fp)
    95d0:	18800115 	stw	r2,4(r3)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->ip_addr),
    ip4_addr2(&netif->ip_addr),
    ip4_addr3(&netif->ip_addr),
    ip4_addr4(&netif->ip_addr)));
}
    95d4:	e037883a 	mov	sp,fp
    95d8:	dfc00117 	ldw	ra,4(sp)
    95dc:	df000017 	ldw	fp,0(sp)
    95e0:	dec00204 	addi	sp,sp,8
    95e4:	f800283a 	ret

000095e8 <netif_set_gw>:
 *
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, struct ip_addr *gw)
{
    95e8:	defffd04 	addi	sp,sp,-12
    95ec:	df000215 	stw	fp,8(sp)
    95f0:	df000204 	addi	fp,sp,8
    95f4:	e13ffe15 	stw	r4,-8(fp)
    95f8:	e17fff15 	stw	r5,-4(fp)
  ip_addr_set(&(netif->gw), gw);
    95fc:	e0bfff17 	ldw	r2,-4(fp)
    9600:	10000626 	beq	r2,zero,961c <netif_set_gw+0x34>
    9604:	e0bfff17 	ldw	r2,-4(fp)
    9608:	10c0000b 	ldhu	r3,0(r2)
    960c:	1080008b 	ldhu	r2,2(r2)
    9610:	1004943a 	slli	r2,r2,16
    9614:	10c4b03a 	or	r2,r2,r3
    9618:	00000106 	br	9620 <netif_set_gw+0x38>
    961c:	0005883a 	mov	r2,zero
    9620:	e0fffe17 	ldw	r3,-8(fp)
    9624:	18800315 	stw	r2,12(r3)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->gw),
    ip4_addr2(&netif->gw),
    ip4_addr3(&netif->gw),
    ip4_addr4(&netif->gw)));
}
    9628:	e037883a 	mov	sp,fp
    962c:	df000017 	ldw	fp,0(sp)
    9630:	dec00104 	addi	sp,sp,4
    9634:	f800283a 	ret

00009638 <netif_set_netmask>:
 * @note call netif_set_addr() if you also want to change ip address and
 * default gateway
 */
void
netif_set_netmask(struct netif *netif, struct ip_addr *netmask)
{
    9638:	defffd04 	addi	sp,sp,-12
    963c:	df000215 	stw	fp,8(sp)
    9640:	df000204 	addi	fp,sp,8
    9644:	e13ffe15 	stw	r4,-8(fp)
    9648:	e17fff15 	stw	r5,-4(fp)
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
    964c:	e0bfff17 	ldw	r2,-4(fp)
    9650:	10000626 	beq	r2,zero,966c <netif_set_netmask+0x34>
    9654:	e0bfff17 	ldw	r2,-4(fp)
    9658:	10c0000b 	ldhu	r3,0(r2)
    965c:	1080008b 	ldhu	r2,2(r2)
    9660:	1004943a 	slli	r2,r2,16
    9664:	10c4b03a 	or	r2,r2,r3
    9668:	00000106 	br	9670 <netif_set_netmask+0x38>
    966c:	0005883a 	mov	r2,zero
    9670:	e0fffe17 	ldw	r3,-8(fp)
    9674:	18800215 	stw	r2,8(r3)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->netmask),
    ip4_addr2(&netif->netmask),
    ip4_addr3(&netif->netmask),
    ip4_addr4(&netif->netmask)));
}
    9678:	e037883a 	mov	sp,fp
    967c:	df000017 	ldw	fp,0(sp)
    9680:	dec00104 	addi	sp,sp,4
    9684:	f800283a 	ret

00009688 <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
    9688:	defffe04 	addi	sp,sp,-8
    968c:	df000115 	stw	fp,4(sp)
    9690:	df000104 	addi	fp,sp,4
    9694:	e13fff15 	stw	r4,-4(fp)
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
    9698:	e0bfff17 	ldw	r2,-4(fp)
    969c:	d0a8d315 	stw	r2,-23732(gp)
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
    96a0:	e037883a 	mov	sp,fp
    96a4:	df000017 	ldw	fp,0(sp)
    96a8:	dec00104 	addi	sp,sp,4
    96ac:	f800283a 	ret

000096b0 <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
    96b0:	defffd04 	addi	sp,sp,-12
    96b4:	dfc00215 	stw	ra,8(sp)
    96b8:	df000115 	stw	fp,4(sp)
    96bc:	df000104 	addi	fp,sp,4
    96c0:	e13fff15 	stw	r4,-4(fp)
  if ( !(netif->flags & NETIF_FLAG_UP )) {
    96c4:	e0bfff17 	ldw	r2,-4(fp)
    96c8:	10800b43 	ldbu	r2,45(r2)
    96cc:	10803fcc 	andi	r2,r2,255
    96d0:	1080004c 	andi	r2,r2,1
    96d4:	1000101e 	bne	r2,zero,9718 <netif_set_up+0x68>
    netif->flags |= NETIF_FLAG_UP;
    96d8:	e0bfff17 	ldw	r2,-4(fp)
    96dc:	10800b43 	ldbu	r2,45(r2)
    96e0:	10800054 	ori	r2,r2,1
    96e4:	1007883a 	mov	r3,r2
    96e8:	e0bfff17 	ldw	r2,-4(fp)
    96ec:	10c00b45 	stb	r3,45(r2)
    NETIF_LINK_CALLBACK(netif);
    NETIF_STATUS_CALLBACK(netif);

#if LWIP_ARP
    /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */ 
    if (netif->flags & NETIF_FLAG_ETHARP) {
    96f0:	e0bfff17 	ldw	r2,-4(fp)
    96f4:	10800b43 	ldbu	r2,45(r2)
    96f8:	10803fcc 	andi	r2,r2,255
    96fc:	1080080c 	andi	r2,r2,32
    9700:	10000526 	beq	r2,zero,9718 <netif_set_up+0x68>
      etharp_gratuitous(netif);
    9704:	e0bfff17 	ldw	r2,-4(fp)
    9708:	10800104 	addi	r2,r2,4
    970c:	e13fff17 	ldw	r4,-4(fp)
    9710:	100b883a 	mov	r5,r2
    9714:	0015ff80 	call	15ff8 <etharp_request>
    if (netif->flags & NETIF_FLAG_IGMP) {
      igmp_report_groups( netif);
    }
#endif /* LWIP_IGMP */
  }
}
    9718:	e037883a 	mov	sp,fp
    971c:	dfc00117 	ldw	ra,4(sp)
    9720:	df000017 	ldw	fp,0(sp)
    9724:	dec00204 	addi	sp,sp,8
    9728:	f800283a 	ret

0000972c <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
    972c:	defffe04 	addi	sp,sp,-8
    9730:	df000115 	stw	fp,4(sp)
    9734:	df000104 	addi	fp,sp,4
    9738:	e13fff15 	stw	r4,-4(fp)
  if ( netif->flags & NETIF_FLAG_UP )
    973c:	e0bfff17 	ldw	r2,-4(fp)
    9740:	10800b43 	ldbu	r2,45(r2)
    9744:	10803fcc 	andi	r2,r2,255
    9748:	1080004c 	andi	r2,r2,1
    974c:	10000726 	beq	r2,zero,976c <netif_set_down+0x40>
    {
      netif->flags &= ~NETIF_FLAG_UP;
    9750:	e0bfff17 	ldw	r2,-4(fp)
    9754:	10c00b43 	ldbu	r3,45(r2)
    9758:	00bfff84 	movi	r2,-2
    975c:	1884703a 	and	r2,r3,r2
    9760:	1007883a 	mov	r3,r2
    9764:	e0bfff17 	ldw	r2,-4(fp)
    9768:	10c00b45 	stb	r3,45(r2)
#endif
      
      NETIF_LINK_CALLBACK(netif);
      NETIF_STATUS_CALLBACK(netif);
    }
}
    976c:	e037883a 	mov	sp,fp
    9770:	df000017 	ldw	fp,0(sp)
    9774:	dec00104 	addi	sp,sp,4
    9778:	f800283a 	ret

0000977c <netif_is_up>:

/**
 * Ask if an interface is up
 */ 
u8_t netif_is_up(struct netif *netif)
{
    977c:	defffe04 	addi	sp,sp,-8
    9780:	df000115 	stw	fp,4(sp)
    9784:	df000104 	addi	fp,sp,4
    9788:	e13fff15 	stw	r4,-4(fp)
  return (netif->flags & NETIF_FLAG_UP)?1:0;
    978c:	e0bfff17 	ldw	r2,-4(fp)
    9790:	10800b43 	ldbu	r2,45(r2)
    9794:	10803fcc 	andi	r2,r2,255
    9798:	1080004c 	andi	r2,r2,1
    979c:	1004c03a 	cmpne	r2,r2,zero
}
    97a0:	e037883a 	mov	sp,fp
    97a4:	df000017 	ldw	fp,0(sp)
    97a8:	dec00104 	addi	sp,sp,4
    97ac:	f800283a 	ret

000097b0 <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
    97b0:	defff604 	addi	sp,sp,-40
    97b4:	dfc00915 	stw	ra,36(sp)
    97b8:	df000815 	stw	fp,32(sp)
    97bc:	df000804 	addi	fp,sp,32
    97c0:	e13ffd15 	stw	r4,-12(fp)
    97c4:	2805883a 	mov	r2,r5
    97c8:	e1bfff15 	stw	r6,-4(fp)
    97cc:	e0bffe0d 	sth	r2,-8(fp)
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
    97d0:	e03ffa0d 	sth	zero,-24(fp)
  switch (layer) {
    97d4:	e0bffd17 	ldw	r2,-12(fp)
    97d8:	10c00060 	cmpeqi	r3,r2,1
    97dc:	1800091e 	bne	r3,zero,9804 <pbuf_alloc+0x54>
    97e0:	0080052e 	bgeu	zero,r2,97f8 <pbuf_alloc+0x48>
    97e4:	10c000a0 	cmpeqi	r3,r2,2
    97e8:	1800091e 	bne	r3,zero,9810 <pbuf_alloc+0x60>
    97ec:	108000e0 	cmpeqi	r2,r2,3
    97f0:	1000141e 	bne	r2,zero,9844 <pbuf_alloc+0x94>
    97f4:	00000a06 	br	9820 <pbuf_alloc+0x70>
  case PBUF_TRANSPORT:
    /* add room for transport (often TCP) layer header */
    offset += PBUF_TRANSPORT_HLEN;
    97f8:	e0bffa0b 	ldhu	r2,-24(fp)
    97fc:	10800504 	addi	r2,r2,20
    9800:	e0bffa0d 	sth	r2,-24(fp)
    /* FALLTHROUGH */
  case PBUF_IP:
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
    9804:	e0bffa0b 	ldhu	r2,-24(fp)
    9808:	10800504 	addi	r2,r2,20
    980c:	e0bffa0d 	sth	r2,-24(fp)
    /* FALLTHROUGH */
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
    9810:	e0bffa0b 	ldhu	r2,-24(fp)
    9814:	10800384 	addi	r2,r2,14
    9818:	e0bffa0d 	sth	r2,-24(fp)
    break;
    981c:	00000a06 	br	9848 <pbuf_alloc+0x98>
  case PBUF_RAW:
    break;
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
    9820:	010000f4 	movhi	r4,3
    9824:	21381b04 	addi	r4,r4,-8084
    9828:	014000f4 	movhi	r5,3
    982c:	29782504 	addi	r5,r5,-8044
    9830:	018033c4 	movi	r6,207
    9834:	01c000f4 	movhi	r7,3
    9838:	39f82c04 	addi	r7,r7,-8016
    983c:	00166c00 	call	166c0 <printf>
    9840:	003fff06 	br	9840 <pbuf_alloc+0x90>
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
    break;
  case PBUF_RAW:
    break;
    9844:	0001883a 	nop
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
    return NULL;
  }

  switch (type) {
    9848:	e0bfff17 	ldw	r2,-4(fp)
    984c:	10c000e8 	cmpgeui	r3,r2,3
    9850:	1800021e 	bne	r3,zero,985c <pbuf_alloc+0xac>
    9854:	0080fa36 	bltu	zero,r2,9c40 <pbuf_alloc+0x490>
    9858:	0000c106 	br	9b60 <pbuf_alloc+0x3b0>
    985c:	108000e0 	cmpeqi	r2,r2,3
    9860:	10010e26 	beq	r2,zero,9c9c <pbuf_alloc+0x4ec>
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
    p = memp_malloc(MEMP_PBUF_POOL);
    9864:	01000204 	movi	r4,8
    9868:	0008ef00 	call	8ef0 <memp_malloc>
    986c:	e0bff815 	stw	r2,-32(fp)
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
    9870:	e0bff817 	ldw	r2,-32(fp)
    9874:	1000021e 	bne	r2,zero,9880 <pbuf_alloc+0xd0>
      PBUF_POOL_IS_EMPTY();
      return NULL;
    9878:	0005883a 	mov	r2,zero
    987c:	00011706 	br	9cdc <pbuf_alloc+0x52c>
    }
    p->type = type;
    9880:	e0bfff17 	ldw	r2,-4(fp)
    9884:	1007883a 	mov	r3,r2
    9888:	e0bff817 	ldw	r2,-32(fp)
    988c:	10c00305 	stb	r3,12(r2)
    p->next = NULL;
    9890:	e0bff817 	ldw	r2,-32(fp)
    9894:	10000015 	stw	zero,0(r2)

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
    9898:	e0bffa0b 	ldhu	r2,-24(fp)
    989c:	10800404 	addi	r2,r2,16
    98a0:	e0fff817 	ldw	r3,-32(fp)
    98a4:	1885883a 	add	r2,r3,r2
    98a8:	10c000c4 	addi	r3,r2,3
    98ac:	00bfff04 	movi	r2,-4
    98b0:	1884703a 	and	r2,r3,r2
    98b4:	1007883a 	mov	r3,r2
    98b8:	e0bff817 	ldw	r2,-32(fp)
    98bc:	10c00115 	stw	r3,4(r2)
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
    98c0:	e0bff817 	ldw	r2,-32(fp)
    98c4:	10800117 	ldw	r2,4(r2)
    98c8:	108000cc 	andi	r2,r2,3
    98cc:	10000926 	beq	r2,zero,98f4 <pbuf_alloc+0x144>
    98d0:	010000f4 	movhi	r4,3
    98d4:	21381b04 	addi	r4,r4,-8084
    98d8:	014000f4 	movhi	r5,3
    98dc:	29783204 	addi	r5,r5,-7992
    98e0:	01803884 	movi	r6,226
    98e4:	01c000f4 	movhi	r7,3
    98e8:	39f82c04 	addi	r7,r7,-8016
    98ec:	00166c00 	call	166c0 <printf>
    98f0:	003fff06 	br	98f0 <pbuf_alloc+0x140>
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
    98f4:	e0bff817 	ldw	r2,-32(fp)
    98f8:	e0fffe0b 	ldhu	r3,-8(fp)
    98fc:	10c0020d 	sth	r3,8(r2)
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
    9900:	e0bffa0b 	ldhu	r2,-24(fp)
    9904:	10c000c4 	addi	r3,r2,3
    9908:	00bfff04 	movi	r2,-4
    990c:	1884703a 	and	r2,r3,r2
    9910:	00c17b04 	movi	r3,1516
    9914:	1885c83a 	sub	r2,r3,r2
    9918:	e0fffe0b 	ldhu	r3,-8(fp)
    991c:	1880010e 	bge	r3,r2,9924 <pbuf_alloc+0x174>
    9920:	1805883a 	mov	r2,r3
    9924:	1007883a 	mov	r3,r2
    9928:	e0bff817 	ldw	r2,-32(fp)
    992c:	10c0028d 	sth	r3,10(r2)
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
    9930:	e0bff817 	ldw	r2,-32(fp)
    9934:	10c00117 	ldw	r3,4(r2)
    9938:	e0bff817 	ldw	r2,-32(fp)
    993c:	1080028b 	ldhu	r2,10(r2)
    9940:	10bfffcc 	andi	r2,r2,65535
    9944:	1885883a 	add	r2,r3,r2
    9948:	e0fff817 	ldw	r3,-32(fp)
    994c:	18c17f04 	addi	r3,r3,1532
    9950:	1880092e 	bgeu	r3,r2,9978 <pbuf_alloc+0x1c8>
    9954:	010000f4 	movhi	r4,3
    9958:	21381b04 	addi	r4,r4,-8084
    995c:	014000f4 	movhi	r5,3
    9960:	29783e04 	addi	r5,r5,-7944
    9964:	01803a44 	movi	r6,233
    9968:	01c000f4 	movhi	r7,3
    996c:	39f82c04 	addi	r7,r7,-8016
    9970:	00166c00 	call	166c0 <printf>
    9974:	003fff06 	br	9974 <pbuf_alloc+0x1c4>
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    LWIP_ASSERT("PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",
    9978:	e0bffa0b 	ldhu	r2,-24(fp)
    997c:	10c000c4 	addi	r3,r2,3
    9980:	00bfff04 	movi	r2,-4
    9984:	1884703a 	and	r2,r3,r2
    9988:	00c17b04 	movi	r3,1516
    998c:	1885c83a 	sub	r2,r3,r2
    9990:	00800916 	blt	zero,r2,99b8 <pbuf_alloc+0x208>
    9994:	010000f4 	movhi	r4,3
    9998:	21381b04 	addi	r4,r4,-8084
    999c:	014000f4 	movhi	r5,3
    99a0:	29784b04 	addi	r5,r5,-7892
    99a4:	01803ac4 	movi	r6,235
    99a8:	01c000f4 	movhi	r7,3
    99ac:	39f82c04 	addi	r7,r7,-8016
    99b0:	00166c00 	call	166c0 <printf>
    99b4:	003fff06 	br	99b4 <pbuf_alloc+0x204>
      (PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)) > 0 );
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
    99b8:	e0bff817 	ldw	r2,-32(fp)
    99bc:	00c00044 	movi	r3,1
    99c0:	10c0038d 	sth	r3,14(r2)

    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
    99c4:	e0bff817 	ldw	r2,-32(fp)
    99c8:	e0bff915 	stw	r2,-28(fp)
    /* remaining length to be allocated */
    rem_len = length - p->len;
    99cc:	e0fffe0b 	ldhu	r3,-8(fp)
    99d0:	e0bff817 	ldw	r2,-32(fp)
    99d4:	1080028b 	ldhu	r2,10(r2)
    99d8:	10bfffcc 	andi	r2,r2,65535
    99dc:	1885c83a 	sub	r2,r3,r2
    99e0:	e0bffb15 	stw	r2,-20(fp)
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
    99e4:	00005b06 	br	9b54 <pbuf_alloc+0x3a4>
      q = memp_malloc(MEMP_PBUF_POOL);
    99e8:	01000204 	movi	r4,8
    99ec:	0008ef00 	call	8ef0 <memp_malloc>
    99f0:	e0bffc15 	stw	r2,-16(fp)
      if (q == NULL) {
    99f4:	e0bffc17 	ldw	r2,-16(fp)
    99f8:	1000041e 	bne	r2,zero,9a0c <pbuf_alloc+0x25c>
        PBUF_POOL_IS_EMPTY();
        /* free chain so far allocated */
        pbuf_free(p);
    99fc:	e13ff817 	ldw	r4,-32(fp)
    9a00:	000a16c0 	call	a16c <pbuf_free>
        /* bail out unsuccesfully */
        return NULL;
    9a04:	0005883a 	mov	r2,zero
    9a08:	0000b406 	br	9cdc <pbuf_alloc+0x52c>
      }
      q->type = type;
    9a0c:	e0bfff17 	ldw	r2,-4(fp)
    9a10:	1007883a 	mov	r3,r2
    9a14:	e0bffc17 	ldw	r2,-16(fp)
    9a18:	10c00305 	stb	r3,12(r2)
      q->flags = 0;
    9a1c:	e0bffc17 	ldw	r2,-16(fp)
    9a20:	10000345 	stb	zero,13(r2)
      q->next = NULL;
    9a24:	e0bffc17 	ldw	r2,-16(fp)
    9a28:	10000015 	stw	zero,0(r2)
      /* make previous pbuf point to this pbuf */
      r->next = q;
    9a2c:	e0bff917 	ldw	r2,-28(fp)
    9a30:	e0fffc17 	ldw	r3,-16(fp)
    9a34:	10c00015 	stw	r3,0(r2)
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
    9a38:	e0bffb17 	ldw	r2,-20(fp)
    9a3c:	00ffff94 	movui	r3,65534
    9a40:	1880090e 	bge	r3,r2,9a68 <pbuf_alloc+0x2b8>
    9a44:	010000f4 	movhi	r4,3
    9a48:	21381b04 	addi	r4,r4,-8084
    9a4c:	014000f4 	movhi	r5,3
    9a50:	29785804 	addi	r5,r5,-7840
    9a54:	01804144 	movi	r6,261
    9a58:	01c000f4 	movhi	r7,3
    9a5c:	39f82c04 	addi	r7,r7,-8016
    9a60:	00166c00 	call	166c0 <printf>
    9a64:	003fff06 	br	9a64 <pbuf_alloc+0x2b4>
      q->tot_len = (u16_t)rem_len;
    9a68:	e0bffb17 	ldw	r2,-20(fp)
    9a6c:	1007883a 	mov	r3,r2
    9a70:	e0bffc17 	ldw	r2,-16(fp)
    9a74:	10c0020d 	sth	r3,8(r2)
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
    9a78:	e0bffb17 	ldw	r2,-20(fp)
    9a7c:	10bfffcc 	andi	r2,r2,65535
    9a80:	10817b28 	cmpgeui	r2,r2,1516
    9a84:	1000021e 	bne	r2,zero,9a90 <pbuf_alloc+0x2e0>
    9a88:	e0bffb17 	ldw	r2,-20(fp)
    9a8c:	00000106 	br	9a94 <pbuf_alloc+0x2e4>
    9a90:	00817b04 	movi	r2,1516
    9a94:	e0fffc17 	ldw	r3,-16(fp)
    9a98:	1880028d 	sth	r2,10(r3)
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
    9a9c:	e0bffc17 	ldw	r2,-16(fp)
    9aa0:	10c00404 	addi	r3,r2,16
    9aa4:	e0bffc17 	ldw	r2,-16(fp)
    9aa8:	10c00115 	stw	r3,4(r2)
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
    9aac:	e0bffc17 	ldw	r2,-16(fp)
    9ab0:	10800117 	ldw	r2,4(r2)
    9ab4:	108000cc 	andi	r2,r2,3
    9ab8:	10000926 	beq	r2,zero,9ae0 <pbuf_alloc+0x330>
    9abc:	010000f4 	movhi	r4,3
    9ac0:	21381b04 	addi	r4,r4,-8084
    9ac4:	014000f4 	movhi	r5,3
    9ac8:	29785d04 	addi	r5,r5,-7820
    9acc:	018042c4 	movi	r6,267
    9ad0:	01c000f4 	movhi	r7,3
    9ad4:	39f82c04 	addi	r7,r7,-8016
    9ad8:	00166c00 	call	166c0 <printf>
    9adc:	003fff06 	br	9adc <pbuf_alloc+0x32c>
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
    9ae0:	e0bff817 	ldw	r2,-32(fp)
    9ae4:	10c00117 	ldw	r3,4(r2)
    9ae8:	e0bff817 	ldw	r2,-32(fp)
    9aec:	1080028b 	ldhu	r2,10(r2)
    9af0:	10bfffcc 	andi	r2,r2,65535
    9af4:	1885883a 	add	r2,r3,r2
    9af8:	e0fff817 	ldw	r3,-32(fp)
    9afc:	18c17f04 	addi	r3,r3,1532
    9b00:	1880092e 	bgeu	r3,r2,9b28 <pbuf_alloc+0x378>
    9b04:	010000f4 	movhi	r4,3
    9b08:	21381b04 	addi	r4,r4,-8084
    9b0c:	014000f4 	movhi	r5,3
    9b10:	29783e04 	addi	r5,r5,-7944
    9b14:	01804384 	movi	r6,270
    9b18:	01c000f4 	movhi	r7,3
    9b1c:	39f82c04 	addi	r7,r7,-8016
    9b20:	00166c00 	call	166c0 <printf>
    9b24:	003fff06 	br	9b24 <pbuf_alloc+0x374>
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
    9b28:	e0bffc17 	ldw	r2,-16(fp)
    9b2c:	00c00044 	movi	r3,1
    9b30:	10c0038d 	sth	r3,14(r2)
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
    9b34:	e0bffc17 	ldw	r2,-16(fp)
    9b38:	1080028b 	ldhu	r2,10(r2)
    9b3c:	10bfffcc 	andi	r2,r2,65535
    9b40:	e0fffb17 	ldw	r3,-20(fp)
    9b44:	1885c83a 	sub	r2,r3,r2
    9b48:	e0bffb15 	stw	r2,-20(fp)
      /* remember this pbuf for linkage in next iteration */
      r = q;
    9b4c:	e0bffc17 	ldw	r2,-16(fp)
    9b50:	e0bff915 	stw	r2,-28(fp)
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
    9b54:	e0bffb17 	ldw	r2,-20(fp)
    9b58:	00bfa316 	blt	zero,r2,99e8 <pbuf_alloc+0x238>
      r = q;
    }
    /* end of chain */
    /*r->next = NULL;*/

    break;
    9b5c:	00005906 	br	9cc4 <pbuf_alloc+0x514>
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
    9b60:	e0bffa0b 	ldhu	r2,-24(fp)
    9b64:	108004c4 	addi	r2,r2,19
    9b68:	1007883a 	mov	r3,r2
    9b6c:	00bfff04 	movi	r2,-4
    9b70:	1884703a 	and	r2,r3,r2
    9b74:	1007883a 	mov	r3,r2
    9b78:	e0bffe0b 	ldhu	r2,-8(fp)
    9b7c:	108000c4 	addi	r2,r2,3
    9b80:	1009883a 	mov	r4,r2
    9b84:	00bfff04 	movi	r2,-4
    9b88:	2084703a 	and	r2,r4,r2
    9b8c:	1885883a 	add	r2,r3,r2
    9b90:	10bfffcc 	andi	r2,r2,65535
    9b94:	1009883a 	mov	r4,r2
    9b98:	00088d00 	call	88d0 <mem_malloc>
    9b9c:	e0bff815 	stw	r2,-32(fp)
    if (p == NULL) {
    9ba0:	e0bff817 	ldw	r2,-32(fp)
    9ba4:	1000021e 	bne	r2,zero,9bb0 <pbuf_alloc+0x400>
      return NULL;
    9ba8:	0005883a 	mov	r2,zero
    9bac:	00004b06 	br	9cdc <pbuf_alloc+0x52c>
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
    9bb0:	e0bffa0b 	ldhu	r2,-24(fp)
    9bb4:	10800404 	addi	r2,r2,16
    9bb8:	e0fff817 	ldw	r3,-32(fp)
    9bbc:	1885883a 	add	r2,r3,r2
    9bc0:	10c000c4 	addi	r3,r2,3
    9bc4:	00bfff04 	movi	r2,-4
    9bc8:	1884703a 	and	r2,r3,r2
    9bcc:	1007883a 	mov	r3,r2
    9bd0:	e0bff817 	ldw	r2,-32(fp)
    9bd4:	10c00115 	stw	r3,4(r2)
    p->len = p->tot_len = length;
    9bd8:	e0bff817 	ldw	r2,-32(fp)
    9bdc:	e0fffe0b 	ldhu	r3,-8(fp)
    9be0:	10c0020d 	sth	r3,8(r2)
    9be4:	e0bff817 	ldw	r2,-32(fp)
    9be8:	10c0020b 	ldhu	r3,8(r2)
    9bec:	e0bff817 	ldw	r2,-32(fp)
    9bf0:	10c0028d 	sth	r3,10(r2)
    p->next = NULL;
    9bf4:	e0bff817 	ldw	r2,-32(fp)
    9bf8:	10000015 	stw	zero,0(r2)
    p->type = type;
    9bfc:	e0bfff17 	ldw	r2,-4(fp)
    9c00:	1007883a 	mov	r3,r2
    9c04:	e0bff817 	ldw	r2,-32(fp)
    9c08:	10c00305 	stb	r3,12(r2)

    LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
    9c0c:	e0bff817 	ldw	r2,-32(fp)
    9c10:	10800117 	ldw	r2,4(r2)
    9c14:	108000cc 	andi	r2,r2,3
    9c18:	10002926 	beq	r2,zero,9cc0 <pbuf_alloc+0x510>
    9c1c:	010000f4 	movhi	r4,3
    9c20:	21381b04 	addi	r4,r4,-8084
    9c24:	014000f4 	movhi	r5,3
    9c28:	29786904 	addi	r5,r5,-7772
    9c2c:	01804984 	movi	r6,294
    9c30:	01c000f4 	movhi	r7,3
    9c34:	39f82c04 	addi	r7,r7,-8016
    9c38:	00166c00 	call	166c0 <printf>
    9c3c:	003fff06 	br	9c3c <pbuf_alloc+0x48c>
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = memp_malloc(MEMP_PBUF);
    9c40:	010001c4 	movi	r4,7
    9c44:	0008ef00 	call	8ef0 <memp_malloc>
    9c48:	e0bff815 	stw	r2,-32(fp)
    if (p == NULL) {
    9c4c:	e0bff817 	ldw	r2,-32(fp)
    9c50:	1000021e 	bne	r2,zero,9c5c <pbuf_alloc+0x4ac>
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                  ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
    9c54:	0005883a 	mov	r2,zero
    9c58:	00002006 	br	9cdc <pbuf_alloc+0x52c>
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
    9c5c:	e0bff817 	ldw	r2,-32(fp)
    9c60:	10000115 	stw	zero,4(r2)
    p->len = p->tot_len = length;
    9c64:	e0bff817 	ldw	r2,-32(fp)
    9c68:	e0fffe0b 	ldhu	r3,-8(fp)
    9c6c:	10c0020d 	sth	r3,8(r2)
    9c70:	e0bff817 	ldw	r2,-32(fp)
    9c74:	10c0020b 	ldhu	r3,8(r2)
    9c78:	e0bff817 	ldw	r2,-32(fp)
    9c7c:	10c0028d 	sth	r3,10(r2)
    p->next = NULL;
    9c80:	e0bff817 	ldw	r2,-32(fp)
    9c84:	10000015 	stw	zero,0(r2)
    p->type = type;
    9c88:	e0bfff17 	ldw	r2,-4(fp)
    9c8c:	1007883a 	mov	r3,r2
    9c90:	e0bff817 	ldw	r2,-32(fp)
    9c94:	10c00305 	stb	r3,12(r2)
    break;
    9c98:	00000a06 	br	9cc4 <pbuf_alloc+0x514>
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
    9c9c:	010000f4 	movhi	r4,3
    9ca0:	21381b04 	addi	r4,r4,-8084
    9ca4:	014000f4 	movhi	r5,3
    9ca8:	29787404 	addi	r5,r5,-7728
    9cac:	01804ec4 	movi	r6,315
    9cb0:	01c000f4 	movhi	r7,3
    9cb4:	39f82c04 	addi	r7,r7,-8016
    9cb8:	00166c00 	call	166c0 <printf>
    9cbc:	003fff06 	br	9cbc <pbuf_alloc+0x50c>
    p->next = NULL;
    p->type = type;

    LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
           ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    break;
    9cc0:	0001883a 	nop
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
    return NULL;
  }
  /* set reference count */
  p->ref = 1;
    9cc4:	e0bff817 	ldw	r2,-32(fp)
    9cc8:	00c00044 	movi	r3,1
    9ccc:	10c0038d 	sth	r3,14(r2)
  /* set flags */
  p->flags = 0;
    9cd0:	e0bff817 	ldw	r2,-32(fp)
    9cd4:	10000345 	stb	zero,13(r2)
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
    9cd8:	e0bff817 	ldw	r2,-32(fp)
}
    9cdc:	e037883a 	mov	sp,fp
    9ce0:	dfc00117 	ldw	ra,4(sp)
    9ce4:	df000017 	ldw	fp,0(sp)
    9ce8:	dec00204 	addi	sp,sp,8
    9cec:	f800283a 	ret

00009cf0 <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
    9cf0:	defff904 	addi	sp,sp,-28
    9cf4:	dfc00615 	stw	ra,24(sp)
    9cf8:	df000515 	stw	fp,20(sp)
    9cfc:	df000504 	addi	fp,sp,20
    9d00:	e13ffe15 	stw	r4,-8(fp)
    9d04:	2805883a 	mov	r2,r5
    9d08:	e0bfff0d 	sth	r2,-4(fp)
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  s32_t grow;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
    9d0c:	e0bffe17 	ldw	r2,-8(fp)
    9d10:	1000091e 	bne	r2,zero,9d38 <pbuf_realloc+0x48>
    9d14:	010000f4 	movhi	r4,3
    9d18:	21381b04 	addi	r4,r4,-8084
    9d1c:	014000f4 	movhi	r5,3
    9d20:	29787b04 	addi	r5,r5,-7700
    9d24:	01805744 	movi	r6,349
    9d28:	01c000f4 	movhi	r7,3
    9d2c:	39f82c04 	addi	r7,r7,-8016
    9d30:	00166c00 	call	166c0 <printf>
    9d34:	003fff06 	br	9d34 <pbuf_realloc+0x44>
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
    9d38:	e0bffe17 	ldw	r2,-8(fp)
    9d3c:	10800303 	ldbu	r2,12(r2)
    9d40:	10803fcc 	andi	r2,r2,255
    9d44:	108000e0 	cmpeqi	r2,r2,3
    9d48:	1000171e 	bne	r2,zero,9da8 <pbuf_realloc+0xb8>
    9d4c:	e0bffe17 	ldw	r2,-8(fp)
    9d50:	10800303 	ldbu	r2,12(r2)
    9d54:	10803fcc 	andi	r2,r2,255
    9d58:	10800060 	cmpeqi	r2,r2,1
    9d5c:	1000121e 	bne	r2,zero,9da8 <pbuf_realloc+0xb8>
    9d60:	e0bffe17 	ldw	r2,-8(fp)
    9d64:	10800303 	ldbu	r2,12(r2)
    9d68:	10803fcc 	andi	r2,r2,255
    9d6c:	10000e26 	beq	r2,zero,9da8 <pbuf_realloc+0xb8>
    9d70:	e0bffe17 	ldw	r2,-8(fp)
    9d74:	10800303 	ldbu	r2,12(r2)
    9d78:	10803fcc 	andi	r2,r2,255
    9d7c:	108000a0 	cmpeqi	r2,r2,2
    9d80:	1000091e 	bne	r2,zero,9da8 <pbuf_realloc+0xb8>
    9d84:	010000f4 	movhi	r4,3
    9d88:	21381b04 	addi	r4,r4,-8084
    9d8c:	014000f4 	movhi	r5,3
    9d90:	29788104 	addi	r5,r5,-7676
    9d94:	01805844 	movi	r6,353
    9d98:	01c000f4 	movhi	r7,3
    9d9c:	39f82c04 	addi	r7,r7,-8016
    9da0:	00166c00 	call	166c0 <printf>
    9da4:	003fff06 	br	9da4 <pbuf_realloc+0xb4>
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
    9da8:	e0bffe17 	ldw	r2,-8(fp)
    9dac:	1080020b 	ldhu	r2,8(r2)
    9db0:	10bfffcc 	andi	r2,r2,65535
    9db4:	e0ffff0b 	ldhu	r3,-4(fp)
    9db8:	1880682e 	bgeu	r3,r2,9f5c <pbuf_realloc+0x26c>
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
    9dbc:	e0ffff0b 	ldhu	r3,-4(fp)
    9dc0:	e0bffe17 	ldw	r2,-8(fp)
    9dc4:	1080020b 	ldhu	r2,8(r2)
    9dc8:	10bfffcc 	andi	r2,r2,65535
    9dcc:	1885c83a 	sub	r2,r3,r2
    9dd0:	e0bffd15 	stw	r2,-12(fp)

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
    9dd4:	e0bfff0b 	ldhu	r2,-4(fp)
    9dd8:	e0bffc0d 	sth	r2,-16(fp)
  q = p;
    9ddc:	e0bffe17 	ldw	r2,-8(fp)
    9de0:	e0bffb15 	stw	r2,-20(fp)
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
    9de4:	00002606 	br	9e80 <pbuf_realloc+0x190>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
    9de8:	e0bffb17 	ldw	r2,-20(fp)
    9dec:	1080028b 	ldhu	r2,10(r2)
    9df0:	e0fffc0b 	ldhu	r3,-16(fp)
    9df4:	1885c83a 	sub	r2,r3,r2
    9df8:	e0bffc0d 	sth	r2,-16(fp)
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
    9dfc:	e0bffd17 	ldw	r2,-12(fp)
    9e00:	00ffff94 	movui	r3,65534
    9e04:	1880090e 	bge	r3,r2,9e2c <pbuf_realloc+0x13c>
    9e08:	010000f4 	movhi	r4,3
    9e0c:	21381b04 	addi	r4,r4,-8084
    9e10:	014000f4 	movhi	r5,3
    9e14:	29788804 	addi	r5,r5,-7648
    9e18:	01805d44 	movi	r6,373
    9e1c:	01c000f4 	movhi	r7,3
    9e20:	39f82c04 	addi	r7,r7,-8016
    9e24:	00166c00 	call	166c0 <printf>
    9e28:	003fff06 	br	9e28 <pbuf_realloc+0x138>
    q->tot_len += (u16_t)grow;
    9e2c:	e0bffb17 	ldw	r2,-20(fp)
    9e30:	10c0020b 	ldhu	r3,8(r2)
    9e34:	e0bffd17 	ldw	r2,-12(fp)
    9e38:	1885883a 	add	r2,r3,r2
    9e3c:	1007883a 	mov	r3,r2
    9e40:	e0bffb17 	ldw	r2,-20(fp)
    9e44:	10c0020d 	sth	r3,8(r2)
    /* proceed to next pbuf in chain */
    q = q->next;
    9e48:	e0bffb17 	ldw	r2,-20(fp)
    9e4c:	10800017 	ldw	r2,0(r2)
    9e50:	e0bffb15 	stw	r2,-20(fp)
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
    9e54:	e0bffb17 	ldw	r2,-20(fp)
    9e58:	1000091e 	bne	r2,zero,9e80 <pbuf_realloc+0x190>
    9e5c:	010000f4 	movhi	r4,3
    9e60:	21381b04 	addi	r4,r4,-8084
    9e64:	014000f4 	movhi	r5,3
    9e68:	29788d04 	addi	r5,r5,-7628
    9e6c:	01805e44 	movi	r6,377
    9e70:	01c000f4 	movhi	r7,3
    9e74:	39f82c04 	addi	r7,r7,-8016
    9e78:	00166c00 	call	166c0 <printf>
    9e7c:	003fff06 	br	9e7c <pbuf_realloc+0x18c>

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
    9e80:	e0bffb17 	ldw	r2,-20(fp)
    9e84:	1080028b 	ldhu	r2,10(r2)
    9e88:	10ffffcc 	andi	r3,r2,65535
    9e8c:	e0bffc0b 	ldhu	r2,-16(fp)
    9e90:	18bfd536 	bltu	r3,r2,9de8 <pbuf_realloc+0xf8>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
    9e94:	e0bffb17 	ldw	r2,-20(fp)
    9e98:	10800303 	ldbu	r2,12(r2)
    9e9c:	10803fcc 	andi	r2,r2,255
    9ea0:	10001d1e 	bne	r2,zero,9f18 <pbuf_realloc+0x228>
    9ea4:	e0bffb17 	ldw	r2,-20(fp)
    9ea8:	1080028b 	ldhu	r2,10(r2)
    9eac:	10ffffcc 	andi	r3,r2,65535
    9eb0:	e0bffc0b 	ldhu	r2,-16(fp)
    9eb4:	18801826 	beq	r3,r2,9f18 <pbuf_realloc+0x228>
    /* reallocate and adjust the length of the pbuf that will be split */
    q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
    9eb8:	e0bffb17 	ldw	r2,-20(fp)
    9ebc:	10800117 	ldw	r2,4(r2)
    9ec0:	1007883a 	mov	r3,r2
    9ec4:	e0bffb17 	ldw	r2,-20(fp)
    9ec8:	1885c83a 	sub	r2,r3,r2
    9ecc:	1007883a 	mov	r3,r2
    9ed0:	e0bffc0b 	ldhu	r2,-16(fp)
    9ed4:	1885883a 	add	r2,r3,r2
    9ed8:	10bfffcc 	andi	r2,r2,65535
    9edc:	e13ffb17 	ldw	r4,-20(fp)
    9ee0:	100b883a 	mov	r5,r2
    9ee4:	00085ac0 	call	85ac <mem_realloc>
    9ee8:	e0bffb15 	stw	r2,-20(fp)
    LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
    9eec:	e0bffb17 	ldw	r2,-20(fp)
    9ef0:	1000091e 	bne	r2,zero,9f18 <pbuf_realloc+0x228>
    9ef4:	010000f4 	movhi	r4,3
    9ef8:	21381b04 	addi	r4,r4,-8084
    9efc:	014000f4 	movhi	r5,3
    9f00:	29789304 	addi	r5,r5,-7604
    9f04:	018060c4 	movi	r6,387
    9f08:	01c000f4 	movhi	r7,3
    9f0c:	39f82c04 	addi	r7,r7,-8016
    9f10:	00166c00 	call	166c0 <printf>
    9f14:	003fff06 	br	9f14 <pbuf_realloc+0x224>
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
    9f18:	e0bffb17 	ldw	r2,-20(fp)
    9f1c:	e0fffc0b 	ldhu	r3,-16(fp)
    9f20:	10c0028d 	sth	r3,10(r2)
  q->tot_len = q->len;
    9f24:	e0bffb17 	ldw	r2,-20(fp)
    9f28:	10c0028b 	ldhu	r3,10(r2)
    9f2c:	e0bffb17 	ldw	r2,-20(fp)
    9f30:	10c0020d 	sth	r3,8(r2)

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
    9f34:	e0bffb17 	ldw	r2,-20(fp)
    9f38:	10800017 	ldw	r2,0(r2)
    9f3c:	10000426 	beq	r2,zero,9f50 <pbuf_realloc+0x260>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
    9f40:	e0bffb17 	ldw	r2,-20(fp)
    9f44:	10800017 	ldw	r2,0(r2)
    9f48:	1009883a 	mov	r4,r2
    9f4c:	000a16c0 	call	a16c <pbuf_free>
  }
  /* q is last packet in chain */
  q->next = NULL;
    9f50:	e0bffb17 	ldw	r2,-20(fp)
    9f54:	10000015 	stw	zero,0(r2)
    9f58:	00000106 	br	9f60 <pbuf_realloc+0x270>
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
    /* enlarging not yet supported */
    return;
    9f5c:	0001883a 	nop
    pbuf_free(q->next);
  }
  /* q is last packet in chain */
  q->next = NULL;

}
    9f60:	e037883a 	mov	sp,fp
    9f64:	dfc00117 	ldw	ra,4(sp)
    9f68:	df000017 	ldw	fp,0(sp)
    9f6c:	dec00204 	addi	sp,sp,8
    9f70:	f800283a 	ret

00009f74 <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
    9f74:	defffa04 	addi	sp,sp,-24
    9f78:	dfc00515 	stw	ra,20(sp)
    9f7c:	df000415 	stw	fp,16(sp)
    9f80:	df000404 	addi	fp,sp,16
    9f84:	e13ffe15 	stw	r4,-8(fp)
    9f88:	2805883a 	mov	r2,r5
    9f8c:	e0bfff0d 	sth	r2,-4(fp)
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
    9f90:	e0bffe17 	ldw	r2,-8(fp)
    9f94:	1000091e 	bne	r2,zero,9fbc <pbuf_header+0x48>
    9f98:	010000f4 	movhi	r4,3
    9f9c:	21381b04 	addi	r4,r4,-8084
    9fa0:	014000f4 	movhi	r5,3
    9fa4:	29789a04 	addi	r5,r5,-7576
    9fa8:	01806b84 	movi	r6,430
    9fac:	01c000f4 	movhi	r7,3
    9fb0:	39f82c04 	addi	r7,r7,-8016
    9fb4:	00166c00 	call	166c0 <printf>
    9fb8:	003fff06 	br	9fb8 <pbuf_header+0x44>
  if ((header_size_increment == 0) || (p == NULL))
    9fbc:	e0bfff0f 	ldh	r2,-4(fp)
    9fc0:	10000226 	beq	r2,zero,9fcc <pbuf_header+0x58>
    9fc4:	e0bffe17 	ldw	r2,-8(fp)
    9fc8:	1000021e 	bne	r2,zero,9fd4 <pbuf_header+0x60>
    return 0;
    9fcc:	0005883a 	mov	r2,zero
    9fd0:	00006106 	br	a158 <pbuf_header+0x1e4>
 
  if (header_size_increment < 0){
    9fd4:	e0bfff0f 	ldh	r2,-4(fp)
    9fd8:	1000110e 	bge	r2,zero,a020 <pbuf_header+0xac>
    increment_magnitude = -header_size_increment;
    9fdc:	e0bfff0b 	ldhu	r2,-4(fp)
    9fe0:	0085c83a 	sub	r2,zero,r2
    9fe4:	e0bffc0d 	sth	r2,-16(fp)
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
    9fe8:	e0bffe17 	ldw	r2,-8(fp)
    9fec:	1080028b 	ldhu	r2,10(r2)
    9ff0:	10ffffcc 	andi	r3,r2,65535
    9ff4:	e0bffc0b 	ldhu	r2,-16(fp)
    9ff8:	18800b2e 	bgeu	r3,r2,a028 <pbuf_header+0xb4>
    9ffc:	010000f4 	movhi	r4,3
    a000:	21381b04 	addi	r4,r4,-8084
    a004:	014000f4 	movhi	r5,3
    a008:	29789d04 	addi	r5,r5,-7564
    a00c:	01806d44 	movi	r6,437
    a010:	01c000f4 	movhi	r7,3
    a014:	39f82c04 	addi	r7,r7,-8016
    a018:	00166c00 	call	166c0 <printf>
    a01c:	003fff06 	br	a01c <pbuf_header+0xa8>
  } else {
    increment_magnitude = header_size_increment;
    a020:	e0bfff0b 	ldhu	r2,-4(fp)
    a024:	e0bffc0d 	sth	r2,-16(fp)
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
    a028:	e0bffe17 	ldw	r2,-8(fp)
    a02c:	10800303 	ldbu	r2,12(r2)
    a030:	10803fcc 	andi	r2,r2,255
    a034:	e0bffc8d 	sth	r2,-14(fp)
  /* remember current payload pointer */
  payload = p->payload;
    a038:	e0bffe17 	ldw	r2,-8(fp)
    a03c:	10800117 	ldw	r2,4(r2)
    a040:	e0bffd15 	stw	r2,-12(fp)

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
    a044:	e0bffc8b 	ldhu	r2,-14(fp)
    a048:	10000326 	beq	r2,zero,a058 <pbuf_header+0xe4>
    a04c:	e0bffc8b 	ldhu	r2,-14(fp)
    a050:	108000d8 	cmpnei	r2,r2,3
    a054:	1000111e 	bne	r2,zero,a09c <pbuf_header+0x128>
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
    a058:	e0bffe17 	ldw	r2,-8(fp)
    a05c:	10c00117 	ldw	r3,4(r2)
    a060:	e0bfff0f 	ldh	r2,-4(fp)
    a064:	0085c83a 	sub	r2,zero,r2
    a068:	1887883a 	add	r3,r3,r2
    a06c:	e0bffe17 	ldw	r2,-8(fp)
    a070:	10c00115 	stw	r3,4(r2)
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
    a074:	e0bffe17 	ldw	r2,-8(fp)
    a078:	10c00117 	ldw	r3,4(r2)
    a07c:	e0bffe17 	ldw	r2,-8(fp)
    a080:	10800404 	addi	r2,r2,16
    a084:	1880252e 	bgeu	r3,r2,a11c <pbuf_header+0x1a8>
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
        ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
        (void *)p->payload, (void *)(p + 1)));
      /* restore old payload pointer */
      p->payload = payload;
    a088:	e0bffe17 	ldw	r2,-8(fp)
    a08c:	e0fffd17 	ldw	r3,-12(fp)
    a090:	10c00115 	stw	r3,4(r2)
      /* bail out unsuccesfully */
      return 1;
    a094:	00800044 	movi	r2,1
    a098:	00002f06 	br	a158 <pbuf_header+0x1e4>
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
    a09c:	e0bffc8b 	ldhu	r2,-14(fp)
    a0a0:	108000a0 	cmpeqi	r2,r2,2
    a0a4:	1000031e 	bne	r2,zero,a0b4 <pbuf_header+0x140>
    a0a8:	e0bffc8b 	ldhu	r2,-14(fp)
    a0ac:	10800058 	cmpnei	r2,r2,1
    a0b0:	1000111e 	bne	r2,zero,a0f8 <pbuf_header+0x184>
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
    a0b4:	e0bfff0f 	ldh	r2,-4(fp)
    a0b8:	10000d0e 	bge	r2,zero,a0f0 <pbuf_header+0x17c>
    a0bc:	e0bffe17 	ldw	r2,-8(fp)
    a0c0:	1080028b 	ldhu	r2,10(r2)
    a0c4:	10ffffcc 	andi	r3,r2,65535
    a0c8:	e0bffc0b 	ldhu	r2,-16(fp)
    a0cc:	18800836 	bltu	r3,r2,a0f0 <pbuf_header+0x17c>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    a0d0:	e0bffe17 	ldw	r2,-8(fp)
    a0d4:	10c00117 	ldw	r3,4(r2)
    a0d8:	e0bfff0f 	ldh	r2,-4(fp)
    a0dc:	0085c83a 	sub	r2,zero,r2
    a0e0:	1887883a 	add	r3,r3,r2
    a0e4:	e0bffe17 	ldw	r2,-8(fp)
    a0e8:	10c00115 	stw	r3,4(r2)
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
    a0ec:	00000b06 	br	a11c <pbuf_header+0x1a8>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
    a0f0:	00800044 	movi	r2,1
    a0f4:	00001806 	br	a158 <pbuf_header+0x1e4>
    }
  }
  else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    a0f8:	010000f4 	movhi	r4,3
    a0fc:	21381b04 	addi	r4,r4,-8084
    a100:	014000f4 	movhi	r5,3
    a104:	2978a504 	addi	r5,r5,-7532
    a108:	01807904 	movi	r6,484
    a10c:	01c000f4 	movhi	r7,3
    a110:	39f82c04 	addi	r7,r7,-8016
    a114:	00166c00 	call	166c0 <printf>
    a118:	003fff06 	br	a118 <pbuf_header+0x1a4>
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
    a11c:	e0bffe17 	ldw	r2,-8(fp)
    a120:	10c0028b 	ldhu	r3,10(r2)
    a124:	e0bfff0b 	ldhu	r2,-4(fp)
    a128:	1885883a 	add	r2,r3,r2
    a12c:	1007883a 	mov	r3,r2
    a130:	e0bffe17 	ldw	r2,-8(fp)
    a134:	10c0028d 	sth	r3,10(r2)
  p->tot_len += header_size_increment;
    a138:	e0bffe17 	ldw	r2,-8(fp)
    a13c:	10c0020b 	ldhu	r3,8(r2)
    a140:	e0bfff0b 	ldhu	r2,-4(fp)
    a144:	1885883a 	add	r2,r3,r2
    a148:	1007883a 	mov	r3,r2
    a14c:	e0bffe17 	ldw	r2,-8(fp)
    a150:	10c0020d 	sth	r3,8(r2)

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
    a154:	0005883a 	mov	r2,zero
}
    a158:	e037883a 	mov	sp,fp
    a15c:	dfc00117 	ldw	ra,4(sp)
    a160:	df000017 	ldw	fp,0(sp)
    a164:	dec00204 	addi	sp,sp,8
    a168:	f800283a 	ret

0000a16c <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
    a16c:	defffa04 	addi	sp,sp,-24
    a170:	dfc00515 	stw	ra,20(sp)
    a174:	df000415 	stw	fp,16(sp)
    a178:	df000404 	addi	fp,sp,16
    a17c:	e13fff15 	stw	r4,-4(fp)
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
    a180:	e0bfff17 	ldw	r2,-4(fp)
    a184:	10000d1e 	bne	r2,zero,a1bc <pbuf_free+0x50>
    LWIP_ASSERT("p != NULL", p != NULL);
    a188:	e0bfff17 	ldw	r2,-4(fp)
    a18c:	1000091e 	bne	r2,zero,a1b4 <pbuf_free+0x48>
    a190:	010000f4 	movhi	r4,3
    a194:	21381b04 	addi	r4,r4,-8084
    a198:	014000f4 	movhi	r5,3
    a19c:	29789a04 	addi	r5,r5,-7576
    a1a0:	01808684 	movi	r6,538
    a1a4:	01c000f4 	movhi	r7,3
    a1a8:	39f82c04 	addi	r7,r7,-8016
    a1ac:	00166c00 	call	166c0 <printf>
    a1b0:	003fff06 	br	a1b0 <pbuf_free+0x44>
    /* if assertions are disabled, proceed with debug output */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
      ("pbuf_free(p == NULL) was called.\n"));
    return 0;
    a1b4:	0005883a 	mov	r2,zero
    a1b8:	00005a06 	br	a324 <pbuf_free+0x1b8>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
    a1bc:	e0bfff17 	ldw	r2,-4(fp)
    a1c0:	10800303 	ldbu	r2,12(r2)
    a1c4:	10803fcc 	andi	r2,r2,255
    a1c8:	10001826 	beq	r2,zero,a22c <pbuf_free+0xc0>
    a1cc:	e0bfff17 	ldw	r2,-4(fp)
    a1d0:	10800303 	ldbu	r2,12(r2)
    a1d4:	10803fcc 	andi	r2,r2,255
    a1d8:	10800060 	cmpeqi	r2,r2,1
    a1dc:	1000131e 	bne	r2,zero,a22c <pbuf_free+0xc0>
    a1e0:	e0bfff17 	ldw	r2,-4(fp)
    a1e4:	10800303 	ldbu	r2,12(r2)
    a1e8:	10803fcc 	andi	r2,r2,255
    a1ec:	108000a0 	cmpeqi	r2,r2,2
    a1f0:	10000e1e 	bne	r2,zero,a22c <pbuf_free+0xc0>
    a1f4:	e0bfff17 	ldw	r2,-4(fp)
    a1f8:	10800303 	ldbu	r2,12(r2)
    a1fc:	10803fcc 	andi	r2,r2,255
    a200:	108000e0 	cmpeqi	r2,r2,3
    a204:	1000091e 	bne	r2,zero,a22c <pbuf_free+0xc0>
    a208:	010000f4 	movhi	r4,3
    a20c:	21381b04 	addi	r4,r4,-8084
    a210:	014000f4 	movhi	r5,3
    a214:	2978a904 	addi	r5,r5,-7516
    a218:	01808984 	movi	r6,550
    a21c:	01c000f4 	movhi	r7,3
    a220:	39f82c04 	addi	r7,r7,-8016
    a224:	00166c00 	call	166c0 <printf>
    a228:	003fff06 	br	a228 <pbuf_free+0xbc>
    p->type == PBUF_RAM || p->type == PBUF_ROM ||
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
    a22c:	e03ffc05 	stb	zero,-16(fp)
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
    a230:	00003906 	br	a318 <pbuf_free+0x1ac>
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
    a234:	e0bfff17 	ldw	r2,-4(fp)
    a238:	1080038b 	ldhu	r2,14(r2)
    a23c:	10bfffcc 	andi	r2,r2,65535
    a240:	1000091e 	bne	r2,zero,a268 <pbuf_free+0xfc>
    a244:	010000f4 	movhi	r4,3
    a248:	21381b04 	addi	r4,r4,-8084
    a24c:	014000f4 	movhi	r5,3
    a250:	2978af04 	addi	r5,r5,-7492
    a254:	01808cc4 	movi	r6,563
    a258:	01c000f4 	movhi	r7,3
    a25c:	39f82c04 	addi	r7,r7,-8016
    a260:	00166c00 	call	166c0 <printf>
    a264:	003fff06 	br	a264 <pbuf_free+0xf8>
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
    a268:	e0bfff17 	ldw	r2,-4(fp)
    a26c:	1080038b 	ldhu	r2,14(r2)
    a270:	10bfffc4 	addi	r2,r2,-1
    a274:	1007883a 	mov	r3,r2
    a278:	e0bfff17 	ldw	r2,-4(fp)
    a27c:	10c0038d 	sth	r3,14(r2)
    a280:	e0bfff17 	ldw	r2,-4(fp)
    a284:	1080038b 	ldhu	r2,14(r2)
    a288:	e0bffc8d 	sth	r2,-14(fp)
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
    a28c:	e0bffc8b 	ldhu	r2,-14(fp)
    a290:	1000201e 	bne	r2,zero,a314 <pbuf_free+0x1a8>
      /* remember next pbuf in chain for next iteration */
      q = p->next;
    a294:	e0bfff17 	ldw	r2,-4(fp)
    a298:	10800017 	ldw	r2,0(r2)
    a29c:	e0bffd15 	stw	r2,-12(fp)
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
    a2a0:	e0bfff17 	ldw	r2,-4(fp)
    a2a4:	10800303 	ldbu	r2,12(r2)
    a2a8:	10803fcc 	andi	r2,r2,255
    a2ac:	e0bffe0d 	sth	r2,-8(fp)
      /* is this a pbuf from the pool? */
      if (type == PBUF_POOL) {
    a2b0:	e0bffe0b 	ldhu	r2,-8(fp)
    a2b4:	108000d8 	cmpnei	r2,r2,3
    a2b8:	1000041e 	bne	r2,zero,a2cc <pbuf_free+0x160>
        memp_free(MEMP_PBUF_POOL, p);
    a2bc:	01000204 	movi	r4,8
    a2c0:	e17fff17 	ldw	r5,-4(fp)
    a2c4:	00090cc0 	call	90cc <memp_free>
    a2c8:	00000c06 	br	a2fc <pbuf_free+0x190>
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
    a2cc:	e0bffe0b 	ldhu	r2,-8(fp)
    a2d0:	10800060 	cmpeqi	r2,r2,1
    a2d4:	1000031e 	bne	r2,zero,a2e4 <pbuf_free+0x178>
    a2d8:	e0bffe0b 	ldhu	r2,-8(fp)
    a2dc:	10800098 	cmpnei	r2,r2,2
    a2e0:	1000041e 	bne	r2,zero,a2f4 <pbuf_free+0x188>
        memp_free(MEMP_PBUF, p);
    a2e4:	010001c4 	movi	r4,7
    a2e8:	e17fff17 	ldw	r5,-4(fp)
    a2ec:	00090cc0 	call	90cc <memp_free>
    a2f0:	00000206 	br	a2fc <pbuf_free+0x190>
      /* type == PBUF_RAM */
      } else {
        mem_free(p);
    a2f4:	e13fff17 	ldw	r4,-4(fp)
    a2f8:	000842c0 	call	842c <mem_free>
      }
      count++;
    a2fc:	e0bffc03 	ldbu	r2,-16(fp)
    a300:	10800044 	addi	r2,r2,1
    a304:	e0bffc05 	stb	r2,-16(fp)
      /* proceed to next pbuf */
      p = q;
    a308:	e0bffd17 	ldw	r2,-12(fp)
    a30c:	e0bfff15 	stw	r2,-4(fp)
    a310:	00000106 	br	a318 <pbuf_free+0x1ac>
    /* p->ref > 0, this pbuf is still referenced to */
    /* (and so the remaining pbufs in chain as well) */
    } else {
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: %p has ref %"U16_F", ending here.\n", (void *)p, ref));
      /* stop walking through the chain */
      p = NULL;
    a314:	e03fff15 	stw	zero,-4(fp)
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
    a318:	e0bfff17 	ldw	r2,-4(fp)
    a31c:	103fc51e 	bne	r2,zero,a234 <pbuf_free+0xc8>
      p = NULL;
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
    a320:	e0bffc03 	ldbu	r2,-16(fp)
}
    a324:	e037883a 	mov	sp,fp
    a328:	dfc00117 	ldw	ra,4(sp)
    a32c:	df000017 	ldw	fp,0(sp)
    a330:	dec00204 	addi	sp,sp,8
    a334:	f800283a 	ret

0000a338 <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
    a338:	defffd04 	addi	sp,sp,-12
    a33c:	df000215 	stw	fp,8(sp)
    a340:	df000204 	addi	fp,sp,8
    a344:	e13fff15 	stw	r4,-4(fp)
  u8_t len;

  len = 0;
    a348:	e03ffe05 	stb	zero,-8(fp)
  while (p != NULL) {
    a34c:	00000606 	br	a368 <pbuf_clen+0x30>
    ++len;
    a350:	e0bffe03 	ldbu	r2,-8(fp)
    a354:	10800044 	addi	r2,r2,1
    a358:	e0bffe05 	stb	r2,-8(fp)
    p = p->next;
    a35c:	e0bfff17 	ldw	r2,-4(fp)
    a360:	10800017 	ldw	r2,0(r2)
    a364:	e0bfff15 	stw	r2,-4(fp)
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
    a368:	e0bfff17 	ldw	r2,-4(fp)
    a36c:	103ff81e 	bne	r2,zero,a350 <pbuf_clen+0x18>
    ++len;
    p = p->next;
  }
  return len;
    a370:	e0bffe03 	ldbu	r2,-8(fp)
}
    a374:	e037883a 	mov	sp,fp
    a378:	df000017 	ldw	fp,0(sp)
    a37c:	dec00104 	addi	sp,sp,4
    a380:	f800283a 	ret

0000a384 <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
    a384:	defffe04 	addi	sp,sp,-8
    a388:	df000115 	stw	fp,4(sp)
    a38c:	df000104 	addi	fp,sp,4
    a390:	e13fff15 	stw	r4,-4(fp)
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
    a394:	e0bfff17 	ldw	r2,-4(fp)
    a398:	10000626 	beq	r2,zero,a3b4 <pbuf_ref+0x30>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
    a39c:	e0bfff17 	ldw	r2,-4(fp)
    a3a0:	1080038b 	ldhu	r2,14(r2)
    a3a4:	10800044 	addi	r2,r2,1
    a3a8:	1007883a 	mov	r3,r2
    a3ac:	e0bfff17 	ldw	r2,-4(fp)
    a3b0:	10c0038d 	sth	r3,14(r2)
    SYS_ARCH_UNPROTECT(old_level);
  }
}
    a3b4:	e037883a 	mov	sp,fp
    a3b8:	df000017 	ldw	fp,0(sp)
    a3bc:	dec00104 	addi	sp,sp,4
    a3c0:	f800283a 	ret

0000a3c4 <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
    a3c4:	defffb04 	addi	sp,sp,-20
    a3c8:	dfc00415 	stw	ra,16(sp)
    a3cc:	df000315 	stw	fp,12(sp)
    a3d0:	df000304 	addi	fp,sp,12
    a3d4:	e13ffe15 	stw	r4,-8(fp)
    a3d8:	e17fff15 	stw	r5,-4(fp)
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
    a3dc:	e0bffe17 	ldw	r2,-8(fp)
    a3e0:	10000226 	beq	r2,zero,a3ec <pbuf_cat+0x28>
    a3e4:	e0bfff17 	ldw	r2,-4(fp)
    a3e8:	1000091e 	bne	r2,zero,a410 <pbuf_cat+0x4c>
    a3ec:	010000f4 	movhi	r4,3
    a3f0:	21381b04 	addi	r4,r4,-8084
    a3f4:	014000f4 	movhi	r5,3
    a3f8:	2978b504 	addi	r5,r5,-7468
    a3fc:	0180a344 	movi	r6,653
    a400:	01c000f4 	movhi	r7,3
    a404:	39f82c04 	addi	r7,r7,-8016
    a408:	00166c00 	call	166c0 <printf>
    a40c:	003fff06 	br	a40c <pbuf_cat+0x48>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
    a410:	e0bffe17 	ldw	r2,-8(fp)
    a414:	e0bffd15 	stw	r2,-12(fp)
    a418:	00000b06 	br	a448 <pbuf_cat+0x84>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
    a41c:	e0bffd17 	ldw	r2,-12(fp)
    a420:	10c0020b 	ldhu	r3,8(r2)
    a424:	e0bfff17 	ldw	r2,-4(fp)
    a428:	1080020b 	ldhu	r2,8(r2)
    a42c:	1885883a 	add	r2,r3,r2
    a430:	1007883a 	mov	r3,r2
    a434:	e0bffd17 	ldw	r2,-12(fp)
    a438:	10c0020d 	sth	r3,8(r2)

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
    a43c:	e0bffd17 	ldw	r2,-12(fp)
    a440:	10800017 	ldw	r2,0(r2)
    a444:	e0bffd15 	stw	r2,-12(fp)
    a448:	e0bffd17 	ldw	r2,-12(fp)
    a44c:	10800017 	ldw	r2,0(r2)
    a450:	103ff21e 	bne	r2,zero,a41c <pbuf_cat+0x58>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
    a454:	e0bffd17 	ldw	r2,-12(fp)
    a458:	10c0020b 	ldhu	r3,8(r2)
    a45c:	e0bffd17 	ldw	r2,-12(fp)
    a460:	1080028b 	ldhu	r2,10(r2)
    a464:	18ffffcc 	andi	r3,r3,65535
    a468:	10bfffcc 	andi	r2,r2,65535
    a46c:	18800926 	beq	r3,r2,a494 <pbuf_cat+0xd0>
    a470:	010000f4 	movhi	r4,3
    a474:	21381b04 	addi	r4,r4,-8084
    a478:	014000f4 	movhi	r5,3
    a47c:	2978c304 	addi	r5,r5,-7412
    a480:	0180a544 	movi	r6,661
    a484:	01c000f4 	movhi	r7,3
    a488:	39f82c04 	addi	r7,r7,-8016
    a48c:	00166c00 	call	166c0 <printf>
    a490:	003fff06 	br	a490 <pbuf_cat+0xcc>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
    a494:	e0bffd17 	ldw	r2,-12(fp)
    a498:	10800017 	ldw	r2,0(r2)
    a49c:	10000926 	beq	r2,zero,a4c4 <pbuf_cat+0x100>
    a4a0:	010000f4 	movhi	r4,3
    a4a4:	21381b04 	addi	r4,r4,-8084
    a4a8:	014000f4 	movhi	r5,3
    a4ac:	2978cf04 	addi	r5,r5,-7364
    a4b0:	0180a584 	movi	r6,662
    a4b4:	01c000f4 	movhi	r7,3
    a4b8:	39f82c04 	addi	r7,r7,-8016
    a4bc:	00166c00 	call	166c0 <printf>
    a4c0:	003fff06 	br	a4c0 <pbuf_cat+0xfc>
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
    a4c4:	e0bffd17 	ldw	r2,-12(fp)
    a4c8:	10c0020b 	ldhu	r3,8(r2)
    a4cc:	e0bfff17 	ldw	r2,-4(fp)
    a4d0:	1080020b 	ldhu	r2,8(r2)
    a4d4:	1885883a 	add	r2,r3,r2
    a4d8:	1007883a 	mov	r3,r2
    a4dc:	e0bffd17 	ldw	r2,-12(fp)
    a4e0:	10c0020d 	sth	r3,8(r2)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
    a4e4:	e0bffd17 	ldw	r2,-12(fp)
    a4e8:	e0ffff17 	ldw	r3,-4(fp)
    a4ec:	10c00015 	stw	r3,0(r2)
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
    a4f0:	e037883a 	mov	sp,fp
    a4f4:	dfc00117 	ldw	ra,4(sp)
    a4f8:	df000017 	ldw	fp,0(sp)
    a4fc:	dec00204 	addi	sp,sp,8
    a500:	f800283a 	ret

0000a504 <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
    a504:	defffc04 	addi	sp,sp,-16
    a508:	dfc00315 	stw	ra,12(sp)
    a50c:	df000215 	stw	fp,8(sp)
    a510:	df000204 	addi	fp,sp,8
    a514:	e13ffe15 	stw	r4,-8(fp)
    a518:	e17fff15 	stw	r5,-4(fp)
  pbuf_cat(h, t);
    a51c:	e13ffe17 	ldw	r4,-8(fp)
    a520:	e17fff17 	ldw	r5,-4(fp)
    a524:	000a3c40 	call	a3c4 <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
    a528:	e13fff17 	ldw	r4,-4(fp)
    a52c:	000a3840 	call	a384 <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
    a530:	e037883a 	mov	sp,fp
    a534:	dfc00117 	ldw	ra,4(sp)
    a538:	df000017 	ldw	fp,0(sp)
    a53c:	dec00204 	addi	sp,sp,8
    a540:	f800283a 	ret

0000a544 <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
    a544:	defffb04 	addi	sp,sp,-20
    a548:	dfc00415 	stw	ra,16(sp)
    a54c:	df000315 	stw	fp,12(sp)
    a550:	df000304 	addi	fp,sp,12
    a554:	e13fff15 	stw	r4,-4(fp)
  struct pbuf *q;
  u8_t tail_gone = 1;
    a558:	00800044 	movi	r2,1
    a55c:	e0bffd05 	stb	r2,-12(fp)
  /* tail */
  q = p->next;
    a560:	e0bfff17 	ldw	r2,-4(fp)
    a564:	10800017 	ldw	r2,0(r2)
    a568:	e0bffe15 	stw	r2,-8(fp)
  /* pbuf has successor in chain? */
  if (q != NULL) {
    a56c:	e0bffe17 	ldw	r2,-8(fp)
    a570:	10002526 	beq	r2,zero,a608 <pbuf_dechain+0xc4>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
    a574:	e0bffe17 	ldw	r2,-8(fp)
    a578:	1080020b 	ldhu	r2,8(r2)
    a57c:	10ffffcc 	andi	r3,r2,65535
    a580:	e0bfff17 	ldw	r2,-4(fp)
    a584:	1080020b 	ldhu	r2,8(r2)
    a588:	113fffcc 	andi	r4,r2,65535
    a58c:	e0bfff17 	ldw	r2,-4(fp)
    a590:	1080028b 	ldhu	r2,10(r2)
    a594:	10bfffcc 	andi	r2,r2,65535
    a598:	2085c83a 	sub	r2,r4,r2
    a59c:	18800926 	beq	r3,r2,a5c4 <pbuf_dechain+0x80>
    a5a0:	010000f4 	movhi	r4,3
    a5a4:	21381b04 	addi	r4,r4,-8084
    a5a8:	014000f4 	movhi	r5,3
    a5ac:	2978d304 	addi	r5,r5,-7348
    a5b0:	0180b2c4 	movi	r6,715
    a5b4:	01c000f4 	movhi	r7,3
    a5b8:	39f82c04 	addi	r7,r7,-8016
    a5bc:	00166c00 	call	166c0 <printf>
    a5c0:	003fff06 	br	a5c0 <pbuf_dechain+0x7c>
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
    a5c4:	e0bfff17 	ldw	r2,-4(fp)
    a5c8:	10c0020b 	ldhu	r3,8(r2)
    a5cc:	e0bfff17 	ldw	r2,-4(fp)
    a5d0:	1080028b 	ldhu	r2,10(r2)
    a5d4:	1885c83a 	sub	r2,r3,r2
    a5d8:	1007883a 	mov	r3,r2
    a5dc:	e0bffe17 	ldw	r2,-8(fp)
    a5e0:	10c0020d 	sth	r3,8(r2)
    /* decouple pbuf from remainder */
    p->next = NULL;
    a5e4:	e0bfff17 	ldw	r2,-4(fp)
    a5e8:	10000015 	stw	zero,0(r2)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
    a5ec:	e0bfff17 	ldw	r2,-4(fp)
    a5f0:	10c0028b 	ldhu	r3,10(r2)
    a5f4:	e0bfff17 	ldw	r2,-4(fp)
    a5f8:	10c0020d 	sth	r3,8(r2)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
    a5fc:	e13ffe17 	ldw	r4,-8(fp)
    a600:	000a16c0 	call	a16c <pbuf_free>
    a604:	e0bffd05 	stb	r2,-12(fp)
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
    a608:	e0bfff17 	ldw	r2,-4(fp)
    a60c:	10c0020b 	ldhu	r3,8(r2)
    a610:	e0bfff17 	ldw	r2,-4(fp)
    a614:	1080028b 	ldhu	r2,10(r2)
    a618:	18ffffcc 	andi	r3,r3,65535
    a61c:	10bfffcc 	andi	r2,r2,65535
    a620:	18800926 	beq	r3,r2,a648 <pbuf_dechain+0x104>
    a624:	010000f4 	movhi	r4,3
    a628:	21381b04 	addi	r4,r4,-8084
    a62c:	014000f4 	movhi	r5,3
    a630:	2978dc04 	addi	r5,r5,-7312
    a634:	0180b704 	movi	r6,732
    a638:	01c000f4 	movhi	r7,3
    a63c:	39f82c04 	addi	r7,r7,-8016
    a640:	00166c00 	call	166c0 <printf>
    a644:	003fff06 	br	a644 <pbuf_dechain+0x100>
  return ((tail_gone > 0) ? NULL : q);
    a648:	e0bffd03 	ldbu	r2,-12(fp)
    a64c:	1000021e 	bne	r2,zero,a658 <pbuf_dechain+0x114>
    a650:	e0bffe17 	ldw	r2,-8(fp)
    a654:	00000106 	br	a65c <pbuf_dechain+0x118>
    a658:	0005883a 	mov	r2,zero
}
    a65c:	e037883a 	mov	sp,fp
    a660:	dfc00117 	ldw	ra,4(sp)
    a664:	df000017 	ldw	fp,0(sp)
    a668:	dec00204 	addi	sp,sp,8
    a66c:	f800283a 	ret

0000a670 <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
    a670:	defffa04 	addi	sp,sp,-24
    a674:	dfc00515 	stw	ra,20(sp)
    a678:	df000415 	stw	fp,16(sp)
    a67c:	df000404 	addi	fp,sp,16
    a680:	e13ffe15 	stw	r4,-8(fp)
    a684:	e17fff15 	stw	r5,-4(fp)
  u16_t offset_to=0, offset_from=0, len;
    a688:	e03ffc0d 	sth	zero,-16(fp)
    a68c:	e03ffc8d 	sth	zero,-14(fp)

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
    a690:	e0bffe17 	ldw	r2,-8(fp)
    a694:	10000926 	beq	r2,zero,a6bc <pbuf_copy+0x4c>
    a698:	e0bfff17 	ldw	r2,-4(fp)
    a69c:	10000726 	beq	r2,zero,a6bc <pbuf_copy+0x4c>
    a6a0:	e0bffe17 	ldw	r2,-8(fp)
    a6a4:	10c0020b 	ldhu	r3,8(r2)
    a6a8:	e0bfff17 	ldw	r2,-4(fp)
    a6ac:	1080020b 	ldhu	r2,8(r2)
    a6b0:	18ffffcc 	andi	r3,r3,65535
    a6b4:	10bfffcc 	andi	r2,r2,65535
    a6b8:	1880092e 	bgeu	r3,r2,a6e0 <pbuf_copy+0x70>
    a6bc:	010000f4 	movhi	r4,3
    a6c0:	21381b04 	addi	r4,r4,-8084
    a6c4:	014000f4 	movhi	r5,3
    a6c8:	2978e204 	addi	r5,r5,-7288
    a6cc:	0180bf04 	movi	r6,764
    a6d0:	01c000f4 	movhi	r7,3
    a6d4:	39f82c04 	addi	r7,r7,-8016
    a6d8:	00166c00 	call	166c0 <printf>
    a6dc:	003fff06 	br	a6dc <pbuf_copy+0x6c>
             (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);

  /* iterate through pbuf chain */
  do
  {
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
    a6e0:	e0bffe17 	ldw	r2,-8(fp)
    a6e4:	1000091e 	bne	r2,zero,a70c <pbuf_copy+0x9c>
    a6e8:	010000f4 	movhi	r4,3
    a6ec:	21381b04 	addi	r4,r4,-8084
    a6f0:	014000f4 	movhi	r5,3
    a6f4:	2978ee04 	addi	r5,r5,-7240
    a6f8:	0180c044 	movi	r6,769
    a6fc:	01c000f4 	movhi	r7,3
    a700:	39f82c04 	addi	r7,r7,-8016
    a704:	00166c00 	call	166c0 <printf>
    a708:	003fff06 	br	a708 <pbuf_copy+0x98>
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
    a70c:	e0bffe17 	ldw	r2,-8(fp)
    a710:	1080028b 	ldhu	r2,10(r2)
    a714:	10ffffcc 	andi	r3,r2,65535
    a718:	e0bffc0b 	ldhu	r2,-16(fp)
    a71c:	1887c83a 	sub	r3,r3,r2
    a720:	e0bfff17 	ldw	r2,-4(fp)
    a724:	1080028b 	ldhu	r2,10(r2)
    a728:	113fffcc 	andi	r4,r2,65535
    a72c:	e0bffc8b 	ldhu	r2,-14(fp)
    a730:	2085c83a 	sub	r2,r4,r2
    a734:	18800616 	blt	r3,r2,a750 <pbuf_copy+0xe0>
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
    a738:	e0bfff17 	ldw	r2,-4(fp)
    a73c:	10c0028b 	ldhu	r3,10(r2)
    a740:	e0bffc8b 	ldhu	r2,-14(fp)
    a744:	1885c83a 	sub	r2,r3,r2
    a748:	e0bffd0d 	sth	r2,-12(fp)
    a74c:	00000506 	br	a764 <pbuf_copy+0xf4>
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    a750:	e0bffe17 	ldw	r2,-8(fp)
    a754:	10c0028b 	ldhu	r3,10(r2)
    a758:	e0bffc0b 	ldhu	r2,-16(fp)
    a75c:	1885c83a 	sub	r2,r3,r2
    a760:	e0bffd0d 	sth	r2,-12(fp)
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
    a764:	e0bffe17 	ldw	r2,-8(fp)
    a768:	10c00117 	ldw	r3,4(r2)
    a76c:	e0bffc0b 	ldhu	r2,-16(fp)
    a770:	1889883a 	add	r4,r3,r2
    a774:	e0bfff17 	ldw	r2,-4(fp)
    a778:	10c00117 	ldw	r3,4(r2)
    a77c:	e0bffc8b 	ldhu	r2,-14(fp)
    a780:	1887883a 	add	r3,r3,r2
    a784:	e0bffd0b 	ldhu	r2,-12(fp)
    a788:	180b883a 	mov	r5,r3
    a78c:	100d883a 	mov	r6,r2
    a790:	00164c00 	call	164c0 <memcpy>
    offset_to += len;
    a794:	e0fffc0b 	ldhu	r3,-16(fp)
    a798:	e0bffd0b 	ldhu	r2,-12(fp)
    a79c:	1885883a 	add	r2,r3,r2
    a7a0:	e0bffc0d 	sth	r2,-16(fp)
    offset_from += len;
    a7a4:	e0fffc8b 	ldhu	r3,-14(fp)
    a7a8:	e0bffd0b 	ldhu	r2,-12(fp)
    a7ac:	1885883a 	add	r2,r3,r2
    a7b0:	e0bffc8d 	sth	r2,-14(fp)
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    a7b4:	e0bffe17 	ldw	r2,-8(fp)
    a7b8:	1080028b 	ldhu	r2,10(r2)
    a7bc:	10ffffcc 	andi	r3,r2,65535
    a7c0:	e0bffc0b 	ldhu	r2,-16(fp)
    a7c4:	1880092e 	bgeu	r3,r2,a7ec <pbuf_copy+0x17c>
    a7c8:	010000f4 	movhi	r4,3
    a7cc:	21381b04 	addi	r4,r4,-8084
    a7d0:	014000f4 	movhi	r5,3
    a7d4:	2978f204 	addi	r5,r5,-7224
    a7d8:	0180c344 	movi	r6,781
    a7dc:	01c000f4 	movhi	r7,3
    a7e0:	39f82c04 	addi	r7,r7,-8016
    a7e4:	00166c00 	call	166c0 <printf>
    a7e8:	003fff06 	br	a7e8 <pbuf_copy+0x178>
    if (offset_to == p_to->len) {
    a7ec:	e0bffe17 	ldw	r2,-8(fp)
    a7f0:	1080028b 	ldhu	r2,10(r2)
    a7f4:	10ffffcc 	andi	r3,r2,65535
    a7f8:	e0bffc0b 	ldhu	r2,-16(fp)
    a7fc:	1880041e 	bne	r3,r2,a810 <pbuf_copy+0x1a0>
      /* on to next p_to (if any) */
      offset_to = 0;
    a800:	e03ffc0d 	sth	zero,-16(fp)
      p_to = p_to->next;
    a804:	e0bffe17 	ldw	r2,-8(fp)
    a808:	10800017 	ldw	r2,0(r2)
    a80c:	e0bffe15 	stw	r2,-8(fp)
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
    a810:	e0bfff17 	ldw	r2,-4(fp)
    a814:	1080028b 	ldhu	r2,10(r2)
    a818:	10ffffcc 	andi	r3,r2,65535
    a81c:	e0bffc8b 	ldhu	r2,-14(fp)
    a820:	1880092e 	bgeu	r3,r2,a848 <pbuf_copy+0x1d8>
    a824:	010000f4 	movhi	r4,3
    a828:	21381b04 	addi	r4,r4,-8084
    a82c:	014000f4 	movhi	r5,3
    a830:	2978f804 	addi	r5,r5,-7200
    a834:	0180c4c4 	movi	r6,787
    a838:	01c000f4 	movhi	r7,3
    a83c:	39f82c04 	addi	r7,r7,-8016
    a840:	00166c00 	call	166c0 <printf>
    a844:	003fff06 	br	a844 <pbuf_copy+0x1d4>
    if (offset_from >= p_from->len) {
    a848:	e0bfff17 	ldw	r2,-4(fp)
    a84c:	1080028b 	ldhu	r2,10(r2)
    a850:	10bfffcc 	andi	r2,r2,65535
    a854:	e0fffc8b 	ldhu	r3,-14(fp)
    a858:	18800436 	bltu	r3,r2,a86c <pbuf_copy+0x1fc>
      /* on to next p_from (if any) */
      offset_from = 0;
    a85c:	e03ffc8d 	sth	zero,-14(fp)
      p_from = p_from->next;
    a860:	e0bfff17 	ldw	r2,-4(fp)
    a864:	10800017 	ldw	r2,0(r2)
    a868:	e0bfff15 	stw	r2,-4(fp)
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
    a86c:	e0bfff17 	ldw	r2,-4(fp)
    a870:	10001326 	beq	r2,zero,a8c0 <pbuf_copy+0x250>
    a874:	e0bfff17 	ldw	r2,-4(fp)
    a878:	10c0028b 	ldhu	r3,10(r2)
    a87c:	e0bfff17 	ldw	r2,-4(fp)
    a880:	1080020b 	ldhu	r2,8(r2)
    a884:	18ffffcc 	andi	r3,r3,65535
    a888:	10bfffcc 	andi	r2,r2,65535
    a88c:	18800c1e 	bne	r3,r2,a8c0 <pbuf_copy+0x250>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
    a890:	e0bfff17 	ldw	r2,-4(fp)
    a894:	10800017 	ldw	r2,0(r2)
    a898:	10000926 	beq	r2,zero,a8c0 <pbuf_copy+0x250>
    a89c:	010000f4 	movhi	r4,3
    a8a0:	21381b04 	addi	r4,r4,-8084
    a8a4:	014000f4 	movhi	r5,3
    a8a8:	2978ff04 	addi	r5,r5,-7172
    a8ac:	0180c744 	movi	r6,797
    a8b0:	01c000f4 	movhi	r7,3
    a8b4:	39f82c04 	addi	r7,r7,-8016
    a8b8:	00166c00 	call	166c0 <printf>
    a8bc:	003fff06 	br	a8bc <pbuf_copy+0x24c>
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
    a8c0:	e0bffe17 	ldw	r2,-8(fp)
    a8c4:	10001326 	beq	r2,zero,a914 <pbuf_copy+0x2a4>
    a8c8:	e0bffe17 	ldw	r2,-8(fp)
    a8cc:	10c0028b 	ldhu	r3,10(r2)
    a8d0:	e0bffe17 	ldw	r2,-8(fp)
    a8d4:	1080020b 	ldhu	r2,8(r2)
    a8d8:	18ffffcc 	andi	r3,r3,65535
    a8dc:	10bfffcc 	andi	r2,r2,65535
    a8e0:	18800c1e 	bne	r3,r2,a914 <pbuf_copy+0x2a4>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
    a8e4:	e0bffe17 	ldw	r2,-8(fp)
    a8e8:	10800017 	ldw	r2,0(r2)
    a8ec:	10000926 	beq	r2,zero,a914 <pbuf_copy+0x2a4>
    a8f0:	010000f4 	movhi	r4,3
    a8f4:	21381b04 	addi	r4,r4,-8084
    a8f8:	014000f4 	movhi	r5,3
    a8fc:	2978ff04 	addi	r5,r5,-7172
    a900:	0180c884 	movi	r6,802
    a904:	01c000f4 	movhi	r7,3
    a908:	39f82c04 	addi	r7,r7,-8016
    a90c:	00166c00 	call	166c0 <printf>
    a910:	003fff06 	br	a910 <pbuf_copy+0x2a0>
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
    a914:	e0bfff17 	ldw	r2,-4(fp)
    a918:	103f711e 	bne	r2,zero,a6e0 <pbuf_copy+0x70>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
    a91c:	0005883a 	mov	r2,zero
}
    a920:	e037883a 	mov	sp,fp
    a924:	dfc00117 	ldw	ra,4(sp)
    a928:	df000017 	ldw	fp,0(sp)
    a92c:	dec00204 	addi	sp,sp,8
    a930:	f800283a 	ret

0000a934 <pbuf_copy_partial>:
 * @param offset offset into the packet buffer from where to begin copying len bytes
 * @return the number of bytes copied, or 0 on failure
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
    a934:	defff704 	addi	sp,sp,-36
    a938:	dfc00815 	stw	ra,32(sp)
    a93c:	df000715 	stw	fp,28(sp)
    a940:	df000704 	addi	fp,sp,28
    a944:	e13ffc15 	stw	r4,-16(fp)
    a948:	e17ffd15 	stw	r5,-12(fp)
    a94c:	3007883a 	mov	r3,r6
    a950:	3805883a 	mov	r2,r7
    a954:	e0fffe0d 	sth	r3,-8(fp)
    a958:	e0bfff0d 	sth	r2,-4(fp)
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;
    a95c:	e03ffb0d 	sth	zero,-20(fp)

  LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
    a960:	e0bffc17 	ldw	r2,-16(fp)
    a964:	1000091e 	bne	r2,zero,a98c <pbuf_copy_partial+0x58>
    a968:	010000f4 	movhi	r4,3
    a96c:	21381b04 	addi	r4,r4,-8084
    a970:	014000f4 	movhi	r5,3
    a974:	29790a04 	addi	r5,r5,-7128
    a978:	0180cf04 	movi	r6,828
    a97c:	01c000f4 	movhi	r7,3
    a980:	39f82c04 	addi	r7,r7,-8016
    a984:	00166c00 	call	166c0 <printf>
    a988:	003fff06 	br	a988 <pbuf_copy_partial+0x54>
  LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
    a98c:	e0bffd17 	ldw	r2,-12(fp)
    a990:	1000091e 	bne	r2,zero,a9b8 <pbuf_copy_partial+0x84>
    a994:	010000f4 	movhi	r4,3
    a998:	21381b04 	addi	r4,r4,-8084
    a99c:	014000f4 	movhi	r5,3
    a9a0:	29791204 	addi	r5,r5,-7096
    a9a4:	0180cf44 	movi	r6,829
    a9a8:	01c000f4 	movhi	r7,3
    a9ac:	39f82c04 	addi	r7,r7,-8016
    a9b0:	00166c00 	call	166c0 <printf>
    a9b4:	003fff06 	br	a9b4 <pbuf_copy_partial+0x80>

  left = 0;
    a9b8:	e03ffa0d 	sth	zero,-24(fp)

  if((buf == NULL) || (dataptr == NULL)) {
    a9bc:	e0bffc17 	ldw	r2,-16(fp)
    a9c0:	10000226 	beq	r2,zero,a9cc <pbuf_copy_partial+0x98>
    a9c4:	e0bffd17 	ldw	r2,-12(fp)
    a9c8:	1000021e 	bne	r2,zero,a9d4 <pbuf_copy_partial+0xa0>
    return 0;
    a9cc:	0005883a 	mov	r2,zero
    a9d0:	00003a06 	br	aabc <pbuf_copy_partial+0x188>
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
    a9d4:	e0bffc17 	ldw	r2,-16(fp)
    a9d8:	e0bff915 	stw	r2,-28(fp)
    a9dc:	00003206 	br	aaa8 <pbuf_copy_partial+0x174>
    if ((offset != 0) && (offset >= p->len)) {
    a9e0:	e0bfff0b 	ldhu	r2,-4(fp)
    a9e4:	10000b26 	beq	r2,zero,aa14 <pbuf_copy_partial+0xe0>
    a9e8:	e0bff917 	ldw	r2,-28(fp)
    a9ec:	1080028b 	ldhu	r2,10(r2)
    a9f0:	10bfffcc 	andi	r2,r2,65535
    a9f4:	e0ffff0b 	ldhu	r3,-4(fp)
    a9f8:	18800636 	bltu	r3,r2,aa14 <pbuf_copy_partial+0xe0>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
    a9fc:	e0bff917 	ldw	r2,-28(fp)
    aa00:	1080028b 	ldhu	r2,10(r2)
    aa04:	e0ffff0b 	ldhu	r3,-4(fp)
    aa08:	1885c83a 	sub	r2,r3,r2
    aa0c:	e0bfff0d 	sth	r2,-4(fp)
    aa10:	00002206 	br	aa9c <pbuf_copy_partial+0x168>
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
    aa14:	e0bff917 	ldw	r2,-28(fp)
    aa18:	10c0028b 	ldhu	r3,10(r2)
    aa1c:	e0bfff0b 	ldhu	r2,-4(fp)
    aa20:	1885c83a 	sub	r2,r3,r2
    aa24:	e0bffa8d 	sth	r2,-22(fp)
      if (buf_copy_len > len)
    aa28:	e0bffa8b 	ldhu	r2,-22(fp)
    aa2c:	e0fffe0b 	ldhu	r3,-8(fp)
    aa30:	1880022e 	bgeu	r3,r2,aa3c <pbuf_copy_partial+0x108>
          buf_copy_len = len;
    aa34:	e0bffe0b 	ldhu	r2,-8(fp)
    aa38:	e0bffa8d 	sth	r2,-22(fp)
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
    aa3c:	e0bffa0b 	ldhu	r2,-24(fp)
    aa40:	e0fffd17 	ldw	r3,-12(fp)
    aa44:	1889883a 	add	r4,r3,r2
    aa48:	e0bff917 	ldw	r2,-28(fp)
    aa4c:	10c00117 	ldw	r3,4(r2)
    aa50:	e0bfff0b 	ldhu	r2,-4(fp)
    aa54:	1887883a 	add	r3,r3,r2
    aa58:	e0bffa8b 	ldhu	r2,-22(fp)
    aa5c:	180b883a 	mov	r5,r3
    aa60:	100d883a 	mov	r6,r2
    aa64:	00164c00 	call	164c0 <memcpy>
      copied_total += buf_copy_len;
    aa68:	e0fffb0b 	ldhu	r3,-20(fp)
    aa6c:	e0bffa8b 	ldhu	r2,-22(fp)
    aa70:	1885883a 	add	r2,r3,r2
    aa74:	e0bffb0d 	sth	r2,-20(fp)
      left += buf_copy_len;
    aa78:	e0fffa0b 	ldhu	r3,-24(fp)
    aa7c:	e0bffa8b 	ldhu	r2,-22(fp)
    aa80:	1885883a 	add	r2,r3,r2
    aa84:	e0bffa0d 	sth	r2,-24(fp)
      len -= buf_copy_len;
    aa88:	e0fffe0b 	ldhu	r3,-8(fp)
    aa8c:	e0bffa8b 	ldhu	r2,-22(fp)
    aa90:	1885c83a 	sub	r2,r3,r2
    aa94:	e0bffe0d 	sth	r2,-8(fp)
      offset = 0;
    aa98:	e03fff0d 	sth	zero,-4(fp)
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
    aa9c:	e0bff917 	ldw	r2,-28(fp)
    aaa0:	10800017 	ldw	r2,0(r2)
    aaa4:	e0bff915 	stw	r2,-28(fp)
    aaa8:	e0bffe0b 	ldhu	r2,-8(fp)
    aaac:	10000226 	beq	r2,zero,aab8 <pbuf_copy_partial+0x184>
    aab0:	e0bff917 	ldw	r2,-28(fp)
    aab4:	103fca1e 	bne	r2,zero,a9e0 <pbuf_copy_partial+0xac>
      left += buf_copy_len;
      len -= buf_copy_len;
      offset = 0;
    }
  }
  return copied_total;
    aab8:	e0bffb0b 	ldhu	r2,-20(fp)
}
    aabc:	e037883a 	mov	sp,fp
    aac0:	dfc00117 	ldw	ra,4(sp)
    aac4:	df000017 	ldw	fp,0(sp)
    aac8:	dec00204 	addi	sp,sp,8
    aacc:	f800283a 	ret

0000aad0 <pbuf_take>:
 *
 * @return ERR_OK if successful, ERR_MEM if the pbuf is not big enough
 */
err_t
pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len)
{
    aad0:	defff804 	addi	sp,sp,-32
    aad4:	dfc00715 	stw	ra,28(sp)
    aad8:	df000615 	stw	fp,24(sp)
    aadc:	df000604 	addi	fp,sp,24
    aae0:	e13ffd15 	stw	r4,-12(fp)
    aae4:	e17ffe15 	stw	r5,-8(fp)
    aae8:	3005883a 	mov	r2,r6
    aaec:	e0bfff0d 	sth	r2,-4(fp)
  struct pbuf *p;
  u16_t buf_copy_len;
  u16_t total_copy_len = len;
    aaf0:	e0bfff0b 	ldhu	r2,-4(fp)
    aaf4:	e0bffb8d 	sth	r2,-18(fp)
  u16_t copied_total = 0;
    aaf8:	e03ffc0d 	sth	zero,-16(fp)

  LWIP_ERROR("pbuf_take: invalid buf", (buf != NULL), return 0;);
    aafc:	e0bffd17 	ldw	r2,-12(fp)
    ab00:	1000091e 	bne	r2,zero,ab28 <pbuf_take+0x58>
    ab04:	010000f4 	movhi	r4,3
    ab08:	21381b04 	addi	r4,r4,-8084
    ab0c:	014000f4 	movhi	r5,3
    ab10:	29791b04 	addi	r5,r5,-7060
    ab14:	0180db04 	movi	r6,876
    ab18:	01c000f4 	movhi	r7,3
    ab1c:	39f82c04 	addi	r7,r7,-8016
    ab20:	00166c00 	call	166c0 <printf>
    ab24:	003fff06 	br	ab24 <pbuf_take+0x54>
  LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return 0;);
    ab28:	e0bffe17 	ldw	r2,-8(fp)
    ab2c:	1000091e 	bne	r2,zero,ab54 <pbuf_take+0x84>
    ab30:	010000f4 	movhi	r4,3
    ab34:	21381b04 	addi	r4,r4,-8084
    ab38:	014000f4 	movhi	r5,3
    ab3c:	29792104 	addi	r5,r5,-7036
    ab40:	0180db44 	movi	r6,877
    ab44:	01c000f4 	movhi	r7,3
    ab48:	39f82c04 	addi	r7,r7,-8016
    ab4c:	00166c00 	call	166c0 <printf>
    ab50:	003fff06 	br	ab50 <pbuf_take+0x80>

  if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
    ab54:	e0bffd17 	ldw	r2,-12(fp)
    ab58:	10000726 	beq	r2,zero,ab78 <pbuf_take+0xa8>
    ab5c:	e0bffe17 	ldw	r2,-8(fp)
    ab60:	10000526 	beq	r2,zero,ab78 <pbuf_take+0xa8>
    ab64:	e0bffd17 	ldw	r2,-12(fp)
    ab68:	1080020b 	ldhu	r2,8(r2)
    ab6c:	10ffffcc 	andi	r3,r2,65535
    ab70:	e0bfff0b 	ldhu	r2,-4(fp)
    ab74:	1880022e 	bgeu	r3,r2,ab80 <pbuf_take+0xb0>
    return ERR_ARG;
    ab78:	00bffd84 	movi	r2,-10
    ab7c:	00003d06 	br	ac74 <pbuf_take+0x1a4>
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; total_copy_len != 0; p = p->next) {
    ab80:	e0bffd17 	ldw	r2,-12(fp)
    ab84:	e0bffa15 	stw	r2,-24(fp)
    ab88:	00002906 	br	ac30 <pbuf_take+0x160>
    LWIP_ASSERT("pbuf_take: invalid pbuf", p != NULL);
    ab8c:	e0bffa17 	ldw	r2,-24(fp)
    ab90:	1000091e 	bne	r2,zero,abb8 <pbuf_take+0xe8>
    ab94:	010000f4 	movhi	r4,3
    ab98:	21381b04 	addi	r4,r4,-8084
    ab9c:	014000f4 	movhi	r5,3
    aba0:	29792804 	addi	r5,r5,-7008
    aba4:	0180dd44 	movi	r6,885
    aba8:	01c000f4 	movhi	r7,3
    abac:	39f82c04 	addi	r7,r7,-8016
    abb0:	00166c00 	call	166c0 <printf>
    abb4:	003fff06 	br	abb4 <pbuf_take+0xe4>
    buf_copy_len = total_copy_len;
    abb8:	e0bffb8b 	ldhu	r2,-18(fp)
    abbc:	e0bffb0d 	sth	r2,-20(fp)
    if (buf_copy_len > p->len) {
    abc0:	e0bffa17 	ldw	r2,-24(fp)
    abc4:	1080028b 	ldhu	r2,10(r2)
    abc8:	10ffffcc 	andi	r3,r2,65535
    abcc:	e0bffb0b 	ldhu	r2,-20(fp)
    abd0:	1880032e 	bgeu	r3,r2,abe0 <pbuf_take+0x110>
      /* this pbuf cannot hold all remaining data */
      buf_copy_len = p->len;
    abd4:	e0bffa17 	ldw	r2,-24(fp)
    abd8:	1080028b 	ldhu	r2,10(r2)
    abdc:	e0bffb0d 	sth	r2,-20(fp)
    }
    /* copy the necessary parts of the buffer */
    MEMCPY(p->payload, &((char*)dataptr)[copied_total], buf_copy_len);
    abe0:	e0bffa17 	ldw	r2,-24(fp)
    abe4:	11000117 	ldw	r4,4(r2)
    abe8:	e0bffc0b 	ldhu	r2,-16(fp)
    abec:	e0fffe17 	ldw	r3,-8(fp)
    abf0:	1887883a 	add	r3,r3,r2
    abf4:	e0bffb0b 	ldhu	r2,-20(fp)
    abf8:	180b883a 	mov	r5,r3
    abfc:	100d883a 	mov	r6,r2
    ac00:	00164c00 	call	164c0 <memcpy>
    total_copy_len -= buf_copy_len;
    ac04:	e0fffb8b 	ldhu	r3,-18(fp)
    ac08:	e0bffb0b 	ldhu	r2,-20(fp)
    ac0c:	1885c83a 	sub	r2,r3,r2
    ac10:	e0bffb8d 	sth	r2,-18(fp)
    copied_total += buf_copy_len;
    ac14:	e0fffc0b 	ldhu	r3,-16(fp)
    ac18:	e0bffb0b 	ldhu	r2,-20(fp)
    ac1c:	1885883a 	add	r2,r3,r2
    ac20:	e0bffc0d 	sth	r2,-16(fp)
  if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
    return ERR_ARG;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; total_copy_len != 0; p = p->next) {
    ac24:	e0bffa17 	ldw	r2,-24(fp)
    ac28:	10800017 	ldw	r2,0(r2)
    ac2c:	e0bffa15 	stw	r2,-24(fp)
    ac30:	e0bffb8b 	ldhu	r2,-18(fp)
    ac34:	103fd51e 	bne	r2,zero,ab8c <pbuf_take+0xbc>
    /* copy the necessary parts of the buffer */
    MEMCPY(p->payload, &((char*)dataptr)[copied_total], buf_copy_len);
    total_copy_len -= buf_copy_len;
    copied_total += buf_copy_len;
  }
  LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
    ac38:	e0bffb8b 	ldhu	r2,-18(fp)
    ac3c:	1000031e 	bne	r2,zero,ac4c <pbuf_take+0x17c>
    ac40:	e0fffc0b 	ldhu	r3,-16(fp)
    ac44:	e0bfff0b 	ldhu	r2,-4(fp)
    ac48:	18800926 	beq	r3,r2,ac70 <pbuf_take+0x1a0>
    ac4c:	010000f4 	movhi	r4,3
    ac50:	21381b04 	addi	r4,r4,-8084
    ac54:	014000f4 	movhi	r5,3
    ac58:	29792e04 	addi	r5,r5,-6984
    ac5c:	0180e004 	movi	r6,896
    ac60:	01c000f4 	movhi	r7,3
    ac64:	39f82c04 	addi	r7,r7,-8016
    ac68:	00166c00 	call	166c0 <printf>
    ac6c:	003fff06 	br	ac6c <pbuf_take+0x19c>
  return ERR_OK;
    ac70:	0005883a 	mov	r2,zero
}
    ac74:	e037883a 	mov	sp,fp
    ac78:	dfc00117 	ldw	ra,4(sp)
    ac7c:	df000017 	ldw	fp,0(sp)
    ac80:	dec00204 	addi	sp,sp,8
    ac84:	f800283a 	ret

0000ac88 <pbuf_coalesce>:
 * @return a new, single pbuf (p->next is NULL)
 *         or the old pbuf if allocation fails
 */
struct pbuf*
pbuf_coalesce(struct pbuf *p, pbuf_layer layer)
{
    ac88:	defffa04 	addi	sp,sp,-24
    ac8c:	dfc00515 	stw	ra,20(sp)
    ac90:	df000415 	stw	fp,16(sp)
    ac94:	df000404 	addi	fp,sp,16
    ac98:	e13ffe15 	stw	r4,-8(fp)
    ac9c:	e17fff15 	stw	r5,-4(fp)
  struct pbuf *q;
  err_t err;
  if (p->next == NULL) {
    aca0:	e0bffe17 	ldw	r2,-8(fp)
    aca4:	10800017 	ldw	r2,0(r2)
    aca8:	1000021e 	bne	r2,zero,acb4 <pbuf_coalesce+0x2c>
    return p;
    acac:	e0bffe17 	ldw	r2,-8(fp)
    acb0:	00001e06 	br	ad2c <pbuf_coalesce+0xa4>
  }
  q = pbuf_alloc(layer, p->tot_len, PBUF_RAM);
    acb4:	e0bffe17 	ldw	r2,-8(fp)
    acb8:	1080020b 	ldhu	r2,8(r2)
    acbc:	10bfffcc 	andi	r2,r2,65535
    acc0:	e13fff17 	ldw	r4,-4(fp)
    acc4:	100b883a 	mov	r5,r2
    acc8:	000d883a 	mov	r6,zero
    accc:	00097b00 	call	97b0 <pbuf_alloc>
    acd0:	e0bffc15 	stw	r2,-16(fp)
  if (q == NULL) {
    acd4:	e0bffc17 	ldw	r2,-16(fp)
    acd8:	1000021e 	bne	r2,zero,ace4 <pbuf_coalesce+0x5c>
    /* @todo: what do we do now? */
    return p;
    acdc:	e0bffe17 	ldw	r2,-8(fp)
    ace0:	00001206 	br	ad2c <pbuf_coalesce+0xa4>
  }
  err = pbuf_copy(q, p);
    ace4:	e13ffc17 	ldw	r4,-16(fp)
    ace8:	e17ffe17 	ldw	r5,-8(fp)
    acec:	000a6700 	call	a670 <pbuf_copy>
    acf0:	e0bffd05 	stb	r2,-12(fp)
  LWIP_ASSERT("pbuf_copy failed", err == ERR_OK);
    acf4:	e0bffd07 	ldb	r2,-12(fp)
    acf8:	10000926 	beq	r2,zero,ad20 <pbuf_coalesce+0x98>
    acfc:	010000f4 	movhi	r4,3
    ad00:	21381b04 	addi	r4,r4,-8084
    ad04:	014000f4 	movhi	r5,3
    ad08:	29793404 	addi	r5,r5,-6960
    ad0c:	0180e784 	movi	r6,926
    ad10:	01c000f4 	movhi	r7,3
    ad14:	39f82c04 	addi	r7,r7,-8016
    ad18:	00166c00 	call	166c0 <printf>
    ad1c:	003fff06 	br	ad1c <pbuf_coalesce+0x94>
  pbuf_free(p);
    ad20:	e13ffe17 	ldw	r4,-8(fp)
    ad24:	000a16c0 	call	a16c <pbuf_free>
  return q;
    ad28:	e0bffc17 	ldw	r2,-16(fp)
}
    ad2c:	e037883a 	mov	sp,fp
    ad30:	dfc00117 	ldw	ra,4(sp)
    ad34:	df000017 	ldw	fp,0(sp)
    ad38:	dec00204 	addi	sp,sp,8
    ad3c:	f800283a 	ret

0000ad40 <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
    ad40:	defff704 	addi	sp,sp,-36
    ad44:	dfc00815 	stw	ra,32(sp)
    ad48:	df000715 	stw	fp,28(sp)
    ad4c:	df000704 	addi	fp,sp,28
    ad50:	e13ffe15 	stw	r4,-8(fp)
    ad54:	e17fff15 	stw	r5,-4(fp)
  struct raw_pcb *pcb, *prev;
  struct ip_hdr *iphdr;
  s16_t proto;
  u8_t eaten = 0;
    ad58:	e03ffb05 	stb	zero,-20(fp)

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
    ad5c:	e0bffe17 	ldw	r2,-8(fp)
    ad60:	10800117 	ldw	r2,4(r2)
    ad64:	e0bffc15 	stw	r2,-16(fp)
  proto = IPH_PROTO(iphdr);
    ad68:	e0bffc17 	ldw	r2,-16(fp)
    ad6c:	1080020b 	ldhu	r2,8(r2)
    ad70:	10bfffcc 	andi	r2,r2,65535
    ad74:	1004d23a 	srli	r2,r2,8
    ad78:	1007883a 	mov	r3,r2
    ad7c:	e0bffc17 	ldw	r2,-16(fp)
    ad80:	1080020b 	ldhu	r2,8(r2)
    ad84:	10bfffcc 	andi	r2,r2,65535
    ad88:	1004923a 	slli	r2,r2,8
    ad8c:	1884b03a 	or	r2,r3,r2
    ad90:	10803fcc 	andi	r2,r2,255
    ad94:	e0bffd0d 	sth	r2,-12(fp)

  prev = NULL;
    ad98:	e03ffa15 	stw	zero,-24(fp)
  pcb = raw_pcbs;
    ad9c:	d0a8d417 	ldw	r2,-23728(gp)
    ada0:	e0bff915 	stw	r2,-28(fp)
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    ada4:	00002806 	br	ae48 <raw_input+0x108>
    if (pcb->protocol == proto) {
    ada8:	e0bff917 	ldw	r2,-28(fp)
    adac:	10800403 	ldbu	r2,16(r2)
    adb0:	10c03fcc 	andi	r3,r2,255
    adb4:	e0bffd0f 	ldh	r2,-12(fp)
    adb8:	18801e1e 	bne	r3,r2,ae34 <raw_input+0xf4>
      /* broadcast filter? */
      if ((pcb->so_options & SOF_BROADCAST) || !ip_addr_isbroadcast(&(iphdr->dest), inp))
#endif /* IP_SOF_BROADCAST_RECV */
      {
        /* receive callback function available? */
        if (pcb->recv != NULL) {
    adbc:	e0bff917 	ldw	r2,-28(fp)
    adc0:	10800517 	ldw	r2,20(r2)
    adc4:	10001b26 	beq	r2,zero,ae34 <raw_input+0xf4>
          /* the receive callback function did not eat the packet? */
          if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0) {
    adc8:	e0bff917 	ldw	r2,-28(fp)
    adcc:	12000517 	ldw	r8,20(r2)
    add0:	e0bff917 	ldw	r2,-28(fp)
    add4:	10c00617 	ldw	r3,24(r2)
    add8:	e0bffc17 	ldw	r2,-16(fp)
    addc:	10800304 	addi	r2,r2,12
    ade0:	1809883a 	mov	r4,r3
    ade4:	e17ff917 	ldw	r5,-28(fp)
    ade8:	e1bffe17 	ldw	r6,-8(fp)
    adec:	100f883a 	mov	r7,r2
    adf0:	403ee83a 	callr	r8
    adf4:	10803fcc 	andi	r2,r2,255
    adf8:	10000e26 	beq	r2,zero,ae34 <raw_input+0xf4>
            /* receive function ate the packet */
            p = NULL;
    adfc:	e03ffe15 	stw	zero,-8(fp)
            eaten = 1;
    ae00:	00800044 	movi	r2,1
    ae04:	e0bffb05 	stb	r2,-20(fp)
            if (prev != NULL) {
    ae08:	e0bffa17 	ldw	r2,-24(fp)
    ae0c:	10000926 	beq	r2,zero,ae34 <raw_input+0xf4>
            /* move the pcb to the front of raw_pcbs so that is
               found faster next time */
              prev->next = pcb->next;
    ae10:	e0bff917 	ldw	r2,-28(fp)
    ae14:	10c00317 	ldw	r3,12(r2)
    ae18:	e0bffa17 	ldw	r2,-24(fp)
    ae1c:	10c00315 	stw	r3,12(r2)
              pcb->next = raw_pcbs;
    ae20:	d0e8d417 	ldw	r3,-23728(gp)
    ae24:	e0bff917 	ldw	r2,-28(fp)
    ae28:	10c00315 	stw	r3,12(r2)
              raw_pcbs = pcb;
    ae2c:	e0bff917 	ldw	r2,-28(fp)
    ae30:	d0a8d415 	stw	r2,-23728(gp)
        }
        /* no receive callback function was set for this raw PCB */
      }
      /* drop the packet */
    }
    prev = pcb;
    ae34:	e0bff917 	ldw	r2,-28(fp)
    ae38:	e0bffa15 	stw	r2,-24(fp)
    pcb = pcb->next;
    ae3c:	e0bff917 	ldw	r2,-28(fp)
    ae40:	10800317 	ldw	r2,12(r2)
    ae44:	e0bff915 	stw	r2,-28(fp)

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    ae48:	e0bffb03 	ldbu	r2,-20(fp)
    ae4c:	1000021e 	bne	r2,zero,ae58 <raw_input+0x118>
    ae50:	e0bff917 	ldw	r2,-28(fp)
    ae54:	103fd41e 	bne	r2,zero,ada8 <raw_input+0x68>
      /* drop the packet */
    }
    prev = pcb;
    pcb = pcb->next;
  }
  return eaten;
    ae58:	e0bffb03 	ldbu	r2,-20(fp)
}
    ae5c:	e037883a 	mov	sp,fp
    ae60:	dfc00117 	ldw	ra,4(sp)
    ae64:	df000017 	ldw	fp,0(sp)
    ae68:	dec00204 	addi	sp,sp,8
    ae6c:	f800283a 	ret

0000ae70 <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
    ae70:	defffd04 	addi	sp,sp,-12
    ae74:	df000215 	stw	fp,8(sp)
    ae78:	df000204 	addi	fp,sp,8
    ae7c:	e13ffe15 	stw	r4,-8(fp)
    ae80:	e17fff15 	stw	r5,-4(fp)
  ip_addr_set(&pcb->local_ip, ipaddr);
    ae84:	e0bfff17 	ldw	r2,-4(fp)
    ae88:	10000626 	beq	r2,zero,aea4 <raw_bind+0x34>
    ae8c:	e0bfff17 	ldw	r2,-4(fp)
    ae90:	10c0000b 	ldhu	r3,0(r2)
    ae94:	1080008b 	ldhu	r2,2(r2)
    ae98:	1004943a 	slli	r2,r2,16
    ae9c:	10c4b03a 	or	r2,r2,r3
    aea0:	00000106 	br	aea8 <raw_bind+0x38>
    aea4:	0005883a 	mov	r2,zero
    aea8:	e0fffe17 	ldw	r3,-8(fp)
    aeac:	18800015 	stw	r2,0(r3)
  return ERR_OK;
    aeb0:	0005883a 	mov	r2,zero
}
    aeb4:	e037883a 	mov	sp,fp
    aeb8:	df000017 	ldw	fp,0(sp)
    aebc:	dec00104 	addi	sp,sp,4
    aec0:	f800283a 	ret

0000aec4 <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
    aec4:	defffd04 	addi	sp,sp,-12
    aec8:	df000215 	stw	fp,8(sp)
    aecc:	df000204 	addi	fp,sp,8
    aed0:	e13ffe15 	stw	r4,-8(fp)
    aed4:	e17fff15 	stw	r5,-4(fp)
  ip_addr_set(&pcb->remote_ip, ipaddr);
    aed8:	e0bfff17 	ldw	r2,-4(fp)
    aedc:	10000626 	beq	r2,zero,aef8 <raw_connect+0x34>
    aee0:	e0bfff17 	ldw	r2,-4(fp)
    aee4:	10c0000b 	ldhu	r3,0(r2)
    aee8:	1080008b 	ldhu	r2,2(r2)
    aeec:	1004943a 	slli	r2,r2,16
    aef0:	10c4b03a 	or	r2,r2,r3
    aef4:	00000106 	br	aefc <raw_connect+0x38>
    aef8:	0005883a 	mov	r2,zero
    aefc:	e0fffe17 	ldw	r3,-8(fp)
    af00:	18800115 	stw	r2,4(r3)
  return ERR_OK;
    af04:	0005883a 	mov	r2,zero
}
    af08:	e037883a 	mov	sp,fp
    af0c:	df000017 	ldw	fp,0(sp)
    af10:	dec00104 	addi	sp,sp,4
    af14:	f800283a 	ret

0000af18 <raw_recv>:
void
raw_recv(struct raw_pcb *pcb,
         u8_t (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
                      struct ip_addr *addr),
         void *recv_arg)
{
    af18:	defffc04 	addi	sp,sp,-16
    af1c:	df000315 	stw	fp,12(sp)
    af20:	df000304 	addi	fp,sp,12
    af24:	e13ffd15 	stw	r4,-12(fp)
    af28:	e17ffe15 	stw	r5,-8(fp)
    af2c:	e1bfff15 	stw	r6,-4(fp)
  /* remember recv() callback and user data */
  pcb->recv = recv;
    af30:	e0bffd17 	ldw	r2,-12(fp)
    af34:	e0fffe17 	ldw	r3,-8(fp)
    af38:	10c00515 	stw	r3,20(r2)
  pcb->recv_arg = recv_arg;
    af3c:	e0bffd17 	ldw	r2,-12(fp)
    af40:	e0ffff17 	ldw	r3,-4(fp)
    af44:	10c00615 	stw	r3,24(r2)
}
    af48:	e037883a 	mov	sp,fp
    af4c:	df000017 	ldw	fp,0(sp)
    af50:	dec00104 	addi	sp,sp,4
    af54:	f800283a 	ret

0000af58 <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
    af58:	defff404 	addi	sp,sp,-48
    af5c:	dfc00b15 	stw	ra,44(sp)
    af60:	df000a15 	stw	fp,40(sp)
    af64:	df000a04 	addi	fp,sp,40
    af68:	e13ffd15 	stw	r4,-12(fp)
    af6c:	e17ffe15 	stw	r5,-8(fp)
    af70:	e1bfff15 	stw	r6,-4(fp)
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
    af74:	e13ffe17 	ldw	r4,-8(fp)
    af78:	01400504 	movi	r5,20
    af7c:	0009f740 	call	9f74 <pbuf_header>
    af80:	10803fcc 	andi	r2,r2,255
    af84:	10000d26 	beq	r2,zero,afbc <raw_sendto+0x64>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
    af88:	01000044 	movi	r4,1
    af8c:	000b883a 	mov	r5,zero
    af90:	000d883a 	mov	r6,zero
    af94:	00097b00 	call	97b0 <pbuf_alloc>
    af98:	e0bffa15 	stw	r2,-24(fp)
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
    af9c:	e0bffa17 	ldw	r2,-24(fp)
    afa0:	1000021e 	bne	r2,zero,afac <raw_sendto+0x54>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
    afa4:	00bfffc4 	movi	r2,-1
    afa8:	00004406 	br	b0bc <raw_sendto+0x164>
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
    afac:	e13ffa17 	ldw	r4,-24(fp)
    afb0:	e17ffe17 	ldw	r5,-8(fp)
    afb4:	000a5040 	call	a504 <pbuf_chain>
    afb8:	00001006 	br	affc <raw_sendto+0xa4>
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
    afbc:	e0bffe17 	ldw	r2,-8(fp)
    afc0:	e0bffa15 	stw	r2,-24(fp)
    if(pbuf_header(q, -IP_HLEN)) {
    afc4:	e13ffa17 	ldw	r4,-24(fp)
    afc8:	017ffb04 	movi	r5,-20
    afcc:	0009f740 	call	9f74 <pbuf_header>
    afd0:	10803fcc 	andi	r2,r2,255
    afd4:	10000926 	beq	r2,zero,affc <raw_sendto+0xa4>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
    afd8:	010000f4 	movhi	r4,3
    afdc:	21393904 	addi	r4,r4,-6940
    afe0:	014000f4 	movhi	r5,3
    afe4:	29794304 	addi	r5,r5,-6900
    afe8:	01803a04 	movi	r6,232
    afec:	01c000f4 	movhi	r7,3
    aff0:	39f94d04 	addi	r7,r7,-6860
    aff4:	00166c00 	call	166c0 <printf>
    aff8:	003fff06 	br	aff8 <raw_sendto+0xa0>
      return ERR_MEM;
    }
  }

  if ((netif = ip_route(ipaddr)) == NULL) {
    affc:	e13fff17 	ldw	r4,-4(fp)
    b000:	00061940 	call	6194 <ip_route>
    b004:	e0bffb15 	stw	r2,-20(fp)
    b008:	e0bffb17 	ldw	r2,-20(fp)
    b00c:	1000071e 	bne	r2,zero,b02c <raw_sendto+0xd4>
    LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_LEVEL_WARNING, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
    b010:	e0fffa17 	ldw	r3,-24(fp)
    b014:	e0bffe17 	ldw	r2,-8(fp)
    b018:	18800226 	beq	r3,r2,b024 <raw_sendto+0xcc>
      pbuf_free(q);
    b01c:	e13ffa17 	ldw	r4,-24(fp)
    b020:	000a16c0 	call	a16c <pbuf_free>
    }
    return ERR_RTE;
    b024:	00bfff04 	movi	r2,-4
    b028:	00002406 	br	b0bc <raw_sendto+0x164>
    }
    return ERR_VAL;
  }
#endif /* IP_SOF_BROADCAST */

  if (ip_addr_isany(&pcb->local_ip)) {
    b02c:	e0bffd17 	ldw	r2,-12(fp)
    b030:	10000326 	beq	r2,zero,b040 <raw_sendto+0xe8>
    b034:	e0bffd17 	ldw	r2,-12(fp)
    b038:	10800017 	ldw	r2,0(r2)
    b03c:	1000041e 	bne	r2,zero,b050 <raw_sendto+0xf8>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
    b040:	e0bffb17 	ldw	r2,-20(fp)
    b044:	10800104 	addi	r2,r2,4
    b048:	e0bff915 	stw	r2,-28(fp)
    b04c:	00000206 	br	b058 <raw_sendto+0x100>
  } else {
    /* use RAW PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
    b050:	e0bffd17 	ldw	r2,-12(fp)
    b054:	e0bff915 	stw	r2,-28(fp)
  }

#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
    b058:	e0bffd17 	ldw	r2,-12(fp)
    b05c:	108002c3 	ldbu	r2,11(r2)
    b060:	10803fcc 	andi	r2,r2,255
    b064:	e0fffd17 	ldw	r3,-12(fp)
    b068:	18c00283 	ldbu	r3,10(r3)
    b06c:	19003fcc 	andi	r4,r3,255
    b070:	e0fffd17 	ldw	r3,-12(fp)
    b074:	18c00403 	ldbu	r3,16(r3)
    b078:	18c03fcc 	andi	r3,r3,255
    b07c:	d9000015 	stw	r4,0(sp)
    b080:	d8c00115 	stw	r3,4(sp)
    b084:	e0fffb17 	ldw	r3,-20(fp)
    b088:	d8c00215 	stw	r3,8(sp)
    b08c:	e13ffa17 	ldw	r4,-24(fp)
    b090:	e17ff917 	ldw	r5,-28(fp)
    b094:	e1bfff17 	ldw	r6,-4(fp)
    b098:	100f883a 	mov	r7,r2
    b09c:	00068600 	call	6860 <ip_output_if>
    b0a0:	e0bffc05 	stb	r2,-16(fp)
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  /* did we chain a header earlier? */
  if (q != p) {
    b0a4:	e0fffa17 	ldw	r3,-24(fp)
    b0a8:	e0bffe17 	ldw	r2,-8(fp)
    b0ac:	18800226 	beq	r3,r2,b0b8 <raw_sendto+0x160>
    /* free the header */
    pbuf_free(q);
    b0b0:	e13ffa17 	ldw	r4,-24(fp)
    b0b4:	000a16c0 	call	a16c <pbuf_free>
  }
  return err;
    b0b8:	e0bffc03 	ldbu	r2,-16(fp)
}
    b0bc:	e037883a 	mov	sp,fp
    b0c0:	dfc00117 	ldw	ra,4(sp)
    b0c4:	df000017 	ldw	fp,0(sp)
    b0c8:	dec00204 	addi	sp,sp,8
    b0cc:	f800283a 	ret

0000b0d0 <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
    b0d0:	defffc04 	addi	sp,sp,-16
    b0d4:	dfc00315 	stw	ra,12(sp)
    b0d8:	df000215 	stw	fp,8(sp)
    b0dc:	df000204 	addi	fp,sp,8
    b0e0:	e13ffe15 	stw	r4,-8(fp)
    b0e4:	e17fff15 	stw	r5,-4(fp)
  return raw_sendto(pcb, p, &pcb->remote_ip);
    b0e8:	e0bffe17 	ldw	r2,-8(fp)
    b0ec:	10800104 	addi	r2,r2,4
    b0f0:	e13ffe17 	ldw	r4,-8(fp)
    b0f4:	e17fff17 	ldw	r5,-4(fp)
    b0f8:	100d883a 	mov	r6,r2
    b0fc:	000af580 	call	af58 <raw_sendto>
}
    b100:	e037883a 	mov	sp,fp
    b104:	dfc00117 	ldw	ra,4(sp)
    b108:	df000017 	ldw	fp,0(sp)
    b10c:	dec00204 	addi	sp,sp,8
    b110:	f800283a 	ret

0000b114 <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
    b114:	defffc04 	addi	sp,sp,-16
    b118:	dfc00315 	stw	ra,12(sp)
    b11c:	df000215 	stw	fp,8(sp)
    b120:	df000204 	addi	fp,sp,8
    b124:	e13fff15 	stw	r4,-4(fp)
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
    b128:	d0e8d417 	ldw	r3,-23728(gp)
    b12c:	e0bfff17 	ldw	r2,-4(fp)
    b130:	1880041e 	bne	r3,r2,b144 <raw_remove+0x30>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    b134:	d0a8d417 	ldw	r2,-23728(gp)
    b138:	10800317 	ldw	r2,12(r2)
    b13c:	d0a8d415 	stw	r2,-23728(gp)
    b140:	00001306 	br	b190 <raw_remove+0x7c>
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
    b144:	d0a8d417 	ldw	r2,-23728(gp)
    b148:	e0bffe15 	stw	r2,-8(fp)
    b14c:	00000e06 	br	b188 <raw_remove+0x74>
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
    b150:	e0bffe17 	ldw	r2,-8(fp)
    b154:	10800317 	ldw	r2,12(r2)
    b158:	10000826 	beq	r2,zero,b17c <raw_remove+0x68>
    b15c:	e0bffe17 	ldw	r2,-8(fp)
    b160:	10c00317 	ldw	r3,12(r2)
    b164:	e0bfff17 	ldw	r2,-4(fp)
    b168:	1880041e 	bne	r3,r2,b17c <raw_remove+0x68>
        /* remove pcb from list */
        pcb2->next = pcb->next;
    b16c:	e0bfff17 	ldw	r2,-4(fp)
    b170:	10c00317 	ldw	r3,12(r2)
    b174:	e0bffe17 	ldw	r2,-8(fp)
    b178:	10c00315 	stw	r3,12(r2)
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
    b17c:	e0bffe17 	ldw	r2,-8(fp)
    b180:	10800317 	ldw	r2,12(r2)
    b184:	e0bffe15 	stw	r2,-8(fp)
    b188:	e0bffe17 	ldw	r2,-8(fp)
    b18c:	103ff01e 	bne	r2,zero,b150 <raw_remove+0x3c>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
    b190:	0009883a 	mov	r4,zero
    b194:	e17fff17 	ldw	r5,-4(fp)
    b198:	00090cc0 	call	90cc <memp_free>
}
    b19c:	e037883a 	mov	sp,fp
    b1a0:	dfc00117 	ldw	ra,4(sp)
    b1a4:	df000017 	ldw	fp,0(sp)
    b1a8:	dec00204 	addi	sp,sp,8
    b1ac:	f800283a 	ret

0000b1b0 <raw_new>:
 * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto) {
    b1b0:	defffc04 	addi	sp,sp,-16
    b1b4:	dfc00315 	stw	ra,12(sp)
    b1b8:	df000215 	stw	fp,8(sp)
    b1bc:	df000204 	addi	fp,sp,8
    b1c0:	2005883a 	mov	r2,r4
    b1c4:	e0bfff05 	stb	r2,-4(fp)
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE, ("raw_new\n"));

  pcb = memp_malloc(MEMP_RAW_PCB);
    b1c8:	0009883a 	mov	r4,zero
    b1cc:	0008ef00 	call	8ef0 <memp_malloc>
    b1d0:	e0bffe15 	stw	r2,-8(fp)
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
    b1d4:	e0bffe17 	ldw	r2,-8(fp)
    b1d8:	10000f26 	beq	r2,zero,b218 <raw_new+0x68>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
    b1dc:	e13ffe17 	ldw	r4,-8(fp)
    b1e0:	000b883a 	mov	r5,zero
    b1e4:	01800704 	movi	r6,28
    b1e8:	00165b80 	call	165b8 <memset>
    pcb->protocol = proto;
    b1ec:	e0bffe17 	ldw	r2,-8(fp)
    b1f0:	e0ffff03 	ldbu	r3,-4(fp)
    b1f4:	10c00405 	stb	r3,16(r2)
    pcb->ttl = RAW_TTL;
    b1f8:	e0bffe17 	ldw	r2,-8(fp)
    b1fc:	00ffffc4 	movi	r3,-1
    b200:	10c002c5 	stb	r3,11(r2)
    pcb->next = raw_pcbs;
    b204:	d0e8d417 	ldw	r3,-23728(gp)
    b208:	e0bffe17 	ldw	r2,-8(fp)
    b20c:	10c00315 	stw	r3,12(r2)
    raw_pcbs = pcb;
    b210:	e0bffe17 	ldw	r2,-8(fp)
    b214:	d0a8d415 	stw	r2,-23728(gp)
  }
  return pcb;
    b218:	e0bffe17 	ldw	r2,-8(fp)
}
    b21c:	e037883a 	mov	sp,fp
    b220:	dfc00117 	ldw	ra,4(sp)
    b224:	df000017 	ldw	fp,0(sp)
    b228:	dec00204 	addi	sp,sp,8
    b22c:	f800283a 	ret

0000b230 <tcp_tmr>:
 * Called periodically to dispatch TCP timers.
 *
 */
void
tcp_tmr(void)
{
    b230:	defffe04 	addi	sp,sp,-8
    b234:	dfc00115 	stw	ra,4(sp)
    b238:	df000015 	stw	fp,0(sp)
    b23c:	d839883a 	mov	fp,sp
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
    b240:	000c8080 	call	c808 <tcp_fasttmr>

  if (++tcp_timer & 1) {
    b244:	d0a8d503 	ldbu	r2,-23724(gp)
    b248:	10800044 	addi	r2,r2,1
    b24c:	d0a8d505 	stb	r2,-23724(gp)
    b250:	d0a8d503 	ldbu	r2,-23724(gp)
    b254:	10803fcc 	andi	r2,r2,255
    b258:	1080004c 	andi	r2,r2,1
    b25c:	10000126 	beq	r2,zero,b264 <tcp_tmr+0x34>
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
    b260:	000bfec0 	call	bfec <tcp_slowtmr>
  }
}
    b264:	e037883a 	mov	sp,fp
    b268:	dfc00117 	ldw	ra,4(sp)
    b26c:	df000017 	ldw	fp,0(sp)
    b270:	dec00204 	addi	sp,sp,8
    b274:	f800283a 	ret

0000b278 <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
    b278:	defffc04 	addi	sp,sp,-16
    b27c:	dfc00315 	stw	ra,12(sp)
    b280:	df000215 	stw	fp,8(sp)
    b284:	df000204 	addi	fp,sp,8
    b288:	e13fff15 	stw	r4,-4(fp)
#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  switch (pcb->state) {
    b28c:	e0bfff17 	ldw	r2,-4(fp)
    b290:	10800417 	ldw	r2,16(r2)
    b294:	10c00228 	cmpgeui	r3,r2,8
    b298:	18005f1e 	bne	r3,zero,b418 <tcp_close+0x1a0>
    b29c:	1085883a 	add	r2,r2,r2
    b2a0:	1087883a 	add	r3,r2,r2
    b2a4:	00800074 	movhi	r2,1
    b2a8:	10acae04 	addi	r2,r2,-19784
    b2ac:	1885883a 	add	r2,r3,r2
    b2b0:	10800017 	ldw	r2,0(r2)
    b2b4:	1000683a 	jmp	r2
    b2b8:	0000b2d8 	cmpnei	zero,zero,715
    b2bc:	0000b358 	cmpnei	zero,zero,717
    b2c0:	0000b37c 	xorhi	zero,zero,717
    b2c4:	0000b3a0 	cmpeqi	zero,zero,718
    b2c8:	0000b3c8 	cmpgei	zero,zero,719
    b2cc:	0000b418 	cmpnei	zero,zero,720
    b2d0:	0000b418 	cmpnei	zero,zero,720
    b2d4:	0000b3f0 	cmpltui	zero,zero,719
     * and the user needs some way to free it should the need arise.
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
    b2d8:	e03ffe05 	stb	zero,-8(fp)
    TCP_RMV(&tcp_bound_pcbs, pcb);
    b2dc:	d0e8da17 	ldw	r3,-23704(gp)
    b2e0:	e0bfff17 	ldw	r2,-4(fp)
    b2e4:	1880041e 	bne	r3,r2,b2f8 <tcp_close+0x80>
    b2e8:	d0a8da17 	ldw	r2,-23704(gp)
    b2ec:	10800317 	ldw	r2,12(r2)
    b2f0:	d0a8da15 	stw	r2,-23704(gp)
    b2f4:	00001106 	br	b33c <tcp_close+0xc4>
    b2f8:	d0a8da17 	ldw	r2,-23704(gp)
    b2fc:	d0a8d915 	stw	r2,-23708(gp)
    b300:	00000c06 	br	b334 <tcp_close+0xbc>
    b304:	d0a8d917 	ldw	r2,-23708(gp)
    b308:	10c00317 	ldw	r3,12(r2)
    b30c:	e0bfff17 	ldw	r2,-4(fp)
    b310:	1880051e 	bne	r3,r2,b328 <tcp_close+0xb0>
    b314:	d0a8d917 	ldw	r2,-23708(gp)
    b318:	e0ffff17 	ldw	r3,-4(fp)
    b31c:	18c00317 	ldw	r3,12(r3)
    b320:	10c00315 	stw	r3,12(r2)
    b324:	00000506 	br	b33c <tcp_close+0xc4>
    b328:	d0a8d917 	ldw	r2,-23708(gp)
    b32c:	10800317 	ldw	r2,12(r2)
    b330:	d0a8d915 	stw	r2,-23708(gp)
    b334:	d0a8d917 	ldw	r2,-23708(gp)
    b338:	103ff21e 	bne	r2,zero,b304 <tcp_close+0x8c>
    b33c:	e0bfff17 	ldw	r2,-4(fp)
    b340:	10000315 	stw	zero,12(r2)
    memp_free(MEMP_TCP_PCB, pcb);
    b344:	01000084 	movi	r4,2
    b348:	e17fff17 	ldw	r5,-4(fp)
    b34c:	00090cc0 	call	90cc <memp_free>
    pcb = NULL;
    b350:	e03fff15 	stw	zero,-4(fp)
    break;
    b354:	00003806 	br	b438 <tcp_close+0x1c0>
  case LISTEN:
    err = ERR_OK;
    b358:	e03ffe05 	stb	zero,-8(fp)
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
    b35c:	d128d804 	addi	r4,gp,-23712
    b360:	e17fff17 	ldw	r5,-4(fp)
    b364:	000d0780 	call	d078 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
    b368:	010000c4 	movi	r4,3
    b36c:	e17fff17 	ldw	r5,-4(fp)
    b370:	00090cc0 	call	90cc <memp_free>
    pcb = NULL;
    b374:	e03fff15 	stw	zero,-4(fp)
    break;
    b378:	00002f06 	br	b438 <tcp_close+0x1c0>
  case SYN_SENT:
    err = ERR_OK;
    b37c:	e03ffe05 	stb	zero,-8(fp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
    b380:	d128d604 	addi	r4,gp,-23720
    b384:	e17fff17 	ldw	r5,-4(fp)
    b388:	000d0780 	call	d078 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
    b38c:	01000084 	movi	r4,2
    b390:	e17fff17 	ldw	r5,-4(fp)
    b394:	00090cc0 	call	90cc <memp_free>
    pcb = NULL;
    b398:	e03fff15 	stw	zero,-4(fp)
    snmp_inc_tcpattemptfails();
    break;
    b39c:	00002606 	br	b438 <tcp_close+0x1c0>
  case SYN_RCVD:
    err = tcp_send_ctrl(pcb, TCP_FIN);
    b3a0:	e13fff17 	ldw	r4,-4(fp)
    b3a4:	01400044 	movi	r5,1
    b3a8:	001127c0 	call	1127c <tcp_send_ctrl>
    b3ac:	e0bffe05 	stb	r2,-8(fp)
    if (err == ERR_OK) {
    b3b0:	e0bffe07 	ldb	r2,-8(fp)
    b3b4:	10001b1e 	bne	r2,zero,b424 <tcp_close+0x1ac>
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
    b3b8:	e0bfff17 	ldw	r2,-4(fp)
    b3bc:	00c00144 	movi	r3,5
    b3c0:	10c00415 	stw	r3,16(r2)
    }
    break;
    b3c4:	00001706 	br	b424 <tcp_close+0x1ac>
  case ESTABLISHED:
    err = tcp_send_ctrl(pcb, TCP_FIN);
    b3c8:	e13fff17 	ldw	r4,-4(fp)
    b3cc:	01400044 	movi	r5,1
    b3d0:	001127c0 	call	1127c <tcp_send_ctrl>
    b3d4:	e0bffe05 	stb	r2,-8(fp)
    if (err == ERR_OK) {
    b3d8:	e0bffe07 	ldb	r2,-8(fp)
    b3dc:	1000131e 	bne	r2,zero,b42c <tcp_close+0x1b4>
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
    b3e0:	e0bfff17 	ldw	r2,-4(fp)
    b3e4:	00c00144 	movi	r3,5
    b3e8:	10c00415 	stw	r3,16(r2)
    }
    break;
    b3ec:	00000f06 	br	b42c <tcp_close+0x1b4>
  case CLOSE_WAIT:
    err = tcp_send_ctrl(pcb, TCP_FIN);
    b3f0:	e13fff17 	ldw	r4,-4(fp)
    b3f4:	01400044 	movi	r5,1
    b3f8:	001127c0 	call	1127c <tcp_send_ctrl>
    b3fc:	e0bffe05 	stb	r2,-8(fp)
    if (err == ERR_OK) {
    b400:	e0bffe07 	ldb	r2,-8(fp)
    b404:	10000b1e 	bne	r2,zero,b434 <tcp_close+0x1bc>
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
    b408:	e0bfff17 	ldw	r2,-4(fp)
    b40c:	00c00244 	movi	r3,9
    b410:	10c00415 	stw	r3,16(r2)
    }
    break;
    b414:	00000706 	br	b434 <tcp_close+0x1bc>
  default:
    /* Has already been closed, do nothing. */
    err = ERR_OK;
    b418:	e03ffe05 	stb	zero,-8(fp)
    pcb = NULL;
    b41c:	e03fff15 	stw	zero,-4(fp)
    break;
    b420:	00000506 	br	b438 <tcp_close+0x1c0>
    err = tcp_send_ctrl(pcb, TCP_FIN);
    if (err == ERR_OK) {
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
    }
    break;
    b424:	0001883a 	nop
    b428:	00000306 	br	b438 <tcp_close+0x1c0>
    err = tcp_send_ctrl(pcb, TCP_FIN);
    if (err == ERR_OK) {
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
    }
    break;
    b42c:	0001883a 	nop
    b430:	00000106 	br	b438 <tcp_close+0x1c0>
    err = tcp_send_ctrl(pcb, TCP_FIN);
    if (err == ERR_OK) {
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
    }
    break;
    b434:	0001883a 	nop
    err = ERR_OK;
    pcb = NULL;
    break;
  }

  if (pcb != NULL && err == ERR_OK) {
    b438:	e0bfff17 	ldw	r2,-4(fp)
    b43c:	10000426 	beq	r2,zero,b450 <tcp_close+0x1d8>
    b440:	e0bffe07 	ldb	r2,-8(fp)
    b444:	1000021e 	bne	r2,zero,b450 <tcp_close+0x1d8>
       Since we don't really have to ensure all data has been sent when tcp_close
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent when tcp_close returns. */
    tcp_output(pcb);
    b448:	e13fff17 	ldw	r4,-4(fp)
    b44c:	00122380 	call	12238 <tcp_output>
  }
  return err;
    b450:	e0bffe03 	ldbu	r2,-8(fp)
}
    b454:	e037883a 	mov	sp,fp
    b458:	dfc00117 	ldw	ra,4(sp)
    b45c:	df000017 	ldw	fp,0(sp)
    b460:	dec00204 	addi	sp,sp,8
    b464:	f800283a 	ret

0000b468 <tcp_abandon>:
 * @param pcb the tcp_pcb to abort
 * @param reset boolean to indicate whether a reset should be sent
 */
void
tcp_abandon(struct tcp_pcb *pcb, int reset)
{
    b468:	defff304 	addi	sp,sp,-52
    b46c:	dfc00c15 	stw	ra,48(sp)
    b470:	df000b15 	stw	fp,44(sp)
    b474:	df000b04 	addi	fp,sp,44
    b478:	e13ffe15 	stw	r4,-8(fp)
    b47c:	e17fff15 	stw	r5,-4(fp)

  
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
    b480:	e0bffe17 	ldw	r2,-8(fp)
    b484:	10800417 	ldw	r2,16(r2)
    b488:	10800298 	cmpnei	r2,r2,10
    b48c:	1000071e 	bne	r2,zero,b4ac <tcp_abandon+0x44>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
    b490:	d128db04 	addi	r4,gp,-23700
    b494:	e17ffe17 	ldw	r5,-8(fp)
    b498:	000d0780 	call	d078 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
    b49c:	01000084 	movi	r4,2
    b4a0:	e17ffe17 	ldw	r5,-8(fp)
    b4a4:	00090cc0 	call	90cc <memp_free>
    b4a8:	00004f06 	br	b5e8 <tcp_abandon+0x180>
  } else {
    seqno = pcb->snd_nxt;
    b4ac:	e0bffe17 	ldw	r2,-8(fp)
    b4b0:	10801717 	ldw	r2,92(r2)
    b4b4:	e0bff715 	stw	r2,-36(fp)
    ackno = pcb->rcv_nxt;
    b4b8:	e0bffe17 	ldw	r2,-8(fp)
    b4bc:	10800a17 	ldw	r2,40(r2)
    b4c0:	e0bff815 	stw	r2,-32(fp)
    ip_addr_set(&local_ip, &(pcb->local_ip));
    b4c4:	e0bffe17 	ldw	r2,-8(fp)
    b4c8:	10000326 	beq	r2,zero,b4d8 <tcp_abandon+0x70>
    b4cc:	e0bffe17 	ldw	r2,-8(fp)
    b4d0:	10800017 	ldw	r2,0(r2)
    b4d4:	00000106 	br	b4dc <tcp_abandon+0x74>
    b4d8:	0005883a 	mov	r2,zero
    b4dc:	e0bffd15 	stw	r2,-12(fp)
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
    b4e0:	e0bffe17 	ldw	r2,-8(fp)
    b4e4:	10800104 	addi	r2,r2,4
    b4e8:	10000326 	beq	r2,zero,b4f8 <tcp_abandon+0x90>
    b4ec:	e0bffe17 	ldw	r2,-8(fp)
    b4f0:	10800117 	ldw	r2,4(r2)
    b4f4:	00000106 	br	b4fc <tcp_abandon+0x94>
    b4f8:	0005883a 	mov	r2,zero
    b4fc:	e0bffc15 	stw	r2,-16(fp)
    local_port = pcb->local_port;
    b500:	e0bffe17 	ldw	r2,-8(fp)
    b504:	1080070b 	ldhu	r2,28(r2)
    b508:	e0bff90d 	sth	r2,-28(fp)
    remote_port = pcb->remote_port;
    b50c:	e0bffe17 	ldw	r2,-8(fp)
    b510:	1080090b 	ldhu	r2,36(r2)
    b514:	e0bff98d 	sth	r2,-26(fp)
#if LWIP_CALLBACK_API
    errf = pcb->errf;
    b518:	e0bffe17 	ldw	r2,-8(fp)
    b51c:	10802617 	ldw	r2,152(r2)
    b520:	e0bffa15 	stw	r2,-24(fp)
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
    b524:	e0bffe17 	ldw	r2,-8(fp)
    b528:	10800617 	ldw	r2,24(r2)
    b52c:	e0bffb15 	stw	r2,-20(fp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
    b530:	d128d604 	addi	r4,gp,-23720
    b534:	e17ffe17 	ldw	r5,-8(fp)
    b538:	000d0780 	call	d078 <tcp_pcb_remove>
    if (pcb->unacked != NULL) {
    b53c:	e0bffe17 	ldw	r2,-8(fp)
    b540:	10801f17 	ldw	r2,124(r2)
    b544:	10000426 	beq	r2,zero,b558 <tcp_abandon+0xf0>
      tcp_segs_free(pcb->unacked);
    b548:	e0bffe17 	ldw	r2,-8(fp)
    b54c:	10801f17 	ldw	r2,124(r2)
    b550:	1009883a 	mov	r4,r2
    b554:	000c9180 	call	c918 <tcp_segs_free>
    }
    if (pcb->unsent != NULL) {
    b558:	e0bffe17 	ldw	r2,-8(fp)
    b55c:	10801e17 	ldw	r2,120(r2)
    b560:	10000426 	beq	r2,zero,b574 <tcp_abandon+0x10c>
      tcp_segs_free(pcb->unsent);
    b564:	e0bffe17 	ldw	r2,-8(fp)
    b568:	10801e17 	ldw	r2,120(r2)
    b56c:	1009883a 	mov	r4,r2
    b570:	000c9180 	call	c918 <tcp_segs_free>
    }
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
    b574:	e0bffe17 	ldw	r2,-8(fp)
    b578:	10802017 	ldw	r2,128(r2)
    b57c:	10000426 	beq	r2,zero,b590 <tcp_abandon+0x128>
      tcp_segs_free(pcb->ooseq);
    b580:	e0bffe17 	ldw	r2,-8(fp)
    b584:	10802017 	ldw	r2,128(r2)
    b588:	1009883a 	mov	r4,r2
    b58c:	000c9180 	call	c918 <tcp_segs_free>
    }
#endif /* TCP_QUEUE_OOSEQ */
    memp_free(MEMP_TCP_PCB, pcb);
    b590:	01000084 	movi	r4,2
    b594:	e17ffe17 	ldw	r5,-8(fp)
    b598:	00090cc0 	call	90cc <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
    b59c:	e0bffa17 	ldw	r2,-24(fp)
    b5a0:	10000426 	beq	r2,zero,b5b4 <tcp_abandon+0x14c>
    b5a4:	e0bffa17 	ldw	r2,-24(fp)
    b5a8:	e13ffb17 	ldw	r4,-20(fp)
    b5ac:	017ffec4 	movi	r5,-5
    b5b0:	103ee83a 	callr	r2
    if (reset) {
    b5b4:	e0bfff17 	ldw	r2,-4(fp)
    b5b8:	10000b26 	beq	r2,zero,b5e8 <tcp_abandon+0x180>
      LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abandon: sending RST\n"));
      tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
    b5bc:	e17ff90b 	ldhu	r5,-28(fp)
    b5c0:	e13ff98b 	ldhu	r4,-26(fp)
    b5c4:	e0fffd04 	addi	r3,fp,-12
    b5c8:	e0bffc04 	addi	r2,fp,-16
    b5cc:	d9400015 	stw	r5,0(sp)
    b5d0:	d9000115 	stw	r4,4(sp)
    b5d4:	e13ff717 	ldw	r4,-36(fp)
    b5d8:	e17ff817 	ldw	r5,-32(fp)
    b5dc:	180d883a 	mov	r6,r3
    b5e0:	100f883a 	mov	r7,r2
    b5e4:	0012e5c0 	call	12e5c <tcp_rst>
    }
  }
}
    b5e8:	e037883a 	mov	sp,fp
    b5ec:	dfc00117 	ldw	ra,4(sp)
    b5f0:	df000017 	ldw	fp,0(sp)
    b5f4:	dec00204 	addi	sp,sp,8
    b5f8:	f800283a 	ret

0000b5fc <tcp_bind>:
 * @return ERR_USE if the port is already in use
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
    b5fc:	defffa04 	addi	sp,sp,-24
    b600:	dfc00515 	stw	ra,20(sp)
    b604:	df000415 	stw	fp,16(sp)
    b608:	df000404 	addi	fp,sp,16
    b60c:	e13ffd15 	stw	r4,-12(fp)
    b610:	e17ffe15 	stw	r5,-8(fp)
    b614:	3005883a 	mov	r2,r6
    b618:	e0bfff0d 	sth	r2,-4(fp)
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
    b61c:	e0bffd17 	ldw	r2,-12(fp)
    b620:	10800417 	ldw	r2,16(r2)
    b624:	10000926 	beq	r2,zero,b64c <tcp_bind+0x50>
    b628:	010000f4 	movhi	r4,3
    b62c:	21397304 	addi	r4,r4,-6708
    b630:	014000f4 	movhi	r5,3
    b634:	29797d04 	addi	r5,r5,-6668
    b638:	01804604 	movi	r6,280
    b63c:	01c000f4 	movhi	r7,3
    b640:	39f98704 	addi	r7,r7,-6628
    b644:	00166c00 	call	166c0 <printf>
    b648:	003fff06 	br	b648 <tcp_bind+0x4c>

  if (port == 0) {
    b64c:	e0bfff0b 	ldhu	r2,-4(fp)
    b650:	1000021e 	bne	r2,zero,b65c <tcp_bind+0x60>
    port = tcp_new_port();
    b654:	000bc9c0 	call	bc9c <tcp_new_port>
    b658:	e0bfff0d 	sth	r2,-4(fp)
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
    b65c:	d0a8d817 	ldw	r2,-23712(gp)
    b660:	e0bffc15 	stw	r2,-16(fp)
    b664:	00001f06 	br	b6e4 <tcp_bind+0xe8>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
    b668:	e0bffc17 	ldw	r2,-16(fp)
    b66c:	1080070b 	ldhu	r2,28(r2)
    b670:	10ffffcc 	andi	r3,r2,65535
    b674:	e0bfff0b 	ldhu	r2,-4(fp)
    b678:	1880171e 	bne	r3,r2,b6d8 <tcp_bind+0xdc>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
    b67c:	e0bffc17 	ldw	r2,-16(fp)
    b680:	10001326 	beq	r2,zero,b6d0 <tcp_bind+0xd4>
    b684:	e0bffc17 	ldw	r2,-16(fp)
    b688:	10800017 	ldw	r2,0(r2)
    b68c:	10001026 	beq	r2,zero,b6d0 <tcp_bind+0xd4>
    b690:	e0bffe17 	ldw	r2,-8(fp)
    b694:	10000e26 	beq	r2,zero,b6d0 <tcp_bind+0xd4>
          ip_addr_isany(ipaddr) ||
    b698:	e0bffe17 	ldw	r2,-8(fp)
    b69c:	10c0000b 	ldhu	r3,0(r2)
    b6a0:	1080008b 	ldhu	r2,2(r2)
    b6a4:	1004943a 	slli	r2,r2,16
    b6a8:	10c4b03a 	or	r2,r2,r3
    b6ac:	10000826 	beq	r2,zero,b6d0 <tcp_bind+0xd4>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
    b6b0:	e0bffc17 	ldw	r2,-16(fp)
    b6b4:	10c00017 	ldw	r3,0(r2)
    b6b8:	e0bffe17 	ldw	r2,-8(fp)
    b6bc:	1100000b 	ldhu	r4,0(r2)
    b6c0:	1080008b 	ldhu	r2,2(r2)
    b6c4:	1004943a 	slli	r2,r2,16
    b6c8:	1104b03a 	or	r2,r2,r4
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
    b6cc:	1880021e 	bne	r3,r2,b6d8 <tcp_bind+0xdc>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
    b6d0:	00bffd44 	movi	r2,-11
    b6d4:	00007b06 	br	b8c4 <tcp_bind+0x2c8>
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    b6d8:	e0bffc17 	ldw	r2,-16(fp)
    b6dc:	10800317 	ldw	r2,12(r2)
    b6e0:	e0bffc15 	stw	r2,-16(fp)
  if (port == 0) {
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
    b6e4:	e0bffc17 	ldw	r2,-16(fp)
    b6e8:	103fdf1e 	bne	r2,zero,b668 <tcp_bind+0x6c>
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
    b6ec:	d0a8d617 	ldw	r2,-23720(gp)
    b6f0:	e0bffc15 	stw	r2,-16(fp)
    b6f4:	00001f06 	br	b774 <tcp_bind+0x178>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
    b6f8:	e0bffc17 	ldw	r2,-16(fp)
    b6fc:	1080070b 	ldhu	r2,28(r2)
    b700:	10ffffcc 	andi	r3,r2,65535
    b704:	e0bfff0b 	ldhu	r2,-4(fp)
    b708:	1880171e 	bne	r3,r2,b768 <tcp_bind+0x16c>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
    b70c:	e0bffc17 	ldw	r2,-16(fp)
    b710:	10001326 	beq	r2,zero,b760 <tcp_bind+0x164>
    b714:	e0bffc17 	ldw	r2,-16(fp)
    b718:	10800017 	ldw	r2,0(r2)
    b71c:	10001026 	beq	r2,zero,b760 <tcp_bind+0x164>
    b720:	e0bffe17 	ldw	r2,-8(fp)
    b724:	10000e26 	beq	r2,zero,b760 <tcp_bind+0x164>
          ip_addr_isany(ipaddr) ||
    b728:	e0bffe17 	ldw	r2,-8(fp)
    b72c:	10c0000b 	ldhu	r3,0(r2)
    b730:	1080008b 	ldhu	r2,2(r2)
    b734:	1004943a 	slli	r2,r2,16
    b738:	10c4b03a 	or	r2,r2,r3
    b73c:	10000826 	beq	r2,zero,b760 <tcp_bind+0x164>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
    b740:	e0bffc17 	ldw	r2,-16(fp)
    b744:	10c00017 	ldw	r3,0(r2)
    b748:	e0bffe17 	ldw	r2,-8(fp)
    b74c:	1100000b 	ldhu	r4,0(r2)
    b750:	1080008b 	ldhu	r2,2(r2)
    b754:	1004943a 	slli	r2,r2,16
    b758:	1104b03a 	or	r2,r2,r4
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
    b75c:	1880021e 	bne	r3,r2,b768 <tcp_bind+0x16c>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
    b760:	00bffd44 	movi	r2,-11
    b764:	00005706 	br	b8c4 <tcp_bind+0x2c8>
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    b768:	e0bffc17 	ldw	r2,-16(fp)
    b76c:	10800317 	ldw	r2,12(r2)
    b770:	e0bffc15 	stw	r2,-16(fp)
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
    b774:	e0bffc17 	ldw	r2,-16(fp)
    b778:	103fdf1e 	bne	r2,zero,b6f8 <tcp_bind+0xfc>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    b77c:	d0a8da17 	ldw	r2,-23704(gp)
    b780:	e0bffc15 	stw	r2,-16(fp)
    b784:	00001f06 	br	b804 <tcp_bind+0x208>
    if (cpcb->local_port == port) {
    b788:	e0bffc17 	ldw	r2,-16(fp)
    b78c:	1080070b 	ldhu	r2,28(r2)
    b790:	10ffffcc 	andi	r3,r2,65535
    b794:	e0bfff0b 	ldhu	r2,-4(fp)
    b798:	1880171e 	bne	r3,r2,b7f8 <tcp_bind+0x1fc>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
    b79c:	e0bffc17 	ldw	r2,-16(fp)
    b7a0:	10001326 	beq	r2,zero,b7f0 <tcp_bind+0x1f4>
    b7a4:	e0bffc17 	ldw	r2,-16(fp)
    b7a8:	10800017 	ldw	r2,0(r2)
    b7ac:	10001026 	beq	r2,zero,b7f0 <tcp_bind+0x1f4>
    b7b0:	e0bffe17 	ldw	r2,-8(fp)
    b7b4:	10000e26 	beq	r2,zero,b7f0 <tcp_bind+0x1f4>
          ip_addr_isany(ipaddr) ||
    b7b8:	e0bffe17 	ldw	r2,-8(fp)
    b7bc:	10c0000b 	ldhu	r3,0(r2)
    b7c0:	1080008b 	ldhu	r2,2(r2)
    b7c4:	1004943a 	slli	r2,r2,16
    b7c8:	10c4b03a 	or	r2,r2,r3
    b7cc:	10000826 	beq	r2,zero,b7f0 <tcp_bind+0x1f4>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
    b7d0:	e0bffc17 	ldw	r2,-16(fp)
    b7d4:	10c00017 	ldw	r3,0(r2)
    b7d8:	e0bffe17 	ldw	r2,-8(fp)
    b7dc:	1100000b 	ldhu	r4,0(r2)
    b7e0:	1080008b 	ldhu	r2,2(r2)
    b7e4:	1004943a 	slli	r2,r2,16
    b7e8:	1104b03a 	or	r2,r2,r4
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
    b7ec:	1880021e 	bne	r3,r2,b7f8 <tcp_bind+0x1fc>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
    b7f0:	00bffd44 	movi	r2,-11
    b7f4:	00003306 	br	b8c4 <tcp_bind+0x2c8>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    b7f8:	e0bffc17 	ldw	r2,-16(fp)
    b7fc:	10800317 	ldw	r2,12(r2)
    b800:	e0bffc15 	stw	r2,-16(fp)
    b804:	e0bffc17 	ldw	r2,-16(fp)
    b808:	103fdf1e 	bne	r2,zero,b788 <tcp_bind+0x18c>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    b80c:	d0a8db17 	ldw	r2,-23700(gp)
    b810:	e0bffc15 	stw	r2,-16(fp)
    b814:	00001206 	br	b860 <tcp_bind+0x264>
    if (cpcb->local_port == port) {
    b818:	e0bffc17 	ldw	r2,-16(fp)
    b81c:	1080070b 	ldhu	r2,28(r2)
    b820:	10ffffcc 	andi	r3,r2,65535
    b824:	e0bfff0b 	ldhu	r2,-4(fp)
    b828:	18800a1e 	bne	r3,r2,b854 <tcp_bind+0x258>
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
    b82c:	e0bffc17 	ldw	r2,-16(fp)
    b830:	10c00017 	ldw	r3,0(r2)
    b834:	e0bffe17 	ldw	r2,-8(fp)
    b838:	1100000b 	ldhu	r4,0(r2)
    b83c:	1080008b 	ldhu	r2,2(r2)
    b840:	1004943a 	slli	r2,r2,16
    b844:	1104b03a 	or	r2,r2,r4
    b848:	1880021e 	bne	r3,r2,b854 <tcp_bind+0x258>
        return ERR_USE;
    b84c:	00bffd44 	movi	r2,-11
    b850:	00001c06 	br	b8c4 <tcp_bind+0x2c8>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    b854:	e0bffc17 	ldw	r2,-16(fp)
    b858:	10800317 	ldw	r2,12(r2)
    b85c:	e0bffc15 	stw	r2,-16(fp)
    b860:	e0bffc17 	ldw	r2,-16(fp)
    b864:	103fec1e 	bne	r2,zero,b818 <tcp_bind+0x21c>
        return ERR_USE;
      }
    }
  }

  if (!ip_addr_isany(ipaddr)) {
    b868:	e0bffe17 	ldw	r2,-8(fp)
    b86c:	10000c26 	beq	r2,zero,b8a0 <tcp_bind+0x2a4>
    b870:	e0bffe17 	ldw	r2,-8(fp)
    b874:	10c0000b 	ldhu	r3,0(r2)
    b878:	1080008b 	ldhu	r2,2(r2)
    b87c:	1004943a 	slli	r2,r2,16
    b880:	10c4b03a 	or	r2,r2,r3
    b884:	10000626 	beq	r2,zero,b8a0 <tcp_bind+0x2a4>
    pcb->local_ip = *ipaddr;
    b888:	e0bffd17 	ldw	r2,-12(fp)
    b88c:	e0fffe17 	ldw	r3,-8(fp)
    b890:	1900000b 	ldhu	r4,0(r3)
    b894:	1100000d 	sth	r4,0(r2)
    b898:	18c0008b 	ldhu	r3,2(r3)
    b89c:	10c0008d 	sth	r3,2(r2)
  }
  pcb->local_port = port;
    b8a0:	e0bffd17 	ldw	r2,-12(fp)
    b8a4:	e0ffff0b 	ldhu	r3,-4(fp)
    b8a8:	10c0070d 	sth	r3,28(r2)
  TCP_REG(&tcp_bound_pcbs, pcb);
    b8ac:	d0e8da17 	ldw	r3,-23704(gp)
    b8b0:	e0bffd17 	ldw	r2,-12(fp)
    b8b4:	10c00315 	stw	r3,12(r2)
    b8b8:	e0bffd17 	ldw	r2,-12(fp)
    b8bc:	d0a8da15 	stw	r2,-23704(gp)
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
    b8c0:	0005883a 	mov	r2,zero
}
    b8c4:	e037883a 	mov	sp,fp
    b8c8:	dfc00117 	ldw	ra,4(sp)
    b8cc:	df000017 	ldw	fp,0(sp)
    b8d0:	dec00204 	addi	sp,sp,8
    b8d4:	f800283a 	ret

0000b8d8 <tcp_accept_null>:
/**
 * Default accept callback if no accept callback is specified by the user.
 */
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
    b8d8:	defffc04 	addi	sp,sp,-16
    b8dc:	df000315 	stw	fp,12(sp)
    b8e0:	df000304 	addi	fp,sp,12
    b8e4:	e13ffd15 	stw	r4,-12(fp)
    b8e8:	e17ffe15 	stw	r5,-8(fp)
    b8ec:	3005883a 	mov	r2,r6
    b8f0:	e0bfff05 	stb	r2,-4(fp)
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
    b8f4:	00bffec4 	movi	r2,-5
}
    b8f8:	e037883a 	mov	sp,fp
    b8fc:	df000017 	ldw	fp,0(sp)
    b900:	dec00104 	addi	sp,sp,4
    b904:	f800283a 	ret

0000b908 <tcp_listen_with_backlog>:
 *       called like this:
 *             tpcb = tcp_listen(tpcb);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
    b908:	defffb04 	addi	sp,sp,-20
    b90c:	dfc00415 	stw	ra,16(sp)
    b910:	df000315 	stw	fp,12(sp)
    b914:	df000304 	addi	fp,sp,12
    b918:	e13ffe15 	stw	r4,-8(fp)
    b91c:	2805883a 	mov	r2,r5
    b920:	e0bfff05 	stb	r2,-4(fp)
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
    b924:	e0bffe17 	ldw	r2,-8(fp)
    b928:	10800417 	ldw	r2,16(r2)
    b92c:	10000926 	beq	r2,zero,b954 <tcp_listen_with_backlog+0x4c>
    b930:	010000f4 	movhi	r4,3
    b934:	21397304 	addi	r4,r4,-6708
    b938:	014000f4 	movhi	r5,3
    b93c:	29798c04 	addi	r5,r5,-6608
    b940:	01805cc4 	movi	r6,371
    b944:	01c000f4 	movhi	r7,3
    b948:	39f98704 	addi	r7,r7,-6628
    b94c:	00166c00 	call	166c0 <printf>
    b950:	003fff06 	br	b950 <tcp_listen_with_backlog+0x48>

  /* already listening? */
  if (pcb->state == LISTEN) {
    b954:	e0bffe17 	ldw	r2,-8(fp)
    b958:	10800417 	ldw	r2,16(r2)
    b95c:	10800058 	cmpnei	r2,r2,1
    b960:	1000021e 	bne	r2,zero,b96c <tcp_listen_with_backlog+0x64>
    return pcb;
    b964:	e0bffe17 	ldw	r2,-8(fp)
    b968:	00005306 	br	bab8 <tcp_listen_with_backlog+0x1b0>
  }
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
    b96c:	010000c4 	movi	r4,3
    b970:	0008ef00 	call	8ef0 <memp_malloc>
    b974:	e0bffd15 	stw	r2,-12(fp)
  if (lpcb == NULL) {
    b978:	e0bffd17 	ldw	r2,-12(fp)
    b97c:	1000021e 	bne	r2,zero,b988 <tcp_listen_with_backlog+0x80>
    return NULL;
    b980:	0005883a 	mov	r2,zero
    b984:	00004c06 	br	bab8 <tcp_listen_with_backlog+0x1b0>
  }
  lpcb->callback_arg = pcb->callback_arg;
    b988:	e0bffe17 	ldw	r2,-8(fp)
    b98c:	10c00617 	ldw	r3,24(r2)
    b990:	e0bffd17 	ldw	r2,-12(fp)
    b994:	10c00615 	stw	r3,24(r2)
  lpcb->local_port = pcb->local_port;
    b998:	e0bffe17 	ldw	r2,-8(fp)
    b99c:	10c0070b 	ldhu	r3,28(r2)
    b9a0:	e0bffd17 	ldw	r2,-12(fp)
    b9a4:	10c0070d 	sth	r3,28(r2)
  lpcb->state = LISTEN;
    b9a8:	e0bffd17 	ldw	r2,-12(fp)
    b9ac:	00c00044 	movi	r3,1
    b9b0:	10c00415 	stw	r3,16(r2)
  lpcb->so_options = pcb->so_options;
    b9b4:	e0bffe17 	ldw	r2,-8(fp)
    b9b8:	10c0020b 	ldhu	r3,8(r2)
    b9bc:	e0bffd17 	ldw	r2,-12(fp)
    b9c0:	10c0020d 	sth	r3,8(r2)
  lpcb->so_options |= SOF_ACCEPTCONN;
    b9c4:	e0bffd17 	ldw	r2,-12(fp)
    b9c8:	1080020b 	ldhu	r2,8(r2)
    b9cc:	10800094 	ori	r2,r2,2
    b9d0:	1007883a 	mov	r3,r2
    b9d4:	e0bffd17 	ldw	r2,-12(fp)
    b9d8:	10c0020d 	sth	r3,8(r2)
  lpcb->ttl = pcb->ttl;
    b9dc:	e0bffe17 	ldw	r2,-8(fp)
    b9e0:	10c002c3 	ldbu	r3,11(r2)
    b9e4:	e0bffd17 	ldw	r2,-12(fp)
    b9e8:	10c002c5 	stb	r3,11(r2)
  lpcb->tos = pcb->tos;
    b9ec:	e0bffe17 	ldw	r2,-8(fp)
    b9f0:	10c00283 	ldbu	r3,10(r2)
    b9f4:	e0bffd17 	ldw	r2,-12(fp)
    b9f8:	10c00285 	stb	r3,10(r2)
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
    b9fc:	e0bffe17 	ldw	r2,-8(fp)
    ba00:	10000326 	beq	r2,zero,ba10 <tcp_listen_with_backlog+0x108>
    ba04:	e0bffe17 	ldw	r2,-8(fp)
    ba08:	10800017 	ldw	r2,0(r2)
    ba0c:	00000106 	br	ba14 <tcp_listen_with_backlog+0x10c>
    ba10:	0005883a 	mov	r2,zero
    ba14:	e0fffd17 	ldw	r3,-12(fp)
    ba18:	18800015 	stw	r2,0(r3)
  TCP_RMV(&tcp_bound_pcbs, pcb);
    ba1c:	d0e8da17 	ldw	r3,-23704(gp)
    ba20:	e0bffe17 	ldw	r2,-8(fp)
    ba24:	1880041e 	bne	r3,r2,ba38 <tcp_listen_with_backlog+0x130>
    ba28:	d0a8da17 	ldw	r2,-23704(gp)
    ba2c:	10800317 	ldw	r2,12(r2)
    ba30:	d0a8da15 	stw	r2,-23704(gp)
    ba34:	00001106 	br	ba7c <tcp_listen_with_backlog+0x174>
    ba38:	d0a8da17 	ldw	r2,-23704(gp)
    ba3c:	d0a8d915 	stw	r2,-23708(gp)
    ba40:	00000c06 	br	ba74 <tcp_listen_with_backlog+0x16c>
    ba44:	d0a8d917 	ldw	r2,-23708(gp)
    ba48:	10c00317 	ldw	r3,12(r2)
    ba4c:	e0bffe17 	ldw	r2,-8(fp)
    ba50:	1880051e 	bne	r3,r2,ba68 <tcp_listen_with_backlog+0x160>
    ba54:	d0a8d917 	ldw	r2,-23708(gp)
    ba58:	e0fffe17 	ldw	r3,-8(fp)
    ba5c:	18c00317 	ldw	r3,12(r3)
    ba60:	10c00315 	stw	r3,12(r2)
    ba64:	00000506 	br	ba7c <tcp_listen_with_backlog+0x174>
    ba68:	d0a8d917 	ldw	r2,-23708(gp)
    ba6c:	10800317 	ldw	r2,12(r2)
    ba70:	d0a8d915 	stw	r2,-23708(gp)
    ba74:	d0a8d917 	ldw	r2,-23708(gp)
    ba78:	103ff21e 	bne	r2,zero,ba44 <tcp_listen_with_backlog+0x13c>
    ba7c:	e0bffe17 	ldw	r2,-8(fp)
    ba80:	10000315 	stw	zero,12(r2)
  memp_free(MEMP_TCP_PCB, pcb);
    ba84:	01000084 	movi	r4,2
    ba88:	e17ffe17 	ldw	r5,-8(fp)
    ba8c:	00090cc0 	call	90cc <memp_free>
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
    ba90:	e0bffd17 	ldw	r2,-12(fp)
    ba94:	00c00074 	movhi	r3,1
    ba98:	18ee3604 	addi	r3,r3,-18216
    ba9c:	10c00815 	stw	r3,32(r2)
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
    baa0:	d0e8d817 	ldw	r3,-23712(gp)
    baa4:	e0bffd17 	ldw	r2,-12(fp)
    baa8:	10c00315 	stw	r3,12(r2)
    baac:	e0bffd17 	ldw	r2,-12(fp)
    bab0:	d0a8d815 	stw	r2,-23712(gp)
  return (struct tcp_pcb *)lpcb;
    bab4:	e0bffd17 	ldw	r2,-12(fp)
}
    bab8:	e037883a 	mov	sp,fp
    babc:	dfc00117 	ldw	ra,4(sp)
    bac0:	df000017 	ldw	fp,0(sp)
    bac4:	dec00204 	addi	sp,sp,8
    bac8:	f800283a 	ret

0000bacc <tcp_update_rcv_ann_wnd>:
 *
 * Returns how much extra window would be advertised if we sent an
 * update now.
 */
u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
{
    bacc:	defffd04 	addi	sp,sp,-12
    bad0:	df000215 	stw	fp,8(sp)
    bad4:	df000204 	addi	fp,sp,8
    bad8:	e13fff15 	stw	r4,-4(fp)
  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
    badc:	e0bfff17 	ldw	r2,-4(fp)
    bae0:	10c00a17 	ldw	r3,40(r2)
    bae4:	e0bfff17 	ldw	r2,-4(fp)
    bae8:	10800b0b 	ldhu	r2,44(r2)
    baec:	10bfffcc 	andi	r2,r2,65535
    baf0:	1885883a 	add	r2,r3,r2
    baf4:	e0bffe15 	stw	r2,-8(fp)

  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
    baf8:	e0bfff17 	ldw	r2,-4(fp)
    bafc:	10c00c17 	ldw	r3,48(r2)
    bb00:	e0bfff17 	ldw	r2,-4(fp)
    bb04:	10800f0b 	ldhu	r2,60(r2)
    bb08:	10bfffcc 	andi	r2,r2,65535
    bb0c:	10810068 	cmpgeui	r2,r2,1025
    bb10:	1000041e 	bne	r2,zero,bb24 <tcp_update_rcv_ann_wnd+0x58>
    bb14:	e0bfff17 	ldw	r2,-4(fp)
    bb18:	10800f0b 	ldhu	r2,60(r2)
    bb1c:	10bfffcc 	andi	r2,r2,65535
    bb20:	00000106 	br	bb28 <tcp_update_rcv_ann_wnd+0x5c>
    bb24:	00810004 	movi	r2,1024
    bb28:	1885883a 	add	r2,r3,r2
    bb2c:	e0fffe17 	ldw	r3,-8(fp)
    bb30:	1885c83a 	sub	r2,r3,r2
    bb34:	10000916 	blt	r2,zero,bb5c <tcp_update_rcv_ann_wnd+0x90>
    /* we can advertise more window */
    pcb->rcv_ann_wnd = pcb->rcv_wnd;
    bb38:	e0bfff17 	ldw	r2,-4(fp)
    bb3c:	10c00b0b 	ldhu	r3,44(r2)
    bb40:	e0bfff17 	ldw	r2,-4(fp)
    bb44:	10c00b8d 	sth	r3,46(r2)
    return new_right_edge - pcb->rcv_ann_right_edge;
    bb48:	e0bfff17 	ldw	r2,-4(fp)
    bb4c:	10800c17 	ldw	r2,48(r2)
    bb50:	e0fffe17 	ldw	r3,-8(fp)
    bb54:	1885c83a 	sub	r2,r3,r2
    bb58:	00001306 	br	bba8 <tcp_update_rcv_ann_wnd+0xdc>
  } else {
    if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
    bb5c:	e0bfff17 	ldw	r2,-4(fp)
    bb60:	10c00a17 	ldw	r3,40(r2)
    bb64:	e0bfff17 	ldw	r2,-4(fp)
    bb68:	10800c17 	ldw	r2,48(r2)
    bb6c:	1885c83a 	sub	r2,r3,r2
    bb70:	0080030e 	bge	zero,r2,bb80 <tcp_update_rcv_ann_wnd+0xb4>
      /* Can happen due to other end sending out of advertised window,
       * but within actual available (but not yet advertised) window */
      pcb->rcv_ann_wnd = 0;
    bb74:	e0bfff17 	ldw	r2,-4(fp)
    bb78:	10000b8d 	sth	zero,46(r2)
    bb7c:	00000906 	br	bba4 <tcp_update_rcv_ann_wnd+0xd8>
    } else {
      /* keep the right edge of window constant */
      pcb->rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
    bb80:	e0bfff17 	ldw	r2,-4(fp)
    bb84:	10800c17 	ldw	r2,48(r2)
    bb88:	1007883a 	mov	r3,r2
    bb8c:	e0bfff17 	ldw	r2,-4(fp)
    bb90:	10800a17 	ldw	r2,40(r2)
    bb94:	1885c83a 	sub	r2,r3,r2
    bb98:	1007883a 	mov	r3,r2
    bb9c:	e0bfff17 	ldw	r2,-4(fp)
    bba0:	10c00b8d 	sth	r3,46(r2)
    }
    return 0;
    bba4:	0005883a 	mov	r2,zero
  }
}
    bba8:	e037883a 	mov	sp,fp
    bbac:	df000017 	ldw	fp,0(sp)
    bbb0:	dec00104 	addi	sp,sp,4
    bbb4:	f800283a 	ret

0000bbb8 <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
    bbb8:	defffb04 	addi	sp,sp,-20
    bbbc:	dfc00415 	stw	ra,16(sp)
    bbc0:	df000315 	stw	fp,12(sp)
    bbc4:	df000304 	addi	fp,sp,12
    bbc8:	e13ffe15 	stw	r4,-8(fp)
    bbcc:	2805883a 	mov	r2,r5
    bbd0:	e0bfff0d 	sth	r2,-4(fp)
  int wnd_inflation;

  LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
    bbd4:	e0bfff0b 	ldhu	r2,-4(fp)
    bbd8:	e0fffe17 	ldw	r3,-8(fp)
    bbdc:	18c00b0b 	ldhu	r3,44(r3)
    bbe0:	18ffffcc 	andi	r3,r3,65535
    bbe4:	013fffd4 	movui	r4,65535
    bbe8:	20c7c83a 	sub	r3,r4,r3
    bbec:	1880090e 	bge	r3,r2,bc14 <tcp_recved+0x5c>
    bbf0:	010000f4 	movhi	r4,3
    bbf4:	21397304 	addi	r4,r4,-6708
    bbf8:	014000f4 	movhi	r5,3
    bbfc:	29799504 	addi	r5,r5,-6572
    bc00:	01806ec4 	movi	r6,443
    bc04:	01c000f4 	movhi	r7,3
    bc08:	39f98704 	addi	r7,r7,-6628
    bc0c:	00166c00 	call	166c0 <printf>
    bc10:	003fff06 	br	bc10 <tcp_recved+0x58>
              len <= 0xffff - pcb->rcv_wnd );

  pcb->rcv_wnd += len;
    bc14:	e0bffe17 	ldw	r2,-8(fp)
    bc18:	10c00b0b 	ldhu	r3,44(r2)
    bc1c:	e0bfff0b 	ldhu	r2,-4(fp)
    bc20:	1885883a 	add	r2,r3,r2
    bc24:	1007883a 	mov	r3,r2
    bc28:	e0bffe17 	ldw	r2,-8(fp)
    bc2c:	10c00b0d 	sth	r3,44(r2)
  if (pcb->rcv_wnd > TCP_WND)
    bc30:	e0bffe17 	ldw	r2,-8(fp)
    bc34:	10800b0b 	ldhu	r2,44(r2)
    bc38:	10bfffcc 	andi	r2,r2,65535
    bc3c:	10820070 	cmpltui	r2,r2,2049
    bc40:	1000031e 	bne	r2,zero,bc50 <tcp_recved+0x98>
    pcb->rcv_wnd = TCP_WND;
    bc44:	e0bffe17 	ldw	r2,-8(fp)
    bc48:	00c20004 	movi	r3,2048
    bc4c:	10c00b0d 	sth	r3,44(r2)

  wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
    bc50:	e13ffe17 	ldw	r4,-8(fp)
    bc54:	000bacc0 	call	bacc <tcp_update_rcv_ann_wnd>
    bc58:	e0bffd15 	stw	r2,-12(fp)

  /* If the change in the right edge of window is significant (default
   * watermark is TCP_WND/2), then send an explicit update now.
   * Otherwise wait for a packet to be sent in the normal course of
   * events (or more window to be available later) */
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) 
    bc5c:	e0bffd17 	ldw	r2,-12(fp)
    bc60:	10808010 	cmplti	r2,r2,512
    bc64:	1000081e 	bne	r2,zero,bc88 <tcp_recved+0xd0>
    tcp_ack_now(pcb);
    bc68:	e0bffe17 	ldw	r2,-8(fp)
    bc6c:	10800983 	ldbu	r2,38(r2)
    bc70:	10800094 	ori	r2,r2,2
    bc74:	1007883a 	mov	r3,r2
    bc78:	e0bffe17 	ldw	r2,-8(fp)
    bc7c:	10c00985 	stb	r3,38(r2)
    bc80:	e13ffe17 	ldw	r4,-8(fp)
    bc84:	00122380 	call	12238 <tcp_output>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
    bc88:	e037883a 	mov	sp,fp
    bc8c:	dfc00117 	ldw	ra,4(sp)
    bc90:	df000017 	ldw	fp,0(sp)
    bc94:	dec00204 	addi	sp,sp,8
    bc98:	f800283a 	ret

0000bc9c <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
    bc9c:	defffe04 	addi	sp,sp,-8
    bca0:	df000115 	stw	fp,4(sp)
    bca4:	df000104 	addi	fp,sp,4
    bca8:	00000506 	br	bcc0 <tcp_new_port+0x24>
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    bcac:	0001883a 	nop
    bcb0:	00000306 	br	bcc0 <tcp_new_port+0x24>
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    bcb4:	0001883a 	nop
    bcb8:	00000106 	br	bcc0 <tcp_new_port+0x24>
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    bcbc:	0001883a 	nop
#define TCP_LOCAL_PORT_RANGE_END   0x7fff
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    bcc0:	d0a0060b 	ldhu	r2,-32744(gp)
    bcc4:	10800044 	addi	r2,r2,1
    bcc8:	d0a0060d 	sth	r2,-32744(gp)
    bccc:	d0a0060b 	ldhu	r2,-32744(gp)
    bcd0:	10bfffcc 	andi	r2,r2,65535
    bcd4:	10a0001c 	xori	r2,r2,32768
    bcd8:	10a00004 	addi	r2,r2,-32768
    bcdc:	1000020e 	bge	r2,zero,bce8 <tcp_new_port+0x4c>
    port = TCP_LOCAL_PORT_RANGE_START;
    bce0:	00840004 	movi	r2,4096
    bce4:	d0a0060d 	sth	r2,-32744(gp)
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    bce8:	d0a8d617 	ldw	r2,-23720(gp)
    bcec:	e0bfff15 	stw	r2,-4(fp)
    bcf0:	00000906 	br	bd18 <tcp_new_port+0x7c>
    if (pcb->local_port == port) {
    bcf4:	e0bfff17 	ldw	r2,-4(fp)
    bcf8:	10c0070b 	ldhu	r3,28(r2)
    bcfc:	d0a0060b 	ldhu	r2,-32744(gp)
    bd00:	18ffffcc 	andi	r3,r3,65535
    bd04:	10bfffcc 	andi	r2,r2,65535
    bd08:	18bfe826 	beq	r3,r2,bcac <tcp_new_port+0x10>
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    bd0c:	e0bfff17 	ldw	r2,-4(fp)
    bd10:	10800317 	ldw	r2,12(r2)
    bd14:	e0bfff15 	stw	r2,-4(fp)
    bd18:	e0bfff17 	ldw	r2,-4(fp)
    bd1c:	103ff51e 	bne	r2,zero,bcf4 <tcp_new_port+0x58>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    bd20:	d0a8db17 	ldw	r2,-23700(gp)
    bd24:	e0bfff15 	stw	r2,-4(fp)
    bd28:	00000906 	br	bd50 <tcp_new_port+0xb4>
    if (pcb->local_port == port) {
    bd2c:	e0bfff17 	ldw	r2,-4(fp)
    bd30:	10c0070b 	ldhu	r3,28(r2)
    bd34:	d0a0060b 	ldhu	r2,-32744(gp)
    bd38:	18ffffcc 	andi	r3,r3,65535
    bd3c:	10bfffcc 	andi	r2,r2,65535
    bd40:	18bfdc26 	beq	r3,r2,bcb4 <tcp_new_port+0x18>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    bd44:	e0bfff17 	ldw	r2,-4(fp)
    bd48:	10800317 	ldw	r2,12(r2)
    bd4c:	e0bfff15 	stw	r2,-4(fp)
    bd50:	e0bfff17 	ldw	r2,-4(fp)
    bd54:	103ff51e 	bne	r2,zero,bd2c <tcp_new_port+0x90>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
    bd58:	d0a8d817 	ldw	r2,-23712(gp)
    bd5c:	e0bfff15 	stw	r2,-4(fp)
    bd60:	00000906 	br	bd88 <tcp_new_port+0xec>
    if (pcb->local_port == port) {
    bd64:	e0bfff17 	ldw	r2,-4(fp)
    bd68:	10c0070b 	ldhu	r3,28(r2)
    bd6c:	d0a0060b 	ldhu	r2,-32744(gp)
    bd70:	18ffffcc 	andi	r3,r3,65535
    bd74:	10bfffcc 	andi	r2,r2,65535
    bd78:	18bfd026 	beq	r3,r2,bcbc <tcp_new_port+0x20>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
    bd7c:	e0bfff17 	ldw	r2,-4(fp)
    bd80:	10800317 	ldw	r2,12(r2)
    bd84:	e0bfff15 	stw	r2,-4(fp)
    bd88:	e0bfff17 	ldw	r2,-4(fp)
    bd8c:	103ff51e 	bne	r2,zero,bd64 <tcp_new_port+0xc8>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  return port;
    bd90:	d0a0060b 	ldhu	r2,-32744(gp)
}
    bd94:	e037883a 	mov	sp,fp
    bd98:	df000017 	ldw	fp,0(sp)
    bd9c:	dec00104 	addi	sp,sp,4
    bda0:	f800283a 	ret

0000bda4 <tcp_connect>:
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port,
      err_t (* connected)(void *arg, struct tcp_pcb *tpcb, err_t err))
{
    bda4:	defff604 	addi	sp,sp,-40
    bda8:	dfc00915 	stw	ra,36(sp)
    bdac:	df000815 	stw	fp,32(sp)
    bdb0:	df000804 	addi	fp,sp,32
    bdb4:	e13ffc15 	stw	r4,-16(fp)
    bdb8:	e17ffd15 	stw	r5,-12(fp)
    bdbc:	3005883a 	mov	r2,r6
    bdc0:	e1ffff15 	stw	r7,-4(fp)
    bdc4:	e0bffe0d 	sth	r2,-8(fp)
  err_t ret;
  u32_t iss;

  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
    bdc8:	e0bffc17 	ldw	r2,-16(fp)
    bdcc:	10800417 	ldw	r2,16(r2)
    bdd0:	10000926 	beq	r2,zero,bdf8 <tcp_connect+0x54>
    bdd4:	010000f4 	movhi	r4,3
    bdd8:	21397304 	addi	r4,r4,-6708
    bddc:	014000f4 	movhi	r5,3
    bde0:	29799e04 	addi	r5,r5,-6536
    bde4:	01808204 	movi	r6,520
    bde8:	01c000f4 	movhi	r7,3
    bdec:	39f98704 	addi	r7,r7,-6628
    bdf0:	00166c00 	call	166c0 <printf>
    bdf4:	003fff06 	br	bdf4 <tcp_connect+0x50>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
    bdf8:	e0bffd17 	ldw	r2,-12(fp)
    bdfc:	10000e26 	beq	r2,zero,be38 <tcp_connect+0x94>
    pcb->remote_ip = *ipaddr;
    be00:	e0bffc17 	ldw	r2,-16(fp)
    be04:	e0fffd17 	ldw	r3,-12(fp)
    be08:	1900000b 	ldhu	r4,0(r3)
    be0c:	1100010d 	sth	r4,4(r2)
    be10:	18c0008b 	ldhu	r3,2(r3)
    be14:	10c0018d 	sth	r3,6(r2)
  } else {
    return ERR_VAL;
  }
  pcb->remote_port = port;
    be18:	e0bffc17 	ldw	r2,-16(fp)
    be1c:	e0fffe0b 	ldhu	r3,-8(fp)
    be20:	10c0090d 	sth	r3,36(r2)
  if (pcb->local_port == 0) {
    be24:	e0bffc17 	ldw	r2,-16(fp)
    be28:	1080070b 	ldhu	r2,28(r2)
    be2c:	10bfffcc 	andi	r2,r2,65535
    be30:	10000326 	beq	r2,zero,be40 <tcp_connect+0x9c>
    be34:	00000506 	br	be4c <tcp_connect+0xa8>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
    pcb->remote_ip = *ipaddr;
  } else {
    return ERR_VAL;
    be38:	00bffdc4 	movi	r2,-9
    be3c:	00006606 	br	bfd8 <tcp_connect+0x234>
  }
  pcb->remote_port = port;
  if (pcb->local_port == 0) {
    pcb->local_port = tcp_new_port();
    be40:	000bc9c0 	call	bc9c <tcp_new_port>
    be44:	e0fffc17 	ldw	r3,-16(fp)
    be48:	1880070d 	sth	r2,28(r3)
  }
  iss = tcp_next_iss();
    be4c:	000d2200 	call	d220 <tcp_next_iss>
    be50:	e0bffa15 	stw	r2,-24(fp)
  pcb->rcv_nxt = 0;
    be54:	e0bffc17 	ldw	r2,-16(fp)
    be58:	10000a15 	stw	zero,40(r2)
  pcb->snd_nxt = iss;
    be5c:	e0bffc17 	ldw	r2,-16(fp)
    be60:	e0fffa17 	ldw	r3,-24(fp)
    be64:	10c01715 	stw	r3,92(r2)
  pcb->lastack = iss - 1;
    be68:	e0bffa17 	ldw	r2,-24(fp)
    be6c:	10ffffc4 	addi	r3,r2,-1
    be70:	e0bffc17 	ldw	r2,-16(fp)
    be74:	10c01415 	stw	r3,80(r2)
  pcb->snd_lbb = iss - 1;
    be78:	e0bffa17 	ldw	r2,-24(fp)
    be7c:	10ffffc4 	addi	r3,r2,-1
    be80:	e0bffc17 	ldw	r2,-16(fp)
    be84:	10c01b15 	stw	r3,108(r2)
  pcb->rcv_wnd = TCP_WND;
    be88:	e0bffc17 	ldw	r2,-16(fp)
    be8c:	00c20004 	movi	r3,2048
    be90:	10c00b0d 	sth	r3,44(r2)
  pcb->rcv_ann_wnd = TCP_WND;
    be94:	e0bffc17 	ldw	r2,-16(fp)
    be98:	00c20004 	movi	r3,2048
    be9c:	10c00b8d 	sth	r3,46(r2)
  pcb->rcv_ann_right_edge = pcb->rcv_nxt;
    bea0:	e0bffc17 	ldw	r2,-16(fp)
    bea4:	10c00a17 	ldw	r3,40(r2)
    bea8:	e0bffc17 	ldw	r2,-16(fp)
    beac:	10c00c15 	stw	r3,48(r2)
  pcb->snd_wnd = TCP_WND;
    beb0:	e0bffc17 	ldw	r2,-16(fp)
    beb4:	00c20004 	movi	r3,2048
    beb8:	10c0180d 	sth	r3,96(r2)
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
    bebc:	e0bffc17 	ldw	r2,-16(fp)
    bec0:	00c08604 	movi	r3,536
    bec4:	10c00f0d 	sth	r3,60(r2)
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
    bec8:	e0bffc17 	ldw	r2,-16(fp)
    becc:	10800f0b 	ldhu	r2,60(r2)
    bed0:	10bfffcc 	andi	r2,r2,65535
    bed4:	1009883a 	mov	r4,r2
    bed8:	e17ffd17 	ldw	r5,-12(fp)
    bedc:	000d2500 	call	d250 <tcp_eff_send_mss>
    bee0:	e0fffc17 	ldw	r3,-16(fp)
    bee4:	18800f0d 	sth	r2,60(r3)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
    bee8:	e0bffc17 	ldw	r2,-16(fp)
    beec:	00c00044 	movi	r3,1
    bef0:	10c0158d 	sth	r3,86(r2)
  pcb->ssthresh = pcb->mss * 10;
    bef4:	e0bffc17 	ldw	r2,-16(fp)
    bef8:	10800f0b 	ldhu	r2,60(r2)
    befc:	108002a4 	muli	r2,r2,10
    bf00:	1007883a 	mov	r3,r2
    bf04:	e0bffc17 	ldw	r2,-16(fp)
    bf08:	10c0160d 	sth	r3,88(r2)
  pcb->state = SYN_SENT;
    bf0c:	e0bffc17 	ldw	r2,-16(fp)
    bf10:	00c00084 	movi	r3,2
    bf14:	10c00415 	stw	r3,16(r2)
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
    bf18:	e0bffc17 	ldw	r2,-16(fp)
    bf1c:	e0ffff17 	ldw	r3,-4(fp)
    bf20:	10c02415 	stw	r3,144(r2)
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
    bf24:	d0e8da17 	ldw	r3,-23704(gp)
    bf28:	e0bffc17 	ldw	r2,-16(fp)
    bf2c:	1880041e 	bne	r3,r2,bf40 <tcp_connect+0x19c>
    bf30:	d0a8da17 	ldw	r2,-23704(gp)
    bf34:	10800317 	ldw	r2,12(r2)
    bf38:	d0a8da15 	stw	r2,-23704(gp)
    bf3c:	00001106 	br	bf84 <tcp_connect+0x1e0>
    bf40:	d0a8da17 	ldw	r2,-23704(gp)
    bf44:	d0a8d915 	stw	r2,-23708(gp)
    bf48:	00000c06 	br	bf7c <tcp_connect+0x1d8>
    bf4c:	d0a8d917 	ldw	r2,-23708(gp)
    bf50:	10c00317 	ldw	r3,12(r2)
    bf54:	e0bffc17 	ldw	r2,-16(fp)
    bf58:	1880051e 	bne	r3,r2,bf70 <tcp_connect+0x1cc>
    bf5c:	d0a8d917 	ldw	r2,-23708(gp)
    bf60:	e0fffc17 	ldw	r3,-16(fp)
    bf64:	18c00317 	ldw	r3,12(r3)
    bf68:	10c00315 	stw	r3,12(r2)
    bf6c:	00000506 	br	bf84 <tcp_connect+0x1e0>
    bf70:	d0a8d917 	ldw	r2,-23708(gp)
    bf74:	10800317 	ldw	r2,12(r2)
    bf78:	d0a8d915 	stw	r2,-23708(gp)
    bf7c:	d0a8d917 	ldw	r2,-23708(gp)
    bf80:	103ff21e 	bne	r2,zero,bf4c <tcp_connect+0x1a8>
    bf84:	e0bffc17 	ldw	r2,-16(fp)
    bf88:	10000315 	stw	zero,12(r2)
  TCP_REG(&tcp_active_pcbs, pcb);
    bf8c:	d0e8d617 	ldw	r3,-23720(gp)
    bf90:	e0bffc17 	ldw	r2,-16(fp)
    bf94:	10c00315 	stw	r3,12(r2)
    bf98:	e0bffc17 	ldw	r2,-16(fp)
    bf9c:	d0a8d615 	stw	r2,-23720(gp)

  snmp_inc_tcpactiveopens();
  
  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, TF_SEG_OPTS_MSS
    bfa0:	d8000015 	stw	zero,0(sp)
    bfa4:	00800044 	movi	r2,1
    bfa8:	d8800115 	stw	r2,4(sp)
    bfac:	e13ffc17 	ldw	r4,-16(fp)
    bfb0:	000b883a 	mov	r5,zero
    bfb4:	000d883a 	mov	r6,zero
    bfb8:	01c00084 	movi	r7,2
    bfbc:	00113880 	call	11388 <tcp_enqueue>
    bfc0:	e0bffb05 	stb	r2,-20(fp)
#if LWIP_TCP_TIMESTAMPS
                    | TF_SEG_OPTS_TS
#endif
                    );
  if (ret == ERR_OK) { 
    bfc4:	e0bffb07 	ldb	r2,-20(fp)
    bfc8:	1000021e 	bne	r2,zero,bfd4 <tcp_connect+0x230>
    tcp_output(pcb);
    bfcc:	e13ffc17 	ldw	r4,-16(fp)
    bfd0:	00122380 	call	12238 <tcp_output>
  }
  return ret;
    bfd4:	e0bffb03 	ldbu	r2,-20(fp)
} 
    bfd8:	e037883a 	mov	sp,fp
    bfdc:	dfc00117 	ldw	ra,4(sp)
    bfe0:	df000017 	ldw	fp,0(sp)
    bfe4:	dec00204 	addi	sp,sp,8
    bfe8:	f800283a 	ret

0000bfec <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
    bfec:	defff704 	addi	sp,sp,-36
    bff0:	dfc00815 	stw	ra,32(sp)
    bff4:	df000715 	stw	fp,28(sp)
    bff8:	df000704 	addi	fp,sp,28
  u16_t eff_wnd;
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  u8_t pcb_reset;       /* flag if a RST should be sent when removing */
  err_t err;

  err = ERR_OK;
    bffc:	e03ffd85 	stb	zero,-10(fp)

  ++tcp_ticks;
    c000:	d0a8d717 	ldw	r2,-23716(gp)
    c004:	10800044 	addi	r2,r2,1
    c008:	d0a8d715 	stw	r2,-23716(gp)

  /* Steps through all of the active PCBs. */
  prev = NULL;
    c00c:	e03ffc15 	stw	zero,-16(fp)
  pcb = tcp_active_pcbs;
    c010:	d0a8d617 	ldw	r2,-23720(gp)
    c014:	e0bffb15 	stw	r2,-20(fp)
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
    c018:	0001a306 	br	c6a8 <tcp_slowtmr+0x6bc>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    c01c:	e0bffb17 	ldw	r2,-20(fp)
    c020:	10800417 	ldw	r2,16(r2)
    c024:	1000091e 	bne	r2,zero,c04c <tcp_slowtmr+0x60>
    c028:	010000f4 	movhi	r4,3
    c02c:	21397304 	addi	r4,r4,-6708
    c030:	014000f4 	movhi	r5,3
    c034:	2979ab04 	addi	r5,r5,-6484
    c038:	01809544 	movi	r6,597
    c03c:	01c000f4 	movhi	r7,3
    c040:	39f98704 	addi	r7,r7,-6628
    c044:	00166c00 	call	166c0 <printf>
    c048:	003fff06 	br	c048 <tcp_slowtmr+0x5c>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    c04c:	e0bffb17 	ldw	r2,-20(fp)
    c050:	10800417 	ldw	r2,16(r2)
    c054:	10800058 	cmpnei	r2,r2,1
    c058:	1000091e 	bne	r2,zero,c080 <tcp_slowtmr+0x94>
    c05c:	010000f4 	movhi	r4,3
    c060:	21397304 	addi	r4,r4,-6708
    c064:	014000f4 	movhi	r5,3
    c068:	2979b604 	addi	r5,r5,-6440
    c06c:	01809584 	movi	r6,598
    c070:	01c000f4 	movhi	r7,3
    c074:	39f98704 	addi	r7,r7,-6628
    c078:	00166c00 	call	166c0 <printf>
    c07c:	003fff06 	br	c07c <tcp_slowtmr+0x90>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
    c080:	e0bffb17 	ldw	r2,-20(fp)
    c084:	10800417 	ldw	r2,16(r2)
    c088:	10800298 	cmpnei	r2,r2,10
    c08c:	1000091e 	bne	r2,zero,c0b4 <tcp_slowtmr+0xc8>
    c090:	010000f4 	movhi	r4,3
    c094:	21397304 	addi	r4,r4,-6708
    c098:	014000f4 	movhi	r5,3
    c09c:	2979c104 	addi	r5,r5,-6396
    c0a0:	018095c4 	movi	r6,599
    c0a4:	01c000f4 	movhi	r7,3
    c0a8:	39f98704 	addi	r7,r7,-6628
    c0ac:	00166c00 	call	166c0 <printf>
    c0b0:	003fff06 	br	c0b0 <tcp_slowtmr+0xc4>

    pcb_remove = 0;
    c0b4:	e03ffd05 	stb	zero,-12(fp)
    pcb_reset = 0;
    c0b8:	e03ffd45 	stb	zero,-11(fp)

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
    c0bc:	e0bffb17 	ldw	r2,-20(fp)
    c0c0:	10800417 	ldw	r2,16(r2)
    c0c4:	10800098 	cmpnei	r2,r2,2
    c0c8:	1000091e 	bne	r2,zero,c0f0 <tcp_slowtmr+0x104>
    c0cc:	e0bffb17 	ldw	r2,-20(fp)
    c0d0:	10801383 	ldbu	r2,78(r2)
    c0d4:	10803fcc 	andi	r2,r2,255
    c0d8:	10800198 	cmpnei	r2,r2,6
    c0dc:	1000041e 	bne	r2,zero,c0f0 <tcp_slowtmr+0x104>
      ++pcb_remove;
    c0e0:	e0bffd03 	ldbu	r2,-12(fp)
    c0e4:	10800044 	addi	r2,r2,1
    c0e8:	e0bffd05 	stb	r2,-12(fp)
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    c0ec:	00008906 	br	c314 <tcp_slowtmr+0x328>
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
    c0f0:	e0bffb17 	ldw	r2,-20(fp)
    c0f4:	10801383 	ldbu	r2,78(r2)
    c0f8:	10803fcc 	andi	r2,r2,255
    c0fc:	10800318 	cmpnei	r2,r2,12
    c100:	1000041e 	bne	r2,zero,c114 <tcp_slowtmr+0x128>
      ++pcb_remove;
    c104:	e0bffd03 	ldbu	r2,-12(fp)
    c108:	10800044 	addi	r2,r2,1
    c10c:	e0bffd05 	stb	r2,-12(fp)
    c110:	00008006 	br	c314 <tcp_slowtmr+0x328>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
    c114:	e0bffb17 	ldw	r2,-20(fp)
    c118:	10802903 	ldbu	r2,164(r2)
    c11c:	10803fcc 	andi	r2,r2,255
    c120:	10002026 	beq	r2,zero,c1a4 <tcp_slowtmr+0x1b8>
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
    c124:	e0bffb17 	ldw	r2,-20(fp)
    c128:	10802817 	ldw	r2,160(r2)
    c12c:	10c00044 	addi	r3,r2,1
    c130:	e0bffb17 	ldw	r2,-20(fp)
    c134:	10c02815 	stw	r3,160(r2)
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
    c138:	e0bffb17 	ldw	r2,-20(fp)
    c13c:	10c02817 	ldw	r3,160(r2)
    c140:	e0bffb17 	ldw	r2,-20(fp)
    c144:	10802903 	ldbu	r2,164(r2)
    c148:	10803fcc 	andi	r2,r2,255
    c14c:	113fffc4 	addi	r4,r2,-1
    c150:	d0a00304 	addi	r2,gp,-32756
    c154:	2085883a 	add	r2,r4,r2
    c158:	10800003 	ldbu	r2,0(r2)
    c15c:	10803fcc 	andi	r2,r2,255
    c160:	18806c36 	bltu	r3,r2,c314 <tcp_slowtmr+0x328>
          pcb->persist_cnt = 0;
    c164:	e0bffb17 	ldw	r2,-20(fp)
    c168:	10002815 	stw	zero,160(r2)
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
    c16c:	e0bffb17 	ldw	r2,-20(fp)
    c170:	10802903 	ldbu	r2,164(r2)
    c174:	10803fcc 	andi	r2,r2,255
    c178:	108001e8 	cmpgeui	r2,r2,7
    c17c:	1000061e 	bne	r2,zero,c198 <tcp_slowtmr+0x1ac>
            pcb->persist_backoff++;
    c180:	e0bffb17 	ldw	r2,-20(fp)
    c184:	10802903 	ldbu	r2,164(r2)
    c188:	10800044 	addi	r2,r2,1
    c18c:	1007883a 	mov	r3,r2
    c190:	e0bffb17 	ldw	r2,-20(fp)
    c194:	10c02905 	stb	r3,164(r2)
          }
          tcp_zero_window_probe(pcb);
    c198:	e13ffb17 	ldw	r4,-20(fp)
    c19c:	00136300 	call	13630 <tcp_zero_window_probe>
    c1a0:	00005c06 	br	c314 <tcp_slowtmr+0x328>
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0)
    c1a4:	e0bffb17 	ldw	r2,-20(fp)
    c1a8:	10800e8b 	ldhu	r2,58(r2)
    c1ac:	10bfffcc 	andi	r2,r2,65535
    c1b0:	10a0001c 	xori	r2,r2,32768
    c1b4:	10a00004 	addi	r2,r2,-32768
    c1b8:	10000616 	blt	r2,zero,c1d4 <tcp_slowtmr+0x1e8>
          ++pcb->rtime;
    c1bc:	e0bffb17 	ldw	r2,-20(fp)
    c1c0:	10800e8b 	ldhu	r2,58(r2)
    c1c4:	10800044 	addi	r2,r2,1
    c1c8:	1007883a 	mov	r3,r2
    c1cc:	e0bffb17 	ldw	r2,-20(fp)
    c1d0:	10c00e8d 	sth	r3,58(r2)

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
    c1d4:	e0bffb17 	ldw	r2,-20(fp)
    c1d8:	10801f17 	ldw	r2,124(r2)
    c1dc:	10004d26 	beq	r2,zero,c314 <tcp_slowtmr+0x328>
    c1e0:	e0bffb17 	ldw	r2,-20(fp)
    c1e4:	10c00e8b 	ldhu	r3,58(r2)
    c1e8:	e0bffb17 	ldw	r2,-20(fp)
    c1ec:	1080130b 	ldhu	r2,76(r2)
    c1f0:	18ffffcc 	andi	r3,r3,65535
    c1f4:	18e0001c 	xori	r3,r3,32768
    c1f8:	18e00004 	addi	r3,r3,-32768
    c1fc:	10bfffcc 	andi	r2,r2,65535
    c200:	10a0001c 	xori	r2,r2,32768
    c204:	10a00004 	addi	r2,r2,-32768
    c208:	18804216 	blt	r3,r2,c314 <tcp_slowtmr+0x328>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
    c20c:	e0bffb17 	ldw	r2,-20(fp)
    c210:	10800417 	ldw	r2,16(r2)
    c214:	108000a0 	cmpeqi	r2,r2,2
    c218:	10001b1e 	bne	r2,zero,c288 <tcp_slowtmr+0x29c>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
    c21c:	e0bffb17 	ldw	r2,-20(fp)
    c220:	1080120b 	ldhu	r2,72(r2)
    c224:	10bfffcc 	andi	r2,r2,65535
    c228:	10a0001c 	xori	r2,r2,32768
    c22c:	10a00004 	addi	r2,r2,-32768
    c230:	1005d0fa 	srai	r2,r2,3
    c234:	10ffffcc 	andi	r3,r2,65535
    c238:	18e0001c 	xori	r3,r3,32768
    c23c:	18e00004 	addi	r3,r3,-32768
    c240:	e0bffb17 	ldw	r2,-20(fp)
    c244:	1080128b 	ldhu	r2,74(r2)
    c248:	10bfffcc 	andi	r2,r2,65535
    c24c:	10a0001c 	xori	r2,r2,32768
    c250:	10a00004 	addi	r2,r2,-32768
    c254:	1887883a 	add	r3,r3,r2
    c258:	e0bffb17 	ldw	r2,-20(fp)
    c25c:	10801383 	ldbu	r2,78(r2)
    c260:	10803fcc 	andi	r2,r2,255
    c264:	010000f4 	movhi	r4,3
    c268:	21396f84 	addi	r4,r4,-6722
    c26c:	2085883a 	add	r2,r4,r2
    c270:	10800003 	ldbu	r2,0(r2)
    c274:	10803fcc 	andi	r2,r2,255
    c278:	1884983a 	sll	r2,r3,r2
    c27c:	1007883a 	mov	r3,r2
    c280:	e0bffb17 	ldw	r2,-20(fp)
    c284:	10c0130d 	sth	r3,76(r2)
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
    c288:	e0bffb17 	ldw	r2,-20(fp)
    c28c:	10000e8d 	sth	zero,58(r2)

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
    c290:	e0bffb17 	ldw	r2,-20(fp)
    c294:	1080180b 	ldhu	r2,96(r2)
    c298:	e0fffb17 	ldw	r3,-20(fp)
    c29c:	18c0158b 	ldhu	r3,86(r3)
    c2a0:	113fffcc 	andi	r4,r2,65535
    c2a4:	197fffcc 	andi	r5,r3,65535
    c2a8:	2900012e 	bgeu	r5,r4,c2b0 <tcp_slowtmr+0x2c4>
    c2ac:	1805883a 	mov	r2,r3
    c2b0:	e0bffe0d 	sth	r2,-8(fp)
          pcb->ssthresh = eff_wnd >> 1;
    c2b4:	e0bffe0b 	ldhu	r2,-8(fp)
    c2b8:	1004d07a 	srli	r2,r2,1
    c2bc:	1007883a 	mov	r3,r2
    c2c0:	e0bffb17 	ldw	r2,-20(fp)
    c2c4:	10c0160d 	sth	r3,88(r2)
          if (pcb->ssthresh < pcb->mss) {
    c2c8:	e0bffb17 	ldw	r2,-20(fp)
    c2cc:	10c0160b 	ldhu	r3,88(r2)
    c2d0:	e0bffb17 	ldw	r2,-20(fp)
    c2d4:	10800f0b 	ldhu	r2,60(r2)
    c2d8:	18ffffcc 	andi	r3,r3,65535
    c2dc:	10bfffcc 	andi	r2,r2,65535
    c2e0:	1880062e 	bgeu	r3,r2,c2fc <tcp_slowtmr+0x310>
            pcb->ssthresh = pcb->mss * 2;
    c2e4:	e0bffb17 	ldw	r2,-20(fp)
    c2e8:	10800f0b 	ldhu	r2,60(r2)
    c2ec:	1085883a 	add	r2,r2,r2
    c2f0:	1007883a 	mov	r3,r2
    c2f4:	e0bffb17 	ldw	r2,-20(fp)
    c2f8:	10c0160d 	sth	r3,88(r2)
          }
          pcb->cwnd = pcb->mss;
    c2fc:	e0bffb17 	ldw	r2,-20(fp)
    c300:	10c00f0b 	ldhu	r3,60(r2)
    c304:	e0bffb17 	ldw	r2,-20(fp)
    c308:	10c0158d 	sth	r3,86(r2)
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
    c30c:	e13ffb17 	ldw	r4,-20(fp)
    c310:	00131000 	call	13100 <tcp_rexmit_rto>
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
    c314:	e0bffb17 	ldw	r2,-20(fp)
    c318:	10800417 	ldw	r2,16(r2)
    c31c:	10800198 	cmpnei	r2,r2,6
    c320:	1000091e 	bne	r2,zero,c348 <tcp_slowtmr+0x35c>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
    c324:	d0e8d717 	ldw	r3,-23716(gp)
    c328:	e0bffb17 	ldw	r2,-20(fp)
    c32c:	10800d17 	ldw	r2,52(r2)
    c330:	1885c83a 	sub	r2,r3,r2
    c334:	10800a70 	cmpltui	r2,r2,41
    c338:	1000031e 	bne	r2,zero,c348 <tcp_slowtmr+0x35c>
          TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
    c33c:	e0bffd03 	ldbu	r2,-12(fp)
    c340:	10800044 	addi	r2,r2,1
    c344:	e0bffd05 	stb	r2,-12(fp)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
    c348:	e0bffb17 	ldw	r2,-20(fp)
    c34c:	1080020b 	ldhu	r2,8(r2)
    c350:	10bfffcc 	andi	r2,r2,65535
    c354:	1080020c 	andi	r2,r2,8
    c358:	10003326 	beq	r2,zero,c428 <tcp_slowtmr+0x43c>
       ((pcb->state == ESTABLISHED) || 
    c35c:	e0bffb17 	ldw	r2,-20(fp)
    c360:	10800417 	ldw	r2,16(r2)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
    c364:	10800120 	cmpeqi	r2,r2,4
    c368:	1000041e 	bne	r2,zero,c37c <tcp_slowtmr+0x390>
       ((pcb->state == ESTABLISHED) || 
        (pcb->state == CLOSE_WAIT))) {
    c36c:	e0bffb17 	ldw	r2,-20(fp)
    c370:	10800417 	ldw	r2,16(r2)
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
       ((pcb->state == ESTABLISHED) || 
    c374:	108001d8 	cmpnei	r2,r2,7
    c378:	10002b1e 	bne	r2,zero,c428 <tcp_slowtmr+0x43c>
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
    c37c:	d0e8d717 	ldw	r3,-23716(gp)
    c380:	e0bffb17 	ldw	r2,-20(fp)
    c384:	10800d17 	ldw	r2,52(r2)
    c388:	1885c83a 	sub	r2,r3,r2
         (pcb->keep_idle + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)
    c38c:	e0fffb17 	ldw	r3,-20(fp)
    c390:	19002717 	ldw	r4,156(r3)
    c394:	00c002b4 	movhi	r3,10
    c398:	18d32e04 	addi	r3,r3,19640
    c39c:	20c9883a 	add	r4,r4,r3
    c3a0:	00c07d04 	movi	r3,500
    c3a4:	20c7203a 	divu	r3,r4,r3
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
    c3a8:	1880072e 	bgeu	r3,r2,c3c8 <tcp_slowtmr+0x3dc>
      {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
                                ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                                ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));
        
        ++pcb_remove;
    c3ac:	e0bffd03 	ldbu	r2,-12(fp)
    c3b0:	10800044 	addi	r2,r2,1
    c3b4:	e0bffd05 	stb	r2,-12(fp)
        ++pcb_reset;
    c3b8:	e0bffd43 	ldbu	r2,-11(fp)
    c3bc:	10800044 	addi	r2,r2,1
    c3c0:	e0bffd45 	stb	r2,-11(fp)
    c3c4:	00001806 	br	c428 <tcp_slowtmr+0x43c>
#if LWIP_TCP_KEEPALIVE
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
    c3c8:	d0e8d717 	ldw	r3,-23716(gp)
    c3cc:	e0bffb17 	ldw	r2,-20(fp)
    c3d0:	10800d17 	ldw	r2,52(r2)
    c3d4:	1885c83a 	sub	r2,r3,r2
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
    c3d8:	e0fffb17 	ldw	r3,-20(fp)
    c3dc:	19002717 	ldw	r4,156(r3)
    c3e0:	e0fffb17 	ldw	r3,-20(fp)
    c3e4:	18c02943 	ldbu	r3,165(r3)
    c3e8:	19403fcc 	andi	r5,r3,255
    c3ec:	00c00074 	movhi	r3,1
    c3f0:	18c93e04 	addi	r3,r3,9464
    c3f4:	28c7383a 	mul	r3,r5,r3
    c3f8:	20c9883a 	add	r4,r4,r3
              / TCP_SLOW_INTERVAL)
    c3fc:	00c07d04 	movi	r3,500
    c400:	20c7203a 	divu	r3,r4,r3
#if LWIP_TCP_KEEPALIVE
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
    c404:	1880082e 	bgeu	r3,r2,c428 <tcp_slowtmr+0x43c>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
              / TCP_SLOW_INTERVAL)
#endif /* LWIP_TCP_KEEPALIVE */
      {
        tcp_keepalive(pcb);
    c408:	e13ffb17 	ldw	r4,-20(fp)
    c40c:	00134ac0 	call	134ac <tcp_keepalive>
        pcb->keep_cnt_sent++;
    c410:	e0bffb17 	ldw	r2,-20(fp)
    c414:	10802943 	ldbu	r2,165(r2)
    c418:	10800044 	addi	r2,r2,1
    c41c:	1007883a 	mov	r3,r2
    c420:	e0bffb17 	ldw	r2,-20(fp)
    c424:	10c02945 	stb	r3,165(r2)

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
    c428:	e0bffb17 	ldw	r2,-20(fp)
    c42c:	10802017 	ldw	r2,128(r2)
    c430:	10001126 	beq	r2,zero,c478 <tcp_slowtmr+0x48c>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
    c434:	d0e8d717 	ldw	r3,-23716(gp)
    c438:	e0bffb17 	ldw	r2,-20(fp)
    c43c:	10800d17 	ldw	r2,52(r2)
    c440:	1887c83a 	sub	r3,r3,r2
    c444:	e0bffb17 	ldw	r2,-20(fp)
    c448:	1080130b 	ldhu	r2,76(r2)
    c44c:	10bfffcc 	andi	r2,r2,65535
    c450:	10a0001c 	xori	r2,r2,32768
    c454:	10a00004 	addi	r2,r2,-32768
    c458:	108001a4 	muli	r2,r2,6

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
    c45c:	18800636 	bltu	r3,r2,c478 <tcp_slowtmr+0x48c>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
      tcp_segs_free(pcb->ooseq);
    c460:	e0bffb17 	ldw	r2,-20(fp)
    c464:	10802017 	ldw	r2,128(r2)
    c468:	1009883a 	mov	r4,r2
    c46c:	000c9180 	call	c918 <tcp_segs_free>
      pcb->ooseq = NULL;
    c470:	e0bffb17 	ldw	r2,-20(fp)
    c474:	10002015 	stw	zero,128(r2)
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
    c478:	e0bffb17 	ldw	r2,-20(fp)
    c47c:	10800417 	ldw	r2,16(r2)
    c480:	108000d8 	cmpnei	r2,r2,3
    c484:	1000091e 	bne	r2,zero,c4ac <tcp_slowtmr+0x4c0>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
    c488:	d0e8d717 	ldw	r3,-23716(gp)
    c48c:	e0bffb17 	ldw	r2,-20(fp)
    c490:	10800d17 	ldw	r2,52(r2)
    c494:	1885c83a 	sub	r2,r3,r2
    c498:	10800a70 	cmpltui	r2,r2,41
    c49c:	1000031e 	bne	r2,zero,c4ac <tcp_slowtmr+0x4c0>
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
    c4a0:	e0bffd03 	ldbu	r2,-12(fp)
    c4a4:	10800044 	addi	r2,r2,1
    c4a8:	e0bffd05 	stb	r2,-12(fp)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
    c4ac:	e0bffb17 	ldw	r2,-20(fp)
    c4b0:	10800417 	ldw	r2,16(r2)
    c4b4:	10800258 	cmpnei	r2,r2,9
    c4b8:	1000091e 	bne	r2,zero,c4e0 <tcp_slowtmr+0x4f4>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
    c4bc:	d0e8d717 	ldw	r3,-23716(gp)
    c4c0:	e0bffb17 	ldw	r2,-20(fp)
    c4c4:	10800d17 	ldw	r2,52(r2)
    c4c8:	1885c83a 	sub	r2,r3,r2
    c4cc:	10803c70 	cmpltui	r2,r2,241
    c4d0:	1000031e 	bne	r2,zero,c4e0 <tcp_slowtmr+0x4f4>
        ++pcb_remove;
    c4d4:	e0bffd03 	ldbu	r2,-12(fp)
    c4d8:	10800044 	addi	r2,r2,1
    c4dc:	e0bffd05 	stb	r2,-12(fp)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
    c4e0:	e0bffd03 	ldbu	r2,-12(fp)
    c4e4:	10004b26 	beq	r2,zero,c614 <tcp_slowtmr+0x628>
      tcp_pcb_purge(pcb);      
    c4e8:	e13ffb17 	ldw	r4,-20(fp)
    c4ec:	000cfa40 	call	cfa4 <tcp_pcb_purge>
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
    c4f0:	e0bffc17 	ldw	r2,-16(fp)
    c4f4:	10001126 	beq	r2,zero,c53c <tcp_slowtmr+0x550>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
    c4f8:	d0a8d617 	ldw	r2,-23720(gp)
    c4fc:	e0fffb17 	ldw	r3,-20(fp)
    c500:	1880091e 	bne	r3,r2,c528 <tcp_slowtmr+0x53c>
    c504:	010000f4 	movhi	r4,3
    c508:	21397304 	addi	r4,r4,-6708
    c50c:	014000f4 	movhi	r5,3
    c510:	2979cd04 	addi	r5,r5,-6348
    c514:	0180b884 	movi	r6,738
    c518:	01c000f4 	movhi	r7,3
    c51c:	39f98704 	addi	r7,r7,-6628
    c520:	00166c00 	call	166c0 <printf>
    c524:	003fff06 	br	c524 <tcp_slowtmr+0x538>
        prev->next = pcb->next;
    c528:	e0bffb17 	ldw	r2,-20(fp)
    c52c:	10c00317 	ldw	r3,12(r2)
    c530:	e0bffc17 	ldw	r2,-16(fp)
    c534:	10c00315 	stw	r3,12(r2)
    c538:	00000f06 	br	c578 <tcp_slowtmr+0x58c>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
    c53c:	d0e8d617 	ldw	r3,-23720(gp)
    c540:	e0bffb17 	ldw	r2,-20(fp)
    c544:	18800926 	beq	r3,r2,c56c <tcp_slowtmr+0x580>
    c548:	010000f4 	movhi	r4,3
    c54c:	21397304 	addi	r4,r4,-6708
    c550:	014000f4 	movhi	r5,3
    c554:	2979d804 	addi	r5,r5,-6304
    c558:	0180b984 	movi	r6,742
    c55c:	01c000f4 	movhi	r7,3
    c560:	39f98704 	addi	r7,r7,-6628
    c564:	00166c00 	call	166c0 <printf>
    c568:	003fff06 	br	c568 <tcp_slowtmr+0x57c>
        tcp_active_pcbs = pcb->next;
    c56c:	e0bffb17 	ldw	r2,-20(fp)
    c570:	10800317 	ldw	r2,12(r2)
    c574:	d0a8d615 	stw	r2,-23720(gp)
      }

      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
    c578:	e0bffb17 	ldw	r2,-20(fp)
    c57c:	10802617 	ldw	r2,152(r2)
    c580:	10000726 	beq	r2,zero,c5a0 <tcp_slowtmr+0x5b4>
    c584:	e0bffb17 	ldw	r2,-20(fp)
    c588:	10c02617 	ldw	r3,152(r2)
    c58c:	e0bffb17 	ldw	r2,-20(fp)
    c590:	10800617 	ldw	r2,24(r2)
    c594:	1009883a 	mov	r4,r2
    c598:	017ffec4 	movi	r5,-5
    c59c:	183ee83a 	callr	r3
      if (pcb_reset) {
    c5a0:	e0bffd43 	ldbu	r2,-11(fp)
    c5a4:	10001226 	beq	r2,zero,c5f0 <tcp_slowtmr+0x604>
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
    c5a8:	e0bffb17 	ldw	r2,-20(fp)
    c5ac:	11001717 	ldw	r4,92(r2)
    c5b0:	e0bffb17 	ldw	r2,-20(fp)
    c5b4:	11400a17 	ldw	r5,40(r2)
    c5b8:	e0fffb17 	ldw	r3,-20(fp)
    c5bc:	e0bffb17 	ldw	r2,-20(fp)
    c5c0:	10800104 	addi	r2,r2,4
          pcb->local_port, pcb->remote_port);
    c5c4:	e1bffb17 	ldw	r6,-20(fp)
    c5c8:	3180070b 	ldhu	r6,28(r6)
        tcp_active_pcbs = pcb->next;
      }

      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
      if (pcb_reset) {
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
    c5cc:	31ffffcc 	andi	r7,r6,65535
          pcb->local_port, pcb->remote_port);
    c5d0:	e1bffb17 	ldw	r6,-20(fp)
    c5d4:	3180090b 	ldhu	r6,36(r6)
        tcp_active_pcbs = pcb->next;
      }

      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
      if (pcb_reset) {
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
    c5d8:	31bfffcc 	andi	r6,r6,65535
    c5dc:	d9c00015 	stw	r7,0(sp)
    c5e0:	d9800115 	stw	r6,4(sp)
    c5e4:	180d883a 	mov	r6,r3
    c5e8:	100f883a 	mov	r7,r2
    c5ec:	0012e5c0 	call	12e5c <tcp_rst>
          pcb->local_port, pcb->remote_port);
      }

      pcb2 = pcb->next;
    c5f0:	e0bffb17 	ldw	r2,-20(fp)
    c5f4:	10800317 	ldw	r2,12(r2)
    c5f8:	e0bfff15 	stw	r2,-4(fp)
      memp_free(MEMP_TCP_PCB, pcb);
    c5fc:	01000084 	movi	r4,2
    c600:	e17ffb17 	ldw	r5,-20(fp)
    c604:	00090cc0 	call	90cc <memp_free>
      pcb = pcb2;
    c608:	e0bfff17 	ldw	r2,-4(fp)
    c60c:	e0bffb15 	stw	r2,-20(fp)
    c610:	00002506 	br	c6a8 <tcp_slowtmr+0x6bc>
    } else {

      /* We check if we should poll the connection. */
      ++pcb->polltmr;
    c614:	e0bffb17 	ldw	r2,-20(fp)
    c618:	10800e03 	ldbu	r2,56(r2)
    c61c:	10800044 	addi	r2,r2,1
    c620:	1007883a 	mov	r3,r2
    c624:	e0bffb17 	ldw	r2,-20(fp)
    c628:	10c00e05 	stb	r3,56(r2)
      if (pcb->polltmr >= pcb->pollinterval) {
    c62c:	e0bffb17 	ldw	r2,-20(fp)
    c630:	10c00e03 	ldbu	r3,56(r2)
    c634:	e0bffb17 	ldw	r2,-20(fp)
    c638:	10800e43 	ldbu	r2,57(r2)
    c63c:	18c03fcc 	andi	r3,r3,255
    c640:	10803fcc 	andi	r2,r2,255
    c644:	18801336 	bltu	r3,r2,c694 <tcp_slowtmr+0x6a8>
        pcb->polltmr = 0;
    c648:	e0bffb17 	ldw	r2,-20(fp)
    c64c:	10000e05 	stb	zero,56(r2)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        TCP_EVENT_POLL(pcb, err);
    c650:	e0bffb17 	ldw	r2,-20(fp)
    c654:	10802517 	ldw	r2,148(r2)
    c658:	10000926 	beq	r2,zero,c680 <tcp_slowtmr+0x694>
    c65c:	e0bffb17 	ldw	r2,-20(fp)
    c660:	10c02517 	ldw	r3,148(r2)
    c664:	e0bffb17 	ldw	r2,-20(fp)
    c668:	10800617 	ldw	r2,24(r2)
    c66c:	1009883a 	mov	r4,r2
    c670:	e17ffb17 	ldw	r5,-20(fp)
    c674:	183ee83a 	callr	r3
    c678:	e0bffd85 	stb	r2,-10(fp)
    c67c:	00000106 	br	c684 <tcp_slowtmr+0x698>
    c680:	e03ffd85 	stb	zero,-10(fp)
        if (err == ERR_OK) {
    c684:	e0bffd87 	ldb	r2,-10(fp)
    c688:	1000021e 	bne	r2,zero,c694 <tcp_slowtmr+0x6a8>
          tcp_output(pcb);
    c68c:	e13ffb17 	ldw	r4,-20(fp)
    c690:	00122380 	call	12238 <tcp_output>
        }
      }
      
      prev = pcb;
    c694:	e0bffb17 	ldw	r2,-20(fp)
    c698:	e0bffc15 	stw	r2,-16(fp)
      pcb = pcb->next;
    c69c:	e0bffb17 	ldw	r2,-20(fp)
    c6a0:	10800317 	ldw	r2,12(r2)
    c6a4:	e0bffb15 	stw	r2,-20(fp)
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
    c6a8:	e0bffb17 	ldw	r2,-20(fp)
    c6ac:	103e5b1e 	bne	r2,zero,c01c <tcp_slowtmr+0x30>
    }
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
    c6b0:	e03ffc15 	stw	zero,-16(fp)
  pcb = tcp_tw_pcbs;
    c6b4:	d0a8db17 	ldw	r2,-23700(gp)
    c6b8:	e0bffb15 	stw	r2,-20(fp)
  while (pcb != NULL) {
    c6bc:	00004b06 	br	c7ec <tcp_slowtmr+0x800>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
    c6c0:	e0bffb17 	ldw	r2,-20(fp)
    c6c4:	10800417 	ldw	r2,16(r2)
    c6c8:	108002a0 	cmpeqi	r2,r2,10
    c6cc:	1000091e 	bne	r2,zero,c6f4 <tcp_slowtmr+0x708>
    c6d0:	010000f4 	movhi	r4,3
    c6d4:	21397304 	addi	r4,r4,-6708
    c6d8:	014000f4 	movhi	r5,3
    c6dc:	2979e304 	addi	r5,r5,-6260
    c6e0:	0180c284 	movi	r6,778
    c6e4:	01c000f4 	movhi	r7,3
    c6e8:	39f98704 	addi	r7,r7,-6628
    c6ec:	00166c00 	call	166c0 <printf>
    c6f0:	003fff06 	br	c6f0 <tcp_slowtmr+0x704>
    pcb_remove = 0;
    c6f4:	e03ffd05 	stb	zero,-12(fp)

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
    c6f8:	d0e8d717 	ldw	r3,-23716(gp)
    c6fc:	e0bffb17 	ldw	r2,-20(fp)
    c700:	10800d17 	ldw	r2,52(r2)
    c704:	1885c83a 	sub	r2,r3,r2
    c708:	10803c70 	cmpltui	r2,r2,241
    c70c:	1000031e 	bne	r2,zero,c71c <tcp_slowtmr+0x730>
      ++pcb_remove;
    c710:	e0bffd03 	ldbu	r2,-12(fp)
    c714:	10800044 	addi	r2,r2,1
    c718:	e0bffd05 	stb	r2,-12(fp)
    }
    


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
    c71c:	e0bffd03 	ldbu	r2,-12(fp)
    c720:	10002d26 	beq	r2,zero,c7d8 <tcp_slowtmr+0x7ec>
      tcp_pcb_purge(pcb);      
    c724:	e13ffb17 	ldw	r4,-20(fp)
    c728:	000cfa40 	call	cfa4 <tcp_pcb_purge>
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
    c72c:	e0bffc17 	ldw	r2,-16(fp)
    c730:	10001126 	beq	r2,zero,c778 <tcp_slowtmr+0x78c>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
    c734:	d0a8db17 	ldw	r2,-23700(gp)
    c738:	e0fffb17 	ldw	r3,-20(fp)
    c73c:	1880091e 	bne	r3,r2,c764 <tcp_slowtmr+0x778>
    c740:	010000f4 	movhi	r4,3
    c744:	21397304 	addi	r4,r4,-6708
    c748:	014000f4 	movhi	r5,3
    c74c:	2979ef04 	addi	r5,r5,-6212
    c750:	0180c644 	movi	r6,793
    c754:	01c000f4 	movhi	r7,3
    c758:	39f98704 	addi	r7,r7,-6628
    c75c:	00166c00 	call	166c0 <printf>
    c760:	003fff06 	br	c760 <tcp_slowtmr+0x774>
        prev->next = pcb->next;
    c764:	e0bffb17 	ldw	r2,-20(fp)
    c768:	10c00317 	ldw	r3,12(r2)
    c76c:	e0bffc17 	ldw	r2,-16(fp)
    c770:	10c00315 	stw	r3,12(r2)
    c774:	00000f06 	br	c7b4 <tcp_slowtmr+0x7c8>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
    c778:	d0e8db17 	ldw	r3,-23700(gp)
    c77c:	e0bffb17 	ldw	r2,-20(fp)
    c780:	18800926 	beq	r3,r2,c7a8 <tcp_slowtmr+0x7bc>
    c784:	010000f4 	movhi	r4,3
    c788:	21397304 	addi	r4,r4,-6708
    c78c:	014000f4 	movhi	r5,3
    c790:	2979f904 	addi	r5,r5,-6172
    c794:	0180c744 	movi	r6,797
    c798:	01c000f4 	movhi	r7,3
    c79c:	39f98704 	addi	r7,r7,-6628
    c7a0:	00166c00 	call	166c0 <printf>
    c7a4:	003fff06 	br	c7a4 <tcp_slowtmr+0x7b8>
        tcp_tw_pcbs = pcb->next;
    c7a8:	e0bffb17 	ldw	r2,-20(fp)
    c7ac:	10800317 	ldw	r2,12(r2)
    c7b0:	d0a8db15 	stw	r2,-23700(gp)
      }
      pcb2 = pcb->next;
    c7b4:	e0bffb17 	ldw	r2,-20(fp)
    c7b8:	10800317 	ldw	r2,12(r2)
    c7bc:	e0bfff15 	stw	r2,-4(fp)
      memp_free(MEMP_TCP_PCB, pcb);
    c7c0:	01000084 	movi	r4,2
    c7c4:	e17ffb17 	ldw	r5,-20(fp)
    c7c8:	00090cc0 	call	90cc <memp_free>
      pcb = pcb2;
    c7cc:	e0bfff17 	ldw	r2,-4(fp)
    c7d0:	e0bffb15 	stw	r2,-20(fp)
    c7d4:	00000506 	br	c7ec <tcp_slowtmr+0x800>
    } else {
      prev = pcb;
    c7d8:	e0bffb17 	ldw	r2,-20(fp)
    c7dc:	e0bffc15 	stw	r2,-16(fp)
      pcb = pcb->next;
    c7e0:	e0bffb17 	ldw	r2,-20(fp)
    c7e4:	10800317 	ldw	r2,12(r2)
    c7e8:	e0bffb15 	stw	r2,-20(fp)

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
    c7ec:	e0bffb17 	ldw	r2,-20(fp)
    c7f0:	103fb31e 	bne	r2,zero,c6c0 <tcp_slowtmr+0x6d4>
    } else {
      prev = pcb;
      pcb = pcb->next;
    }
  }
}
    c7f4:	e037883a 	mov	sp,fp
    c7f8:	dfc00117 	ldw	ra,4(sp)
    c7fc:	df000017 	ldw	fp,0(sp)
    c800:	dec00204 	addi	sp,sp,8
    c804:	f800283a 	ret

0000c808 <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
    c808:	defffc04 	addi	sp,sp,-16
    c80c:	dfc00315 	stw	ra,12(sp)
    c810:	df000215 	stw	fp,8(sp)
    c814:	df000204 	addi	fp,sp,8
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    c818:	d0a8d617 	ldw	r2,-23720(gp)
    c81c:	e0bffe15 	stw	r2,-8(fp)
    c820:	00003606 	br	c8fc <tcp_fasttmr+0xf4>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
    c824:	e0bffe17 	ldw	r2,-8(fp)
    c828:	10802117 	ldw	r2,132(r2)
    c82c:	10001c26 	beq	r2,zero,c8a0 <tcp_fasttmr+0x98>
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
    c830:	e0bffe17 	ldw	r2,-8(fp)
    c834:	10802317 	ldw	r2,140(r2)
    c838:	10000d26 	beq	r2,zero,c870 <tcp_fasttmr+0x68>
    c83c:	e0bffe17 	ldw	r2,-8(fp)
    c840:	12002317 	ldw	r8,140(r2)
    c844:	e0bffe17 	ldw	r2,-8(fp)
    c848:	10c00617 	ldw	r3,24(r2)
    c84c:	e0bffe17 	ldw	r2,-8(fp)
    c850:	10802117 	ldw	r2,132(r2)
    c854:	1809883a 	mov	r4,r3
    c858:	e17ffe17 	ldw	r5,-8(fp)
    c85c:	100d883a 	mov	r6,r2
    c860:	000f883a 	mov	r7,zero
    c864:	403ee83a 	callr	r8
    c868:	e0bfff05 	stb	r2,-4(fp)
    c86c:	00000806 	br	c890 <tcp_fasttmr+0x88>
    c870:	e0bffe17 	ldw	r2,-8(fp)
    c874:	10802117 	ldw	r2,132(r2)
    c878:	0009883a 	mov	r4,zero
    c87c:	e17ffe17 	ldw	r5,-8(fp)
    c880:	100d883a 	mov	r6,r2
    c884:	000f883a 	mov	r7,zero
    c888:	000ca7c0 	call	ca7c <tcp_recv_null>
    c88c:	e0bfff05 	stb	r2,-4(fp)
      if (err == ERR_OK) {
    c890:	e0bfff07 	ldb	r2,-4(fp)
    c894:	1000021e 	bne	r2,zero,c8a0 <tcp_fasttmr+0x98>
        pcb->refused_data = NULL;
    c898:	e0bffe17 	ldw	r2,-8(fp)
    c89c:	10002115 	stw	zero,132(r2)
      }
    }

    /* send delayed ACKs */  
    if (pcb->flags & TF_ACK_DELAY) {
    c8a0:	e0bffe17 	ldw	r2,-8(fp)
    c8a4:	10800983 	ldbu	r2,38(r2)
    c8a8:	10803fcc 	andi	r2,r2,255
    c8ac:	1080004c 	andi	r2,r2,1
    c8b0:	10000f26 	beq	r2,zero,c8f0 <tcp_fasttmr+0xe8>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
    c8b4:	e0bffe17 	ldw	r2,-8(fp)
    c8b8:	10800983 	ldbu	r2,38(r2)
    c8bc:	10800094 	ori	r2,r2,2
    c8c0:	1007883a 	mov	r3,r2
    c8c4:	e0bffe17 	ldw	r2,-8(fp)
    c8c8:	10c00985 	stb	r3,38(r2)
    c8cc:	e13ffe17 	ldw	r4,-8(fp)
    c8d0:	00122380 	call	12238 <tcp_output>
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    c8d4:	e0bffe17 	ldw	r2,-8(fp)
    c8d8:	10c00983 	ldbu	r3,38(r2)
    c8dc:	00bfff04 	movi	r2,-4
    c8e0:	1884703a 	and	r2,r3,r2
    c8e4:	1007883a 	mov	r3,r2
    c8e8:	e0bffe17 	ldw	r2,-8(fp)
    c8ec:	10c00985 	stb	r3,38(r2)
void
tcp_fasttmr(void)
{
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    c8f0:	e0bffe17 	ldw	r2,-8(fp)
    c8f4:	10800317 	ldw	r2,12(r2)
    c8f8:	e0bffe15 	stw	r2,-8(fp)
    c8fc:	e0bffe17 	ldw	r2,-8(fp)
    c900:	103fc81e 	bne	r2,zero,c824 <tcp_fasttmr+0x1c>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }
  }
}
    c904:	e037883a 	mov	sp,fp
    c908:	dfc00117 	ldw	ra,4(sp)
    c90c:	df000017 	ldw	fp,0(sp)
    c910:	dec00204 	addi	sp,sp,8
    c914:	f800283a 	ret

0000c918 <tcp_segs_free>:
 * @param seg tcp_seg list of TCP segments to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
    c918:	defffb04 	addi	sp,sp,-20
    c91c:	dfc00415 	stw	ra,16(sp)
    c920:	df000315 	stw	fp,12(sp)
    c924:	df000304 	addi	fp,sp,12
    c928:	e13fff15 	stw	r4,-4(fp)
  u8_t count = 0;
    c92c:	e03ffd05 	stb	zero,-12(fp)
  struct tcp_seg *next;
  while (seg != NULL) {
    c930:	00000a06 	br	c95c <tcp_segs_free+0x44>
    next = seg->next;
    c934:	e0bfff17 	ldw	r2,-4(fp)
    c938:	10800017 	ldw	r2,0(r2)
    c93c:	e0bffe15 	stw	r2,-8(fp)
    count += tcp_seg_free(seg);
    c940:	e13fff17 	ldw	r4,-4(fp)
    c944:	000c97c0 	call	c97c <tcp_seg_free>
    c948:	e0fffd03 	ldbu	r3,-12(fp)
    c94c:	10c5883a 	add	r2,r2,r3
    c950:	e0bffd05 	stb	r2,-12(fp)
    seg = next;
    c954:	e0bffe17 	ldw	r2,-8(fp)
    c958:	e0bfff15 	stw	r2,-4(fp)
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  struct tcp_seg *next;
  while (seg != NULL) {
    c95c:	e0bfff17 	ldw	r2,-4(fp)
    c960:	103ff41e 	bne	r2,zero,c934 <tcp_segs_free+0x1c>
    next = seg->next;
    count += tcp_seg_free(seg);
    seg = next;
  }
  return count;
    c964:	e0bffd03 	ldbu	r2,-12(fp)
}
    c968:	e037883a 	mov	sp,fp
    c96c:	dfc00117 	ldw	ra,4(sp)
    c970:	df000017 	ldw	fp,0(sp)
    c974:	dec00204 	addi	sp,sp,8
    c978:	f800283a 	ret

0000c97c <tcp_seg_free>:
 * @param seg single tcp_seg to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
    c97c:	defffc04 	addi	sp,sp,-16
    c980:	dfc00315 	stw	ra,12(sp)
    c984:	df000215 	stw	fp,8(sp)
    c988:	df000204 	addi	fp,sp,8
    c98c:	e13fff15 	stw	r4,-4(fp)
  u8_t count = 0;
    c990:	e03ffe05 	stb	zero,-8(fp)
  
  if (seg != NULL) {
    c994:	e0bfff17 	ldw	r2,-4(fp)
    c998:	10000b26 	beq	r2,zero,c9c8 <tcp_seg_free+0x4c>
    if (seg->p != NULL) {
    c99c:	e0bfff17 	ldw	r2,-4(fp)
    c9a0:	10800117 	ldw	r2,4(r2)
    c9a4:	10000526 	beq	r2,zero,c9bc <tcp_seg_free+0x40>
      count = pbuf_free(seg->p);
    c9a8:	e0bfff17 	ldw	r2,-4(fp)
    c9ac:	10800117 	ldw	r2,4(r2)
    c9b0:	1009883a 	mov	r4,r2
    c9b4:	000a16c0 	call	a16c <pbuf_free>
    c9b8:	e0bffe05 	stb	r2,-8(fp)
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
    c9bc:	01000104 	movi	r4,4
    c9c0:	e17fff17 	ldw	r5,-4(fp)
    c9c4:	00090cc0 	call	90cc <memp_free>
  }
  return count;
    c9c8:	e0bffe03 	ldbu	r2,-8(fp)
}
    c9cc:	e037883a 	mov	sp,fp
    c9d0:	dfc00117 	ldw	ra,4(sp)
    c9d4:	df000017 	ldw	fp,0(sp)
    c9d8:	dec00204 	addi	sp,sp,8
    c9dc:	f800283a 	ret

0000c9e0 <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
    c9e0:	defffd04 	addi	sp,sp,-12
    c9e4:	df000215 	stw	fp,8(sp)
    c9e8:	df000204 	addi	fp,sp,8
    c9ec:	e13ffe15 	stw	r4,-8(fp)
    c9f0:	2805883a 	mov	r2,r5
    c9f4:	e0bfff05 	stb	r2,-4(fp)
  pcb->prio = prio;
    c9f8:	e0bffe17 	ldw	r2,-8(fp)
    c9fc:	e0ffff03 	ldbu	r3,-4(fp)
    ca00:	10c00505 	stb	r3,20(r2)
}
    ca04:	e037883a 	mov	sp,fp
    ca08:	df000017 	ldw	fp,0(sp)
    ca0c:	dec00104 	addi	sp,sp,4
    ca10:	f800283a 	ret

0000ca14 <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
    ca14:	defffc04 	addi	sp,sp,-16
    ca18:	dfc00315 	stw	ra,12(sp)
    ca1c:	df000215 	stw	fp,8(sp)
    ca20:	df000204 	addi	fp,sp,8
    ca24:	e13fff15 	stw	r4,-4(fp)
  struct tcp_seg *cseg;

  cseg = memp_malloc(MEMP_TCP_SEG);
    ca28:	01000104 	movi	r4,4
    ca2c:	0008ef00 	call	8ef0 <memp_malloc>
    ca30:	e0bffe15 	stw	r2,-8(fp)
  if (cseg == NULL) {
    ca34:	e0bffe17 	ldw	r2,-8(fp)
    ca38:	1000021e 	bne	r2,zero,ca44 <tcp_seg_copy+0x30>
    return NULL;
    ca3c:	0005883a 	mov	r2,zero
    ca40:	00000906 	br	ca68 <tcp_seg_copy+0x54>
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
    ca44:	e13ffe17 	ldw	r4,-8(fp)
    ca48:	e17fff17 	ldw	r5,-4(fp)
    ca4c:	01800504 	movi	r6,20
    ca50:	00164c00 	call	164c0 <memcpy>
  pbuf_ref(cseg->p);
    ca54:	e0bffe17 	ldw	r2,-8(fp)
    ca58:	10800117 	ldw	r2,4(r2)
    ca5c:	1009883a 	mov	r4,r2
    ca60:	000a3840 	call	a384 <pbuf_ref>
  return cseg;
    ca64:	e0bffe17 	ldw	r2,-8(fp)
}
    ca68:	e037883a 	mov	sp,fp
    ca6c:	dfc00117 	ldw	ra,4(sp)
    ca70:	df000017 	ldw	fp,0(sp)
    ca74:	dec00204 	addi	sp,sp,8
    ca78:	f800283a 	ret

0000ca7c <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
    ca7c:	defffa04 	addi	sp,sp,-24
    ca80:	dfc00515 	stw	ra,20(sp)
    ca84:	df000415 	stw	fp,16(sp)
    ca88:	df000404 	addi	fp,sp,16
    ca8c:	e13ffc15 	stw	r4,-16(fp)
    ca90:	e17ffd15 	stw	r5,-12(fp)
    ca94:	e1bffe15 	stw	r6,-8(fp)
    ca98:	3805883a 	mov	r2,r7
    ca9c:	e0bfff05 	stb	r2,-4(fp)
  LWIP_UNUSED_ARG(arg);
  if (p != NULL) {
    caa0:	e0bffe17 	ldw	r2,-8(fp)
    caa4:	10000926 	beq	r2,zero,cacc <tcp_recv_null+0x50>
    tcp_recved(pcb, p->tot_len);
    caa8:	e0bffe17 	ldw	r2,-8(fp)
    caac:	1080020b 	ldhu	r2,8(r2)
    cab0:	10bfffcc 	andi	r2,r2,65535
    cab4:	e13ffd17 	ldw	r4,-12(fp)
    cab8:	100b883a 	mov	r5,r2
    cabc:	000bbb80 	call	bbb8 <tcp_recved>
    pbuf_free(p);
    cac0:	e13ffe17 	ldw	r4,-8(fp)
    cac4:	000a16c0 	call	a16c <pbuf_free>
    cac8:	00000506 	br	cae0 <tcp_recv_null+0x64>
  } else if (err == ERR_OK) {
    cacc:	e0bfff07 	ldb	r2,-4(fp)
    cad0:	1000031e 	bne	r2,zero,cae0 <tcp_recv_null+0x64>
    return tcp_close(pcb);
    cad4:	e13ffd17 	ldw	r4,-12(fp)
    cad8:	000b2780 	call	b278 <tcp_close>
    cadc:	00000106 	br	cae4 <tcp_recv_null+0x68>
  }
  return ERR_OK;
    cae0:	0005883a 	mov	r2,zero
}
    cae4:	e037883a 	mov	sp,fp
    cae8:	dfc00117 	ldw	ra,4(sp)
    caec:	df000017 	ldw	fp,0(sp)
    caf0:	dec00204 	addi	sp,sp,8
    caf4:	f800283a 	ret

0000caf8 <tcp_kill_prio>:
 *
 * @param prio minimum priority
 */
static void
tcp_kill_prio(u8_t prio)
{
    caf8:	defff904 	addi	sp,sp,-28
    cafc:	dfc00615 	stw	ra,24(sp)
    cb00:	df000515 	stw	fp,20(sp)
    cb04:	df000504 	addi	fp,sp,20
    cb08:	2005883a 	mov	r2,r4
    cb0c:	e0bfff05 	stb	r2,-4(fp)
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;
  u8_t mprio;


  mprio = TCP_PRIO_MAX;
    cb10:	00801fc4 	movi	r2,127
    cb14:	e0bffe05 	stb	r2,-8(fp)
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
    cb18:	e03ffd15 	stw	zero,-12(fp)
  inactive = NULL;
    cb1c:	e03ffc15 	stw	zero,-16(fp)
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    cb20:	d0a8d617 	ldw	r2,-23720(gp)
    cb24:	e0bffb15 	stw	r2,-20(fp)
    cb28:	00001d06 	br	cba0 <tcp_kill_prio+0xa8>
    if (pcb->prio <= prio &&
    cb2c:	e0bffb17 	ldw	r2,-20(fp)
    cb30:	10800503 	ldbu	r2,20(r2)
    cb34:	10803fcc 	andi	r2,r2,255
    cb38:	e0ffff03 	ldbu	r3,-4(fp)
    cb3c:	18801536 	bltu	r3,r2,cb94 <tcp_kill_prio+0x9c>
       pcb->prio <= mprio &&
    cb40:	e0bffb17 	ldw	r2,-20(fp)
    cb44:	10800503 	ldbu	r2,20(r2)
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
    cb48:	10803fcc 	andi	r2,r2,255
    cb4c:	e0fffe03 	ldbu	r3,-8(fp)
    cb50:	18801036 	bltu	r3,r2,cb94 <tcp_kill_prio+0x9c>
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
    cb54:	d0e8d717 	ldw	r3,-23716(gp)
    cb58:	e0bffb17 	ldw	r2,-20(fp)
    cb5c:	10800d17 	ldw	r2,52(r2)
    cb60:	1887c83a 	sub	r3,r3,r2
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
    cb64:	e0bffd17 	ldw	r2,-12(fp)
    cb68:	18800a36 	bltu	r3,r2,cb94 <tcp_kill_prio+0x9c>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
    cb6c:	d0e8d717 	ldw	r3,-23716(gp)
    cb70:	e0bffb17 	ldw	r2,-20(fp)
    cb74:	10800d17 	ldw	r2,52(r2)
    cb78:	1885c83a 	sub	r2,r3,r2
    cb7c:	e0bffd15 	stw	r2,-12(fp)
      inactive = pcb;
    cb80:	e0bffb17 	ldw	r2,-20(fp)
    cb84:	e0bffc15 	stw	r2,-16(fp)
      mprio = pcb->prio;
    cb88:	e0bffb17 	ldw	r2,-20(fp)
    cb8c:	10800503 	ldbu	r2,20(r2)
    cb90:	e0bffe05 	stb	r2,-8(fp)
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    cb94:	e0bffb17 	ldw	r2,-20(fp)
    cb98:	10800317 	ldw	r2,12(r2)
    cb9c:	e0bffb15 	stw	r2,-20(fp)
    cba0:	e0bffb17 	ldw	r2,-20(fp)
    cba4:	103fe11e 	bne	r2,zero,cb2c <tcp_kill_prio+0x34>
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
    }
  }
  if (inactive != NULL) {
    cba8:	e0bffc17 	ldw	r2,-16(fp)
    cbac:	10000326 	beq	r2,zero,cbbc <tcp_kill_prio+0xc4>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
    cbb0:	e13ffc17 	ldw	r4,-16(fp)
    cbb4:	01400044 	movi	r5,1
    cbb8:	000b4680 	call	b468 <tcp_abandon>
  }      
}
    cbbc:	e037883a 	mov	sp,fp
    cbc0:	dfc00117 	ldw	ra,4(sp)
    cbc4:	df000017 	ldw	fp,0(sp)
    cbc8:	dec00204 	addi	sp,sp,8
    cbcc:	f800283a 	ret

0000cbd0 <tcp_kill_timewait>:
 * Kills the oldest connection that is in TIME_WAIT state.
 * Called from tcp_alloc() if no more connections are available.
 */
static void
tcp_kill_timewait(void)
{
    cbd0:	defffb04 	addi	sp,sp,-20
    cbd4:	dfc00415 	stw	ra,16(sp)
    cbd8:	df000315 	stw	fp,12(sp)
    cbdc:	df000304 	addi	fp,sp,12
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  inactivity = 0;
    cbe0:	e03fff15 	stw	zero,-4(fp)
  inactive = NULL;
    cbe4:	e03ffe15 	stw	zero,-8(fp)
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    cbe8:	d0a8db17 	ldw	r2,-23700(gp)
    cbec:	e0bffd15 	stw	r2,-12(fp)
    cbf0:	00001006 	br	cc34 <tcp_kill_timewait+0x64>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
    cbf4:	d0e8d717 	ldw	r3,-23716(gp)
    cbf8:	e0bffd17 	ldw	r2,-12(fp)
    cbfc:	10800d17 	ldw	r2,52(r2)
    cc00:	1887c83a 	sub	r3,r3,r2
    cc04:	e0bfff17 	ldw	r2,-4(fp)
    cc08:	18800736 	bltu	r3,r2,cc28 <tcp_kill_timewait+0x58>
      inactivity = tcp_ticks - pcb->tmr;
    cc0c:	d0e8d717 	ldw	r3,-23716(gp)
    cc10:	e0bffd17 	ldw	r2,-12(fp)
    cc14:	10800d17 	ldw	r2,52(r2)
    cc18:	1885c83a 	sub	r2,r3,r2
    cc1c:	e0bfff15 	stw	r2,-4(fp)
      inactive = pcb;
    cc20:	e0bffd17 	ldw	r2,-12(fp)
    cc24:	e0bffe15 	stw	r2,-8(fp)
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    cc28:	e0bffd17 	ldw	r2,-12(fp)
    cc2c:	10800317 	ldw	r2,12(r2)
    cc30:	e0bffd15 	stw	r2,-12(fp)
    cc34:	e0bffd17 	ldw	r2,-12(fp)
    cc38:	103fee1e 	bne	r2,zero,cbf4 <tcp_kill_timewait+0x24>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
    }
  }
  if (inactive != NULL) {
    cc3c:	e0bffe17 	ldw	r2,-8(fp)
    cc40:	10000326 	beq	r2,zero,cc50 <tcp_kill_timewait+0x80>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
    cc44:	e13ffe17 	ldw	r4,-8(fp)
    cc48:	01400044 	movi	r5,1
    cc4c:	000b4680 	call	b468 <tcp_abandon>
  }      
}
    cc50:	e037883a 	mov	sp,fp
    cc54:	dfc00117 	ldw	ra,4(sp)
    cc58:	df000017 	ldw	fp,0(sp)
    cc5c:	dec00204 	addi	sp,sp,8
    cc60:	f800283a 	ret

0000cc64 <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
    cc64:	defffb04 	addi	sp,sp,-20
    cc68:	dfc00415 	stw	ra,16(sp)
    cc6c:	df000315 	stw	fp,12(sp)
    cc70:	df000304 	addi	fp,sp,12
    cc74:	2005883a 	mov	r2,r4
    cc78:	e0bfff05 	stb	r2,-4(fp)
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = memp_malloc(MEMP_TCP_PCB);
    cc7c:	01000084 	movi	r4,2
    cc80:	0008ef00 	call	8ef0 <memp_malloc>
    cc84:	e0bffd15 	stw	r2,-12(fp)
  if (pcb == NULL) {
    cc88:	e0bffd17 	ldw	r2,-12(fp)
    cc8c:	1000201e 	bne	r2,zero,cd10 <tcp_alloc+0xac>
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
    cc90:	000cbd00 	call	cbd0 <tcp_kill_timewait>
    /* Try to allocate a tcp_pcb again. */
    pcb = memp_malloc(MEMP_TCP_PCB);
    cc94:	01000084 	movi	r4,2
    cc98:	0008ef00 	call	8ef0 <memp_malloc>
    cc9c:	e0bffd15 	stw	r2,-12(fp)
    if (pcb == NULL) {
    cca0:	e0bffd17 	ldw	r2,-12(fp)
    cca4:	1000101e 	bne	r2,zero,cce8 <tcp_alloc+0x84>
      /* Try killing active connections with lower priority than the new one. */
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing connection with prio lower than %d\n", prio));
      tcp_kill_prio(prio);
    cca8:	e0bfff03 	ldbu	r2,-4(fp)
    ccac:	1009883a 	mov	r4,r2
    ccb0:	000caf80 	call	caf8 <tcp_kill_prio>
      /* Try to allocate a tcp_pcb again. */
      pcb = memp_malloc(MEMP_TCP_PCB);
    ccb4:	01000084 	movi	r4,2
    ccb8:	0008ef00 	call	8ef0 <memp_malloc>
    ccbc:	e0bffd15 	stw	r2,-12(fp)
      if (pcb != NULL) {
    ccc0:	e0bffd17 	ldw	r2,-12(fp)
    ccc4:	10000826 	beq	r2,zero,cce8 <tcp_alloc+0x84>
        /* adjust err stats: memp_malloc failed twice before */
        MEMP_STATS_DEC(err, MEMP_TCP_PCB);
    ccc8:	00800134 	movhi	r2,4
    cccc:	108d9504 	addi	r2,r2,13908
    ccd0:	1080330b 	ldhu	r2,204(r2)
    ccd4:	10bfffc4 	addi	r2,r2,-1
    ccd8:	1007883a 	mov	r3,r2
    ccdc:	00800134 	movhi	r2,4
    cce0:	108d9504 	addi	r2,r2,13908
    cce4:	10c0330d 	sth	r3,204(r2)
      }
    }
    if (pcb != NULL) {
    cce8:	e0bffd17 	ldw	r2,-12(fp)
    ccec:	10000826 	beq	r2,zero,cd10 <tcp_alloc+0xac>
      /* adjust err stats: timewait PCB was freed above */
      MEMP_STATS_DEC(err, MEMP_TCP_PCB);
    ccf0:	00800134 	movhi	r2,4
    ccf4:	108d9504 	addi	r2,r2,13908
    ccf8:	1080330b 	ldhu	r2,204(r2)
    ccfc:	10bfffc4 	addi	r2,r2,-1
    cd00:	1007883a 	mov	r3,r2
    cd04:	00800134 	movhi	r2,4
    cd08:	108d9504 	addi	r2,r2,13908
    cd0c:	10c0330d 	sth	r3,204(r2)
    }
  }
  if (pcb != NULL) {
    cd10:	e0bffd17 	ldw	r2,-12(fp)
    cd14:	10004526 	beq	r2,zero,ce2c <tcp_alloc+0x1c8>
    memset(pcb, 0, sizeof(struct tcp_pcb));
    cd18:	e13ffd17 	ldw	r4,-12(fp)
    cd1c:	000b883a 	mov	r5,zero
    cd20:	01802a04 	movi	r6,168
    cd24:	00165b80 	call	165b8 <memset>
    pcb->prio = TCP_PRIO_NORMAL;
    cd28:	e0bffd17 	ldw	r2,-12(fp)
    cd2c:	00c01004 	movi	r3,64
    cd30:	10c00505 	stb	r3,20(r2)
    pcb->snd_buf = TCP_SND_BUF;
    cd34:	e0bffd17 	ldw	r2,-12(fp)
    cd38:	00d00004 	movi	r3,16384
    cd3c:	10c01c8d 	sth	r3,114(r2)
    pcb->snd_queuelen = 0;
    cd40:	e0bffd17 	ldw	r2,-12(fp)
    cd44:	10001d0d 	sth	zero,116(r2)
    pcb->rcv_wnd = TCP_WND;
    cd48:	e0bffd17 	ldw	r2,-12(fp)
    cd4c:	00c20004 	movi	r3,2048
    cd50:	10c00b0d 	sth	r3,44(r2)
    pcb->rcv_ann_wnd = TCP_WND;
    cd54:	e0bffd17 	ldw	r2,-12(fp)
    cd58:	00c20004 	movi	r3,2048
    cd5c:	10c00b8d 	sth	r3,46(r2)
    pcb->tos = 0;
    cd60:	e0bffd17 	ldw	r2,-12(fp)
    cd64:	10000285 	stb	zero,10(r2)
    pcb->ttl = TCP_TTL;
    cd68:	e0bffd17 	ldw	r2,-12(fp)
    cd6c:	00ffffc4 	movi	r3,-1
    cd70:	10c002c5 	stb	r3,11(r2)
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
    cd74:	e0bffd17 	ldw	r2,-12(fp)
    cd78:	00c08604 	movi	r3,536
    cd7c:	10c00f0d 	sth	r3,60(r2)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
    cd80:	e0bffd17 	ldw	r2,-12(fp)
    cd84:	00c00184 	movi	r3,6
    cd88:	10c0130d 	sth	r3,76(r2)
    pcb->sa = 0;
    cd8c:	e0bffd17 	ldw	r2,-12(fp)
    cd90:	1000120d 	sth	zero,72(r2)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
    cd94:	e0bffd17 	ldw	r2,-12(fp)
    cd98:	00c00184 	movi	r3,6
    cd9c:	10c0128d 	sth	r3,74(r2)
    pcb->rtime = -1;
    cda0:	e0bffd17 	ldw	r2,-12(fp)
    cda4:	00ffffc4 	movi	r3,-1
    cda8:	10c00e8d 	sth	r3,58(r2)
    pcb->cwnd = 1;
    cdac:	e0bffd17 	ldw	r2,-12(fp)
    cdb0:	00c00044 	movi	r3,1
    cdb4:	10c0158d 	sth	r3,86(r2)
    iss = tcp_next_iss();
    cdb8:	000d2200 	call	d220 <tcp_next_iss>
    cdbc:	e0bffe15 	stw	r2,-8(fp)
    pcb->snd_wl2 = iss;
    cdc0:	e0bffd17 	ldw	r2,-12(fp)
    cdc4:	e0fffe17 	ldw	r3,-8(fp)
    cdc8:	10c01a15 	stw	r3,104(r2)
    pcb->snd_nxt = iss;
    cdcc:	e0bffd17 	ldw	r2,-12(fp)
    cdd0:	e0fffe17 	ldw	r3,-8(fp)
    cdd4:	10c01715 	stw	r3,92(r2)
    pcb->lastack = iss;
    cdd8:	e0bffd17 	ldw	r2,-12(fp)
    cddc:	e0fffe17 	ldw	r3,-8(fp)
    cde0:	10c01415 	stw	r3,80(r2)
    pcb->snd_lbb = iss;   
    cde4:	e0bffd17 	ldw	r2,-12(fp)
    cde8:	e0fffe17 	ldw	r3,-8(fp)
    cdec:	10c01b15 	stw	r3,108(r2)
    pcb->tmr = tcp_ticks;
    cdf0:	d0e8d717 	ldw	r3,-23716(gp)
    cdf4:	e0bffd17 	ldw	r2,-12(fp)
    cdf8:	10c00d15 	stw	r3,52(r2)

    pcb->polltmr = 0;
    cdfc:	e0bffd17 	ldw	r2,-12(fp)
    ce00:	10000e05 	stb	zero,56(r2)

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
    ce04:	e0bffd17 	ldw	r2,-12(fp)
    ce08:	00c00074 	movhi	r3,1
    ce0c:	18f29f04 	addi	r3,r3,-13700
    ce10:	10c02315 	stw	r3,140(r2)
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
    ce14:	e0bffd17 	ldw	r2,-12(fp)
    ce18:	00c01bb4 	movhi	r3,110
    ce1c:	18f74004 	addi	r3,r3,-8960
    ce20:	10c02715 	stw	r3,156(r2)
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
    ce24:	e0bffd17 	ldw	r2,-12(fp)
    ce28:	10002945 	stb	zero,165(r2)
  }
  return pcb;
    ce2c:	e0bffd17 	ldw	r2,-12(fp)
}
    ce30:	e037883a 	mov	sp,fp
    ce34:	dfc00117 	ldw	ra,4(sp)
    ce38:	df000017 	ldw	fp,0(sp)
    ce3c:	dec00204 	addi	sp,sp,8
    ce40:	f800283a 	ret

0000ce44 <tcp_new>:
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
    ce44:	defffe04 	addi	sp,sp,-8
    ce48:	dfc00115 	stw	ra,4(sp)
    ce4c:	df000015 	stw	fp,0(sp)
    ce50:	d839883a 	mov	fp,sp
  return tcp_alloc(TCP_PRIO_NORMAL);
    ce54:	01001004 	movi	r4,64
    ce58:	000cc640 	call	cc64 <tcp_alloc>
}
    ce5c:	e037883a 	mov	sp,fp
    ce60:	dfc00117 	ldw	ra,4(sp)
    ce64:	df000017 	ldw	fp,0(sp)
    ce68:	dec00204 	addi	sp,sp,8
    ce6c:	f800283a 	ret

0000ce70 <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
    ce70:	defffd04 	addi	sp,sp,-12
    ce74:	df000215 	stw	fp,8(sp)
    ce78:	df000204 	addi	fp,sp,8
    ce7c:	e13ffe15 	stw	r4,-8(fp)
    ce80:	e17fff15 	stw	r5,-4(fp)
  pcb->callback_arg = arg;
    ce84:	e0bffe17 	ldw	r2,-8(fp)
    ce88:	e0ffff17 	ldw	r3,-4(fp)
    ce8c:	10c00615 	stw	r3,24(r2)
}
    ce90:	e037883a 	mov	sp,fp
    ce94:	df000017 	ldw	fp,0(sp)
    ce98:	dec00104 	addi	sp,sp,4
    ce9c:	f800283a 	ret

0000cea0 <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
    cea0:	defffd04 	addi	sp,sp,-12
    cea4:	df000215 	stw	fp,8(sp)
    cea8:	df000204 	addi	fp,sp,8
    ceac:	e13ffe15 	stw	r4,-8(fp)
    ceb0:	e17fff15 	stw	r5,-4(fp)
  pcb->recv = recv;
    ceb4:	e0bffe17 	ldw	r2,-8(fp)
    ceb8:	e0ffff17 	ldw	r3,-4(fp)
    cebc:	10c02315 	stw	r3,140(r2)
}
    cec0:	e037883a 	mov	sp,fp
    cec4:	df000017 	ldw	fp,0(sp)
    cec8:	dec00104 	addi	sp,sp,4
    cecc:	f800283a 	ret

0000ced0 <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
    ced0:	defffd04 	addi	sp,sp,-12
    ced4:	df000215 	stw	fp,8(sp)
    ced8:	df000204 	addi	fp,sp,8
    cedc:	e13ffe15 	stw	r4,-8(fp)
    cee0:	e17fff15 	stw	r5,-4(fp)
  pcb->sent = sent;
    cee4:	e0bffe17 	ldw	r2,-8(fp)
    cee8:	e0ffff17 	ldw	r3,-4(fp)
    ceec:	10c02215 	stw	r3,136(r2)
}
    cef0:	e037883a 	mov	sp,fp
    cef4:	df000017 	ldw	fp,0(sp)
    cef8:	dec00104 	addi	sp,sp,4
    cefc:	f800283a 	ret

0000cf00 <tcp_err>:
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
    cf00:	defffd04 	addi	sp,sp,-12
    cf04:	df000215 	stw	fp,8(sp)
    cf08:	df000204 	addi	fp,sp,8
    cf0c:	e13ffe15 	stw	r4,-8(fp)
    cf10:	e17fff15 	stw	r5,-4(fp)
  pcb->errf = errf;
    cf14:	e0bffe17 	ldw	r2,-8(fp)
    cf18:	e0ffff17 	ldw	r3,-4(fp)
    cf1c:	10c02615 	stw	r3,152(r2)
}
    cf20:	e037883a 	mov	sp,fp
    cf24:	df000017 	ldw	fp,0(sp)
    cf28:	dec00104 	addi	sp,sp,4
    cf2c:	f800283a 	ret

0000cf30 <tcp_accept>:
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
    cf30:	defffd04 	addi	sp,sp,-12
    cf34:	df000215 	stw	fp,8(sp)
    cf38:	df000204 	addi	fp,sp,8
    cf3c:	e13ffe15 	stw	r4,-8(fp)
    cf40:	e17fff15 	stw	r5,-4(fp)
  pcb->accept = accept;
    cf44:	e0bffe17 	ldw	r2,-8(fp)
    cf48:	e0ffff17 	ldw	r3,-4(fp)
    cf4c:	10c00815 	stw	r3,32(r2)
}
    cf50:	e037883a 	mov	sp,fp
    cf54:	df000017 	ldw	fp,0(sp)
    cf58:	dec00104 	addi	sp,sp,4
    cf5c:	f800283a 	ret

0000cf60 <tcp_poll>:
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
    cf60:	defffc04 	addi	sp,sp,-16
    cf64:	df000315 	stw	fp,12(sp)
    cf68:	df000304 	addi	fp,sp,12
    cf6c:	e13ffd15 	stw	r4,-12(fp)
    cf70:	e17ffe15 	stw	r5,-8(fp)
    cf74:	3005883a 	mov	r2,r6
    cf78:	e0bfff05 	stb	r2,-4(fp)
#if LWIP_CALLBACK_API
  pcb->poll = poll;
    cf7c:	e0bffd17 	ldw	r2,-12(fp)
    cf80:	e0fffe17 	ldw	r3,-8(fp)
    cf84:	10c02515 	stw	r3,148(r2)
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
    cf88:	e0bffd17 	ldw	r2,-12(fp)
    cf8c:	e0ffff03 	ldbu	r3,-4(fp)
    cf90:	10c00e45 	stb	r3,57(r2)
}
    cf94:	e037883a 	mov	sp,fp
    cf98:	df000017 	ldw	fp,0(sp)
    cf9c:	dec00104 	addi	sp,sp,4
    cfa0:	f800283a 	ret

0000cfa4 <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
    cfa4:	defffd04 	addi	sp,sp,-12
    cfa8:	dfc00215 	stw	ra,8(sp)
    cfac:	df000115 	stw	fp,4(sp)
    cfb0:	df000104 	addi	fp,sp,4
    cfb4:	e13fff15 	stw	r4,-4(fp)
  if (pcb->state != CLOSED &&
    cfb8:	e0bfff17 	ldw	r2,-4(fp)
    cfbc:	10800417 	ldw	r2,16(r2)
    cfc0:	10002826 	beq	r2,zero,d064 <tcp_pcb_purge+0xc0>
     pcb->state != TIME_WAIT &&
    cfc4:	e0bfff17 	ldw	r2,-4(fp)
    cfc8:	10800417 	ldw	r2,16(r2)
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
    cfcc:	108002a0 	cmpeqi	r2,r2,10
    cfd0:	1000241e 	bne	r2,zero,d064 <tcp_pcb_purge+0xc0>
     pcb->state != TIME_WAIT &&
     pcb->state != LISTEN) {
    cfd4:	e0bfff17 	ldw	r2,-4(fp)
    cfd8:	10800417 	ldw	r2,16(r2)
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
     pcb->state != TIME_WAIT &&
    cfdc:	10800060 	cmpeqi	r2,r2,1
    cfe0:	1000201e 	bne	r2,zero,d064 <tcp_pcb_purge+0xc0>
      }
    }
#endif /* TCP_LISTEN_BACKLOG */


    if (pcb->refused_data != NULL) {
    cfe4:	e0bfff17 	ldw	r2,-4(fp)
    cfe8:	10802117 	ldw	r2,132(r2)
    cfec:	10000626 	beq	r2,zero,d008 <tcp_pcb_purge+0x64>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
    cff0:	e0bfff17 	ldw	r2,-4(fp)
    cff4:	10802117 	ldw	r2,132(r2)
    cff8:	1009883a 	mov	r4,r2
    cffc:	000a16c0 	call	a16c <pbuf_free>
      pcb->refused_data = NULL;
    d000:	e0bfff17 	ldw	r2,-4(fp)
    d004:	10002115 	stw	zero,132(r2)
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
    d008:	e0bfff17 	ldw	r2,-4(fp)
    d00c:	00ffffc4 	movi	r3,-1
    d010:	10c00e8d 	sth	r3,58(r2)

    tcp_segs_free(pcb->ooseq);
    d014:	e0bfff17 	ldw	r2,-4(fp)
    d018:	10802017 	ldw	r2,128(r2)
    d01c:	1009883a 	mov	r4,r2
    d020:	000c9180 	call	c918 <tcp_segs_free>
    pcb->ooseq = NULL;
    d024:	e0bfff17 	ldw	r2,-4(fp)
    d028:	10002015 	stw	zero,128(r2)
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
    d02c:	e0bfff17 	ldw	r2,-4(fp)
    d030:	10801e17 	ldw	r2,120(r2)
    d034:	1009883a 	mov	r4,r2
    d038:	000c9180 	call	c918 <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
    d03c:	e0bfff17 	ldw	r2,-4(fp)
    d040:	10801f17 	ldw	r2,124(r2)
    d044:	1009883a 	mov	r4,r2
    d048:	000c9180 	call	c918 <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
    d04c:	e0bfff17 	ldw	r2,-4(fp)
    d050:	10001e15 	stw	zero,120(r2)
    d054:	e0bfff17 	ldw	r2,-4(fp)
    d058:	10c01e17 	ldw	r3,120(r2)
    d05c:	e0bfff17 	ldw	r2,-4(fp)
    d060:	10c01f15 	stw	r3,124(r2)
  }
}
    d064:	e037883a 	mov	sp,fp
    d068:	dfc00117 	ldw	ra,4(sp)
    d06c:	df000017 	ldw	fp,0(sp)
    d070:	dec00204 	addi	sp,sp,8
    d074:	f800283a 	ret

0000d078 <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
    d078:	defffc04 	addi	sp,sp,-16
    d07c:	dfc00315 	stw	ra,12(sp)
    d080:	df000215 	stw	fp,8(sp)
    d084:	df000204 	addi	fp,sp,8
    d088:	e13ffe15 	stw	r4,-8(fp)
    d08c:	e17fff15 	stw	r5,-4(fp)
  TCP_RMV(pcblist, pcb);
    d090:	e0bffe17 	ldw	r2,-8(fp)
    d094:	10c00017 	ldw	r3,0(r2)
    d098:	e0bfff17 	ldw	r2,-4(fp)
    d09c:	1880061e 	bne	r3,r2,d0b8 <tcp_pcb_remove+0x40>
    d0a0:	e0bffe17 	ldw	r2,-8(fp)
    d0a4:	10800017 	ldw	r2,0(r2)
    d0a8:	10c00317 	ldw	r3,12(r2)
    d0ac:	e0bffe17 	ldw	r2,-8(fp)
    d0b0:	10c00015 	stw	r3,0(r2)
    d0b4:	00001206 	br	d100 <tcp_pcb_remove+0x88>
    d0b8:	e0bffe17 	ldw	r2,-8(fp)
    d0bc:	10800017 	ldw	r2,0(r2)
    d0c0:	d0a8d915 	stw	r2,-23708(gp)
    d0c4:	00000c06 	br	d0f8 <tcp_pcb_remove+0x80>
    d0c8:	d0a8d917 	ldw	r2,-23708(gp)
    d0cc:	10c00317 	ldw	r3,12(r2)
    d0d0:	e0bfff17 	ldw	r2,-4(fp)
    d0d4:	1880051e 	bne	r3,r2,d0ec <tcp_pcb_remove+0x74>
    d0d8:	d0a8d917 	ldw	r2,-23708(gp)
    d0dc:	e0ffff17 	ldw	r3,-4(fp)
    d0e0:	18c00317 	ldw	r3,12(r3)
    d0e4:	10c00315 	stw	r3,12(r2)
    d0e8:	00000506 	br	d100 <tcp_pcb_remove+0x88>
    d0ec:	d0a8d917 	ldw	r2,-23708(gp)
    d0f0:	10800317 	ldw	r2,12(r2)
    d0f4:	d0a8d915 	stw	r2,-23708(gp)
    d0f8:	d0a8d917 	ldw	r2,-23708(gp)
    d0fc:	103ff21e 	bne	r2,zero,d0c8 <tcp_pcb_remove+0x50>
    d100:	e0bfff17 	ldw	r2,-4(fp)
    d104:	10000315 	stw	zero,12(r2)

  tcp_pcb_purge(pcb);
    d108:	e13fff17 	ldw	r4,-4(fp)
    d10c:	000cfa40 	call	cfa4 <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
    d110:	e0bfff17 	ldw	r2,-4(fp)
    d114:	10800417 	ldw	r2,16(r2)
    d118:	108002a0 	cmpeqi	r2,r2,10
    d11c:	1000111e 	bne	r2,zero,d164 <tcp_pcb_remove+0xec>
     pcb->state != LISTEN &&
    d120:	e0bfff17 	ldw	r2,-4(fp)
    d124:	10800417 	ldw	r2,16(r2)
  TCP_RMV(pcblist, pcb);

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
    d128:	10800060 	cmpeqi	r2,r2,1
    d12c:	10000d1e 	bne	r2,zero,d164 <tcp_pcb_remove+0xec>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
    d130:	e0bfff17 	ldw	r2,-4(fp)
    d134:	10800983 	ldbu	r2,38(r2)
    d138:	10803fcc 	andi	r2,r2,255
    d13c:	1080004c 	andi	r2,r2,1

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
     pcb->state != LISTEN &&
    d140:	10000826 	beq	r2,zero,d164 <tcp_pcb_remove+0xec>
     pcb->flags & TF_ACK_DELAY) {
    pcb->flags |= TF_ACK_NOW;
    d144:	e0bfff17 	ldw	r2,-4(fp)
    d148:	10800983 	ldbu	r2,38(r2)
    d14c:	10800094 	ori	r2,r2,2
    d150:	1007883a 	mov	r3,r2
    d154:	e0bfff17 	ldw	r2,-4(fp)
    d158:	10c00985 	stb	r3,38(r2)
    tcp_output(pcb);
    d15c:	e13fff17 	ldw	r4,-4(fp)
    d160:	00122380 	call	12238 <tcp_output>
  }

  if (pcb->state != LISTEN) {
    d164:	e0bfff17 	ldw	r2,-4(fp)
    d168:	10800417 	ldw	r2,16(r2)
    d16c:	10800060 	cmpeqi	r2,r2,1
    d170:	1000241e 	bne	r2,zero,d204 <tcp_pcb_remove+0x18c>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
    d174:	e0bfff17 	ldw	r2,-4(fp)
    d178:	10801e17 	ldw	r2,120(r2)
    d17c:	10000926 	beq	r2,zero,d1a4 <tcp_pcb_remove+0x12c>
    d180:	010000f4 	movhi	r4,3
    d184:	21397304 	addi	r4,r4,-6708
    d188:	014000f4 	movhi	r5,3
    d18c:	297a0304 	addi	r5,r5,-6132
    d190:	01813dc4 	movi	r6,1271
    d194:	01c000f4 	movhi	r7,3
    d198:	39f98704 	addi	r7,r7,-6628
    d19c:	00166c00 	call	166c0 <printf>
    d1a0:	003fff06 	br	d1a0 <tcp_pcb_remove+0x128>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
    d1a4:	e0bfff17 	ldw	r2,-4(fp)
    d1a8:	10801f17 	ldw	r2,124(r2)
    d1ac:	10000926 	beq	r2,zero,d1d4 <tcp_pcb_remove+0x15c>
    d1b0:	010000f4 	movhi	r4,3
    d1b4:	21397304 	addi	r4,r4,-6708
    d1b8:	014000f4 	movhi	r5,3
    d1bc:	297a0904 	addi	r5,r5,-6108
    d1c0:	01813e04 	movi	r6,1272
    d1c4:	01c000f4 	movhi	r7,3
    d1c8:	39f98704 	addi	r7,r7,-6628
    d1cc:	00166c00 	call	166c0 <printf>
    d1d0:	003fff06 	br	d1d0 <tcp_pcb_remove+0x158>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
    d1d4:	e0bfff17 	ldw	r2,-4(fp)
    d1d8:	10802017 	ldw	r2,128(r2)
    d1dc:	10000926 	beq	r2,zero,d204 <tcp_pcb_remove+0x18c>
    d1e0:	010000f4 	movhi	r4,3
    d1e4:	21397304 	addi	r4,r4,-6708
    d1e8:	014000f4 	movhi	r5,3
    d1ec:	297a1004 	addi	r5,r5,-6080
    d1f0:	01813e84 	movi	r6,1274
    d1f4:	01c000f4 	movhi	r7,3
    d1f8:	39f98704 	addi	r7,r7,-6628
    d1fc:	00166c00 	call	166c0 <printf>
    d200:	003fff06 	br	d200 <tcp_pcb_remove+0x188>
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
    d204:	e0bfff17 	ldw	r2,-4(fp)
    d208:	10000415 	stw	zero,16(r2)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
    d20c:	e037883a 	mov	sp,fp
    d210:	dfc00117 	ldw	ra,4(sp)
    d214:	df000017 	ldw	fp,0(sp)
    d218:	dec00204 	addi	sp,sp,8
    d21c:	f800283a 	ret

0000d220 <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(void)
{
    d220:	deffff04 	addi	sp,sp,-4
    d224:	df000015 	stw	fp,0(sp)
    d228:	d839883a 	mov	fp,sp
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
    d22c:	d0e00517 	ldw	r3,-32748(gp)
    d230:	d0a8d717 	ldw	r2,-23716(gp)
    d234:	1885883a 	add	r2,r3,r2
    d238:	d0a00515 	stw	r2,-32748(gp)
  return iss;
    d23c:	d0a00517 	ldw	r2,-32748(gp)
}
    d240:	e037883a 	mov	sp,fp
    d244:	df000017 	ldw	fp,0(sp)
    d248:	dec00104 	addi	sp,sp,4
    d24c:	f800283a 	ret

0000d250 <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
{
    d250:	defffa04 	addi	sp,sp,-24
    d254:	dfc00515 	stw	ra,20(sp)
    d258:	df000415 	stw	fp,16(sp)
    d25c:	df000404 	addi	fp,sp,16
    d260:	2005883a 	mov	r2,r4
    d264:	e17fff15 	stw	r5,-4(fp)
    d268:	e0bffe0d 	sth	r2,-8(fp)
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
    d26c:	e13fff17 	ldw	r4,-4(fp)
    d270:	00061940 	call	6194 <ip_route>
    d274:	e0bffc15 	stw	r2,-16(fp)
  if ((outif != NULL) && (outif->mtu != 0)) {
    d278:	e0bffc17 	ldw	r2,-16(fp)
    d27c:	10000f26 	beq	r2,zero,d2bc <tcp_eff_send_mss+0x6c>
    d280:	e0bffc17 	ldw	r2,-16(fp)
    d284:	1080090b 	ldhu	r2,36(r2)
    d288:	10bfffcc 	andi	r2,r2,65535
    d28c:	10000b26 	beq	r2,zero,d2bc <tcp_eff_send_mss+0x6c>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
    d290:	e0bffc17 	ldw	r2,-16(fp)
    d294:	1080090b 	ldhu	r2,36(r2)
    d298:	10bff604 	addi	r2,r2,-40
    d29c:	e0bffd0d 	sth	r2,-12(fp)
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * We correct for TCP options in tcp_enqueue(), and don't support
     * IP options
     */
    sendmss = LWIP_MIN(sendmss, mss_s);
    d2a0:	e0fffe0b 	ldhu	r3,-8(fp)
    d2a4:	e0bffd0b 	ldhu	r2,-12(fp)
    d2a8:	113fffcc 	andi	r4,r2,65535
    d2ac:	197fffcc 	andi	r5,r3,65535
    d2b0:	2900012e 	bgeu	r5,r4,d2b8 <tcp_eff_send_mss+0x68>
    d2b4:	1805883a 	mov	r2,r3
    d2b8:	e0bffe0d 	sth	r2,-8(fp)
  }
  return sendmss;
    d2bc:	e0bffe0b 	ldhu	r2,-8(fp)
}
    d2c0:	e037883a 	mov	sp,fp
    d2c4:	dfc00117 	ldw	ra,4(sp)
    d2c8:	df000017 	ldw	fp,0(sp)
    d2cc:	dec00204 	addi	sp,sp,8
    d2d0:	f800283a 	ret

0000d2d4 <tcp_debug_state_str>:
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

const char*
tcp_debug_state_str(enum tcp_state s)
{
    d2d4:	defffe04 	addi	sp,sp,-8
    d2d8:	df000115 	stw	fp,4(sp)
    d2dc:	df000104 	addi	fp,sp,4
    d2e0:	e13fff15 	stw	r4,-4(fp)
  return tcp_state_str[s];
    d2e4:	00c000f4 	movhi	r3,3
    d2e8:	18c4ae04 	addi	r3,r3,4792
    d2ec:	e0bfff17 	ldw	r2,-4(fp)
    d2f0:	1085883a 	add	r2,r2,r2
    d2f4:	1085883a 	add	r2,r2,r2
    d2f8:	1885883a 	add	r2,r3,r2
    d2fc:	10800017 	ldw	r2,0(r2)
}
    d300:	e037883a 	mov	sp,fp
    d304:	df000017 	ldw	fp,0(sp)
    d308:	dec00104 	addi	sp,sp,4
    d30c:	f800283a 	ret

0000d310 <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
    d310:	defff604 	addi	sp,sp,-40
    d314:	dfc00915 	stw	ra,36(sp)
    d318:	df000815 	stw	fp,32(sp)
    d31c:	df000804 	addi	fp,sp,32
    d320:	e13ffe15 	stw	r4,-8(fp)
    d324:	e17fff15 	stw	r5,-4(fp)
  u8_t hdrlen;
  err_t err;

  PERF_START;

  TCP_STATS_INC(tcp.recv);
    d328:	00800134 	movhi	r2,4
    d32c:	108d9504 	addi	r2,r2,13908
    d330:	1080248b 	ldhu	r2,146(r2)
    d334:	10800044 	addi	r2,r2,1
    d338:	1007883a 	mov	r3,r2
    d33c:	00800134 	movhi	r2,4
    d340:	108d9504 	addi	r2,r2,13908
    d344:	10c0248d 	sth	r3,146(r2)
  snmp_inc_tcpinsegs();

  iphdr = p->payload;
    d348:	e0bffe17 	ldw	r2,-8(fp)
    d34c:	10800117 	ldw	r2,4(r2)
    d350:	d0a8dd15 	stw	r2,-23692(gp)
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
    d354:	e0bffe17 	ldw	r2,-8(fp)
    d358:	10c00117 	ldw	r3,4(r2)
    d35c:	d0a8dd17 	ldw	r2,-23692(gp)
    d360:	1080000b 	ldhu	r2,0(r2)
    d364:	10bfffcc 	andi	r2,r2,65535
    d368:	1004d23a 	srli	r2,r2,8
    d36c:	113fffcc 	andi	r4,r2,65535
    d370:	d0a8dd17 	ldw	r2,-23692(gp)
    d374:	1080000b 	ldhu	r2,0(r2)
    d378:	10bfffcc 	andi	r2,r2,65535
    d37c:	1004923a 	slli	r2,r2,8
    d380:	10bfffcc 	andi	r2,r2,65535
    d384:	2084b03a 	or	r2,r4,r2
    d388:	1005d23a 	srai	r2,r2,8
    d38c:	108003cc 	andi	r2,r2,15
    d390:	1085883a 	add	r2,r2,r2
    d394:	1085883a 	add	r2,r2,r2
    d398:	1885883a 	add	r2,r3,r2
    d39c:	d0a8dc15 	stw	r2,-23696(gp)
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
    d3a0:	d0a8dd17 	ldw	r2,-23692(gp)
    d3a4:	1080000b 	ldhu	r2,0(r2)
    d3a8:	10bfffcc 	andi	r2,r2,65535
    d3ac:	1004d23a 	srli	r2,r2,8
    d3b0:	10ffffcc 	andi	r3,r2,65535
    d3b4:	d0a8dd17 	ldw	r2,-23692(gp)
    d3b8:	1080000b 	ldhu	r2,0(r2)
    d3bc:	10bfffcc 	andi	r2,r2,65535
    d3c0:	1004923a 	slli	r2,r2,8
    d3c4:	10bfffcc 	andi	r2,r2,65535
    d3c8:	1884b03a 	or	r2,r3,r2
    d3cc:	1005d23a 	srai	r2,r2,8
    d3d0:	108003cc 	andi	r2,r2,15
    d3d4:	1085883a 	add	r2,r2,r2
    d3d8:	1085883a 	add	r2,r2,r2
    d3dc:	0085c83a 	sub	r2,zero,r2
    d3e0:	10bfffcc 	andi	r2,r2,65535
    d3e4:	10a0001c 	xori	r2,r2,32768
    d3e8:	10a00004 	addi	r2,r2,-32768
    d3ec:	e13ffe17 	ldw	r4,-8(fp)
    d3f0:	100b883a 	mov	r5,r2
    d3f4:	0009f740 	call	9f74 <pbuf_header>
    d3f8:	10803fcc 	andi	r2,r2,255
    d3fc:	1000051e 	bne	r2,zero,d414 <tcp_input+0x104>
    d400:	e0bffe17 	ldw	r2,-8(fp)
    d404:	1080020b 	ldhu	r2,8(r2)
    d408:	10bfffcc 	andi	r2,r2,65535
    d40c:	10800528 	cmpgeui	r2,r2,20
    d410:	1000131e 	bne	r2,zero,d460 <tcp_input+0x150>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
    TCP_STATS_INC(tcp.lenerr);
    d414:	00800134 	movhi	r2,4
    d418:	108d9504 	addi	r2,r2,13908
    d41c:	1080268b 	ldhu	r2,154(r2)
    d420:	10800044 	addi	r2,r2,1
    d424:	1007883a 	mov	r3,r2
    d428:	00800134 	movhi	r2,4
    d42c:	108d9504 	addi	r2,r2,13908
    d430:	10c0268d 	sth	r3,154(r2)
    TCP_STATS_INC(tcp.drop);
    d434:	00800134 	movhi	r2,4
    d438:	108d9504 	addi	r2,r2,13908
    d43c:	1080258b 	ldhu	r2,150(r2)
    d440:	10800044 	addi	r2,r2,1
    d444:	1007883a 	mov	r3,r2
    d448:	00800134 	movhi	r2,4
    d44c:	108d9504 	addi	r2,r2,13908
    d450:	10c0258d 	sth	r3,150(r2)
    snmp_inc_tcpinerrs();
    pbuf_free(p);
    d454:	e13ffe17 	ldw	r4,-8(fp)
    d458:	000a16c0 	call	a16c <pbuf_free>
    return;
    d45c:	0002f406 	br	e030 <tcp_input+0xd20>
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
    d460:	d0a8dd17 	ldw	r2,-23692(gp)
    d464:	10800404 	addi	r2,r2,16
    d468:	1009883a 	mov	r4,r2
    d46c:	e17fff17 	ldw	r5,-4(fp)
    d470:	0006db00 	call	6db0 <ip_addr_isbroadcast>
    d474:	10803fcc 	andi	r2,r2,255
    d478:	1000081e 	bne	r2,zero,d49c <tcp_input+0x18c>
      ip_addr_ismulticast(&(iphdr->dest))) {
    d47c:	d0a8dd17 	ldw	r2,-23692(gp)
    d480:	10c0040b 	ldhu	r3,16(r2)
    d484:	1080048b 	ldhu	r2,18(r2)
    d488:	1004943a 	slli	r2,r2,16
    d48c:	10c4b03a 	or	r2,r2,r3
    d490:	10803c0c 	andi	r2,r2,240
    pbuf_free(p);
    return;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
    d494:	10803818 	cmpnei	r2,r2,224
    d498:	1000131e 	bne	r2,zero,d4e8 <tcp_input+0x1d8>
      ip_addr_ismulticast(&(iphdr->dest))) {
    TCP_STATS_INC(tcp.proterr);
    d49c:	00800134 	movhi	r2,4
    d4a0:	108d9504 	addi	r2,r2,13908
    d4a4:	1080280b 	ldhu	r2,160(r2)
    d4a8:	10800044 	addi	r2,r2,1
    d4ac:	1007883a 	mov	r3,r2
    d4b0:	00800134 	movhi	r2,4
    d4b4:	108d9504 	addi	r2,r2,13908
    d4b8:	10c0280d 	sth	r3,160(r2)
    TCP_STATS_INC(tcp.drop);
    d4bc:	00800134 	movhi	r2,4
    d4c0:	108d9504 	addi	r2,r2,13908
    d4c4:	1080258b 	ldhu	r2,150(r2)
    d4c8:	10800044 	addi	r2,r2,1
    d4cc:	1007883a 	mov	r3,r2
    d4d0:	00800134 	movhi	r2,4
    d4d4:	108d9504 	addi	r2,r2,13908
    d4d8:	10c0258d 	sth	r3,150(r2)
    snmp_inc_tcpinerrs();
    pbuf_free(p);
    d4dc:	e13ffe17 	ldw	r4,-8(fp)
    d4e0:	000a16c0 	call	a16c <pbuf_free>
    return;
    d4e4:	0002d206 	br	e030 <tcp_input+0xd20>
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
    d4e8:	d0a8dd17 	ldw	r2,-23692(gp)
    d4ec:	10c00304 	addi	r3,r2,12
      (struct ip_addr *)&(iphdr->dest),
    d4f0:	d0a8dd17 	ldw	r2,-23692(gp)
    return;
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
    d4f4:	10800404 	addi	r2,r2,16
      (struct ip_addr *)&(iphdr->dest),
      IP_PROTO_TCP, p->tot_len) != 0) {
    d4f8:	e13ffe17 	ldw	r4,-8(fp)
    d4fc:	2100020b 	ldhu	r4,8(r4)
    return;
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
    d500:	213fffcc 	andi	r4,r4,65535
    d504:	d9000015 	stw	r4,0(sp)
    d508:	e13ffe17 	ldw	r4,-8(fp)
    d50c:	180b883a 	mov	r5,r3
    d510:	100d883a 	mov	r6,r2
    d514:	01c00184 	movi	r7,6
    d518:	0005e240 	call	5e24 <inet_chksum_pseudo>
    d51c:	10bfffcc 	andi	r2,r2,65535
    d520:	10001326 	beq	r2,zero,d570 <tcp_input+0x260>
        inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src), (struct ip_addr *)&(iphdr->dest),
      IP_PROTO_TCP, p->tot_len)));
#if TCP_DEBUG
    tcp_debug_print(tcphdr);
#endif /* TCP_DEBUG */
    TCP_STATS_INC(tcp.chkerr);
    d524:	00800134 	movhi	r2,4
    d528:	108d9504 	addi	r2,r2,13908
    d52c:	1080260b 	ldhu	r2,152(r2)
    d530:	10800044 	addi	r2,r2,1
    d534:	1007883a 	mov	r3,r2
    d538:	00800134 	movhi	r2,4
    d53c:	108d9504 	addi	r2,r2,13908
    d540:	10c0260d 	sth	r3,152(r2)
    TCP_STATS_INC(tcp.drop);
    d544:	00800134 	movhi	r2,4
    d548:	108d9504 	addi	r2,r2,13908
    d54c:	1080258b 	ldhu	r2,150(r2)
    d550:	10800044 	addi	r2,r2,1
    d554:	1007883a 	mov	r3,r2
    d558:	00800134 	movhi	r2,4
    d55c:	108d9504 	addi	r2,r2,13908
    d560:	10c0258d 	sth	r3,150(r2)
    snmp_inc_tcpinerrs();
    pbuf_free(p);
    d564:	e13ffe17 	ldw	r4,-8(fp)
    d568:	000a16c0 	call	a16c <pbuf_free>
    return;
    d56c:	0002b006 	br	e030 <tcp_input+0xd20>
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
    d570:	d0a8dc17 	ldw	r2,-23696(gp)
    d574:	1080030b 	ldhu	r2,12(r2)
    d578:	10bfffcc 	andi	r2,r2,65535
    d57c:	1004d23a 	srli	r2,r2,8
    d580:	10ffffcc 	andi	r3,r2,65535
    d584:	d0a8dc17 	ldw	r2,-23696(gp)
    d588:	1080030b 	ldhu	r2,12(r2)
    d58c:	10bfffcc 	andi	r2,r2,65535
    d590:	1004923a 	slli	r2,r2,8
    d594:	10bfffcc 	andi	r2,r2,65535
    d598:	1884b03a 	or	r2,r3,r2
    d59c:	1005d33a 	srai	r2,r2,12
    d5a0:	e0bffd45 	stb	r2,-11(fp)
  if(pbuf_header(p, -(hdrlen * 4))){
    d5a4:	e0bffd43 	ldbu	r2,-11(fp)
    d5a8:	10bfff24 	muli	r2,r2,-4
    d5ac:	10bfffcc 	andi	r2,r2,65535
    d5b0:	10a0001c 	xori	r2,r2,32768
    d5b4:	10a00004 	addi	r2,r2,-32768
    d5b8:	e13ffe17 	ldw	r4,-8(fp)
    d5bc:	100b883a 	mov	r5,r2
    d5c0:	0009f740 	call	9f74 <pbuf_header>
    d5c4:	10803fcc 	andi	r2,r2,255
    d5c8:	10001326 	beq	r2,zero,d618 <tcp_input+0x308>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
    TCP_STATS_INC(tcp.lenerr);
    d5cc:	00800134 	movhi	r2,4
    d5d0:	108d9504 	addi	r2,r2,13908
    d5d4:	1080268b 	ldhu	r2,154(r2)
    d5d8:	10800044 	addi	r2,r2,1
    d5dc:	1007883a 	mov	r3,r2
    d5e0:	00800134 	movhi	r2,4
    d5e4:	108d9504 	addi	r2,r2,13908
    d5e8:	10c0268d 	sth	r3,154(r2)
    TCP_STATS_INC(tcp.drop);
    d5ec:	00800134 	movhi	r2,4
    d5f0:	108d9504 	addi	r2,r2,13908
    d5f4:	1080258b 	ldhu	r2,150(r2)
    d5f8:	10800044 	addi	r2,r2,1
    d5fc:	1007883a 	mov	r3,r2
    d600:	00800134 	movhi	r2,4
    d604:	108d9504 	addi	r2,r2,13908
    d608:	10c0258d 	sth	r3,150(r2)
    snmp_inc_tcpinerrs();
    pbuf_free(p);
    d60c:	e13ffe17 	ldw	r4,-8(fp)
    d610:	000a16c0 	call	a16c <pbuf_free>
    return;
    d614:	00028606 	br	e030 <tcp_input+0xd20>
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
    d618:	d0a8dc17 	ldw	r2,-23696(gp)
    d61c:	d0e8dc17 	ldw	r3,-23696(gp)
    d620:	18c0000b 	ldhu	r3,0(r3)
    d624:	18ffffcc 	andi	r3,r3,65535
    d628:	1806d23a 	srli	r3,r3,8
    d62c:	1809883a 	mov	r4,r3
    d630:	d0e8dc17 	ldw	r3,-23696(gp)
    d634:	18c0000b 	ldhu	r3,0(r3)
    d638:	18ffffcc 	andi	r3,r3,65535
    d63c:	1806923a 	slli	r3,r3,8
    d640:	20c6b03a 	or	r3,r4,r3
    d644:	10c0000d 	sth	r3,0(r2)
  tcphdr->dest = ntohs(tcphdr->dest);
    d648:	d0a8dc17 	ldw	r2,-23696(gp)
    d64c:	d0e8dc17 	ldw	r3,-23696(gp)
    d650:	18c0008b 	ldhu	r3,2(r3)
    d654:	18ffffcc 	andi	r3,r3,65535
    d658:	1806d23a 	srli	r3,r3,8
    d65c:	1809883a 	mov	r4,r3
    d660:	d0e8dc17 	ldw	r3,-23696(gp)
    d664:	18c0008b 	ldhu	r3,2(r3)
    d668:	18ffffcc 	andi	r3,r3,65535
    d66c:	1806923a 	slli	r3,r3,8
    d670:	20c6b03a 	or	r3,r4,r3
    d674:	10c0008d 	sth	r3,2(r2)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
    d678:	d0a8dc17 	ldw	r2,-23696(gp)
    d67c:	d0e8dc17 	ldw	r3,-23696(gp)
    d680:	1900010b 	ldhu	r4,4(r3)
    d684:	18c0018b 	ldhu	r3,6(r3)
    d688:	1806943a 	slli	r3,r3,16
    d68c:	1906b03a 	or	r3,r3,r4
    d690:	1808d63a 	srli	r4,r3,24
    d694:	d0e8dc17 	ldw	r3,-23696(gp)
    d698:	1940010b 	ldhu	r5,4(r3)
    d69c:	18c0018b 	ldhu	r3,6(r3)
    d6a0:	1806943a 	slli	r3,r3,16
    d6a4:	1946b03a 	or	r3,r3,r5
    d6a8:	1806d23a 	srli	r3,r3,8
    d6ac:	18ffc00c 	andi	r3,r3,65280
    d6b0:	20c8b03a 	or	r4,r4,r3
    d6b4:	d0e8dc17 	ldw	r3,-23696(gp)
    d6b8:	1940010b 	ldhu	r5,4(r3)
    d6bc:	18c0018b 	ldhu	r3,6(r3)
    d6c0:	1806943a 	slli	r3,r3,16
    d6c4:	1946b03a 	or	r3,r3,r5
    d6c8:	18ffc00c 	andi	r3,r3,65280
    d6cc:	1806923a 	slli	r3,r3,8
    d6d0:	20c8b03a 	or	r4,r4,r3
    d6d4:	d0e8dc17 	ldw	r3,-23696(gp)
    d6d8:	1940010b 	ldhu	r5,4(r3)
    d6dc:	18c0018b 	ldhu	r3,6(r3)
    d6e0:	1806943a 	slli	r3,r3,16
    d6e4:	1946b03a 	or	r3,r3,r5
    d6e8:	1806963a 	slli	r3,r3,24
    d6ec:	20c6b03a 	or	r3,r4,r3
    d6f0:	193fffcc 	andi	r4,r3,65535
    d6f4:	1140010b 	ldhu	r5,4(r2)
    d6f8:	280a703a 	and	r5,r5,zero
    d6fc:	2908b03a 	or	r4,r5,r4
    d700:	1100010d 	sth	r4,4(r2)
    d704:	1806d43a 	srli	r3,r3,16
    d708:	1100018b 	ldhu	r4,6(r2)
    d70c:	2008703a 	and	r4,r4,zero
    d710:	20c6b03a 	or	r3,r4,r3
    d714:	10c0018d 	sth	r3,6(r2)
    d718:	10c0010b 	ldhu	r3,4(r2)
    d71c:	1080018b 	ldhu	r2,6(r2)
    d720:	1004943a 	slli	r2,r2,16
    d724:	10c4b03a 	or	r2,r2,r3
    d728:	d0a8de15 	stw	r2,-23688(gp)
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
    d72c:	d0a8dc17 	ldw	r2,-23696(gp)
    d730:	d0e8dc17 	ldw	r3,-23696(gp)
    d734:	1900020b 	ldhu	r4,8(r3)
    d738:	18c0028b 	ldhu	r3,10(r3)
    d73c:	1806943a 	slli	r3,r3,16
    d740:	1906b03a 	or	r3,r3,r4
    d744:	1808d63a 	srli	r4,r3,24
    d748:	d0e8dc17 	ldw	r3,-23696(gp)
    d74c:	1940020b 	ldhu	r5,8(r3)
    d750:	18c0028b 	ldhu	r3,10(r3)
    d754:	1806943a 	slli	r3,r3,16
    d758:	1946b03a 	or	r3,r3,r5
    d75c:	1806d23a 	srli	r3,r3,8
    d760:	18ffc00c 	andi	r3,r3,65280
    d764:	20c8b03a 	or	r4,r4,r3
    d768:	d0e8dc17 	ldw	r3,-23696(gp)
    d76c:	1940020b 	ldhu	r5,8(r3)
    d770:	18c0028b 	ldhu	r3,10(r3)
    d774:	1806943a 	slli	r3,r3,16
    d778:	1946b03a 	or	r3,r3,r5
    d77c:	18ffc00c 	andi	r3,r3,65280
    d780:	1806923a 	slli	r3,r3,8
    d784:	20c8b03a 	or	r4,r4,r3
    d788:	d0e8dc17 	ldw	r3,-23696(gp)
    d78c:	1940020b 	ldhu	r5,8(r3)
    d790:	18c0028b 	ldhu	r3,10(r3)
    d794:	1806943a 	slli	r3,r3,16
    d798:	1946b03a 	or	r3,r3,r5
    d79c:	1806963a 	slli	r3,r3,24
    d7a0:	20c6b03a 	or	r3,r4,r3
    d7a4:	193fffcc 	andi	r4,r3,65535
    d7a8:	1140020b 	ldhu	r5,8(r2)
    d7ac:	280a703a 	and	r5,r5,zero
    d7b0:	2908b03a 	or	r4,r5,r4
    d7b4:	1100020d 	sth	r4,8(r2)
    d7b8:	1806d43a 	srli	r3,r3,16
    d7bc:	1100028b 	ldhu	r4,10(r2)
    d7c0:	2008703a 	and	r4,r4,zero
    d7c4:	20c6b03a 	or	r3,r4,r3
    d7c8:	10c0028d 	sth	r3,10(r2)
    d7cc:	10c0020b 	ldhu	r3,8(r2)
    d7d0:	1080028b 	ldhu	r2,10(r2)
    d7d4:	1004943a 	slli	r2,r2,16
    d7d8:	10c4b03a 	or	r2,r2,r3
    d7dc:	d0a8df15 	stw	r2,-23684(gp)
  tcphdr->wnd = ntohs(tcphdr->wnd);
    d7e0:	d0a8dc17 	ldw	r2,-23696(gp)
    d7e4:	d0e8dc17 	ldw	r3,-23696(gp)
    d7e8:	18c0038b 	ldhu	r3,14(r3)
    d7ec:	18ffffcc 	andi	r3,r3,65535
    d7f0:	1806d23a 	srli	r3,r3,8
    d7f4:	1809883a 	mov	r4,r3
    d7f8:	d0e8dc17 	ldw	r3,-23696(gp)
    d7fc:	18c0038b 	ldhu	r3,14(r3)
    d800:	18ffffcc 	andi	r3,r3,65535
    d804:	1806923a 	slli	r3,r3,8
    d808:	20c6b03a 	or	r3,r4,r3
    d80c:	10c0038d 	sth	r3,14(r2)

  flags = TCPH_FLAGS(tcphdr);
    d810:	d0a8dc17 	ldw	r2,-23696(gp)
    d814:	1080030b 	ldhu	r2,12(r2)
    d818:	10bfffcc 	andi	r2,r2,65535
    d81c:	1004d23a 	srli	r2,r2,8
    d820:	1007883a 	mov	r3,r2
    d824:	d0a8dc17 	ldw	r2,-23696(gp)
    d828:	1080030b 	ldhu	r2,12(r2)
    d82c:	10bfffcc 	andi	r2,r2,65535
    d830:	1004923a 	slli	r2,r2,8
    d834:	1884b03a 	or	r2,r3,r2
    d838:	10800fcc 	andi	r2,r2,63
    d83c:	d0a8e005 	stb	r2,-23680(gp)
  tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
    d840:	e0bffe17 	ldw	r2,-8(fp)
    d844:	10c0020b 	ldhu	r3,8(r2)
    d848:	d0a8e003 	ldbu	r2,-23680(gp)
    d84c:	10803fcc 	andi	r2,r2,255
    d850:	108000cc 	andi	r2,r2,3
    d854:	1004c03a 	cmpne	r2,r2,zero
    d858:	10803fcc 	andi	r2,r2,255
    d85c:	1885883a 	add	r2,r3,r2
    d860:	d0a8e08d 	sth	r2,-23678(gp)

  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;
    d864:	e03ffb15 	stw	zero,-20(fp)

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    d868:	008000f4 	movhi	r2,3
    d86c:	1095f604 	addi	r2,r2,22488
    d870:	10800017 	ldw	r2,0(r2)
    d874:	e0bffa15 	stw	r2,-24(fp)
    d878:	00007206 	br	da44 <tcp_input+0x734>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    d87c:	e0bffa17 	ldw	r2,-24(fp)
    d880:	10800417 	ldw	r2,16(r2)
    d884:	1000091e 	bne	r2,zero,d8ac <tcp_input+0x59c>
    d888:	010000f4 	movhi	r4,3
    d88c:	213a1604 	addi	r4,r4,-6056
    d890:	014000f4 	movhi	r5,3
    d894:	297a2004 	addi	r5,r5,-6016
    d898:	01802d44 	movi	r6,181
    d89c:	01c000f4 	movhi	r7,3
    d8a0:	39fa2a04 	addi	r7,r7,-5976
    d8a4:	00166c00 	call	166c0 <printf>
    d8a8:	003fff06 	br	d8a8 <tcp_input+0x598>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    d8ac:	e0bffa17 	ldw	r2,-24(fp)
    d8b0:	10800417 	ldw	r2,16(r2)
    d8b4:	10800298 	cmpnei	r2,r2,10
    d8b8:	1000091e 	bne	r2,zero,d8e0 <tcp_input+0x5d0>
    d8bc:	010000f4 	movhi	r4,3
    d8c0:	213a1604 	addi	r4,r4,-6056
    d8c4:	014000f4 	movhi	r5,3
    d8c8:	297a3004 	addi	r5,r5,-5952
    d8cc:	01802d84 	movi	r6,182
    d8d0:	01c000f4 	movhi	r7,3
    d8d4:	39fa2a04 	addi	r7,r7,-5976
    d8d8:	00166c00 	call	166c0 <printf>
    d8dc:	003fff06 	br	d8dc <tcp_input+0x5cc>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    d8e0:	e0bffa17 	ldw	r2,-24(fp)
    d8e4:	10800417 	ldw	r2,16(r2)
    d8e8:	10800058 	cmpnei	r2,r2,1
    d8ec:	1000091e 	bne	r2,zero,d914 <tcp_input+0x604>
    d8f0:	010000f4 	movhi	r4,3
    d8f4:	213a1604 	addi	r4,r4,-6056
    d8f8:	014000f4 	movhi	r5,3
    d8fc:	297a3b04 	addi	r5,r5,-5908
    d900:	01802dc4 	movi	r6,183
    d904:	01c000f4 	movhi	r7,3
    d908:	39fa2a04 	addi	r7,r7,-5976
    d90c:	00166c00 	call	166c0 <printf>
    d910:	003fff06 	br	d910 <tcp_input+0x600>
    if (pcb->remote_port == tcphdr->src &&
    d914:	e0bffa17 	ldw	r2,-24(fp)
    d918:	10c0090b 	ldhu	r3,36(r2)
    d91c:	d0a8dc17 	ldw	r2,-23696(gp)
    d920:	1080000b 	ldhu	r2,0(r2)
    d924:	18ffffcc 	andi	r3,r3,65535
    d928:	10bfffcc 	andi	r2,r2,65535
    d92c:	1880401e 	bne	r3,r2,da30 <tcp_input+0x720>
       pcb->local_port == tcphdr->dest &&
    d930:	e0bffa17 	ldw	r2,-24(fp)
    d934:	10c0070b 	ldhu	r3,28(r2)
    d938:	d0a8dc17 	ldw	r2,-23696(gp)
    d93c:	1080008b 	ldhu	r2,2(r2)
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
    d940:	18ffffcc 	andi	r3,r3,65535
    d944:	10bfffcc 	andi	r2,r2,65535
    d948:	1880391e 	bne	r3,r2,da30 <tcp_input+0x720>
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
    d94c:	e0bffa17 	ldw	r2,-24(fp)
    d950:	10c00117 	ldw	r3,4(r2)
    d954:	d0a8dd17 	ldw	r2,-23692(gp)
    d958:	1100030b 	ldhu	r4,12(r2)
    d95c:	1080038b 	ldhu	r2,14(r2)
    d960:	1004943a 	slli	r2,r2,16
    d964:	1104b03a 	or	r2,r2,r4
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
       pcb->local_port == tcphdr->dest &&
    d968:	1880311e 	bne	r3,r2,da30 <tcp_input+0x720>
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
       ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
    d96c:	e0bffa17 	ldw	r2,-24(fp)
    d970:	10c00017 	ldw	r3,0(r2)
    d974:	d0a8dd17 	ldw	r2,-23692(gp)
    d978:	1100040b 	ldhu	r4,16(r2)
    d97c:	1080048b 	ldhu	r2,18(r2)
    d980:	1004943a 	slli	r2,r2,16
    d984:	1104b03a 	or	r2,r2,r4
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
    d988:	1880291e 	bne	r3,r2,da30 <tcp_input+0x720>
       ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
    d98c:	e0bffa17 	ldw	r2,-24(fp)
    d990:	10c00317 	ldw	r3,12(r2)
    d994:	e0bffa17 	ldw	r2,-24(fp)
    d998:	1880091e 	bne	r3,r2,d9c0 <tcp_input+0x6b0>
    d99c:	010000f4 	movhi	r4,3
    d9a0:	213a1604 	addi	r4,r4,-6056
    d9a4:	014000f4 	movhi	r5,3
    d9a8:	297a4504 	addi	r5,r5,-5868
    d9ac:	01803004 	movi	r6,192
    d9b0:	01c000f4 	movhi	r7,3
    d9b4:	39fa2a04 	addi	r7,r7,-5976
    d9b8:	00166c00 	call	166c0 <printf>
    d9bc:	003fff06 	br	d9bc <tcp_input+0x6ac>
      if (prev != NULL) {
    d9c0:	e0bffb17 	ldw	r2,-20(fp)
    d9c4:	10000d26 	beq	r2,zero,d9fc <tcp_input+0x6ec>
        prev->next = pcb->next;
    d9c8:	e0bffa17 	ldw	r2,-24(fp)
    d9cc:	10c00317 	ldw	r3,12(r2)
    d9d0:	e0bffb17 	ldw	r2,-20(fp)
    d9d4:	10c00315 	stw	r3,12(r2)
        pcb->next = tcp_active_pcbs;
    d9d8:	008000f4 	movhi	r2,3
    d9dc:	1095f604 	addi	r2,r2,22488
    d9e0:	10c00017 	ldw	r3,0(r2)
    d9e4:	e0bffa17 	ldw	r2,-24(fp)
    d9e8:	10c00315 	stw	r3,12(r2)
        tcp_active_pcbs = pcb;
    d9ec:	008000f4 	movhi	r2,3
    d9f0:	1095f604 	addi	r2,r2,22488
    d9f4:	e0fffa17 	ldw	r3,-24(fp)
    d9f8:	10c00015 	stw	r3,0(r2)
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
    d9fc:	e0bffa17 	ldw	r2,-24(fp)
    da00:	10c00317 	ldw	r3,12(r2)
    da04:	e0bffa17 	ldw	r2,-24(fp)
    da08:	1880111e 	bne	r3,r2,da50 <tcp_input+0x740>
    da0c:	010000f4 	movhi	r4,3
    da10:	213a1604 	addi	r4,r4,-6056
    da14:	014000f4 	movhi	r5,3
    da18:	297a5004 	addi	r5,r5,-5824
    da1c:	01803184 	movi	r6,198
    da20:	01c000f4 	movhi	r7,3
    da24:	39fa2a04 	addi	r7,r7,-5976
    da28:	00166c00 	call	166c0 <printf>
    da2c:	003fff06 	br	da2c <tcp_input+0x71c>
      break;
    }
    prev = pcb;
    da30:	e0bffa17 	ldw	r2,-24(fp)
    da34:	e0bffb15 	stw	r2,-20(fp)
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    da38:	e0bffa17 	ldw	r2,-24(fp)
    da3c:	10800317 	ldw	r2,12(r2)
    da40:	e0bffa15 	stw	r2,-24(fp)
    da44:	e0bffa17 	ldw	r2,-24(fp)
    da48:	103f8c1e 	bne	r2,zero,d87c <tcp_input+0x56c>
    da4c:	00000106 	br	da54 <tcp_input+0x744>
        prev->next = pcb->next;
        pcb->next = tcp_active_pcbs;
        tcp_active_pcbs = pcb;
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
      break;
    da50:	0001883a 	nop
    }
    prev = pcb;
  }

  if (pcb == NULL) {
    da54:	e0bffa17 	ldw	r2,-24(fp)
    da58:	10006f1e 	bne	r2,zero,dc18 <tcp_input+0x908>
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    da5c:	008000f4 	movhi	r2,3
    da60:	1095fb04 	addi	r2,r2,22508
    da64:	10800017 	ldw	r2,0(r2)
    da68:	e0bffa15 	stw	r2,-24(fp)
    da6c:	00003306 	br	db3c <tcp_input+0x82c>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
    da70:	e0bffa17 	ldw	r2,-24(fp)
    da74:	10800417 	ldw	r2,16(r2)
    da78:	108002a0 	cmpeqi	r2,r2,10
    da7c:	1000091e 	bne	r2,zero,daa4 <tcp_input+0x794>
    da80:	010000f4 	movhi	r4,3
    da84:	213a1604 	addi	r4,r4,-6056
    da88:	014000f4 	movhi	r5,3
    da8c:	297a5b04 	addi	r5,r5,-5780
    da90:	01803404 	movi	r6,208
    da94:	01c000f4 	movhi	r7,3
    da98:	39fa2a04 	addi	r7,r7,-5976
    da9c:	00166c00 	call	166c0 <printf>
    daa0:	003fff06 	br	daa0 <tcp_input+0x790>
      if (pcb->remote_port == tcphdr->src &&
    daa4:	e0bffa17 	ldw	r2,-24(fp)
    daa8:	10c0090b 	ldhu	r3,36(r2)
    daac:	d0a8dc17 	ldw	r2,-23696(gp)
    dab0:	1080000b 	ldhu	r2,0(r2)
    dab4:	18ffffcc 	andi	r3,r3,65535
    dab8:	10bfffcc 	andi	r2,r2,65535
    dabc:	18801c1e 	bne	r3,r2,db30 <tcp_input+0x820>
         pcb->local_port == tcphdr->dest &&
    dac0:	e0bffa17 	ldw	r2,-24(fp)
    dac4:	10c0070b 	ldhu	r3,28(r2)
    dac8:	d0a8dc17 	ldw	r2,-23696(gp)
    dacc:	1080008b 	ldhu	r2,2(r2)
  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
    dad0:	18ffffcc 	andi	r3,r3,65535
    dad4:	10bfffcc 	andi	r2,r2,65535
    dad8:	1880151e 	bne	r3,r2,db30 <tcp_input+0x820>
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
    dadc:	e0bffa17 	ldw	r2,-24(fp)
    dae0:	10c00117 	ldw	r3,4(r2)
    dae4:	d0a8dd17 	ldw	r2,-23692(gp)
    dae8:	1100030b 	ldhu	r4,12(r2)
    daec:	1080038b 	ldhu	r2,14(r2)
    daf0:	1004943a 	slli	r2,r2,16
    daf4:	1104b03a 	or	r2,r2,r4
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
         pcb->local_port == tcphdr->dest &&
    daf8:	18800d1e 	bne	r3,r2,db30 <tcp_input+0x820>
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
         ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
    dafc:	e0bffa17 	ldw	r2,-24(fp)
    db00:	10c00017 	ldw	r3,0(r2)
    db04:	d0a8dd17 	ldw	r2,-23692(gp)
    db08:	1100040b 	ldhu	r4,16(r2)
    db0c:	1080048b 	ldhu	r2,18(r2)
    db10:	1004943a 	slli	r2,r2,16
    db14:	1104b03a 	or	r2,r2,r4
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
    db18:	1880051e 	bne	r3,r2,db30 <tcp_input+0x820>
         ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
    db1c:	e13ffa17 	ldw	r4,-24(fp)
    db20:	000e2e40 	call	e2e4 <tcp_timewait_input>
        pbuf_free(p);
    db24:	e13ffe17 	ldw	r4,-8(fp)
    db28:	000a16c0 	call	a16c <pbuf_free>
        return;
    db2c:	00014006 	br	e030 <tcp_input+0xd20>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    db30:	e0bffa17 	ldw	r2,-24(fp)
    db34:	10800317 	ldw	r2,12(r2)
    db38:	e0bffa15 	stw	r2,-24(fp)
    db3c:	e0bffa17 	ldw	r2,-24(fp)
    db40:	103fcb1e 	bne	r2,zero,da70 <tcp_input+0x760>
      }
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    db44:	e03ffb15 	stw	zero,-20(fp)
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    db48:	008000f4 	movhi	r2,3
    db4c:	1095f804 	addi	r2,r2,22496
    db50:	10800017 	ldw	r2,0(r2)
    db54:	e0bffc15 	stw	r2,-16(fp)
    db58:	00002d06 	br	dc10 <tcp_input+0x900>
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
    db5c:	e0bffc17 	ldw	r2,-16(fp)
    db60:	10000b26 	beq	r2,zero,db90 <tcp_input+0x880>
    db64:	e0bffc17 	ldw	r2,-16(fp)
    db68:	10800017 	ldw	r2,0(r2)
    db6c:	10000826 	beq	r2,zero,db90 <tcp_input+0x880>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
    db70:	e0bffc17 	ldw	r2,-16(fp)
    db74:	10c00017 	ldw	r3,0(r2)
    db78:	d0a8dd17 	ldw	r2,-23692(gp)
    db7c:	1100040b 	ldhu	r4,16(r2)
    db80:	1080048b 	ldhu	r2,18(r2)
    db84:	1004943a 	slli	r2,r2,16
    db88:	1104b03a 	or	r2,r2,r4

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
    db8c:	18801b1e 	bne	r3,r2,dbfc <tcp_input+0x8ec>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
        lpcb->local_port == tcphdr->dest) {
    db90:	e0bffc17 	ldw	r2,-16(fp)
    db94:	10c0070b 	ldhu	r3,28(r2)
    db98:	d0a8dc17 	ldw	r2,-23696(gp)
    db9c:	1080008b 	ldhu	r2,2(r2)
  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
    dba0:	18ffffcc 	andi	r3,r3,65535
    dba4:	10bfffcc 	andi	r2,r2,65535
    dba8:	1880141e 	bne	r3,r2,dbfc <tcp_input+0x8ec>
        lpcb->local_port == tcphdr->dest) {
        /* Move this PCB to the front of the list so that subsequent
           lookups will be faster (we exploit locality in TCP segment
           arrivals). */
        if (prev != NULL) {
    dbac:	e0bffb17 	ldw	r2,-20(fp)
    dbb0:	10000d26 	beq	r2,zero,dbe8 <tcp_input+0x8d8>
          ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
    dbb4:	e0bffc17 	ldw	r2,-16(fp)
    dbb8:	10c00317 	ldw	r3,12(r2)
    dbbc:	e0bffb17 	ldw	r2,-20(fp)
    dbc0:	10c00315 	stw	r3,12(r2)
                /* our successor is the remainder of the listening list */
          lpcb->next = tcp_listen_pcbs.listen_pcbs;
    dbc4:	008000f4 	movhi	r2,3
    dbc8:	1095f804 	addi	r2,r2,22496
    dbcc:	10c00017 	ldw	r3,0(r2)
    dbd0:	e0bffc17 	ldw	r2,-16(fp)
    dbd4:	10c00315 	stw	r3,12(r2)
                /* put this listening pcb at the head of the listening list */
          tcp_listen_pcbs.listen_pcbs = lpcb;
    dbd8:	008000f4 	movhi	r2,3
    dbdc:	1095f804 	addi	r2,r2,22496
    dbe0:	e0fffc17 	ldw	r3,-16(fp)
    dbe4:	10c00015 	stw	r3,0(r2)
        }
      
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
        tcp_listen_input(lpcb);
    dbe8:	e13ffc17 	ldw	r4,-16(fp)
    dbec:	000e0440 	call	e044 <tcp_listen_input>
        pbuf_free(p);
    dbf0:	e13ffe17 	ldw	r4,-8(fp)
    dbf4:	000a16c0 	call	a16c <pbuf_free>
        return;
    dbf8:	00010d06 	br	e030 <tcp_input+0xd20>
      }
      prev = (struct tcp_pcb *)lpcb;
    dbfc:	e0bffc17 	ldw	r2,-16(fp)
    dc00:	e0bffb15 	stw	r2,-20(fp)
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    dc04:	e0bffc17 	ldw	r2,-16(fp)
    dc08:	10800317 	ldw	r2,12(r2)
    dc0c:	e0bffc15 	stw	r2,-16(fp)
    dc10:	e0bffc17 	ldw	r2,-16(fp)
    dc14:	103fd11e 	bne	r2,zero,db5c <tcp_input+0x84c>
  tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"));
#endif /* TCP_INPUT_DEBUG */


  if (pcb != NULL) {
    dc18:	e0bffa17 	ldw	r2,-24(fp)
    dc1c:	1000d126 	beq	r2,zero,df64 <tcp_input+0xc54>
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
    dc20:	00800134 	movhi	r2,4
    dc24:	108cfa04 	addi	r2,r2,13288
    dc28:	10000015 	stw	zero,0(r2)
    inseg.len = p->tot_len;
    dc2c:	e0bffe17 	ldw	r2,-8(fp)
    dc30:	10c0020b 	ldhu	r3,8(r2)
    dc34:	00800134 	movhi	r2,4
    dc38:	108cfa04 	addi	r2,r2,13288
    dc3c:	10c0030d 	sth	r3,12(r2)
    inseg.dataptr = p->payload;
    dc40:	e0bffe17 	ldw	r2,-8(fp)
    dc44:	10c00117 	ldw	r3,4(r2)
    dc48:	00800134 	movhi	r2,4
    dc4c:	108cfa04 	addi	r2,r2,13288
    dc50:	10c00215 	stw	r3,8(r2)
    inseg.p = p;
    dc54:	00800134 	movhi	r2,4
    dc58:	108cfa04 	addi	r2,r2,13288
    dc5c:	e0fffe17 	ldw	r3,-8(fp)
    dc60:	10c00115 	stw	r3,4(r2)
    inseg.tcphdr = tcphdr;
    dc64:	d0e8dc17 	ldw	r3,-23696(gp)
    dc68:	00800134 	movhi	r2,4
    dc6c:	108cfa04 	addi	r2,r2,13288
    dc70:	10c00415 	stw	r3,16(r2)

    recv_data = NULL;
    dc74:	d028e215 	stw	zero,-23672(gp)
    recv_flags = 0;
    dc78:	d028e105 	stb	zero,-23676(gp)

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
    dc7c:	e0bffa17 	ldw	r2,-24(fp)
    dc80:	10802117 	ldw	r2,132(r2)
    dc84:	10002826 	beq	r2,zero,dd28 <tcp_input+0xa18>
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
    dc88:	e0bffa17 	ldw	r2,-24(fp)
    dc8c:	10802317 	ldw	r2,140(r2)
    dc90:	10000d26 	beq	r2,zero,dcc8 <tcp_input+0x9b8>
    dc94:	e0bffa17 	ldw	r2,-24(fp)
    dc98:	12002317 	ldw	r8,140(r2)
    dc9c:	e0bffa17 	ldw	r2,-24(fp)
    dca0:	10c00617 	ldw	r3,24(r2)
    dca4:	e0bffa17 	ldw	r2,-24(fp)
    dca8:	10802117 	ldw	r2,132(r2)
    dcac:	1809883a 	mov	r4,r3
    dcb0:	e17ffa17 	ldw	r5,-24(fp)
    dcb4:	100d883a 	mov	r6,r2
    dcb8:	000f883a 	mov	r7,zero
    dcbc:	403ee83a 	callr	r8
    dcc0:	e0bffd05 	stb	r2,-12(fp)
    dcc4:	00000806 	br	dce8 <tcp_input+0x9d8>
    dcc8:	e0bffa17 	ldw	r2,-24(fp)
    dccc:	10802117 	ldw	r2,132(r2)
    dcd0:	0009883a 	mov	r4,zero
    dcd4:	e17ffa17 	ldw	r5,-24(fp)
    dcd8:	100d883a 	mov	r6,r2
    dcdc:	000f883a 	mov	r7,zero
    dce0:	000ca7c0 	call	ca7c <tcp_recv_null>
    dce4:	e0bffd05 	stb	r2,-12(fp)
      if (err == ERR_OK) {
    dce8:	e0bffd07 	ldb	r2,-12(fp)
    dcec:	1000031e 	bne	r2,zero,dcfc <tcp_input+0x9ec>
        pcb->refused_data = NULL;
    dcf0:	e0bffa17 	ldw	r2,-24(fp)
    dcf4:	10002115 	stw	zero,132(r2)
    dcf8:	00000b06 	br	dd28 <tcp_input+0xa18>
      } else {
        /* drop incoming packets, because pcb is "full" */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
        TCP_STATS_INC(tcp.drop);
    dcfc:	00800134 	movhi	r2,4
    dd00:	108d9504 	addi	r2,r2,13908
    dd04:	1080258b 	ldhu	r2,150(r2)
    dd08:	10800044 	addi	r2,r2,1
    dd0c:	1007883a 	mov	r3,r2
    dd10:	00800134 	movhi	r2,4
    dd14:	108d9504 	addi	r2,r2,13908
    dd18:	10c0258d 	sth	r3,150(r2)
        snmp_inc_tcpinerrs();
        pbuf_free(p);
    dd1c:	e13ffe17 	ldw	r4,-8(fp)
    dd20:	000a16c0 	call	a16c <pbuf_free>
        return;
    dd24:	0000c206 	br	e030 <tcp_input+0xd20>
      }
    }
    tcp_input_pcb = pcb;
    dd28:	e0bffa17 	ldw	r2,-24(fp)
    dd2c:	d0a8e315 	stw	r2,-23668(gp)
    err = tcp_process(pcb);
    dd30:	e13ffa17 	ldw	r4,-24(fp)
    dd34:	000e41c0 	call	e41c <tcp_process>
    dd38:	e0bffd05 	stb	r2,-12(fp)
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
    dd3c:	e0bffd07 	ldb	r2,-12(fp)
    dd40:	10bffee0 	cmpeqi	r2,r2,-5
    dd44:	1000791e 	bne	r2,zero,df2c <tcp_input+0xc1c>
      if (recv_flags & TF_RESET) {
    dd48:	d0a8e103 	ldbu	r2,-23676(gp)
    dd4c:	10803fcc 	andi	r2,r2,255
    dd50:	1080020c 	andi	r2,r2,8
    dd54:	10001226 	beq	r2,zero,dda0 <tcp_input+0xa90>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
    dd58:	e0bffa17 	ldw	r2,-24(fp)
    dd5c:	10802617 	ldw	r2,152(r2)
    dd60:	10000726 	beq	r2,zero,dd80 <tcp_input+0xa70>
    dd64:	e0bffa17 	ldw	r2,-24(fp)
    dd68:	10c02617 	ldw	r3,152(r2)
    dd6c:	e0bffa17 	ldw	r2,-24(fp)
    dd70:	10800617 	ldw	r2,24(r2)
    dd74:	1009883a 	mov	r4,r2
    dd78:	017ffe84 	movi	r5,-6
    dd7c:	183ee83a 	callr	r3
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
    dd80:	010000f4 	movhi	r4,3
    dd84:	2115f604 	addi	r4,r4,22488
    dd88:	e17ffa17 	ldw	r5,-24(fp)
    dd8c:	000d0780 	call	d078 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
    dd90:	01000084 	movi	r4,2
    dd94:	e17ffa17 	ldw	r5,-24(fp)
    dd98:	00090cc0 	call	90cc <memp_free>
    dd9c:	00006306 	br	df2c <tcp_input+0xc1c>
      } else if (recv_flags & TF_CLOSED) {
    dda0:	d0a8e103 	ldbu	r2,-23676(gp)
    dda4:	10803fcc 	andi	r2,r2,255
    dda8:	1080040c 	andi	r2,r2,16
    ddac:	10000826 	beq	r2,zero,ddd0 <tcp_input+0xac0>
        /* The connection has been closed and we will deallocate the
           PCB. */
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
    ddb0:	010000f4 	movhi	r4,3
    ddb4:	2115f604 	addi	r4,r4,22488
    ddb8:	e17ffa17 	ldw	r5,-24(fp)
    ddbc:	000d0780 	call	d078 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
    ddc0:	01000084 	movi	r4,2
    ddc4:	e17ffa17 	ldw	r5,-24(fp)
    ddc8:	00090cc0 	call	90cc <memp_free>
    ddcc:	00005706 	br	df2c <tcp_input+0xc1c>
      } else {
        err = ERR_OK;
    ddd0:	e03ffd05 	stb	zero,-12(fp)
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
    ddd4:	e0bffa17 	ldw	r2,-24(fp)
    ddd8:	10801c0b 	ldhu	r2,112(r2)
    dddc:	10bfffcc 	andi	r2,r2,65535
    dde0:	10001126 	beq	r2,zero,de28 <tcp_input+0xb18>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
    dde4:	e0bffa17 	ldw	r2,-24(fp)
    dde8:	10802217 	ldw	r2,136(r2)
    ddec:	10000d26 	beq	r2,zero,de24 <tcp_input+0xb14>
    ddf0:	e0bffa17 	ldw	r2,-24(fp)
    ddf4:	11c02217 	ldw	r7,136(r2)
    ddf8:	e0bffa17 	ldw	r2,-24(fp)
    ddfc:	10c00617 	ldw	r3,24(r2)
    de00:	e0bffa17 	ldw	r2,-24(fp)
    de04:	10801c0b 	ldhu	r2,112(r2)
    de08:	10bfffcc 	andi	r2,r2,65535
    de0c:	1809883a 	mov	r4,r3
    de10:	e17ffa17 	ldw	r5,-24(fp)
    de14:	100d883a 	mov	r6,r2
    de18:	383ee83a 	callr	r7
    de1c:	e0bffd05 	stb	r2,-12(fp)
    de20:	00000106 	br	de28 <tcp_input+0xb18>
    de24:	e03ffd05 	stb	zero,-12(fp)
        }
      
        if (recv_data != NULL) {
    de28:	d0a8e217 	ldw	r2,-23672(gp)
    de2c:	10002426 	beq	r2,zero,dec0 <tcp_input+0xbb0>
          if(flags & TCP_PSH) {
    de30:	d0a8e003 	ldbu	r2,-23680(gp)
    de34:	10803fcc 	andi	r2,r2,255
    de38:	1080020c 	andi	r2,r2,8
    de3c:	10000526 	beq	r2,zero,de54 <tcp_input+0xb44>
            recv_data->flags |= PBUF_FLAG_PUSH;
    de40:	d0a8e217 	ldw	r2,-23672(gp)
    de44:	d0e8e217 	ldw	r3,-23672(gp)
    de48:	18c00343 	ldbu	r3,13(r3)
    de4c:	18c00054 	ori	r3,r3,1
    de50:	10c00345 	stb	r3,13(r2)
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
    de54:	e0bffa17 	ldw	r2,-24(fp)
    de58:	10802317 	ldw	r2,140(r2)
    de5c:	10000c26 	beq	r2,zero,de90 <tcp_input+0xb80>
    de60:	e0bffa17 	ldw	r2,-24(fp)
    de64:	12002317 	ldw	r8,140(r2)
    de68:	e0bffa17 	ldw	r2,-24(fp)
    de6c:	10c00617 	ldw	r3,24(r2)
    de70:	d0a8e217 	ldw	r2,-23672(gp)
    de74:	1809883a 	mov	r4,r3
    de78:	e17ffa17 	ldw	r5,-24(fp)
    de7c:	100d883a 	mov	r6,r2
    de80:	000f883a 	mov	r7,zero
    de84:	403ee83a 	callr	r8
    de88:	e0bffd05 	stb	r2,-12(fp)
    de8c:	00000706 	br	deac <tcp_input+0xb9c>
    de90:	d0a8e217 	ldw	r2,-23672(gp)
    de94:	0009883a 	mov	r4,zero
    de98:	e17ffa17 	ldw	r5,-24(fp)
    de9c:	100d883a 	mov	r6,r2
    dea0:	000f883a 	mov	r7,zero
    dea4:	000ca7c0 	call	ca7c <tcp_recv_null>
    dea8:	e0bffd05 	stb	r2,-12(fp)

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
    deac:	e0bffd07 	ldb	r2,-12(fp)
    deb0:	10000326 	beq	r2,zero,dec0 <tcp_input+0xbb0>
            pcb->refused_data = recv_data;
    deb4:	d0e8e217 	ldw	r3,-23672(gp)
    deb8:	e0bffa17 	ldw	r2,-24(fp)
    debc:	10c02115 	stw	r3,132(r2)
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
    dec0:	d0a8e103 	ldbu	r2,-23676(gp)
    dec4:	10803fcc 	andi	r2,r2,255
    dec8:	1080080c 	andi	r2,r2,32
    decc:	10001426 	beq	r2,zero,df20 <tcp_input+0xc10>
          TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
    ded0:	e0bffa17 	ldw	r2,-24(fp)
    ded4:	10802317 	ldw	r2,140(r2)
    ded8:	10000b26 	beq	r2,zero,df08 <tcp_input+0xbf8>
    dedc:	e0bffa17 	ldw	r2,-24(fp)
    dee0:	10c02317 	ldw	r3,140(r2)
    dee4:	e0bffa17 	ldw	r2,-24(fp)
    dee8:	10800617 	ldw	r2,24(r2)
    deec:	1009883a 	mov	r4,r2
    def0:	e17ffa17 	ldw	r5,-24(fp)
    def4:	000d883a 	mov	r6,zero
    def8:	000f883a 	mov	r7,zero
    defc:	183ee83a 	callr	r3
    df00:	e0bffd05 	stb	r2,-12(fp)
    df04:	00000606 	br	df20 <tcp_input+0xc10>
    df08:	0009883a 	mov	r4,zero
    df0c:	e17ffa17 	ldw	r5,-24(fp)
    df10:	000d883a 	mov	r6,zero
    df14:	000f883a 	mov	r7,zero
    df18:	000ca7c0 	call	ca7c <tcp_recv_null>
    df1c:	e0bffd05 	stb	r2,-12(fp)
        }

        tcp_input_pcb = NULL;
    df20:	d028e315 	stw	zero,-23668(gp)
        /* Try to send something out. */
        tcp_output(pcb);
    df24:	e13ffa17 	ldw	r4,-24(fp)
    df28:	00122380 	call	12238 <tcp_output>
        tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */
      }
    }
    tcp_input_pcb = NULL;
    df2c:	d028e315 	stw	zero,-23668(gp)


    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
    df30:	00800134 	movhi	r2,4
    df34:	108cfa04 	addi	r2,r2,13288
    df38:	10800117 	ldw	r2,4(r2)
    df3c:	10003c26 	beq	r2,zero,e030 <tcp_input+0xd20>
    {
      pbuf_free(inseg.p);
    df40:	00800134 	movhi	r2,4
    df44:	108cfa04 	addi	r2,r2,13288
    df48:	10800117 	ldw	r2,4(r2)
    df4c:	1009883a 	mov	r4,r2
    df50:	000a16c0 	call	a16c <pbuf_free>
      inseg.p = NULL;
    df54:	00800134 	movhi	r2,4
    df58:	108cfa04 	addi	r2,r2,13288
    df5c:	10000115 	stw	zero,4(r2)
    df60:	00003306 	br	e030 <tcp_input+0xd20>
  } else {

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
    df64:	d0a8dc17 	ldw	r2,-23696(gp)
    df68:	1080030b 	ldhu	r2,12(r2)
    df6c:	10bfffcc 	andi	r2,r2,65535
    df70:	1004d23a 	srli	r2,r2,8
    df74:	10ffffcc 	andi	r3,r2,65535
    df78:	d0a8dc17 	ldw	r2,-23696(gp)
    df7c:	1080030b 	ldhu	r2,12(r2)
    df80:	10bfffcc 	andi	r2,r2,65535
    df84:	1004923a 	slli	r2,r2,8
    df88:	10bfffcc 	andi	r2,r2,65535
    df8c:	1884b03a 	or	r2,r3,r2
    df90:	1080010c 	andi	r2,r2,4
    df94:	1000241e 	bne	r2,zero,e028 <tcp_input+0xd18>
      TCP_STATS_INC(tcp.proterr);
    df98:	00800134 	movhi	r2,4
    df9c:	108d9504 	addi	r2,r2,13908
    dfa0:	1080280b 	ldhu	r2,160(r2)
    dfa4:	10800044 	addi	r2,r2,1
    dfa8:	1007883a 	mov	r3,r2
    dfac:	00800134 	movhi	r2,4
    dfb0:	108d9504 	addi	r2,r2,13908
    dfb4:	10c0280d 	sth	r3,160(r2)
      TCP_STATS_INC(tcp.drop);
    dfb8:	00800134 	movhi	r2,4
    dfbc:	108d9504 	addi	r2,r2,13908
    dfc0:	1080258b 	ldhu	r2,150(r2)
    dfc4:	10800044 	addi	r2,r2,1
    dfc8:	1007883a 	mov	r3,r2
    dfcc:	00800134 	movhi	r2,4
    dfd0:	108d9504 	addi	r2,r2,13908
    dfd4:	10c0258d 	sth	r3,150(r2)
      tcp_rst(ackno, seqno + tcplen,
    dfd8:	d128df17 	ldw	r4,-23684(gp)
    dfdc:	d0a8e08b 	ldhu	r2,-23678(gp)
    dfe0:	10ffffcc 	andi	r3,r2,65535
    dfe4:	d0a8de17 	ldw	r2,-23688(gp)
    dfe8:	188b883a 	add	r5,r3,r2
        &(iphdr->dest), &(iphdr->src),
    dfec:	d0a8dd17 	ldw	r2,-23692(gp)
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
    dff0:	10c00404 	addi	r3,r2,16
        &(iphdr->dest), &(iphdr->src),
    dff4:	d0a8dd17 	ldw	r2,-23692(gp)
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
    dff8:	10800304 	addi	r2,r2,12
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    dffc:	d1a8dc17 	ldw	r6,-23696(gp)
    e000:	3180008b 	ldhu	r6,2(r6)
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
    e004:	31ffffcc 	andi	r7,r6,65535
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    e008:	d1a8dc17 	ldw	r6,-23696(gp)
    e00c:	3180000b 	ldhu	r6,0(r6)
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
    e010:	31bfffcc 	andi	r6,r6,65535
    e014:	d9c00015 	stw	r7,0(sp)
    e018:	d9800115 	stw	r6,4(sp)
    e01c:	180d883a 	mov	r6,r3
    e020:	100f883a 	mov	r7,r2
    e024:	0012e5c0 	call	12e5c <tcp_rst>
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    pbuf_free(p);
    e028:	e13ffe17 	ldw	r4,-8(fp)
    e02c:	000a16c0 	call	a16c <pbuf_free>
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
}
    e030:	e037883a 	mov	sp,fp
    e034:	dfc00117 	ldw	ra,4(sp)
    e038:	df000017 	ldw	fp,0(sp)
    e03c:	dec00204 	addi	sp,sp,8
    e040:	f800283a 	ret

0000e044 <tcp_listen_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_listen_input(struct tcp_pcb_listen *pcb)
{
    e044:	defff904 	addi	sp,sp,-28
    e048:	dfc00615 	stw	ra,24(sp)
    e04c:	df000515 	stw	fp,20(sp)
    e050:	df000504 	addi	fp,sp,20
    e054:	e13fff15 	stw	r4,-4(fp)
  struct tcp_pcb *npcb;
  err_t rc;

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    e058:	d0a8e003 	ldbu	r2,-23680(gp)
    e05c:	10803fcc 	andi	r2,r2,255
    e060:	1080040c 	andi	r2,r2,16
    e064:	10001626 	beq	r2,zero,e0c0 <tcp_listen_input+0x7c>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
    e068:	d0a8df17 	ldw	r2,-23684(gp)
    e06c:	11000044 	addi	r4,r2,1
    e070:	d0a8e08b 	ldhu	r2,-23678(gp)
    e074:	10ffffcc 	andi	r3,r2,65535
    e078:	d0a8de17 	ldw	r2,-23688(gp)
    e07c:	188b883a 	add	r5,r3,r2
      &(iphdr->dest), &(iphdr->src),
    e080:	d0a8dd17 	ldw	r2,-23692(gp)
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
    e084:	10c00404 	addi	r3,r2,16
      &(iphdr->dest), &(iphdr->src),
    e088:	d0a8dd17 	ldw	r2,-23692(gp)
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
    e08c:	10800304 	addi	r2,r2,12
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
    e090:	d1a8dc17 	ldw	r6,-23696(gp)
    e094:	3180008b 	ldhu	r6,2(r6)
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
    e098:	31ffffcc 	andi	r7,r6,65535
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
    e09c:	d1a8dc17 	ldw	r6,-23696(gp)
    e0a0:	3180000b 	ldhu	r6,0(r6)
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
    e0a4:	31bfffcc 	andi	r6,r6,65535
    e0a8:	d9c00015 	stw	r7,0(sp)
    e0ac:	d9800115 	stw	r6,4(sp)
    e0b0:	180d883a 	mov	r6,r3
    e0b4:	100f883a 	mov	r7,r2
    e0b8:	0012e5c0 	call	12e5c <tcp_rst>
    e0bc:	00008306 	br	e2cc <tcp_listen_input+0x288>
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  } else if (flags & TCP_SYN) {
    e0c0:	d0a8e003 	ldbu	r2,-23680(gp)
    e0c4:	10803fcc 	andi	r2,r2,255
    e0c8:	1080008c 	andi	r2,r2,2
    e0cc:	10007f26 	beq	r2,zero,e2cc <tcp_listen_input+0x288>
    if (pcb->accepts_pending >= pcb->backlog) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: listen backlog exceeded for port %"U16_F"\n", tcphdr->dest));
      return ERR_ABRT;
    }
#endif /* TCP_LISTEN_BACKLOG */
    npcb = tcp_alloc(pcb->prio);
    e0d0:	e0bfff17 	ldw	r2,-4(fp)
    e0d4:	10800503 	ldbu	r2,20(r2)
    e0d8:	10803fcc 	andi	r2,r2,255
    e0dc:	1009883a 	mov	r4,r2
    e0e0:	000cc640 	call	cc64 <tcp_alloc>
    e0e4:	e0bffd15 	stw	r2,-12(fp)
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
    e0e8:	e0bffd17 	ldw	r2,-12(fp)
    e0ec:	10000a1e 	bne	r2,zero,e118 <tcp_listen_input+0xd4>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: could not allocate PCB\n"));
      TCP_STATS_INC(tcp.memerr);
    e0f0:	00800134 	movhi	r2,4
    e0f4:	108d9504 	addi	r2,r2,13908
    e0f8:	1080270b 	ldhu	r2,156(r2)
    e0fc:	10800044 	addi	r2,r2,1
    e100:	1007883a 	mov	r3,r2
    e104:	00800134 	movhi	r2,4
    e108:	108d9504 	addi	r2,r2,13908
    e10c:	10c0270d 	sth	r3,156(r2)
      return ERR_MEM;
    e110:	00bfffc4 	movi	r2,-1
    e114:	00006e06 	br	e2d0 <tcp_listen_input+0x28c>
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
    e118:	d0a8dd17 	ldw	r2,-23692(gp)
    e11c:	10800404 	addi	r2,r2,16
    e120:	10000626 	beq	r2,zero,e13c <tcp_listen_input+0xf8>
    e124:	d0a8dd17 	ldw	r2,-23692(gp)
    e128:	10c0040b 	ldhu	r3,16(r2)
    e12c:	1080048b 	ldhu	r2,18(r2)
    e130:	1004943a 	slli	r2,r2,16
    e134:	10c4b03a 	or	r2,r2,r3
    e138:	00000106 	br	e140 <tcp_listen_input+0xfc>
    e13c:	0005883a 	mov	r2,zero
    e140:	e0fffd17 	ldw	r3,-12(fp)
    e144:	18800015 	stw	r2,0(r3)
    npcb->local_port = pcb->local_port;
    e148:	e0bfff17 	ldw	r2,-4(fp)
    e14c:	10c0070b 	ldhu	r3,28(r2)
    e150:	e0bffd17 	ldw	r2,-12(fp)
    e154:	10c0070d 	sth	r3,28(r2)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
    e158:	d0a8dd17 	ldw	r2,-23692(gp)
    e15c:	10800304 	addi	r2,r2,12
    e160:	10000626 	beq	r2,zero,e17c <tcp_listen_input+0x138>
    e164:	d0a8dd17 	ldw	r2,-23692(gp)
    e168:	10c0030b 	ldhu	r3,12(r2)
    e16c:	1080038b 	ldhu	r2,14(r2)
    e170:	1004943a 	slli	r2,r2,16
    e174:	10c4b03a 	or	r2,r2,r3
    e178:	00000106 	br	e180 <tcp_listen_input+0x13c>
    e17c:	0005883a 	mov	r2,zero
    e180:	e0fffd17 	ldw	r3,-12(fp)
    e184:	18800115 	stw	r2,4(r3)
    npcb->remote_port = tcphdr->src;
    e188:	d0a8dc17 	ldw	r2,-23696(gp)
    e18c:	10c0000b 	ldhu	r3,0(r2)
    e190:	e0bffd17 	ldw	r2,-12(fp)
    e194:	10c0090d 	sth	r3,36(r2)
    npcb->state = SYN_RCVD;
    e198:	e0bffd17 	ldw	r2,-12(fp)
    e19c:	00c000c4 	movi	r3,3
    e1a0:	10c00415 	stw	r3,16(r2)
    npcb->rcv_nxt = seqno + 1;
    e1a4:	d0a8de17 	ldw	r2,-23688(gp)
    e1a8:	10c00044 	addi	r3,r2,1
    e1ac:	e0bffd17 	ldw	r2,-12(fp)
    e1b0:	10c00a15 	stw	r3,40(r2)
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
    e1b4:	e0bffd17 	ldw	r2,-12(fp)
    e1b8:	10c00a17 	ldw	r3,40(r2)
    e1bc:	e0bffd17 	ldw	r2,-12(fp)
    e1c0:	10c00c15 	stw	r3,48(r2)
    npcb->snd_wnd = tcphdr->wnd;
    e1c4:	d0a8dc17 	ldw	r2,-23696(gp)
    e1c8:	10c0038b 	ldhu	r3,14(r2)
    e1cc:	e0bffd17 	ldw	r2,-12(fp)
    e1d0:	10c0180d 	sth	r3,96(r2)
    npcb->ssthresh = npcb->snd_wnd;
    e1d4:	e0bffd17 	ldw	r2,-12(fp)
    e1d8:	10c0180b 	ldhu	r3,96(r2)
    e1dc:	e0bffd17 	ldw	r2,-12(fp)
    e1e0:	10c0160d 	sth	r3,88(r2)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
    e1e4:	d0a8de17 	ldw	r2,-23688(gp)
    e1e8:	10ffffc4 	addi	r3,r2,-1
    e1ec:	e0bffd17 	ldw	r2,-12(fp)
    e1f0:	10c01915 	stw	r3,100(r2)
    npcb->callback_arg = pcb->callback_arg;
    e1f4:	e0bfff17 	ldw	r2,-4(fp)
    e1f8:	10c00617 	ldw	r3,24(r2)
    e1fc:	e0bffd17 	ldw	r2,-12(fp)
    e200:	10c00615 	stw	r3,24(r2)
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
    e204:	e0bfff17 	ldw	r2,-4(fp)
    e208:	10c00817 	ldw	r3,32(r2)
    e20c:	e0bffd17 	ldw	r2,-12(fp)
    e210:	10c00815 	stw	r3,32(r2)
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
    e214:	e0bfff17 	ldw	r2,-4(fp)
    e218:	1080020b 	ldhu	r2,8(r2)
    e21c:	1080664c 	andi	r2,r2,409
    e220:	1007883a 	mov	r3,r2
    e224:	e0bffd17 	ldw	r2,-12(fp)
    e228:	10c0020d 	sth	r3,8(r2)
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG(&tcp_active_pcbs, npcb);
    e22c:	008000f4 	movhi	r2,3
    e230:	1095f604 	addi	r2,r2,22488
    e234:	10c00017 	ldw	r3,0(r2)
    e238:	e0bffd17 	ldw	r2,-12(fp)
    e23c:	10c00315 	stw	r3,12(r2)
    e240:	008000f4 	movhi	r2,3
    e244:	1095f604 	addi	r2,r2,22488
    e248:	e0fffd17 	ldw	r3,-12(fp)
    e24c:	10c00015 	stw	r3,0(r2)

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
    e250:	e13ffd17 	ldw	r4,-12(fp)
    e254:	0010dfc0 	call	10dfc <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
    e258:	e0bffd17 	ldw	r2,-12(fp)
    e25c:	10800f0b 	ldhu	r2,60(r2)
    e260:	10ffffcc 	andi	r3,r2,65535
    e264:	e0bffd17 	ldw	r2,-12(fp)
    e268:	10800104 	addi	r2,r2,4
    e26c:	1809883a 	mov	r4,r3
    e270:	100b883a 	mov	r5,r2
    e274:	000d2500 	call	d250 <tcp_eff_send_mss>
    e278:	e0fffd17 	ldw	r3,-12(fp)
    e27c:	18800f0d 	sth	r2,60(r3)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Send a SYN|ACK together with the MSS option. */
    rc = tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, TF_SEG_OPTS_MSS
    e280:	d8000015 	stw	zero,0(sp)
    e284:	00800044 	movi	r2,1
    e288:	d8800115 	stw	r2,4(sp)
    e28c:	e13ffd17 	ldw	r4,-12(fp)
    e290:	000b883a 	mov	r5,zero
    e294:	000d883a 	mov	r6,zero
    e298:	01c00484 	movi	r7,18
    e29c:	00113880 	call	11388 <tcp_enqueue>
    e2a0:	e0bffe05 	stb	r2,-8(fp)
#if LWIP_TCP_TIMESTAMPS
      /* and maybe include the TIMESTAMP option */
     | (npcb->flags & TF_TIMESTAMP ? TF_SEG_OPTS_TS : 0)
#endif
      );
    if (rc != ERR_OK) {
    e2a4:	e0bffe07 	ldb	r2,-8(fp)
    e2a8:	10000526 	beq	r2,zero,e2c0 <tcp_listen_input+0x27c>
      tcp_abandon(npcb, 0);
    e2ac:	e13ffd17 	ldw	r4,-12(fp)
    e2b0:	000b883a 	mov	r5,zero
    e2b4:	000b4680 	call	b468 <tcp_abandon>
      return rc;
    e2b8:	e0bffe03 	ldbu	r2,-8(fp)
    e2bc:	00000406 	br	e2d0 <tcp_listen_input+0x28c>
    }
    return tcp_output(npcb);
    e2c0:	e13ffd17 	ldw	r4,-12(fp)
    e2c4:	00122380 	call	12238 <tcp_output>
    e2c8:	00000106 	br	e2d0 <tcp_listen_input+0x28c>
  }
  return ERR_OK;
    e2cc:	0005883a 	mov	r2,zero
}
    e2d0:	e037883a 	mov	sp,fp
    e2d4:	dfc00117 	ldw	ra,4(sp)
    e2d8:	df000017 	ldw	fp,0(sp)
    e2dc:	dec00204 	addi	sp,sp,8
    e2e0:	f800283a 	ret

0000e2e4 <tcp_timewait_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_timewait_input(struct tcp_pcb *pcb)
{
    e2e4:	defffb04 	addi	sp,sp,-20
    e2e8:	dfc00415 	stw	ra,16(sp)
    e2ec:	df000315 	stw	fp,12(sp)
    e2f0:	df000304 	addi	fp,sp,12
    e2f4:	e13fff15 	stw	r4,-4(fp)
  /* RFC 1337: in TIME_WAIT, ignore RST and ACK FINs + any 'acceptable' segments */
  /* RFC 793 3.9 Event Processing - Segment Arrives:
   * - first check sequence number - we skip that one in TIME_WAIT (always
   *   acceptable since we only send ACKs)
   * - second check the RST bit (... return) */
  if (flags & TCP_RST)  {
    e2f8:	d0a8e003 	ldbu	r2,-23680(gp)
    e2fc:	10803fcc 	andi	r2,r2,255
    e300:	1080010c 	andi	r2,r2,4
    e304:	10000226 	beq	r2,zero,e310 <tcp_timewait_input+0x2c>
    return ERR_OK;
    e308:	0005883a 	mov	r2,zero
    e30c:	00003e06 	br	e408 <tcp_timewait_input+0x124>
  }
  /* - fourth, check the SYN bit, */
  if (flags & TCP_SYN) {
    e310:	d0a8e003 	ldbu	r2,-23680(gp)
    e314:	10803fcc 	andi	r2,r2,255
    e318:	1080008c 	andi	r2,r2,2
    e31c:	10002426 	beq	r2,zero,e3b0 <tcp_timewait_input+0xcc>
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
    e320:	d0e8de17 	ldw	r3,-23688(gp)
    e324:	e0bfff17 	ldw	r2,-4(fp)
    e328:	10800a17 	ldw	r2,40(r2)
    e32c:	1885c83a 	sub	r2,r3,r2
    e330:	10002816 	blt	r2,zero,e3d4 <tcp_timewait_input+0xf0>
    e334:	d0e8de17 	ldw	r3,-23688(gp)
    e338:	e0bfff17 	ldw	r2,-4(fp)
    e33c:	11000a17 	ldw	r4,40(r2)
    e340:	e0bfff17 	ldw	r2,-4(fp)
    e344:	10800b0b 	ldhu	r2,44(r2)
    e348:	10bfffcc 	andi	r2,r2,65535
    e34c:	2085883a 	add	r2,r4,r2
    e350:	1885c83a 	sub	r2,r3,r2
    e354:	00801f16 	blt	zero,r2,e3d4 <tcp_timewait_input+0xf0>
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
    e358:	d128df17 	ldw	r4,-23684(gp)
    e35c:	d0a8e08b 	ldhu	r2,-23678(gp)
    e360:	10ffffcc 	andi	r3,r2,65535
    e364:	d0a8de17 	ldw	r2,-23688(gp)
    e368:	188b883a 	add	r5,r3,r2
    e36c:	d0a8dd17 	ldw	r2,-23692(gp)
    e370:	10c00404 	addi	r3,r2,16
    e374:	d0a8dd17 	ldw	r2,-23692(gp)
    e378:	10800304 	addi	r2,r2,12
        tcphdr->dest, tcphdr->src);
    e37c:	d1a8dc17 	ldw	r6,-23696(gp)
    e380:	3180008b 	ldhu	r6,2(r6)
  if (flags & TCP_SYN) {
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
    e384:	31ffffcc 	andi	r7,r6,65535
        tcphdr->dest, tcphdr->src);
    e388:	d1a8dc17 	ldw	r6,-23696(gp)
    e38c:	3180000b 	ldhu	r6,0(r6)
  if (flags & TCP_SYN) {
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
    e390:	31bfffcc 	andi	r6,r6,65535
    e394:	d9c00015 	stw	r7,0(sp)
    e398:	d9800115 	stw	r6,4(sp)
    e39c:	180d883a 	mov	r6,r3
    e3a0:	100f883a 	mov	r7,r2
    e3a4:	0012e5c0 	call	12e5c <tcp_rst>
        tcphdr->dest, tcphdr->src);
      return ERR_OK;
    e3a8:	0005883a 	mov	r2,zero
    e3ac:	00001606 	br	e408 <tcp_timewait_input+0x124>
    }
  } else if (flags & TCP_FIN) {
    e3b0:	d0a8e003 	ldbu	r2,-23680(gp)
    e3b4:	10803fcc 	andi	r2,r2,255
    e3b8:	1080004c 	andi	r2,r2,1
    e3bc:	10000526 	beq	r2,zero,e3d4 <tcp_timewait_input+0xf0>
    /* - eighth, check the FIN bit: Remain in the TIME-WAIT state.
         Restart the 2 MSL time-wait timeout.*/
    pcb->tmr = tcp_ticks;
    e3c0:	008000f4 	movhi	r2,3
    e3c4:	1095f704 	addi	r2,r2,22492
    e3c8:	10c00017 	ldw	r3,0(r2)
    e3cc:	e0bfff17 	ldw	r2,-4(fp)
    e3d0:	10c00d15 	stw	r3,52(r2)
  }

  if ((tcplen > 0))  {
    e3d4:	d0a8e08b 	ldhu	r2,-23678(gp)
    e3d8:	10bfffcc 	andi	r2,r2,65535
    e3dc:	10000926 	beq	r2,zero,e404 <tcp_timewait_input+0x120>
    /* Acknowledge data, FIN or out-of-window SYN */
    pcb->flags |= TF_ACK_NOW;
    e3e0:	e0bfff17 	ldw	r2,-4(fp)
    e3e4:	10800983 	ldbu	r2,38(r2)
    e3e8:	10800094 	ori	r2,r2,2
    e3ec:	1007883a 	mov	r3,r2
    e3f0:	e0bfff17 	ldw	r2,-4(fp)
    e3f4:	10c00985 	stb	r3,38(r2)
    return tcp_output(pcb);
    e3f8:	e13fff17 	ldw	r4,-4(fp)
    e3fc:	00122380 	call	12238 <tcp_output>
    e400:	00000106 	br	e408 <tcp_timewait_input+0x124>
  }
  return ERR_OK;
    e404:	0005883a 	mov	r2,zero
}
    e408:	e037883a 	mov	sp,fp
    e40c:	dfc00117 	ldw	ra,4(sp)
    e410:	df000017 	ldw	fp,0(sp)
    e414:	dec00204 	addi	sp,sp,8
    e418:	f800283a 	ret

0000e41c <tcp_process>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_process(struct tcp_pcb *pcb)
{
    e41c:	defff804 	addi	sp,sp,-32
    e420:	dfc00715 	stw	ra,28(sp)
    e424:	df000615 	stw	fp,24(sp)
    e428:	df000604 	addi	fp,sp,24
    e42c:	e13fff15 	stw	r4,-4(fp)
  struct tcp_seg *rseg;
  u8_t acceptable = 0;
    e430:	e03ffc05 	stb	zero,-16(fp)
  err_t err;

  err = ERR_OK;
    e434:	e03ffc45 	stb	zero,-15(fp)

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
    e438:	d0a8e003 	ldbu	r2,-23680(gp)
    e43c:	10803fcc 	andi	r2,r2,255
    e440:	1080010c 	andi	r2,r2,4
    e444:	10003726 	beq	r2,zero,e524 <tcp_process+0x108>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
    e448:	e0bfff17 	ldw	r2,-4(fp)
    e44c:	10800417 	ldw	r2,16(r2)
    e450:	10800098 	cmpnei	r2,r2,2
    e454:	1000071e 	bne	r2,zero,e474 <tcp_process+0x58>
      if (ackno == pcb->snd_nxt) {
    e458:	e0bfff17 	ldw	r2,-4(fp)
    e45c:	10c01717 	ldw	r3,92(r2)
    e460:	d0a8df17 	ldw	r2,-23684(gp)
    e464:	1880131e 	bne	r3,r2,e4b4 <tcp_process+0x98>
        acceptable = 1;
    e468:	00800044 	movi	r2,1
    e46c:	e0bffc05 	stb	r2,-16(fp)
    e470:	00001006 	br	e4b4 <tcp_process+0x98>
      }
    } else {
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
    e474:	d0e8de17 	ldw	r3,-23688(gp)
    e478:	e0bfff17 	ldw	r2,-4(fp)
    e47c:	10800a17 	ldw	r2,40(r2)
    e480:	1885c83a 	sub	r2,r3,r2
    e484:	10000b16 	blt	r2,zero,e4b4 <tcp_process+0x98>
    e488:	d0e8de17 	ldw	r3,-23688(gp)
    e48c:	e0bfff17 	ldw	r2,-4(fp)
    e490:	11000a17 	ldw	r4,40(r2)
    e494:	e0bfff17 	ldw	r2,-4(fp)
    e498:	10800b0b 	ldhu	r2,44(r2)
    e49c:	10bfffcc 	andi	r2,r2,65535
    e4a0:	2085883a 	add	r2,r4,r2
    e4a4:	1885c83a 	sub	r2,r3,r2
    e4a8:	00800216 	blt	zero,r2,e4b4 <tcp_process+0x98>
                          pcb->rcv_nxt+pcb->rcv_wnd)) {
        acceptable = 1;
    e4ac:	00800044 	movi	r2,1
    e4b0:	e0bffc05 	stb	r2,-16(fp)
      }
    }

    if (acceptable) {
    e4b4:	e0bffc03 	ldbu	r2,-16(fp)
    e4b8:	10001826 	beq	r2,zero,e51c <tcp_process+0x100>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
    e4bc:	e0bfff17 	ldw	r2,-4(fp)
    e4c0:	10800417 	ldw	r2,16(r2)
    e4c4:	1000091e 	bne	r2,zero,e4ec <tcp_process+0xd0>
    e4c8:	010000f4 	movhi	r4,3
    e4cc:	213a1604 	addi	r4,r4,-6056
    e4d0:	014000f4 	movhi	r5,3
    e4d4:	297a6704 	addi	r5,r5,-5732
    e4d8:	01808944 	movi	r6,549
    e4dc:	01c000f4 	movhi	r7,3
    e4e0:	39fa2a04 	addi	r7,r7,-5976
    e4e4:	00166c00 	call	166c0 <printf>
    e4e8:	003fff06 	br	e4e8 <tcp_process+0xcc>
      recv_flags |= TF_RESET;
    e4ec:	d0a8e103 	ldbu	r2,-23676(gp)
    e4f0:	10800214 	ori	r2,r2,8
    e4f4:	d0a8e105 	stb	r2,-23676(gp)
      pcb->flags &= ~TF_ACK_DELAY;
    e4f8:	e0bfff17 	ldw	r2,-4(fp)
    e4fc:	10c00983 	ldbu	r3,38(r2)
    e500:	00bfff84 	movi	r2,-2
    e504:	1884703a 	and	r2,r3,r2
    e508:	1007883a 	mov	r3,r2
    e50c:	e0bfff17 	ldw	r2,-4(fp)
    e510:	10c00985 	stb	r3,38(r2)
      return ERR_RST;
    e514:	00bffe84 	movi	r2,-6
    e518:	0002a306 	br	efa8 <tcp_process+0xb8c>
    } else {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
       seqno, pcb->rcv_nxt));
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
       seqno, pcb->rcv_nxt));
      return ERR_OK;
    e51c:	0005883a 	mov	r2,zero
    e520:	0002a106 	br	efa8 <tcp_process+0xb8c>
    }
  }

  if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) { 
    e524:	d0a8e003 	ldbu	r2,-23680(gp)
    e528:	10803fcc 	andi	r2,r2,255
    e52c:	1080008c 	andi	r2,r2,2
    e530:	10001226 	beq	r2,zero,e57c <tcp_process+0x160>
    e534:	e0bfff17 	ldw	r2,-4(fp)
    e538:	10800417 	ldw	r2,16(r2)
    e53c:	108000a0 	cmpeqi	r2,r2,2
    e540:	10000e1e 	bne	r2,zero,e57c <tcp_process+0x160>
    e544:	e0bfff17 	ldw	r2,-4(fp)
    e548:	10800417 	ldw	r2,16(r2)
    e54c:	108000e0 	cmpeqi	r2,r2,3
    e550:	10000a1e 	bne	r2,zero,e57c <tcp_process+0x160>
    /* Cope with new connection attempt after remote end crashed */
    tcp_ack_now(pcb);
    e554:	e0bfff17 	ldw	r2,-4(fp)
    e558:	10800983 	ldbu	r2,38(r2)
    e55c:	10800094 	ori	r2,r2,2
    e560:	1007883a 	mov	r3,r2
    e564:	e0bfff17 	ldw	r2,-4(fp)
    e568:	10c00985 	stb	r3,38(r2)
    e56c:	e13fff17 	ldw	r4,-4(fp)
    e570:	00122380 	call	12238 <tcp_output>
    return ERR_OK;
    e574:	0005883a 	mov	r2,zero
    e578:	00028b06 	br	efa8 <tcp_process+0xb8c>
  }
  
  /* Update the PCB (in)activity timer. */
  pcb->tmr = tcp_ticks;
    e57c:	008000f4 	movhi	r2,3
    e580:	1095f704 	addi	r2,r2,22492
    e584:	10c00017 	ldw	r3,0(r2)
    e588:	e0bfff17 	ldw	r2,-4(fp)
    e58c:	10c00d15 	stw	r3,52(r2)
  pcb->keep_cnt_sent = 0;
    e590:	e0bfff17 	ldw	r2,-4(fp)
    e594:	10002945 	stb	zero,165(r2)

  tcp_parseopt(pcb);
    e598:	e13fff17 	ldw	r4,-4(fp)
    e59c:	0010dfc0 	call	10dfc <tcp_parseopt>

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
    e5a0:	e0bfff17 	ldw	r2,-4(fp)
    e5a4:	10800417 	ldw	r2,16(r2)
    e5a8:	10c002a8 	cmpgeui	r3,r2,10
    e5ac:	18026e1e 	bne	r3,zero,ef68 <tcp_process+0xb4c>
    e5b0:	1085883a 	add	r2,r2,r2
    e5b4:	1087883a 	add	r3,r2,r2
    e5b8:	00800074 	movhi	r2,1
    e5bc:	10b97304 	addi	r2,r2,-6708
    e5c0:	1885883a 	add	r2,r3,r2
    e5c4:	10800017 	ldw	r2,0(r2)
    e5c8:	1000683a 	jmp	r2
    e5cc:	0000ef68 	cmpgeui	zero,zero,957
    e5d0:	0000ef68 	cmpgeui	zero,zero,957
    e5d4:	0000e5f4 	movhi	zero,919
    e5d8:	0000e8f4 	movhi	zero,931
    e5dc:	0000eaf4 	movhi	zero,939
    e5e0:	0000eb3c 	xorhi	zero,zero,940
    e5e4:	0000ece8 	cmpgeui	zero,zero,947
    e5e8:	0000eaf4 	movhi	zero,939
    e5ec:	0000ee14 	movui	zero,952
    e5f0:	0000ef30 	cmpltui	zero,zero,956
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
    e5f4:	d0a8e003 	ldbu	r2,-23680(gp)
    e5f8:	10803fcc 	andi	r2,r2,255
    e5fc:	1080040c 	andi	r2,r2,16
    e600:	1000a326 	beq	r2,zero,e890 <tcp_process+0x474>
    e604:	d0a8e003 	ldbu	r2,-23680(gp)
    e608:	10803fcc 	andi	r2,r2,255
    e60c:	1080008c 	andi	r2,r2,2
    e610:	10009f26 	beq	r2,zero,e890 <tcp_process+0x474>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
    e614:	e0bfff17 	ldw	r2,-4(fp)
    e618:	10801f17 	ldw	r2,124(r2)
    e61c:	10800417 	ldw	r2,16(r2)
    e620:	10c0010b 	ldhu	r3,4(r2)
    e624:	1080018b 	ldhu	r2,6(r2)
    e628:	1004943a 	slli	r2,r2,16
    e62c:	10c4b03a 	or	r2,r2,r3
    e630:	1006d63a 	srli	r3,r2,24
    e634:	e0bfff17 	ldw	r2,-4(fp)
    e638:	10801f17 	ldw	r2,124(r2)
    e63c:	10800417 	ldw	r2,16(r2)
    e640:	1100010b 	ldhu	r4,4(r2)
    e644:	1080018b 	ldhu	r2,6(r2)
    e648:	1004943a 	slli	r2,r2,16
    e64c:	1104b03a 	or	r2,r2,r4
    e650:	1004d23a 	srli	r2,r2,8
    e654:	10bfc00c 	andi	r2,r2,65280
    e658:	1886b03a 	or	r3,r3,r2
    e65c:	e0bfff17 	ldw	r2,-4(fp)
    e660:	10801f17 	ldw	r2,124(r2)
    e664:	10800417 	ldw	r2,16(r2)
    e668:	1100010b 	ldhu	r4,4(r2)
    e66c:	1080018b 	ldhu	r2,6(r2)
    e670:	1004943a 	slli	r2,r2,16
    e674:	1104b03a 	or	r2,r2,r4
    e678:	10bfc00c 	andi	r2,r2,65280
    e67c:	1004923a 	slli	r2,r2,8
    e680:	1886b03a 	or	r3,r3,r2
    e684:	e0bfff17 	ldw	r2,-4(fp)
    e688:	10801f17 	ldw	r2,124(r2)
    e68c:	10800417 	ldw	r2,16(r2)
    e690:	1100010b 	ldhu	r4,4(r2)
    e694:	1080018b 	ldhu	r2,6(r2)
    e698:	1004943a 	slli	r2,r2,16
    e69c:	1104b03a 	or	r2,r2,r4
    e6a0:	1004963a 	slli	r2,r2,24
    e6a4:	1884b03a 	or	r2,r3,r2
    e6a8:	10c00044 	addi	r3,r2,1
    e6ac:	d0a8df17 	ldw	r2,-23684(gp)
    e6b0:	1880771e 	bne	r3,r2,e890 <tcp_process+0x474>
      pcb->snd_buf++;
    e6b4:	e0bfff17 	ldw	r2,-4(fp)
    e6b8:	10801c8b 	ldhu	r2,114(r2)
    e6bc:	10800044 	addi	r2,r2,1
    e6c0:	1007883a 	mov	r3,r2
    e6c4:	e0bfff17 	ldw	r2,-4(fp)
    e6c8:	10c01c8d 	sth	r3,114(r2)
      pcb->rcv_nxt = seqno + 1;
    e6cc:	d0a8de17 	ldw	r2,-23688(gp)
    e6d0:	10c00044 	addi	r3,r2,1
    e6d4:	e0bfff17 	ldw	r2,-4(fp)
    e6d8:	10c00a15 	stw	r3,40(r2)
      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
    e6dc:	e0bfff17 	ldw	r2,-4(fp)
    e6e0:	10c00a17 	ldw	r3,40(r2)
    e6e4:	e0bfff17 	ldw	r2,-4(fp)
    e6e8:	10c00c15 	stw	r3,48(r2)
      pcb->lastack = ackno;
    e6ec:	d0e8df17 	ldw	r3,-23684(gp)
    e6f0:	e0bfff17 	ldw	r2,-4(fp)
    e6f4:	10c01415 	stw	r3,80(r2)
      pcb->snd_wnd = tcphdr->wnd;
    e6f8:	d0a8dc17 	ldw	r2,-23696(gp)
    e6fc:	10c0038b 	ldhu	r3,14(r2)
    e700:	e0bfff17 	ldw	r2,-4(fp)
    e704:	10c0180d 	sth	r3,96(r2)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
    e708:	d0a8de17 	ldw	r2,-23688(gp)
    e70c:	10ffffc4 	addi	r3,r2,-1
    e710:	e0bfff17 	ldw	r2,-4(fp)
    e714:	10c01915 	stw	r3,100(r2)
      pcb->state = ESTABLISHED;
    e718:	e0bfff17 	ldw	r2,-4(fp)
    e71c:	00c00104 	movi	r3,4
    e720:	10c00415 	stw	r3,16(r2)

#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
    e724:	e0bfff17 	ldw	r2,-4(fp)
    e728:	10800f0b 	ldhu	r2,60(r2)
    e72c:	10ffffcc 	andi	r3,r2,65535
    e730:	e0bfff17 	ldw	r2,-4(fp)
    e734:	10800104 	addi	r2,r2,4
    e738:	1809883a 	mov	r4,r3
    e73c:	100b883a 	mov	r5,r2
    e740:	000d2500 	call	d250 <tcp_eff_send_mss>
    e744:	e0ffff17 	ldw	r3,-4(fp)
    e748:	18800f0d 	sth	r2,60(r3)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
    e74c:	e0bfff17 	ldw	r2,-4(fp)
    e750:	10800f0b 	ldhu	r2,60(r2)
    e754:	108002a4 	muli	r2,r2,10
    e758:	1007883a 	mov	r3,r2
    e75c:	e0bfff17 	ldw	r2,-4(fp)
    e760:	10c0160d 	sth	r3,88(r2)

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
    e764:	e0bfff17 	ldw	r2,-4(fp)
    e768:	1080158b 	ldhu	r2,86(r2)
    e76c:	10bfffcc 	andi	r2,r2,65535
    e770:	10800058 	cmpnei	r2,r2,1
    e774:	1000041e 	bne	r2,zero,e788 <tcp_process+0x36c>
    e778:	e0bfff17 	ldw	r2,-4(fp)
    e77c:	10800f0b 	ldhu	r2,60(r2)
    e780:	1085883a 	add	r2,r2,r2
    e784:	00000206 	br	e790 <tcp_process+0x374>
    e788:	e0bfff17 	ldw	r2,-4(fp)
    e78c:	10800f0b 	ldhu	r2,60(r2)
    e790:	e0ffff17 	ldw	r3,-4(fp)
    e794:	1880158d 	sth	r2,86(r3)
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
    e798:	e0bfff17 	ldw	r2,-4(fp)
    e79c:	10801d0b 	ldhu	r2,116(r2)
    e7a0:	10bfffcc 	andi	r2,r2,65535
    e7a4:	1000091e 	bne	r2,zero,e7cc <tcp_process+0x3b0>
    e7a8:	010000f4 	movhi	r4,3
    e7ac:	213a1604 	addi	r4,r4,-6056
    e7b0:	014000f4 	movhi	r5,3
    e7b4:	297a6f04 	addi	r5,r5,-5700
    e7b8:	018095c4 	movi	r6,599
    e7bc:	01c000f4 	movhi	r7,3
    e7c0:	39fa2a04 	addi	r7,r7,-5976
    e7c4:	00166c00 	call	166c0 <printf>
    e7c8:	003fff06 	br	e7c8 <tcp_process+0x3ac>
      --pcb->snd_queuelen;
    e7cc:	e0bfff17 	ldw	r2,-4(fp)
    e7d0:	10801d0b 	ldhu	r2,116(r2)
    e7d4:	10bfffc4 	addi	r2,r2,-1
    e7d8:	1007883a 	mov	r3,r2
    e7dc:	e0bfff17 	ldw	r2,-4(fp)
    e7e0:	10c01d0d 	sth	r3,116(r2)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
    e7e4:	e0bfff17 	ldw	r2,-4(fp)
    e7e8:	10801f17 	ldw	r2,124(r2)
    e7ec:	e0bffd15 	stw	r2,-12(fp)
      pcb->unacked = rseg->next;
    e7f0:	e0bffd17 	ldw	r2,-12(fp)
    e7f4:	10c00017 	ldw	r3,0(r2)
    e7f8:	e0bfff17 	ldw	r2,-4(fp)
    e7fc:	10c01f15 	stw	r3,124(r2)

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
    e800:	e0bfff17 	ldw	r2,-4(fp)
    e804:	10801f17 	ldw	r2,124(r2)
    e808:	1000041e 	bne	r2,zero,e81c <tcp_process+0x400>
        pcb->rtime = -1;
    e80c:	e0bfff17 	ldw	r2,-4(fp)
    e810:	00ffffc4 	movi	r3,-1
    e814:	10c00e8d 	sth	r3,58(r2)
    e818:	00000406 	br	e82c <tcp_process+0x410>
      else {
        pcb->rtime = 0;
    e81c:	e0bfff17 	ldw	r2,-4(fp)
    e820:	10000e8d 	sth	zero,58(r2)
        pcb->nrtx = 0;
    e824:	e0bfff17 	ldw	r2,-4(fp)
    e828:	10001385 	stb	zero,78(r2)
      }

      tcp_seg_free(rseg);
    e82c:	e13ffd17 	ldw	r4,-12(fp)
    e830:	000c97c0 	call	c97c <tcp_seg_free>

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
    e834:	e0bfff17 	ldw	r2,-4(fp)
    e838:	10802417 	ldw	r2,144(r2)
    e83c:	10000a26 	beq	r2,zero,e868 <tcp_process+0x44c>
    e840:	e0bfff17 	ldw	r2,-4(fp)
    e844:	10c02417 	ldw	r3,144(r2)
    e848:	e0bfff17 	ldw	r2,-4(fp)
    e84c:	10800617 	ldw	r2,24(r2)
    e850:	1009883a 	mov	r4,r2
    e854:	e17fff17 	ldw	r5,-4(fp)
    e858:	000d883a 	mov	r6,zero
    e85c:	183ee83a 	callr	r3
    e860:	e0bffc45 	stb	r2,-15(fp)
    e864:	00000106 	br	e86c <tcp_process+0x450>
    e868:	e03ffc45 	stb	zero,-15(fp)
      tcp_ack_now(pcb);
    e86c:	e0bfff17 	ldw	r2,-4(fp)
    e870:	10800983 	ldbu	r2,38(r2)
    e874:	10800094 	ori	r2,r2,2
    e878:	1007883a 	mov	r3,r2
    e87c:	e0bfff17 	ldw	r2,-4(fp)
    e880:	10c00985 	stb	r3,38(r2)
    e884:	e13fff17 	ldw	r4,-4(fp)
    e888:	00122380 	call	12238 <tcp_output>
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    break;
    e88c:	0001b806 	br	ef70 <tcp_process+0xb54>
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
    e890:	d0a8e003 	ldbu	r2,-23680(gp)
    e894:	10803fcc 	andi	r2,r2,255
    e898:	1080040c 	andi	r2,r2,16
    e89c:	1001b426 	beq	r2,zero,ef70 <tcp_process+0xb54>
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
    e8a0:	d128df17 	ldw	r4,-23684(gp)
    e8a4:	d0a8e08b 	ldhu	r2,-23678(gp)
    e8a8:	10ffffcc 	andi	r3,r2,65535
    e8ac:	d0a8de17 	ldw	r2,-23688(gp)
    e8b0:	188b883a 	add	r5,r3,r2
    e8b4:	d0a8dd17 	ldw	r2,-23692(gp)
    e8b8:	10c00404 	addi	r3,r2,16
    e8bc:	d0a8dd17 	ldw	r2,-23692(gp)
    e8c0:	10800304 	addi	r2,r2,12
        tcphdr->dest, tcphdr->src);
    e8c4:	d1a8dc17 	ldw	r6,-23696(gp)
    e8c8:	3180008b 	ldhu	r6,2(r6)
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
    e8cc:	31ffffcc 	andi	r7,r6,65535
        tcphdr->dest, tcphdr->src);
    e8d0:	d1a8dc17 	ldw	r6,-23696(gp)
    e8d4:	3180000b 	ldhu	r6,0(r6)
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
    e8d8:	31bfffcc 	andi	r6,r6,65535
    e8dc:	d9c00015 	stw	r7,0(sp)
    e8e0:	d9800115 	stw	r6,4(sp)
    e8e4:	180d883a 	mov	r6,r3
    e8e8:	100f883a 	mov	r7,r2
    e8ec:	0012e5c0 	call	12e5c <tcp_rst>
        tcphdr->dest, tcphdr->src);
    }
    break;
    e8f0:	00019f06 	br	ef70 <tcp_process+0xb54>
  case SYN_RCVD:
    if (flags & TCP_ACK) {
    e8f4:	d0a8e003 	ldbu	r2,-23680(gp)
    e8f8:	10803fcc 	andi	r2,r2,255
    e8fc:	1080040c 	andi	r2,r2,16
    e900:	10007026 	beq	r2,zero,eac4 <tcp_process+0x6a8>
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
    e904:	e0bfff17 	ldw	r2,-4(fp)
    e908:	10801417 	ldw	r2,80(r2)
    e90c:	0086303a 	nor	r3,zero,r2
    e910:	d0a8df17 	ldw	r2,-23684(gp)
    e914:	1885883a 	add	r2,r3,r2
    e918:	10005316 	blt	r2,zero,ea68 <tcp_process+0x64c>
    e91c:	d0e8df17 	ldw	r3,-23684(gp)
    e920:	e0bfff17 	ldw	r2,-4(fp)
    e924:	10801717 	ldw	r2,92(r2)
    e928:	1885c83a 	sub	r2,r3,r2
    e92c:	00804e16 	blt	zero,r2,ea68 <tcp_process+0x64c>
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
    e930:	e0bfff17 	ldw	r2,-4(fp)
    e934:	00c00104 	movi	r3,4
    e938:	10c00415 	stw	r3,16(r2)
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
    e93c:	e0bfff17 	ldw	r2,-4(fp)
    e940:	10800817 	ldw	r2,32(r2)
    e944:	1000091e 	bne	r2,zero,e96c <tcp_process+0x550>
    e948:	010000f4 	movhi	r4,3
    e94c:	213a1604 	addi	r4,r4,-6056
    e950:	014000f4 	movhi	r5,3
    e954:	297a7504 	addi	r5,r5,-5676
    e958:	01809f04 	movi	r6,636
    e95c:	01c000f4 	movhi	r7,3
    e960:	39fa2a04 	addi	r7,r7,-5976
    e964:	00166c00 	call	166c0 <printf>
    e968:	003fff06 	br	e968 <tcp_process+0x54c>
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
    e96c:	e0bfff17 	ldw	r2,-4(fp)
    e970:	10800817 	ldw	r2,32(r2)
    e974:	10000a26 	beq	r2,zero,e9a0 <tcp_process+0x584>
    e978:	e0bfff17 	ldw	r2,-4(fp)
    e97c:	10c00817 	ldw	r3,32(r2)
    e980:	e0bfff17 	ldw	r2,-4(fp)
    e984:	10800617 	ldw	r2,24(r2)
    e988:	1009883a 	mov	r4,r2
    e98c:	e17fff17 	ldw	r5,-4(fp)
    e990:	000d883a 	mov	r6,zero
    e994:	183ee83a 	callr	r3
    e998:	e0bffc45 	stb	r2,-15(fp)
    e99c:	00000106 	br	e9a4 <tcp_process+0x588>
    e9a0:	e03ffc45 	stb	zero,-15(fp)
        if (err != ERR_OK) {
    e9a4:	e0bffc47 	ldb	r2,-15(fp)
    e9a8:	10000526 	beq	r2,zero,e9c0 <tcp_process+0x5a4>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
    e9ac:	e13fff17 	ldw	r4,-4(fp)
    e9b0:	01400044 	movi	r5,1
    e9b4:	000b4680 	call	b468 <tcp_abandon>
          return ERR_ABRT;
    e9b8:	00bffec4 	movi	r2,-5
    e9bc:	00017a06 	br	efa8 <tcp_process+0xb8c>
        }
        old_cwnd = pcb->cwnd;
    e9c0:	e0bfff17 	ldw	r2,-4(fp)
    e9c4:	1080158b 	ldhu	r2,86(r2)
    e9c8:	e0bffe0d 	sth	r2,-8(fp)
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        tcp_receive(pcb);
    e9cc:	e13fff17 	ldw	r4,-4(fp)
    e9d0:	000f1d80 	call	f1d8 <tcp_receive>

        /* Prevent ACK for SYN to generate a sent event */
        if (pcb->acked != 0) {
    e9d4:	e0bfff17 	ldw	r2,-4(fp)
    e9d8:	10801c0b 	ldhu	r2,112(r2)
    e9dc:	10bfffcc 	andi	r2,r2,65535
    e9e0:	10000626 	beq	r2,zero,e9fc <tcp_process+0x5e0>
          pcb->acked--;
    e9e4:	e0bfff17 	ldw	r2,-4(fp)
    e9e8:	10801c0b 	ldhu	r2,112(r2)
    e9ec:	10bfffc4 	addi	r2,r2,-1
    e9f0:	1007883a 	mov	r3,r2
    e9f4:	e0bfff17 	ldw	r2,-4(fp)
    e9f8:	10c01c0d 	sth	r3,112(r2)
        }

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
    e9fc:	e0bffe0b 	ldhu	r2,-8(fp)
    ea00:	10800058 	cmpnei	r2,r2,1
    ea04:	1000041e 	bne	r2,zero,ea18 <tcp_process+0x5fc>
    ea08:	e0bfff17 	ldw	r2,-4(fp)
    ea0c:	10800f0b 	ldhu	r2,60(r2)
    ea10:	1085883a 	add	r2,r2,r2
    ea14:	00000206 	br	ea20 <tcp_process+0x604>
    ea18:	e0bfff17 	ldw	r2,-4(fp)
    ea1c:	10800f0b 	ldhu	r2,60(r2)
    ea20:	e0ffff17 	ldw	r3,-4(fp)
    ea24:	1880158d 	sth	r2,86(r3)

        if (recv_flags & TF_GOT_FIN) {
    ea28:	d0a8e103 	ldbu	r2,-23676(gp)
    ea2c:	10803fcc 	andi	r2,r2,255
    ea30:	1080080c 	andi	r2,r2,32
    ea34:	10002126 	beq	r2,zero,eabc <tcp_process+0x6a0>
          tcp_ack_now(pcb);
    ea38:	e0bfff17 	ldw	r2,-4(fp)
    ea3c:	10800983 	ldbu	r2,38(r2)
    ea40:	10800094 	ori	r2,r2,2
    ea44:	1007883a 	mov	r3,r2
    ea48:	e0bfff17 	ldw	r2,-4(fp)
    ea4c:	10c00985 	stb	r3,38(r2)
    ea50:	e13fff17 	ldw	r4,-4(fp)
    ea54:	00122380 	call	12238 <tcp_output>
          pcb->state = CLOSE_WAIT;
    ea58:	e0bfff17 	ldw	r2,-4(fp)
    ea5c:	00c001c4 	movi	r3,7
    ea60:	10c00415 	stw	r3,16(r2)
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
    ea64:	00001506 	br	eabc <tcp_process+0x6a0>
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
    ea68:	d128df17 	ldw	r4,-23684(gp)
    ea6c:	d0a8e08b 	ldhu	r2,-23678(gp)
    ea70:	10ffffcc 	andi	r3,r2,65535
    ea74:	d0a8de17 	ldw	r2,-23688(gp)
    ea78:	188b883a 	add	r5,r3,r2
    ea7c:	d0a8dd17 	ldw	r2,-23692(gp)
    ea80:	10c00404 	addi	r3,r2,16
    ea84:	d0a8dd17 	ldw	r2,-23692(gp)
    ea88:	10800304 	addi	r2,r2,12
                tcphdr->dest, tcphdr->src);
    ea8c:	d1a8dc17 	ldw	r6,-23696(gp)
    ea90:	3180008b 	ldhu	r6,2(r6)
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
    ea94:	31ffffcc 	andi	r7,r6,65535
                tcphdr->dest, tcphdr->src);
    ea98:	d1a8dc17 	ldw	r6,-23696(gp)
    ea9c:	3180000b 	ldhu	r6,0(r6)
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
    eaa0:	31bfffcc 	andi	r6,r6,65535
    eaa4:	d9c00015 	stw	r7,0(sp)
    eaa8:	d9800115 	stw	r6,4(sp)
    eaac:	180d883a 	mov	r6,r3
    eab0:	100f883a 	mov	r7,r2
    eab4:	0012e5c0 	call	12e5c <tcp_rst>
      }
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
      /* Looks like another copy of the SYN - retransmit our SYN-ACK */
      tcp_rexmit(pcb);
    }
    break;
    eab8:	00012f06 	br	ef78 <tcp_process+0xb5c>
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
    eabc:	0001883a 	nop
      }
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
      /* Looks like another copy of the SYN - retransmit our SYN-ACK */
      tcp_rexmit(pcb);
    }
    break;
    eac0:	00012d06 	br	ef78 <tcp_process+0xb5c>
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
                tcphdr->dest, tcphdr->src);
      }
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
    eac4:	d0a8e003 	ldbu	r2,-23680(gp)
    eac8:	10803fcc 	andi	r2,r2,255
    eacc:	1080008c 	andi	r2,r2,2
    ead0:	10012926 	beq	r2,zero,ef78 <tcp_process+0xb5c>
    ead4:	e0bfff17 	ldw	r2,-4(fp)
    ead8:	10800a17 	ldw	r2,40(r2)
    eadc:	10ffffc4 	addi	r3,r2,-1
    eae0:	d0a8de17 	ldw	r2,-23688(gp)
    eae4:	1881241e 	bne	r3,r2,ef78 <tcp_process+0xb5c>
      /* Looks like another copy of the SYN - retransmit our SYN-ACK */
      tcp_rexmit(pcb);
    eae8:	e13fff17 	ldw	r4,-4(fp)
    eaec:	00131b40 	call	131b4 <tcp_rexmit>
    }
    break;
    eaf0:	00012106 	br	ef78 <tcp_process+0xb5c>
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    tcp_receive(pcb);
    eaf4:	e13fff17 	ldw	r4,-4(fp)
    eaf8:	000f1d80 	call	f1d8 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) { /* passive close */
    eafc:	d0a8e103 	ldbu	r2,-23676(gp)
    eb00:	10803fcc 	andi	r2,r2,255
    eb04:	1080080c 	andi	r2,r2,32
    eb08:	10011d26 	beq	r2,zero,ef80 <tcp_process+0xb64>
      tcp_ack_now(pcb);
    eb0c:	e0bfff17 	ldw	r2,-4(fp)
    eb10:	10800983 	ldbu	r2,38(r2)
    eb14:	10800094 	ori	r2,r2,2
    eb18:	1007883a 	mov	r3,r2
    eb1c:	e0bfff17 	ldw	r2,-4(fp)
    eb20:	10c00985 	stb	r3,38(r2)
    eb24:	e13fff17 	ldw	r4,-4(fp)
    eb28:	00122380 	call	12238 <tcp_output>
      pcb->state = CLOSE_WAIT;
    eb2c:	e0bfff17 	ldw	r2,-4(fp)
    eb30:	00c001c4 	movi	r3,7
    eb34:	10c00415 	stw	r3,16(r2)
    }
    break;
    eb38:	00011106 	br	ef80 <tcp_process+0xb64>
  case FIN_WAIT_1:
    tcp_receive(pcb);
    eb3c:	e13fff17 	ldw	r4,-4(fp)
    eb40:	000f1d80 	call	f1d8 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) {
    eb44:	d0a8e103 	ldbu	r2,-23676(gp)
    eb48:	10803fcc 	andi	r2,r2,255
    eb4c:	1080080c 	andi	r2,r2,32
    eb50:	10005926 	beq	r2,zero,ecb8 <tcp_process+0x89c>
      if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
    eb54:	d0a8e003 	ldbu	r2,-23680(gp)
    eb58:	10803fcc 	andi	r2,r2,255
    eb5c:	1080040c 	andi	r2,r2,16
    eb60:	10004926 	beq	r2,zero,ec88 <tcp_process+0x86c>
    eb64:	e0bfff17 	ldw	r2,-4(fp)
    eb68:	10c01717 	ldw	r3,92(r2)
    eb6c:	d0a8df17 	ldw	r2,-23684(gp)
    eb70:	1880451e 	bne	r3,r2,ec88 <tcp_process+0x86c>
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed: FIN_WAIT_1 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
    eb74:	e0bfff17 	ldw	r2,-4(fp)
    eb78:	10800983 	ldbu	r2,38(r2)
    eb7c:	10800094 	ori	r2,r2,2
    eb80:	1007883a 	mov	r3,r2
    eb84:	e0bfff17 	ldw	r2,-4(fp)
    eb88:	10c00985 	stb	r3,38(r2)
    eb8c:	e13fff17 	ldw	r4,-4(fp)
    eb90:	00122380 	call	12238 <tcp_output>
        tcp_pcb_purge(pcb);
    eb94:	e13fff17 	ldw	r4,-4(fp)
    eb98:	000cfa40 	call	cfa4 <tcp_pcb_purge>
        TCP_RMV(&tcp_active_pcbs, pcb);
    eb9c:	008000f4 	movhi	r2,3
    eba0:	1095f604 	addi	r2,r2,22488
    eba4:	10c00017 	ldw	r3,0(r2)
    eba8:	e0bfff17 	ldw	r2,-4(fp)
    ebac:	1880081e 	bne	r3,r2,ebd0 <tcp_process+0x7b4>
    ebb0:	008000f4 	movhi	r2,3
    ebb4:	1095f604 	addi	r2,r2,22488
    ebb8:	10800017 	ldw	r2,0(r2)
    ebbc:	10c00317 	ldw	r3,12(r2)
    ebc0:	008000f4 	movhi	r2,3
    ebc4:	1095f604 	addi	r2,r2,22488
    ebc8:	10c00015 	stw	r3,0(r2)
    ebcc:	00001f06 	br	ec4c <tcp_process+0x830>
    ebd0:	008000f4 	movhi	r2,3
    ebd4:	1095f604 	addi	r2,r2,22488
    ebd8:	10c00017 	ldw	r3,0(r2)
    ebdc:	008000f4 	movhi	r2,3
    ebe0:	1095f904 	addi	r2,r2,22500
    ebe4:	10c00015 	stw	r3,0(r2)
    ebe8:	00001406 	br	ec3c <tcp_process+0x820>
    ebec:	008000f4 	movhi	r2,3
    ebf0:	1095f904 	addi	r2,r2,22500
    ebf4:	10800017 	ldw	r2,0(r2)
    ebf8:	10c00317 	ldw	r3,12(r2)
    ebfc:	e0bfff17 	ldw	r2,-4(fp)
    ec00:	1880071e 	bne	r3,r2,ec20 <tcp_process+0x804>
    ec04:	008000f4 	movhi	r2,3
    ec08:	1095f904 	addi	r2,r2,22500
    ec0c:	10800017 	ldw	r2,0(r2)
    ec10:	e0ffff17 	ldw	r3,-4(fp)
    ec14:	18c00317 	ldw	r3,12(r3)
    ec18:	10c00315 	stw	r3,12(r2)
    ec1c:	00000b06 	br	ec4c <tcp_process+0x830>
    ec20:	008000f4 	movhi	r2,3
    ec24:	1095f904 	addi	r2,r2,22500
    ec28:	10800017 	ldw	r2,0(r2)
    ec2c:	10c00317 	ldw	r3,12(r2)
    ec30:	008000f4 	movhi	r2,3
    ec34:	1095f904 	addi	r2,r2,22500
    ec38:	10c00015 	stw	r3,0(r2)
    ec3c:	008000f4 	movhi	r2,3
    ec40:	1095f904 	addi	r2,r2,22500
    ec44:	10800017 	ldw	r2,0(r2)
    ec48:	103fe81e 	bne	r2,zero,ebec <tcp_process+0x7d0>
    ec4c:	e0bfff17 	ldw	r2,-4(fp)
    ec50:	10000315 	stw	zero,12(r2)
        pcb->state = TIME_WAIT;
    ec54:	e0bfff17 	ldw	r2,-4(fp)
    ec58:	00c00284 	movi	r3,10
    ec5c:	10c00415 	stw	r3,16(r2)
        TCP_REG(&tcp_tw_pcbs, pcb);
    ec60:	008000f4 	movhi	r2,3
    ec64:	1095fb04 	addi	r2,r2,22508
    ec68:	10c00017 	ldw	r3,0(r2)
    ec6c:	e0bfff17 	ldw	r2,-4(fp)
    ec70:	10c00315 	stw	r3,12(r2)
    ec74:	008000f4 	movhi	r2,3
    ec78:	1095fb04 	addi	r2,r2,22508
    ec7c:	e0ffff17 	ldw	r3,-4(fp)
    ec80:	10c00015 	stw	r3,0(r2)
        pcb->state = CLOSING;
      }
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
      pcb->state = FIN_WAIT_2;
    }
    break;
    ec84:	0000c006 	br	ef88 <tcp_process+0xb6c>
        tcp_pcb_purge(pcb);
        TCP_RMV(&tcp_active_pcbs, pcb);
        pcb->state = TIME_WAIT;
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        tcp_ack_now(pcb);
    ec88:	e0bfff17 	ldw	r2,-4(fp)
    ec8c:	10800983 	ldbu	r2,38(r2)
    ec90:	10800094 	ori	r2,r2,2
    ec94:	1007883a 	mov	r3,r2
    ec98:	e0bfff17 	ldw	r2,-4(fp)
    ec9c:	10c00985 	stb	r3,38(r2)
    eca0:	e13fff17 	ldw	r4,-4(fp)
    eca4:	00122380 	call	12238 <tcp_output>
        pcb->state = CLOSING;
    eca8:	e0bfff17 	ldw	r2,-4(fp)
    ecac:	00c00204 	movi	r3,8
    ecb0:	10c00415 	stw	r3,16(r2)
      }
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
      pcb->state = FIN_WAIT_2;
    }
    break;
    ecb4:	0000b406 	br	ef88 <tcp_process+0xb6c>
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        tcp_ack_now(pcb);
        pcb->state = CLOSING;
      }
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
    ecb8:	d0a8e003 	ldbu	r2,-23680(gp)
    ecbc:	10803fcc 	andi	r2,r2,255
    ecc0:	1080040c 	andi	r2,r2,16
    ecc4:	1000b026 	beq	r2,zero,ef88 <tcp_process+0xb6c>
    ecc8:	e0bfff17 	ldw	r2,-4(fp)
    eccc:	10c01717 	ldw	r3,92(r2)
    ecd0:	d0a8df17 	ldw	r2,-23684(gp)
    ecd4:	1880ac1e 	bne	r3,r2,ef88 <tcp_process+0xb6c>
      pcb->state = FIN_WAIT_2;
    ecd8:	e0bfff17 	ldw	r2,-4(fp)
    ecdc:	00c00184 	movi	r3,6
    ece0:	10c00415 	stw	r3,16(r2)
    }
    break;
    ece4:	0000a806 	br	ef88 <tcp_process+0xb6c>
  case FIN_WAIT_2:
    tcp_receive(pcb);
    ece8:	e13fff17 	ldw	r4,-4(fp)
    ecec:	000f1d80 	call	f1d8 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) {
    ecf0:	d0a8e103 	ldbu	r2,-23676(gp)
    ecf4:	10803fcc 	andi	r2,r2,255
    ecf8:	1080080c 	andi	r2,r2,32
    ecfc:	1000a426 	beq	r2,zero,ef90 <tcp_process+0xb74>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: FIN_WAIT_2 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
    ed00:	e0bfff17 	ldw	r2,-4(fp)
    ed04:	10800983 	ldbu	r2,38(r2)
    ed08:	10800094 	ori	r2,r2,2
    ed0c:	1007883a 	mov	r3,r2
    ed10:	e0bfff17 	ldw	r2,-4(fp)
    ed14:	10c00985 	stb	r3,38(r2)
    ed18:	e13fff17 	ldw	r4,-4(fp)
    ed1c:	00122380 	call	12238 <tcp_output>
      tcp_pcb_purge(pcb);
    ed20:	e13fff17 	ldw	r4,-4(fp)
    ed24:	000cfa40 	call	cfa4 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
    ed28:	008000f4 	movhi	r2,3
    ed2c:	1095f604 	addi	r2,r2,22488
    ed30:	10c00017 	ldw	r3,0(r2)
    ed34:	e0bfff17 	ldw	r2,-4(fp)
    ed38:	1880081e 	bne	r3,r2,ed5c <tcp_process+0x940>
    ed3c:	008000f4 	movhi	r2,3
    ed40:	1095f604 	addi	r2,r2,22488
    ed44:	10800017 	ldw	r2,0(r2)
    ed48:	10c00317 	ldw	r3,12(r2)
    ed4c:	008000f4 	movhi	r2,3
    ed50:	1095f604 	addi	r2,r2,22488
    ed54:	10c00015 	stw	r3,0(r2)
    ed58:	00001f06 	br	edd8 <tcp_process+0x9bc>
    ed5c:	008000f4 	movhi	r2,3
    ed60:	1095f604 	addi	r2,r2,22488
    ed64:	10c00017 	ldw	r3,0(r2)
    ed68:	008000f4 	movhi	r2,3
    ed6c:	1095f904 	addi	r2,r2,22500
    ed70:	10c00015 	stw	r3,0(r2)
    ed74:	00001406 	br	edc8 <tcp_process+0x9ac>
    ed78:	008000f4 	movhi	r2,3
    ed7c:	1095f904 	addi	r2,r2,22500
    ed80:	10800017 	ldw	r2,0(r2)
    ed84:	10c00317 	ldw	r3,12(r2)
    ed88:	e0bfff17 	ldw	r2,-4(fp)
    ed8c:	1880071e 	bne	r3,r2,edac <tcp_process+0x990>
    ed90:	008000f4 	movhi	r2,3
    ed94:	1095f904 	addi	r2,r2,22500
    ed98:	10800017 	ldw	r2,0(r2)
    ed9c:	e0ffff17 	ldw	r3,-4(fp)
    eda0:	18c00317 	ldw	r3,12(r3)
    eda4:	10c00315 	stw	r3,12(r2)
    eda8:	00000b06 	br	edd8 <tcp_process+0x9bc>
    edac:	008000f4 	movhi	r2,3
    edb0:	1095f904 	addi	r2,r2,22500
    edb4:	10800017 	ldw	r2,0(r2)
    edb8:	10c00317 	ldw	r3,12(r2)
    edbc:	008000f4 	movhi	r2,3
    edc0:	1095f904 	addi	r2,r2,22500
    edc4:	10c00015 	stw	r3,0(r2)
    edc8:	008000f4 	movhi	r2,3
    edcc:	1095f904 	addi	r2,r2,22500
    edd0:	10800017 	ldw	r2,0(r2)
    edd4:	103fe81e 	bne	r2,zero,ed78 <tcp_process+0x95c>
    edd8:	e0bfff17 	ldw	r2,-4(fp)
    eddc:	10000315 	stw	zero,12(r2)
      pcb->state = TIME_WAIT;
    ede0:	e0bfff17 	ldw	r2,-4(fp)
    ede4:	00c00284 	movi	r3,10
    ede8:	10c00415 	stw	r3,16(r2)
      TCP_REG(&tcp_tw_pcbs, pcb);
    edec:	008000f4 	movhi	r2,3
    edf0:	1095fb04 	addi	r2,r2,22508
    edf4:	10c00017 	ldw	r3,0(r2)
    edf8:	e0bfff17 	ldw	r2,-4(fp)
    edfc:	10c00315 	stw	r3,12(r2)
    ee00:	008000f4 	movhi	r2,3
    ee04:	1095fb04 	addi	r2,r2,22508
    ee08:	e0ffff17 	ldw	r3,-4(fp)
    ee0c:	10c00015 	stw	r3,0(r2)
    }
    break;
    ee10:	00005f06 	br	ef90 <tcp_process+0xb74>
  case CLOSING:
    tcp_receive(pcb);
    ee14:	e13fff17 	ldw	r4,-4(fp)
    ee18:	000f1d80 	call	f1d8 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
    ee1c:	d0a8e003 	ldbu	r2,-23680(gp)
    ee20:	10803fcc 	andi	r2,r2,255
    ee24:	1080040c 	andi	r2,r2,16
    ee28:	10005b26 	beq	r2,zero,ef98 <tcp_process+0xb7c>
    ee2c:	e0bfff17 	ldw	r2,-4(fp)
    ee30:	10c01717 	ldw	r3,92(r2)
    ee34:	d0a8df17 	ldw	r2,-23684(gp)
    ee38:	1880571e 	bne	r3,r2,ef98 <tcp_process+0xb7c>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_pcb_purge(pcb);
    ee3c:	e13fff17 	ldw	r4,-4(fp)
    ee40:	000cfa40 	call	cfa4 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
    ee44:	008000f4 	movhi	r2,3
    ee48:	1095f604 	addi	r2,r2,22488
    ee4c:	10c00017 	ldw	r3,0(r2)
    ee50:	e0bfff17 	ldw	r2,-4(fp)
    ee54:	1880081e 	bne	r3,r2,ee78 <tcp_process+0xa5c>
    ee58:	008000f4 	movhi	r2,3
    ee5c:	1095f604 	addi	r2,r2,22488
    ee60:	10800017 	ldw	r2,0(r2)
    ee64:	10c00317 	ldw	r3,12(r2)
    ee68:	008000f4 	movhi	r2,3
    ee6c:	1095f604 	addi	r2,r2,22488
    ee70:	10c00015 	stw	r3,0(r2)
    ee74:	00001f06 	br	eef4 <tcp_process+0xad8>
    ee78:	008000f4 	movhi	r2,3
    ee7c:	1095f604 	addi	r2,r2,22488
    ee80:	10c00017 	ldw	r3,0(r2)
    ee84:	008000f4 	movhi	r2,3
    ee88:	1095f904 	addi	r2,r2,22500
    ee8c:	10c00015 	stw	r3,0(r2)
    ee90:	00001406 	br	eee4 <tcp_process+0xac8>
    ee94:	008000f4 	movhi	r2,3
    ee98:	1095f904 	addi	r2,r2,22500
    ee9c:	10800017 	ldw	r2,0(r2)
    eea0:	10c00317 	ldw	r3,12(r2)
    eea4:	e0bfff17 	ldw	r2,-4(fp)
    eea8:	1880071e 	bne	r3,r2,eec8 <tcp_process+0xaac>
    eeac:	008000f4 	movhi	r2,3
    eeb0:	1095f904 	addi	r2,r2,22500
    eeb4:	10800017 	ldw	r2,0(r2)
    eeb8:	e0ffff17 	ldw	r3,-4(fp)
    eebc:	18c00317 	ldw	r3,12(r3)
    eec0:	10c00315 	stw	r3,12(r2)
    eec4:	00000b06 	br	eef4 <tcp_process+0xad8>
    eec8:	008000f4 	movhi	r2,3
    eecc:	1095f904 	addi	r2,r2,22500
    eed0:	10800017 	ldw	r2,0(r2)
    eed4:	10c00317 	ldw	r3,12(r2)
    eed8:	008000f4 	movhi	r2,3
    eedc:	1095f904 	addi	r2,r2,22500
    eee0:	10c00015 	stw	r3,0(r2)
    eee4:	008000f4 	movhi	r2,3
    eee8:	1095f904 	addi	r2,r2,22500
    eeec:	10800017 	ldw	r2,0(r2)
    eef0:	103fe81e 	bne	r2,zero,ee94 <tcp_process+0xa78>
    eef4:	e0bfff17 	ldw	r2,-4(fp)
    eef8:	10000315 	stw	zero,12(r2)
      pcb->state = TIME_WAIT;
    eefc:	e0bfff17 	ldw	r2,-4(fp)
    ef00:	00c00284 	movi	r3,10
    ef04:	10c00415 	stw	r3,16(r2)
      TCP_REG(&tcp_tw_pcbs, pcb);
    ef08:	008000f4 	movhi	r2,3
    ef0c:	1095fb04 	addi	r2,r2,22508
    ef10:	10c00017 	ldw	r3,0(r2)
    ef14:	e0bfff17 	ldw	r2,-4(fp)
    ef18:	10c00315 	stw	r3,12(r2)
    ef1c:	008000f4 	movhi	r2,3
    ef20:	1095fb04 	addi	r2,r2,22508
    ef24:	e0ffff17 	ldw	r3,-4(fp)
    ef28:	10c00015 	stw	r3,0(r2)
    }
    break;
    ef2c:	00001a06 	br	ef98 <tcp_process+0xb7c>
  case LAST_ACK:
    tcp_receive(pcb);
    ef30:	e13fff17 	ldw	r4,-4(fp)
    ef34:	000f1d80 	call	f1d8 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
    ef38:	d0a8e003 	ldbu	r2,-23680(gp)
    ef3c:	10803fcc 	andi	r2,r2,255
    ef40:	1080040c 	andi	r2,r2,16
    ef44:	10001626 	beq	r2,zero,efa0 <tcp_process+0xb84>
    ef48:	e0bfff17 	ldw	r2,-4(fp)
    ef4c:	10c01717 	ldw	r3,92(r2)
    ef50:	d0a8df17 	ldw	r2,-23684(gp)
    ef54:	1880121e 	bne	r3,r2,efa0 <tcp_process+0xb84>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags |= TF_CLOSED;
    ef58:	d0a8e103 	ldbu	r2,-23676(gp)
    ef5c:	10800414 	ori	r2,r2,16
    ef60:	d0a8e105 	stb	r2,-23676(gp)
    }
    break;
    ef64:	00000e06 	br	efa0 <tcp_process+0xb84>
  default:
    break;
    ef68:	0001883a 	nop
    ef6c:	00000d06 	br	efa4 <tcp_process+0xb88>
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    break;
    ef70:	0001883a 	nop
    ef74:	00000b06 	br	efa4 <tcp_process+0xb88>
      }
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
      /* Looks like another copy of the SYN - retransmit our SYN-ACK */
      tcp_rexmit(pcb);
    }
    break;
    ef78:	0001883a 	nop
    ef7c:	00000906 	br	efa4 <tcp_process+0xb88>
    tcp_receive(pcb);
    if (recv_flags & TF_GOT_FIN) { /* passive close */
      tcp_ack_now(pcb);
      pcb->state = CLOSE_WAIT;
    }
    break;
    ef80:	0001883a 	nop
    ef84:	00000706 	br	efa4 <tcp_process+0xb88>
        pcb->state = CLOSING;
      }
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
      pcb->state = FIN_WAIT_2;
    }
    break;
    ef88:	0001883a 	nop
    ef8c:	00000506 	br	efa4 <tcp_process+0xb88>
      tcp_pcb_purge(pcb);
      TCP_RMV(&tcp_active_pcbs, pcb);
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
    }
    break;
    ef90:	0001883a 	nop
    ef94:	00000306 	br	efa4 <tcp_process+0xb88>
      tcp_pcb_purge(pcb);
      TCP_RMV(&tcp_active_pcbs, pcb);
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
    }
    break;
    ef98:	0001883a 	nop
    ef9c:	00000106 	br	efa4 <tcp_process+0xb88>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags |= TF_CLOSED;
    }
    break;
    efa0:	0001883a 	nop
  default:
    break;
  }
  return ERR_OK;
    efa4:	0005883a 	mov	r2,zero
}
    efa8:	e037883a 	mov	sp,fp
    efac:	dfc00117 	ldw	ra,4(sp)
    efb0:	df000017 	ldw	fp,0(sp)
    efb4:	dec00204 	addi	sp,sp,8
    efb8:	f800283a 	ret

0000efbc <tcp_oos_insert_segment>:
 *
 * Called from tcp_receive()
 */
static void
tcp_oos_insert_segment(struct tcp_seg *cseg, struct tcp_seg *next)
{
    efbc:	defffb04 	addi	sp,sp,-20
    efc0:	dfc00415 	stw	ra,16(sp)
    efc4:	df000315 	stw	fp,12(sp)
    efc8:	df000304 	addi	fp,sp,12
    efcc:	e13ffe15 	stw	r4,-8(fp)
    efd0:	e17fff15 	stw	r5,-4(fp)
  struct tcp_seg *old_seg;

  if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
    efd4:	e0bffe17 	ldw	r2,-8(fp)
    efd8:	10800417 	ldw	r2,16(r2)
    efdc:	1080030b 	ldhu	r2,12(r2)
    efe0:	10bfffcc 	andi	r2,r2,65535
    efe4:	1004d23a 	srli	r2,r2,8
    efe8:	10ffffcc 	andi	r3,r2,65535
    efec:	e0bffe17 	ldw	r2,-8(fp)
    eff0:	10800417 	ldw	r2,16(r2)
    eff4:	1080030b 	ldhu	r2,12(r2)
    eff8:	10bfffcc 	andi	r2,r2,65535
    effc:	1004923a 	slli	r2,r2,8
    f000:	10bfffcc 	andi	r2,r2,65535
    f004:	1884b03a 	or	r2,r3,r2
    f008:	1080004c 	andi	r2,r2,1
    f00c:	10003326 	beq	r2,zero,f0dc <tcp_oos_insert_segment+0x120>
    /* received segment overlaps all following segments */
    tcp_segs_free(next);
    f010:	e13fff17 	ldw	r4,-4(fp)
    f014:	000c9180 	call	c918 <tcp_segs_free>
    next = NULL;
    f018:	e03fff15 	stw	zero,-4(fp)
    f01c:	00006606 	br	f1b8 <tcp_oos_insert_segment+0x1fc>
       oos queue may have segments with FIN flag */
    while (next &&
           TCP_SEQ_GEQ((seqno + cseg->len),
                      (next->tcphdr->seqno + next->len))) {
      /* cseg with FIN already processed */
      if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
    f020:	e0bfff17 	ldw	r2,-4(fp)
    f024:	10800417 	ldw	r2,16(r2)
    f028:	1080030b 	ldhu	r2,12(r2)
    f02c:	10bfffcc 	andi	r2,r2,65535
    f030:	1004d23a 	srli	r2,r2,8
    f034:	10ffffcc 	andi	r3,r2,65535
    f038:	e0bfff17 	ldw	r2,-4(fp)
    f03c:	10800417 	ldw	r2,16(r2)
    f040:	1080030b 	ldhu	r2,12(r2)
    f044:	10bfffcc 	andi	r2,r2,65535
    f048:	1004923a 	slli	r2,r2,8
    f04c:	10bfffcc 	andi	r2,r2,65535
    f050:	1884b03a 	or	r2,r3,r2
    f054:	1080004c 	andi	r2,r2,1
    f058:	10001926 	beq	r2,zero,f0c0 <tcp_oos_insert_segment+0x104>
        TCPH_FLAGS_SET(cseg->tcphdr, TCPH_FLAGS(cseg->tcphdr) | TCP_FIN);
    f05c:	e0bffe17 	ldw	r2,-8(fp)
    f060:	10800417 	ldw	r2,16(r2)
    f064:	e0fffe17 	ldw	r3,-8(fp)
    f068:	18c00417 	ldw	r3,16(r3)
    f06c:	1900030b 	ldhu	r4,12(r3)
    f070:	00f03fc4 	movi	r3,-16129
    f074:	20c6703a 	and	r3,r4,r3
    f078:	1809883a 	mov	r4,r3
    f07c:	e0fffe17 	ldw	r3,-8(fp)
    f080:	18c00417 	ldw	r3,16(r3)
    f084:	18c0030b 	ldhu	r3,12(r3)
    f088:	18ffffcc 	andi	r3,r3,65535
    f08c:	1806d23a 	srli	r3,r3,8
    f090:	180b883a 	mov	r5,r3
    f094:	e0fffe17 	ldw	r3,-8(fp)
    f098:	18c00417 	ldw	r3,16(r3)
    f09c:	18c0030b 	ldhu	r3,12(r3)
    f0a0:	18ffffcc 	andi	r3,r3,65535
    f0a4:	1806923a 	slli	r3,r3,8
    f0a8:	28c6b03a 	or	r3,r5,r3
    f0ac:	18c00f8c 	andi	r3,r3,62
    f0b0:	18c00054 	ori	r3,r3,1
    f0b4:	1806923a 	slli	r3,r3,8
    f0b8:	20c6b03a 	or	r3,r4,r3
    f0bc:	10c0030d 	sth	r3,12(r2)
      }
      old_seg = next;
    f0c0:	e0bfff17 	ldw	r2,-4(fp)
    f0c4:	e0bffd15 	stw	r2,-12(fp)
      next = next->next;
    f0c8:	e0bfff17 	ldw	r2,-4(fp)
    f0cc:	10800017 	ldw	r2,0(r2)
    f0d0:	e0bfff15 	stw	r2,-4(fp)
      tcp_seg_free(old_seg);
    f0d4:	e13ffd17 	ldw	r4,-12(fp)
    f0d8:	000c97c0 	call	c97c <tcp_seg_free>
    next = NULL;
  }
  else {
    /* delete some following segments
       oos queue may have segments with FIN flag */
    while (next &&
    f0dc:	e0bfff17 	ldw	r2,-4(fp)
    f0e0:	10001226 	beq	r2,zero,f12c <tcp_oos_insert_segment+0x170>
           TCP_SEQ_GEQ((seqno + cseg->len),
    f0e4:	e0bffe17 	ldw	r2,-8(fp)
    f0e8:	1080030b 	ldhu	r2,12(r2)
    f0ec:	10ffffcc 	andi	r3,r2,65535
    f0f0:	d0a8de17 	ldw	r2,-23688(gp)
    f0f4:	1887883a 	add	r3,r3,r2
    f0f8:	e0bfff17 	ldw	r2,-4(fp)
    f0fc:	10800417 	ldw	r2,16(r2)
    f100:	1100010b 	ldhu	r4,4(r2)
    f104:	1080018b 	ldhu	r2,6(r2)
    f108:	1004943a 	slli	r2,r2,16
    f10c:	1104b03a 	or	r2,r2,r4
    f110:	1009883a 	mov	r4,r2
    f114:	e0bfff17 	ldw	r2,-4(fp)
    f118:	1080030b 	ldhu	r2,12(r2)
    f11c:	10bfffcc 	andi	r2,r2,65535
    f120:	2085883a 	add	r2,r4,r2
    f124:	1885c83a 	sub	r2,r3,r2
    next = NULL;
  }
  else {
    /* delete some following segments
       oos queue may have segments with FIN flag */
    while (next &&
    f128:	103fbd0e 	bge	r2,zero,f020 <tcp_oos_insert_segment+0x64>
      }
      old_seg = next;
      next = next->next;
      tcp_seg_free(old_seg);
    }
    if (next &&
    f12c:	e0bfff17 	ldw	r2,-4(fp)
    f130:	10002126 	beq	r2,zero,f1b8 <tcp_oos_insert_segment+0x1fc>
        TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
    f134:	e0bffe17 	ldw	r2,-8(fp)
    f138:	1080030b 	ldhu	r2,12(r2)
    f13c:	10ffffcc 	andi	r3,r2,65535
    f140:	d0a8de17 	ldw	r2,-23688(gp)
    f144:	1887883a 	add	r3,r3,r2
    f148:	e0bfff17 	ldw	r2,-4(fp)
    f14c:	10800417 	ldw	r2,16(r2)
    f150:	1100010b 	ldhu	r4,4(r2)
    f154:	1080018b 	ldhu	r2,6(r2)
    f158:	1004943a 	slli	r2,r2,16
    f15c:	1104b03a 	or	r2,r2,r4
    f160:	1885c83a 	sub	r2,r3,r2
      }
      old_seg = next;
      next = next->next;
      tcp_seg_free(old_seg);
    }
    if (next &&
    f164:	0080140e 	bge	zero,r2,f1b8 <tcp_oos_insert_segment+0x1fc>
        TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
      /* We need to trim the incoming segment. */
      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
    f168:	e0bfff17 	ldw	r2,-4(fp)
    f16c:	10800417 	ldw	r2,16(r2)
    f170:	10c0010b 	ldhu	r3,4(r2)
    f174:	1080018b 	ldhu	r2,6(r2)
    f178:	1004943a 	slli	r2,r2,16
    f17c:	10c4b03a 	or	r2,r2,r3
    f180:	1007883a 	mov	r3,r2
    f184:	d0a8de17 	ldw	r2,-23688(gp)
    f188:	1885c83a 	sub	r2,r3,r2
    f18c:	1007883a 	mov	r3,r2
    f190:	e0bffe17 	ldw	r2,-8(fp)
    f194:	10c0030d 	sth	r3,12(r2)
      pbuf_realloc(cseg->p, cseg->len);
    f198:	e0bffe17 	ldw	r2,-8(fp)
    f19c:	10c00117 	ldw	r3,4(r2)
    f1a0:	e0bffe17 	ldw	r2,-8(fp)
    f1a4:	1080030b 	ldhu	r2,12(r2)
    f1a8:	10bfffcc 	andi	r2,r2,65535
    f1ac:	1809883a 	mov	r4,r3
    f1b0:	100b883a 	mov	r5,r2
    f1b4:	0009cf00 	call	9cf0 <pbuf_realloc>
    }
  }
  cseg->next = next;
    f1b8:	e0bffe17 	ldw	r2,-8(fp)
    f1bc:	e0ffff17 	ldw	r3,-4(fp)
    f1c0:	10c00015 	stw	r3,0(r2)
}
    f1c4:	e037883a 	mov	sp,fp
    f1c8:	dfc00117 	ldw	ra,4(sp)
    f1cc:	df000017 	ldw	fp,0(sp)
    f1d0:	dec00204 	addi	sp,sp,8
    f1d4:	f800283a 	ret

0000f1d8 <tcp_receive>:
 *
 * Called from tcp_process().
 */
static void
tcp_receive(struct tcp_pcb *pcb)
{
    f1d8:	defff004 	addi	sp,sp,-64
    f1dc:	dfc00f15 	stw	ra,60(sp)
    f1e0:	df000e15 	stw	fp,56(sp)
    f1e4:	dc000d15 	stw	r16,52(sp)
    f1e8:	df000d04 	addi	fp,sp,52
    f1ec:	e13fff15 	stw	r4,-4(fp)
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  int found_dupack = 0;
    f1f0:	e03ff815 	stw	zero,-32(fp)

  if (flags & TCP_ACK) {
    f1f4:	d0a8e003 	ldbu	r2,-23680(gp)
    f1f8:	10803fcc 	andi	r2,r2,255
    f1fc:	1080040c 	andi	r2,r2,16
    f200:	10028326 	beq	r2,zero,fc10 <tcp_receive+0xa38>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
    f204:	e0bfff17 	ldw	r2,-4(fp)
    f208:	1080180b 	ldhu	r2,96(r2)
    f20c:	10ffffcc 	andi	r3,r2,65535
    f210:	e0bfff17 	ldw	r2,-4(fp)
    f214:	10801a17 	ldw	r2,104(r2)
    f218:	1885883a 	add	r2,r3,r2
    f21c:	e0bffa15 	stw	r2,-24(fp)

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
    f220:	e0bfff17 	ldw	r2,-4(fp)
    f224:	10c01917 	ldw	r3,100(r2)
    f228:	d0a8de17 	ldw	r2,-23688(gp)
    f22c:	1885c83a 	sub	r2,r3,r2
    f230:	10001416 	blt	r2,zero,f284 <tcp_receive+0xac>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
    f234:	e0bfff17 	ldw	r2,-4(fp)
    f238:	10c01917 	ldw	r3,100(r2)
    f23c:	d0a8de17 	ldw	r2,-23688(gp)

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
    f240:	1880051e 	bne	r3,r2,f258 <tcp_receive+0x80>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
    f244:	e0bfff17 	ldw	r2,-4(fp)
    f248:	10c01a17 	ldw	r3,104(r2)
    f24c:	d0a8df17 	ldw	r2,-23684(gp)
    f250:	1885c83a 	sub	r2,r3,r2
    f254:	10000b16 	blt	r2,zero,f284 <tcp_receive+0xac>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
    f258:	e0bfff17 	ldw	r2,-4(fp)
    f25c:	10c01a17 	ldw	r3,104(r2)
    f260:	d0a8df17 	ldw	r2,-23684(gp)
  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
    f264:	18801b1e 	bne	r3,r2,f2d4 <tcp_receive+0xfc>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
    f268:	d0a8dc17 	ldw	r2,-23696(gp)
    f26c:	1080038b 	ldhu	r2,14(r2)
    f270:	e0ffff17 	ldw	r3,-4(fp)
    f274:	18c0180b 	ldhu	r3,96(r3)
    f278:	10bfffcc 	andi	r2,r2,65535
    f27c:	18ffffcc 	andi	r3,r3,65535
    f280:	1880142e 	bgeu	r3,r2,f2d4 <tcp_receive+0xfc>
      pcb->snd_wnd = tcphdr->wnd;
    f284:	d0a8dc17 	ldw	r2,-23696(gp)
    f288:	10c0038b 	ldhu	r3,14(r2)
    f28c:	e0bfff17 	ldw	r2,-4(fp)
    f290:	10c0180d 	sth	r3,96(r2)
      pcb->snd_wl1 = seqno;
    f294:	d0e8de17 	ldw	r3,-23688(gp)
    f298:	e0bfff17 	ldw	r2,-4(fp)
    f29c:	10c01915 	stw	r3,100(r2)
      pcb->snd_wl2 = ackno;
    f2a0:	d0e8df17 	ldw	r3,-23684(gp)
    f2a4:	e0bfff17 	ldw	r2,-4(fp)
    f2a8:	10c01a15 	stw	r3,104(r2)
      if (pcb->snd_wnd > 0 && pcb->persist_backoff > 0) {
    f2ac:	e0bfff17 	ldw	r2,-4(fp)
    f2b0:	1080180b 	ldhu	r2,96(r2)
    f2b4:	10bfffcc 	andi	r2,r2,65535
    f2b8:	10000626 	beq	r2,zero,f2d4 <tcp_receive+0xfc>
    f2bc:	e0bfff17 	ldw	r2,-4(fp)
    f2c0:	10802903 	ldbu	r2,164(r2)
    f2c4:	10803fcc 	andi	r2,r2,255
    f2c8:	10000226 	beq	r2,zero,f2d4 <tcp_receive+0xfc>
          pcb->persist_backoff = 0;
    f2cc:	e0bfff17 	ldw	r2,-4(fp)
    f2d0:	10002905 	stb	zero,164(r2)
     * If it only passes 1, should reset dupack counter
     *
     */

    /* Clause 1 */
    if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
    f2d4:	d0e8df17 	ldw	r3,-23684(gp)
    f2d8:	e0bfff17 	ldw	r2,-4(fp)
    f2dc:	10801417 	ldw	r2,80(r2)
    f2e0:	1885c83a 	sub	r2,r3,r2
    f2e4:	00804b16 	blt	zero,r2,f414 <tcp_receive+0x23c>
      pcb->acked = 0;
    f2e8:	e0bfff17 	ldw	r2,-4(fp)
    f2ec:	10001c0d 	sth	zero,112(r2)
      /* Clause 2 */
      if (tcplen == 0) {
    f2f0:	d0a8e08b 	ldhu	r2,-23678(gp)
    f2f4:	10bfffcc 	andi	r2,r2,65535
    f2f8:	1000411e 	bne	r2,zero,f400 <tcp_receive+0x228>
        /* Clause 3 */
        if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge){
    f2fc:	e0bfff17 	ldw	r2,-4(fp)
    f300:	10c01a17 	ldw	r3,104(r2)
    f304:	e0bfff17 	ldw	r2,-4(fp)
    f308:	1080180b 	ldhu	r2,96(r2)
    f30c:	10bfffcc 	andi	r2,r2,65535
    f310:	1887883a 	add	r3,r3,r2
    f314:	e0bffa17 	ldw	r2,-24(fp)
    f318:	1880391e 	bne	r3,r2,f400 <tcp_receive+0x228>
          /* Clause 4 */
          if (pcb->rtime >= 0) {
    f31c:	e0bfff17 	ldw	r2,-4(fp)
    f320:	10800e8b 	ldhu	r2,58(r2)
    f324:	10bfffcc 	andi	r2,r2,65535
    f328:	10a0001c 	xori	r2,r2,32768
    f32c:	10a00004 	addi	r2,r2,-32768
    f330:	10003316 	blt	r2,zero,f400 <tcp_receive+0x228>
            /* Clause 5 */
            if (pcb->lastack == ackno) {
    f334:	e0bfff17 	ldw	r2,-4(fp)
    f338:	10c01417 	ldw	r3,80(r2)
    f33c:	d0a8df17 	ldw	r2,-23684(gp)
    f340:	18802f1e 	bne	r3,r2,f400 <tcp_receive+0x228>
              found_dupack = 1;
    f344:	00800044 	movi	r2,1
    f348:	e0bff815 	stw	r2,-32(fp)
              if (pcb->dupacks + 1 > pcb->dupacks)
    f34c:	e0bfff17 	ldw	r2,-4(fp)
    f350:	10801503 	ldbu	r2,84(r2)
    f354:	10803fcc 	andi	r2,r2,255
    f358:	10800044 	addi	r2,r2,1
    f35c:	e0ffff17 	ldw	r3,-4(fp)
    f360:	18c01503 	ldbu	r3,84(r3)
    f364:	18c03fcc 	andi	r3,r3,255
    f368:	1880060e 	bge	r3,r2,f384 <tcp_receive+0x1ac>
                ++pcb->dupacks;
    f36c:	e0bfff17 	ldw	r2,-4(fp)
    f370:	10801503 	ldbu	r2,84(r2)
    f374:	10800044 	addi	r2,r2,1
    f378:	1007883a 	mov	r3,r2
    f37c:	e0bfff17 	ldw	r2,-4(fp)
    f380:	10c01505 	stb	r3,84(r2)
              if (pcb->dupacks > 3) {
    f384:	e0bfff17 	ldw	r2,-4(fp)
    f388:	10801503 	ldbu	r2,84(r2)
    f38c:	10803fcc 	andi	r2,r2,255
    f390:	10800130 	cmpltui	r2,r2,4
    f394:	1000131e 	bne	r2,zero,f3e4 <tcp_receive+0x20c>
                /* Inflate the congestion window, but not if it means that
                   the value overflows. */
                if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
    f398:	e0bfff17 	ldw	r2,-4(fp)
    f39c:	10c0158b 	ldhu	r3,86(r2)
    f3a0:	e0bfff17 	ldw	r2,-4(fp)
    f3a4:	10800f0b 	ldhu	r2,60(r2)
    f3a8:	1885883a 	add	r2,r3,r2
    f3ac:	e0ffff17 	ldw	r3,-4(fp)
    f3b0:	18c0158b 	ldhu	r3,86(r3)
    f3b4:	10bfffcc 	andi	r2,r2,65535
    f3b8:	18ffffcc 	andi	r3,r3,65535
    f3bc:	1880102e 	bgeu	r3,r2,f400 <tcp_receive+0x228>
                  pcb->cwnd += pcb->mss;
    f3c0:	e0bfff17 	ldw	r2,-4(fp)
    f3c4:	10c0158b 	ldhu	r3,86(r2)
    f3c8:	e0bfff17 	ldw	r2,-4(fp)
    f3cc:	10800f0b 	ldhu	r2,60(r2)
    f3d0:	1885883a 	add	r2,r3,r2
    f3d4:	1007883a 	mov	r3,r2
    f3d8:	e0bfff17 	ldw	r2,-4(fp)
    f3dc:	10c0158d 	sth	r3,86(r2)
    f3e0:	00000706 	br	f400 <tcp_receive+0x228>
                }
              } else if (pcb->dupacks == 3) {
    f3e4:	e0bfff17 	ldw	r2,-4(fp)
    f3e8:	10801503 	ldbu	r2,84(r2)
    f3ec:	10803fcc 	andi	r2,r2,255
    f3f0:	108000d8 	cmpnei	r2,r2,3
    f3f4:	1000021e 	bne	r2,zero,f400 <tcp_receive+0x228>
                /* Do fast retransmit */
                tcp_rexmit_fast(pcb);
    f3f8:	e13fff17 	ldw	r4,-4(fp)
    f3fc:	00133880 	call	13388 <tcp_rexmit_fast>
          }
        }
      }
      /* If Clause (1) or more is true, but not a duplicate ack, reset
       * count of consecutive duplicate acks */
      if (!found_dupack) {
    f400:	e0bff817 	ldw	r2,-32(fp)
    f404:	1001731e 	bne	r2,zero,f9d4 <tcp_receive+0x7fc>
        pcb->dupacks = 0;
    f408:	e0bfff17 	ldw	r2,-4(fp)
    f40c:	10001505 	stb	zero,84(r2)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
    f410:	00017006 	br	f9d4 <tcp_receive+0x7fc>
      /* If Clause (1) or more is true, but not a duplicate ack, reset
       * count of consecutive duplicate acks */
      if (!found_dupack) {
        pcb->dupacks = 0;
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)){
    f414:	e0bfff17 	ldw	r2,-4(fp)
    f418:	10801417 	ldw	r2,80(r2)
    f41c:	0086303a 	nor	r3,zero,r2
    f420:	d0a8df17 	ldw	r2,-23684(gp)
    f424:	1885883a 	add	r2,r3,r2
    f428:	10011316 	blt	r2,zero,f878 <tcp_receive+0x6a0>
    f42c:	d0e8df17 	ldw	r3,-23684(gp)
    f430:	e0bfff17 	ldw	r2,-4(fp)
    f434:	10801717 	ldw	r2,92(r2)
    f438:	1885c83a 	sub	r2,r3,r2
    f43c:	00810e16 	blt	zero,r2,f878 <tcp_receive+0x6a0>
      /* We come here when the ACK acknowledges new data. */

      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
    f440:	e0bfff17 	ldw	r2,-4(fp)
    f444:	10800983 	ldbu	r2,38(r2)
    f448:	10803fcc 	andi	r2,r2,255
    f44c:	1080010c 	andi	r2,r2,4
    f450:	10000b26 	beq	r2,zero,f480 <tcp_receive+0x2a8>
        pcb->flags &= ~TF_INFR;
    f454:	e0bfff17 	ldw	r2,-4(fp)
    f458:	10c00983 	ldbu	r3,38(r2)
    f45c:	00bffec4 	movi	r2,-5
    f460:	1884703a 	and	r2,r3,r2
    f464:	1007883a 	mov	r3,r2
    f468:	e0bfff17 	ldw	r2,-4(fp)
    f46c:	10c00985 	stb	r3,38(r2)
        pcb->cwnd = pcb->ssthresh;
    f470:	e0bfff17 	ldw	r2,-4(fp)
    f474:	10c0160b 	ldhu	r3,88(r2)
    f478:	e0bfff17 	ldw	r2,-4(fp)
    f47c:	10c0158d 	sth	r3,86(r2)
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
    f480:	e0bfff17 	ldw	r2,-4(fp)
    f484:	10001385 	stb	zero,78(r2)

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
    f488:	e0bfff17 	ldw	r2,-4(fp)
    f48c:	1080120b 	ldhu	r2,72(r2)
    f490:	10bfffcc 	andi	r2,r2,65535
    f494:	10a0001c 	xori	r2,r2,32768
    f498:	10a00004 	addi	r2,r2,-32768
    f49c:	1005d0fa 	srai	r2,r2,3
    f4a0:	1007883a 	mov	r3,r2
    f4a4:	e0bfff17 	ldw	r2,-4(fp)
    f4a8:	1080128b 	ldhu	r2,74(r2)
    f4ac:	1885883a 	add	r2,r3,r2
    f4b0:	1007883a 	mov	r3,r2
    f4b4:	e0bfff17 	ldw	r2,-4(fp)
    f4b8:	10c0130d 	sth	r3,76(r2)

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
    f4bc:	d0a8df17 	ldw	r2,-23684(gp)
    f4c0:	1007883a 	mov	r3,r2
    f4c4:	e0bfff17 	ldw	r2,-4(fp)
    f4c8:	10801417 	ldw	r2,80(r2)
    f4cc:	1885c83a 	sub	r2,r3,r2
    f4d0:	1007883a 	mov	r3,r2
    f4d4:	e0bfff17 	ldw	r2,-4(fp)
    f4d8:	10c01c0d 	sth	r3,112(r2)

      pcb->snd_buf += pcb->acked;
    f4dc:	e0bfff17 	ldw	r2,-4(fp)
    f4e0:	10c01c8b 	ldhu	r3,114(r2)
    f4e4:	e0bfff17 	ldw	r2,-4(fp)
    f4e8:	10801c0b 	ldhu	r2,112(r2)
    f4ec:	1885883a 	add	r2,r3,r2
    f4f0:	1007883a 	mov	r3,r2
    f4f4:	e0bfff17 	ldw	r2,-4(fp)
    f4f8:	10c01c8d 	sth	r3,114(r2)

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
    f4fc:	e0bfff17 	ldw	r2,-4(fp)
    f500:	10001505 	stb	zero,84(r2)
      pcb->lastack = ackno;
    f504:	d0e8df17 	ldw	r3,-23684(gp)
    f508:	e0bfff17 	ldw	r2,-4(fp)
    f50c:	10c01415 	stw	r3,80(r2)

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
    f510:	e0bfff17 	ldw	r2,-4(fp)
    f514:	10800417 	ldw	r2,16(r2)
    f518:	10800130 	cmpltui	r2,r2,4
    f51c:	1000861e 	bne	r2,zero,f738 <tcp_receive+0x560>
        if (pcb->cwnd < pcb->ssthresh) {
    f520:	e0bfff17 	ldw	r2,-4(fp)
    f524:	10c0158b 	ldhu	r3,86(r2)
    f528:	e0bfff17 	ldw	r2,-4(fp)
    f52c:	1080160b 	ldhu	r2,88(r2)
    f530:	18ffffcc 	andi	r3,r3,65535
    f534:	10bfffcc 	andi	r2,r2,65535
    f538:	1880132e 	bgeu	r3,r2,f588 <tcp_receive+0x3b0>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
    f53c:	e0bfff17 	ldw	r2,-4(fp)
    f540:	10c0158b 	ldhu	r3,86(r2)
    f544:	e0bfff17 	ldw	r2,-4(fp)
    f548:	10800f0b 	ldhu	r2,60(r2)
    f54c:	1885883a 	add	r2,r3,r2
    f550:	e0ffff17 	ldw	r3,-4(fp)
    f554:	18c0158b 	ldhu	r3,86(r3)
    f558:	10bfffcc 	andi	r2,r2,65535
    f55c:	18ffffcc 	andi	r3,r3,65535
    f560:	1880752e 	bgeu	r3,r2,f738 <tcp_receive+0x560>
            pcb->cwnd += pcb->mss;
    f564:	e0bfff17 	ldw	r2,-4(fp)
    f568:	10c0158b 	ldhu	r3,86(r2)
    f56c:	e0bfff17 	ldw	r2,-4(fp)
    f570:	10800f0b 	ldhu	r2,60(r2)
    f574:	1885883a 	add	r2,r3,r2
    f578:	1007883a 	mov	r3,r2
    f57c:	e0bfff17 	ldw	r2,-4(fp)
    f580:	10c0158d 	sth	r3,86(r2)
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
    f584:	00006c06 	br	f738 <tcp_receive+0x560>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
            pcb->cwnd += pcb->mss;
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
        } else {
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
    f588:	e0bfff17 	ldw	r2,-4(fp)
    f58c:	10c0158b 	ldhu	r3,86(r2)
    f590:	e0bfff17 	ldw	r2,-4(fp)
    f594:	10800f0b 	ldhu	r2,60(r2)
    f598:	113fffcc 	andi	r4,r2,65535
    f59c:	e0bfff17 	ldw	r2,-4(fp)
    f5a0:	10800f0b 	ldhu	r2,60(r2)
    f5a4:	10bfffcc 	andi	r2,r2,65535
    f5a8:	2089383a 	mul	r4,r4,r2
    f5ac:	e0bfff17 	ldw	r2,-4(fp)
    f5b0:	1080158b 	ldhu	r2,86(r2)
    f5b4:	10bfffcc 	andi	r2,r2,65535
    f5b8:	2085283a 	div	r2,r4,r2
    f5bc:	1885883a 	add	r2,r3,r2
    f5c0:	e0bffb0d 	sth	r2,-20(fp)
          if (new_cwnd > pcb->cwnd) {
    f5c4:	e0bfff17 	ldw	r2,-4(fp)
    f5c8:	1080158b 	ldhu	r2,86(r2)
    f5cc:	10ffffcc 	andi	r3,r2,65535
    f5d0:	e0bffb0b 	ldhu	r2,-20(fp)
    f5d4:	1880582e 	bgeu	r3,r2,f738 <tcp_receive+0x560>
            pcb->cwnd = new_cwnd;
    f5d8:	e0bfff17 	ldw	r2,-4(fp)
    f5dc:	e0fffb0b 	ldhu	r3,-20(fp)
    f5e0:	10c0158d 	sth	r3,86(r2)
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
    f5e4:	00005406 	br	f738 <tcp_receive+0x560>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
    f5e8:	e0bfff17 	ldw	r2,-4(fp)
    f5ec:	10801f17 	ldw	r2,124(r2)
    f5f0:	e0bff315 	stw	r2,-52(fp)
        pcb->unacked = pcb->unacked->next;
    f5f4:	e0bfff17 	ldw	r2,-4(fp)
    f5f8:	10801f17 	ldw	r2,124(r2)
    f5fc:	10c00017 	ldw	r3,0(r2)
    f600:	e0bfff17 	ldw	r2,-4(fp)
    f604:	10c01f15 	stw	r3,124(r2)

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
    f608:	e0bfff17 	ldw	r2,-4(fp)
    f60c:	14001d0b 	ldhu	r16,116(r2)
    f610:	e0bff317 	ldw	r2,-52(fp)
    f614:	10800117 	ldw	r2,4(r2)
    f618:	1009883a 	mov	r4,r2
    f61c:	000a3380 	call	a338 <pbuf_clen>
    f620:	10803fcc 	andi	r2,r2,255
    f624:	80ffffcc 	andi	r3,r16,65535
    f628:	10bfffcc 	andi	r2,r2,65535
    f62c:	1880092e 	bgeu	r3,r2,f654 <tcp_receive+0x47c>
    f630:	010000f4 	movhi	r4,3
    f634:	213a1604 	addi	r4,r4,-6056
    f638:	014000f4 	movhi	r5,3
    f63c:	297a7a04 	addi	r5,r5,-5656
    f640:	0180ec44 	movi	r6,945
    f644:	01c000f4 	movhi	r7,3
    f648:	39fa2a04 	addi	r7,r7,-5976
    f64c:	00166c00 	call	166c0 <printf>
    f650:	003fff06 	br	f650 <tcp_receive+0x478>
        /* Prevent ACK for FIN to generate a sent event */
        if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
    f654:	e0bfff17 	ldw	r2,-4(fp)
    f658:	10801c0b 	ldhu	r2,112(r2)
    f65c:	10bfffcc 	andi	r2,r2,65535
    f660:	10001526 	beq	r2,zero,f6b8 <tcp_receive+0x4e0>
    f664:	e0bff317 	ldw	r2,-52(fp)
    f668:	10800417 	ldw	r2,16(r2)
    f66c:	1080030b 	ldhu	r2,12(r2)
    f670:	10bfffcc 	andi	r2,r2,65535
    f674:	1004d23a 	srli	r2,r2,8
    f678:	10ffffcc 	andi	r3,r2,65535
    f67c:	e0bff317 	ldw	r2,-52(fp)
    f680:	10800417 	ldw	r2,16(r2)
    f684:	1080030b 	ldhu	r2,12(r2)
    f688:	10bfffcc 	andi	r2,r2,65535
    f68c:	1004923a 	slli	r2,r2,8
    f690:	10bfffcc 	andi	r2,r2,65535
    f694:	1884b03a 	or	r2,r3,r2
    f698:	1080004c 	andi	r2,r2,1
    f69c:	10000626 	beq	r2,zero,f6b8 <tcp_receive+0x4e0>
          pcb->acked--;
    f6a0:	e0bfff17 	ldw	r2,-4(fp)
    f6a4:	10801c0b 	ldhu	r2,112(r2)
    f6a8:	10bfffc4 	addi	r2,r2,-1
    f6ac:	1007883a 	mov	r3,r2
    f6b0:	e0bfff17 	ldw	r2,-4(fp)
    f6b4:	10c01c0d 	sth	r3,112(r2)
        }

        pcb->snd_queuelen -= pbuf_clen(next->p);
    f6b8:	e0bfff17 	ldw	r2,-4(fp)
    f6bc:	14001d0b 	ldhu	r16,116(r2)
    f6c0:	e0bff317 	ldw	r2,-52(fp)
    f6c4:	10800117 	ldw	r2,4(r2)
    f6c8:	1009883a 	mov	r4,r2
    f6cc:	000a3380 	call	a338 <pbuf_clen>
    f6d0:	10803fcc 	andi	r2,r2,255
    f6d4:	8085c83a 	sub	r2,r16,r2
    f6d8:	1007883a 	mov	r3,r2
    f6dc:	e0bfff17 	ldw	r2,-4(fp)
    f6e0:	10c01d0d 	sth	r3,116(r2)
        tcp_seg_free(next);
    f6e4:	e13ff317 	ldw	r4,-52(fp)
    f6e8:	000c97c0 	call	c97c <tcp_seg_free>

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
        if (pcb->snd_queuelen != 0) {
    f6ec:	e0bfff17 	ldw	r2,-4(fp)
    f6f0:	10801d0b 	ldhu	r2,116(r2)
    f6f4:	10bfffcc 	andi	r2,r2,65535
    f6f8:	10001026 	beq	r2,zero,f73c <tcp_receive+0x564>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
    f6fc:	e0bfff17 	ldw	r2,-4(fp)
    f700:	10801f17 	ldw	r2,124(r2)
    f704:	10000d1e 	bne	r2,zero,f73c <tcp_receive+0x564>
    f708:	e0bfff17 	ldw	r2,-4(fp)
    f70c:	10801e17 	ldw	r2,120(r2)
    f710:	10000a1e 	bne	r2,zero,f73c <tcp_receive+0x564>
    f714:	010000f4 	movhi	r4,3
    f718:	213a1604 	addi	r4,r4,-6056
    f71c:	014000f4 	movhi	r5,3
    f720:	297a8404 	addi	r5,r5,-5616
    f724:	0180ef44 	movi	r6,957
    f728:	01c000f4 	movhi	r7,3
    f72c:	39fa2a04 	addi	r7,r7,-5976
    f730:	00166c00 	call	166c0 <printf>
    f734:	003fff06 	br	f734 <tcp_receive+0x55c>
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
    f738:	0001883a 	nop
    f73c:	e0bfff17 	ldw	r2,-4(fp)
    f740:	10801f17 	ldw	r2,124(r2)
    f744:	10004026 	beq	r2,zero,f848 <tcp_receive+0x670>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
    f748:	e0bfff17 	ldw	r2,-4(fp)
    f74c:	10801f17 	ldw	r2,124(r2)
    f750:	10800417 	ldw	r2,16(r2)
    f754:	10c0010b 	ldhu	r3,4(r2)
    f758:	1080018b 	ldhu	r2,6(r2)
    f75c:	1004943a 	slli	r2,r2,16
    f760:	10c4b03a 	or	r2,r2,r3
    f764:	1006d63a 	srli	r3,r2,24
    f768:	e0bfff17 	ldw	r2,-4(fp)
    f76c:	10801f17 	ldw	r2,124(r2)
    f770:	10800417 	ldw	r2,16(r2)
    f774:	1100010b 	ldhu	r4,4(r2)
    f778:	1080018b 	ldhu	r2,6(r2)
    f77c:	1004943a 	slli	r2,r2,16
    f780:	1104b03a 	or	r2,r2,r4
    f784:	1004d23a 	srli	r2,r2,8
    f788:	10bfc00c 	andi	r2,r2,65280
    f78c:	1886b03a 	or	r3,r3,r2
    f790:	e0bfff17 	ldw	r2,-4(fp)
    f794:	10801f17 	ldw	r2,124(r2)
    f798:	10800417 	ldw	r2,16(r2)
    f79c:	1100010b 	ldhu	r4,4(r2)
    f7a0:	1080018b 	ldhu	r2,6(r2)
    f7a4:	1004943a 	slli	r2,r2,16
    f7a8:	1104b03a 	or	r2,r2,r4
    f7ac:	10bfc00c 	andi	r2,r2,65280
    f7b0:	1004923a 	slli	r2,r2,8
    f7b4:	1886b03a 	or	r3,r3,r2
    f7b8:	e0bfff17 	ldw	r2,-4(fp)
    f7bc:	10801f17 	ldw	r2,124(r2)
    f7c0:	10800417 	ldw	r2,16(r2)
    f7c4:	1100010b 	ldhu	r4,4(r2)
    f7c8:	1080018b 	ldhu	r2,6(r2)
    f7cc:	1004943a 	slli	r2,r2,16
    f7d0:	1104b03a 	or	r2,r2,r4
    f7d4:	1004963a 	slli	r2,r2,24
    f7d8:	1886b03a 	or	r3,r3,r2
    f7dc:	e0bfff17 	ldw	r2,-4(fp)
    f7e0:	10801f17 	ldw	r2,124(r2)
    f7e4:	1080030b 	ldhu	r2,12(r2)
    f7e8:	113fffcc 	andi	r4,r2,65535
    f7ec:	e0bfff17 	ldw	r2,-4(fp)
    f7f0:	10801f17 	ldw	r2,124(r2)
    f7f4:	10800417 	ldw	r2,16(r2)
    f7f8:	1080030b 	ldhu	r2,12(r2)
    f7fc:	10bfffcc 	andi	r2,r2,65535
    f800:	1004d23a 	srli	r2,r2,8
    f804:	117fffcc 	andi	r5,r2,65535
    f808:	e0bfff17 	ldw	r2,-4(fp)
    f80c:	10801f17 	ldw	r2,124(r2)
    f810:	10800417 	ldw	r2,16(r2)
    f814:	1080030b 	ldhu	r2,12(r2)
    f818:	10bfffcc 	andi	r2,r2,65535
    f81c:	1004923a 	slli	r2,r2,8
    f820:	10bfffcc 	andi	r2,r2,65535
    f824:	2884b03a 	or	r2,r5,r2
    f828:	108000cc 	andi	r2,r2,3
    f82c:	1004c03a 	cmpne	r2,r2,zero
    f830:	10803fcc 	andi	r2,r2,255
    f834:	2085883a 	add	r2,r4,r2
    f838:	1887883a 	add	r3,r3,r2
    f83c:	d0a8df17 	ldw	r2,-23684(gp)
    f840:	1885c83a 	sub	r2,r3,r2
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
    f844:	00bf680e 	bge	zero,r2,f5e8 <tcp_receive+0x410>
        }
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
    f848:	e0bfff17 	ldw	r2,-4(fp)
    f84c:	10801f17 	ldw	r2,124(r2)
    f850:	1000041e 	bne	r2,zero,f864 <tcp_receive+0x68c>
        pcb->rtime = -1;
    f854:	e0bfff17 	ldw	r2,-4(fp)
    f858:	00ffffc4 	movi	r3,-1
    f85c:	10c00e8d 	sth	r3,58(r2)
    f860:	00000206 	br	f86c <tcp_receive+0x694>
      else
        pcb->rtime = 0;
    f864:	e0bfff17 	ldw	r2,-4(fp)
    f868:	10000e8d 	sth	zero,58(r2)

      pcb->polltmr = 0;
    f86c:	e0bfff17 	ldw	r2,-4(fp)
    f870:	10000e05 	stb	zero,56(r2)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
    f874:	00005706 	br	f9d4 <tcp_receive+0x7fc>
        pcb->rtime = 0;

      pcb->polltmr = 0;
    } else {
      /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
      pcb->acked = 0;
    f878:	e0bfff17 	ldw	r2,-4(fp)
    f87c:	10001c0d 	sth	zero,112(r2)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
    f880:	00005406 	br	f9d4 <tcp_receive+0x7fc>
                           TCP_TCPLEN(pcb->unsent), pcb->snd_nxt)) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
    f884:	e0bfff17 	ldw	r2,-4(fp)
    f888:	10801e17 	ldw	r2,120(r2)
    f88c:	e0bff315 	stw	r2,-52(fp)
      pcb->unsent = pcb->unsent->next;
    f890:	e0bfff17 	ldw	r2,-4(fp)
    f894:	10801e17 	ldw	r2,120(r2)
    f898:	10c00017 	ldw	r3,0(r2)
    f89c:	e0bfff17 	ldw	r2,-4(fp)
    f8a0:	10c01e15 	stw	r3,120(r2)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
    f8a4:	e0bfff17 	ldw	r2,-4(fp)
    f8a8:	14001d0b 	ldhu	r16,116(r2)
    f8ac:	e0bff317 	ldw	r2,-52(fp)
    f8b0:	10800117 	ldw	r2,4(r2)
    f8b4:	1009883a 	mov	r4,r2
    f8b8:	000a3380 	call	a338 <pbuf_clen>
    f8bc:	10803fcc 	andi	r2,r2,255
    f8c0:	80ffffcc 	andi	r3,r16,65535
    f8c4:	10bfffcc 	andi	r2,r2,65535
    f8c8:	1880092e 	bgeu	r3,r2,f8f0 <tcp_receive+0x718>
    f8cc:	010000f4 	movhi	r4,3
    f8d0:	213a1604 	addi	r4,r4,-6056
    f8d4:	014000f4 	movhi	r5,3
    f8d8:	297a7a04 	addi	r5,r5,-5656
    f8dc:	0180f784 	movi	r6,990
    f8e0:	01c000f4 	movhi	r7,3
    f8e4:	39fa2a04 	addi	r7,r7,-5976
    f8e8:	00166c00 	call	166c0 <printf>
    f8ec:	003fff06 	br	f8ec <tcp_receive+0x714>
      /* Prevent ACK for FIN to generate a sent event */
      if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
    f8f0:	e0bfff17 	ldw	r2,-4(fp)
    f8f4:	10801c0b 	ldhu	r2,112(r2)
    f8f8:	10bfffcc 	andi	r2,r2,65535
    f8fc:	10001526 	beq	r2,zero,f954 <tcp_receive+0x77c>
    f900:	e0bff317 	ldw	r2,-52(fp)
    f904:	10800417 	ldw	r2,16(r2)
    f908:	1080030b 	ldhu	r2,12(r2)
    f90c:	10bfffcc 	andi	r2,r2,65535
    f910:	1004d23a 	srli	r2,r2,8
    f914:	10ffffcc 	andi	r3,r2,65535
    f918:	e0bff317 	ldw	r2,-52(fp)
    f91c:	10800417 	ldw	r2,16(r2)
    f920:	1080030b 	ldhu	r2,12(r2)
    f924:	10bfffcc 	andi	r2,r2,65535
    f928:	1004923a 	slli	r2,r2,8
    f92c:	10bfffcc 	andi	r2,r2,65535
    f930:	1884b03a 	or	r2,r3,r2
    f934:	1080004c 	andi	r2,r2,1
    f938:	10000626 	beq	r2,zero,f954 <tcp_receive+0x77c>
        pcb->acked--;
    f93c:	e0bfff17 	ldw	r2,-4(fp)
    f940:	10801c0b 	ldhu	r2,112(r2)
    f944:	10bfffc4 	addi	r2,r2,-1
    f948:	1007883a 	mov	r3,r2
    f94c:	e0bfff17 	ldw	r2,-4(fp)
    f950:	10c01c0d 	sth	r3,112(r2)
      }
      pcb->snd_queuelen -= pbuf_clen(next->p);
    f954:	e0bfff17 	ldw	r2,-4(fp)
    f958:	14001d0b 	ldhu	r16,116(r2)
    f95c:	e0bff317 	ldw	r2,-52(fp)
    f960:	10800117 	ldw	r2,4(r2)
    f964:	1009883a 	mov	r4,r2
    f968:	000a3380 	call	a338 <pbuf_clen>
    f96c:	10803fcc 	andi	r2,r2,255
    f970:	8085c83a 	sub	r2,r16,r2
    f974:	1007883a 	mov	r3,r2
    f978:	e0bfff17 	ldw	r2,-4(fp)
    f97c:	10c01d0d 	sth	r3,116(r2)
      tcp_seg_free(next);
    f980:	e13ff317 	ldw	r4,-52(fp)
    f984:	000c97c0 	call	c97c <tcp_seg_free>
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
      if (pcb->snd_queuelen != 0) {
    f988:	e0bfff17 	ldw	r2,-4(fp)
    f98c:	10801d0b 	ldhu	r2,116(r2)
    f990:	10bfffcc 	andi	r2,r2,65535
    f994:	10001026 	beq	r2,zero,f9d8 <tcp_receive+0x800>
        LWIP_ASSERT("tcp_receive: valid queue length",
    f998:	e0bfff17 	ldw	r2,-4(fp)
    f99c:	10801f17 	ldw	r2,124(r2)
    f9a0:	10000d1e 	bne	r2,zero,f9d8 <tcp_receive+0x800>
    f9a4:	e0bfff17 	ldw	r2,-4(fp)
    f9a8:	10801e17 	ldw	r2,120(r2)
    f9ac:	10000a1e 	bne	r2,zero,f9d8 <tcp_receive+0x800>
    f9b0:	010000f4 	movhi	r4,3
    f9b4:	213a1604 	addi	r4,r4,-6056
    f9b8:	014000f4 	movhi	r5,3
    f9bc:	297a8404 	addi	r5,r5,-5616
    f9c0:	0180fa04 	movi	r6,1000
    f9c4:	01c000f4 	movhi	r7,3
    f9c8:	39fa2a04 	addi	r7,r7,-5976
    f9cc:	00166c00 	call	166c0 <printf>
    f9d0:	003fff06 	br	f9d0 <tcp_receive+0x7f8>
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
    f9d4:	0001883a 	nop
    f9d8:	e0bfff17 	ldw	r2,-4(fp)
    f9dc:	10801e17 	ldw	r2,120(r2)
    f9e0:	10004526 	beq	r2,zero,faf8 <tcp_receive+0x920>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
    f9e4:	d0e8df17 	ldw	r3,-23684(gp)
    f9e8:	e0bfff17 	ldw	r2,-4(fp)
    f9ec:	10801e17 	ldw	r2,120(r2)
    f9f0:	10800417 	ldw	r2,16(r2)
    f9f4:	1100010b 	ldhu	r4,4(r2)
    f9f8:	1080018b 	ldhu	r2,6(r2)
    f9fc:	1004943a 	slli	r2,r2,16
    fa00:	1104b03a 	or	r2,r2,r4
    fa04:	1008d63a 	srli	r4,r2,24
    fa08:	e0bfff17 	ldw	r2,-4(fp)
    fa0c:	10801e17 	ldw	r2,120(r2)
    fa10:	10800417 	ldw	r2,16(r2)
    fa14:	1140010b 	ldhu	r5,4(r2)
    fa18:	1080018b 	ldhu	r2,6(r2)
    fa1c:	1004943a 	slli	r2,r2,16
    fa20:	1144b03a 	or	r2,r2,r5
    fa24:	1004d23a 	srli	r2,r2,8
    fa28:	10bfc00c 	andi	r2,r2,65280
    fa2c:	2088b03a 	or	r4,r4,r2
    fa30:	e0bfff17 	ldw	r2,-4(fp)
    fa34:	10801e17 	ldw	r2,120(r2)
    fa38:	10800417 	ldw	r2,16(r2)
    fa3c:	1140010b 	ldhu	r5,4(r2)
    fa40:	1080018b 	ldhu	r2,6(r2)
    fa44:	1004943a 	slli	r2,r2,16
    fa48:	1144b03a 	or	r2,r2,r5
    fa4c:	10bfc00c 	andi	r2,r2,65280
    fa50:	1004923a 	slli	r2,r2,8
    fa54:	2088b03a 	or	r4,r4,r2
    fa58:	e0bfff17 	ldw	r2,-4(fp)
    fa5c:	10801e17 	ldw	r2,120(r2)
    fa60:	10800417 	ldw	r2,16(r2)
    fa64:	1140010b 	ldhu	r5,4(r2)
    fa68:	1080018b 	ldhu	r2,6(r2)
    fa6c:	1004943a 	slli	r2,r2,16
    fa70:	1144b03a 	or	r2,r2,r5
    fa74:	1004963a 	slli	r2,r2,24
    fa78:	2088b03a 	or	r4,r4,r2
    fa7c:	e0bfff17 	ldw	r2,-4(fp)
    fa80:	10801e17 	ldw	r2,120(r2)
    fa84:	1080030b 	ldhu	r2,12(r2)
    fa88:	117fffcc 	andi	r5,r2,65535
    fa8c:	e0bfff17 	ldw	r2,-4(fp)
    fa90:	10801e17 	ldw	r2,120(r2)
    fa94:	10800417 	ldw	r2,16(r2)
    fa98:	1080030b 	ldhu	r2,12(r2)
    fa9c:	10bfffcc 	andi	r2,r2,65535
    faa0:	1004d23a 	srli	r2,r2,8
    faa4:	11bfffcc 	andi	r6,r2,65535
    faa8:	e0bfff17 	ldw	r2,-4(fp)
    faac:	10801e17 	ldw	r2,120(r2)
    fab0:	10800417 	ldw	r2,16(r2)
    fab4:	1080030b 	ldhu	r2,12(r2)
    fab8:	10bfffcc 	andi	r2,r2,65535
    fabc:	1004923a 	slli	r2,r2,8
    fac0:	10bfffcc 	andi	r2,r2,65535
    fac4:	3084b03a 	or	r2,r6,r2
    fac8:	108000cc 	andi	r2,r2,3
    facc:	1004c03a 	cmpne	r2,r2,zero
    fad0:	10803fcc 	andi	r2,r2,255
    fad4:	2885883a 	add	r2,r5,r2
    fad8:	2085883a 	add	r2,r4,r2
    fadc:	1885c83a 	sub	r2,r3,r2
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
    fae0:	10000516 	blt	r2,zero,faf8 <tcp_receive+0x920>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
    fae4:	d0e8df17 	ldw	r3,-23684(gp)
    fae8:	e0bfff17 	ldw	r2,-4(fp)
    faec:	10801717 	ldw	r2,92(r2)
    faf0:	1885c83a 	sub	r2,r3,r2
    faf4:	00bf630e 	bge	zero,r2,f884 <tcp_receive+0x6ac>
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
    faf8:	e0bfff17 	ldw	r2,-4(fp)
    fafc:	10801017 	ldw	r2,64(r2)
    fb00:	10004326 	beq	r2,zero,fc10 <tcp_receive+0xa38>
    fb04:	e0bfff17 	ldw	r2,-4(fp)
    fb08:	10c01117 	ldw	r3,68(r2)
    fb0c:	d0a8df17 	ldw	r2,-23684(gp)
    fb10:	1885c83a 	sub	r2,r3,r2
    fb14:	10003e0e 	bge	r2,zero,fc10 <tcp_receive+0xa38>
      /* diff between this shouldn't exceed 32K since this are tcp timer ticks
         and a round-trip shouldn't be that long... */
      m = (s16_t)(tcp_ticks - pcb->rttest);
    fb18:	008000f4 	movhi	r2,3
    fb1c:	1095f704 	addi	r2,r2,22492
    fb20:	10800017 	ldw	r2,0(r2)
    fb24:	1007883a 	mov	r3,r2
    fb28:	e0bfff17 	ldw	r2,-4(fp)
    fb2c:	10801017 	ldw	r2,64(r2)
    fb30:	1885c83a 	sub	r2,r3,r2
    fb34:	e0bff70d 	sth	r2,-36(fp)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
    fb38:	e0fff70b 	ldhu	r3,-36(fp)
    fb3c:	e0bfff17 	ldw	r2,-4(fp)
    fb40:	1080120b 	ldhu	r2,72(r2)
    fb44:	10bfffcc 	andi	r2,r2,65535
    fb48:	10a0001c 	xori	r2,r2,32768
    fb4c:	10a00004 	addi	r2,r2,-32768
    fb50:	1005d0fa 	srai	r2,r2,3
    fb54:	1885c83a 	sub	r2,r3,r2
    fb58:	e0bff70d 	sth	r2,-36(fp)
      pcb->sa += m;
    fb5c:	e0bfff17 	ldw	r2,-4(fp)
    fb60:	1080120b 	ldhu	r2,72(r2)
    fb64:	1007883a 	mov	r3,r2
    fb68:	e0bff70b 	ldhu	r2,-36(fp)
    fb6c:	1885883a 	add	r2,r3,r2
    fb70:	1007883a 	mov	r3,r2
    fb74:	e0bfff17 	ldw	r2,-4(fp)
    fb78:	10c0120d 	sth	r3,72(r2)
      if (m < 0) {
    fb7c:	e0bff70f 	ldh	r2,-36(fp)
    fb80:	1000030e 	bge	r2,zero,fb90 <tcp_receive+0x9b8>
        m = -m;
    fb84:	e0bff70b 	ldhu	r2,-36(fp)
    fb88:	0085c83a 	sub	r2,zero,r2
    fb8c:	e0bff70d 	sth	r2,-36(fp)
      }
      m = m - (pcb->sv >> 2);
    fb90:	e0fff70b 	ldhu	r3,-36(fp)
    fb94:	e0bfff17 	ldw	r2,-4(fp)
    fb98:	1080128b 	ldhu	r2,74(r2)
    fb9c:	10bfffcc 	andi	r2,r2,65535
    fba0:	10a0001c 	xori	r2,r2,32768
    fba4:	10a00004 	addi	r2,r2,-32768
    fba8:	1005d0ba 	srai	r2,r2,2
    fbac:	1885c83a 	sub	r2,r3,r2
    fbb0:	e0bff70d 	sth	r2,-36(fp)
      pcb->sv += m;
    fbb4:	e0bfff17 	ldw	r2,-4(fp)
    fbb8:	1080128b 	ldhu	r2,74(r2)
    fbbc:	1007883a 	mov	r3,r2
    fbc0:	e0bff70b 	ldhu	r2,-36(fp)
    fbc4:	1885883a 	add	r2,r3,r2
    fbc8:	1007883a 	mov	r3,r2
    fbcc:	e0bfff17 	ldw	r2,-4(fp)
    fbd0:	10c0128d 	sth	r3,74(r2)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
    fbd4:	e0bfff17 	ldw	r2,-4(fp)
    fbd8:	1080120b 	ldhu	r2,72(r2)
    fbdc:	10bfffcc 	andi	r2,r2,65535
    fbe0:	10a0001c 	xori	r2,r2,32768
    fbe4:	10a00004 	addi	r2,r2,-32768
    fbe8:	1005d0fa 	srai	r2,r2,3
    fbec:	1007883a 	mov	r3,r2
    fbf0:	e0bfff17 	ldw	r2,-4(fp)
    fbf4:	1080128b 	ldhu	r2,74(r2)
    fbf8:	1885883a 	add	r2,r3,r2
    fbfc:	1007883a 	mov	r3,r2
    fc00:	e0bfff17 	ldw	r2,-4(fp)
    fc04:	10c0130d 	sth	r3,76(r2)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
    fc08:	e0bfff17 	ldw	r2,-4(fp)
    fc0c:	10001015 	stw	zero,64(r2)
    }
  }

  /* If the incoming segment contains data, we must process it
     further. */
  if (tcplen > 0) {
    fc10:	d0a8e08b 	ldhu	r2,-23678(gp)
    fc14:	10bfffcc 	andi	r2,r2,65535
    fc18:	10045b26 	beq	r2,zero,10d88 <tcp_receive+0x1bb0>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
    fc1c:	e0bfff17 	ldw	r2,-4(fp)
    fc20:	10c00a17 	ldw	r3,40(r2)
    fc24:	d0a8de17 	ldw	r2,-23688(gp)
    fc28:	0084303a 	nor	r2,zero,r2
    fc2c:	1885883a 	add	r2,r3,r2
    fc30:	1000aa16 	blt	r2,zero,fedc <tcp_receive+0xd04>
    fc34:	e0bfff17 	ldw	r2,-4(fp)
    fc38:	10c00a17 	ldw	r3,40(r2)
    fc3c:	d0a8e08b 	ldhu	r2,-23678(gp)
    fc40:	113fffcc 	andi	r4,r2,65535
    fc44:	d0a8de17 	ldw	r2,-23688(gp)
    fc48:	2085883a 	add	r2,r4,r2
    fc4c:	1885c83a 	sub	r2,r3,r2
    fc50:	10800044 	addi	r2,r2,1
    fc54:	0080a116 	blt	zero,r2,fedc <tcp_receive+0xd04>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
    fc58:	e0bfff17 	ldw	r2,-4(fp)
    fc5c:	10c00a17 	ldw	r3,40(r2)
    fc60:	d0a8de17 	ldw	r2,-23688(gp)
    fc64:	1885c83a 	sub	r2,r3,r2
    fc68:	e0bff615 	stw	r2,-40(fp)
      p = inseg.p;
    fc6c:	00800134 	movhi	r2,4
    fc70:	108cfa04 	addi	r2,r2,13288
    fc74:	10800117 	ldw	r2,4(r2)
    fc78:	e0bff515 	stw	r2,-44(fp)
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
    fc7c:	00800134 	movhi	r2,4
    fc80:	108cfa04 	addi	r2,r2,13288
    fc84:	10800117 	ldw	r2,4(r2)
    fc88:	1000091e 	bne	r2,zero,fcb0 <tcp_receive+0xad8>
    fc8c:	010000f4 	movhi	r4,3
    fc90:	213a1604 	addi	r4,r4,-6056
    fc94:	014000f4 	movhi	r5,3
    fc98:	297a8c04 	addi	r5,r5,-5584
    fc9c:	01811104 	movi	r6,1092
    fca0:	01c000f4 	movhi	r7,3
    fca4:	39fa2a04 	addi	r7,r7,-5976
    fca8:	00166c00 	call	166c0 <printf>
    fcac:	003fff06 	br	fcac <tcp_receive+0xad4>
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
    fcb0:	e0bff617 	ldw	r2,-40(fp)
    fcb4:	109fffd0 	cmplti	r2,r2,32767
    fcb8:	1000091e 	bne	r2,zero,fce0 <tcp_receive+0xb08>
    fcbc:	010000f4 	movhi	r4,3
    fcc0:	213a1604 	addi	r4,r4,-6056
    fcc4:	014000f4 	movhi	r5,3
    fcc8:	297a9004 	addi	r5,r5,-5568
    fccc:	01811144 	movi	r6,1093
    fcd0:	01c000f4 	movhi	r7,3
    fcd4:	39fa2a04 	addi	r7,r7,-5976
    fcd8:	00166c00 	call	166c0 <printf>
    fcdc:	003fff06 	br	fcdc <tcp_receive+0xb04>
      if (inseg.p->len < off) {
    fce0:	00800134 	movhi	r2,4
    fce4:	108cfa04 	addi	r2,r2,13288
    fce8:	10800117 	ldw	r2,4(r2)
    fcec:	1080028b 	ldhu	r2,10(r2)
    fcf0:	10ffffcc 	andi	r3,r2,65535
    fcf4:	e0bff617 	ldw	r2,-40(fp)
    fcf8:	18803e0e 	bge	r3,r2,fdf4 <tcp_receive+0xc1c>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
    fcfc:	00800134 	movhi	r2,4
    fd00:	108cfa04 	addi	r2,r2,13288
    fd04:	10800117 	ldw	r2,4(r2)
    fd08:	1080020b 	ldhu	r2,8(r2)
    fd0c:	10ffffcc 	andi	r3,r2,65535
    fd10:	e0bff617 	ldw	r2,-40(fp)
    fd14:	1880090e 	bge	r3,r2,fd3c <tcp_receive+0xb64>
    fd18:	010000f4 	movhi	r4,3
    fd1c:	213a1604 	addi	r4,r4,-6056
    fd20:	014000f4 	movhi	r5,3
    fd24:	297a9404 	addi	r5,r5,-5552
    fd28:	018111c4 	movi	r6,1095
    fd2c:	01c000f4 	movhi	r7,3
    fd30:	39fa2a04 	addi	r7,r7,-5976
    fd34:	00166c00 	call	166c0 <printf>
    fd38:	003fff06 	br	fd38 <tcp_receive+0xb60>
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
    fd3c:	00800134 	movhi	r2,4
    fd40:	108cfa04 	addi	r2,r2,13288
    fd44:	10800117 	ldw	r2,4(r2)
    fd48:	10c0020b 	ldhu	r3,8(r2)
    fd4c:	e0bff617 	ldw	r2,-40(fp)
    fd50:	1885c83a 	sub	r2,r3,r2
    fd54:	e0bffb8d 	sth	r2,-18(fp)
        while (p->len < off) {
    fd58:	00000e06 	br	fd94 <tcp_receive+0xbbc>
          off -= p->len;
    fd5c:	e0bff517 	ldw	r2,-44(fp)
    fd60:	1080028b 	ldhu	r2,10(r2)
    fd64:	10bfffcc 	andi	r2,r2,65535
    fd68:	e0fff617 	ldw	r3,-40(fp)
    fd6c:	1885c83a 	sub	r2,r3,r2
    fd70:	e0bff615 	stw	r2,-40(fp)
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
    fd74:	e0bff517 	ldw	r2,-44(fp)
    fd78:	e0fffb8b 	ldhu	r3,-18(fp)
    fd7c:	10c0020d 	sth	r3,8(r2)
          p->len = 0;
    fd80:	e0bff517 	ldw	r2,-44(fp)
    fd84:	1000028d 	sth	zero,10(r2)
          p = p->next;
    fd88:	e0bff517 	ldw	r2,-44(fp)
    fd8c:	10800017 	ldw	r2,0(r2)
    fd90:	e0bff515 	stw	r2,-44(fp)
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
    fd94:	e0bff517 	ldw	r2,-44(fp)
    fd98:	1080028b 	ldhu	r2,10(r2)
    fd9c:	10ffffcc 	andi	r3,r2,65535
    fda0:	e0bff617 	ldw	r2,-40(fp)
    fda4:	18bfed16 	blt	r3,r2,fd5c <tcp_receive+0xb84>
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
          p = p->next;
        }
        if(pbuf_header(p, (s16_t)-off)) {
    fda8:	e0bff617 	ldw	r2,-40(fp)
    fdac:	0085c83a 	sub	r2,zero,r2
    fdb0:	10bfffcc 	andi	r2,r2,65535
    fdb4:	10a0001c 	xori	r2,r2,32768
    fdb8:	10a00004 	addi	r2,r2,-32768
    fdbc:	e13ff517 	ldw	r4,-44(fp)
    fdc0:	100b883a 	mov	r5,r2
    fdc4:	0009f740 	call	9f74 <pbuf_header>
    fdc8:	10803fcc 	andi	r2,r2,255
    fdcc:	10001f26 	beq	r2,zero,fe4c <tcp_receive+0xc74>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
    fdd0:	010000f4 	movhi	r4,3
    fdd4:	213a1604 	addi	r4,r4,-6056
    fdd8:	014000f4 	movhi	r5,3
    fddc:	297a9804 	addi	r5,r5,-5536
    fde0:	01811504 	movi	r6,1108
    fde4:	01c000f4 	movhi	r7,3
    fde8:	39fa2a04 	addi	r7,r7,-5976
    fdec:	00166c00 	call	166c0 <printf>
    fdf0:	003fff06 	br	fdf0 <tcp_receive+0xc18>
        }
      } else {
        if(pbuf_header(inseg.p, (s16_t)-off)) {
    fdf4:	00800134 	movhi	r2,4
    fdf8:	108cfa04 	addi	r2,r2,13288
    fdfc:	10c00117 	ldw	r3,4(r2)
    fe00:	e0bff617 	ldw	r2,-40(fp)
    fe04:	0085c83a 	sub	r2,zero,r2
    fe08:	10bfffcc 	andi	r2,r2,65535
    fe0c:	10a0001c 	xori	r2,r2,32768
    fe10:	10a00004 	addi	r2,r2,-32768
    fe14:	1809883a 	mov	r4,r3
    fe18:	100b883a 	mov	r5,r2
    fe1c:	0009f740 	call	9f74 <pbuf_header>
    fe20:	10803fcc 	andi	r2,r2,255
    fe24:	10000926 	beq	r2,zero,fe4c <tcp_receive+0xc74>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
    fe28:	010000f4 	movhi	r4,3
    fe2c:	213a1604 	addi	r4,r4,-6056
    fe30:	014000f4 	movhi	r5,3
    fe34:	297a9804 	addi	r5,r5,-5536
    fe38:	01811644 	movi	r6,1113
    fe3c:	01c000f4 	movhi	r7,3
    fe40:	39fa2a04 	addi	r7,r7,-5976
    fe44:	00166c00 	call	166c0 <printf>
    fe48:	003fff06 	br	fe48 <tcp_receive+0xc70>
        }
      }
      /* KJM following line changed to use p->payload rather than inseg->p->payload
         to fix bug #9076 */
      inseg.dataptr = p->payload;
    fe4c:	e0bff517 	ldw	r2,-44(fp)
    fe50:	10c00117 	ldw	r3,4(r2)
    fe54:	00800134 	movhi	r2,4
    fe58:	108cfa04 	addi	r2,r2,13288
    fe5c:	10c00215 	stw	r3,8(r2)
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
    fe60:	00800134 	movhi	r2,4
    fe64:	108cfa04 	addi	r2,r2,13288
    fe68:	10c0030b 	ldhu	r3,12(r2)
    fe6c:	d0a8de17 	ldw	r2,-23688(gp)
    fe70:	1009883a 	mov	r4,r2
    fe74:	e0bfff17 	ldw	r2,-4(fp)
    fe78:	10800a17 	ldw	r2,40(r2)
    fe7c:	2085c83a 	sub	r2,r4,r2
    fe80:	1885883a 	add	r2,r3,r2
    fe84:	1007883a 	mov	r3,r2
    fe88:	00800134 	movhi	r2,4
    fe8c:	108cfa04 	addi	r2,r2,13288
    fe90:	10c0030d 	sth	r3,12(r2)
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
    fe94:	00800134 	movhi	r2,4
    fe98:	108cfa04 	addi	r2,r2,13288
    fe9c:	10800417 	ldw	r2,16(r2)
    fea0:	e0ffff17 	ldw	r3,-4(fp)
    fea4:	18c00a17 	ldw	r3,40(r3)
    fea8:	d0e8de15 	stw	r3,-23688(gp)
    feac:	d0e8de17 	ldw	r3,-23688(gp)
    feb0:	193fffcc 	andi	r4,r3,65535
    feb4:	1140010b 	ldhu	r5,4(r2)
    feb8:	280a703a 	and	r5,r5,zero
    febc:	2908b03a 	or	r4,r5,r4
    fec0:	1100010d 	sth	r4,4(r2)
    fec4:	1806d43a 	srli	r3,r3,16
    fec8:	1100018b 	ldhu	r4,6(r2)
    fecc:	2008703a 	and	r4,r4,zero
    fed0:	20c6b03a 	or	r3,r4,r3
    fed4:	10c0018d 	sth	r3,6(r2)
    fed8:	00000d06 	br	ff10 <tcp_receive+0xd38>
    }
    else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
    fedc:	d0e8de17 	ldw	r3,-23688(gp)
    fee0:	e0bfff17 	ldw	r2,-4(fp)
    fee4:	10800a17 	ldw	r2,40(r2)
    fee8:	1885c83a 	sub	r2,r3,r2
    feec:	1000080e 	bge	r2,zero,ff10 <tcp_receive+0xd38>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
    fef0:	e0bfff17 	ldw	r2,-4(fp)
    fef4:	10800983 	ldbu	r2,38(r2)
    fef8:	10800094 	ori	r2,r2,2
    fefc:	1007883a 	mov	r3,r2
    ff00:	e0bfff17 	ldw	r2,-4(fp)
    ff04:	10c00985 	stb	r3,38(r2)
    ff08:	e13fff17 	ldw	r4,-4(fp)
    ff0c:	00122380 	call	12238 <tcp_output>
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
    ff10:	d0e8de17 	ldw	r3,-23688(gp)
    ff14:	e0bfff17 	ldw	r2,-4(fp)
    ff18:	10800a17 	ldw	r2,40(r2)
    ff1c:	1885c83a 	sub	r2,r3,r2
    ff20:	10039616 	blt	r2,zero,10d7c <tcp_receive+0x1ba4>
    ff24:	d0e8de17 	ldw	r3,-23688(gp)
    ff28:	e0bfff17 	ldw	r2,-4(fp)
    ff2c:	11000a17 	ldw	r4,40(r2)
    ff30:	e0bfff17 	ldw	r2,-4(fp)
    ff34:	10800b0b 	ldhu	r2,44(r2)
    ff38:	10bfffcc 	andi	r2,r2,65535
    ff3c:	2085883a 	add	r2,r4,r2
    ff40:	1885c83a 	sub	r2,r3,r2
    ff44:	10800044 	addi	r2,r2,1
    ff48:	00838c16 	blt	zero,r2,10d7c <tcp_receive+0x1ba4>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
    ff4c:	e0bfff17 	ldw	r2,-4(fp)
    ff50:	10c00a17 	ldw	r3,40(r2)
    ff54:	d0a8de17 	ldw	r2,-23688(gp)
    ff58:	18829e1e 	bne	r3,r2,109d4 <tcp_receive+0x17fc>
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
        tcplen = TCP_TCPLEN(&inseg);
    ff5c:	00800134 	movhi	r2,4
    ff60:	108cfa04 	addi	r2,r2,13288
    ff64:	10c0030b 	ldhu	r3,12(r2)
    ff68:	00800134 	movhi	r2,4
    ff6c:	108cfa04 	addi	r2,r2,13288
    ff70:	10800417 	ldw	r2,16(r2)
    ff74:	1080030b 	ldhu	r2,12(r2)
    ff78:	10bfffcc 	andi	r2,r2,65535
    ff7c:	1004d23a 	srli	r2,r2,8
    ff80:	113fffcc 	andi	r4,r2,65535
    ff84:	00800134 	movhi	r2,4
    ff88:	108cfa04 	addi	r2,r2,13288
    ff8c:	10800417 	ldw	r2,16(r2)
    ff90:	1080030b 	ldhu	r2,12(r2)
    ff94:	10bfffcc 	andi	r2,r2,65535
    ff98:	1004923a 	slli	r2,r2,8
    ff9c:	10bfffcc 	andi	r2,r2,65535
    ffa0:	2084b03a 	or	r2,r4,r2
    ffa4:	108000cc 	andi	r2,r2,3
    ffa8:	1004c03a 	cmpne	r2,r2,zero
    ffac:	10803fcc 	andi	r2,r2,255
    ffb0:	1885883a 	add	r2,r3,r2
    ffb4:	d0a8e08d 	sth	r2,-23678(gp)

        if (tcplen > pcb->rcv_wnd) {
    ffb8:	e0bfff17 	ldw	r2,-4(fp)
    ffbc:	10c00b0b 	ldhu	r3,44(r2)
    ffc0:	d0a8e08b 	ldhu	r2,-23678(gp)
    ffc4:	18ffffcc 	andi	r3,r3,65535
    ffc8:	10bfffcc 	andi	r2,r2,65535
    ffcc:	1880802e 	bgeu	r3,r2,101d0 <tcp_receive+0xff8>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, 
                      ("tcp_receive: other end overran receive window"
                       "seqno %"U32_F" len %"U32_F" right edge %"U32_F"\n",
                       seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
    ffd0:	00800134 	movhi	r2,4
    ffd4:	108cfa04 	addi	r2,r2,13288
    ffd8:	10800417 	ldw	r2,16(r2)
    ffdc:	1080030b 	ldhu	r2,12(r2)
    ffe0:	10bfffcc 	andi	r2,r2,65535
    ffe4:	1004d23a 	srli	r2,r2,8
    ffe8:	10ffffcc 	andi	r3,r2,65535
    ffec:	00800134 	movhi	r2,4
    fff0:	108cfa04 	addi	r2,r2,13288
    fff4:	10800417 	ldw	r2,16(r2)
    fff8:	1080030b 	ldhu	r2,12(r2)
    fffc:	10bfffcc 	andi	r2,r2,65535
   10000:	1004923a 	slli	r2,r2,8
   10004:	10bfffcc 	andi	r2,r2,65535
   10008:	1884b03a 	or	r2,r3,r2
   1000c:	1080004c 	andi	r2,r2,1
   10010:	10001c26 	beq	r2,zero,10084 <tcp_receive+0xeac>
            /* Must remove the FIN from the header as we're trimming 
             * that byte of sequence-space from the packet */
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) &~ TCP_FIN);
   10014:	00800134 	movhi	r2,4
   10018:	108cfa04 	addi	r2,r2,13288
   1001c:	10800417 	ldw	r2,16(r2)
   10020:	00c00134 	movhi	r3,4
   10024:	18ccfa04 	addi	r3,r3,13288
   10028:	18c00417 	ldw	r3,16(r3)
   1002c:	1900030b 	ldhu	r4,12(r3)
   10030:	00f03fc4 	movi	r3,-16129
   10034:	20c6703a 	and	r3,r4,r3
   10038:	1809883a 	mov	r4,r3
   1003c:	00c00134 	movhi	r3,4
   10040:	18ccfa04 	addi	r3,r3,13288
   10044:	18c00417 	ldw	r3,16(r3)
   10048:	18c0030b 	ldhu	r3,12(r3)
   1004c:	18ffffcc 	andi	r3,r3,65535
   10050:	1806d23a 	srli	r3,r3,8
   10054:	180b883a 	mov	r5,r3
   10058:	00c00134 	movhi	r3,4
   1005c:	18ccfa04 	addi	r3,r3,13288
   10060:	18c00417 	ldw	r3,16(r3)
   10064:	18c0030b 	ldhu	r3,12(r3)
   10068:	18ffffcc 	andi	r3,r3,65535
   1006c:	1806923a 	slli	r3,r3,8
   10070:	28c6b03a 	or	r3,r5,r3
   10074:	18c00f8c 	andi	r3,r3,62
   10078:	1806923a 	slli	r3,r3,8
   1007c:	20c6b03a 	or	r3,r4,r3
   10080:	10c0030d 	sth	r3,12(r2)
          }
          /* Adjust length of segment to fit in the window. */
          inseg.len = pcb->rcv_wnd;
   10084:	e0bfff17 	ldw	r2,-4(fp)
   10088:	10c00b0b 	ldhu	r3,44(r2)
   1008c:	00800134 	movhi	r2,4
   10090:	108cfa04 	addi	r2,r2,13288
   10094:	10c0030d 	sth	r3,12(r2)
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
   10098:	00800134 	movhi	r2,4
   1009c:	108cfa04 	addi	r2,r2,13288
   100a0:	10800417 	ldw	r2,16(r2)
   100a4:	1080030b 	ldhu	r2,12(r2)
   100a8:	10bfffcc 	andi	r2,r2,65535
   100ac:	1004d23a 	srli	r2,r2,8
   100b0:	10ffffcc 	andi	r3,r2,65535
   100b4:	00800134 	movhi	r2,4
   100b8:	108cfa04 	addi	r2,r2,13288
   100bc:	10800417 	ldw	r2,16(r2)
   100c0:	1080030b 	ldhu	r2,12(r2)
   100c4:	10bfffcc 	andi	r2,r2,65535
   100c8:	1004923a 	slli	r2,r2,8
   100cc:	10bfffcc 	andi	r2,r2,65535
   100d0:	1884b03a 	or	r2,r3,r2
   100d4:	1080008c 	andi	r2,r2,2
   100d8:	10000826 	beq	r2,zero,100fc <tcp_receive+0xf24>
            inseg.len -= 1;
   100dc:	00800134 	movhi	r2,4
   100e0:	108cfa04 	addi	r2,r2,13288
   100e4:	1080030b 	ldhu	r2,12(r2)
   100e8:	10bfffc4 	addi	r2,r2,-1
   100ec:	1007883a 	mov	r3,r2
   100f0:	00800134 	movhi	r2,4
   100f4:	108cfa04 	addi	r2,r2,13288
   100f8:	10c0030d 	sth	r3,12(r2)
          }
          pbuf_realloc(inseg.p, inseg.len);
   100fc:	00800134 	movhi	r2,4
   10100:	108cfa04 	addi	r2,r2,13288
   10104:	10c00117 	ldw	r3,4(r2)
   10108:	00800134 	movhi	r2,4
   1010c:	108cfa04 	addi	r2,r2,13288
   10110:	1080030b 	ldhu	r2,12(r2)
   10114:	10bfffcc 	andi	r2,r2,65535
   10118:	1809883a 	mov	r4,r3
   1011c:	100b883a 	mov	r5,r2
   10120:	0009cf00 	call	9cf0 <pbuf_realloc>
          tcplen = TCP_TCPLEN(&inseg);
   10124:	00800134 	movhi	r2,4
   10128:	108cfa04 	addi	r2,r2,13288
   1012c:	10c0030b 	ldhu	r3,12(r2)
   10130:	00800134 	movhi	r2,4
   10134:	108cfa04 	addi	r2,r2,13288
   10138:	10800417 	ldw	r2,16(r2)
   1013c:	1080030b 	ldhu	r2,12(r2)
   10140:	10bfffcc 	andi	r2,r2,65535
   10144:	1004d23a 	srli	r2,r2,8
   10148:	113fffcc 	andi	r4,r2,65535
   1014c:	00800134 	movhi	r2,4
   10150:	108cfa04 	addi	r2,r2,13288
   10154:	10800417 	ldw	r2,16(r2)
   10158:	1080030b 	ldhu	r2,12(r2)
   1015c:	10bfffcc 	andi	r2,r2,65535
   10160:	1004923a 	slli	r2,r2,8
   10164:	10bfffcc 	andi	r2,r2,65535
   10168:	2084b03a 	or	r2,r4,r2
   1016c:	108000cc 	andi	r2,r2,3
   10170:	1004c03a 	cmpne	r2,r2,zero
   10174:	10803fcc 	andi	r2,r2,255
   10178:	1885883a 	add	r2,r3,r2
   1017c:	d0a8e08d 	sth	r2,-23678(gp)
          LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
   10180:	d0a8e08b 	ldhu	r2,-23678(gp)
   10184:	10ffffcc 	andi	r3,r2,65535
   10188:	d0a8de17 	ldw	r2,-23688(gp)
   1018c:	1887883a 	add	r3,r3,r2
   10190:	e0bfff17 	ldw	r2,-4(fp)
   10194:	11000a17 	ldw	r4,40(r2)
   10198:	e0bfff17 	ldw	r2,-4(fp)
   1019c:	10800b0b 	ldhu	r2,44(r2)
   101a0:	10bfffcc 	andi	r2,r2,65535
   101a4:	2085883a 	add	r2,r4,r2
   101a8:	18800926 	beq	r3,r2,101d0 <tcp_receive+0xff8>
   101ac:	010000f4 	movhi	r4,3
   101b0:	213a1604 	addi	r4,r4,-6056
   101b4:	014000f4 	movhi	r5,3
   101b8:	297a9d04 	addi	r5,r5,-5516
   101bc:	01812244 	movi	r6,1161
   101c0:	01c000f4 	movhi	r7,3
   101c4:	39fa2a04 	addi	r7,r7,-5976
   101c8:	00166c00 	call	166c0 <printf>
   101cc:	003fff06 	br	101cc <tcp_receive+0xff4>
                      (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
        }
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL) {
   101d0:	e0bfff17 	ldw	r2,-4(fp)
   101d4:	10802017 	ldw	r2,128(r2)
   101d8:	10010026 	beq	r2,zero,105dc <tcp_receive+0x1404>
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
   101dc:	00800134 	movhi	r2,4
   101e0:	108cfa04 	addi	r2,r2,13288
   101e4:	10800417 	ldw	r2,16(r2)
   101e8:	1080030b 	ldhu	r2,12(r2)
   101ec:	10bfffcc 	andi	r2,r2,65535
   101f0:	1004d23a 	srli	r2,r2,8
   101f4:	10ffffcc 	andi	r3,r2,65535
   101f8:	00800134 	movhi	r2,4
   101fc:	108cfa04 	addi	r2,r2,13288
   10200:	10800417 	ldw	r2,16(r2)
   10204:	1080030b 	ldhu	r2,12(r2)
   10208:	10bfffcc 	andi	r2,r2,65535
   1020c:	1004923a 	slli	r2,r2,8
   10210:	10bfffcc 	andi	r2,r2,65535
   10214:	1884b03a 	or	r2,r3,r2
   10218:	1080004c 	andi	r2,r2,1
   1021c:	10000f26 	beq	r2,zero,1025c <tcp_receive+0x1084>
             * bin the ooseq queue
             * rcv_nxt
             * .    |--ooseq--|
             * .==seg============|FIN
             */
            while (pcb->ooseq != NULL) {
   10220:	00000a06 	br	1024c <tcp_receive+0x1074>
              struct tcp_seg *old_ooseq = pcb->ooseq;
   10224:	e0bfff17 	ldw	r2,-4(fp)
   10228:	10802017 	ldw	r2,128(r2)
   1022c:	e0bffc15 	stw	r2,-16(fp)
              pcb->ooseq = pcb->ooseq->next;
   10230:	e0bfff17 	ldw	r2,-4(fp)
   10234:	10802017 	ldw	r2,128(r2)
   10238:	10c00017 	ldw	r3,0(r2)
   1023c:	e0bfff17 	ldw	r2,-4(fp)
   10240:	10c02015 	stw	r3,128(r2)
              tcp_seg_free(old_ooseq);
   10244:	e13ffc17 	ldw	r4,-16(fp)
   10248:	000c97c0 	call	c97c <tcp_seg_free>
             * bin the ooseq queue
             * rcv_nxt
             * .    |--ooseq--|
             * .==seg============|FIN
             */
            while (pcb->ooseq != NULL) {
   1024c:	e0bfff17 	ldw	r2,-4(fp)
   10250:	10802017 	ldw	r2,128(r2)
   10254:	103ff31e 	bne	r2,zero,10224 <tcp_receive+0x104c>
   10258:	0000e006 	br	105dc <tcp_receive+0x1404>
              pcb->ooseq = pcb->ooseq->next;
              tcp_seg_free(old_ooseq);
            }               
          } 
          else {
            struct tcp_seg* next = pcb->ooseq;
   1025c:	e0bfff17 	ldw	r2,-4(fp)
   10260:	10802017 	ldw	r2,128(r2)
   10264:	e0bff915 	stw	r2,-28(fp)
            struct tcp_seg *old_seg;
            /* rcv_nxt
             * .    |--ooseq--|
             * .==seg============|
             */
            while (next &&
   10268:	00005b06 	br	103d8 <tcp_receive+0x1200>
                   TCP_SEQ_GEQ(seqno + tcplen,
                               next->tcphdr->seqno + next->len)) {
              /* inseg doesn't have FIN (already processed) */
              if (TCPH_FLAGS(next->tcphdr) & TCP_FIN &&
   1026c:	e0bff917 	ldw	r2,-28(fp)
   10270:	10800417 	ldw	r2,16(r2)
   10274:	1080030b 	ldhu	r2,12(r2)
   10278:	10bfffcc 	andi	r2,r2,65535
   1027c:	1004d23a 	srli	r2,r2,8
   10280:	10ffffcc 	andi	r3,r2,65535
   10284:	e0bff917 	ldw	r2,-28(fp)
   10288:	10800417 	ldw	r2,16(r2)
   1028c:	1080030b 	ldhu	r2,12(r2)
   10290:	10bfffcc 	andi	r2,r2,65535
   10294:	1004923a 	slli	r2,r2,8
   10298:	10bfffcc 	andi	r2,r2,65535
   1029c:	1884b03a 	or	r2,r3,r2
   102a0:	1080004c 	andi	r2,r2,1
   102a4:	10004526 	beq	r2,zero,103bc <tcp_receive+0x11e4>
                  (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
   102a8:	00800134 	movhi	r2,4
   102ac:	108cfa04 	addi	r2,r2,13288
   102b0:	10800417 	ldw	r2,16(r2)
   102b4:	1080030b 	ldhu	r2,12(r2)
   102b8:	10bfffcc 	andi	r2,r2,65535
   102bc:	1004d23a 	srli	r2,r2,8
   102c0:	10ffffcc 	andi	r3,r2,65535
   102c4:	00800134 	movhi	r2,4
   102c8:	108cfa04 	addi	r2,r2,13288
   102cc:	10800417 	ldw	r2,16(r2)
   102d0:	1080030b 	ldhu	r2,12(r2)
   102d4:	10bfffcc 	andi	r2,r2,65535
   102d8:	1004923a 	slli	r2,r2,8
   102dc:	10bfffcc 	andi	r2,r2,65535
   102e0:	1884b03a 	or	r2,r3,r2
   102e4:	1080008c 	andi	r2,r2,2
             */
            while (next &&
                   TCP_SEQ_GEQ(seqno + tcplen,
                               next->tcphdr->seqno + next->len)) {
              /* inseg doesn't have FIN (already processed) */
              if (TCPH_FLAGS(next->tcphdr) & TCP_FIN &&
   102e8:	1000341e 	bne	r2,zero,103bc <tcp_receive+0x11e4>
                  (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
                TCPH_FLAGS_SET(inseg.tcphdr, 
   102ec:	00800134 	movhi	r2,4
   102f0:	108cfa04 	addi	r2,r2,13288
   102f4:	10800417 	ldw	r2,16(r2)
   102f8:	00c00134 	movhi	r3,4
   102fc:	18ccfa04 	addi	r3,r3,13288
   10300:	18c00417 	ldw	r3,16(r3)
   10304:	1900030b 	ldhu	r4,12(r3)
   10308:	00f03fc4 	movi	r3,-16129
   1030c:	20c6703a 	and	r3,r4,r3
   10310:	1809883a 	mov	r4,r3
   10314:	00c00134 	movhi	r3,4
   10318:	18ccfa04 	addi	r3,r3,13288
   1031c:	18c00417 	ldw	r3,16(r3)
   10320:	18c0030b 	ldhu	r3,12(r3)
   10324:	18ffffcc 	andi	r3,r3,65535
   10328:	1806d23a 	srli	r3,r3,8
   1032c:	180b883a 	mov	r5,r3
   10330:	00c00134 	movhi	r3,4
   10334:	18ccfa04 	addi	r3,r3,13288
   10338:	18c00417 	ldw	r3,16(r3)
   1033c:	18c0030b 	ldhu	r3,12(r3)
   10340:	18ffffcc 	andi	r3,r3,65535
   10344:	1806923a 	slli	r3,r3,8
   10348:	28c6b03a 	or	r3,r5,r3
   1034c:	18c00f8c 	andi	r3,r3,62
   10350:	18c00054 	ori	r3,r3,1
   10354:	1806923a 	slli	r3,r3,8
   10358:	20c6b03a 	or	r3,r4,r3
   1035c:	10c0030d 	sth	r3,12(r2)
                               TCPH_FLAGS(inseg.tcphdr) | TCP_FIN);
                tcplen = TCP_TCPLEN(&inseg);
   10360:	00800134 	movhi	r2,4
   10364:	108cfa04 	addi	r2,r2,13288
   10368:	10c0030b 	ldhu	r3,12(r2)
   1036c:	00800134 	movhi	r2,4
   10370:	108cfa04 	addi	r2,r2,13288
   10374:	10800417 	ldw	r2,16(r2)
   10378:	1080030b 	ldhu	r2,12(r2)
   1037c:	10bfffcc 	andi	r2,r2,65535
   10380:	1004d23a 	srli	r2,r2,8
   10384:	113fffcc 	andi	r4,r2,65535
   10388:	00800134 	movhi	r2,4
   1038c:	108cfa04 	addi	r2,r2,13288
   10390:	10800417 	ldw	r2,16(r2)
   10394:	1080030b 	ldhu	r2,12(r2)
   10398:	10bfffcc 	andi	r2,r2,65535
   1039c:	1004923a 	slli	r2,r2,8
   103a0:	10bfffcc 	andi	r2,r2,65535
   103a4:	2084b03a 	or	r2,r4,r2
   103a8:	108000cc 	andi	r2,r2,3
   103ac:	1004c03a 	cmpne	r2,r2,zero
   103b0:	10803fcc 	andi	r2,r2,255
   103b4:	1885883a 	add	r2,r3,r2
   103b8:	d0a8e08d 	sth	r2,-23678(gp)
              }
              old_seg = next;
   103bc:	e0bff917 	ldw	r2,-28(fp)
   103c0:	e0bffd15 	stw	r2,-12(fp)
              next = next->next;
   103c4:	e0bff917 	ldw	r2,-28(fp)
   103c8:	10800017 	ldw	r2,0(r2)
   103cc:	e0bff915 	stw	r2,-28(fp)
              tcp_seg_free(old_seg);
   103d0:	e13ffd17 	ldw	r4,-12(fp)
   103d4:	000c97c0 	call	c97c <tcp_seg_free>
            struct tcp_seg *old_seg;
            /* rcv_nxt
             * .    |--ooseq--|
             * .==seg============|
             */
            while (next &&
   103d8:	e0bff917 	ldw	r2,-28(fp)
   103dc:	10001126 	beq	r2,zero,10424 <tcp_receive+0x124c>
                   TCP_SEQ_GEQ(seqno + tcplen,
   103e0:	d0a8e08b 	ldhu	r2,-23678(gp)
   103e4:	10ffffcc 	andi	r3,r2,65535
   103e8:	d0a8de17 	ldw	r2,-23688(gp)
   103ec:	1887883a 	add	r3,r3,r2
   103f0:	e0bff917 	ldw	r2,-28(fp)
   103f4:	10800417 	ldw	r2,16(r2)
   103f8:	1100010b 	ldhu	r4,4(r2)
   103fc:	1080018b 	ldhu	r2,6(r2)
   10400:	1004943a 	slli	r2,r2,16
   10404:	1104b03a 	or	r2,r2,r4
   10408:	1009883a 	mov	r4,r2
   1040c:	e0bff917 	ldw	r2,-28(fp)
   10410:	1080030b 	ldhu	r2,12(r2)
   10414:	10bfffcc 	andi	r2,r2,65535
   10418:	2085883a 	add	r2,r4,r2
   1041c:	1885c83a 	sub	r2,r3,r2
            struct tcp_seg *old_seg;
            /* rcv_nxt
             * .    |--ooseq--|
             * .==seg============|
             */
            while (next &&
   10420:	103f920e 	bge	r2,zero,1026c <tcp_receive+0x1094>
            }
            /* rcv_nxt
             * .             |--ooseq--|
             * .==seg============|
             */
            if (next &&
   10424:	e0bff917 	ldw	r2,-28(fp)
   10428:	10006926 	beq	r2,zero,105d0 <tcp_receive+0x13f8>
                TCP_SEQ_GT(seqno + tcplen,
   1042c:	d0a8e08b 	ldhu	r2,-23678(gp)
   10430:	10ffffcc 	andi	r3,r2,65535
   10434:	d0a8de17 	ldw	r2,-23688(gp)
   10438:	1887883a 	add	r3,r3,r2
   1043c:	e0bff917 	ldw	r2,-28(fp)
   10440:	10800417 	ldw	r2,16(r2)
   10444:	1100010b 	ldhu	r4,4(r2)
   10448:	1080018b 	ldhu	r2,6(r2)
   1044c:	1004943a 	slli	r2,r2,16
   10450:	1104b03a 	or	r2,r2,r4
   10454:	1885c83a 	sub	r2,r3,r2
            }
            /* rcv_nxt
             * .             |--ooseq--|
             * .==seg============|
             */
            if (next &&
   10458:	00805d0e 	bge	zero,r2,105d0 <tcp_receive+0x13f8>
                TCP_SEQ_GT(seqno + tcplen,
                           next->tcphdr->seqno)) {
              /* FIN in inseg already handled by dropping whole ooseq queue */
              inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
   1045c:	e0bfff17 	ldw	r2,-4(fp)
   10460:	10802017 	ldw	r2,128(r2)
   10464:	10800417 	ldw	r2,16(r2)
   10468:	10c0010b 	ldhu	r3,4(r2)
   1046c:	1080018b 	ldhu	r2,6(r2)
   10470:	1004943a 	slli	r2,r2,16
   10474:	10c4b03a 	or	r2,r2,r3
   10478:	1007883a 	mov	r3,r2
   1047c:	d0a8de17 	ldw	r2,-23688(gp)
   10480:	1885c83a 	sub	r2,r3,r2
   10484:	1007883a 	mov	r3,r2
   10488:	00800134 	movhi	r2,4
   1048c:	108cfa04 	addi	r2,r2,13288
   10490:	10c0030d 	sth	r3,12(r2)
              if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
   10494:	00800134 	movhi	r2,4
   10498:	108cfa04 	addi	r2,r2,13288
   1049c:	10800417 	ldw	r2,16(r2)
   104a0:	1080030b 	ldhu	r2,12(r2)
   104a4:	10bfffcc 	andi	r2,r2,65535
   104a8:	1004d23a 	srli	r2,r2,8
   104ac:	10ffffcc 	andi	r3,r2,65535
   104b0:	00800134 	movhi	r2,4
   104b4:	108cfa04 	addi	r2,r2,13288
   104b8:	10800417 	ldw	r2,16(r2)
   104bc:	1080030b 	ldhu	r2,12(r2)
   104c0:	10bfffcc 	andi	r2,r2,65535
   104c4:	1004923a 	slli	r2,r2,8
   104c8:	10bfffcc 	andi	r2,r2,65535
   104cc:	1884b03a 	or	r2,r3,r2
   104d0:	1080008c 	andi	r2,r2,2
   104d4:	10000826 	beq	r2,zero,104f8 <tcp_receive+0x1320>
                inseg.len -= 1;
   104d8:	00800134 	movhi	r2,4
   104dc:	108cfa04 	addi	r2,r2,13288
   104e0:	1080030b 	ldhu	r2,12(r2)
   104e4:	10bfffc4 	addi	r2,r2,-1
   104e8:	1007883a 	mov	r3,r2
   104ec:	00800134 	movhi	r2,4
   104f0:	108cfa04 	addi	r2,r2,13288
   104f4:	10c0030d 	sth	r3,12(r2)
              }
              pbuf_realloc(inseg.p, inseg.len);
   104f8:	00800134 	movhi	r2,4
   104fc:	108cfa04 	addi	r2,r2,13288
   10500:	10c00117 	ldw	r3,4(r2)
   10504:	00800134 	movhi	r2,4
   10508:	108cfa04 	addi	r2,r2,13288
   1050c:	1080030b 	ldhu	r2,12(r2)
   10510:	10bfffcc 	andi	r2,r2,65535
   10514:	1809883a 	mov	r4,r3
   10518:	100b883a 	mov	r5,r2
   1051c:	0009cf00 	call	9cf0 <pbuf_realloc>
              tcplen = TCP_TCPLEN(&inseg);
   10520:	00800134 	movhi	r2,4
   10524:	108cfa04 	addi	r2,r2,13288
   10528:	10c0030b 	ldhu	r3,12(r2)
   1052c:	00800134 	movhi	r2,4
   10530:	108cfa04 	addi	r2,r2,13288
   10534:	10800417 	ldw	r2,16(r2)
   10538:	1080030b 	ldhu	r2,12(r2)
   1053c:	10bfffcc 	andi	r2,r2,65535
   10540:	1004d23a 	srli	r2,r2,8
   10544:	113fffcc 	andi	r4,r2,65535
   10548:	00800134 	movhi	r2,4
   1054c:	108cfa04 	addi	r2,r2,13288
   10550:	10800417 	ldw	r2,16(r2)
   10554:	1080030b 	ldhu	r2,12(r2)
   10558:	10bfffcc 	andi	r2,r2,65535
   1055c:	1004923a 	slli	r2,r2,8
   10560:	10bfffcc 	andi	r2,r2,65535
   10564:	2084b03a 	or	r2,r4,r2
   10568:	108000cc 	andi	r2,r2,3
   1056c:	1004c03a 	cmpne	r2,r2,zero
   10570:	10803fcc 	andi	r2,r2,255
   10574:	1885883a 	add	r2,r3,r2
   10578:	d0a8e08d 	sth	r2,-23678(gp)
              LWIP_ASSERT("tcp_receive: segment not trimmed correctly to ooseq queue\n",
   1057c:	d0a8e08b 	ldhu	r2,-23678(gp)
   10580:	10ffffcc 	andi	r3,r2,65535
   10584:	d0a8de17 	ldw	r2,-23688(gp)
   10588:	1887883a 	add	r3,r3,r2
   1058c:	e0bfff17 	ldw	r2,-4(fp)
   10590:	10802017 	ldw	r2,128(r2)
   10594:	10800417 	ldw	r2,16(r2)
   10598:	1100010b 	ldhu	r4,4(r2)
   1059c:	1080018b 	ldhu	r2,6(r2)
   105a0:	1004943a 	slli	r2,r2,16
   105a4:	1104b03a 	or	r2,r2,r4
   105a8:	18800926 	beq	r3,r2,105d0 <tcp_receive+0x13f8>
   105ac:	010000f4 	movhi	r4,3
   105b0:	213a1604 	addi	r4,r4,-6056
   105b4:	014000f4 	movhi	r5,3
   105b8:	297aab04 	addi	r5,r5,-5460
   105bc:	01813044 	movi	r6,1217
   105c0:	01c000f4 	movhi	r7,3
   105c4:	39fa2a04 	addi	r7,r7,-5976
   105c8:	00166c00 	call	166c0 <printf>
   105cc:	003fff06 	br	105cc <tcp_receive+0x13f4>
                          (seqno + tcplen) == pcb->ooseq->tcphdr->seqno);
            }
            pcb->ooseq = next;
   105d0:	e0bfff17 	ldw	r2,-4(fp)
   105d4:	e0fff917 	ldw	r3,-28(fp)
   105d8:	10c02015 	stw	r3,128(r2)
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        pcb->rcv_nxt = seqno + tcplen;
   105dc:	d0a8e08b 	ldhu	r2,-23678(gp)
   105e0:	10ffffcc 	andi	r3,r2,65535
   105e4:	d0a8de17 	ldw	r2,-23688(gp)
   105e8:	1887883a 	add	r3,r3,r2
   105ec:	e0bfff17 	ldw	r2,-4(fp)
   105f0:	10c00a15 	stw	r3,40(r2)

        /* Update the receiver's (our) window. */
        LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
   105f4:	e0bfff17 	ldw	r2,-4(fp)
   105f8:	10c00b0b 	ldhu	r3,44(r2)
   105fc:	d0a8e08b 	ldhu	r2,-23678(gp)
   10600:	18ffffcc 	andi	r3,r3,65535
   10604:	10bfffcc 	andi	r2,r2,65535
   10608:	1880092e 	bgeu	r3,r2,10630 <tcp_receive+0x1458>
   1060c:	010000f4 	movhi	r4,3
   10610:	213a1604 	addi	r4,r4,-6056
   10614:	014000f4 	movhi	r5,3
   10618:	297aba04 	addi	r5,r5,-5400
   1061c:	018132c4 	movi	r6,1227
   10620:	01c000f4 	movhi	r7,3
   10624:	39fa2a04 	addi	r7,r7,-5976
   10628:	00166c00 	call	166c0 <printf>
   1062c:	003fff06 	br	1062c <tcp_receive+0x1454>
        pcb->rcv_wnd -= tcplen;
   10630:	e0bfff17 	ldw	r2,-4(fp)
   10634:	10c00b0b 	ldhu	r3,44(r2)
   10638:	d0a8e08b 	ldhu	r2,-23678(gp)
   1063c:	1885c83a 	sub	r2,r3,r2
   10640:	1007883a 	mov	r3,r2
   10644:	e0bfff17 	ldw	r2,-4(fp)
   10648:	10c00b0d 	sth	r3,44(r2)

        tcp_update_rcv_ann_wnd(pcb);
   1064c:	e13fff17 	ldw	r4,-4(fp)
   10650:	000bacc0 	call	bacc <tcp_update_rcv_ann_wnd>
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
   10654:	00800134 	movhi	r2,4
   10658:	108cfa04 	addi	r2,r2,13288
   1065c:	10800117 	ldw	r2,4(r2)
   10660:	1080020b 	ldhu	r2,8(r2)
   10664:	10bfffcc 	andi	r2,r2,65535
   10668:	10000726 	beq	r2,zero,10688 <tcp_receive+0x14b0>
          recv_data = inseg.p;
   1066c:	00800134 	movhi	r2,4
   10670:	108cfa04 	addi	r2,r2,13288
   10674:	10800117 	ldw	r2,4(r2)
   10678:	d0a8e215 	stw	r2,-23672(gp)
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
   1067c:	00800134 	movhi	r2,4
   10680:	108cfa04 	addi	r2,r2,13288
   10684:	10000115 	stw	zero,4(r2)
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
   10688:	00800134 	movhi	r2,4
   1068c:	108cfa04 	addi	r2,r2,13288
   10690:	10800417 	ldw	r2,16(r2)
   10694:	1080030b 	ldhu	r2,12(r2)
   10698:	10bfffcc 	andi	r2,r2,65535
   1069c:	1004d23a 	srli	r2,r2,8
   106a0:	10ffffcc 	andi	r3,r2,65535
   106a4:	00800134 	movhi	r2,4
   106a8:	108cfa04 	addi	r2,r2,13288
   106ac:	10800417 	ldw	r2,16(r2)
   106b0:	1080030b 	ldhu	r2,12(r2)
   106b4:	10bfffcc 	andi	r2,r2,65535
   106b8:	1004923a 	slli	r2,r2,8
   106bc:	10bfffcc 	andi	r2,r2,65535
   106c0:	1884b03a 	or	r2,r3,r2
   106c4:	1080004c 	andi	r2,r2,1
   106c8:	10009726 	beq	r2,zero,10928 <tcp_receive+0x1750>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags |= TF_GOT_FIN;
   106cc:	d0a8e103 	ldbu	r2,-23676(gp)
   106d0:	10800814 	ori	r2,r2,32
   106d4:	d0a8e105 	stb	r2,-23676(gp)
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
   106d8:	00009306 	br	10928 <tcp_receive+0x1750>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          cseg = pcb->ooseq;
   106dc:	e0bfff17 	ldw	r2,-4(fp)
   106e0:	10802017 	ldw	r2,128(r2)
   106e4:	e0bffe15 	stw	r2,-8(fp)
          seqno = pcb->ooseq->tcphdr->seqno;
   106e8:	e0bfff17 	ldw	r2,-4(fp)
   106ec:	10802017 	ldw	r2,128(r2)
   106f0:	10800417 	ldw	r2,16(r2)
   106f4:	10c0010b 	ldhu	r3,4(r2)
   106f8:	1080018b 	ldhu	r2,6(r2)
   106fc:	1004943a 	slli	r2,r2,16
   10700:	10c4b03a 	or	r2,r2,r3
   10704:	d0a8de15 	stw	r2,-23688(gp)

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
   10708:	e0bfff17 	ldw	r2,-4(fp)
   1070c:	10c00a17 	ldw	r3,40(r2)
   10710:	e0bffe17 	ldw	r2,-8(fp)
   10714:	1080030b 	ldhu	r2,12(r2)
   10718:	113fffcc 	andi	r4,r2,65535
   1071c:	e0bffe17 	ldw	r2,-8(fp)
   10720:	10800417 	ldw	r2,16(r2)
   10724:	1080030b 	ldhu	r2,12(r2)
   10728:	10bfffcc 	andi	r2,r2,65535
   1072c:	1004d23a 	srli	r2,r2,8
   10730:	117fffcc 	andi	r5,r2,65535
   10734:	e0bffe17 	ldw	r2,-8(fp)
   10738:	10800417 	ldw	r2,16(r2)
   1073c:	1080030b 	ldhu	r2,12(r2)
   10740:	10bfffcc 	andi	r2,r2,65535
   10744:	1004923a 	slli	r2,r2,8
   10748:	10bfffcc 	andi	r2,r2,65535
   1074c:	2884b03a 	or	r2,r5,r2
   10750:	108000cc 	andi	r2,r2,3
   10754:	1004c03a 	cmpne	r2,r2,zero
   10758:	10803fcc 	andi	r2,r2,255
   1075c:	2085883a 	add	r2,r4,r2
   10760:	1887883a 	add	r3,r3,r2
   10764:	e0bfff17 	ldw	r2,-4(fp)
   10768:	10c00a15 	stw	r3,40(r2)
          LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
   1076c:	e0bfff17 	ldw	r2,-4(fp)
   10770:	10800b0b 	ldhu	r2,44(r2)
   10774:	10ffffcc 	andi	r3,r2,65535
   10778:	e0bffe17 	ldw	r2,-8(fp)
   1077c:	1080030b 	ldhu	r2,12(r2)
   10780:	113fffcc 	andi	r4,r2,65535
   10784:	e0bffe17 	ldw	r2,-8(fp)
   10788:	10800417 	ldw	r2,16(r2)
   1078c:	1080030b 	ldhu	r2,12(r2)
   10790:	10bfffcc 	andi	r2,r2,65535
   10794:	1004d23a 	srli	r2,r2,8
   10798:	117fffcc 	andi	r5,r2,65535
   1079c:	e0bffe17 	ldw	r2,-8(fp)
   107a0:	10800417 	ldw	r2,16(r2)
   107a4:	1080030b 	ldhu	r2,12(r2)
   107a8:	10bfffcc 	andi	r2,r2,65535
   107ac:	1004923a 	slli	r2,r2,8
   107b0:	10bfffcc 	andi	r2,r2,65535
   107b4:	2884b03a 	or	r2,r5,r2
   107b8:	108000cc 	andi	r2,r2,3
   107bc:	1004c03a 	cmpne	r2,r2,zero
   107c0:	10803fcc 	andi	r2,r2,255
   107c4:	2085883a 	add	r2,r4,r2
   107c8:	1880090e 	bge	r3,r2,107f0 <tcp_receive+0x1618>
   107cc:	010000f4 	movhi	r4,3
   107d0:	213a1604 	addi	r4,r4,-6056
   107d4:	014000f4 	movhi	r5,3
   107d8:	297ac204 	addi	r5,r5,-5368
   107dc:	01813c04 	movi	r6,1264
   107e0:	01c000f4 	movhi	r7,3
   107e4:	39fa2a04 	addi	r7,r7,-5976
   107e8:	00166c00 	call	166c0 <printf>
   107ec:	003fff06 	br	107ec <tcp_receive+0x1614>
                      pcb->rcv_wnd >= TCP_TCPLEN(cseg));
          pcb->rcv_wnd -= TCP_TCPLEN(cseg);
   107f0:	e0bfff17 	ldw	r2,-4(fp)
   107f4:	10c00b0b 	ldhu	r3,44(r2)
   107f8:	e0bffe17 	ldw	r2,-8(fp)
   107fc:	1100030b 	ldhu	r4,12(r2)
   10800:	e0bffe17 	ldw	r2,-8(fp)
   10804:	10800417 	ldw	r2,16(r2)
   10808:	1080030b 	ldhu	r2,12(r2)
   1080c:	10bfffcc 	andi	r2,r2,65535
   10810:	1004d23a 	srli	r2,r2,8
   10814:	117fffcc 	andi	r5,r2,65535
   10818:	e0bffe17 	ldw	r2,-8(fp)
   1081c:	10800417 	ldw	r2,16(r2)
   10820:	1080030b 	ldhu	r2,12(r2)
   10824:	10bfffcc 	andi	r2,r2,65535
   10828:	1004923a 	slli	r2,r2,8
   1082c:	10bfffcc 	andi	r2,r2,65535
   10830:	2884b03a 	or	r2,r5,r2
   10834:	108000cc 	andi	r2,r2,3
   10838:	1004c03a 	cmpne	r2,r2,zero
   1083c:	10803fcc 	andi	r2,r2,255
   10840:	2085883a 	add	r2,r4,r2
   10844:	1885c83a 	sub	r2,r3,r2
   10848:	1007883a 	mov	r3,r2
   1084c:	e0bfff17 	ldw	r2,-4(fp)
   10850:	10c00b0d 	sth	r3,44(r2)

          tcp_update_rcv_ann_wnd(pcb);
   10854:	e13fff17 	ldw	r4,-4(fp)
   10858:	000bacc0 	call	bacc <tcp_update_rcv_ann_wnd>

          if (cseg->p->tot_len > 0) {
   1085c:	e0bffe17 	ldw	r2,-8(fp)
   10860:	10800117 	ldw	r2,4(r2)
   10864:	1080020b 	ldhu	r2,8(r2)
   10868:	10bfffcc 	andi	r2,r2,65535
   1086c:	10000e26 	beq	r2,zero,108a8 <tcp_receive+0x16d0>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            if (recv_data) {
   10870:	d0a8e217 	ldw	r2,-23672(gp)
   10874:	10000726 	beq	r2,zero,10894 <tcp_receive+0x16bc>
              pbuf_cat(recv_data, cseg->p);
   10878:	d0e8e217 	ldw	r3,-23672(gp)
   1087c:	e0bffe17 	ldw	r2,-8(fp)
   10880:	10800117 	ldw	r2,4(r2)
   10884:	1809883a 	mov	r4,r3
   10888:	100b883a 	mov	r5,r2
   1088c:	000a3c40 	call	a3c4 <pbuf_cat>
   10890:	00000306 	br	108a0 <tcp_receive+0x16c8>
            } else {
              recv_data = cseg->p;
   10894:	e0bffe17 	ldw	r2,-8(fp)
   10898:	10800117 	ldw	r2,4(r2)
   1089c:	d0a8e215 	stw	r2,-23672(gp)
            }
            cseg->p = NULL;
   108a0:	e0bffe17 	ldw	r2,-8(fp)
   108a4:	10000115 	stw	zero,4(r2)
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
   108a8:	e0bffe17 	ldw	r2,-8(fp)
   108ac:	10800417 	ldw	r2,16(r2)
   108b0:	1080030b 	ldhu	r2,12(r2)
   108b4:	10bfffcc 	andi	r2,r2,65535
   108b8:	1004d23a 	srli	r2,r2,8
   108bc:	10ffffcc 	andi	r3,r2,65535
   108c0:	e0bffe17 	ldw	r2,-8(fp)
   108c4:	10800417 	ldw	r2,16(r2)
   108c8:	1080030b 	ldhu	r2,12(r2)
   108cc:	10bfffcc 	andi	r2,r2,65535
   108d0:	1004923a 	slli	r2,r2,8
   108d4:	10bfffcc 	andi	r2,r2,65535
   108d8:	1884b03a 	or	r2,r3,r2
   108dc:	1080004c 	andi	r2,r2,1
   108e0:	10000a26 	beq	r2,zero,1090c <tcp_receive+0x1734>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags |= TF_GOT_FIN;
   108e4:	d0a8e103 	ldbu	r2,-23676(gp)
   108e8:	10800814 	ori	r2,r2,32
   108ec:	d0a8e105 	stb	r2,-23676(gp)
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
   108f0:	e0bfff17 	ldw	r2,-4(fp)
   108f4:	10800417 	ldw	r2,16(r2)
   108f8:	10800118 	cmpnei	r2,r2,4
   108fc:	1000031e 	bne	r2,zero,1090c <tcp_receive+0x1734>
              pcb->state = CLOSE_WAIT;
   10900:	e0bfff17 	ldw	r2,-4(fp)
   10904:	00c001c4 	movi	r3,7
   10908:	10c00415 	stw	r3,16(r2)
            } 
          }

          pcb->ooseq = cseg->next;
   1090c:	e0bffe17 	ldw	r2,-8(fp)
   10910:	10c00017 	ldw	r3,0(r2)
   10914:	e0bfff17 	ldw	r2,-4(fp)
   10918:	10c02015 	stw	r3,128(r2)
          tcp_seg_free(cseg);
   1091c:	e13ffe17 	ldw	r4,-8(fp)
   10920:	000c97c0 	call	c97c <tcp_seg_free>
   10924:	00000106 	br	1092c <tcp_receive+0x1754>
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
   10928:	0001883a 	nop
   1092c:	e0bfff17 	ldw	r2,-4(fp)
   10930:	10802017 	ldw	r2,128(r2)
   10934:	10000b26 	beq	r2,zero,10964 <tcp_receive+0x178c>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
   10938:	e0bfff17 	ldw	r2,-4(fp)
   1093c:	10802017 	ldw	r2,128(r2)
   10940:	10800417 	ldw	r2,16(r2)
   10944:	10c0010b 	ldhu	r3,4(r2)
   10948:	1080018b 	ldhu	r2,6(r2)
   1094c:	1004943a 	slli	r2,r2,16
   10950:	10c4b03a 	or	r2,r2,r3
   10954:	1007883a 	mov	r3,r2
   10958:	e0bfff17 	ldw	r2,-4(fp)
   1095c:	10800a17 	ldw	r2,40(r2)
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
   10960:	18bf5e26 	beq	r3,r2,106dc <tcp_receive+0x1504>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
   10964:	e0bfff17 	ldw	r2,-4(fp)
   10968:	10800983 	ldbu	r2,38(r2)
   1096c:	10803fcc 	andi	r2,r2,255
   10970:	1080004c 	andi	r2,r2,1
   10974:	10001026 	beq	r2,zero,109b8 <tcp_receive+0x17e0>
   10978:	e0bfff17 	ldw	r2,-4(fp)
   1097c:	10c00983 	ldbu	r3,38(r2)
   10980:	00bfff84 	movi	r2,-2
   10984:	1884703a 	and	r2,r3,r2
   10988:	1007883a 	mov	r3,r2
   1098c:	e0bfff17 	ldw	r2,-4(fp)
   10990:	10c00985 	stb	r3,38(r2)
   10994:	e0bfff17 	ldw	r2,-4(fp)
   10998:	10800983 	ldbu	r2,38(r2)
   1099c:	10800094 	ori	r2,r2,2
   109a0:	1007883a 	mov	r3,r2
   109a4:	e0bfff17 	ldw	r2,-4(fp)
   109a8:	10c00985 	stb	r3,38(r2)
   109ac:	e13fff17 	ldw	r4,-4(fp)
   109b0:	00122380 	call	12238 <tcp_output>
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
   109b4:	00010b06 	br	10de4 <tcp_receive+0x1c0c>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
   109b8:	e0bfff17 	ldw	r2,-4(fp)
   109bc:	10800983 	ldbu	r2,38(r2)
   109c0:	10800054 	ori	r2,r2,1
   109c4:	1007883a 	mov	r3,r2
   109c8:	e0bfff17 	ldw	r2,-4(fp)
   109cc:	10c00985 	stb	r3,38(r2)
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
   109d0:	00010406 	br	10de4 <tcp_receive+0x1c0c>
        /* Acknowledge the segment(s). */
        tcp_ack(pcb);

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_send_empty_ack(pcb);
   109d4:	e13fff17 	ldw	r4,-4(fp)
   109d8:	00120dc0 	call	120dc <tcp_send_empty_ack>
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
   109dc:	e0bfff17 	ldw	r2,-4(fp)
   109e0:	10802017 	ldw	r2,128(r2)
   109e4:	1000061e 	bne	r2,zero,10a00 <tcp_receive+0x1828>
          pcb->ooseq = tcp_seg_copy(&inseg);
   109e8:	01000134 	movhi	r4,4
   109ec:	210cfa04 	addi	r4,r4,13288
   109f0:	000ca140 	call	ca14 <tcp_seg_copy>
   109f4:	e0ffff17 	ldw	r3,-4(fp)
   109f8:	18802015 	stw	r2,128(r3)
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
   109fc:	0000f906 	br	10de4 <tcp_receive+0x1c0c>

             If the incoming segment has the same sequence number as a
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
   10a00:	e03ff415 	stw	zero,-48(fp)
          for(next = pcb->ooseq; next != NULL; next = next->next) {
   10a04:	e0bfff17 	ldw	r2,-4(fp)
   10a08:	10802017 	ldw	r2,128(r2)
   10a0c:	e0bff315 	stw	r2,-52(fp)
   10a10:	0000ca06 	br	10d3c <tcp_receive+0x1b64>
            if (seqno == next->tcphdr->seqno) {
   10a14:	e0bff317 	ldw	r2,-52(fp)
   10a18:	10800417 	ldw	r2,16(r2)
   10a1c:	10c0010b 	ldhu	r3,4(r2)
   10a20:	1080018b 	ldhu	r2,6(r2)
   10a24:	1004943a 	slli	r2,r2,16
   10a28:	10c4b03a 	or	r2,r2,r3
   10a2c:	1007883a 	mov	r3,r2
   10a30:	d0a8de17 	ldw	r2,-23688(gp)
   10a34:	18801b1e 	bne	r3,r2,10aa4 <tcp_receive+0x18cc>
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
   10a38:	00800134 	movhi	r2,4
   10a3c:	108cfa04 	addi	r2,r2,13288
   10a40:	1080030b 	ldhu	r2,12(r2)
   10a44:	e0fff317 	ldw	r3,-52(fp)
   10a48:	18c0030b 	ldhu	r3,12(r3)
   10a4c:	10bfffcc 	andi	r2,r2,65535
   10a50:	18ffffcc 	andi	r3,r3,65535
   10a54:	1880bc2e 	bgeu	r3,r2,10d48 <tcp_receive+0x1b70>
                /* The incoming segment is larger than the old
                   segment. We replace some segments with the new
                   one. */
                cseg = tcp_seg_copy(&inseg);
   10a58:	01000134 	movhi	r4,4
   10a5c:	210cfa04 	addi	r4,r4,13288
   10a60:	000ca140 	call	ca14 <tcp_seg_copy>
   10a64:	e0bffe15 	stw	r2,-8(fp)
                if (cseg != NULL) {
   10a68:	e0bffe17 	ldw	r2,-8(fp)
   10a6c:	1000b826 	beq	r2,zero,10d50 <tcp_receive+0x1b78>
                  if (prev != NULL) {
   10a70:	e0bff417 	ldw	r2,-48(fp)
   10a74:	10000426 	beq	r2,zero,10a88 <tcp_receive+0x18b0>
                    prev->next = cseg;
   10a78:	e0bff417 	ldw	r2,-48(fp)
   10a7c:	e0fffe17 	ldw	r3,-8(fp)
   10a80:	10c00015 	stw	r3,0(r2)
   10a84:	00000306 	br	10a94 <tcp_receive+0x18bc>
                  } else {
                    pcb->ooseq = cseg;
   10a88:	e0bfff17 	ldw	r2,-4(fp)
   10a8c:	e0fffe17 	ldw	r3,-8(fp)
   10a90:	10c02015 	stw	r3,128(r2)
                  }
                  tcp_oos_insert_segment(cseg, next);
   10a94:	e13ffe17 	ldw	r4,-8(fp)
   10a98:	e17ff317 	ldw	r5,-52(fp)
   10a9c:	000efbc0 	call	efbc <tcp_oos_insert_segment>
                }
                break;
   10aa0:	0000ab06 	br	10d50 <tcp_receive+0x1b78>
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
              }
            } else {
              if (prev == NULL) {
   10aa4:	e0bff417 	ldw	r2,-48(fp)
   10aa8:	1000161e 	bne	r2,zero,10b04 <tcp_receive+0x192c>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
   10aac:	d0e8de17 	ldw	r3,-23688(gp)
   10ab0:	e0bff317 	ldw	r2,-52(fp)
   10ab4:	10800417 	ldw	r2,16(r2)
   10ab8:	1100010b 	ldhu	r4,4(r2)
   10abc:	1080018b 	ldhu	r2,6(r2)
   10ac0:	1004943a 	slli	r2,r2,16
   10ac4:	1104b03a 	or	r2,r2,r4
   10ac8:	1885c83a 	sub	r2,r3,r2
   10acc:	1000500e 	bge	r2,zero,10c10 <tcp_receive+0x1a38>
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */
                  cseg = tcp_seg_copy(&inseg);
   10ad0:	01000134 	movhi	r4,4
   10ad4:	210cfa04 	addi	r4,r4,13288
   10ad8:	000ca140 	call	ca14 <tcp_seg_copy>
   10adc:	e0bffe15 	stw	r2,-8(fp)
                  if (cseg != NULL) {
   10ae0:	e0bffe17 	ldw	r2,-8(fp)
   10ae4:	10009c26 	beq	r2,zero,10d58 <tcp_receive+0x1b80>
                    pcb->ooseq = cseg;
   10ae8:	e0bfff17 	ldw	r2,-4(fp)
   10aec:	e0fffe17 	ldw	r3,-8(fp)
   10af0:	10c02015 	stw	r3,128(r2)
                    tcp_oos_insert_segment(cseg, next);
   10af4:	e13ffe17 	ldw	r4,-8(fp)
   10af8:	e17ff317 	ldw	r5,-52(fp)
   10afc:	000efbc0 	call	efbc <tcp_oos_insert_segment>
                  }
                  break;
   10b00:	00009506 	br	10d58 <tcp_receive+0x1b80>
                }
              } else {
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)) {
   10b04:	e0bff417 	ldw	r2,-48(fp)
   10b08:	10800417 	ldw	r2,16(r2)
   10b0c:	10c0010b 	ldhu	r3,4(r2)
   10b10:	1080018b 	ldhu	r2,6(r2)
   10b14:	1004943a 	slli	r2,r2,16
   10b18:	10c4b03a 	or	r2,r2,r3
   10b1c:	0086303a 	nor	r3,zero,r2
   10b20:	d0a8de17 	ldw	r2,-23688(gp)
   10b24:	1885883a 	add	r2,r3,r2
   10b28:	10003916 	blt	r2,zero,10c10 <tcp_receive+0x1a38>
   10b2c:	d0e8de17 	ldw	r3,-23688(gp)
   10b30:	e0bff317 	ldw	r2,-52(fp)
   10b34:	10800417 	ldw	r2,16(r2)
   10b38:	1100010b 	ldhu	r4,4(r2)
   10b3c:	1080018b 	ldhu	r2,6(r2)
   10b40:	1004943a 	slli	r2,r2,16
   10b44:	1104b03a 	or	r2,r2,r4
   10b48:	1885c83a 	sub	r2,r3,r2
   10b4c:	10800044 	addi	r2,r2,1
   10b50:	00802f16 	blt	zero,r2,10c10 <tcp_receive+0x1a38>
                  /* The sequence number of the incoming segment is in
                     between the sequence numbers of the previous and
                     the next segment on ->ooseq. We trim trim the previous
                     segment, delete next segments that included in received segment
                     and trim received, if needed. */
                  cseg = tcp_seg_copy(&inseg);
   10b54:	01000134 	movhi	r4,4
   10b58:	210cfa04 	addi	r4,r4,13288
   10b5c:	000ca140 	call	ca14 <tcp_seg_copy>
   10b60:	e0bffe15 	stw	r2,-8(fp)
                  if (cseg != NULL) {
   10b64:	e0bffe17 	ldw	r2,-8(fp)
   10b68:	10007d26 	beq	r2,zero,10d60 <tcp_receive+0x1b88>
                    if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
   10b6c:	e0bff417 	ldw	r2,-48(fp)
   10b70:	10800417 	ldw	r2,16(r2)
   10b74:	10c0010b 	ldhu	r3,4(r2)
   10b78:	1080018b 	ldhu	r2,6(r2)
   10b7c:	1004943a 	slli	r2,r2,16
   10b80:	10c4b03a 	or	r2,r2,r3
   10b84:	1007883a 	mov	r3,r2
   10b88:	e0bff417 	ldw	r2,-48(fp)
   10b8c:	1080030b 	ldhu	r2,12(r2)
   10b90:	10bfffcc 	andi	r2,r2,65535
   10b94:	1887883a 	add	r3,r3,r2
   10b98:	d0a8de17 	ldw	r2,-23688(gp)
   10b9c:	1885c83a 	sub	r2,r3,r2
   10ba0:	0080140e 	bge	zero,r2,10bf4 <tcp_receive+0x1a1c>
                      /* We need to trim the prev segment. */
                      prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
   10ba4:	d0a8de17 	ldw	r2,-23688(gp)
   10ba8:	1007883a 	mov	r3,r2
   10bac:	e0bff417 	ldw	r2,-48(fp)
   10bb0:	10800417 	ldw	r2,16(r2)
   10bb4:	1100010b 	ldhu	r4,4(r2)
   10bb8:	1080018b 	ldhu	r2,6(r2)
   10bbc:	1004943a 	slli	r2,r2,16
   10bc0:	1104b03a 	or	r2,r2,r4
   10bc4:	1885c83a 	sub	r2,r3,r2
   10bc8:	1007883a 	mov	r3,r2
   10bcc:	e0bff417 	ldw	r2,-48(fp)
   10bd0:	10c0030d 	sth	r3,12(r2)
                      pbuf_realloc(prev->p, prev->len);
   10bd4:	e0bff417 	ldw	r2,-48(fp)
   10bd8:	10c00117 	ldw	r3,4(r2)
   10bdc:	e0bff417 	ldw	r2,-48(fp)
   10be0:	1080030b 	ldhu	r2,12(r2)
   10be4:	10bfffcc 	andi	r2,r2,65535
   10be8:	1809883a 	mov	r4,r3
   10bec:	100b883a 	mov	r5,r2
   10bf0:	0009cf00 	call	9cf0 <pbuf_realloc>
                    }
                    prev->next = cseg;
   10bf4:	e0bff417 	ldw	r2,-48(fp)
   10bf8:	e0fffe17 	ldw	r3,-8(fp)
   10bfc:	10c00015 	stw	r3,0(r2)
                    tcp_oos_insert_segment(cseg, next);
   10c00:	e13ffe17 	ldw	r4,-8(fp)
   10c04:	e17ff317 	ldw	r5,-52(fp)
   10c08:	000efbc0 	call	efbc <tcp_oos_insert_segment>
                  }
                  break;
   10c0c:	00005406 	br	10d60 <tcp_receive+0x1b88>
                }
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
   10c10:	e0bff317 	ldw	r2,-52(fp)
   10c14:	10800017 	ldw	r2,0(r2)
   10c18:	1000431e 	bne	r2,zero,10d28 <tcp_receive+0x1b50>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
   10c1c:	d0e8de17 	ldw	r3,-23688(gp)
   10c20:	e0bff317 	ldw	r2,-52(fp)
   10c24:	10800417 	ldw	r2,16(r2)
   10c28:	1100010b 	ldhu	r4,4(r2)
   10c2c:	1080018b 	ldhu	r2,6(r2)
   10c30:	1004943a 	slli	r2,r2,16
   10c34:	1104b03a 	or	r2,r2,r4
   10c38:	1885c83a 	sub	r2,r3,r2
                }
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
   10c3c:	00803a0e 	bge	zero,r2,10d28 <tcp_receive+0x1b50>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
   10c40:	e0bff317 	ldw	r2,-52(fp)
   10c44:	10800417 	ldw	r2,16(r2)
   10c48:	1080030b 	ldhu	r2,12(r2)
   10c4c:	10bfffcc 	andi	r2,r2,65535
   10c50:	1004d23a 	srli	r2,r2,8
   10c54:	10ffffcc 	andi	r3,r2,65535
   10c58:	e0bff317 	ldw	r2,-52(fp)
   10c5c:	10800417 	ldw	r2,16(r2)
   10c60:	1080030b 	ldhu	r2,12(r2)
   10c64:	10bfffcc 	andi	r2,r2,65535
   10c68:	1004923a 	slli	r2,r2,8
   10c6c:	10bfffcc 	andi	r2,r2,65535
   10c70:	1884b03a 	or	r2,r3,r2
   10c74:	1080004c 	andi	r2,r2,1
   10c78:	10003b1e 	bne	r2,zero,10d68 <tcp_receive+0x1b90>
                  /* segment "next" already contains all data */
                  break;
                }
                next->next = tcp_seg_copy(&inseg);
   10c7c:	01000134 	movhi	r4,4
   10c80:	210cfa04 	addi	r4,r4,13288
   10c84:	000ca140 	call	ca14 <tcp_seg_copy>
   10c88:	e0fff317 	ldw	r3,-52(fp)
   10c8c:	18800015 	stw	r2,0(r3)
                if (next->next != NULL) {
   10c90:	e0bff317 	ldw	r2,-52(fp)
   10c94:	10800017 	ldw	r2,0(r2)
   10c98:	10003526 	beq	r2,zero,10d70 <tcp_receive+0x1b98>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
   10c9c:	e0bff317 	ldw	r2,-52(fp)
   10ca0:	10800417 	ldw	r2,16(r2)
   10ca4:	10c0010b 	ldhu	r3,4(r2)
   10ca8:	1080018b 	ldhu	r2,6(r2)
   10cac:	1004943a 	slli	r2,r2,16
   10cb0:	10c4b03a 	or	r2,r2,r3
   10cb4:	1007883a 	mov	r3,r2
   10cb8:	e0bff317 	ldw	r2,-52(fp)
   10cbc:	1080030b 	ldhu	r2,12(r2)
   10cc0:	10bfffcc 	andi	r2,r2,65535
   10cc4:	1887883a 	add	r3,r3,r2
   10cc8:	d0a8de17 	ldw	r2,-23688(gp)
   10ccc:	1885c83a 	sub	r2,r3,r2
   10cd0:	0080270e 	bge	zero,r2,10d70 <tcp_receive+0x1b98>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
   10cd4:	d0a8de17 	ldw	r2,-23688(gp)
   10cd8:	1007883a 	mov	r3,r2
   10cdc:	e0bff317 	ldw	r2,-52(fp)
   10ce0:	10800417 	ldw	r2,16(r2)
   10ce4:	1100010b 	ldhu	r4,4(r2)
   10ce8:	1080018b 	ldhu	r2,6(r2)
   10cec:	1004943a 	slli	r2,r2,16
   10cf0:	1104b03a 	or	r2,r2,r4
   10cf4:	1885c83a 	sub	r2,r3,r2
   10cf8:	1007883a 	mov	r3,r2
   10cfc:	e0bff317 	ldw	r2,-52(fp)
   10d00:	10c0030d 	sth	r3,12(r2)
                    pbuf_realloc(next->p, next->len);
   10d04:	e0bff317 	ldw	r2,-52(fp)
   10d08:	10c00117 	ldw	r3,4(r2)
   10d0c:	e0bff317 	ldw	r2,-52(fp)
   10d10:	1080030b 	ldhu	r2,12(r2)
   10d14:	10bfffcc 	andi	r2,r2,65535
   10d18:	1809883a 	mov	r4,r3
   10d1c:	100b883a 	mov	r5,r2
   10d20:	0009cf00 	call	9cf0 <pbuf_realloc>
                  }
                }
                break;
   10d24:	00001206 	br	10d70 <tcp_receive+0x1b98>
              }
            }
            prev = next;
   10d28:	e0bff317 	ldw	r2,-52(fp)
   10d2c:	e0bff415 	stw	r2,-48(fp)
             If the incoming segment has the same sequence number as a
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
   10d30:	e0bff317 	ldw	r2,-52(fp)
   10d34:	10800017 	ldw	r2,0(r2)
   10d38:	e0bff315 	stw	r2,-52(fp)
   10d3c:	e0bff317 	ldw	r2,-52(fp)
   10d40:	103f341e 	bne	r2,zero,10a14 <tcp_receive+0x183c>
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
   10d44:	00002706 	br	10de4 <tcp_receive+0x1c0c>
                break;
              } else {
                /* Either the lenghts are the same or the incoming
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
   10d48:	0001883a 	nop
   10d4c:	00000906 	br	10d74 <tcp_receive+0x1b9c>
                  } else {
                    pcb->ooseq = cseg;
                  }
                  tcp_oos_insert_segment(cseg, next);
                }
                break;
   10d50:	0001883a 	nop
   10d54:	00000706 	br	10d74 <tcp_receive+0x1b9c>
                  cseg = tcp_seg_copy(&inseg);
                  if (cseg != NULL) {
                    pcb->ooseq = cseg;
                    tcp_oos_insert_segment(cseg, next);
                  }
                  break;
   10d58:	0001883a 	nop
   10d5c:	00000506 	br	10d74 <tcp_receive+0x1b9c>
                      pbuf_realloc(prev->p, prev->len);
                    }
                    prev->next = cseg;
                    tcp_oos_insert_segment(cseg, next);
                  }
                  break;
   10d60:	0001883a 	nop
   10d64:	00000306 	br	10d74 <tcp_receive+0x1b9c>
                 of the list. */
              if (next->next == NULL &&
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
                  /* segment "next" already contains all data */
                  break;
   10d68:	0001883a 	nop
   10d6c:	00000106 	br	10d74 <tcp_receive+0x1b9c>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
                    pbuf_realloc(next->p, next->len);
                  }
                }
                break;
   10d70:	0001883a 	nop
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
   10d74:	0001883a 	nop
   10d78:	00001a06 	br	10de4 <tcp_receive+0x1c0c>
#endif /* TCP_QUEUE_OOSEQ */

      }
    } else {
      /* The incoming segment is not withing the window. */
      tcp_send_empty_ack(pcb);
   10d7c:	e13fff17 	ldw	r4,-4(fp)
   10d80:	00120dc0 	call	120dc <tcp_send_empty_ack>
   10d84:	00001706 	br	10de4 <tcp_receive+0x1c0c>
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
   10d88:	d0e8de17 	ldw	r3,-23688(gp)
   10d8c:	e0bfff17 	ldw	r2,-4(fp)
   10d90:	10800a17 	ldw	r2,40(r2)
   10d94:	1885c83a 	sub	r2,r3,r2
   10d98:	10000a16 	blt	r2,zero,10dc4 <tcp_receive+0x1bec>
   10d9c:	d0e8de17 	ldw	r3,-23688(gp)
   10da0:	e0bfff17 	ldw	r2,-4(fp)
   10da4:	11000a17 	ldw	r4,40(r2)
   10da8:	e0bfff17 	ldw	r2,-4(fp)
   10dac:	10800b0b 	ldhu	r2,44(r2)
   10db0:	10bfffcc 	andi	r2,r2,65535
   10db4:	2085883a 	add	r2,r4,r2
   10db8:	1885c83a 	sub	r2,r3,r2
   10dbc:	10800044 	addi	r2,r2,1
   10dc0:	0080080e 	bge	zero,r2,10de4 <tcp_receive+0x1c0c>
      tcp_ack_now(pcb);
   10dc4:	e0bfff17 	ldw	r2,-4(fp)
   10dc8:	10800983 	ldbu	r2,38(r2)
   10dcc:	10800094 	ori	r2,r2,2
   10dd0:	1007883a 	mov	r3,r2
   10dd4:	e0bfff17 	ldw	r2,-4(fp)
   10dd8:	10c00985 	stb	r3,38(r2)
   10ddc:	e13fff17 	ldw	r4,-4(fp)
   10de0:	00122380 	call	12238 <tcp_output>
    }
  }
}
   10de4:	e037883a 	mov	sp,fp
   10de8:	dfc00217 	ldw	ra,8(sp)
   10dec:	df000117 	ldw	fp,4(sp)
   10df0:	dc000017 	ldw	r16,0(sp)
   10df4:	dec00304 	addi	sp,sp,12
   10df8:	f800283a 	ret

00010dfc <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
   10dfc:	defffa04 	addi	sp,sp,-24
   10e00:	df000515 	stw	fp,20(sp)
   10e04:	df000504 	addi	fp,sp,20
   10e08:	e13fff15 	stw	r4,-4(fp)
  u8_t *opts, opt;
#if LWIP_TCP_TIMESTAMPS
  u32_t tsval;
#endif

  opts = (u8_t *)tcphdr + TCP_HLEN;
   10e0c:	d0a8dc17 	ldw	r2,-23696(gp)
   10e10:	10800504 	addi	r2,r2,20
   10e14:	e0bffc15 	stw	r2,-16(fp)

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
   10e18:	d0a8dc17 	ldw	r2,-23696(gp)
   10e1c:	1080030b 	ldhu	r2,12(r2)
   10e20:	10bfffcc 	andi	r2,r2,65535
   10e24:	1004d23a 	srli	r2,r2,8
   10e28:	10ffffcc 	andi	r3,r2,65535
   10e2c:	d0a8dc17 	ldw	r2,-23696(gp)
   10e30:	1080030b 	ldhu	r2,12(r2)
   10e34:	10bfffcc 	andi	r2,r2,65535
   10e38:	1004923a 	slli	r2,r2,8
   10e3c:	10bfffcc 	andi	r2,r2,65535
   10e40:	1884b03a 	or	r2,r3,r2
   10e44:	1005d33a 	srai	r2,r2,12
   10e48:	10800190 	cmplti	r2,r2,6
   10e4c:	1000651e 	bne	r2,zero,10fe4 <tcp_parseopt+0x1e8>
    max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
   10e50:	d0a8dc17 	ldw	r2,-23696(gp)
   10e54:	1080030b 	ldhu	r2,12(r2)
   10e58:	10bfffcc 	andi	r2,r2,65535
   10e5c:	1004d23a 	srli	r2,r2,8
   10e60:	10ffffcc 	andi	r3,r2,65535
   10e64:	d0a8dc17 	ldw	r2,-23696(gp)
   10e68:	1080030b 	ldhu	r2,12(r2)
   10e6c:	10bfffcc 	andi	r2,r2,65535
   10e70:	1004923a 	slli	r2,r2,8
   10e74:	10bfffcc 	andi	r2,r2,65535
   10e78:	1884b03a 	or	r2,r3,r2
   10e7c:	1005d33a 	srai	r2,r2,12
   10e80:	10bffec4 	addi	r2,r2,-5
   10e84:	1085883a 	add	r2,r2,r2
   10e88:	1085883a 	add	r2,r2,r2
   10e8c:	e0bffd0d 	sth	r2,-12(fp)
    for (c = 0; c < max_c; ) {
   10e90:	e03ffb0d 	sth	zero,-20(fp)
   10e94:	00004a06 	br	10fc0 <tcp_parseopt+0x1c4>
      opt = opts[c];
   10e98:	e0bffb0b 	ldhu	r2,-20(fp)
   10e9c:	e0fffc17 	ldw	r3,-16(fp)
   10ea0:	1885883a 	add	r2,r3,r2
   10ea4:	10800003 	ldbu	r2,0(r2)
   10ea8:	e0bffd85 	stb	r2,-10(fp)
      switch (opt) {
   10eac:	e0bffd83 	ldbu	r2,-10(fp)
   10eb0:	10c00060 	cmpeqi	r3,r2,1
   10eb4:	1800041e 	bne	r3,zero,10ec8 <tcp_parseopt+0xcc>
   10eb8:	10c000a0 	cmpeqi	r3,r2,2
   10ebc:	1800061e 	bne	r3,zero,10ed8 <tcp_parseopt+0xdc>
   10ec0:	10004326 	beq	r2,zero,10fd0 <tcp_parseopt+0x1d4>
   10ec4:	00002e06 	br	10f80 <tcp_parseopt+0x184>
        /* End of options. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: EOL\n"));
        return;
      case 0x01:
        /* NOP option. */
        ++c;
   10ec8:	e0bffb0b 	ldhu	r2,-20(fp)
   10ecc:	10800044 	addi	r2,r2,1
   10ed0:	e0bffb0d 	sth	r2,-20(fp)
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: NOP\n"));
        break;
   10ed4:	00003a06 	br	10fc0 <tcp_parseopt+0x1c4>
      case 0x02:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
        if (opts[c + 1] != 0x04 || c + 0x04 > max_c) {
   10ed8:	e0bffb0b 	ldhu	r2,-20(fp)
   10edc:	10800044 	addi	r2,r2,1
   10ee0:	e0fffc17 	ldw	r3,-16(fp)
   10ee4:	1885883a 	add	r2,r3,r2
   10ee8:	10800003 	ldbu	r2,0(r2)
   10eec:	10803fcc 	andi	r2,r2,255
   10ef0:	10800118 	cmpnei	r2,r2,4
   10ef4:	1000381e 	bne	r2,zero,10fd8 <tcp_parseopt+0x1dc>
   10ef8:	e0bffb0b 	ldhu	r2,-20(fp)
   10efc:	10800104 	addi	r2,r2,4
   10f00:	e0fffd0b 	ldhu	r3,-12(fp)
   10f04:	18803416 	blt	r3,r2,10fd8 <tcp_parseopt+0x1dc>
          /* Bad length */
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
          return;
        }
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
   10f08:	e0bffb0b 	ldhu	r2,-20(fp)
   10f0c:	10800084 	addi	r2,r2,2
   10f10:	e0fffc17 	ldw	r3,-16(fp)
   10f14:	1885883a 	add	r2,r3,r2
   10f18:	10800003 	ldbu	r2,0(r2)
   10f1c:	10803fcc 	andi	r2,r2,255
   10f20:	1004923a 	slli	r2,r2,8
   10f24:	1007883a 	mov	r3,r2
   10f28:	e0bffb0b 	ldhu	r2,-20(fp)
   10f2c:	108000c4 	addi	r2,r2,3
   10f30:	e13ffc17 	ldw	r4,-16(fp)
   10f34:	2085883a 	add	r2,r4,r2
   10f38:	10800003 	ldbu	r2,0(r2)
   10f3c:	10803fcc 	andi	r2,r2,255
   10f40:	1884b03a 	or	r2,r3,r2
   10f44:	e0bffe0d 	sth	r2,-8(fp)
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
   10f48:	e0bffe0b 	ldhu	r2,-8(fp)
   10f4c:	10816d68 	cmpgeui	r2,r2,1461
   10f50:	1000041e 	bne	r2,zero,10f64 <tcp_parseopt+0x168>
   10f54:	e0bffe0b 	ldhu	r2,-8(fp)
   10f58:	10000226 	beq	r2,zero,10f64 <tcp_parseopt+0x168>
   10f5c:	e0bffe0b 	ldhu	r2,-8(fp)
   10f60:	00000106 	br	10f68 <tcp_parseopt+0x16c>
   10f64:	00816d04 	movi	r2,1460
   10f68:	e0ffff17 	ldw	r3,-4(fp)
   10f6c:	18800f0d 	sth	r2,60(r3)
        /* Advance to next option */
        c += 0x04;
   10f70:	e0bffb0b 	ldhu	r2,-20(fp)
   10f74:	10800104 	addi	r2,r2,4
   10f78:	e0bffb0d 	sth	r2,-20(fp)
        break;
   10f7c:	00001006 	br	10fc0 <tcp_parseopt+0x1c4>
        c += 0x0A;
        break;
#endif
      default:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
        if (opts[c + 1] == 0) {
   10f80:	e0bffb0b 	ldhu	r2,-20(fp)
   10f84:	10800044 	addi	r2,r2,1
   10f88:	e0fffc17 	ldw	r3,-16(fp)
   10f8c:	1885883a 	add	r2,r3,r2
   10f90:	10800003 	ldbu	r2,0(r2)
   10f94:	10803fcc 	andi	r2,r2,255
   10f98:	10001126 	beq	r2,zero,10fe0 <tcp_parseopt+0x1e4>
             and we don't process them further. */
          return;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
   10f9c:	e0bffb0b 	ldhu	r2,-20(fp)
   10fa0:	10800044 	addi	r2,r2,1
   10fa4:	e0fffc17 	ldw	r3,-16(fp)
   10fa8:	1885883a 	add	r2,r3,r2
   10fac:	10800003 	ldbu	r2,0(r2)
   10fb0:	10c03fcc 	andi	r3,r2,255
   10fb4:	e0bffb0b 	ldhu	r2,-20(fp)
   10fb8:	1885883a 	add	r2,r3,r2
   10fbc:	e0bffb0d 	sth	r2,-20(fp)
  opts = (u8_t *)tcphdr + TCP_HLEN;

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
    for (c = 0; c < max_c; ) {
   10fc0:	e0fffb0b 	ldhu	r3,-20(fp)
   10fc4:	e0bffd0b 	ldhu	r2,-12(fp)
   10fc8:	18bfb336 	bltu	r3,r2,10e98 <tcp_parseopt+0x9c>
   10fcc:	00000506 	br	10fe4 <tcp_parseopt+0x1e8>
      opt = opts[c];
      switch (opt) {
      case 0x00:
        /* End of options. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: EOL\n"));
        return;
   10fd0:	0001883a 	nop
   10fd4:	00000306 	br	10fe4 <tcp_parseopt+0x1e8>
      case 0x02:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
        if (opts[c + 1] != 0x04 || c + 0x04 > max_c) {
          /* Bad length */
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
          return;
   10fd8:	0001883a 	nop
   10fdc:	00000106 	br	10fe4 <tcp_parseopt+0x1e8>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
        if (opts[c + 1] == 0) {
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
          /* If the length field is zero, the options are malformed
             and we don't process them further. */
          return;
   10fe0:	0001883a 	nop
           can skip past them. */
        c += opts[c + 1];
      }
    }
  }
}
   10fe4:	e037883a 	mov	sp,fp
   10fe8:	df000017 	ldw	fp,0(sp)
   10fec:	dec00104 	addi	sp,sp,4
   10ff0:	f800283a 	ret

00010ff4 <tcp_output_set_header>:
static void tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb);

static struct tcp_hdr *
tcp_output_set_header(struct tcp_pcb *pcb, struct pbuf *p, int optlen,
                      u32_t seqno_be /* already in network byte order */)
{
   10ff4:	defffa04 	addi	sp,sp,-24
   10ff8:	df000515 	stw	fp,20(sp)
   10ffc:	df000504 	addi	fp,sp,20
   11000:	e13ffc15 	stw	r4,-16(fp)
   11004:	e17ffd15 	stw	r5,-12(fp)
   11008:	e1bffe15 	stw	r6,-8(fp)
   1100c:	e1ffff15 	stw	r7,-4(fp)
  struct tcp_hdr *tcphdr = p->payload;
   11010:	e0bffd17 	ldw	r2,-12(fp)
   11014:	10800117 	ldw	r2,4(r2)
   11018:	e0bffb15 	stw	r2,-20(fp)
  tcphdr->src = htons(pcb->local_port);
   1101c:	e0bffc17 	ldw	r2,-16(fp)
   11020:	1080070b 	ldhu	r2,28(r2)
   11024:	10bfffcc 	andi	r2,r2,65535
   11028:	1004d23a 	srli	r2,r2,8
   1102c:	1007883a 	mov	r3,r2
   11030:	e0bffc17 	ldw	r2,-16(fp)
   11034:	1080070b 	ldhu	r2,28(r2)
   11038:	10bfffcc 	andi	r2,r2,65535
   1103c:	1004923a 	slli	r2,r2,8
   11040:	1884b03a 	or	r2,r3,r2
   11044:	1007883a 	mov	r3,r2
   11048:	e0bffb17 	ldw	r2,-20(fp)
   1104c:	10c0000d 	sth	r3,0(r2)
  tcphdr->dest = htons(pcb->remote_port);
   11050:	e0bffc17 	ldw	r2,-16(fp)
   11054:	1080090b 	ldhu	r2,36(r2)
   11058:	10bfffcc 	andi	r2,r2,65535
   1105c:	1004d23a 	srli	r2,r2,8
   11060:	1007883a 	mov	r3,r2
   11064:	e0bffc17 	ldw	r2,-16(fp)
   11068:	1080090b 	ldhu	r2,36(r2)
   1106c:	10bfffcc 	andi	r2,r2,65535
   11070:	1004923a 	slli	r2,r2,8
   11074:	1884b03a 	or	r2,r3,r2
   11078:	1007883a 	mov	r3,r2
   1107c:	e0bffb17 	ldw	r2,-20(fp)
   11080:	10c0008d 	sth	r3,2(r2)
  tcphdr->seqno = seqno_be;
   11084:	e0bffb17 	ldw	r2,-20(fp)
   11088:	e0ffff17 	ldw	r3,-4(fp)
   1108c:	18ffffcc 	andi	r3,r3,65535
   11090:	1100010b 	ldhu	r4,4(r2)
   11094:	2008703a 	and	r4,r4,zero
   11098:	20c6b03a 	or	r3,r4,r3
   1109c:	10c0010d 	sth	r3,4(r2)
   110a0:	e0ffff17 	ldw	r3,-4(fp)
   110a4:	1806d43a 	srli	r3,r3,16
   110a8:	1100018b 	ldhu	r4,6(r2)
   110ac:	2008703a 	and	r4,r4,zero
   110b0:	20c6b03a 	or	r3,r4,r3
   110b4:	10c0018d 	sth	r3,6(r2)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
   110b8:	e0bffc17 	ldw	r2,-16(fp)
   110bc:	10800a17 	ldw	r2,40(r2)
   110c0:	1006d63a 	srli	r3,r2,24
   110c4:	e0bffc17 	ldw	r2,-16(fp)
   110c8:	10800a17 	ldw	r2,40(r2)
   110cc:	1004d23a 	srli	r2,r2,8
   110d0:	10bfc00c 	andi	r2,r2,65280
   110d4:	1886b03a 	or	r3,r3,r2
   110d8:	e0bffc17 	ldw	r2,-16(fp)
   110dc:	10800a17 	ldw	r2,40(r2)
   110e0:	10bfc00c 	andi	r2,r2,65280
   110e4:	1004923a 	slli	r2,r2,8
   110e8:	1886b03a 	or	r3,r3,r2
   110ec:	e0bffc17 	ldw	r2,-16(fp)
   110f0:	10800a17 	ldw	r2,40(r2)
   110f4:	1004963a 	slli	r2,r2,24
   110f8:	1886b03a 	or	r3,r3,r2
   110fc:	e0bffb17 	ldw	r2,-20(fp)
   11100:	193fffcc 	andi	r4,r3,65535
   11104:	1140020b 	ldhu	r5,8(r2)
   11108:	280a703a 	and	r5,r5,zero
   1110c:	2908b03a 	or	r4,r5,r4
   11110:	1100020d 	sth	r4,8(r2)
   11114:	1806d43a 	srli	r3,r3,16
   11118:	1100028b 	ldhu	r4,10(r2)
   1111c:	2008703a 	and	r4,r4,zero
   11120:	20c6b03a 	or	r3,r4,r3
   11124:	10c0028d 	sth	r3,10(r2)
  TCPH_FLAGS_SET(tcphdr, TCP_ACK);
   11128:	e0bffb17 	ldw	r2,-20(fp)
   1112c:	10c0030b 	ldhu	r3,12(r2)
   11130:	00b03fc4 	movi	r2,-16129
   11134:	1884703a 	and	r2,r3,r2
   11138:	10840014 	ori	r2,r2,4096
   1113c:	1007883a 	mov	r3,r2
   11140:	e0bffb17 	ldw	r2,-20(fp)
   11144:	10c0030d 	sth	r3,12(r2)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
   11148:	e0bffc17 	ldw	r2,-16(fp)
   1114c:	10800b8b 	ldhu	r2,46(r2)
   11150:	10bfffcc 	andi	r2,r2,65535
   11154:	1004d23a 	srli	r2,r2,8
   11158:	1007883a 	mov	r3,r2
   1115c:	e0bffc17 	ldw	r2,-16(fp)
   11160:	10800b8b 	ldhu	r2,46(r2)
   11164:	10bfffcc 	andi	r2,r2,65535
   11168:	1004923a 	slli	r2,r2,8
   1116c:	1884b03a 	or	r2,r3,r2
   11170:	1007883a 	mov	r3,r2
   11174:	e0bffb17 	ldw	r2,-20(fp)
   11178:	10c0038d 	sth	r3,14(r2)
  tcphdr->urgp = 0;
   1117c:	e0bffb17 	ldw	r2,-20(fp)
   11180:	1000048d 	sth	zero,18(r2)
  TCPH_HDRLEN_SET(tcphdr, (5 + optlen / 4));
   11184:	e0bffe17 	ldw	r2,-8(fp)
   11188:	1000010e 	bge	r2,zero,11190 <tcp_output_set_header+0x19c>
   1118c:	108000c4 	addi	r2,r2,3
   11190:	1005d0ba 	srai	r2,r2,2
   11194:	10800144 	addi	r2,r2,5
   11198:	1004933a 	slli	r2,r2,12
   1119c:	1007883a 	mov	r3,r2
   111a0:	e0bffb17 	ldw	r2,-20(fp)
   111a4:	1080030b 	ldhu	r2,12(r2)
   111a8:	10bfffcc 	andi	r2,r2,65535
   111ac:	1004d23a 	srli	r2,r2,8
   111b0:	113fffcc 	andi	r4,r2,65535
   111b4:	e0bffb17 	ldw	r2,-20(fp)
   111b8:	1080030b 	ldhu	r2,12(r2)
   111bc:	10bfffcc 	andi	r2,r2,65535
   111c0:	1004923a 	slli	r2,r2,8
   111c4:	10bfffcc 	andi	r2,r2,65535
   111c8:	2084b03a 	or	r2,r4,r2
   111cc:	10800fcc 	andi	r2,r2,63
   111d0:	1884b03a 	or	r2,r3,r2
   111d4:	10bfc00c 	andi	r2,r2,65280
   111d8:	1004d23a 	srli	r2,r2,8
   111dc:	1007883a 	mov	r3,r2
   111e0:	e0bffe17 	ldw	r2,-8(fp)
   111e4:	1000010e 	bge	r2,zero,111ec <tcp_output_set_header+0x1f8>
   111e8:	108000c4 	addi	r2,r2,3
   111ec:	1005d0ba 	srai	r2,r2,2
   111f0:	10800144 	addi	r2,r2,5
   111f4:	1004933a 	slli	r2,r2,12
   111f8:	1009883a 	mov	r4,r2
   111fc:	e0bffb17 	ldw	r2,-20(fp)
   11200:	1080030b 	ldhu	r2,12(r2)
   11204:	10bfffcc 	andi	r2,r2,65535
   11208:	1004d23a 	srli	r2,r2,8
   1120c:	100b883a 	mov	r5,r2
   11210:	e0bffb17 	ldw	r2,-20(fp)
   11214:	1080030b 	ldhu	r2,12(r2)
   11218:	10bfffcc 	andi	r2,r2,65535
   1121c:	1004923a 	slli	r2,r2,8
   11220:	2884b03a 	or	r2,r5,r2
   11224:	10800fcc 	andi	r2,r2,63
   11228:	2084b03a 	or	r2,r4,r2
   1122c:	1004923a 	slli	r2,r2,8
   11230:	1884b03a 	or	r2,r3,r2
   11234:	1007883a 	mov	r3,r2
   11238:	e0bffb17 	ldw	r2,-20(fp)
   1123c:	10c0030d 	sth	r3,12(r2)
  tcphdr->chksum = 0;
   11240:	e0bffb17 	ldw	r2,-20(fp)
   11244:	1000040d 	sth	zero,16(r2)

  /* If we're sending a packet, update the announced right window edge */
  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
   11248:	e0bffc17 	ldw	r2,-16(fp)
   1124c:	10c00a17 	ldw	r3,40(r2)
   11250:	e0bffc17 	ldw	r2,-16(fp)
   11254:	10800b8b 	ldhu	r2,46(r2)
   11258:	10bfffcc 	andi	r2,r2,65535
   1125c:	1887883a 	add	r3,r3,r2
   11260:	e0bffc17 	ldw	r2,-16(fp)
   11264:	10c00c15 	stw	r3,48(r2)

  return tcphdr;
   11268:	e0bffb17 	ldw	r2,-20(fp)
}
   1126c:	e037883a 	mov	sp,fp
   11270:	df000017 	ldw	fp,0(sp)
   11274:	dec00104 	addi	sp,sp,4
   11278:	f800283a 	ret

0001127c <tcp_send_ctrl>:
 * @param flags the flags to set in the segment header
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_ctrl(struct tcp_pcb *pcb, u8_t flags)
{
   1127c:	defffa04 	addi	sp,sp,-24
   11280:	dfc00515 	stw	ra,20(sp)
   11284:	df000415 	stw	fp,16(sp)
   11288:	df000404 	addi	fp,sp,16
   1128c:	e13ffe15 	stw	r4,-8(fp)
   11290:	2805883a 	mov	r2,r5
   11294:	e0bfff05 	stb	r2,-4(fp)
  /* no data, no length, flags, copy=1, no optdata */
  return tcp_enqueue(pcb, NULL, 0, flags, TCP_WRITE_FLAG_COPY, 0);
   11298:	e0bfff03 	ldbu	r2,-4(fp)
   1129c:	00c00044 	movi	r3,1
   112a0:	d8c00015 	stw	r3,0(sp)
   112a4:	d8000115 	stw	zero,4(sp)
   112a8:	e13ffe17 	ldw	r4,-8(fp)
   112ac:	000b883a 	mov	r5,zero
   112b0:	000d883a 	mov	r6,zero
   112b4:	100f883a 	mov	r7,r2
   112b8:	00113880 	call	11388 <tcp_enqueue>
}
   112bc:	e037883a 	mov	sp,fp
   112c0:	dfc00117 	ldw	ra,4(sp)
   112c4:	df000017 	ldw	fp,0(sp)
   112c8:	dec00204 	addi	sp,sp,8
   112cc:	f800283a 	ret

000112d0 <tcp_write>:
 * 
 * @see tcp_write()
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
   112d0:	defff804 	addi	sp,sp,-32
   112d4:	dfc00715 	stw	ra,28(sp)
   112d8:	df000615 	stw	fp,24(sp)
   112dc:	df000604 	addi	fp,sp,24
   112e0:	e13ffc15 	stw	r4,-16(fp)
   112e4:	e17ffd15 	stw	r5,-12(fp)
   112e8:	3007883a 	mov	r3,r6
   112ec:	3805883a 	mov	r2,r7
   112f0:	e0fffe0d 	sth	r3,-8(fp)
   112f4:	e0bfff05 	stb	r2,-4(fp)
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
   112f8:	e0bffc17 	ldw	r2,-16(fp)
   112fc:	10800417 	ldw	r2,16(r2)
   11300:	10800120 	cmpeqi	r2,r2,4
   11304:	10000c1e 	bne	r2,zero,11338 <tcp_write+0x68>
     pcb->state == CLOSE_WAIT ||
   11308:	e0bffc17 	ldw	r2,-16(fp)
   1130c:	10800417 	ldw	r2,16(r2)
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
   11310:	108001e0 	cmpeqi	r2,r2,7
   11314:	1000081e 	bne	r2,zero,11338 <tcp_write+0x68>
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
   11318:	e0bffc17 	ldw	r2,-16(fp)
   1131c:	10800417 	ldw	r2,16(r2)
{
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
     pcb->state == CLOSE_WAIT ||
   11320:	108000a0 	cmpeqi	r2,r2,2
   11324:	1000041e 	bne	r2,zero,11338 <tcp_write+0x68>
     pcb->state == SYN_SENT ||
     pcb->state == SYN_RCVD) {
   11328:	e0bffc17 	ldw	r2,-16(fp)
   1132c:	10800417 	ldw	r2,16(r2)
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
   11330:	108000d8 	cmpnei	r2,r2,3
   11334:	10000e1e 	bne	r2,zero,11370 <tcp_write+0xa0>
     pcb->state == SYN_RCVD) {
    if (len > 0) {
   11338:	e0bffe0b 	ldhu	r2,-8(fp)
   1133c:	10000a26 	beq	r2,zero,11368 <tcp_write+0x98>
#if LWIP_TCP_TIMESTAMPS
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, 
                         pcb->flags & TF_TIMESTAMP ? TF_SEG_OPTS_TS : 0);
#else
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, 0);
   11340:	e0bffe0b 	ldhu	r2,-8(fp)
   11344:	e0ffff03 	ldbu	r3,-4(fp)
   11348:	d8c00015 	stw	r3,0(sp)
   1134c:	d8000115 	stw	zero,4(sp)
   11350:	e13ffc17 	ldw	r4,-16(fp)
   11354:	e17ffd17 	ldw	r5,-12(fp)
   11358:	100d883a 	mov	r6,r2
   1135c:	000f883a 	mov	r7,zero
   11360:	00113880 	call	11388 <tcp_enqueue>
   11364:	00000306 	br	11374 <tcp_write+0xa4>
#endif
    }
    return ERR_OK;
   11368:	0005883a 	mov	r2,zero
   1136c:	00000106 	br	11374 <tcp_write+0xa4>
  } else {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
   11370:	00bffe04 	movi	r2,-8
  }
}
   11374:	e037883a 	mov	sp,fp
   11378:	dfc00117 	ldw	ra,4(sp)
   1137c:	df000017 	ldw	fp,0(sp)
   11380:	dec00204 	addi	sp,sp,8
   11384:	f800283a 	ret

00011388 <tcp_enqueue>:
 * @param optflags options to include in segment later on (see definition of struct tcp_seg)
 */
err_t
tcp_enqueue(struct tcp_pcb *pcb, void *arg, u16_t len,
            u8_t flags, u8_t apiflags, u8_t optflags)
{
   11388:	deffef04 	addi	sp,sp,-68
   1138c:	dfc01015 	stw	ra,64(sp)
   11390:	df000f15 	stw	fp,60(sp)
   11394:	df000f04 	addi	fp,sp,60
   11398:	e13ffa15 	stw	r4,-24(fp)
   1139c:	e17ffb15 	stw	r5,-20(fp)
   113a0:	3007883a 	mov	r3,r6
   113a4:	3805883a 	mov	r2,r7
   113a8:	e1400217 	ldw	r5,8(fp)
   113ac:	e1000317 	ldw	r4,12(fp)
   113b0:	e0fffc0d 	sth	r3,-16(fp)
   113b4:	e0bffd05 	stb	r2,-12(fp)
   113b8:	e17ffe05 	stb	r5,-8(fp)
   113bc:	e13fff05 	stb	r4,-4(fp)
  u8_t optlen;

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, 
              ("tcp_enqueue(pcb=%p, arg=%p, len=%"U16_F", flags=%"X16_F", apiflags=%"U16_F")\n",
               (void *)pcb, arg, len, (u16_t)flags, (u16_t)apiflags));
  LWIP_ERROR("tcp_enqueue: packet needs payload, options, or SYN/FIN (programmer violates API)",
   113c0:	e0bffc0b 	ldhu	r2,-16(fp)
   113c4:	10000e1e 	bne	r2,zero,11400 <tcp_enqueue+0x78>
   113c8:	e0bfff03 	ldbu	r2,-4(fp)
   113cc:	10000c1e 	bne	r2,zero,11400 <tcp_enqueue+0x78>
   113d0:	e0bffd03 	ldbu	r2,-12(fp)
   113d4:	108000cc 	andi	r2,r2,3
   113d8:	1000091e 	bne	r2,zero,11400 <tcp_enqueue+0x78>
   113dc:	010000f4 	movhi	r4,3
   113e0:	213acc04 	addi	r4,r4,-5328
   113e4:	014000f4 	movhi	r5,3
   113e8:	297ad604 	addi	r5,r5,-5288
   113ec:	01802ac4 	movi	r6,171
   113f0:	01c000f4 	movhi	r7,3
   113f4:	39faeb04 	addi	r7,r7,-5204
   113f8:	00166c00 	call	166c0 <printf>
   113fc:	003fff06 	br	113fc <tcp_enqueue+0x74>
             ((len != 0) || (optflags != 0) || ((flags & (TCP_SYN | TCP_FIN)) != 0)),
             return ERR_ARG;);
  LWIP_ERROR("tcp_enqueue: len != 0 || arg == NULL (programmer violates API)", 
   11400:	e0bffc0b 	ldhu	r2,-16(fp)
   11404:	10000b1e 	bne	r2,zero,11434 <tcp_enqueue+0xac>
   11408:	e0bffb17 	ldw	r2,-20(fp)
   1140c:	10000926 	beq	r2,zero,11434 <tcp_enqueue+0xac>
   11410:	010000f4 	movhi	r4,3
   11414:	213acc04 	addi	r4,r4,-5328
   11418:	014000f4 	movhi	r5,3
   1141c:	297af104 	addi	r5,r5,-5180
   11420:	01802b44 	movi	r6,173
   11424:	01c000f4 	movhi	r7,3
   11428:	39faeb04 	addi	r7,r7,-5204
   1142c:	00166c00 	call	166c0 <printf>
   11430:	003fff06 	br	11430 <tcp_enqueue+0xa8>
             ((len != 0) || (arg == NULL)), return ERR_ARG;);

  /* fail on too much data */
  if (len > pcb->snd_buf) {
   11434:	e0bffa17 	ldw	r2,-24(fp)
   11438:	10801c8b 	ldhu	r2,114(r2)
   1143c:	10ffffcc 	andi	r3,r2,65535
   11440:	e0bffc0b 	ldhu	r2,-16(fp)
   11444:	1880092e 	bgeu	r3,r2,1146c <tcp_enqueue+0xe4>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_WARNING,
      ("tcp_enqueue: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n", len, pcb->snd_buf));
    pcb->flags |= TF_NAGLEMEMERR;
   11448:	e0bffa17 	ldw	r2,-24(fp)
   1144c:	10c00983 	ldbu	r3,38(r2)
   11450:	00bfe004 	movi	r2,-128
   11454:	1884b03a 	or	r2,r3,r2
   11458:	1007883a 	mov	r3,r2
   1145c:	e0bffa17 	ldw	r2,-24(fp)
   11460:	10c00985 	stb	r3,38(r2)
    return ERR_MEM;
   11464:	00bfffc4 	movi	r2,-1
   11468:	00031706 	br	120c8 <tcp_enqueue+0xd40>
  }
  left = len;
   1146c:	e0bffc0b 	ldhu	r2,-16(fp)
   11470:	e0bff50d 	sth	r2,-44(fp)
  ptr = arg;
   11474:	e0bffb17 	ldw	r2,-20(fp)
   11478:	e0bff615 	stw	r2,-40(fp)

  optlen = LWIP_TCP_OPT_LENGTH(optflags);
   1147c:	e0bfff03 	ldbu	r2,-4(fp)
   11480:	1080004c 	andi	r2,r2,1
   11484:	10000226 	beq	r2,zero,11490 <tcp_enqueue+0x108>
   11488:	00c00104 	movi	r3,4
   1148c:	00000106 	br	11494 <tcp_enqueue+0x10c>
   11490:	0007883a 	mov	r3,zero
   11494:	e0bfff03 	ldbu	r2,-4(fp)
   11498:	1080008c 	andi	r2,r2,2
   1149c:	10000226 	beq	r2,zero,114a8 <tcp_enqueue+0x120>
   114a0:	00800304 	movi	r2,12
   114a4:	00000106 	br	114ac <tcp_enqueue+0x124>
   114a8:	0005883a 	mov	r2,zero
   114ac:	1885883a 	add	r2,r3,r2
   114b0:	e0bff785 	stb	r2,-34(fp)

  /* seqno will be the sequence number of the first segment enqueued
   * by the call to this function. */
  seqno = pcb->snd_lbb;
   114b4:	e0bffa17 	ldw	r2,-24(fp)
   114b8:	10801b17 	ldw	r2,108(r2)
   114bc:	e0bff415 	stw	r2,-48(fp)

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  queuelen = pcb->snd_queuelen;
   114c0:	e0bffa17 	ldw	r2,-24(fp)
   114c4:	10801d0b 	ldhu	r2,116(r2)
   114c8:	e0bff70d 	sth	r2,-36(fp)
  /* check for configured max queuelen and possible overflow */
  if ((queuelen >= TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
   114cc:	e0bff70b 	ldhu	r2,-36(fp)
   114d0:	10800b28 	cmpgeui	r2,r2,44
   114d4:	1000031e 	bne	r2,zero,114e4 <tcp_enqueue+0x15c>
   114d8:	e0bff70b 	ldhu	r2,-36(fp)
   114dc:	10bfff70 	cmpltui	r2,r2,65533
   114e0:	1000111e 	bne	r2,zero,11528 <tcp_enqueue+0x1a0>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_WARNING,
      ("tcp_enqueue: too long queue %"U16_F" (max %"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
   114e4:	00800134 	movhi	r2,4
   114e8:	108d9504 	addi	r2,r2,13908
   114ec:	1080270b 	ldhu	r2,156(r2)
   114f0:	10800044 	addi	r2,r2,1
   114f4:	1007883a 	mov	r3,r2
   114f8:	00800134 	movhi	r2,4
   114fc:	108d9504 	addi	r2,r2,13908
   11500:	10c0270d 	sth	r3,156(r2)
    pcb->flags |= TF_NAGLEMEMERR;
   11504:	e0bffa17 	ldw	r2,-24(fp)
   11508:	10c00983 	ldbu	r3,38(r2)
   1150c:	00bfe004 	movi	r2,-128
   11510:	1884b03a 	or	r2,r3,r2
   11514:	1007883a 	mov	r3,r2
   11518:	e0bffa17 	ldw	r2,-24(fp)
   1151c:	10c00985 	stb	r3,38(r2)
    return ERR_MEM;
   11520:	00bfffc4 	movi	r2,-1
   11524:	0002e806 	br	120c8 <tcp_enqueue+0xd40>
  }
  if (queuelen != 0) {
   11528:	e0bff70b 	ldhu	r2,-36(fp)
   1152c:	10000f26 	beq	r2,zero,1156c <tcp_enqueue+0x1e4>
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
   11530:	e0bffa17 	ldw	r2,-24(fp)
   11534:	10801f17 	ldw	r2,124(r2)
   11538:	10001b1e 	bne	r2,zero,115a8 <tcp_enqueue+0x220>
   1153c:	e0bffa17 	ldw	r2,-24(fp)
   11540:	10801e17 	ldw	r2,120(r2)
   11544:	1000181e 	bne	r2,zero,115a8 <tcp_enqueue+0x220>
   11548:	010000f4 	movhi	r4,3
   1154c:	213acc04 	addi	r4,r4,-5328
   11550:	014000f4 	movhi	r5,3
   11554:	297b0104 	addi	r5,r5,-5116
   11558:	01803384 	movi	r6,206
   1155c:	01c000f4 	movhi	r7,3
   11560:	39faeb04 	addi	r7,r7,-5204
   11564:	00166c00 	call	166c0 <printf>
   11568:	003fff06 	br	11568 <tcp_enqueue+0x1e0>
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
   1156c:	e0bffa17 	ldw	r2,-24(fp)
   11570:	10801f17 	ldw	r2,124(r2)
   11574:	1000031e 	bne	r2,zero,11584 <tcp_enqueue+0x1fc>
   11578:	e0bffa17 	ldw	r2,-24(fp)
   1157c:	10801e17 	ldw	r2,120(r2)
   11580:	10000926 	beq	r2,zero,115a8 <tcp_enqueue+0x220>
   11584:	010000f4 	movhi	r4,3
   11588:	213acc04 	addi	r4,r4,-5328
   1158c:	014000f4 	movhi	r5,3
   11590:	297b1004 	addi	r5,r5,-5056
   11594:	01803444 	movi	r6,209
   11598:	01c000f4 	movhi	r7,3
   1159c:	39faeb04 	addi	r7,r7,-5204
   115a0:	00166c00 	call	166c0 <printf>
   115a4:	003fff06 	br	115a4 <tcp_enqueue+0x21c>
      pcb->unacked == NULL && pcb->unsent == NULL);
  }

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
   115a8:	e03ff115 	stw	zero,-60(fp)
   115ac:	e0bff117 	ldw	r2,-60(fp)
   115b0:	e0bff315 	stw	r2,-52(fp)
   115b4:	e0bff317 	ldw	r2,-52(fp)
   115b8:	e0bff215 	stw	r2,-56(fp)
  seglen = 0;
   115bc:	e03ff58d 	sth	zero,-42(fp)
  while (queue == NULL || left > 0) {
   115c0:	00013506 	br	11a98 <tcp_enqueue+0x710>
    /* The segment length (including options) should be at most the MSS */
    seglen = left > (pcb->mss - optlen) ? (pcb->mss - optlen) : left;
   115c4:	e0bff50b 	ldhu	r2,-44(fp)
   115c8:	e0fffa17 	ldw	r3,-24(fp)
   115cc:	18c00f0b 	ldhu	r3,60(r3)
   115d0:	193fffcc 	andi	r4,r3,65535
   115d4:	e0fff783 	ldbu	r3,-34(fp)
   115d8:	20c7c83a 	sub	r3,r4,r3
   115dc:	1880010e 	bge	r3,r2,115e4 <tcp_enqueue+0x25c>
   115e0:	1805883a 	mov	r2,r3
   115e4:	e0bff58d 	sth	r2,-42(fp)

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
   115e8:	01000104 	movi	r4,4
   115ec:	0008ef00 	call	8ef0 <memp_malloc>
   115f0:	e0bff115 	stw	r2,-60(fp)
    if (seg == NULL) {
   115f4:	e0bff117 	ldw	r2,-60(fp)
   115f8:	10028526 	beq	r2,zero,12010 <tcp_enqueue+0xc88>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, 
                  ("tcp_enqueue: could not allocate memory for tcp_seg\n"));
      goto memerr;
    }
    seg->next = NULL;
   115fc:	e0bff117 	ldw	r2,-60(fp)
   11600:	10000015 	stw	zero,0(r2)
    seg->p = NULL;
   11604:	e0bff117 	ldw	r2,-60(fp)
   11608:	10000115 	stw	zero,4(r2)

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
   1160c:	e0bff317 	ldw	r2,-52(fp)
   11610:	1000031e 	bne	r2,zero,11620 <tcp_enqueue+0x298>
      queue = seg;
   11614:	e0bff117 	ldw	r2,-60(fp)
   11618:	e0bff315 	stw	r2,-52(fp)
   1161c:	00000e06 	br	11658 <tcp_enqueue+0x2d0>
    }
    /* subsequent segments of to-be-queued data */
    else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("useg != NULL", useg != NULL);
   11620:	e0bff217 	ldw	r2,-56(fp)
   11624:	1000091e 	bne	r2,zero,1164c <tcp_enqueue+0x2c4>
   11628:	010000f4 	movhi	r4,3
   1162c:	213acc04 	addi	r4,r4,-5328
   11630:	014000f4 	movhi	r5,3
   11634:	297b1d04 	addi	r5,r5,-5004
   11638:	01803b44 	movi	r6,237
   1163c:	01c000f4 	movhi	r7,3
   11640:	39faeb04 	addi	r7,r7,-5204
   11644:	00166c00 	call	166c0 <printf>
   11648:	003fff06 	br	11648 <tcp_enqueue+0x2c0>
      useg->next = seg;
   1164c:	e0bff217 	ldw	r2,-56(fp)
   11650:	e0fff117 	ldw	r3,-60(fp)
   11654:	10c00015 	stw	r3,0(r2)
    }
    /* remember last segment of to-be-queued data for next iteration */
    useg = seg;
   11658:	e0bff117 	ldw	r2,-60(fp)
   1165c:	e0bff215 	stw	r2,-56(fp)

    /* If copy is set, memory should be allocated
     * and data copied into pbuf, otherwise data comes from
     * ROM or other static memory, and need not be copied.  */
    if (apiflags & TCP_WRITE_FLAG_COPY) {
   11660:	e0bffe03 	ldbu	r2,-8(fp)
   11664:	1080004c 	andi	r2,r2,1
   11668:	10003826 	beq	r2,zero,1174c <tcp_enqueue+0x3c4>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen + optlen, PBUF_RAM)) == NULL) {
   1166c:	e0fff783 	ldbu	r3,-34(fp)
   11670:	e0bff58b 	ldhu	r2,-42(fp)
   11674:	1885883a 	add	r2,r3,r2
   11678:	10bfffcc 	andi	r2,r2,65535
   1167c:	0009883a 	mov	r4,zero
   11680:	100b883a 	mov	r5,r2
   11684:	000d883a 	mov	r6,zero
   11688:	00097b00 	call	97b0 <pbuf_alloc>
   1168c:	e0fff117 	ldw	r3,-60(fp)
   11690:	18800115 	stw	r2,4(r3)
   11694:	e0bff117 	ldw	r2,-60(fp)
   11698:	10800117 	ldw	r2,4(r2)
   1169c:	10025e26 	beq	r2,zero,12018 <tcp_enqueue+0xc90>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, 
                    ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
   116a0:	e0bff117 	ldw	r2,-60(fp)
   116a4:	10800117 	ldw	r2,4(r2)
   116a8:	1080028b 	ldhu	r2,10(r2)
   116ac:	10ffffcc 	andi	r3,r2,65535
   116b0:	e13ff58b 	ldhu	r4,-42(fp)
   116b4:	e0bff783 	ldbu	r2,-34(fp)
   116b8:	2085883a 	add	r2,r4,r2
   116bc:	1880090e 	bge	r3,r2,116e4 <tcp_enqueue+0x35c>
   116c0:	010000f4 	movhi	r4,3
   116c4:	213acc04 	addi	r4,r4,-5328
   116c8:	014000f4 	movhi	r5,3
   116cc:	297b2104 	addi	r5,r5,-4988
   116d0:	01803f44 	movi	r6,253
   116d4:	01c000f4 	movhi	r7,3
   116d8:	39faeb04 	addi	r7,r7,-5204
   116dc:	00166c00 	call	166c0 <printf>
   116e0:	003fff06 	br	116e0 <tcp_enqueue+0x358>
                  (seg->p->len >= seglen + optlen));
      queuelen += pbuf_clen(seg->p);
   116e4:	e0bff117 	ldw	r2,-60(fp)
   116e8:	10800117 	ldw	r2,4(r2)
   116ec:	1009883a 	mov	r4,r2
   116f0:	000a3380 	call	a338 <pbuf_clen>
   116f4:	10c03fcc 	andi	r3,r2,255
   116f8:	e0bff70b 	ldhu	r2,-36(fp)
   116fc:	1885883a 	add	r2,r3,r2
   11700:	e0bff70d 	sth	r2,-36(fp)
      if (arg != NULL) {
   11704:	e0bffb17 	ldw	r2,-20(fp)
   11708:	10000a26 	beq	r2,zero,11734 <tcp_enqueue+0x3ac>
        MEMCPY((char *)seg->p->payload + optlen, ptr, seglen);
   1170c:	e0bff117 	ldw	r2,-60(fp)
   11710:	10800117 	ldw	r2,4(r2)
   11714:	10c00117 	ldw	r3,4(r2)
   11718:	e0bff783 	ldbu	r2,-34(fp)
   1171c:	1887883a 	add	r3,r3,r2
   11720:	e0bff58b 	ldhu	r2,-42(fp)
   11724:	1809883a 	mov	r4,r3
   11728:	e17ff617 	ldw	r5,-40(fp)
   1172c:	100d883a 	mov	r6,r2
   11730:	00164c00 	call	164c0 <memcpy>
      }
      seg->dataptr = seg->p->payload;
   11734:	e0bff117 	ldw	r2,-60(fp)
   11738:	10800117 	ldw	r2,4(r2)
   1173c:	10c00117 	ldw	r3,4(r2)
   11740:	e0bff117 	ldw	r2,-60(fp)
   11744:	10c00215 	stw	r3,8(r2)
   11748:	00003206 	br	11814 <tcp_enqueue+0x48c>
    }
    /* do not copy data */
    else {
      /* First, allocate a pbuf for the headers. */
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
   1174c:	e0bff783 	ldbu	r2,-34(fp)
   11750:	0009883a 	mov	r4,zero
   11754:	100b883a 	mov	r5,r2
   11758:	000d883a 	mov	r6,zero
   1175c:	00097b00 	call	97b0 <pbuf_alloc>
   11760:	e0fff117 	ldw	r3,-60(fp)
   11764:	18800115 	stw	r2,4(r3)
   11768:	e0bff117 	ldw	r2,-60(fp)
   1176c:	10800117 	ldw	r2,4(r2)
   11770:	10022b26 	beq	r2,zero,12020 <tcp_enqueue+0xc98>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, 
                    ("tcp_enqueue: could not allocate memory for header pbuf\n"));
        goto memerr;
      }
      queuelen += pbuf_clen(seg->p);
   11774:	e0bff117 	ldw	r2,-60(fp)
   11778:	10800117 	ldw	r2,4(r2)
   1177c:	1009883a 	mov	r4,r2
   11780:	000a3380 	call	a338 <pbuf_clen>
   11784:	10c03fcc 	andi	r3,r2,255
   11788:	e0bff70b 	ldhu	r2,-36(fp)
   1178c:	1885883a 	add	r2,r3,r2
   11790:	e0bff70d 	sth	r2,-36(fp)
      /* Second, allocate a pbuf for holding the data.
       * since the referenced data is available at least until it is sent out on the
       * link (as it has to be ACKed by the remote party) we can safely use PBUF_ROM
       * instead of PBUF_REF here.
       */
      if (left > 0) {
   11794:	e0bff50b 	ldhu	r2,-44(fp)
   11798:	10001e26 	beq	r2,zero,11814 <tcp_enqueue+0x48c>
        if ((p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
   1179c:	e0bff58b 	ldhu	r2,-42(fp)
   117a0:	010000c4 	movi	r4,3
   117a4:	100b883a 	mov	r5,r2
   117a8:	01800044 	movi	r6,1
   117ac:	00097b00 	call	97b0 <pbuf_alloc>
   117b0:	e0bff915 	stw	r2,-28(fp)
   117b4:	e0bff917 	ldw	r2,-28(fp)
   117b8:	1000071e 	bne	r2,zero,117d8 <tcp_enqueue+0x450>
          /* If allocation fails, we have to deallocate the header pbuf as well. */
          pbuf_free(seg->p);
   117bc:	e0bff117 	ldw	r2,-60(fp)
   117c0:	10800117 	ldw	r2,4(r2)
   117c4:	1009883a 	mov	r4,r2
   117c8:	000a16c0 	call	a16c <pbuf_free>
          seg->p = NULL;
   117cc:	e0bff117 	ldw	r2,-60(fp)
   117d0:	10000115 	stw	zero,4(r2)
          LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, 
                      ("tcp_enqueue: could not allocate memory for zero-copy pbuf\n"));
          goto memerr;
   117d4:	00021506 	br	1202c <tcp_enqueue+0xca4>
        }
        ++queuelen;
   117d8:	e0bff70b 	ldhu	r2,-36(fp)
   117dc:	10800044 	addi	r2,r2,1
   117e0:	e0bff70d 	sth	r2,-36(fp)
        /* reference the non-volatile payload data */
        p->payload = ptr;
   117e4:	e0bff917 	ldw	r2,-28(fp)
   117e8:	e0fff617 	ldw	r3,-40(fp)
   117ec:	10c00115 	stw	r3,4(r2)
        seg->dataptr = ptr;
   117f0:	e0bff117 	ldw	r2,-60(fp)
   117f4:	e0fff617 	ldw	r3,-40(fp)
   117f8:	10c00215 	stw	r3,8(r2)

        /* Concatenate the headers and data pbufs together. */
        pbuf_cat(seg->p/*header*/, p/*data*/);
   117fc:	e0bff117 	ldw	r2,-60(fp)
   11800:	10800117 	ldw	r2,4(r2)
   11804:	1009883a 	mov	r4,r2
   11808:	e17ff917 	ldw	r5,-28(fp)
   1180c:	000a3c40 	call	a3c4 <pbuf_cat>
        p = NULL;
   11810:	e03ff915 	stw	zero,-28(fp)
      }
    }

    /* Now that there are more segments queued, we check again if the
    length of the queue exceeds the configured maximum or overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
   11814:	e0bff70b 	ldhu	r2,-36(fp)
   11818:	10800b68 	cmpgeui	r2,r2,45
   1181c:	1002021e 	bne	r2,zero,12028 <tcp_enqueue+0xca0>
   11820:	e0bff70b 	ldhu	r2,-36(fp)
   11824:	10bfff70 	cmpltui	r2,r2,65533
   11828:	1001ff26 	beq	r2,zero,12028 <tcp_enqueue+0xca0>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
        ("tcp_enqueue: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      goto memerr;
    }

    seg->len = seglen;
   1182c:	e0bff117 	ldw	r2,-60(fp)
   11830:	e0fff58b 	ldhu	r3,-42(fp)
   11834:	10c0030d 	sth	r3,12(r2)

    /* build TCP header */
    if (pbuf_header(seg->p, TCP_HLEN)) {
   11838:	e0bff117 	ldw	r2,-60(fp)
   1183c:	10800117 	ldw	r2,4(r2)
   11840:	1009883a 	mov	r4,r2
   11844:	01400504 	movi	r5,20
   11848:	0009f740 	call	9f74 <pbuf_header>
   1184c:	10803fcc 	andi	r2,r2,255
   11850:	10000926 	beq	r2,zero,11878 <tcp_enqueue+0x4f0>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_enqueue: no room for TCP header in pbuf.\n"));
      TCP_STATS_INC(tcp.err);
   11854:	00800134 	movhi	r2,4
   11858:	108d9504 	addi	r2,r2,13908
   1185c:	1080290b 	ldhu	r2,164(r2)
   11860:	10800044 	addi	r2,r2,1
   11864:	1007883a 	mov	r3,r2
   11868:	00800134 	movhi	r2,4
   1186c:	108d9504 	addi	r2,r2,13908
   11870:	10c0290d 	sth	r3,164(r2)
      goto memerr;
   11874:	0001ed06 	br	1202c <tcp_enqueue+0xca4>
    }
    seg->tcphdr = seg->p->payload;
   11878:	e0bff117 	ldw	r2,-60(fp)
   1187c:	10800117 	ldw	r2,4(r2)
   11880:	10c00117 	ldw	r3,4(r2)
   11884:	e0bff117 	ldw	r2,-60(fp)
   11888:	10c00415 	stw	r3,16(r2)
    seg->tcphdr->src = htons(pcb->local_port);
   1188c:	e0bff117 	ldw	r2,-60(fp)
   11890:	10800417 	ldw	r2,16(r2)
   11894:	e0fffa17 	ldw	r3,-24(fp)
   11898:	18c0070b 	ldhu	r3,28(r3)
   1189c:	18ffffcc 	andi	r3,r3,65535
   118a0:	1806d23a 	srli	r3,r3,8
   118a4:	1809883a 	mov	r4,r3
   118a8:	e0fffa17 	ldw	r3,-24(fp)
   118ac:	18c0070b 	ldhu	r3,28(r3)
   118b0:	18ffffcc 	andi	r3,r3,65535
   118b4:	1806923a 	slli	r3,r3,8
   118b8:	20c6b03a 	or	r3,r4,r3
   118bc:	10c0000d 	sth	r3,0(r2)
    seg->tcphdr->dest = htons(pcb->remote_port);
   118c0:	e0bff117 	ldw	r2,-60(fp)
   118c4:	10800417 	ldw	r2,16(r2)
   118c8:	e0fffa17 	ldw	r3,-24(fp)
   118cc:	18c0090b 	ldhu	r3,36(r3)
   118d0:	18ffffcc 	andi	r3,r3,65535
   118d4:	1806d23a 	srli	r3,r3,8
   118d8:	1809883a 	mov	r4,r3
   118dc:	e0fffa17 	ldw	r3,-24(fp)
   118e0:	18c0090b 	ldhu	r3,36(r3)
   118e4:	18ffffcc 	andi	r3,r3,65535
   118e8:	1806923a 	slli	r3,r3,8
   118ec:	20c6b03a 	or	r3,r4,r3
   118f0:	10c0008d 	sth	r3,2(r2)
    seg->tcphdr->seqno = htonl(seqno);
   118f4:	e0bff117 	ldw	r2,-60(fp)
   118f8:	10800417 	ldw	r2,16(r2)
   118fc:	e0fff417 	ldw	r3,-48(fp)
   11900:	1808d63a 	srli	r4,r3,24
   11904:	e0fff417 	ldw	r3,-48(fp)
   11908:	1806d23a 	srli	r3,r3,8
   1190c:	18ffc00c 	andi	r3,r3,65280
   11910:	20c8b03a 	or	r4,r4,r3
   11914:	e0fff417 	ldw	r3,-48(fp)
   11918:	18ffc00c 	andi	r3,r3,65280
   1191c:	1806923a 	slli	r3,r3,8
   11920:	20c8b03a 	or	r4,r4,r3
   11924:	e0fff417 	ldw	r3,-48(fp)
   11928:	1806963a 	slli	r3,r3,24
   1192c:	20c6b03a 	or	r3,r4,r3
   11930:	193fffcc 	andi	r4,r3,65535
   11934:	1140010b 	ldhu	r5,4(r2)
   11938:	280a703a 	and	r5,r5,zero
   1193c:	2908b03a 	or	r4,r5,r4
   11940:	1100010d 	sth	r4,4(r2)
   11944:	1806d43a 	srli	r3,r3,16
   11948:	1100018b 	ldhu	r4,6(r2)
   1194c:	2008703a 	and	r4,r4,zero
   11950:	20c6b03a 	or	r3,r4,r3
   11954:	10c0018d 	sth	r3,6(r2)
    seg->tcphdr->urgp = 0;
   11958:	e0bff117 	ldw	r2,-60(fp)
   1195c:	10800417 	ldw	r2,16(r2)
   11960:	1000048d 	sth	zero,18(r2)
    TCPH_FLAGS_SET(seg->tcphdr, flags);
   11964:	e0bff117 	ldw	r2,-60(fp)
   11968:	10800417 	ldw	r2,16(r2)
   1196c:	e0fff117 	ldw	r3,-60(fp)
   11970:	18c00417 	ldw	r3,16(r3)
   11974:	18c0030b 	ldhu	r3,12(r3)
   11978:	1809883a 	mov	r4,r3
   1197c:	00f03fc4 	movi	r3,-16129
   11980:	20c6703a 	and	r3,r4,r3
   11984:	1809883a 	mov	r4,r3
   11988:	e0fffd03 	ldbu	r3,-12(fp)
   1198c:	1806923a 	slli	r3,r3,8
   11990:	20c6b03a 	or	r3,r4,r3
   11994:	10c0030d 	sth	r3,12(r2)
    /* don't fill in tcphdr->ackno and tcphdr->wnd until later */

    seg->flags = optflags;
   11998:	e0bff117 	ldw	r2,-60(fp)
   1199c:	e0ffff03 	ldbu	r3,-4(fp)
   119a0:	10c00385 	stb	r3,14(r2)

    /* Set the length of the header */
    TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
   119a4:	e0bff117 	ldw	r2,-60(fp)
   119a8:	10800417 	ldw	r2,16(r2)
   119ac:	e0fff783 	ldbu	r3,-34(fp)
   119b0:	1806d0ba 	srli	r3,r3,2
   119b4:	18c03fcc 	andi	r3,r3,255
   119b8:	18c00144 	addi	r3,r3,5
   119bc:	1806933a 	slli	r3,r3,12
   119c0:	1809883a 	mov	r4,r3
   119c4:	e0fff117 	ldw	r3,-60(fp)
   119c8:	18c00417 	ldw	r3,16(r3)
   119cc:	18c0030b 	ldhu	r3,12(r3)
   119d0:	18ffffcc 	andi	r3,r3,65535
   119d4:	1806d23a 	srli	r3,r3,8
   119d8:	197fffcc 	andi	r5,r3,65535
   119dc:	e0fff117 	ldw	r3,-60(fp)
   119e0:	18c00417 	ldw	r3,16(r3)
   119e4:	18c0030b 	ldhu	r3,12(r3)
   119e8:	18ffffcc 	andi	r3,r3,65535
   119ec:	1806923a 	slli	r3,r3,8
   119f0:	18ffffcc 	andi	r3,r3,65535
   119f4:	28c6b03a 	or	r3,r5,r3
   119f8:	18c00fcc 	andi	r3,r3,63
   119fc:	20c6b03a 	or	r3,r4,r3
   11a00:	18ffc00c 	andi	r3,r3,65280
   11a04:	1806d23a 	srli	r3,r3,8
   11a08:	1809883a 	mov	r4,r3
   11a0c:	e0fff783 	ldbu	r3,-34(fp)
   11a10:	1806d0ba 	srli	r3,r3,2
   11a14:	18c03fcc 	andi	r3,r3,255
   11a18:	18c00144 	addi	r3,r3,5
   11a1c:	1806933a 	slli	r3,r3,12
   11a20:	180b883a 	mov	r5,r3
   11a24:	e0fff117 	ldw	r3,-60(fp)
   11a28:	18c00417 	ldw	r3,16(r3)
   11a2c:	18c0030b 	ldhu	r3,12(r3)
   11a30:	18ffffcc 	andi	r3,r3,65535
   11a34:	1806d23a 	srli	r3,r3,8
   11a38:	180d883a 	mov	r6,r3
   11a3c:	e0fff117 	ldw	r3,-60(fp)
   11a40:	18c00417 	ldw	r3,16(r3)
   11a44:	18c0030b 	ldhu	r3,12(r3)
   11a48:	18ffffcc 	andi	r3,r3,65535
   11a4c:	1806923a 	slli	r3,r3,8
   11a50:	30c6b03a 	or	r3,r6,r3
   11a54:	18c00fcc 	andi	r3,r3,63
   11a58:	28c6b03a 	or	r3,r5,r3
   11a5c:	1806923a 	slli	r3,r3,8
   11a60:	20c6b03a 	or	r3,r4,r3
   11a64:	10c0030d 	sth	r3,12(r2)
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_enqueue: queueing %"U32_F":%"U32_F" (0x%"X16_F")\n",
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
   11a68:	e0fff50b 	ldhu	r3,-44(fp)
   11a6c:	e0bff58b 	ldhu	r2,-42(fp)
   11a70:	1885c83a 	sub	r2,r3,r2
   11a74:	e0bff50d 	sth	r2,-44(fp)
    seqno += seglen;
   11a78:	e0bff58b 	ldhu	r2,-42(fp)
   11a7c:	e0fff417 	ldw	r3,-48(fp)
   11a80:	1885883a 	add	r2,r3,r2
   11a84:	e0bff415 	stw	r2,-48(fp)
    ptr = (void *)((u8_t *)ptr + seglen);
   11a88:	e0bff58b 	ldhu	r2,-42(fp)
   11a8c:	e0fff617 	ldw	r3,-40(fp)
   11a90:	1885883a 	add	r2,r3,r2
   11a94:	e0bff615 	stw	r2,-40(fp)

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  seglen = 0;
  while (queue == NULL || left > 0) {
   11a98:	e0bff317 	ldw	r2,-52(fp)
   11a9c:	103ec926 	beq	r2,zero,115c4 <tcp_enqueue+0x23c>
   11aa0:	e0bff50b 	ldhu	r2,-44(fp)
   11aa4:	103ec71e 	bne	r2,zero,115c4 <tcp_enqueue+0x23c>
  }

  /* Now that the data to be enqueued has been broken up into TCP
  segments in the queue variable, we add them to the end of the
  pcb->unsent queue. */
  if (pcb->unsent == NULL) {
   11aa8:	e0bffa17 	ldw	r2,-24(fp)
   11aac:	10801e17 	ldw	r2,120(r2)
   11ab0:	1000021e 	bne	r2,zero,11abc <tcp_enqueue+0x734>
    useg = NULL;
   11ab4:	e03ff215 	stw	zero,-56(fp)
   11ab8:	00000a06 	br	11ae4 <tcp_enqueue+0x75c>
  }
  else {
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
   11abc:	e0bffa17 	ldw	r2,-24(fp)
   11ac0:	10801e17 	ldw	r2,120(r2)
   11ac4:	e0bff215 	stw	r2,-56(fp)
   11ac8:	00000306 	br	11ad8 <tcp_enqueue+0x750>
   11acc:	e0bff217 	ldw	r2,-56(fp)
   11ad0:	10800017 	ldw	r2,0(r2)
   11ad4:	e0bff215 	stw	r2,-56(fp)
   11ad8:	e0bff217 	ldw	r2,-56(fp)
   11adc:	10800017 	ldw	r2,0(r2)
   11ae0:	103ffa1e 	bne	r2,zero,11acc <tcp_enqueue+0x744>
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
   11ae4:	e0bff217 	ldw	r2,-56(fp)
   11ae8:	1000f826 	beq	r2,zero,11ecc <tcp_enqueue+0xb44>
    TCP_TCPLEN(useg) != 0 &&
   11aec:	e0bff217 	ldw	r2,-56(fp)
   11af0:	1080030b 	ldhu	r2,12(r2)
   11af4:	10ffffcc 	andi	r3,r2,65535
   11af8:	e0bff217 	ldw	r2,-56(fp)
   11afc:	10800417 	ldw	r2,16(r2)
   11b00:	1080030b 	ldhu	r2,12(r2)
   11b04:	10bfffcc 	andi	r2,r2,65535
   11b08:	1004d23a 	srli	r2,r2,8
   11b0c:	113fffcc 	andi	r4,r2,65535
   11b10:	e0bff217 	ldw	r2,-56(fp)
   11b14:	10800417 	ldw	r2,16(r2)
   11b18:	1080030b 	ldhu	r2,12(r2)
   11b1c:	10bfffcc 	andi	r2,r2,65535
   11b20:	1004923a 	slli	r2,r2,8
   11b24:	10bfffcc 	andi	r2,r2,65535
   11b28:	2084b03a 	or	r2,r4,r2
   11b2c:	108000cc 	andi	r2,r2,3
   11b30:	1004c03a 	cmpne	r2,r2,zero
   11b34:	10803fcc 	andi	r2,r2,255
   11b38:	1885883a 	add	r2,r3,r2
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
   11b3c:	1000e326 	beq	r2,zero,11ecc <tcp_enqueue+0xb44>
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
   11b40:	e0bff217 	ldw	r2,-56(fp)
   11b44:	10800417 	ldw	r2,16(r2)
   11b48:	1080030b 	ldhu	r2,12(r2)
   11b4c:	10bfffcc 	andi	r2,r2,65535
   11b50:	1004d23a 	srli	r2,r2,8
   11b54:	10ffffcc 	andi	r3,r2,65535
   11b58:	e0bff217 	ldw	r2,-56(fp)
   11b5c:	10800417 	ldw	r2,16(r2)
   11b60:	1080030b 	ldhu	r2,12(r2)
   11b64:	10bfffcc 	andi	r2,r2,65535
   11b68:	1004923a 	slli	r2,r2,8
   11b6c:	10bfffcc 	andi	r2,r2,65535
   11b70:	1884b03a 	or	r2,r3,r2
   11b74:	108000cc 	andi	r2,r2,3
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
   11b78:	1000d41e 	bne	r2,zero,11ecc <tcp_enqueue+0xb44>
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
    (!(flags & (TCP_SYN | TCP_FIN)) || (flags == TCP_FIN)) &&
   11b7c:	e0bffd03 	ldbu	r2,-12(fp)
   11b80:	108000cc 	andi	r2,r2,3

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
   11b84:	10000326 	beq	r2,zero,11b94 <tcp_enqueue+0x80c>
    (!(flags & (TCP_SYN | TCP_FIN)) || (flags == TCP_FIN)) &&
   11b88:	e0bffd03 	ldbu	r2,-12(fp)
   11b8c:	10800058 	cmpnei	r2,r2,1
   11b90:	1000ce1e 	bne	r2,zero,11ecc <tcp_enqueue+0xb44>
    /* fit within max seg size */
    (useg->len + queue->len <= pcb->mss) &&
   11b94:	e0bff217 	ldw	r2,-56(fp)
   11b98:	1080030b 	ldhu	r2,12(r2)
   11b9c:	10ffffcc 	andi	r3,r2,65535
   11ba0:	e0bff317 	ldw	r2,-52(fp)
   11ba4:	1080030b 	ldhu	r2,12(r2)
   11ba8:	10bfffcc 	andi	r2,r2,65535
   11bac:	1885883a 	add	r2,r3,r2
   11bb0:	e0fffa17 	ldw	r3,-24(fp)
   11bb4:	18c00f0b 	ldhu	r3,60(r3)
   11bb8:	18ffffcc 	andi	r3,r3,65535
  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
    (!(flags & (TCP_SYN | TCP_FIN)) || (flags == TCP_FIN)) &&
   11bbc:	1880c316 	blt	r3,r2,11ecc <tcp_enqueue+0xb44>
    /* fit within max seg size */
    (useg->len + queue->len <= pcb->mss) &&
    /* only concatenate segments with the same options */
    (useg->flags == queue->flags) &&
   11bc0:	e0bff217 	ldw	r2,-56(fp)
   11bc4:	10c00383 	ldbu	r3,14(r2)
   11bc8:	e0bff317 	ldw	r2,-52(fp)
   11bcc:	10800383 	ldbu	r2,14(r2)
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
    (!(flags & (TCP_SYN | TCP_FIN)) || (flags == TCP_FIN)) &&
    /* fit within max seg size */
    (useg->len + queue->len <= pcb->mss) &&
   11bd0:	18c03fcc 	andi	r3,r3,255
   11bd4:	10803fcc 	andi	r2,r2,255
   11bd8:	1880bc1e 	bne	r3,r2,11ecc <tcp_enqueue+0xb44>
    /* only concatenate segments with the same options */
    (useg->flags == queue->flags) &&
    /* segments are consecutive */
    (ntohl(useg->tcphdr->seqno) + useg->len == ntohl(queue->tcphdr->seqno)) ) {
   11bdc:	e0bff217 	ldw	r2,-56(fp)
   11be0:	10800417 	ldw	r2,16(r2)
   11be4:	10c0010b 	ldhu	r3,4(r2)
   11be8:	1080018b 	ldhu	r2,6(r2)
   11bec:	1004943a 	slli	r2,r2,16
   11bf0:	10c4b03a 	or	r2,r2,r3
   11bf4:	1006d63a 	srli	r3,r2,24
   11bf8:	e0bff217 	ldw	r2,-56(fp)
   11bfc:	10800417 	ldw	r2,16(r2)
   11c00:	1100010b 	ldhu	r4,4(r2)
   11c04:	1080018b 	ldhu	r2,6(r2)
   11c08:	1004943a 	slli	r2,r2,16
   11c0c:	1104b03a 	or	r2,r2,r4
   11c10:	1004d23a 	srli	r2,r2,8
   11c14:	10bfc00c 	andi	r2,r2,65280
   11c18:	1886b03a 	or	r3,r3,r2
   11c1c:	e0bff217 	ldw	r2,-56(fp)
   11c20:	10800417 	ldw	r2,16(r2)
   11c24:	1100010b 	ldhu	r4,4(r2)
   11c28:	1080018b 	ldhu	r2,6(r2)
   11c2c:	1004943a 	slli	r2,r2,16
   11c30:	1104b03a 	or	r2,r2,r4
   11c34:	10bfc00c 	andi	r2,r2,65280
   11c38:	1004923a 	slli	r2,r2,8
   11c3c:	1886b03a 	or	r3,r3,r2
   11c40:	e0bff217 	ldw	r2,-56(fp)
   11c44:	10800417 	ldw	r2,16(r2)
   11c48:	1100010b 	ldhu	r4,4(r2)
   11c4c:	1080018b 	ldhu	r2,6(r2)
   11c50:	1004943a 	slli	r2,r2,16
   11c54:	1104b03a 	or	r2,r2,r4
   11c58:	1004963a 	slli	r2,r2,24
   11c5c:	1886b03a 	or	r3,r3,r2
   11c60:	e0bff217 	ldw	r2,-56(fp)
   11c64:	1080030b 	ldhu	r2,12(r2)
   11c68:	10bfffcc 	andi	r2,r2,65535
   11c6c:	1887883a 	add	r3,r3,r2
   11c70:	e0bff317 	ldw	r2,-52(fp)
   11c74:	10800417 	ldw	r2,16(r2)
   11c78:	1100010b 	ldhu	r4,4(r2)
   11c7c:	1080018b 	ldhu	r2,6(r2)
   11c80:	1004943a 	slli	r2,r2,16
   11c84:	1104b03a 	or	r2,r2,r4
   11c88:	1008d63a 	srli	r4,r2,24
   11c8c:	e0bff317 	ldw	r2,-52(fp)
   11c90:	10800417 	ldw	r2,16(r2)
   11c94:	1140010b 	ldhu	r5,4(r2)
   11c98:	1080018b 	ldhu	r2,6(r2)
   11c9c:	1004943a 	slli	r2,r2,16
   11ca0:	1144b03a 	or	r2,r2,r5
   11ca4:	1004d23a 	srli	r2,r2,8
   11ca8:	10bfc00c 	andi	r2,r2,65280
   11cac:	2088b03a 	or	r4,r4,r2
   11cb0:	e0bff317 	ldw	r2,-52(fp)
   11cb4:	10800417 	ldw	r2,16(r2)
   11cb8:	1140010b 	ldhu	r5,4(r2)
   11cbc:	1080018b 	ldhu	r2,6(r2)
   11cc0:	1004943a 	slli	r2,r2,16
   11cc4:	1144b03a 	or	r2,r2,r5
   11cc8:	10bfc00c 	andi	r2,r2,65280
   11ccc:	1004923a 	slli	r2,r2,8
   11cd0:	2088b03a 	or	r4,r4,r2
   11cd4:	e0bff317 	ldw	r2,-52(fp)
   11cd8:	10800417 	ldw	r2,16(r2)
   11cdc:	1140010b 	ldhu	r5,4(r2)
   11ce0:	1080018b 	ldhu	r2,6(r2)
   11ce4:	1004943a 	slli	r2,r2,16
   11ce8:	1144b03a 	or	r2,r2,r5
   11cec:	1004963a 	slli	r2,r2,24
   11cf0:	2084b03a 	or	r2,r4,r2
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
    (!(flags & (TCP_SYN | TCP_FIN)) || (flags == TCP_FIN)) &&
    /* fit within max seg size */
    (useg->len + queue->len <= pcb->mss) &&
    /* only concatenate segments with the same options */
    (useg->flags == queue->flags) &&
   11cf4:	1880751e 	bne	r3,r2,11ecc <tcp_enqueue+0xb44>
    /* segments are consecutive */
    (ntohl(useg->tcphdr->seqno) + useg->len == ntohl(queue->tcphdr->seqno)) ) {
    /* Remove TCP header from first segment of our to-be-queued list */
    if(pbuf_header(queue->p, -(TCP_HLEN + optlen))) {
   11cf8:	e0bff317 	ldw	r2,-52(fp)
   11cfc:	10c00117 	ldw	r3,4(r2)
   11d00:	e0bff783 	ldbu	r2,-34(fp)
   11d04:	013ffb04 	movi	r4,-20
   11d08:	2085c83a 	sub	r2,r4,r2
   11d0c:	10bfffcc 	andi	r2,r2,65535
   11d10:	10a0001c 	xori	r2,r2,32768
   11d14:	10a00004 	addi	r2,r2,-32768
   11d18:	1809883a 	mov	r4,r3
   11d1c:	100b883a 	mov	r5,r2
   11d20:	0009f740 	call	9f74 <pbuf_header>
   11d24:	10803fcc 	andi	r2,r2,255
   11d28:	10000926 	beq	r2,zero,11d50 <tcp_enqueue+0x9c8>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
   11d2c:	010000f4 	movhi	r4,3
   11d30:	213acc04 	addi	r4,r4,-5328
   11d34:	014000f4 	movhi	r5,3
   11d38:	297b2e04 	addi	r5,r5,-4936
   11d3c:	018059c4 	movi	r6,359
   11d40:	01c000f4 	movhi	r7,3
   11d44:	39faeb04 	addi	r7,r7,-5204
   11d48:	00166c00 	call	166c0 <printf>
   11d4c:	003fff06 	br	11d4c <tcp_enqueue+0x9c4>
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    if (queue->p->len == 0) {
   11d50:	e0bff317 	ldw	r2,-52(fp)
   11d54:	10800117 	ldw	r2,4(r2)
   11d58:	1080028b 	ldhu	r2,10(r2)
   11d5c:	10bfffcc 	andi	r2,r2,65535
   11d60:	10000f1e 	bne	r2,zero,11da0 <tcp_enqueue+0xa18>
      /* free the first (header-only) pbuf if it is now empty (contained only headers) */
      struct pbuf *old_q = queue->p;
   11d64:	e0bff317 	ldw	r2,-52(fp)
   11d68:	10800117 	ldw	r2,4(r2)
   11d6c:	e0bff815 	stw	r2,-32(fp)
      queue->p = queue->p->next;
   11d70:	e0bff317 	ldw	r2,-52(fp)
   11d74:	10800117 	ldw	r2,4(r2)
   11d78:	10c00017 	ldw	r3,0(r2)
   11d7c:	e0bff317 	ldw	r2,-52(fp)
   11d80:	10c00115 	stw	r3,4(r2)
      old_q->next = NULL;
   11d84:	e0bff817 	ldw	r2,-32(fp)
   11d88:	10000015 	stw	zero,0(r2)
      queuelen--;
   11d8c:	e0bff70b 	ldhu	r2,-36(fp)
   11d90:	10bfffc4 	addi	r2,r2,-1
   11d94:	e0bff70d 	sth	r2,-36(fp)
      pbuf_free(old_q);
   11d98:	e13ff817 	ldw	r4,-32(fp)
   11d9c:	000a16c0 	call	a16c <pbuf_free>
    }
    if (flags & TCP_FIN) {
   11da0:	e0bffd03 	ldbu	r2,-12(fp)
   11da4:	1080004c 	andi	r2,r2,1
   11da8:	10001826 	beq	r2,zero,11e0c <tcp_enqueue+0xa84>
      /* the new segment contains only FIN, no data -> put the FIN into the last segment */
      LWIP_ASSERT("FIN enqueued together with data", queue->p == NULL && queue->len == 0);
   11dac:	e0bff317 	ldw	r2,-52(fp)
   11db0:	10800117 	ldw	r2,4(r2)
   11db4:	1000041e 	bne	r2,zero,11dc8 <tcp_enqueue+0xa40>
   11db8:	e0bff317 	ldw	r2,-52(fp)
   11dbc:	1080030b 	ldhu	r2,12(r2)
   11dc0:	10bfffcc 	andi	r2,r2,65535
   11dc4:	10000926 	beq	r2,zero,11dec <tcp_enqueue+0xa64>
   11dc8:	010000f4 	movhi	r4,3
   11dcc:	213acc04 	addi	r4,r4,-5328
   11dd0:	014000f4 	movhi	r5,3
   11dd4:	297b3304 	addi	r5,r5,-4916
   11dd8:	01805d44 	movi	r6,373
   11ddc:	01c000f4 	movhi	r7,3
   11de0:	39faeb04 	addi	r7,r7,-5204
   11de4:	00166c00 	call	166c0 <printf>
   11de8:	003fff06 	br	11de8 <tcp_enqueue+0xa60>
      TCPH_SET_FLAG(useg->tcphdr, TCP_FIN);
   11dec:	e0bff217 	ldw	r2,-56(fp)
   11df0:	10800417 	ldw	r2,16(r2)
   11df4:	e0fff217 	ldw	r3,-56(fp)
   11df8:	18c00417 	ldw	r3,16(r3)
   11dfc:	18c0030b 	ldhu	r3,12(r3)
   11e00:	18c04014 	ori	r3,r3,256
   11e04:	10c0030d 	sth	r3,12(r2)
   11e08:	00002406 	br	11e9c <tcp_enqueue+0xb14>
    } else {
      LWIP_ASSERT("zero-length pbuf", (queue->p != NULL) && (queue->p->len > 0));
   11e0c:	e0bff317 	ldw	r2,-52(fp)
   11e10:	10800117 	ldw	r2,4(r2)
   11e14:	10000526 	beq	r2,zero,11e2c <tcp_enqueue+0xaa4>
   11e18:	e0bff317 	ldw	r2,-52(fp)
   11e1c:	10800117 	ldw	r2,4(r2)
   11e20:	1080028b 	ldhu	r2,10(r2)
   11e24:	10bfffcc 	andi	r2,r2,65535
   11e28:	1000091e 	bne	r2,zero,11e50 <tcp_enqueue+0xac8>
   11e2c:	010000f4 	movhi	r4,3
   11e30:	213acc04 	addi	r4,r4,-5328
   11e34:	014000f4 	movhi	r5,3
   11e38:	297b3b04 	addi	r5,r5,-4884
   11e3c:	01805e04 	movi	r6,376
   11e40:	01c000f4 	movhi	r7,3
   11e44:	39faeb04 	addi	r7,r7,-5204
   11e48:	00166c00 	call	166c0 <printf>
   11e4c:	003fff06 	br	11e4c <tcp_enqueue+0xac4>
      pbuf_cat(useg->p, queue->p);
   11e50:	e0bff217 	ldw	r2,-56(fp)
   11e54:	10c00117 	ldw	r3,4(r2)
   11e58:	e0bff317 	ldw	r2,-52(fp)
   11e5c:	10800117 	ldw	r2,4(r2)
   11e60:	1809883a 	mov	r4,r3
   11e64:	100b883a 	mov	r5,r2
   11e68:	000a3c40 	call	a3c4 <pbuf_cat>
      useg->len += queue->len;
   11e6c:	e0bff217 	ldw	r2,-56(fp)
   11e70:	10c0030b 	ldhu	r3,12(r2)
   11e74:	e0bff317 	ldw	r2,-52(fp)
   11e78:	1080030b 	ldhu	r2,12(r2)
   11e7c:	1885883a 	add	r2,r3,r2
   11e80:	1007883a 	mov	r3,r2
   11e84:	e0bff217 	ldw	r2,-56(fp)
   11e88:	10c0030d 	sth	r3,12(r2)
      useg->next = queue->next;
   11e8c:	e0bff317 	ldw	r2,-52(fp)
   11e90:	10c00017 	ldw	r3,0(r2)
   11e94:	e0bff217 	ldw	r2,-56(fp)
   11e98:	10c00015 	stw	r3,0(r2)
    }

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("tcp_enqueue: chaining segments, new len %"U16_F"\n", useg->len));
    if (seg == queue) {
   11e9c:	e0fff117 	ldw	r3,-60(fp)
   11ea0:	e0bff317 	ldw	r2,-52(fp)
   11ea4:	1880051e 	bne	r3,r2,11ebc <tcp_enqueue+0xb34>
      seg = useg;
   11ea8:	e0bff217 	ldw	r2,-56(fp)
   11eac:	e0bff115 	stw	r2,-60(fp)
      seglen = useg->len;
   11eb0:	e0bff217 	ldw	r2,-56(fp)
   11eb4:	1080030b 	ldhu	r2,12(r2)
   11eb8:	e0bff58d 	sth	r2,-42(fp)
    }
    memp_free(MEMP_TCP_SEG, queue);
   11ebc:	01000104 	movi	r4,4
   11ec0:	e17ff317 	ldw	r5,-52(fp)
   11ec4:	00090cc0 	call	90cc <memp_free>
   11ec8:	00000906 	br	11ef0 <tcp_enqueue+0xb68>
  }
  else {
    /* empty list */
    if (useg == NULL) {
   11ecc:	e0bff217 	ldw	r2,-56(fp)
   11ed0:	1000041e 	bne	r2,zero,11ee4 <tcp_enqueue+0xb5c>
      /* initialize list with this segment */
      pcb->unsent = queue;
   11ed4:	e0bffa17 	ldw	r2,-24(fp)
   11ed8:	e0fff317 	ldw	r3,-52(fp)
   11edc:	10c01e15 	stw	r3,120(r2)
   11ee0:	00000306 	br	11ef0 <tcp_enqueue+0xb68>
    }
    /* enqueue segment */
    else {
      useg->next = queue;
   11ee4:	e0bff217 	ldw	r2,-56(fp)
   11ee8:	e0fff317 	ldw	r3,-52(fp)
   11eec:	10c00015 	stw	r3,0(r2)
    }
  }
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
   11ef0:	e0bffd03 	ldbu	r2,-12(fp)
   11ef4:	1080008c 	andi	r2,r2,2
   11ef8:	1000031e 	bne	r2,zero,11f08 <tcp_enqueue+0xb80>
   11efc:	e0bffd03 	ldbu	r2,-12(fp)
   11f00:	1080004c 	andi	r2,r2,1
   11f04:	10000326 	beq	r2,zero,11f14 <tcp_enqueue+0xb8c>
    ++len;
   11f08:	e0bffc0b 	ldhu	r2,-16(fp)
   11f0c:	10800044 	addi	r2,r2,1
   11f10:	e0bffc0d 	sth	r2,-16(fp)
  }
  if (flags & TCP_FIN) {
   11f14:	e0bffd03 	ldbu	r2,-12(fp)
   11f18:	1080004c 	andi	r2,r2,1
   11f1c:	10000626 	beq	r2,zero,11f38 <tcp_enqueue+0xbb0>
    pcb->flags |= TF_FIN;
   11f20:	e0bffa17 	ldw	r2,-24(fp)
   11f24:	10800983 	ldbu	r2,38(r2)
   11f28:	10800814 	ori	r2,r2,32
   11f2c:	1007883a 	mov	r3,r2
   11f30:	e0bffa17 	ldw	r2,-24(fp)
   11f34:	10c00985 	stb	r3,38(r2)
  }
  pcb->snd_lbb += len;
   11f38:	e0bffa17 	ldw	r2,-24(fp)
   11f3c:	10c01b17 	ldw	r3,108(r2)
   11f40:	e0bffc0b 	ldhu	r2,-16(fp)
   11f44:	1887883a 	add	r3,r3,r2
   11f48:	e0bffa17 	ldw	r2,-24(fp)
   11f4c:	10c01b15 	stw	r3,108(r2)

  pcb->snd_buf -= len;
   11f50:	e0bffa17 	ldw	r2,-24(fp)
   11f54:	10c01c8b 	ldhu	r3,114(r2)
   11f58:	e0bffc0b 	ldhu	r2,-16(fp)
   11f5c:	1885c83a 	sub	r2,r3,r2
   11f60:	1007883a 	mov	r3,r2
   11f64:	e0bffa17 	ldw	r2,-24(fp)
   11f68:	10c01c8d 	sth	r3,114(r2)

  /* update number of segments on the queues */
  pcb->snd_queuelen = queuelen;
   11f6c:	e0bffa17 	ldw	r2,-24(fp)
   11f70:	e0fff70b 	ldhu	r3,-36(fp)
   11f74:	10c01d0d 	sth	r3,116(r2)
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
   11f78:	e0bffa17 	ldw	r2,-24(fp)
   11f7c:	10801d0b 	ldhu	r2,116(r2)
   11f80:	10bfffcc 	andi	r2,r2,65535
   11f84:	10000f26 	beq	r2,zero,11fc4 <tcp_enqueue+0xc3c>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
   11f88:	e0bffa17 	ldw	r2,-24(fp)
   11f8c:	10801f17 	ldw	r2,124(r2)
   11f90:	10000c1e 	bne	r2,zero,11fc4 <tcp_enqueue+0xc3c>
   11f94:	e0bffa17 	ldw	r2,-24(fp)
   11f98:	10801e17 	ldw	r2,120(r2)
   11f9c:	1000091e 	bne	r2,zero,11fc4 <tcp_enqueue+0xc3c>
   11fa0:	010000f4 	movhi	r4,3
   11fa4:	213acc04 	addi	r4,r4,-5328
   11fa8:	014000f4 	movhi	r5,3
   11fac:	297b4004 	addi	r5,r5,-4864
   11fb0:	018067c4 	movi	r6,415
   11fb4:	01c000f4 	movhi	r7,3
   11fb8:	39faeb04 	addi	r7,r7,-5204
   11fbc:	00166c00 	call	166c0 <printf>
   11fc0:	003fff06 	br	11fc0 <tcp_enqueue+0xc38>
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued, but only
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
   11fc4:	e0bff117 	ldw	r2,-60(fp)
   11fc8:	10000f26 	beq	r2,zero,12008 <tcp_enqueue+0xc80>
   11fcc:	e0bff58b 	ldhu	r2,-42(fp)
   11fd0:	10000d26 	beq	r2,zero,12008 <tcp_enqueue+0xc80>
   11fd4:	e0bff117 	ldw	r2,-60(fp)
   11fd8:	10800417 	ldw	r2,16(r2)
   11fdc:	10000a26 	beq	r2,zero,12008 <tcp_enqueue+0xc80>
   11fe0:	e0bffe03 	ldbu	r2,-8(fp)
   11fe4:	1080008c 	andi	r2,r2,2
   11fe8:	1000071e 	bne	r2,zero,12008 <tcp_enqueue+0xc80>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
   11fec:	e0bff117 	ldw	r2,-60(fp)
   11ff0:	10800417 	ldw	r2,16(r2)
   11ff4:	e0fff117 	ldw	r3,-60(fp)
   11ff8:	18c00417 	ldw	r3,16(r3)
   11ffc:	18c0030b 	ldhu	r3,12(r3)
   12000:	18c20014 	ori	r3,r3,2048
   12004:	10c0030d 	sth	r3,12(r2)
  }

  return ERR_OK;
   12008:	0005883a 	mov	r2,zero
   1200c:	00002e06 	br	120c8 <tcp_enqueue+0xd40>
    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
    if (seg == NULL) {
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, 
                  ("tcp_enqueue: could not allocate memory for tcp_seg\n"));
      goto memerr;
   12010:	0001883a 	nop
   12014:	00000506 	br	1202c <tcp_enqueue+0xca4>
     * ROM or other static memory, and need not be copied.  */
    if (apiflags & TCP_WRITE_FLAG_COPY) {
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen + optlen, PBUF_RAM)) == NULL) {
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, 
                    ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
   12018:	0001883a 	nop
   1201c:	00000306 	br	1202c <tcp_enqueue+0xca4>
    else {
      /* First, allocate a pbuf for the headers. */
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, 
                    ("tcp_enqueue: could not allocate memory for header pbuf\n"));
        goto memerr;
   12020:	0001883a 	nop
   12024:	00000106 	br	1202c <tcp_enqueue+0xca4>
    /* Now that there are more segments queued, we check again if the
    length of the queue exceeds the configured maximum or overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
        ("tcp_enqueue: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      goto memerr;
   12028:	0001883a 	nop
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
   1202c:	e0bffa17 	ldw	r2,-24(fp)
   12030:	10c00983 	ldbu	r3,38(r2)
   12034:	00bfe004 	movi	r2,-128
   12038:	1884b03a 	or	r2,r3,r2
   1203c:	1007883a 	mov	r3,r2
   12040:	e0bffa17 	ldw	r2,-24(fp)
   12044:	10c00985 	stb	r3,38(r2)
  TCP_STATS_INC(tcp.memerr);
   12048:	00800134 	movhi	r2,4
   1204c:	108d9504 	addi	r2,r2,13908
   12050:	1080270b 	ldhu	r2,156(r2)
   12054:	10800044 	addi	r2,r2,1
   12058:	1007883a 	mov	r3,r2
   1205c:	00800134 	movhi	r2,4
   12060:	108d9504 	addi	r2,r2,13908
   12064:	10c0270d 	sth	r3,156(r2)

  if (queue != NULL) {
   12068:	e0bff317 	ldw	r2,-52(fp)
   1206c:	10000226 	beq	r2,zero,12078 <tcp_enqueue+0xcf0>
    tcp_segs_free(queue);
   12070:	e13ff317 	ldw	r4,-52(fp)
   12074:	000c9180 	call	c918 <tcp_segs_free>
  }
  if (pcb->snd_queuelen != 0) {
   12078:	e0bffa17 	ldw	r2,-24(fp)
   1207c:	10801d0b 	ldhu	r2,116(r2)
   12080:	10bfffcc 	andi	r2,r2,65535
   12084:	10000f26 	beq	r2,zero,120c4 <tcp_enqueue+0xd3c>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
   12088:	e0bffa17 	ldw	r2,-24(fp)
   1208c:	10801f17 	ldw	r2,124(r2)
   12090:	10000c1e 	bne	r2,zero,120c4 <tcp_enqueue+0xd3c>
   12094:	e0bffa17 	ldw	r2,-24(fp)
   12098:	10801e17 	ldw	r2,120(r2)
   1209c:	1000091e 	bne	r2,zero,120c4 <tcp_enqueue+0xd3c>
   120a0:	010000f4 	movhi	r4,3
   120a4:	213acc04 	addi	r4,r4,-5328
   120a8:	014000f4 	movhi	r5,3
   120ac:	297b4004 	addi	r5,r5,-4864
   120b0:	01806c84 	movi	r6,434
   120b4:	01c000f4 	movhi	r7,3
   120b8:	39faeb04 	addi	r7,r7,-5204
   120bc:	00166c00 	call	166c0 <printf>
   120c0:	003fff06 	br	120c0 <tcp_enqueue+0xd38>
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
   120c4:	00bfffc4 	movi	r2,-1
}
   120c8:	e037883a 	mov	sp,fp
   120cc:	dfc00117 	ldw	ra,4(sp)
   120d0:	df000017 	ldw	fp,0(sp)
   120d4:	dec00204 	addi	sp,sp,8
   120d8:	f800283a 	ret

000120dc <tcp_send_empty_ack>:
 *
 * @param pcb Protocol control block for the TCP connection to send the ACK
 */
err_t
tcp_send_empty_ack(struct tcp_pcb *pcb)
{
   120dc:	defff804 	addi	sp,sp,-32
   120e0:	dfc00715 	stw	ra,28(sp)
   120e4:	df000615 	stw	fp,24(sp)
   120e8:	df000604 	addi	fp,sp,24
   120ec:	e13fff15 	stw	r4,-4(fp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  u8_t optlen = 0;
   120f0:	e03ffc05 	stb	zero,-16(fp)
#if LWIP_TCP_TIMESTAMPS
  if (pcb->flags & TF_TIMESTAMP) {
    optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
  }
#endif
  p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen, PBUF_RAM);
   120f4:	e0bffc03 	ldbu	r2,-16(fp)
   120f8:	10800504 	addi	r2,r2,20
   120fc:	10bfffcc 	andi	r2,r2,65535
   12100:	01000044 	movi	r4,1
   12104:	100b883a 	mov	r5,r2
   12108:	000d883a 	mov	r6,zero
   1210c:	00097b00 	call	97b0 <pbuf_alloc>
   12110:	e0bffd15 	stw	r2,-12(fp)
  if (p == NULL) {
   12114:	e0bffd17 	ldw	r2,-12(fp)
   12118:	1000021e 	bne	r2,zero,12124 <tcp_send_empty_ack+0x48>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
    return ERR_BUF;
   1211c:	00bfff84 	movi	r2,-2
   12120:	00004006 	br	12224 <tcp_send_empty_ack+0x148>
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, 
              ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
  /* remove ACK flags from the PCB, as we send an empty ACK now */
  pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
   12124:	e0bfff17 	ldw	r2,-4(fp)
   12128:	10c00983 	ldbu	r3,38(r2)
   1212c:	00bfff04 	movi	r2,-4
   12130:	1884703a 	and	r2,r3,r2
   12134:	1007883a 	mov	r3,r2
   12138:	e0bfff17 	ldw	r2,-4(fp)
   1213c:	10c00985 	stb	r3,38(r2)

  tcphdr = tcp_output_set_header(pcb, p, optlen, htonl(pcb->snd_nxt));
   12140:	e0fffc03 	ldbu	r3,-16(fp)
   12144:	e0bfff17 	ldw	r2,-4(fp)
   12148:	10801717 	ldw	r2,92(r2)
   1214c:	1008d63a 	srli	r4,r2,24
   12150:	e0bfff17 	ldw	r2,-4(fp)
   12154:	10801717 	ldw	r2,92(r2)
   12158:	1004d23a 	srli	r2,r2,8
   1215c:	10bfc00c 	andi	r2,r2,65280
   12160:	2088b03a 	or	r4,r4,r2
   12164:	e0bfff17 	ldw	r2,-4(fp)
   12168:	10801717 	ldw	r2,92(r2)
   1216c:	10bfc00c 	andi	r2,r2,65280
   12170:	1004923a 	slli	r2,r2,8
   12174:	2088b03a 	or	r4,r4,r2
   12178:	e0bfff17 	ldw	r2,-4(fp)
   1217c:	10801717 	ldw	r2,92(r2)
   12180:	1004963a 	slli	r2,r2,24
   12184:	2084b03a 	or	r2,r4,r2
   12188:	e13fff17 	ldw	r4,-4(fp)
   1218c:	e17ffd17 	ldw	r5,-12(fp)
   12190:	180d883a 	mov	r6,r3
   12194:	100f883a 	mov	r7,r2
   12198:	0010ff40 	call	10ff4 <tcp_output_set_header>
   1219c:	e0bffe15 	stw	r2,-8(fp)
    tcp_build_timestamp_option(pcb, (u32_t *)(tcphdr + 1));
  }
#endif 

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
   121a0:	e0ffff17 	ldw	r3,-4(fp)
   121a4:	e0bfff17 	ldw	r2,-4(fp)
   121a8:	10800104 	addi	r2,r2,4
        IP_PROTO_TCP, p->tot_len);
   121ac:	e13ffd17 	ldw	r4,-12(fp)
   121b0:	2100020b 	ldhu	r4,8(r4)
    tcp_build_timestamp_option(pcb, (u32_t *)(tcphdr + 1));
  }
#endif 

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
   121b4:	213fffcc 	andi	r4,r4,65535
   121b8:	d9000015 	stw	r4,0(sp)
   121bc:	e13ffd17 	ldw	r4,-12(fp)
   121c0:	180b883a 	mov	r5,r3
   121c4:	100d883a 	mov	r6,r2
   121c8:	01c00184 	movi	r7,6
   121cc:	0005e240 	call	5e24 <inet_chksum_pseudo>
   121d0:	e0fffe17 	ldw	r3,-8(fp)
   121d4:	1880040d 	sth	r2,16(r3)
#endif
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
   121d8:	e17fff17 	ldw	r5,-4(fp)
   121dc:	e0bfff17 	ldw	r2,-4(fp)
   121e0:	10c00104 	addi	r3,r2,4
   121e4:	e0bfff17 	ldw	r2,-4(fp)
   121e8:	108002c3 	ldbu	r2,11(r2)
   121ec:	10803fcc 	andi	r2,r2,255
   121f0:	e13fff17 	ldw	r4,-4(fp)
   121f4:	21000283 	ldbu	r4,10(r4)
   121f8:	21003fcc 	andi	r4,r4,255
   121fc:	d9000015 	stw	r4,0(sp)
   12200:	01000184 	movi	r4,6
   12204:	d9000115 	stw	r4,4(sp)
   12208:	e13ffd17 	ldw	r4,-12(fp)
   1220c:	180d883a 	mov	r6,r3
   12210:	100f883a 	mov	r7,r2
   12214:	0006cfc0 	call	6cfc <ip_output>
      IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
  pbuf_free(p);
   12218:	e13ffd17 	ldw	r4,-12(fp)
   1221c:	000a16c0 	call	a16c <pbuf_free>

  return ERR_OK;
   12220:	0005883a 	mov	r2,zero
}
   12224:	e037883a 	mov	sp,fp
   12228:	dfc00117 	ldw	ra,4(sp)
   1222c:	df000017 	ldw	fp,0(sp)
   12230:	dec00204 	addi	sp,sp,8
   12234:	f800283a 	ret

00012238 <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
   12238:	defff804 	addi	sp,sp,-32
   1223c:	dfc00715 	stw	ra,28(sp)
   12240:	df000615 	stw	fp,24(sp)
   12244:	df000604 	addi	fp,sp,24
   12248:	e13fff15 	stw	r4,-4(fp)

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
   1224c:	008000f4 	movhi	r2,3
   12250:	10960304 	addi	r2,r2,22540
   12254:	10c00017 	ldw	r3,0(r2)
   12258:	e0bfff17 	ldw	r2,-4(fp)
   1225c:	1880021e 	bne	r3,r2,12268 <tcp_output+0x30>
    return ERR_OK;
   12260:	0005883a 	mov	r2,zero
   12264:	00021406 	br	12ab8 <tcp_output+0x880>
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
   12268:	e0bfff17 	ldw	r2,-4(fp)
   1226c:	1080158b 	ldhu	r2,86(r2)
   12270:	e0ffff17 	ldw	r3,-4(fp)
   12274:	18c0180b 	ldhu	r3,96(r3)
   12278:	113fffcc 	andi	r4,r2,65535
   1227c:	197fffcc 	andi	r5,r3,65535
   12280:	2900012e 	bgeu	r5,r4,12288 <tcp_output+0x50>
   12284:	1805883a 	mov	r2,r3
   12288:	10bfffcc 	andi	r2,r2,65535
   1228c:	e0bffd15 	stw	r2,-12(fp)

  seg = pcb->unsent;
   12290:	e0bfff17 	ldw	r2,-4(fp)
   12294:	10801e17 	ldw	r2,120(r2)
   12298:	e0bffa15 	stw	r2,-24(fp)
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
   1229c:	e0bfff17 	ldw	r2,-4(fp)
   122a0:	10800983 	ldbu	r2,38(r2)
   122a4:	10803fcc 	andi	r2,r2,255
   122a8:	1080008c 	andi	r2,r2,2
   122ac:	10002f26 	beq	r2,zero,1236c <tcp_output+0x134>
   122b0:	e0bffa17 	ldw	r2,-24(fp)
   122b4:	10002a26 	beq	r2,zero,12360 <tcp_output+0x128>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
   122b8:	e0bffa17 	ldw	r2,-24(fp)
   122bc:	10800417 	ldw	r2,16(r2)
   122c0:	10c0010b 	ldhu	r3,4(r2)
   122c4:	1080018b 	ldhu	r2,6(r2)
   122c8:	1004943a 	slli	r2,r2,16
   122cc:	10c4b03a 	or	r2,r2,r3
   122d0:	1006d63a 	srli	r3,r2,24
   122d4:	e0bffa17 	ldw	r2,-24(fp)
   122d8:	10800417 	ldw	r2,16(r2)
   122dc:	1100010b 	ldhu	r4,4(r2)
   122e0:	1080018b 	ldhu	r2,6(r2)
   122e4:	1004943a 	slli	r2,r2,16
   122e8:	1104b03a 	or	r2,r2,r4
   122ec:	1004d23a 	srli	r2,r2,8
   122f0:	10bfc00c 	andi	r2,r2,65280
   122f4:	1886b03a 	or	r3,r3,r2
   122f8:	e0bffa17 	ldw	r2,-24(fp)
   122fc:	10800417 	ldw	r2,16(r2)
   12300:	1100010b 	ldhu	r4,4(r2)
   12304:	1080018b 	ldhu	r2,6(r2)
   12308:	1004943a 	slli	r2,r2,16
   1230c:	1104b03a 	or	r2,r2,r4
   12310:	10bfc00c 	andi	r2,r2,65280
   12314:	1004923a 	slli	r2,r2,8
   12318:	1886b03a 	or	r3,r3,r2
   1231c:	e0bffa17 	ldw	r2,-24(fp)
   12320:	10800417 	ldw	r2,16(r2)
   12324:	1100010b 	ldhu	r4,4(r2)
   12328:	1080018b 	ldhu	r2,6(r2)
   1232c:	1004943a 	slli	r2,r2,16
   12330:	1104b03a 	or	r2,r2,r4
   12334:	1004963a 	slli	r2,r2,24
   12338:	1886b03a 	or	r3,r3,r2
   1233c:	e0bfff17 	ldw	r2,-4(fp)
   12340:	10801417 	ldw	r2,80(r2)
   12344:	1887c83a 	sub	r3,r3,r2
   12348:	e0bffa17 	ldw	r2,-24(fp)
   1234c:	1080030b 	ldhu	r2,12(r2)
   12350:	10bfffcc 	andi	r2,r2,65535
   12354:	1885883a 	add	r2,r3,r2
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
   12358:	e0fffd17 	ldw	r3,-12(fp)
   1235c:	1880032e 	bgeu	r3,r2,1236c <tcp_output+0x134>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
     return tcp_send_empty_ack(pcb);
   12360:	e13fff17 	ldw	r4,-4(fp)
   12364:	00120dc0 	call	120dc <tcp_send_empty_ack>
   12368:	0001d306 	br	12ab8 <tcp_output+0x880>
  }

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
   1236c:	e0bfff17 	ldw	r2,-4(fp)
   12370:	10801f17 	ldw	r2,124(r2)
   12374:	e0bffb15 	stw	r2,-20(fp)
  if (useg != NULL) {
   12378:	e0bffb17 	ldw	r2,-20(fp)
   1237c:	10016226 	beq	r2,zero,12908 <tcp_output+0x6d0>
    for (; useg->next != NULL; useg = useg->next);
   12380:	00000306 	br	12390 <tcp_output+0x158>
   12384:	e0bffb17 	ldw	r2,-20(fp)
   12388:	10800017 	ldw	r2,0(r2)
   1238c:	e0bffb15 	stw	r2,-20(fp)
   12390:	e0bffb17 	ldw	r2,-20(fp)
   12394:	10800017 	ldw	r2,0(r2)
   12398:	103ffa1e 	bne	r2,zero,12384 <tcp_output+0x14c>
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
   1239c:	00015a06 	br	12908 <tcp_output+0x6d0>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
   123a0:	e0bffa17 	ldw	r2,-24(fp)
   123a4:	10800417 	ldw	r2,16(r2)
   123a8:	1080030b 	ldhu	r2,12(r2)
   123ac:	10bfffcc 	andi	r2,r2,65535
   123b0:	1004d23a 	srli	r2,r2,8
   123b4:	10ffffcc 	andi	r3,r2,65535
   123b8:	e0bffa17 	ldw	r2,-24(fp)
   123bc:	10800417 	ldw	r2,16(r2)
   123c0:	1080030b 	ldhu	r2,12(r2)
   123c4:	10bfffcc 	andi	r2,r2,65535
   123c8:	1004923a 	slli	r2,r2,8
   123cc:	10bfffcc 	andi	r2,r2,65535
   123d0:	1884b03a 	or	r2,r3,r2
   123d4:	1080010c 	andi	r2,r2,4
   123d8:	10000926 	beq	r2,zero,12400 <tcp_output+0x1c8>
   123dc:	010000f4 	movhi	r4,3
   123e0:	213acc04 	addi	r4,r4,-5328
   123e4:	014000f4 	movhi	r5,3
   123e8:	297b4804 	addi	r5,r5,-4832
   123ec:	01809144 	movi	r6,581
   123f0:	01c000f4 	movhi	r7,3
   123f4:	39faeb04 	addi	r7,r7,-5204
   123f8:	00166c00 	call	166c0 <printf>
   123fc:	003fff06 	br	123fc <tcp_output+0x1c4>
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
   12400:	e0bfff17 	ldw	r2,-4(fp)
   12404:	10801f17 	ldw	r2,124(r2)
   12408:	10001426 	beq	r2,zero,1245c <tcp_output+0x224>
   1240c:	e0bfff17 	ldw	r2,-4(fp)
   12410:	10800983 	ldbu	r2,38(r2)
   12414:	10803fcc 	andi	r2,r2,255
   12418:	1080110c 	andi	r2,r2,68
   1241c:	10000f1e 	bne	r2,zero,1245c <tcp_output+0x224>
   12420:	e0bfff17 	ldw	r2,-4(fp)
   12424:	10801e17 	ldw	r2,120(r2)
   12428:	10000e26 	beq	r2,zero,12464 <tcp_output+0x22c>
   1242c:	e0bfff17 	ldw	r2,-4(fp)
   12430:	10801e17 	ldw	r2,120(r2)
   12434:	10800017 	ldw	r2,0(r2)
   12438:	1000081e 	bne	r2,zero,1245c <tcp_output+0x224>
   1243c:	e0bfff17 	ldw	r2,-4(fp)
   12440:	10801e17 	ldw	r2,120(r2)
   12444:	10c0030b 	ldhu	r3,12(r2)
   12448:	e0bfff17 	ldw	r2,-4(fp)
   1244c:	10800f0b 	ldhu	r2,60(r2)
   12450:	18ffffcc 	andi	r3,r3,65535
   12454:	10bfffcc 	andi	r2,r2,65535
   12458:	18800236 	bltu	r3,r2,12464 <tcp_output+0x22c>
   1245c:	00800044 	movi	r2,1
   12460:	00000106 	br	12468 <tcp_output+0x230>
   12464:	0005883a 	mov	r2,zero
   12468:	1000051e 	bne	r2,zero,12480 <tcp_output+0x248>
      ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
   1246c:	e0bfff17 	ldw	r2,-4(fp)
   12470:	10800983 	ldbu	r2,38(r2)
   12474:	10803fcc 	andi	r2,r2,255
   12478:	1080280c 	andi	r2,r2,160
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
   1247c:	10014f26 	beq	r2,zero,129bc <tcp_output+0x784>
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
   12480:	e0bffa17 	ldw	r2,-24(fp)
   12484:	10c00017 	ldw	r3,0(r2)
   12488:	e0bfff17 	ldw	r2,-4(fp)
   1248c:	10c01e15 	stw	r3,120(r2)

    if (pcb->state != SYN_SENT) {
   12490:	e0bfff17 	ldw	r2,-4(fp)
   12494:	10800417 	ldw	r2,16(r2)
   12498:	108000a0 	cmpeqi	r2,r2,2
   1249c:	10000e1e 	bne	r2,zero,124d8 <tcp_output+0x2a0>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
   124a0:	e0bffa17 	ldw	r2,-24(fp)
   124a4:	10800417 	ldw	r2,16(r2)
   124a8:	e0fffa17 	ldw	r3,-24(fp)
   124ac:	18c00417 	ldw	r3,16(r3)
   124b0:	18c0030b 	ldhu	r3,12(r3)
   124b4:	18c40014 	ori	r3,r3,4096
   124b8:	10c0030d 	sth	r3,12(r2)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
   124bc:	e0bfff17 	ldw	r2,-4(fp)
   124c0:	10c00983 	ldbu	r3,38(r2)
   124c4:	00bfff04 	movi	r2,-4
   124c8:	1884703a 	and	r2,r3,r2
   124cc:	1007883a 	mov	r3,r2
   124d0:	e0bfff17 	ldw	r2,-4(fp)
   124d4:	10c00985 	stb	r3,38(r2)
    }

    tcp_output_segment(seg, pcb);
   124d8:	e13ffa17 	ldw	r4,-24(fp)
   124dc:	e17fff17 	ldw	r5,-4(fp)
   124e0:	0012acc0 	call	12acc <tcp_output_segment>
    snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
   124e4:	e0bffa17 	ldw	r2,-24(fp)
   124e8:	10800417 	ldw	r2,16(r2)
   124ec:	10c0010b 	ldhu	r3,4(r2)
   124f0:	1080018b 	ldhu	r2,6(r2)
   124f4:	1004943a 	slli	r2,r2,16
   124f8:	10c4b03a 	or	r2,r2,r3
   124fc:	1006d63a 	srli	r3,r2,24
   12500:	e0bffa17 	ldw	r2,-24(fp)
   12504:	10800417 	ldw	r2,16(r2)
   12508:	1100010b 	ldhu	r4,4(r2)
   1250c:	1080018b 	ldhu	r2,6(r2)
   12510:	1004943a 	slli	r2,r2,16
   12514:	1104b03a 	or	r2,r2,r4
   12518:	1004d23a 	srli	r2,r2,8
   1251c:	10bfc00c 	andi	r2,r2,65280
   12520:	1886b03a 	or	r3,r3,r2
   12524:	e0bffa17 	ldw	r2,-24(fp)
   12528:	10800417 	ldw	r2,16(r2)
   1252c:	1100010b 	ldhu	r4,4(r2)
   12530:	1080018b 	ldhu	r2,6(r2)
   12534:	1004943a 	slli	r2,r2,16
   12538:	1104b03a 	or	r2,r2,r4
   1253c:	10bfc00c 	andi	r2,r2,65280
   12540:	1004923a 	slli	r2,r2,8
   12544:	1886b03a 	or	r3,r3,r2
   12548:	e0bffa17 	ldw	r2,-24(fp)
   1254c:	10800417 	ldw	r2,16(r2)
   12550:	1100010b 	ldhu	r4,4(r2)
   12554:	1080018b 	ldhu	r2,6(r2)
   12558:	1004943a 	slli	r2,r2,16
   1255c:	1104b03a 	or	r2,r2,r4
   12560:	1004963a 	slli	r2,r2,24
   12564:	1886b03a 	or	r3,r3,r2
   12568:	e0bffa17 	ldw	r2,-24(fp)
   1256c:	1080030b 	ldhu	r2,12(r2)
   12570:	113fffcc 	andi	r4,r2,65535
   12574:	e0bffa17 	ldw	r2,-24(fp)
   12578:	10800417 	ldw	r2,16(r2)
   1257c:	1080030b 	ldhu	r2,12(r2)
   12580:	10bfffcc 	andi	r2,r2,65535
   12584:	1004d23a 	srli	r2,r2,8
   12588:	117fffcc 	andi	r5,r2,65535
   1258c:	e0bffa17 	ldw	r2,-24(fp)
   12590:	10800417 	ldw	r2,16(r2)
   12594:	1080030b 	ldhu	r2,12(r2)
   12598:	10bfffcc 	andi	r2,r2,65535
   1259c:	1004923a 	slli	r2,r2,8
   125a0:	10bfffcc 	andi	r2,r2,65535
   125a4:	2884b03a 	or	r2,r5,r2
   125a8:	108000cc 	andi	r2,r2,3
   125ac:	1004c03a 	cmpne	r2,r2,zero
   125b0:	10803fcc 	andi	r2,r2,255
   125b4:	2085883a 	add	r2,r4,r2
   125b8:	1885883a 	add	r2,r3,r2
   125bc:	e0bffe15 	stw	r2,-8(fp)
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
   125c0:	e0bfff17 	ldw	r2,-4(fp)
   125c4:	10c01717 	ldw	r3,92(r2)
   125c8:	e0bffe17 	ldw	r2,-8(fp)
   125cc:	1885c83a 	sub	r2,r3,r2
   125d0:	1000030e 	bge	r2,zero,125e0 <tcp_output+0x3a8>
      pcb->snd_nxt = snd_nxt;
   125d4:	e0bfff17 	ldw	r2,-4(fp)
   125d8:	e0fffe17 	ldw	r3,-8(fp)
   125dc:	10c01715 	stw	r3,92(r2)
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
   125e0:	e0bffa17 	ldw	r2,-24(fp)
   125e4:	1080030b 	ldhu	r2,12(r2)
   125e8:	10ffffcc 	andi	r3,r2,65535
   125ec:	e0bffa17 	ldw	r2,-24(fp)
   125f0:	10800417 	ldw	r2,16(r2)
   125f4:	1080030b 	ldhu	r2,12(r2)
   125f8:	10bfffcc 	andi	r2,r2,65535
   125fc:	1004d23a 	srli	r2,r2,8
   12600:	113fffcc 	andi	r4,r2,65535
   12604:	e0bffa17 	ldw	r2,-24(fp)
   12608:	10800417 	ldw	r2,16(r2)
   1260c:	1080030b 	ldhu	r2,12(r2)
   12610:	10bfffcc 	andi	r2,r2,65535
   12614:	1004923a 	slli	r2,r2,8
   12618:	10bfffcc 	andi	r2,r2,65535
   1261c:	2084b03a 	or	r2,r4,r2
   12620:	108000cc 	andi	r2,r2,3
   12624:	1004c03a 	cmpne	r2,r2,zero
   12628:	10803fcc 	andi	r2,r2,255
   1262c:	1885883a 	add	r2,r3,r2
   12630:	0080b00e 	bge	zero,r2,128f4 <tcp_output+0x6bc>
      seg->next = NULL;
   12634:	e0bffa17 	ldw	r2,-24(fp)
   12638:	10000015 	stw	zero,0(r2)
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
   1263c:	e0bfff17 	ldw	r2,-4(fp)
   12640:	10801f17 	ldw	r2,124(r2)
   12644:	1000061e 	bne	r2,zero,12660 <tcp_output+0x428>
        pcb->unacked = seg;
   12648:	e0bfff17 	ldw	r2,-4(fp)
   1264c:	e0fffa17 	ldw	r3,-24(fp)
   12650:	10c01f15 	stw	r3,124(r2)
        useg = seg;
   12654:	e0bffa17 	ldw	r2,-24(fp)
   12658:	e0bffb15 	stw	r2,-20(fp)
   1265c:	0000a706 	br	128fc <tcp_output+0x6c4>
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
   12660:	e0bffa17 	ldw	r2,-24(fp)
   12664:	10800417 	ldw	r2,16(r2)
   12668:	10c0010b 	ldhu	r3,4(r2)
   1266c:	1080018b 	ldhu	r2,6(r2)
   12670:	1004943a 	slli	r2,r2,16
   12674:	10c4b03a 	or	r2,r2,r3
   12678:	1006d63a 	srli	r3,r2,24
   1267c:	e0bffa17 	ldw	r2,-24(fp)
   12680:	10800417 	ldw	r2,16(r2)
   12684:	1100010b 	ldhu	r4,4(r2)
   12688:	1080018b 	ldhu	r2,6(r2)
   1268c:	1004943a 	slli	r2,r2,16
   12690:	1104b03a 	or	r2,r2,r4
   12694:	1004d23a 	srli	r2,r2,8
   12698:	10bfc00c 	andi	r2,r2,65280
   1269c:	1886b03a 	or	r3,r3,r2
   126a0:	e0bffa17 	ldw	r2,-24(fp)
   126a4:	10800417 	ldw	r2,16(r2)
   126a8:	1100010b 	ldhu	r4,4(r2)
   126ac:	1080018b 	ldhu	r2,6(r2)
   126b0:	1004943a 	slli	r2,r2,16
   126b4:	1104b03a 	or	r2,r2,r4
   126b8:	10bfc00c 	andi	r2,r2,65280
   126bc:	1004923a 	slli	r2,r2,8
   126c0:	1886b03a 	or	r3,r3,r2
   126c4:	e0bffa17 	ldw	r2,-24(fp)
   126c8:	10800417 	ldw	r2,16(r2)
   126cc:	1100010b 	ldhu	r4,4(r2)
   126d0:	1080018b 	ldhu	r2,6(r2)
   126d4:	1004943a 	slli	r2,r2,16
   126d8:	1104b03a 	or	r2,r2,r4
   126dc:	1004963a 	slli	r2,r2,24
   126e0:	1886b03a 	or	r3,r3,r2
   126e4:	e0bffb17 	ldw	r2,-20(fp)
   126e8:	10800417 	ldw	r2,16(r2)
   126ec:	1100010b 	ldhu	r4,4(r2)
   126f0:	1080018b 	ldhu	r2,6(r2)
   126f4:	1004943a 	slli	r2,r2,16
   126f8:	1104b03a 	or	r2,r2,r4
   126fc:	1008d63a 	srli	r4,r2,24
   12700:	e0bffb17 	ldw	r2,-20(fp)
   12704:	10800417 	ldw	r2,16(r2)
   12708:	1140010b 	ldhu	r5,4(r2)
   1270c:	1080018b 	ldhu	r2,6(r2)
   12710:	1004943a 	slli	r2,r2,16
   12714:	1144b03a 	or	r2,r2,r5
   12718:	1004d23a 	srli	r2,r2,8
   1271c:	10bfc00c 	andi	r2,r2,65280
   12720:	2088b03a 	or	r4,r4,r2
   12724:	e0bffb17 	ldw	r2,-20(fp)
   12728:	10800417 	ldw	r2,16(r2)
   1272c:	1140010b 	ldhu	r5,4(r2)
   12730:	1080018b 	ldhu	r2,6(r2)
   12734:	1004943a 	slli	r2,r2,16
   12738:	1144b03a 	or	r2,r2,r5
   1273c:	10bfc00c 	andi	r2,r2,65280
   12740:	1004923a 	slli	r2,r2,8
   12744:	2088b03a 	or	r4,r4,r2
   12748:	e0bffb17 	ldw	r2,-20(fp)
   1274c:	10800417 	ldw	r2,16(r2)
   12750:	1140010b 	ldhu	r5,4(r2)
   12754:	1080018b 	ldhu	r2,6(r2)
   12758:	1004943a 	slli	r2,r2,16
   1275c:	1144b03a 	or	r2,r2,r5
   12760:	1004963a 	slli	r2,r2,24
   12764:	2084b03a 	or	r2,r4,r2
   12768:	1885c83a 	sub	r2,r3,r2
   1276c:	10005a0e 	bge	r2,zero,128d8 <tcp_output+0x6a0>
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
   12770:	e0bfff17 	ldw	r2,-4(fp)
   12774:	10801f04 	addi	r2,r2,124
   12778:	e0bffc15 	stw	r2,-16(fp)
          while (*cur_seg &&
   1277c:	00000306 	br	1278c <tcp_output+0x554>
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
              cur_seg = &((*cur_seg)->next );
   12780:	e0bffc17 	ldw	r2,-16(fp)
   12784:	10800017 	ldw	r2,0(r2)
   12788:	e0bffc15 	stw	r2,-16(fp)
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
          while (*cur_seg &&
   1278c:	e0bffc17 	ldw	r2,-16(fp)
   12790:	10800017 	ldw	r2,0(r2)
   12794:	10004826 	beq	r2,zero,128b8 <tcp_output+0x680>
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
   12798:	e0bffc17 	ldw	r2,-16(fp)
   1279c:	10800017 	ldw	r2,0(r2)
   127a0:	10800417 	ldw	r2,16(r2)
   127a4:	10c0010b 	ldhu	r3,4(r2)
   127a8:	1080018b 	ldhu	r2,6(r2)
   127ac:	1004943a 	slli	r2,r2,16
   127b0:	10c4b03a 	or	r2,r2,r3
   127b4:	1006d63a 	srli	r3,r2,24
   127b8:	e0bffc17 	ldw	r2,-16(fp)
   127bc:	10800017 	ldw	r2,0(r2)
   127c0:	10800417 	ldw	r2,16(r2)
   127c4:	1100010b 	ldhu	r4,4(r2)
   127c8:	1080018b 	ldhu	r2,6(r2)
   127cc:	1004943a 	slli	r2,r2,16
   127d0:	1104b03a 	or	r2,r2,r4
   127d4:	1004d23a 	srli	r2,r2,8
   127d8:	10bfc00c 	andi	r2,r2,65280
   127dc:	1886b03a 	or	r3,r3,r2
   127e0:	e0bffc17 	ldw	r2,-16(fp)
   127e4:	10800017 	ldw	r2,0(r2)
   127e8:	10800417 	ldw	r2,16(r2)
   127ec:	1100010b 	ldhu	r4,4(r2)
   127f0:	1080018b 	ldhu	r2,6(r2)
   127f4:	1004943a 	slli	r2,r2,16
   127f8:	1104b03a 	or	r2,r2,r4
   127fc:	10bfc00c 	andi	r2,r2,65280
   12800:	1004923a 	slli	r2,r2,8
   12804:	1886b03a 	or	r3,r3,r2
   12808:	e0bffc17 	ldw	r2,-16(fp)
   1280c:	10800017 	ldw	r2,0(r2)
   12810:	10800417 	ldw	r2,16(r2)
   12814:	1100010b 	ldhu	r4,4(r2)
   12818:	1080018b 	ldhu	r2,6(r2)
   1281c:	1004943a 	slli	r2,r2,16
   12820:	1104b03a 	or	r2,r2,r4
   12824:	1004963a 	slli	r2,r2,24
   12828:	1886b03a 	or	r3,r3,r2
   1282c:	e0bffa17 	ldw	r2,-24(fp)
   12830:	10800417 	ldw	r2,16(r2)
   12834:	1100010b 	ldhu	r4,4(r2)
   12838:	1080018b 	ldhu	r2,6(r2)
   1283c:	1004943a 	slli	r2,r2,16
   12840:	1104b03a 	or	r2,r2,r4
   12844:	1008d63a 	srli	r4,r2,24
   12848:	e0bffa17 	ldw	r2,-24(fp)
   1284c:	10800417 	ldw	r2,16(r2)
   12850:	1140010b 	ldhu	r5,4(r2)
   12854:	1080018b 	ldhu	r2,6(r2)
   12858:	1004943a 	slli	r2,r2,16
   1285c:	1144b03a 	or	r2,r2,r5
   12860:	1004d23a 	srli	r2,r2,8
   12864:	10bfc00c 	andi	r2,r2,65280
   12868:	2088b03a 	or	r4,r4,r2
   1286c:	e0bffa17 	ldw	r2,-24(fp)
   12870:	10800417 	ldw	r2,16(r2)
   12874:	1140010b 	ldhu	r5,4(r2)
   12878:	1080018b 	ldhu	r2,6(r2)
   1287c:	1004943a 	slli	r2,r2,16
   12880:	1144b03a 	or	r2,r2,r5
   12884:	10bfc00c 	andi	r2,r2,65280
   12888:	1004923a 	slli	r2,r2,8
   1288c:	2088b03a 	or	r4,r4,r2
   12890:	e0bffa17 	ldw	r2,-24(fp)
   12894:	10800417 	ldw	r2,16(r2)
   12898:	1140010b 	ldhu	r5,4(r2)
   1289c:	1080018b 	ldhu	r2,6(r2)
   128a0:	1004943a 	slli	r2,r2,16
   128a4:	1144b03a 	or	r2,r2,r5
   128a8:	1004963a 	slli	r2,r2,24
   128ac:	2084b03a 	or	r2,r4,r2
   128b0:	1885c83a 	sub	r2,r3,r2
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
          while (*cur_seg &&
   128b4:	103fb216 	blt	r2,zero,12780 <tcp_output+0x548>
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
              cur_seg = &((*cur_seg)->next );
          }
          seg->next = (*cur_seg);
   128b8:	e0bffc17 	ldw	r2,-16(fp)
   128bc:	10c00017 	ldw	r3,0(r2)
   128c0:	e0bffa17 	ldw	r2,-24(fp)
   128c4:	10c00015 	stw	r3,0(r2)
          (*cur_seg) = seg;
   128c8:	e0bffc17 	ldw	r2,-16(fp)
   128cc:	e0fffa17 	ldw	r3,-24(fp)
   128d0:	10c00015 	stw	r3,0(r2)
   128d4:	00000906 	br	128fc <tcp_output+0x6c4>
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
   128d8:	e0bffb17 	ldw	r2,-20(fp)
   128dc:	e0fffa17 	ldw	r3,-24(fp)
   128e0:	10c00015 	stw	r3,0(r2)
          useg = useg->next;
   128e4:	e0bffb17 	ldw	r2,-20(fp)
   128e8:	10800017 	ldw	r2,0(r2)
   128ec:	e0bffb15 	stw	r2,-20(fp)
   128f0:	00000206 	br	128fc <tcp_output+0x6c4>
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
   128f4:	e13ffa17 	ldw	r4,-24(fp)
   128f8:	000c97c0 	call	c97c <tcp_seg_free>
    }
    seg = pcb->unsent;
   128fc:	e0bfff17 	ldw	r2,-4(fp)
   12900:	10801e17 	ldw	r2,120(r2)
   12904:	e0bffa15 	stw	r2,-24(fp)
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
   12908:	e0bffa17 	ldw	r2,-24(fp)
   1290c:	10002c26 	beq	r2,zero,129c0 <tcp_output+0x788>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
   12910:	e0bffa17 	ldw	r2,-24(fp)
   12914:	10800417 	ldw	r2,16(r2)
   12918:	10c0010b 	ldhu	r3,4(r2)
   1291c:	1080018b 	ldhu	r2,6(r2)
   12920:	1004943a 	slli	r2,r2,16
   12924:	10c4b03a 	or	r2,r2,r3
   12928:	1006d63a 	srli	r3,r2,24
   1292c:	e0bffa17 	ldw	r2,-24(fp)
   12930:	10800417 	ldw	r2,16(r2)
   12934:	1100010b 	ldhu	r4,4(r2)
   12938:	1080018b 	ldhu	r2,6(r2)
   1293c:	1004943a 	slli	r2,r2,16
   12940:	1104b03a 	or	r2,r2,r4
   12944:	1004d23a 	srli	r2,r2,8
   12948:	10bfc00c 	andi	r2,r2,65280
   1294c:	1886b03a 	or	r3,r3,r2
   12950:	e0bffa17 	ldw	r2,-24(fp)
   12954:	10800417 	ldw	r2,16(r2)
   12958:	1100010b 	ldhu	r4,4(r2)
   1295c:	1080018b 	ldhu	r2,6(r2)
   12960:	1004943a 	slli	r2,r2,16
   12964:	1104b03a 	or	r2,r2,r4
   12968:	10bfc00c 	andi	r2,r2,65280
   1296c:	1004923a 	slli	r2,r2,8
   12970:	1886b03a 	or	r3,r3,r2
   12974:	e0bffa17 	ldw	r2,-24(fp)
   12978:	10800417 	ldw	r2,16(r2)
   1297c:	1100010b 	ldhu	r4,4(r2)
   12980:	1080018b 	ldhu	r2,6(r2)
   12984:	1004943a 	slli	r2,r2,16
   12988:	1104b03a 	or	r2,r2,r4
   1298c:	1004963a 	slli	r2,r2,24
   12990:	1886b03a 	or	r3,r3,r2
   12994:	e0bfff17 	ldw	r2,-4(fp)
   12998:	10801417 	ldw	r2,80(r2)
   1299c:	1887c83a 	sub	r3,r3,r2
   129a0:	e0bffa17 	ldw	r2,-24(fp)
   129a4:	1080030b 	ldhu	r2,12(r2)
   129a8:	10bfffcc 	andi	r2,r2,65535
   129ac:	1885883a 	add	r2,r3,r2
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
   129b0:	e0fffd17 	ldw	r3,-12(fp)
   129b4:	18be7a2e 	bgeu	r3,r2,123a0 <tcp_output+0x168>
   129b8:	00000106 	br	129c0 <tcp_output+0x788>
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
      ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
      break;
   129bc:	0001883a 	nop
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
   129c0:	e0bffa17 	ldw	r2,-24(fp)
   129c4:	10003526 	beq	r2,zero,12a9c <tcp_output+0x864>
   129c8:	e0bfff17 	ldw	r2,-4(fp)
   129cc:	10802903 	ldbu	r2,164(r2)
   129d0:	10803fcc 	andi	r2,r2,255
   129d4:	1000311e 	bne	r2,zero,12a9c <tcp_output+0x864>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
   129d8:	e0bffa17 	ldw	r2,-24(fp)
   129dc:	10800417 	ldw	r2,16(r2)
   129e0:	10c0010b 	ldhu	r3,4(r2)
   129e4:	1080018b 	ldhu	r2,6(r2)
   129e8:	1004943a 	slli	r2,r2,16
   129ec:	10c4b03a 	or	r2,r2,r3
   129f0:	1006d63a 	srli	r3,r2,24
   129f4:	e0bffa17 	ldw	r2,-24(fp)
   129f8:	10800417 	ldw	r2,16(r2)
   129fc:	1100010b 	ldhu	r4,4(r2)
   12a00:	1080018b 	ldhu	r2,6(r2)
   12a04:	1004943a 	slli	r2,r2,16
   12a08:	1104b03a 	or	r2,r2,r4
   12a0c:	1004d23a 	srli	r2,r2,8
   12a10:	10bfc00c 	andi	r2,r2,65280
   12a14:	1886b03a 	or	r3,r3,r2
   12a18:	e0bffa17 	ldw	r2,-24(fp)
   12a1c:	10800417 	ldw	r2,16(r2)
   12a20:	1100010b 	ldhu	r4,4(r2)
   12a24:	1080018b 	ldhu	r2,6(r2)
   12a28:	1004943a 	slli	r2,r2,16
   12a2c:	1104b03a 	or	r2,r2,r4
   12a30:	10bfc00c 	andi	r2,r2,65280
   12a34:	1004923a 	slli	r2,r2,8
   12a38:	1886b03a 	or	r3,r3,r2
   12a3c:	e0bffa17 	ldw	r2,-24(fp)
   12a40:	10800417 	ldw	r2,16(r2)
   12a44:	1100010b 	ldhu	r4,4(r2)
   12a48:	1080018b 	ldhu	r2,6(r2)
   12a4c:	1004943a 	slli	r2,r2,16
   12a50:	1104b03a 	or	r2,r2,r4
   12a54:	1004963a 	slli	r2,r2,24
   12a58:	1886b03a 	or	r3,r3,r2
   12a5c:	e0bfff17 	ldw	r2,-4(fp)
   12a60:	10801417 	ldw	r2,80(r2)
   12a64:	1887c83a 	sub	r3,r3,r2
   12a68:	e0bffa17 	ldw	r2,-24(fp)
   12a6c:	1080030b 	ldhu	r2,12(r2)
   12a70:	10bfffcc 	andi	r2,r2,65535
   12a74:	1885883a 	add	r2,r3,r2
   12a78:	e0ffff17 	ldw	r3,-4(fp)
   12a7c:	18c0180b 	ldhu	r3,96(r3)
   12a80:	18ffffcc 	andi	r3,r3,65535
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
   12a84:	1880052e 	bgeu	r3,r2,12a9c <tcp_output+0x864>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
    /* prepare for persist timer */
    pcb->persist_cnt = 0;
   12a88:	e0bfff17 	ldw	r2,-4(fp)
   12a8c:	10002815 	stw	zero,160(r2)
    pcb->persist_backoff = 1;
   12a90:	e0bfff17 	ldw	r2,-4(fp)
   12a94:	00c00044 	movi	r3,1
   12a98:	10c02905 	stb	r3,164(r2)
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
   12a9c:	e0bfff17 	ldw	r2,-4(fp)
   12aa0:	10800983 	ldbu	r2,38(r2)
   12aa4:	10801fcc 	andi	r2,r2,127
   12aa8:	1007883a 	mov	r3,r2
   12aac:	e0bfff17 	ldw	r2,-4(fp)
   12ab0:	10c00985 	stb	r3,38(r2)
  return ERR_OK;
   12ab4:	0005883a 	mov	r2,zero
}
   12ab8:	e037883a 	mov	sp,fp
   12abc:	dfc00117 	ldw	ra,4(sp)
   12ac0:	df000017 	ldw	fp,0(sp)
   12ac4:	dec00204 	addi	sp,sp,8
   12ac8:	f800283a 	ret

00012acc <tcp_output_segment>:
 * @param seg the tcp_seg to send
 * @param pcb the tcp_pcb for the TCP connection used to send the segment
 */
static void
tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb)
{
   12acc:	defff604 	addi	sp,sp,-40
   12ad0:	dfc00915 	stw	ra,36(sp)
   12ad4:	df000815 	stw	fp,32(sp)
   12ad8:	dc000715 	stw	r16,28(sp)
   12adc:	df000704 	addi	fp,sp,28
   12ae0:	e13ffe15 	stw	r4,-8(fp)
   12ae4:	e17fff15 	stw	r5,-4(fp)
  /** @bug Exclude retransmitted segments from this count. */
  snmp_inc_tcpoutsegs();

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
   12ae8:	e0bffe17 	ldw	r2,-8(fp)
   12aec:	10800417 	ldw	r2,16(r2)
   12af0:	e0ffff17 	ldw	r3,-4(fp)
   12af4:	18c00a17 	ldw	r3,40(r3)
   12af8:	1808d63a 	srli	r4,r3,24
   12afc:	e0ffff17 	ldw	r3,-4(fp)
   12b00:	18c00a17 	ldw	r3,40(r3)
   12b04:	1806d23a 	srli	r3,r3,8
   12b08:	18ffc00c 	andi	r3,r3,65280
   12b0c:	20c8b03a 	or	r4,r4,r3
   12b10:	e0ffff17 	ldw	r3,-4(fp)
   12b14:	18c00a17 	ldw	r3,40(r3)
   12b18:	18ffc00c 	andi	r3,r3,65280
   12b1c:	1806923a 	slli	r3,r3,8
   12b20:	20c8b03a 	or	r4,r4,r3
   12b24:	e0ffff17 	ldw	r3,-4(fp)
   12b28:	18c00a17 	ldw	r3,40(r3)
   12b2c:	1806963a 	slli	r3,r3,24
   12b30:	20c6b03a 	or	r3,r4,r3
   12b34:	193fffcc 	andi	r4,r3,65535
   12b38:	1140020b 	ldhu	r5,8(r2)
   12b3c:	280a703a 	and	r5,r5,zero
   12b40:	2908b03a 	or	r4,r5,r4
   12b44:	1100020d 	sth	r4,8(r2)
   12b48:	1806d43a 	srli	r3,r3,16
   12b4c:	1100028b 	ldhu	r4,10(r2)
   12b50:	2008703a 	and	r4,r4,zero
   12b54:	20c6b03a 	or	r3,r4,r3
   12b58:	10c0028d 	sth	r3,10(r2)

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
   12b5c:	e0bffe17 	ldw	r2,-8(fp)
   12b60:	10800417 	ldw	r2,16(r2)
   12b64:	e0ffff17 	ldw	r3,-4(fp)
   12b68:	18c00b8b 	ldhu	r3,46(r3)
   12b6c:	18ffffcc 	andi	r3,r3,65535
   12b70:	1806d23a 	srli	r3,r3,8
   12b74:	1809883a 	mov	r4,r3
   12b78:	e0ffff17 	ldw	r3,-4(fp)
   12b7c:	18c00b8b 	ldhu	r3,46(r3)
   12b80:	18ffffcc 	andi	r3,r3,65535
   12b84:	1806923a 	slli	r3,r3,8
   12b88:	20c6b03a 	or	r3,r4,r3
   12b8c:	10c0038d 	sth	r3,14(r2)

  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
   12b90:	e0bfff17 	ldw	r2,-4(fp)
   12b94:	10c00a17 	ldw	r3,40(r2)
   12b98:	e0bfff17 	ldw	r2,-4(fp)
   12b9c:	10800b8b 	ldhu	r2,46(r2)
   12ba0:	10bfffcc 	andi	r2,r2,65535
   12ba4:	1887883a 	add	r3,r3,r2
   12ba8:	e0bfff17 	ldw	r2,-4(fp)
   12bac:	10c00c15 	stw	r3,48(r2)

  /* Add any requested options.  NB MSS option is only set on SYN
     packets, so ignore it here */
  opts = (u32_t *)(seg->tcphdr + 1);
   12bb0:	e0bffe17 	ldw	r2,-8(fp)
   12bb4:	10800417 	ldw	r2,16(r2)
   12bb8:	10800504 	addi	r2,r2,20
   12bbc:	e0bffb15 	stw	r2,-20(fp)
  if (seg->flags & TF_SEG_OPTS_MSS) {
   12bc0:	e0bffe17 	ldw	r2,-8(fp)
   12bc4:	10800383 	ldbu	r2,14(r2)
   12bc8:	10803fcc 	andi	r2,r2,255
   12bcc:	1080004c 	andi	r2,r2,1
   12bd0:	10000726 	beq	r2,zero,12bf0 <tcp_output_segment+0x124>
    TCP_BUILD_MSS_OPTION(*opts);
   12bd4:	e0bffb17 	ldw	r2,-20(fp)
   12bd8:	00ed0174 	movhi	r3,46085
   12bdc:	18c10084 	addi	r3,r3,1026
   12be0:	10c00015 	stw	r3,0(r2)
    opts += 1;
   12be4:	e0bffb17 	ldw	r2,-20(fp)
   12be8:	10800104 	addi	r2,r2,4
   12bec:	e0bffb15 	stw	r2,-20(fp)
  }
#endif

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
   12bf0:	e0bfff17 	ldw	r2,-4(fp)
   12bf4:	10000326 	beq	r2,zero,12c04 <tcp_output_segment+0x138>
   12bf8:	e0bfff17 	ldw	r2,-4(fp)
   12bfc:	10800017 	ldw	r2,0(r2)
   12c00:	1000101e 	bne	r2,zero,12c44 <tcp_output_segment+0x178>
    netif = ip_route(&(pcb->remote_ip));
   12c04:	e0bfff17 	ldw	r2,-4(fp)
   12c08:	10800104 	addi	r2,r2,4
   12c0c:	1009883a 	mov	r4,r2
   12c10:	00061940 	call	6194 <ip_route>
   12c14:	e0bffc15 	stw	r2,-16(fp)
    if (netif == NULL) {
   12c18:	e0bffc17 	ldw	r2,-16(fp)
   12c1c:	10008826 	beq	r2,zero,12e40 <tcp_output_segment+0x374>
      return;
    }
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
   12c20:	e0bffc17 	ldw	r2,-16(fp)
   12c24:	10800104 	addi	r2,r2,4
   12c28:	10000326 	beq	r2,zero,12c38 <tcp_output_segment+0x16c>
   12c2c:	e0bffc17 	ldw	r2,-16(fp)
   12c30:	10800117 	ldw	r2,4(r2)
   12c34:	00000106 	br	12c3c <tcp_output_segment+0x170>
   12c38:	0005883a 	mov	r2,zero
   12c3c:	e0ffff17 	ldw	r3,-4(fp)
   12c40:	18800015 	stw	r2,0(r3)
  }

  /* Set retransmission timer running if it is not currently enabled */
  if(pcb->rtime == -1)
   12c44:	e0bfff17 	ldw	r2,-4(fp)
   12c48:	10800e8b 	ldhu	r2,58(r2)
   12c4c:	10bfffcc 	andi	r2,r2,65535
   12c50:	10a0001c 	xori	r2,r2,32768
   12c54:	10a00004 	addi	r2,r2,-32768
   12c58:	10bfffd8 	cmpnei	r2,r2,-1
   12c5c:	1000021e 	bne	r2,zero,12c68 <tcp_output_segment+0x19c>
    pcb->rtime = 0;
   12c60:	e0bfff17 	ldw	r2,-4(fp)
   12c64:	10000e8d 	sth	zero,58(r2)

  if (pcb->rttest == 0) {
   12c68:	e0bfff17 	ldw	r2,-4(fp)
   12c6c:	10801017 	ldw	r2,64(r2)
   12c70:	1000281e 	bne	r2,zero,12d14 <tcp_output_segment+0x248>
    pcb->rttest = tcp_ticks;
   12c74:	008000f4 	movhi	r2,3
   12c78:	1095f704 	addi	r2,r2,22492
   12c7c:	10c00017 	ldw	r3,0(r2)
   12c80:	e0bfff17 	ldw	r2,-4(fp)
   12c84:	10c01015 	stw	r3,64(r2)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
   12c88:	e0bffe17 	ldw	r2,-8(fp)
   12c8c:	10800417 	ldw	r2,16(r2)
   12c90:	10c0010b 	ldhu	r3,4(r2)
   12c94:	1080018b 	ldhu	r2,6(r2)
   12c98:	1004943a 	slli	r2,r2,16
   12c9c:	10c4b03a 	or	r2,r2,r3
   12ca0:	1006d63a 	srli	r3,r2,24
   12ca4:	e0bffe17 	ldw	r2,-8(fp)
   12ca8:	10800417 	ldw	r2,16(r2)
   12cac:	1100010b 	ldhu	r4,4(r2)
   12cb0:	1080018b 	ldhu	r2,6(r2)
   12cb4:	1004943a 	slli	r2,r2,16
   12cb8:	1104b03a 	or	r2,r2,r4
   12cbc:	1004d23a 	srli	r2,r2,8
   12cc0:	10bfc00c 	andi	r2,r2,65280
   12cc4:	1886b03a 	or	r3,r3,r2
   12cc8:	e0bffe17 	ldw	r2,-8(fp)
   12ccc:	10800417 	ldw	r2,16(r2)
   12cd0:	1100010b 	ldhu	r4,4(r2)
   12cd4:	1080018b 	ldhu	r2,6(r2)
   12cd8:	1004943a 	slli	r2,r2,16
   12cdc:	1104b03a 	or	r2,r2,r4
   12ce0:	10bfc00c 	andi	r2,r2,65280
   12ce4:	1004923a 	slli	r2,r2,8
   12ce8:	1886b03a 	or	r3,r3,r2
   12cec:	e0bffe17 	ldw	r2,-8(fp)
   12cf0:	10800417 	ldw	r2,16(r2)
   12cf4:	1100010b 	ldhu	r4,4(r2)
   12cf8:	1080018b 	ldhu	r2,6(r2)
   12cfc:	1004943a 	slli	r2,r2,16
   12d00:	1104b03a 	or	r2,r2,r4
   12d04:	1004963a 	slli	r2,r2,24
   12d08:	1886b03a 	or	r3,r3,r2
   12d0c:	e0bfff17 	ldw	r2,-4(fp)
   12d10:	10c01115 	stw	r3,68(r2)
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
   12d14:	e0bffe17 	ldw	r2,-8(fp)
   12d18:	10800417 	ldw	r2,16(r2)
   12d1c:	1007883a 	mov	r3,r2
   12d20:	e0bffe17 	ldw	r2,-8(fp)
   12d24:	10800117 	ldw	r2,4(r2)
   12d28:	10800117 	ldw	r2,4(r2)
   12d2c:	1885c83a 	sub	r2,r3,r2
   12d30:	e0bffd0d 	sth	r2,-12(fp)

  seg->p->len -= len;
   12d34:	e0bffe17 	ldw	r2,-8(fp)
   12d38:	10800117 	ldw	r2,4(r2)
   12d3c:	e0fffe17 	ldw	r3,-8(fp)
   12d40:	18c00117 	ldw	r3,4(r3)
   12d44:	1900028b 	ldhu	r4,10(r3)
   12d48:	e0fffd0b 	ldhu	r3,-12(fp)
   12d4c:	20c7c83a 	sub	r3,r4,r3
   12d50:	10c0028d 	sth	r3,10(r2)
  seg->p->tot_len -= len;
   12d54:	e0bffe17 	ldw	r2,-8(fp)
   12d58:	10800117 	ldw	r2,4(r2)
   12d5c:	e0fffe17 	ldw	r3,-8(fp)
   12d60:	18c00117 	ldw	r3,4(r3)
   12d64:	1900020b 	ldhu	r4,8(r3)
   12d68:	e0fffd0b 	ldhu	r3,-12(fp)
   12d6c:	20c7c83a 	sub	r3,r4,r3
   12d70:	10c0020d 	sth	r3,8(r2)

  seg->p->payload = seg->tcphdr;
   12d74:	e0bffe17 	ldw	r2,-8(fp)
   12d78:	10800117 	ldw	r2,4(r2)
   12d7c:	e0fffe17 	ldw	r3,-8(fp)
   12d80:	18c00417 	ldw	r3,16(r3)
   12d84:	10c00115 	stw	r3,4(r2)

  seg->tcphdr->chksum = 0;
   12d88:	e0bffe17 	ldw	r2,-8(fp)
   12d8c:	10800417 	ldw	r2,16(r2)
   12d90:	1000040d 	sth	zero,16(r2)
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
   12d94:	e0bffe17 	ldw	r2,-8(fp)
   12d98:	14000417 	ldw	r16,16(r2)
   12d9c:	e0bffe17 	ldw	r2,-8(fp)
   12da0:	11000117 	ldw	r4,4(r2)
   12da4:	e0ffff17 	ldw	r3,-4(fp)
   12da8:	e0bfff17 	ldw	r2,-4(fp)
   12dac:	10800104 	addi	r2,r2,4
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
   12db0:	e17ffe17 	ldw	r5,-8(fp)
   12db4:	29400117 	ldw	r5,4(r5)
   12db8:	2940020b 	ldhu	r5,8(r5)

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
   12dbc:	297fffcc 	andi	r5,r5,65535
   12dc0:	d9400015 	stw	r5,0(sp)
   12dc4:	180b883a 	mov	r5,r3
   12dc8:	100d883a 	mov	r6,r2
   12dcc:	01c00184 	movi	r7,6
   12dd0:	0005e240 	call	5e24 <inet_chksum_pseudo>
   12dd4:	8080040d 	sth	r2,16(r16)
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
   12dd8:	00800134 	movhi	r2,4
   12ddc:	108d9504 	addi	r2,r2,13908
   12de0:	1080240b 	ldhu	r2,144(r2)
   12de4:	10800044 	addi	r2,r2,1
   12de8:	1007883a 	mov	r3,r2
   12dec:	00800134 	movhi	r2,4
   12df0:	108d9504 	addi	r2,r2,13908
   12df4:	10c0240d 	sth	r3,144(r2)

#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
   12df8:	e0bffe17 	ldw	r2,-8(fp)
   12dfc:	11000117 	ldw	r4,4(r2)
   12e00:	e17fff17 	ldw	r5,-4(fp)
   12e04:	e0bfff17 	ldw	r2,-4(fp)
   12e08:	10c00104 	addi	r3,r2,4
   12e0c:	e0bfff17 	ldw	r2,-4(fp)
   12e10:	108002c3 	ldbu	r2,11(r2)
   12e14:	10803fcc 	andi	r2,r2,255
   12e18:	e1bfff17 	ldw	r6,-4(fp)
   12e1c:	31800283 	ldbu	r6,10(r6)
   12e20:	31803fcc 	andi	r6,r6,255
   12e24:	d9800015 	stw	r6,0(sp)
   12e28:	01800184 	movi	r6,6
   12e2c:	d9800115 	stw	r6,4(sp)
   12e30:	180d883a 	mov	r6,r3
   12e34:	100f883a 	mov	r7,r2
   12e38:	0006cfc0 	call	6cfc <ip_output>
   12e3c:	00000106 	br	12e44 <tcp_output_segment+0x378>
  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
    netif = ip_route(&(pcb->remote_ip));
    if (netif == NULL) {
      return;
   12e40:	0001883a 	nop
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
}
   12e44:	e037883a 	mov	sp,fp
   12e48:	dfc00217 	ldw	ra,8(sp)
   12e4c:	df000117 	ldw	fp,4(sp)
   12e50:	dc000017 	ldw	r16,0(sp)
   12e54:	dec00304 	addi	sp,sp,12
   12e58:	f800283a 	ret

00012e5c <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  struct ip_addr *local_ip, struct ip_addr *remote_ip,
  u16_t local_port, u16_t remote_port)
{
   12e5c:	defff404 	addi	sp,sp,-48
   12e60:	dfc00b15 	stw	ra,44(sp)
   12e64:	df000a15 	stw	fp,40(sp)
   12e68:	df000a04 	addi	fp,sp,40
   12e6c:	e13ffa15 	stw	r4,-24(fp)
   12e70:	e17ffb15 	stw	r5,-20(fp)
   12e74:	e1bffc15 	stw	r6,-16(fp)
   12e78:	e1fffd15 	stw	r7,-12(fp)
   12e7c:	e0c00217 	ldw	r3,8(fp)
   12e80:	e0800317 	ldw	r2,12(fp)
   12e84:	e0fffe0d 	sth	r3,-8(fp)
   12e88:	e0bfff0d 	sth	r2,-4(fp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
   12e8c:	01000044 	movi	r4,1
   12e90:	01400504 	movi	r5,20
   12e94:	000d883a 	mov	r6,zero
   12e98:	00097b00 	call	97b0 <pbuf_alloc>
   12e9c:	e0bff815 	stw	r2,-32(fp)
  if (p == NULL) {
   12ea0:	e0bff817 	ldw	r2,-32(fp)
   12ea4:	10009026 	beq	r2,zero,130e8 <tcp_rst+0x28c>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
   12ea8:	e0bff817 	ldw	r2,-32(fp)
   12eac:	1080028b 	ldhu	r2,10(r2)
   12eb0:	10bfffcc 	andi	r2,r2,65535
   12eb4:	10800528 	cmpgeui	r2,r2,20
   12eb8:	1000091e 	bne	r2,zero,12ee0 <tcp_rst+0x84>
   12ebc:	010000f4 	movhi	r4,3
   12ec0:	213acc04 	addi	r4,r4,-5328
   12ec4:	014000f4 	movhi	r5,3
   12ec8:	297b4e04 	addi	r5,r5,-4808
   12ecc:	0180c384 	movi	r6,782
   12ed0:	01c000f4 	movhi	r7,3
   12ed4:	39faeb04 	addi	r7,r7,-5204
   12ed8:	00166c00 	call	166c0 <printf>
   12edc:	003fff06 	br	12edc <tcp_rst+0x80>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
   12ee0:	e0bff817 	ldw	r2,-32(fp)
   12ee4:	10800117 	ldw	r2,4(r2)
   12ee8:	e0bff915 	stw	r2,-28(fp)
  tcphdr->src = htons(local_port);
   12eec:	e0bffe0b 	ldhu	r2,-8(fp)
   12ef0:	1004d23a 	srli	r2,r2,8
   12ef4:	1007883a 	mov	r3,r2
   12ef8:	e0bffe0b 	ldhu	r2,-8(fp)
   12efc:	1004923a 	slli	r2,r2,8
   12f00:	1884b03a 	or	r2,r3,r2
   12f04:	1007883a 	mov	r3,r2
   12f08:	e0bff917 	ldw	r2,-28(fp)
   12f0c:	10c0000d 	sth	r3,0(r2)
  tcphdr->dest = htons(remote_port);
   12f10:	e0bfff0b 	ldhu	r2,-4(fp)
   12f14:	1004d23a 	srli	r2,r2,8
   12f18:	1007883a 	mov	r3,r2
   12f1c:	e0bfff0b 	ldhu	r2,-4(fp)
   12f20:	1004923a 	slli	r2,r2,8
   12f24:	1884b03a 	or	r2,r3,r2
   12f28:	1007883a 	mov	r3,r2
   12f2c:	e0bff917 	ldw	r2,-28(fp)
   12f30:	10c0008d 	sth	r3,2(r2)
  tcphdr->seqno = htonl(seqno);
   12f34:	e0bffa17 	ldw	r2,-24(fp)
   12f38:	1006d63a 	srli	r3,r2,24
   12f3c:	e0bffa17 	ldw	r2,-24(fp)
   12f40:	1004d23a 	srli	r2,r2,8
   12f44:	10bfc00c 	andi	r2,r2,65280
   12f48:	1886b03a 	or	r3,r3,r2
   12f4c:	e0bffa17 	ldw	r2,-24(fp)
   12f50:	10bfc00c 	andi	r2,r2,65280
   12f54:	1004923a 	slli	r2,r2,8
   12f58:	1886b03a 	or	r3,r3,r2
   12f5c:	e0bffa17 	ldw	r2,-24(fp)
   12f60:	1004963a 	slli	r2,r2,24
   12f64:	1886b03a 	or	r3,r3,r2
   12f68:	e0bff917 	ldw	r2,-28(fp)
   12f6c:	193fffcc 	andi	r4,r3,65535
   12f70:	1140010b 	ldhu	r5,4(r2)
   12f74:	280a703a 	and	r5,r5,zero
   12f78:	2908b03a 	or	r4,r5,r4
   12f7c:	1100010d 	sth	r4,4(r2)
   12f80:	1806d43a 	srli	r3,r3,16
   12f84:	1100018b 	ldhu	r4,6(r2)
   12f88:	2008703a 	and	r4,r4,zero
   12f8c:	20c6b03a 	or	r3,r4,r3
   12f90:	10c0018d 	sth	r3,6(r2)
  tcphdr->ackno = htonl(ackno);
   12f94:	e0bffb17 	ldw	r2,-20(fp)
   12f98:	1006d63a 	srli	r3,r2,24
   12f9c:	e0bffb17 	ldw	r2,-20(fp)
   12fa0:	1004d23a 	srli	r2,r2,8
   12fa4:	10bfc00c 	andi	r2,r2,65280
   12fa8:	1886b03a 	or	r3,r3,r2
   12fac:	e0bffb17 	ldw	r2,-20(fp)
   12fb0:	10bfc00c 	andi	r2,r2,65280
   12fb4:	1004923a 	slli	r2,r2,8
   12fb8:	1886b03a 	or	r3,r3,r2
   12fbc:	e0bffb17 	ldw	r2,-20(fp)
   12fc0:	1004963a 	slli	r2,r2,24
   12fc4:	1886b03a 	or	r3,r3,r2
   12fc8:	e0bff917 	ldw	r2,-28(fp)
   12fcc:	193fffcc 	andi	r4,r3,65535
   12fd0:	1140020b 	ldhu	r5,8(r2)
   12fd4:	280a703a 	and	r5,r5,zero
   12fd8:	2908b03a 	or	r4,r5,r4
   12fdc:	1100020d 	sth	r4,8(r2)
   12fe0:	1806d43a 	srli	r3,r3,16
   12fe4:	1100028b 	ldhu	r4,10(r2)
   12fe8:	2008703a 	and	r4,r4,zero
   12fec:	20c6b03a 	or	r3,r4,r3
   12ff0:	10c0028d 	sth	r3,10(r2)
  TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
   12ff4:	e0bff917 	ldw	r2,-28(fp)
   12ff8:	10c0030b 	ldhu	r3,12(r2)
   12ffc:	00b03fc4 	movi	r2,-16129
   13000:	1884703a 	and	r2,r3,r2
   13004:	10850014 	ori	r2,r2,5120
   13008:	1007883a 	mov	r3,r2
   1300c:	e0bff917 	ldw	r2,-28(fp)
   13010:	10c0030d 	sth	r3,12(r2)
  tcphdr->wnd = htons(TCP_WND);
   13014:	e0bff917 	ldw	r2,-28(fp)
   13018:	00c00204 	movi	r3,8
   1301c:	10c0038d 	sth	r3,14(r2)
  tcphdr->urgp = 0;
   13020:	e0bff917 	ldw	r2,-28(fp)
   13024:	1000048d 	sth	zero,18(r2)
  TCPH_HDRLEN_SET(tcphdr, 5);
   13028:	e0bff917 	ldw	r2,-28(fp)
   1302c:	1080030b 	ldhu	r2,12(r2)
   13030:	10bfffcc 	andi	r2,r2,65535
   13034:	1004d23a 	srli	r2,r2,8
   13038:	1007883a 	mov	r3,r2
   1303c:	e0bff917 	ldw	r2,-28(fp)
   13040:	1080030b 	ldhu	r2,12(r2)
   13044:	10bfffcc 	andi	r2,r2,65535
   13048:	1004923a 	slli	r2,r2,8
   1304c:	1884b03a 	or	r2,r3,r2
   13050:	10800fcc 	andi	r2,r2,63
   13054:	1004923a 	slli	r2,r2,8
   13058:	10801414 	ori	r2,r2,80
   1305c:	1007883a 	mov	r3,r2
   13060:	e0bff917 	ldw	r2,-28(fp)
   13064:	10c0030d 	sth	r3,12(r2)

  tcphdr->chksum = 0;
   13068:	e0bff917 	ldw	r2,-28(fp)
   1306c:	1000040d 	sth	zero,16(r2)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
              IP_PROTO_TCP, p->tot_len);
   13070:	e0bff817 	ldw	r2,-32(fp)
   13074:	1080020b 	ldhu	r2,8(r2)
  tcphdr->urgp = 0;
  TCPH_HDRLEN_SET(tcphdr, 5);

  tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
   13078:	10bfffcc 	andi	r2,r2,65535
   1307c:	d8800015 	stw	r2,0(sp)
   13080:	e13ff817 	ldw	r4,-32(fp)
   13084:	e17ffc17 	ldw	r5,-16(fp)
   13088:	e1bffd17 	ldw	r6,-12(fp)
   1308c:	01c00184 	movi	r7,6
   13090:	0005e240 	call	5e24 <inet_chksum_pseudo>
   13094:	e0fff917 	ldw	r3,-28(fp)
   13098:	1880040d 	sth	r2,16(r3)
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
   1309c:	00800134 	movhi	r2,4
   130a0:	108d9504 	addi	r2,r2,13908
   130a4:	1080240b 	ldhu	r2,144(r2)
   130a8:	10800044 	addi	r2,r2,1
   130ac:	1007883a 	mov	r3,r2
   130b0:	00800134 	movhi	r2,4
   130b4:	108d9504 	addi	r2,r2,13908
   130b8:	10c0240d 	sth	r3,144(r2)
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
   130bc:	d8000015 	stw	zero,0(sp)
   130c0:	00800184 	movi	r2,6
   130c4:	d8800115 	stw	r2,4(sp)
   130c8:	e13ff817 	ldw	r4,-32(fp)
   130cc:	e17ffc17 	ldw	r5,-16(fp)
   130d0:	e1bffd17 	ldw	r6,-12(fp)
   130d4:	01c03fc4 	movi	r7,255
   130d8:	0006cfc0 	call	6cfc <ip_output>
  pbuf_free(p);
   130dc:	e13ff817 	ldw	r4,-32(fp)
   130e0:	000a16c0 	call	a16c <pbuf_free>
   130e4:	00000106 	br	130ec <tcp_rst+0x290>
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  if (p == NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
   130e8:	0001883a 	nop
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  pbuf_free(p);
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
   130ec:	e037883a 	mov	sp,fp
   130f0:	dfc00117 	ldw	ra,4(sp)
   130f4:	df000017 	ldw	fp,0(sp)
   130f8:	dec00204 	addi	sp,sp,8
   130fc:	f800283a 	ret

00013100 <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
   13100:	defffc04 	addi	sp,sp,-16
   13104:	dfc00315 	stw	ra,12(sp)
   13108:	df000215 	stw	fp,8(sp)
   1310c:	df000204 	addi	fp,sp,8
   13110:	e13fff15 	stw	r4,-4(fp)
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
   13114:	e0bfff17 	ldw	r2,-4(fp)
   13118:	10801f17 	ldw	r2,124(r2)
   1311c:	10001f26 	beq	r2,zero,1319c <tcp_rexmit_rto+0x9c>
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
   13120:	e0bfff17 	ldw	r2,-4(fp)
   13124:	10801f17 	ldw	r2,124(r2)
   13128:	e0bffe15 	stw	r2,-8(fp)
   1312c:	00000306 	br	1313c <tcp_rexmit_rto+0x3c>
   13130:	e0bffe17 	ldw	r2,-8(fp)
   13134:	10800017 	ldw	r2,0(r2)
   13138:	e0bffe15 	stw	r2,-8(fp)
   1313c:	e0bffe17 	ldw	r2,-8(fp)
   13140:	10800017 	ldw	r2,0(r2)
   13144:	103ffa1e 	bne	r2,zero,13130 <tcp_rexmit_rto+0x30>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
   13148:	e0bfff17 	ldw	r2,-4(fp)
   1314c:	10c01e17 	ldw	r3,120(r2)
   13150:	e0bffe17 	ldw	r2,-8(fp)
   13154:	10c00015 	stw	r3,0(r2)
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
   13158:	e0bfff17 	ldw	r2,-4(fp)
   1315c:	10c01f17 	ldw	r3,124(r2)
   13160:	e0bfff17 	ldw	r2,-4(fp)
   13164:	10c01e15 	stw	r3,120(r2)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
   13168:	e0bfff17 	ldw	r2,-4(fp)
   1316c:	10001f15 	stw	zero,124(r2)

  /* increment number of retransmissions */
  ++pcb->nrtx;
   13170:	e0bfff17 	ldw	r2,-4(fp)
   13174:	10801383 	ldbu	r2,78(r2)
   13178:	10800044 	addi	r2,r2,1
   1317c:	1007883a 	mov	r3,r2
   13180:	e0bfff17 	ldw	r2,-4(fp)
   13184:	10c01385 	stb	r3,78(r2)

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
   13188:	e0bfff17 	ldw	r2,-4(fp)
   1318c:	10001015 	stw	zero,64(r2)

  /* Do the actual retransmission */
  tcp_output(pcb);
   13190:	e13fff17 	ldw	r4,-4(fp)
   13194:	00122380 	call	12238 <tcp_output>
   13198:	00000106 	br	131a0 <tcp_rexmit_rto+0xa0>
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
    return;
   1319c:	0001883a 	nop
  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;

  /* Do the actual retransmission */
  tcp_output(pcb);
}
   131a0:	e037883a 	mov	sp,fp
   131a4:	dfc00117 	ldw	ra,4(sp)
   131a8:	df000017 	ldw	fp,0(sp)
   131ac:	dec00204 	addi	sp,sp,8
   131b0:	f800283a 	ret

000131b4 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
   131b4:	defffc04 	addi	sp,sp,-16
   131b8:	df000315 	stw	fp,12(sp)
   131bc:	df000304 	addi	fp,sp,12
   131c0:	e13fff15 	stw	r4,-4(fp)
  struct tcp_seg *seg;
  struct tcp_seg **cur_seg;

  if (pcb->unacked == NULL) {
   131c4:	e0bfff17 	ldw	r2,-4(fp)
   131c8:	10801f17 	ldw	r2,124(r2)
   131cc:	10006926 	beq	r2,zero,13374 <tcp_rexmit+0x1c0>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
   131d0:	e0bfff17 	ldw	r2,-4(fp)
   131d4:	10801f17 	ldw	r2,124(r2)
   131d8:	e0bffe15 	stw	r2,-8(fp)
  pcb->unacked = seg->next;
   131dc:	e0bffe17 	ldw	r2,-8(fp)
   131e0:	10c00017 	ldw	r3,0(r2)
   131e4:	e0bfff17 	ldw	r2,-4(fp)
   131e8:	10c01f15 	stw	r3,124(r2)

  cur_seg = &(pcb->unsent);
   131ec:	e0bfff17 	ldw	r2,-4(fp)
   131f0:	10801e04 	addi	r2,r2,120
   131f4:	e0bffd15 	stw	r2,-12(fp)
  while (*cur_seg &&
   131f8:	00000306 	br	13208 <tcp_rexmit+0x54>
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
      cur_seg = &((*cur_seg)->next );
   131fc:	e0bffd17 	ldw	r2,-12(fp)
   13200:	10800017 	ldw	r2,0(r2)
   13204:	e0bffd15 	stw	r2,-12(fp)
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;

  cur_seg = &(pcb->unsent);
  while (*cur_seg &&
   13208:	e0bffd17 	ldw	r2,-12(fp)
   1320c:	10800017 	ldw	r2,0(r2)
   13210:	10004826 	beq	r2,zero,13334 <tcp_rexmit+0x180>
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
   13214:	e0bffd17 	ldw	r2,-12(fp)
   13218:	10800017 	ldw	r2,0(r2)
   1321c:	10800417 	ldw	r2,16(r2)
   13220:	10c0010b 	ldhu	r3,4(r2)
   13224:	1080018b 	ldhu	r2,6(r2)
   13228:	1004943a 	slli	r2,r2,16
   1322c:	10c4b03a 	or	r2,r2,r3
   13230:	1006d63a 	srli	r3,r2,24
   13234:	e0bffd17 	ldw	r2,-12(fp)
   13238:	10800017 	ldw	r2,0(r2)
   1323c:	10800417 	ldw	r2,16(r2)
   13240:	1100010b 	ldhu	r4,4(r2)
   13244:	1080018b 	ldhu	r2,6(r2)
   13248:	1004943a 	slli	r2,r2,16
   1324c:	1104b03a 	or	r2,r2,r4
   13250:	1004d23a 	srli	r2,r2,8
   13254:	10bfc00c 	andi	r2,r2,65280
   13258:	1886b03a 	or	r3,r3,r2
   1325c:	e0bffd17 	ldw	r2,-12(fp)
   13260:	10800017 	ldw	r2,0(r2)
   13264:	10800417 	ldw	r2,16(r2)
   13268:	1100010b 	ldhu	r4,4(r2)
   1326c:	1080018b 	ldhu	r2,6(r2)
   13270:	1004943a 	slli	r2,r2,16
   13274:	1104b03a 	or	r2,r2,r4
   13278:	10bfc00c 	andi	r2,r2,65280
   1327c:	1004923a 	slli	r2,r2,8
   13280:	1886b03a 	or	r3,r3,r2
   13284:	e0bffd17 	ldw	r2,-12(fp)
   13288:	10800017 	ldw	r2,0(r2)
   1328c:	10800417 	ldw	r2,16(r2)
   13290:	1100010b 	ldhu	r4,4(r2)
   13294:	1080018b 	ldhu	r2,6(r2)
   13298:	1004943a 	slli	r2,r2,16
   1329c:	1104b03a 	or	r2,r2,r4
   132a0:	1004963a 	slli	r2,r2,24
   132a4:	1886b03a 	or	r3,r3,r2
   132a8:	e0bffe17 	ldw	r2,-8(fp)
   132ac:	10800417 	ldw	r2,16(r2)
   132b0:	1100010b 	ldhu	r4,4(r2)
   132b4:	1080018b 	ldhu	r2,6(r2)
   132b8:	1004943a 	slli	r2,r2,16
   132bc:	1104b03a 	or	r2,r2,r4
   132c0:	1008d63a 	srli	r4,r2,24
   132c4:	e0bffe17 	ldw	r2,-8(fp)
   132c8:	10800417 	ldw	r2,16(r2)
   132cc:	1140010b 	ldhu	r5,4(r2)
   132d0:	1080018b 	ldhu	r2,6(r2)
   132d4:	1004943a 	slli	r2,r2,16
   132d8:	1144b03a 	or	r2,r2,r5
   132dc:	1004d23a 	srli	r2,r2,8
   132e0:	10bfc00c 	andi	r2,r2,65280
   132e4:	2088b03a 	or	r4,r4,r2
   132e8:	e0bffe17 	ldw	r2,-8(fp)
   132ec:	10800417 	ldw	r2,16(r2)
   132f0:	1140010b 	ldhu	r5,4(r2)
   132f4:	1080018b 	ldhu	r2,6(r2)
   132f8:	1004943a 	slli	r2,r2,16
   132fc:	1144b03a 	or	r2,r2,r5
   13300:	10bfc00c 	andi	r2,r2,65280
   13304:	1004923a 	slli	r2,r2,8
   13308:	2088b03a 	or	r4,r4,r2
   1330c:	e0bffe17 	ldw	r2,-8(fp)
   13310:	10800417 	ldw	r2,16(r2)
   13314:	1140010b 	ldhu	r5,4(r2)
   13318:	1080018b 	ldhu	r2,6(r2)
   1331c:	1004943a 	slli	r2,r2,16
   13320:	1144b03a 	or	r2,r2,r5
   13324:	1004963a 	slli	r2,r2,24
   13328:	2084b03a 	or	r2,r4,r2
   1332c:	1885c83a 	sub	r2,r3,r2
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;

  cur_seg = &(pcb->unsent);
  while (*cur_seg &&
   13330:	103fb216 	blt	r2,zero,131fc <tcp_rexmit+0x48>
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
      cur_seg = &((*cur_seg)->next );
  }
  seg->next = *cur_seg;
   13334:	e0bffd17 	ldw	r2,-12(fp)
   13338:	10c00017 	ldw	r3,0(r2)
   1333c:	e0bffe17 	ldw	r2,-8(fp)
   13340:	10c00015 	stw	r3,0(r2)
  *cur_seg = seg;
   13344:	e0bffd17 	ldw	r2,-12(fp)
   13348:	e0fffe17 	ldw	r3,-8(fp)
   1334c:	10c00015 	stw	r3,0(r2)

  ++pcb->nrtx;
   13350:	e0bfff17 	ldw	r2,-4(fp)
   13354:	10801383 	ldbu	r2,78(r2)
   13358:	10800044 	addi	r2,r2,1
   1335c:	1007883a 	mov	r3,r2
   13360:	e0bfff17 	ldw	r2,-4(fp)
   13364:	10c01385 	stb	r3,78(r2)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
   13368:	e0bfff17 	ldw	r2,-4(fp)
   1336c:	10001015 	stw	zero,64(r2)
   13370:	00000106 	br	13378 <tcp_rexmit+0x1c4>
{
  struct tcp_seg *seg;
  struct tcp_seg **cur_seg;

  if (pcb->unacked == NULL) {
    return;
   13374:	0001883a 	nop

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  /* No need to call tcp_output: we are always called from tcp_input()
     and thus tcp_output directly returns. */
}
   13378:	e037883a 	mov	sp,fp
   1337c:	df000017 	ldw	fp,0(sp)
   13380:	dec00104 	addi	sp,sp,4
   13384:	f800283a 	ret

00013388 <tcp_rexmit_fast>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void 
tcp_rexmit_fast(struct tcp_pcb *pcb)
{
   13388:	defffd04 	addi	sp,sp,-12
   1338c:	dfc00215 	stw	ra,8(sp)
   13390:	df000115 	stw	fp,4(sp)
   13394:	df000104 	addi	fp,sp,4
   13398:	e13fff15 	stw	r4,-4(fp)
  if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
   1339c:	e0bfff17 	ldw	r2,-4(fp)
   133a0:	10801f17 	ldw	r2,124(r2)
   133a4:	10003c26 	beq	r2,zero,13498 <tcp_rexmit_fast+0x110>
   133a8:	e0bfff17 	ldw	r2,-4(fp)
   133ac:	10800983 	ldbu	r2,38(r2)
   133b0:	10803fcc 	andi	r2,r2,255
   133b4:	1080010c 	andi	r2,r2,4
   133b8:	1000371e 	bne	r2,zero,13498 <tcp_rexmit_fast+0x110>
    LWIP_DEBUGF(TCP_FR_DEBUG, 
                ("tcp_receive: dupacks %"U16_F" (%"U32_F
                 "), fast retransmit %"U32_F"\n",
                 (u16_t)pcb->dupacks, pcb->lastack,
                 ntohl(pcb->unacked->tcphdr->seqno)));
    tcp_rexmit(pcb);
   133bc:	e13fff17 	ldw	r4,-4(fp)
   133c0:	00131b40 	call	131b4 <tcp_rexmit>

    /* Set ssthresh to half of the minimum of the current
     * cwnd and the advertised window */
    if (pcb->cwnd > pcb->snd_wnd)
   133c4:	e0bfff17 	ldw	r2,-4(fp)
   133c8:	1080158b 	ldhu	r2,86(r2)
   133cc:	e0ffff17 	ldw	r3,-4(fp)
   133d0:	18c0180b 	ldhu	r3,96(r3)
   133d4:	10bfffcc 	andi	r2,r2,65535
   133d8:	18ffffcc 	andi	r3,r3,65535
   133dc:	1880082e 	bgeu	r3,r2,13400 <tcp_rexmit_fast+0x78>
      pcb->ssthresh = pcb->snd_wnd / 2;
   133e0:	e0bfff17 	ldw	r2,-4(fp)
   133e4:	1080180b 	ldhu	r2,96(r2)
   133e8:	10bfffcc 	andi	r2,r2,65535
   133ec:	1004d07a 	srli	r2,r2,1
   133f0:	1007883a 	mov	r3,r2
   133f4:	e0bfff17 	ldw	r2,-4(fp)
   133f8:	10c0160d 	sth	r3,88(r2)
   133fc:	00000706 	br	1341c <tcp_rexmit_fast+0x94>
    else
      pcb->ssthresh = pcb->cwnd / 2;
   13400:	e0bfff17 	ldw	r2,-4(fp)
   13404:	1080158b 	ldhu	r2,86(r2)
   13408:	10bfffcc 	andi	r2,r2,65535
   1340c:	1004d07a 	srli	r2,r2,1
   13410:	1007883a 	mov	r3,r2
   13414:	e0bfff17 	ldw	r2,-4(fp)
   13418:	10c0160d 	sth	r3,88(r2)
    
    /* The minimum value for ssthresh should be 2 MSS */
    if (pcb->ssthresh < 2*pcb->mss) {
   1341c:	e0bfff17 	ldw	r2,-4(fp)
   13420:	1080160b 	ldhu	r2,88(r2)
   13424:	10ffffcc 	andi	r3,r2,65535
   13428:	e0bfff17 	ldw	r2,-4(fp)
   1342c:	10800f0b 	ldhu	r2,60(r2)
   13430:	10bfffcc 	andi	r2,r2,65535
   13434:	1085883a 	add	r2,r2,r2
   13438:	1880060e 	bge	r3,r2,13454 <tcp_rexmit_fast+0xcc>
      LWIP_DEBUGF(TCP_FR_DEBUG, 
                  ("tcp_receive: The minimum value for ssthresh %"U16_F
                   " should be min 2 mss %"U16_F"...\n",
                   pcb->ssthresh, 2*pcb->mss));
      pcb->ssthresh = 2*pcb->mss;
   1343c:	e0bfff17 	ldw	r2,-4(fp)
   13440:	10800f0b 	ldhu	r2,60(r2)
   13444:	1085883a 	add	r2,r2,r2
   13448:	1007883a 	mov	r3,r2
   1344c:	e0bfff17 	ldw	r2,-4(fp)
   13450:	10c0160d 	sth	r3,88(r2)
    }
    
    pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
   13454:	e0bfff17 	ldw	r2,-4(fp)
   13458:	1100160b 	ldhu	r4,88(r2)
   1345c:	e0bfff17 	ldw	r2,-4(fp)
   13460:	10c00f0b 	ldhu	r3,60(r2)
   13464:	1805883a 	mov	r2,r3
   13468:	1085883a 	add	r2,r2,r2
   1346c:	10c5883a 	add	r2,r2,r3
   13470:	2085883a 	add	r2,r4,r2
   13474:	1007883a 	mov	r3,r2
   13478:	e0bfff17 	ldw	r2,-4(fp)
   1347c:	10c0158d 	sth	r3,86(r2)
    pcb->flags |= TF_INFR;
   13480:	e0bfff17 	ldw	r2,-4(fp)
   13484:	10800983 	ldbu	r2,38(r2)
   13488:	10800114 	ori	r2,r2,4
   1348c:	1007883a 	mov	r3,r2
   13490:	e0bfff17 	ldw	r2,-4(fp)
   13494:	10c00985 	stb	r3,38(r2)
  } 
}
   13498:	e037883a 	mov	sp,fp
   1349c:	dfc00117 	ldw	ra,4(sp)
   134a0:	df000017 	ldw	fp,0(sp)
   134a4:	dec00204 	addi	sp,sp,8
   134a8:	f800283a 	ret

000134ac <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
   134ac:	defff904 	addi	sp,sp,-28
   134b0:	dfc00615 	stw	ra,24(sp)
   134b4:	df000515 	stw	fp,20(sp)
   134b8:	df000504 	addi	fp,sp,20
   134bc:	e13fff15 	stw	r4,-4(fp)
                          ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
   134c0:	01000044 	movi	r4,1
   134c4:	01400504 	movi	r5,20
   134c8:	000d883a 	mov	r6,zero
   134cc:	00097b00 	call	97b0 <pbuf_alloc>
   134d0:	e0bffd15 	stw	r2,-12(fp)
   
  if(p == NULL) {
   134d4:	e0bffd17 	ldw	r2,-12(fp)
   134d8:	10004f26 	beq	r2,zero,13618 <tcp_keepalive+0x16c>
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
   134dc:	e0bffd17 	ldw	r2,-12(fp)
   134e0:	1080028b 	ldhu	r2,10(r2)
   134e4:	10bfffcc 	andi	r2,r2,65535
   134e8:	10800528 	cmpgeui	r2,r2,20
   134ec:	1000091e 	bne	r2,zero,13514 <tcp_keepalive+0x68>
   134f0:	010000f4 	movhi	r4,3
   134f4:	213acc04 	addi	r4,r4,-5328
   134f8:	014000f4 	movhi	r5,3
   134fc:	297b4e04 	addi	r5,r5,-4808
   13500:	0180ee04 	movi	r6,952
   13504:	01c000f4 	movhi	r7,3
   13508:	39faeb04 	addi	r7,r7,-5204
   1350c:	00166c00 	call	166c0 <printf>
   13510:	003fff06 	br	13510 <tcp_keepalive+0x64>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = tcp_output_set_header(pcb, p, 0, htonl(pcb->snd_nxt - 1));
   13514:	e0bfff17 	ldw	r2,-4(fp)
   13518:	10801717 	ldw	r2,92(r2)
   1351c:	10bfffc4 	addi	r2,r2,-1
   13520:	1006d63a 	srli	r3,r2,24
   13524:	e0bfff17 	ldw	r2,-4(fp)
   13528:	10801717 	ldw	r2,92(r2)
   1352c:	10bfffc4 	addi	r2,r2,-1
   13530:	1004d23a 	srli	r2,r2,8
   13534:	10bfc00c 	andi	r2,r2,65280
   13538:	1886b03a 	or	r3,r3,r2
   1353c:	e0bfff17 	ldw	r2,-4(fp)
   13540:	10801717 	ldw	r2,92(r2)
   13544:	10bfffc4 	addi	r2,r2,-1
   13548:	10bfc00c 	andi	r2,r2,65280
   1354c:	1004923a 	slli	r2,r2,8
   13550:	1886b03a 	or	r3,r3,r2
   13554:	e0bfff17 	ldw	r2,-4(fp)
   13558:	10801717 	ldw	r2,92(r2)
   1355c:	10bfffc4 	addi	r2,r2,-1
   13560:	1004963a 	slli	r2,r2,24
   13564:	1884b03a 	or	r2,r3,r2
   13568:	e13fff17 	ldw	r4,-4(fp)
   1356c:	e17ffd17 	ldw	r5,-12(fp)
   13570:	000d883a 	mov	r6,zero
   13574:	100f883a 	mov	r7,r2
   13578:	0010ff40 	call	10ff4 <tcp_output_set_header>
   1357c:	e0bffe15 	stw	r2,-8(fp)

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
   13580:	e0ffff17 	ldw	r3,-4(fp)
   13584:	e0bfff17 	ldw	r2,-4(fp)
   13588:	10800104 	addi	r2,r2,4
                                      IP_PROTO_TCP, p->tot_len);
   1358c:	e13ffd17 	ldw	r4,-12(fp)
   13590:	2100020b 	ldhu	r4,8(r4)
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = tcp_output_set_header(pcb, p, 0, htonl(pcb->snd_nxt - 1));

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
   13594:	213fffcc 	andi	r4,r4,65535
   13598:	d9000015 	stw	r4,0(sp)
   1359c:	e13ffd17 	ldw	r4,-12(fp)
   135a0:	180b883a 	mov	r5,r3
   135a4:	100d883a 	mov	r6,r2
   135a8:	01c00184 	movi	r7,6
   135ac:	0005e240 	call	5e24 <inet_chksum_pseudo>
   135b0:	e0fffe17 	ldw	r3,-8(fp)
   135b4:	1880040d 	sth	r2,16(r3)
                                      IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
   135b8:	00800134 	movhi	r2,4
   135bc:	108d9504 	addi	r2,r2,13908
   135c0:	1080240b 	ldhu	r2,144(r2)
   135c4:	10800044 	addi	r2,r2,1
   135c8:	1007883a 	mov	r3,r2
   135cc:	00800134 	movhi	r2,4
   135d0:	108d9504 	addi	r2,r2,13908
   135d4:	10c0240d 	sth	r3,144(r2)
  /* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
   135d8:	e17fff17 	ldw	r5,-4(fp)
   135dc:	e0bfff17 	ldw	r2,-4(fp)
   135e0:	10c00104 	addi	r3,r2,4
   135e4:	e0bfff17 	ldw	r2,-4(fp)
   135e8:	108002c3 	ldbu	r2,11(r2)
   135ec:	10803fcc 	andi	r2,r2,255
   135f0:	d8000015 	stw	zero,0(sp)
   135f4:	01000184 	movi	r4,6
   135f8:	d9000115 	stw	r4,4(sp)
   135fc:	e13ffd17 	ldw	r4,-12(fp)
   13600:	180d883a 	mov	r6,r3
   13604:	100f883a 	mov	r7,r2
   13608:	0006cfc0 	call	6cfc <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
   1360c:	e13ffd17 	ldw	r4,-12(fp)
   13610:	000a16c0 	call	a16c <pbuf_free>
   13614:	00000106 	br	1361c <tcp_keepalive+0x170>
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
   
  if(p == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
   13618:	0001883a 	nop

  pbuf_free(p);

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
   1361c:	e037883a 	mov	sp,fp
   13620:	dfc00117 	ldw	ra,4(sp)
   13624:	df000017 	ldw	fp,0(sp)
   13628:	dec00204 	addi	sp,sp,8
   1362c:	f800283a 	ret

00013630 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
   13630:	defff704 	addi	sp,sp,-36
   13634:	dfc00815 	stw	ra,32(sp)
   13638:	df000715 	stw	fp,28(sp)
   1363c:	df000704 	addi	fp,sp,28
   13640:	e13fff15 	stw	r4,-4(fp)
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
   13644:	e0bfff17 	ldw	r2,-4(fp)
   13648:	10801f17 	ldw	r2,124(r2)
   1364c:	e0bffb15 	stw	r2,-20(fp)

  if(seg == NULL)
   13650:	e0bffb17 	ldw	r2,-20(fp)
   13654:	1000031e 	bne	r2,zero,13664 <tcp_zero_window_probe+0x34>
    seg = pcb->unsent;
   13658:	e0bfff17 	ldw	r2,-4(fp)
   1365c:	10801e17 	ldw	r2,120(r2)
   13660:	e0bffb15 	stw	r2,-20(fp)

  if(seg == NULL)
   13664:	e0bffb17 	ldw	r2,-20(fp)
   13668:	10007726 	beq	r2,zero,13848 <tcp_zero_window_probe+0x218>
    return;

  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
   1366c:	e0bffb17 	ldw	r2,-20(fp)
   13670:	10800417 	ldw	r2,16(r2)
   13674:	1080030b 	ldhu	r2,12(r2)
   13678:	10bfffcc 	andi	r2,r2,65535
   1367c:	1004d23a 	srli	r2,r2,8
   13680:	10ffffcc 	andi	r3,r2,65535
   13684:	e0bffb17 	ldw	r2,-20(fp)
   13688:	10800417 	ldw	r2,16(r2)
   1368c:	1080030b 	ldhu	r2,12(r2)
   13690:	10bfffcc 	andi	r2,r2,65535
   13694:	1004923a 	slli	r2,r2,8
   13698:	10bfffcc 	andi	r2,r2,65535
   1369c:	1884b03a 	or	r2,r3,r2
   136a0:	1080004c 	andi	r2,r2,1
   136a4:	10000626 	beq	r2,zero,136c0 <tcp_zero_window_probe+0x90>
   136a8:	e0bffb17 	ldw	r2,-20(fp)
   136ac:	1080030b 	ldhu	r2,12(r2)
   136b0:	10bfffcc 	andi	r2,r2,65535
   136b4:	1000021e 	bne	r2,zero,136c0 <tcp_zero_window_probe+0x90>
   136b8:	00800044 	movi	r2,1
   136bc:	00000106 	br	136c4 <tcp_zero_window_probe+0x94>
   136c0:	0005883a 	mov	r2,zero
   136c4:	e0bffc05 	stb	r2,-16(fp)
  len = is_fin ? TCP_HLEN : TCP_HLEN + 1;
   136c8:	e0bffc03 	ldbu	r2,-16(fp)
   136cc:	10000226 	beq	r2,zero,136d8 <tcp_zero_window_probe+0xa8>
   136d0:	00800504 	movi	r2,20
   136d4:	00000106 	br	136dc <tcp_zero_window_probe+0xac>
   136d8:	00800544 	movi	r2,21
   136dc:	e0bffc8d 	sth	r2,-14(fp)

  p = pbuf_alloc(PBUF_IP, len, PBUF_RAM);
   136e0:	e0bffc8b 	ldhu	r2,-14(fp)
   136e4:	01000044 	movi	r4,1
   136e8:	100b883a 	mov	r5,r2
   136ec:	000d883a 	mov	r6,zero
   136f0:	00097b00 	call	97b0 <pbuf_alloc>
   136f4:	e0bffd15 	stw	r2,-12(fp)
  if(p == NULL) {
   136f8:	e0bffd17 	ldw	r2,-12(fp)
   136fc:	10005426 	beq	r2,zero,13850 <tcp_zero_window_probe+0x220>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
   13700:	e0bffd17 	ldw	r2,-12(fp)
   13704:	1080028b 	ldhu	r2,10(r2)
   13708:	10bfffcc 	andi	r2,r2,65535
   1370c:	10800528 	cmpgeui	r2,r2,20
   13710:	1000091e 	bne	r2,zero,13738 <tcp_zero_window_probe+0x108>
   13714:	010000f4 	movhi	r4,3
   13718:	213acc04 	addi	r4,r4,-5328
   1371c:	014000f4 	movhi	r5,3
   13720:	297b4e04 	addi	r5,r5,-4808
   13724:	0180ff84 	movi	r6,1022
   13728:	01c000f4 	movhi	r7,3
   1372c:	39faeb04 	addi	r7,r7,-5204
   13730:	00166c00 	call	166c0 <printf>
   13734:	003fff06 	br	13734 <tcp_zero_window_probe+0x104>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = tcp_output_set_header(pcb, p, 0, seg->tcphdr->seqno);
   13738:	e0bffb17 	ldw	r2,-20(fp)
   1373c:	10800417 	ldw	r2,16(r2)
   13740:	10c0010b 	ldhu	r3,4(r2)
   13744:	1080018b 	ldhu	r2,6(r2)
   13748:	1004943a 	slli	r2,r2,16
   1374c:	10c4b03a 	or	r2,r2,r3
   13750:	e13fff17 	ldw	r4,-4(fp)
   13754:	e17ffd17 	ldw	r5,-12(fp)
   13758:	000d883a 	mov	r6,zero
   1375c:	100f883a 	mov	r7,r2
   13760:	0010ff40 	call	10ff4 <tcp_output_set_header>
   13764:	e0bffe15 	stw	r2,-8(fp)

  if (is_fin) {
   13768:	e0bffc03 	ldbu	r2,-16(fp)
   1376c:	10000926 	beq	r2,zero,13794 <tcp_zero_window_probe+0x164>
    /* FIN segment, no data */
    TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
   13770:	e0bffe17 	ldw	r2,-8(fp)
   13774:	10c0030b 	ldhu	r3,12(r2)
   13778:	00b03fc4 	movi	r2,-16129
   1377c:	1884703a 	and	r2,r3,r2
   13780:	10844014 	ori	r2,r2,4352
   13784:	1007883a 	mov	r3,r2
   13788:	e0bffe17 	ldw	r2,-8(fp)
   1378c:	10c0030d 	sth	r3,12(r2)
   13790:	00000706 	br	137b0 <tcp_zero_window_probe+0x180>
  } else {
    /* Data segment, copy in one byte from the head of the unacked queue */
    *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;
   13794:	e0bffd17 	ldw	r2,-12(fp)
   13798:	10800117 	ldw	r2,4(r2)
   1379c:	10800504 	addi	r2,r2,20
   137a0:	e0fffb17 	ldw	r3,-20(fp)
   137a4:	18c00217 	ldw	r3,8(r3)
   137a8:	18c00003 	ldbu	r3,0(r3)
   137ac:	10c00005 	stb	r3,0(r2)
  }

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
   137b0:	e0ffff17 	ldw	r3,-4(fp)
   137b4:	e0bfff17 	ldw	r2,-4(fp)
   137b8:	10800104 	addi	r2,r2,4
                                      IP_PROTO_TCP, p->tot_len);
   137bc:	e13ffd17 	ldw	r4,-12(fp)
   137c0:	2100020b 	ldhu	r4,8(r4)
    /* Data segment, copy in one byte from the head of the unacked queue */
    *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;
  }

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
   137c4:	213fffcc 	andi	r4,r4,65535
   137c8:	d9000015 	stw	r4,0(sp)
   137cc:	e13ffd17 	ldw	r4,-12(fp)
   137d0:	180b883a 	mov	r5,r3
   137d4:	100d883a 	mov	r6,r2
   137d8:	01c00184 	movi	r7,6
   137dc:	0005e240 	call	5e24 <inet_chksum_pseudo>
   137e0:	e0fffe17 	ldw	r3,-8(fp)
   137e4:	1880040d 	sth	r2,16(r3)
                                      IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
   137e8:	00800134 	movhi	r2,4
   137ec:	108d9504 	addi	r2,r2,13908
   137f0:	1080240b 	ldhu	r2,144(r2)
   137f4:	10800044 	addi	r2,r2,1
   137f8:	1007883a 	mov	r3,r2
   137fc:	00800134 	movhi	r2,4
   13800:	108d9504 	addi	r2,r2,13908
   13804:	10c0240d 	sth	r3,144(r2)
  /* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
   13808:	e17fff17 	ldw	r5,-4(fp)
   1380c:	e0bfff17 	ldw	r2,-4(fp)
   13810:	10c00104 	addi	r3,r2,4
   13814:	e0bfff17 	ldw	r2,-4(fp)
   13818:	108002c3 	ldbu	r2,11(r2)
   1381c:	10803fcc 	andi	r2,r2,255
   13820:	d8000015 	stw	zero,0(sp)
   13824:	01000184 	movi	r4,6
   13828:	d9000115 	stw	r4,4(sp)
   1382c:	e13ffd17 	ldw	r4,-12(fp)
   13830:	180d883a 	mov	r6,r3
   13834:	100f883a 	mov	r7,r2
   13838:	0006cfc0 	call	6cfc <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
   1383c:	e13ffd17 	ldw	r4,-12(fp)
   13840:	000a16c0 	call	a16c <pbuf_free>
   13844:	00000306 	br	13854 <tcp_zero_window_probe+0x224>

  if(seg == NULL)
    seg = pcb->unsent;

  if(seg == NULL)
    return;
   13848:	0001883a 	nop
   1384c:	00000106 	br	13854 <tcp_zero_window_probe+0x224>
  len = is_fin ? TCP_HLEN : TCP_HLEN + 1;

  p = pbuf_alloc(PBUF_IP, len, PBUF_RAM);
  if(p == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
   13850:	0001883a 	nop
  pbuf_free(p);

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
   13854:	e037883a 	mov	sp,fp
   13858:	dfc00117 	ldw	ra,4(sp)
   1385c:	df000017 	ldw	fp,0(sp)
   13860:	dec00204 	addi	sp,sp,8
   13864:	f800283a 	ret

00013868 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
   13868:	defff304 	addi	sp,sp,-52
   1386c:	dfc00c15 	stw	ra,48(sp)
   13870:	df000b15 	stw	fp,44(sp)
   13874:	df000b04 	addi	fp,sp,44
   13878:	e13ffe15 	stw	r4,-8(fp)
   1387c:	e17fff15 	stw	r5,-4(fp)
  u8_t local_match;
  u8_t broadcast;

  PERF_START;

  UDP_STATS_INC(udp.recv);
   13880:	00800134 	movhi	r2,4
   13884:	108d9504 	addi	r2,r2,13908
   13888:	10801e8b 	ldhu	r2,122(r2)
   1388c:	10800044 	addi	r2,r2,1
   13890:	1007883a 	mov	r3,r2
   13894:	00800134 	movhi	r2,4
   13898:	108d9504 	addi	r2,r2,13908
   1389c:	10c01e8d 	sth	r3,122(r2)

  iphdr = p->payload;
   138a0:	e0bffe17 	ldw	r2,-8(fp)
   138a4:	10800117 	ldw	r2,4(r2)
   138a8:	e0bffa15 	stw	r2,-24(fp)

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
   138ac:	e0bffe17 	ldw	r2,-8(fp)
   138b0:	1080020b 	ldhu	r2,8(r2)
   138b4:	10ffffcc 	andi	r3,r2,65535
   138b8:	e0bffa17 	ldw	r2,-24(fp)
   138bc:	1080000b 	ldhu	r2,0(r2)
   138c0:	10bfffcc 	andi	r2,r2,65535
   138c4:	1004d23a 	srli	r2,r2,8
   138c8:	113fffcc 	andi	r4,r2,65535
   138cc:	e0bffa17 	ldw	r2,-24(fp)
   138d0:	1080000b 	ldhu	r2,0(r2)
   138d4:	10bfffcc 	andi	r2,r2,65535
   138d8:	1004923a 	slli	r2,r2,8
   138dc:	10bfffcc 	andi	r2,r2,65535
   138e0:	2084b03a 	or	r2,r4,r2
   138e4:	1005d23a 	srai	r2,r2,8
   138e8:	108003cc 	andi	r2,r2,15
   138ec:	10800084 	addi	r2,r2,2
   138f0:	1085883a 	add	r2,r2,r2
   138f4:	1085883a 	add	r2,r2,r2
   138f8:	18801816 	blt	r3,r2,1395c <udp_input+0xf4>
   138fc:	e0bffa17 	ldw	r2,-24(fp)
   13900:	1080000b 	ldhu	r2,0(r2)
   13904:	10bfffcc 	andi	r2,r2,65535
   13908:	1004d23a 	srli	r2,r2,8
   1390c:	10ffffcc 	andi	r3,r2,65535
   13910:	e0bffa17 	ldw	r2,-24(fp)
   13914:	1080000b 	ldhu	r2,0(r2)
   13918:	10bfffcc 	andi	r2,r2,65535
   1391c:	1004923a 	slli	r2,r2,8
   13920:	10bfffcc 	andi	r2,r2,65535
   13924:	1884b03a 	or	r2,r3,r2
   13928:	1005d23a 	srai	r2,r2,8
   1392c:	108003cc 	andi	r2,r2,15
   13930:	1085883a 	add	r2,r2,r2
   13934:	1085883a 	add	r2,r2,r2
   13938:	0085c83a 	sub	r2,zero,r2
   1393c:	10bfffcc 	andi	r2,r2,65535
   13940:	10a0001c 	xori	r2,r2,32768
   13944:	10a00004 	addi	r2,r2,-32768
   13948:	e13ffe17 	ldw	r4,-8(fp)
   1394c:	100b883a 	mov	r5,r2
   13950:	0009f740 	call	9f74 <pbuf_header>
   13954:	10803fcc 	andi	r2,r2,255
   13958:	10001326 	beq	r2,zero,139a8 <udp_input+0x140>
    /* drop short packets */
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
   1395c:	00800134 	movhi	r2,4
   13960:	108d9504 	addi	r2,r2,13908
   13964:	1080208b 	ldhu	r2,130(r2)
   13968:	10800044 	addi	r2,r2,1
   1396c:	1007883a 	mov	r3,r2
   13970:	00800134 	movhi	r2,4
   13974:	108d9504 	addi	r2,r2,13908
   13978:	10c0208d 	sth	r3,130(r2)
    UDP_STATS_INC(udp.drop);
   1397c:	00800134 	movhi	r2,4
   13980:	108d9504 	addi	r2,r2,13908
   13984:	10801f8b 	ldhu	r2,126(r2)
   13988:	10800044 	addi	r2,r2,1
   1398c:	1007883a 	mov	r3,r2
   13990:	00800134 	movhi	r2,4
   13994:	108d9504 	addi	r2,r2,13908
   13998:	10c01f8d 	sth	r3,126(r2)
    snmp_inc_udpinerrors();
    pbuf_free(p);
   1399c:	e13ffe17 	ldw	r4,-8(fp)
   139a0:	000a16c0 	call	a16c <pbuf_free>
    goto end;
   139a4:	00013c06 	br	13e98 <udp_input+0x630>
  }

  udphdr = (struct udp_hdr *)p->payload;
   139a8:	e0bffe17 	ldw	r2,-8(fp)
   139ac:	10800117 	ldw	r2,4(r2)
   139b0:	e0bffb15 	stw	r2,-20(fp)

  /* is broadcast packet ? */
  broadcast = ip_addr_isbroadcast(&(iphdr->dest), inp);
   139b4:	e0bffa17 	ldw	r2,-24(fp)
   139b8:	10800404 	addi	r2,r2,16
   139bc:	1009883a 	mov	r4,r2
   139c0:	e17fff17 	ldw	r5,-4(fp)
   139c4:	0006db00 	call	6db0 <ip_addr_isbroadcast>
   139c8:	e0bffc05 	stb	r2,-16(fp)

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
   139cc:	e0bffb17 	ldw	r2,-20(fp)
   139d0:	1080000b 	ldhu	r2,0(r2)
   139d4:	10bfffcc 	andi	r2,r2,65535
   139d8:	1004d23a 	srli	r2,r2,8
   139dc:	1007883a 	mov	r3,r2
   139e0:	e0bffb17 	ldw	r2,-20(fp)
   139e4:	1080000b 	ldhu	r2,0(r2)
   139e8:	10bfffcc 	andi	r2,r2,65535
   139ec:	1004923a 	slli	r2,r2,8
   139f0:	1884b03a 	or	r2,r3,r2
   139f4:	e0bffc8d 	sth	r2,-14(fp)
  dest = ntohs(udphdr->dest);
   139f8:	e0bffb17 	ldw	r2,-20(fp)
   139fc:	1080008b 	ldhu	r2,2(r2)
   13a00:	10bfffcc 	andi	r2,r2,65535
   13a04:	1004d23a 	srli	r2,r2,8
   13a08:	1007883a 	mov	r3,r2
   13a0c:	e0bffb17 	ldw	r2,-20(fp)
   13a10:	1080008b 	ldhu	r2,2(r2)
   13a14:	10bfffcc 	andi	r2,r2,65535
   13a18:	1004923a 	slli	r2,r2,8
   13a1c:	1884b03a 	or	r2,r3,r2
   13a20:	e0bffd0d 	sth	r2,-12(fp)
               ip4_addr3(&iphdr->dest), ip4_addr4(&iphdr->dest), ntohs(udphdr->dest),
               ip4_addr1(&iphdr->src), ip4_addr2(&iphdr->src),
               ip4_addr3(&iphdr->src), ip4_addr4(&iphdr->src), ntohs(udphdr->src)));

#if LWIP_DHCP
  pcb = NULL;
   13a24:	e03ff615 	stw	zero,-40(fp)
  /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
     the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
  if (dest == DHCP_CLIENT_PORT) {
   13a28:	e0bffd0b 	ldhu	r2,-12(fp)
   13a2c:	10801118 	cmpnei	r2,r2,68
   13a30:	1000231e 	bne	r2,zero,13ac0 <udp_input+0x258>
    /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
    if (src == DHCP_SERVER_PORT) {
   13a34:	e0bffc8b 	ldhu	r2,-14(fp)
   13a38:	108010d8 	cmpnei	r2,r2,67
   13a3c:	10007d1e 	bne	r2,zero,13c34 <udp_input+0x3cc>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
   13a40:	e0bfff17 	ldw	r2,-4(fp)
   13a44:	10800817 	ldw	r2,32(r2)
   13a48:	10007a26 	beq	r2,zero,13c34 <udp_input+0x3cc>
   13a4c:	e0bfff17 	ldw	r2,-4(fp)
   13a50:	10800817 	ldw	r2,32(r2)
   13a54:	10800117 	ldw	r2,4(r2)
   13a58:	10007626 	beq	r2,zero,13c34 <udp_input+0x3cc>
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
   13a5c:	e0bfff17 	ldw	r2,-4(fp)
   13a60:	10800817 	ldw	r2,32(r2)
   13a64:	10800117 	ldw	r2,4(r2)
   13a68:	10800104 	addi	r2,r2,4
   13a6c:	10000f26 	beq	r2,zero,13aac <udp_input+0x244>
   13a70:	e0bfff17 	ldw	r2,-4(fp)
   13a74:	10800817 	ldw	r2,32(r2)
   13a78:	10800117 	ldw	r2,4(r2)
   13a7c:	10800117 	ldw	r2,4(r2)
   13a80:	10000a26 	beq	r2,zero,13aac <udp_input+0x244>
           ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &(iphdr->src)))) {
   13a84:	e0bfff17 	ldw	r2,-4(fp)
   13a88:	10800817 	ldw	r2,32(r2)
   13a8c:	10800117 	ldw	r2,4(r2)
   13a90:	10c00117 	ldw	r3,4(r2)
   13a94:	e0bffa17 	ldw	r2,-24(fp)
   13a98:	1100030b 	ldhu	r4,12(r2)
   13a9c:	1080038b 	ldhu	r2,14(r2)
   13aa0:	1004943a 	slli	r2,r2,16
   13aa4:	1104b03a 	or	r2,r2,r4
    if (src == DHCP_SERVER_PORT) {
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
   13aa8:	1880621e 	bne	r3,r2,13c34 <udp_input+0x3cc>
           ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &(iphdr->src)))) {
          pcb = inp->dhcp->pcb;
   13aac:	e0bfff17 	ldw	r2,-4(fp)
   13ab0:	10800817 	ldw	r2,32(r2)
   13ab4:	10800117 	ldw	r2,4(r2)
   13ab8:	e0bff615 	stw	r2,-40(fp)
   13abc:	00005d06 	br	13c34 <udp_input+0x3cc>
      }
    }
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
   13ac0:	e03ff715 	stw	zero,-36(fp)
    local_match = 0;
   13ac4:	e03ff905 	stb	zero,-28(fp)
    uncon_pcb = NULL;
   13ac8:	e03ff815 	stw	zero,-32(fp)
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
   13acc:	d0a8e417 	ldw	r2,-23664(gp)
   13ad0:	e0bff615 	stw	r2,-40(fp)
   13ad4:	00005106 	br	13c1c <udp_input+0x3b4>
      local_match = 0;
   13ad8:	e03ff905 	stb	zero,-28(fp)
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
   13adc:	e0bff617 	ldw	r2,-40(fp)
   13ae0:	1080048b 	ldhu	r2,18(r2)
   13ae4:	10ffffcc 	andi	r3,r2,65535
   13ae8:	e0bffd0b 	ldhu	r2,-12(fp)
   13aec:	18801c1e 	bne	r3,r2,13b60 <udp_input+0x2f8>
   13af0:	e0bffc03 	ldbu	r2,-16(fp)
   13af4:	1000051e 	bne	r2,zero,13b0c <udp_input+0x2a4>
          ((!broadcast && ip_addr_isany(&pcb->local_ip)) ||
   13af8:	e0bff617 	ldw	r2,-40(fp)
   13afc:	10000d26 	beq	r2,zero,13b34 <udp_input+0x2cc>
   13b00:	e0bff617 	ldw	r2,-40(fp)
   13b04:	10800017 	ldw	r2,0(r2)
   13b08:	10000a26 	beq	r2,zero,13b34 <udp_input+0x2cc>
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) ||
   13b0c:	e0bff617 	ldw	r2,-40(fp)
   13b10:	10c00017 	ldw	r3,0(r2)
   13b14:	e0bffa17 	ldw	r2,-24(fp)
   13b18:	1100040b 	ldhu	r4,16(r2)
   13b1c:	1080048b 	ldhu	r2,18(r2)
   13b20:	1004943a 	slli	r2,r2,16
   13b24:	1104b03a 	or	r2,r2,r4
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
          ((!broadcast && ip_addr_isany(&pcb->local_ip)) ||
   13b28:	18800226 	beq	r3,r2,13b34 <udp_input+0x2cc>
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) ||
   13b2c:	e0bffc03 	ldbu	r2,-16(fp)
   13b30:	10000b26 	beq	r2,zero,13b60 <udp_input+0x2f8>
#if IP_SOF_BROADCAST_RECV
           (broadcast && (pcb->so_options & SOF_BROADCAST)))) {
#else  /* IP_SOF_BROADCAST_RECV */
           (broadcast))) {
#endif /* IP_SOF_BROADCAST_RECV */
        local_match = 1;
   13b34:	00800044 	movi	r2,1
   13b38:	e0bff905 	stb	r2,-28(fp)
        if ((uncon_pcb == NULL) && 
   13b3c:	e0bff817 	ldw	r2,-32(fp)
   13b40:	1000071e 	bne	r2,zero,13b60 <udp_input+0x2f8>
            ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
   13b44:	e0bff617 	ldw	r2,-40(fp)
   13b48:	10800403 	ldbu	r2,16(r2)
   13b4c:	10803fcc 	andi	r2,r2,255
   13b50:	1080010c 	andi	r2,r2,4
           (broadcast && (pcb->so_options & SOF_BROADCAST)))) {
#else  /* IP_SOF_BROADCAST_RECV */
           (broadcast))) {
#endif /* IP_SOF_BROADCAST_RECV */
        local_match = 1;
        if ((uncon_pcb == NULL) && 
   13b54:	1000021e 	bne	r2,zero,13b60 <udp_input+0x2f8>
            ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
          /* the first unconnected matching PCB */
          uncon_pcb = pcb;
   13b58:	e0bff617 	ldw	r2,-40(fp)
   13b5c:	e0bff815 	stw	r2,-32(fp)
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
   13b60:	e0bff903 	ldbu	r2,-28(fp)
   13b64:	10002826 	beq	r2,zero,13c08 <udp_input+0x3a0>
          (pcb->remote_port == src) &&
   13b68:	e0bff617 	ldw	r2,-40(fp)
   13b6c:	1080050b 	ldhu	r2,20(r2)
          /* the first unconnected matching PCB */
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
   13b70:	10ffffcc 	andi	r3,r2,65535
   13b74:	e0bffc8b 	ldhu	r2,-14(fp)
   13b78:	1880231e 	bne	r3,r2,13c08 <udp_input+0x3a0>
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
   13b7c:	e0bff617 	ldw	r2,-40(fp)
   13b80:	10800104 	addi	r2,r2,4
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
   13b84:	10000b26 	beq	r2,zero,13bb4 <udp_input+0x34c>
          (ip_addr_isany(&pcb->remote_ip) ||
   13b88:	e0bff617 	ldw	r2,-40(fp)
   13b8c:	10800117 	ldw	r2,4(r2)
   13b90:	10000826 	beq	r2,zero,13bb4 <udp_input+0x34c>
           ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
   13b94:	e0bff617 	ldw	r2,-40(fp)
   13b98:	10c00117 	ldw	r3,4(r2)
   13b9c:	e0bffa17 	ldw	r2,-24(fp)
   13ba0:	1100030b 	ldhu	r4,12(r2)
   13ba4:	1080038b 	ldhu	r2,14(r2)
   13ba8:	1004943a 	slli	r2,r2,16
   13bac:	1104b03a 	or	r2,r2,r4
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
   13bb0:	1880151e 	bne	r3,r2,13c08 <udp_input+0x3a0>
           ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
        /* the first fully matching PCB */
        if (prev != NULL) {
   13bb4:	e0bff717 	ldw	r2,-36(fp)
   13bb8:	10000a26 	beq	r2,zero,13be4 <udp_input+0x37c>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
   13bbc:	e0bff617 	ldw	r2,-40(fp)
   13bc0:	10c00317 	ldw	r3,12(r2)
   13bc4:	e0bff717 	ldw	r2,-36(fp)
   13bc8:	10c00315 	stw	r3,12(r2)
          pcb->next = udp_pcbs;
   13bcc:	d0e8e417 	ldw	r3,-23664(gp)
   13bd0:	e0bff617 	ldw	r2,-40(fp)
   13bd4:	10c00315 	stw	r3,12(r2)
          udp_pcbs = pcb;
   13bd8:	e0bff617 	ldw	r2,-40(fp)
   13bdc:	d0a8e415 	stw	r2,-23664(gp)
        } else {
          UDP_STATS_INC(udp.cachehit);
        }
        break;
   13be0:	00001006 	br	13c24 <udp_input+0x3bc>
             found faster next time */
          prev->next = pcb->next;
          pcb->next = udp_pcbs;
          udp_pcbs = pcb;
        } else {
          UDP_STATS_INC(udp.cachehit);
   13be4:	00800134 	movhi	r2,4
   13be8:	108d9504 	addi	r2,r2,13908
   13bec:	1080238b 	ldhu	r2,142(r2)
   13bf0:	10800044 	addi	r2,r2,1
   13bf4:	1007883a 	mov	r3,r2
   13bf8:	00800134 	movhi	r2,4
   13bfc:	108d9504 	addi	r2,r2,13908
   13c00:	10c0238d 	sth	r3,142(r2)
        }
        break;
   13c04:	00000706 	br	13c24 <udp_input+0x3bc>
      }
      prev = pcb;
   13c08:	e0bff617 	ldw	r2,-40(fp)
   13c0c:	e0bff715 	stw	r2,-36(fp)
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
   13c10:	e0bff617 	ldw	r2,-40(fp)
   13c14:	10800317 	ldw	r2,12(r2)
   13c18:	e0bff615 	stw	r2,-40(fp)
   13c1c:	e0bff617 	ldw	r2,-40(fp)
   13c20:	103fad1e 	bne	r2,zero,13ad8 <udp_input+0x270>
        break;
      }
      prev = pcb;
    }
    /* no fully matching pcb found? then look for an unconnected pcb */
    if (pcb == NULL) {
   13c24:	e0bff617 	ldw	r2,-40(fp)
   13c28:	1000021e 	bne	r2,zero,13c34 <udp_input+0x3cc>
      pcb = uncon_pcb;
   13c2c:	e0bff817 	ldw	r2,-32(fp)
   13c30:	e0bff615 	stw	r2,-40(fp)
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
   13c34:	e0bff617 	ldw	r2,-40(fp)
   13c38:	1000081e 	bne	r2,zero,13c5c <udp_input+0x3f4>
   13c3c:	e0bfff17 	ldw	r2,-4(fp)
   13c40:	10c00117 	ldw	r3,4(r2)
   13c44:	e0bffa17 	ldw	r2,-24(fp)
   13c48:	1100040b 	ldhu	r4,16(r2)
   13c4c:	1080048b 	ldhu	r2,18(r2)
   13c50:	1004943a 	slli	r2,r2,16
   13c54:	1104b03a 	or	r2,r2,r4
   13c58:	18808d1e 	bne	r3,r2,13e90 <udp_input+0x628>
#endif /* CHECKSUM_CHECK_UDP */
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
   13c5c:	e0bffb17 	ldw	r2,-20(fp)
   13c60:	1080018b 	ldhu	r2,6(r2)
   13c64:	10bfffcc 	andi	r2,r2,65535
   13c68:	10002226 	beq	r2,zero,13cf4 <udp_input+0x48c>
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
   13c6c:	e0bffa17 	ldw	r2,-24(fp)
   13c70:	10c00304 	addi	r3,r2,12
   13c74:	e0bffa17 	ldw	r2,-24(fp)
   13c78:	10800404 	addi	r2,r2,16
                               (struct ip_addr *)&(iphdr->dest),
                               IP_PROTO_UDP, p->tot_len) != 0) {
   13c7c:	e13ffe17 	ldw	r4,-8(fp)
   13c80:	2100020b 	ldhu	r4,8(r4)
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
   13c84:	213fffcc 	andi	r4,r4,65535
   13c88:	d9000015 	stw	r4,0(sp)
   13c8c:	e13ffe17 	ldw	r4,-8(fp)
   13c90:	180b883a 	mov	r5,r3
   13c94:	100d883a 	mov	r6,r2
   13c98:	01c00444 	movi	r7,17
   13c9c:	0005e240 	call	5e24 <inet_chksum_pseudo>
   13ca0:	10bfffcc 	andi	r2,r2,65535
   13ca4:	10001326 	beq	r2,zero,13cf4 <udp_input+0x48c>
                               (struct ip_addr *)&(iphdr->dest),
                               IP_PROTO_UDP, p->tot_len) != 0) {
          LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                      ("udp_input: UDP datagram discarded due to failing checksum\n"));
          UDP_STATS_INC(udp.chkerr);
   13ca8:	00800134 	movhi	r2,4
   13cac:	108d9504 	addi	r2,r2,13908
   13cb0:	1080200b 	ldhu	r2,128(r2)
   13cb4:	10800044 	addi	r2,r2,1
   13cb8:	1007883a 	mov	r3,r2
   13cbc:	00800134 	movhi	r2,4
   13cc0:	108d9504 	addi	r2,r2,13908
   13cc4:	10c0200d 	sth	r3,128(r2)
          UDP_STATS_INC(udp.drop);
   13cc8:	00800134 	movhi	r2,4
   13ccc:	108d9504 	addi	r2,r2,13908
   13cd0:	10801f8b 	ldhu	r2,126(r2)
   13cd4:	10800044 	addi	r2,r2,1
   13cd8:	1007883a 	mov	r3,r2
   13cdc:	00800134 	movhi	r2,4
   13ce0:	108d9504 	addi	r2,r2,13908
   13ce4:	10c01f8d 	sth	r3,126(r2)
          snmp_inc_udpinerrors();
          pbuf_free(p);
   13ce8:	e13ffe17 	ldw	r4,-8(fp)
   13cec:	000a16c0 	call	a16c <pbuf_free>
          goto end;
   13cf0:	00006906 	br	13e98 <udp_input+0x630>
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
   13cf4:	e13ffe17 	ldw	r4,-8(fp)
   13cf8:	017ffe04 	movi	r5,-8
   13cfc:	0009f740 	call	9f74 <pbuf_header>
   13d00:	10803fcc 	andi	r2,r2,255
   13d04:	10000926 	beq	r2,zero,13d2c <udp_input+0x4c4>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
   13d08:	010000f4 	movhi	r4,3
   13d0c:	213b5a04 	addi	r4,r4,-4760
   13d10:	014000f4 	movhi	r5,3
   13d14:	297b6404 	addi	r5,r5,-4720
   13d18:	01804484 	movi	r6,274
   13d1c:	01c000f4 	movhi	r7,3
   13d20:	39fb6904 	addi	r7,r7,-4700
   13d24:	00166c00 	call	166c0 <printf>
   13d28:	003fff06 	br	13d28 <udp_input+0x4c0>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
   13d2c:	e0bff617 	ldw	r2,-40(fp)
   13d30:	10001426 	beq	r2,zero,13d84 <udp_input+0x51c>
      snmp_inc_udpindatagrams();
      /* callback */
      if (pcb->recv != NULL) {
   13d34:	e0bff617 	ldw	r2,-40(fp)
   13d38:	10800617 	ldw	r2,24(r2)
   13d3c:	10000e26 	beq	r2,zero,13d78 <udp_input+0x510>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, &iphdr->src, src);
   13d40:	e0bff617 	ldw	r2,-40(fp)
   13d44:	12000617 	ldw	r8,24(r2)
   13d48:	e0bff617 	ldw	r2,-40(fp)
   13d4c:	10c00717 	ldw	r3,28(r2)
   13d50:	e0bffa17 	ldw	r2,-24(fp)
   13d54:	10800304 	addi	r2,r2,12
   13d58:	e13ffc8b 	ldhu	r4,-14(fp)
   13d5c:	d9000015 	stw	r4,0(sp)
   13d60:	1809883a 	mov	r4,r3
   13d64:	e17ff617 	ldw	r5,-40(fp)
   13d68:	e1bffe17 	ldw	r6,-8(fp)
   13d6c:	100f883a 	mov	r7,r2
   13d70:	403ee83a 	callr	r8
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
   13d74:	00004806 	br	13e98 <udp_input+0x630>
      if (pcb->recv != NULL) {
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, &iphdr->src, src);
      } else {
        /* no recv function registered? then we have to free the pbuf! */
        pbuf_free(p);
   13d78:	e13ffe17 	ldw	r4,-8(fp)
   13d7c:	000a16c0 	call	a16c <pbuf_free>
        goto end;
   13d80:	00004506 	br	13e98 <udp_input+0x630>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!broadcast &&
   13d84:	e0bffc03 	ldbu	r2,-16(fp)
   13d88:	10002e1e 	bne	r2,zero,13e44 <udp_input+0x5dc>
          !ip_addr_ismulticast(&iphdr->dest)) {
   13d8c:	e0bffa17 	ldw	r2,-24(fp)
   13d90:	10c0040b 	ldhu	r3,16(r2)
   13d94:	1080048b 	ldhu	r2,18(r2)
   13d98:	1004943a 	slli	r2,r2,16
   13d9c:	10c4b03a 	or	r2,r2,r3
   13da0:	10803c0c 	andi	r2,r2,240
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!broadcast &&
   13da4:	10803820 	cmpeqi	r2,r2,224
   13da8:	1000261e 	bne	r2,zero,13e44 <udp_input+0x5dc>
          !ip_addr_ismulticast(&iphdr->dest)) {
        /* move payload pointer back to ip header */
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
   13dac:	e0bffa17 	ldw	r2,-24(fp)
   13db0:	1080000b 	ldhu	r2,0(r2)
   13db4:	10bfffcc 	andi	r2,r2,65535
   13db8:	1004d23a 	srli	r2,r2,8
   13dbc:	10ffffcc 	andi	r3,r2,65535
   13dc0:	e0bffa17 	ldw	r2,-24(fp)
   13dc4:	1080000b 	ldhu	r2,0(r2)
   13dc8:	10bfffcc 	andi	r2,r2,65535
   13dcc:	1004923a 	slli	r2,r2,8
   13dd0:	10bfffcc 	andi	r2,r2,65535
   13dd4:	1884b03a 	or	r2,r3,r2
   13dd8:	1005d23a 	srai	r2,r2,8
   13ddc:	108003cc 	andi	r2,r2,15
   13de0:	10800084 	addi	r2,r2,2
   13de4:	1085883a 	add	r2,r2,r2
   13de8:	1085883a 	add	r2,r2,r2
   13dec:	10bfffcc 	andi	r2,r2,65535
   13df0:	10a0001c 	xori	r2,r2,32768
   13df4:	10a00004 	addi	r2,r2,-32768
   13df8:	e13ffe17 	ldw	r4,-8(fp)
   13dfc:	100b883a 	mov	r5,r2
   13e00:	0009f740 	call	9f74 <pbuf_header>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
   13e04:	e0bffe17 	ldw	r2,-8(fp)
   13e08:	10c00117 	ldw	r3,4(r2)
   13e0c:	e0bffa17 	ldw	r2,-24(fp)
   13e10:	18800926 	beq	r3,r2,13e38 <udp_input+0x5d0>
   13e14:	010000f4 	movhi	r4,3
   13e18:	213b5a04 	addi	r4,r4,-4760
   13e1c:	014000f4 	movhi	r5,3
   13e20:	297b6e04 	addi	r5,r5,-4680
   13e24:	01804b44 	movi	r6,301
   13e28:	01c000f4 	movhi	r7,3
   13e2c:	39fb6904 	addi	r7,r7,-4700
   13e30:	00166c00 	call	166c0 <printf>
   13e34:	003fff06 	br	13e34 <udp_input+0x5cc>
        icmp_dest_unreach(p, ICMP_DUR_PORT);
   13e38:	e13ffe17 	ldw	r4,-8(fp)
   13e3c:	014000c4 	movi	r5,3
   13e40:	000546c0 	call	546c <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
   13e44:	00800134 	movhi	r2,4
   13e48:	108d9504 	addi	r2,r2,13908
   13e4c:	1080220b 	ldhu	r2,136(r2)
   13e50:	10800044 	addi	r2,r2,1
   13e54:	1007883a 	mov	r3,r2
   13e58:	00800134 	movhi	r2,4
   13e5c:	108d9504 	addi	r2,r2,13908
   13e60:	10c0220d 	sth	r3,136(r2)
      UDP_STATS_INC(udp.drop);
   13e64:	00800134 	movhi	r2,4
   13e68:	108d9504 	addi	r2,r2,13908
   13e6c:	10801f8b 	ldhu	r2,126(r2)
   13e70:	10800044 	addi	r2,r2,1
   13e74:	1007883a 	mov	r3,r2
   13e78:	00800134 	movhi	r2,4
   13e7c:	108d9504 	addi	r2,r2,13908
   13e80:	10c01f8d 	sth	r3,126(r2)
      snmp_inc_udpnoports();
      pbuf_free(p);
   13e84:	e13ffe17 	ldw	r4,-8(fp)
   13e88:	000a16c0 	call	a16c <pbuf_free>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
   13e8c:	00000206 	br	13e98 <udp_input+0x630>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
    }
  } else {
    pbuf_free(p);
   13e90:	e13ffe17 	ldw	r4,-8(fp)
   13e94:	000a16c0 	call	a16c <pbuf_free>
  }
end:
  PERF_STOP("udp_input");
}
   13e98:	e037883a 	mov	sp,fp
   13e9c:	dfc00117 	ldw	ra,4(sp)
   13ea0:	df000017 	ldw	fp,0(sp)
   13ea4:	dec00204 	addi	sp,sp,8
   13ea8:	f800283a 	ret

00013eac <udp_send>:
 *
 * @see udp_disconnect() udp_sendto()
 */
err_t
udp_send(struct udp_pcb *pcb, struct pbuf *p)
{
   13eac:	defffc04 	addi	sp,sp,-16
   13eb0:	dfc00315 	stw	ra,12(sp)
   13eb4:	df000215 	stw	fp,8(sp)
   13eb8:	df000204 	addi	fp,sp,8
   13ebc:	e13ffe15 	stw	r4,-8(fp)
   13ec0:	e17fff15 	stw	r5,-4(fp)
  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
   13ec4:	e0bffe17 	ldw	r2,-8(fp)
   13ec8:	10c00104 	addi	r3,r2,4
   13ecc:	e0bffe17 	ldw	r2,-8(fp)
   13ed0:	1080050b 	ldhu	r2,20(r2)
   13ed4:	10bfffcc 	andi	r2,r2,65535
   13ed8:	e13ffe17 	ldw	r4,-8(fp)
   13edc:	e17fff17 	ldw	r5,-4(fp)
   13ee0:	180d883a 	mov	r6,r3
   13ee4:	100f883a 	mov	r7,r2
   13ee8:	0013f000 	call	13f00 <udp_sendto>
}
   13eec:	e037883a 	mov	sp,fp
   13ef0:	dfc00117 	ldw	ra,4(sp)
   13ef4:	df000017 	ldw	fp,0(sp)
   13ef8:	dec00204 	addi	sp,sp,8
   13efc:	f800283a 	ret

00013f00 <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port)
{
   13f00:	defff804 	addi	sp,sp,-32
   13f04:	dfc00715 	stw	ra,28(sp)
   13f08:	df000615 	stw	fp,24(sp)
   13f0c:	df000604 	addi	fp,sp,24
   13f10:	e13ffc15 	stw	r4,-16(fp)
   13f14:	e17ffd15 	stw	r5,-12(fp)
   13f18:	e1bffe15 	stw	r6,-8(fp)
   13f1c:	3805883a 	mov	r2,r7
   13f20:	e0bfff0d 	sth	r2,-4(fp)

  /* find the outgoing network interface for this packet */
#if LWIP_IGMP
  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
#else
  netif = ip_route(dst_ip);
   13f24:	e13ffe17 	ldw	r4,-8(fp)
   13f28:	00061940 	call	6194 <ip_route>
   13f2c:	e0bffb15 	stw	r2,-20(fp)
#endif /* LWIP_IGMP */

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
   13f30:	e0bffb17 	ldw	r2,-20(fp)
   13f34:	10000a1e 	bne	r2,zero,13f60 <udp_sendto+0x60>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: No route to 0x%"X32_F"\n", dst_ip->addr));
    UDP_STATS_INC(udp.rterr);
   13f38:	00800134 	movhi	r2,4
   13f3c:	108d9504 	addi	r2,r2,13908
   13f40:	1080218b 	ldhu	r2,134(r2)
   13f44:	10800044 	addi	r2,r2,1
   13f48:	1007883a 	mov	r3,r2
   13f4c:	00800134 	movhi	r2,4
   13f50:	108d9504 	addi	r2,r2,13908
   13f54:	10c0218d 	sth	r3,134(r2)
    return ERR_RTE;
   13f58:	00bfff04 	movi	r2,-4
   13f5c:	00000806 	br	13f80 <udp_sendto+0x80>
  }
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
   13f60:	e0bfff0b 	ldhu	r2,-4(fp)
   13f64:	e0fffb17 	ldw	r3,-20(fp)
   13f68:	d8c00015 	stw	r3,0(sp)
   13f6c:	e13ffc17 	ldw	r4,-16(fp)
   13f70:	e17ffd17 	ldw	r5,-12(fp)
   13f74:	e1bffe17 	ldw	r6,-8(fp)
   13f78:	100f883a 	mov	r7,r2
   13f7c:	0013f940 	call	13f94 <udp_sendto_if>
}
   13f80:	e037883a 	mov	sp,fp
   13f84:	dfc00117 	ldw	ra,4(sp)
   13f88:	df000017 	ldw	fp,0(sp)
   13f8c:	dec00204 	addi	sp,sp,8
   13f90:	f800283a 	ret

00013f94 <udp_sendto_if>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port, struct netif *netif)
{
   13f94:	defff304 	addi	sp,sp,-52
   13f98:	dfc00c15 	stw	ra,48(sp)
   13f9c:	df000b15 	stw	fp,44(sp)
   13fa0:	df000b04 	addi	fp,sp,44
   13fa4:	e13ffc15 	stw	r4,-16(fp)
   13fa8:	e17ffd15 	stw	r5,-12(fp)
   13fac:	e1bffe15 	stw	r6,-8(fp)
   13fb0:	3805883a 	mov	r2,r7
   13fb4:	e0bfff0d 	sth	r2,-4(fp)
    return ERR_VAL;
  }
#endif /* IP_SOF_BROADCAST */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
   13fb8:	e0bffc17 	ldw	r2,-16(fp)
   13fbc:	1080048b 	ldhu	r2,18(r2)
   13fc0:	10bfffcc 	andi	r2,r2,65535
   13fc4:	10000d1e 	bne	r2,zero,13ffc <udp_sendto_if+0x68>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
   13fc8:	e0fffc17 	ldw	r3,-16(fp)
   13fcc:	e0bffc17 	ldw	r2,-16(fp)
   13fd0:	1080048b 	ldhu	r2,18(r2)
   13fd4:	10bfffcc 	andi	r2,r2,65535
   13fd8:	e13ffc17 	ldw	r4,-16(fp)
   13fdc:	180b883a 	mov	r5,r3
   13fe0:	100d883a 	mov	r6,r2
   13fe4:	00142740 	call	14274 <udp_bind>
   13fe8:	e0bffa05 	stb	r2,-24(fp)
    if (err != ERR_OK) {
   13fec:	e0bffa07 	ldb	r2,-24(fp)
   13ff0:	10000226 	beq	r2,zero,13ffc <udp_sendto_if+0x68>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: forced port bind failed\n"));
      return err;
   13ff4:	e0bffa03 	ldbu	r2,-24(fp)
   13ff8:	00009906 	br	14260 <udp_sendto_if+0x2cc>
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
   13ffc:	e13ffd17 	ldw	r4,-12(fp)
   14000:	01400204 	movi	r5,8
   14004:	0009f740 	call	9f74 <pbuf_header>
   14008:	10803fcc 	andi	r2,r2,255
   1400c:	10000d26 	beq	r2,zero,14044 <udp_sendto_if+0xb0>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
   14010:	01000044 	movi	r4,1
   14014:	01400204 	movi	r5,8
   14018:	000d883a 	mov	r6,zero
   1401c:	00097b00 	call	97b0 <pbuf_alloc>
   14020:	e0bff915 	stw	r2,-28(fp)
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
   14024:	e0bff917 	ldw	r2,-28(fp)
   14028:	1000021e 	bne	r2,zero,14034 <udp_sendto_if+0xa0>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
   1402c:	00bfffc4 	movi	r2,-1
   14030:	00008b06 	br	14260 <udp_sendto_if+0x2cc>
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
   14034:	e13ff917 	ldw	r4,-28(fp)
   14038:	e17ffd17 	ldw	r5,-12(fp)
   1403c:	000a5040 	call	a504 <pbuf_chain>
   14040:	00000206 	br	1404c <udp_sendto_if+0xb8>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  } else {
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
   14044:	e0bffd17 	ldw	r2,-12(fp)
   14048:	e0bff915 	stw	r2,-28(fp)
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
   1404c:	e0bff917 	ldw	r2,-28(fp)
   14050:	1080028b 	ldhu	r2,10(r2)
   14054:	10bfffcc 	andi	r2,r2,65535
   14058:	10800228 	cmpgeui	r2,r2,8
   1405c:	1000091e 	bne	r2,zero,14084 <udp_sendto_if+0xf0>
   14060:	010000f4 	movhi	r4,3
   14064:	213b5a04 	addi	r4,r4,-4760
   14068:	014000f4 	movhi	r5,3
   1406c:	297b7304 	addi	r5,r5,-4660
   14070:	018070c4 	movi	r6,451
   14074:	01c000f4 	movhi	r7,3
   14078:	39fb6904 	addi	r7,r7,-4700
   1407c:	00166c00 	call	166c0 <printf>
   14080:	003fff06 	br	14080 <udp_sendto_if+0xec>
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = q->payload;
   14084:	e0bff917 	ldw	r2,-28(fp)
   14088:	10800117 	ldw	r2,4(r2)
   1408c:	e0bffb15 	stw	r2,-20(fp)
  udphdr->src = htons(pcb->local_port);
   14090:	e0bffc17 	ldw	r2,-16(fp)
   14094:	1080048b 	ldhu	r2,18(r2)
   14098:	10bfffcc 	andi	r2,r2,65535
   1409c:	1004d23a 	srli	r2,r2,8
   140a0:	1007883a 	mov	r3,r2
   140a4:	e0bffc17 	ldw	r2,-16(fp)
   140a8:	1080048b 	ldhu	r2,18(r2)
   140ac:	10bfffcc 	andi	r2,r2,65535
   140b0:	1004923a 	slli	r2,r2,8
   140b4:	1884b03a 	or	r2,r3,r2
   140b8:	1007883a 	mov	r3,r2
   140bc:	e0bffb17 	ldw	r2,-20(fp)
   140c0:	10c0000d 	sth	r3,0(r2)
  udphdr->dest = htons(dst_port);
   140c4:	e0bfff0b 	ldhu	r2,-4(fp)
   140c8:	1004d23a 	srli	r2,r2,8
   140cc:	1007883a 	mov	r3,r2
   140d0:	e0bfff0b 	ldhu	r2,-4(fp)
   140d4:	1004923a 	slli	r2,r2,8
   140d8:	1884b03a 	or	r2,r3,r2
   140dc:	1007883a 	mov	r3,r2
   140e0:	e0bffb17 	ldw	r2,-20(fp)
   140e4:	10c0008d 	sth	r3,2(r2)
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
   140e8:	e0bffb17 	ldw	r2,-20(fp)
   140ec:	1000018d 	sth	zero,6(r2)

  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
   140f0:	e0bffc17 	ldw	r2,-16(fp)
   140f4:	10000326 	beq	r2,zero,14104 <udp_sendto_if+0x170>
   140f8:	e0bffc17 	ldw	r2,-16(fp)
   140fc:	10800017 	ldw	r2,0(r2)
   14100:	1000041e 	bne	r2,zero,14114 <udp_sendto_if+0x180>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
   14104:	e0800217 	ldw	r2,8(fp)
   14108:	10800104 	addi	r2,r2,4
   1410c:	e0bff815 	stw	r2,-32(fp)
   14110:	00000f06 	br	14150 <udp_sendto_if+0x1bc>
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
   14114:	e0bffc17 	ldw	r2,-16(fp)
   14118:	10c00017 	ldw	r3,0(r2)
   1411c:	e0800217 	ldw	r2,8(fp)
   14120:	10800117 	ldw	r2,4(r2)
   14124:	18800826 	beq	r3,r2,14148 <udp_sendto_if+0x1b4>
      /* local_ip doesn't match, drop the packet */
      if (q != p) {
   14128:	e0fff917 	ldw	r3,-28(fp)
   1412c:	e0bffd17 	ldw	r2,-12(fp)
   14130:	18800326 	beq	r3,r2,14140 <udp_sendto_if+0x1ac>
        /* free the header pbuf */
        pbuf_free(q);
   14134:	e13ff917 	ldw	r4,-28(fp)
   14138:	000a16c0 	call	a16c <pbuf_free>
        q = NULL;
   1413c:	e03ff915 	stw	zero,-28(fp)
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
   14140:	00bffdc4 	movi	r2,-9
   14144:	00004606 	br	14260 <udp_sendto_if+0x2cc>
    }
    /* use UDP PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
   14148:	e0bffc17 	ldw	r2,-16(fp)
   1414c:	e0bff815 	stw	r2,-32(fp)
#endif /* LWIP_NETIF_HWADDRHINT*/
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
   14150:	e0bff917 	ldw	r2,-28(fp)
   14154:	1080020b 	ldhu	r2,8(r2)
   14158:	10bfffcc 	andi	r2,r2,65535
   1415c:	1004d23a 	srli	r2,r2,8
   14160:	1007883a 	mov	r3,r2
   14164:	e0bff917 	ldw	r2,-28(fp)
   14168:	1080020b 	ldhu	r2,8(r2)
   1416c:	10bfffcc 	andi	r2,r2,65535
   14170:	1004923a 	slli	r2,r2,8
   14174:	1884b03a 	or	r2,r3,r2
   14178:	1007883a 	mov	r3,r2
   1417c:	e0bffb17 	ldw	r2,-20(fp)
   14180:	10c0010d 	sth	r3,4(r2)
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
   14184:	e0bffc17 	ldw	r2,-16(fp)
   14188:	10800403 	ldbu	r2,16(r2)
   1418c:	10803fcc 	andi	r2,r2,255
   14190:	1080004c 	andi	r2,r2,1
   14194:	1000121e 	bne	r2,zero,141e0 <udp_sendto_if+0x24c>
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
   14198:	e0bff917 	ldw	r2,-28(fp)
   1419c:	1080020b 	ldhu	r2,8(r2)
   141a0:	10bfffcc 	andi	r2,r2,65535
   141a4:	d8800015 	stw	r2,0(sp)
   141a8:	e13ff917 	ldw	r4,-28(fp)
   141ac:	e17ff817 	ldw	r5,-32(fp)
   141b0:	e1bffe17 	ldw	r6,-8(fp)
   141b4:	01c00444 	movi	r7,17
   141b8:	0005e240 	call	5e24 <inet_chksum_pseudo>
   141bc:	e0fffb17 	ldw	r3,-20(fp)
   141c0:	1880018d 	sth	r2,6(r3)
      /* chksum zero must become 0xffff, as zero means 'no checksum' */
      if (udphdr->chksum == 0x0000) udphdr->chksum = 0xffff;
   141c4:	e0bffb17 	ldw	r2,-20(fp)
   141c8:	1080018b 	ldhu	r2,6(r2)
   141cc:	10bfffcc 	andi	r2,r2,65535
   141d0:	1000031e 	bne	r2,zero,141e0 <udp_sendto_if+0x24c>
   141d4:	e0bffb17 	ldw	r2,-20(fp)
   141d8:	00ffffc4 	movi	r3,-1
   141dc:	10c0018d 	sth	r3,6(r2)
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
#if LWIP_NETIF_HWADDRHINT
    netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);
   141e0:	e0bffc17 	ldw	r2,-16(fp)
   141e4:	108002c3 	ldbu	r2,11(r2)
   141e8:	10803fcc 	andi	r2,r2,255
   141ec:	e0fffc17 	ldw	r3,-16(fp)
   141f0:	18c00283 	ldbu	r3,10(r3)
   141f4:	18c03fcc 	andi	r3,r3,255
   141f8:	d8c00015 	stw	r3,0(sp)
   141fc:	00c00444 	movi	r3,17
   14200:	d8c00115 	stw	r3,4(sp)
   14204:	e0c00217 	ldw	r3,8(fp)
   14208:	d8c00215 	stw	r3,8(sp)
   1420c:	e13ff917 	ldw	r4,-28(fp)
   14210:	e17ff817 	ldw	r5,-32(fp)
   14214:	e1bffe17 	ldw	r6,-8(fp)
   14218:	100f883a 	mov	r7,r2
   1421c:	00068600 	call	6860 <ip_output_if>
   14220:	e0bffa05 	stb	r2,-24(fp)
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
   14224:	e0fff917 	ldw	r3,-28(fp)
   14228:	e0bffd17 	ldw	r2,-12(fp)
   1422c:	18800326 	beq	r3,r2,1423c <udp_sendto_if+0x2a8>
    /* free the header pbuf */
    pbuf_free(q);
   14230:	e13ff917 	ldw	r4,-28(fp)
   14234:	000a16c0 	call	a16c <pbuf_free>
    q = NULL;
   14238:	e03ff915 	stw	zero,-28(fp)
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
   1423c:	00800134 	movhi	r2,4
   14240:	108d9504 	addi	r2,r2,13908
   14244:	10801e0b 	ldhu	r2,120(r2)
   14248:	10800044 	addi	r2,r2,1
   1424c:	1007883a 	mov	r3,r2
   14250:	00800134 	movhi	r2,4
   14254:	108d9504 	addi	r2,r2,13908
   14258:	10c01e0d 	sth	r3,120(r2)
  return err;
   1425c:	e0bffa03 	ldbu	r2,-24(fp)
}
   14260:	e037883a 	mov	sp,fp
   14264:	dfc00117 	ldw	ra,4(sp)
   14268:	df000017 	ldw	fp,0(sp)
   1426c:	dec00204 	addi	sp,sp,8
   14270:	f800283a 	ret

00014274 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
   14274:	defff904 	addi	sp,sp,-28
   14278:	dfc00615 	stw	ra,24(sp)
   1427c:	df000515 	stw	fp,20(sp)
   14280:	df000504 	addi	fp,sp,20
   14284:	e13ffd15 	stw	r4,-12(fp)
   14288:	e17ffe15 	stw	r5,-8(fp)
   1428c:	3005883a 	mov	r2,r6
   14290:	e0bfff0d 	sth	r2,-4(fp)

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
   14294:	e03ffc05 	stb	zero,-16(fp)
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
   14298:	d0a8e417 	ldw	r2,-23664(gp)
   1429c:	e0bffb15 	stw	r2,-20(fp)
   142a0:	00001306 	br	142f0 <udp_bind+0x7c>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
   142a4:	e0fffd17 	ldw	r3,-12(fp)
   142a8:	e0bffb17 	ldw	r2,-20(fp)
   142ac:	18800d1e 	bne	r3,r2,142e4 <udp_bind+0x70>
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
   142b0:	e0bffc03 	ldbu	r2,-16(fp)
   142b4:	10000926 	beq	r2,zero,142dc <udp_bind+0x68>
   142b8:	010000f4 	movhi	r4,3
   142bc:	213b5a04 	addi	r4,r4,-4760
   142c0:	014000f4 	movhi	r5,3
   142c4:	297b7f04 	addi	r5,r5,-4612
   142c8:	01809484 	movi	r6,594
   142cc:	01c000f4 	movhi	r7,3
   142d0:	39fb6904 	addi	r7,r7,-4700
   142d4:	00166c00 	call	166c0 <printf>
   142d8:	003fff06 	br	142d8 <udp_bind+0x64>
      /* pcb already in list, just rebind */
      rebind = 1;
   142dc:	00800044 	movi	r2,1
   142e0:	e0bffc05 	stb	r2,-16(fp)
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
   142e4:	e0bffb17 	ldw	r2,-20(fp)
   142e8:	10800317 	ldw	r2,12(r2)
   142ec:	e0bffb15 	stw	r2,-20(fp)
   142f0:	e0bffb17 	ldw	r2,-20(fp)
   142f4:	103feb1e 	bne	r2,zero,142a4 <udp_bind+0x30>
        return ERR_USE;
      }
#endif
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
   142f8:	e0bffe17 	ldw	r2,-8(fp)
   142fc:	10000626 	beq	r2,zero,14318 <udp_bind+0xa4>
   14300:	e0bffe17 	ldw	r2,-8(fp)
   14304:	10c0000b 	ldhu	r3,0(r2)
   14308:	1080008b 	ldhu	r2,2(r2)
   1430c:	1004943a 	slli	r2,r2,16
   14310:	10c4b03a 	or	r2,r2,r3
   14314:	00000106 	br	1431c <udp_bind+0xa8>
   14318:	0005883a 	mov	r2,zero
   1431c:	e0fffd17 	ldw	r3,-12(fp)
   14320:	18800015 	stw	r2,0(r3)

  /* no port specified? */
  if (port == 0) {
   14324:	e0bfff0b 	ldhu	r2,-4(fp)
   14328:	10001c1e 	bne	r2,zero,1439c <udp_bind+0x128>
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
   1432c:	00840004 	movi	r2,4096
   14330:	e0bfff0d 	sth	r2,-4(fp)
    ipcb = udp_pcbs;
   14334:	d0a8e417 	ldw	r2,-23664(gp)
   14338:	e0bffb15 	stw	r2,-20(fp)
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
   1433c:	00000e06 	br	14378 <udp_bind+0x104>
      if (ipcb->local_port == port) {
   14340:	e0bffb17 	ldw	r2,-20(fp)
   14344:	1080048b 	ldhu	r2,18(r2)
   14348:	10ffffcc 	andi	r3,r2,65535
   1434c:	e0bfff0b 	ldhu	r2,-4(fp)
   14350:	1880061e 	bne	r3,r2,1436c <udp_bind+0xf8>
        /* port is already used by another udp_pcb */
        port++;
   14354:	e0bfff0b 	ldhu	r2,-4(fp)
   14358:	10800044 	addi	r2,r2,1
   1435c:	e0bfff0d 	sth	r2,-4(fp)
        /* restart scanning all udp pcbs */
        ipcb = udp_pcbs;
   14360:	d0a8e417 	ldw	r2,-23664(gp)
   14364:	e0bffb15 	stw	r2,-20(fp)
   14368:	00000306 	br	14378 <udp_bind+0x104>
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
   1436c:	e0bffb17 	ldw	r2,-20(fp)
   14370:	10800317 	ldw	r2,12(r2)
   14374:	e0bffb15 	stw	r2,-20(fp)
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
   14378:	e0bffb17 	ldw	r2,-20(fp)
   1437c:	10000326 	beq	r2,zero,1438c <udp_bind+0x118>
   14380:	e0bfff0b 	ldhu	r2,-4(fp)
   14384:	109fffd8 	cmpnei	r2,r2,32767
   14388:	103fed1e 	bne	r2,zero,14340 <udp_bind+0xcc>
        ipcb = udp_pcbs;
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
    }
    if (ipcb != NULL) {
   1438c:	e0bffb17 	ldw	r2,-20(fp)
   14390:	10000226 	beq	r2,zero,1439c <udp_bind+0x128>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
   14394:	00bffd44 	movi	r2,-11
   14398:	00000b06 	br	143c8 <udp_bind+0x154>
    }
  }
  pcb->local_port = port;
   1439c:	e0bffd17 	ldw	r2,-12(fp)
   143a0:	e0ffff0b 	ldhu	r3,-4(fp)
   143a4:	10c0048d 	sth	r3,18(r2)
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
   143a8:	e0bffc03 	ldbu	r2,-16(fp)
   143ac:	1000051e 	bne	r2,zero,143c4 <udp_bind+0x150>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
   143b0:	d0e8e417 	ldw	r3,-23664(gp)
   143b4:	e0bffd17 	ldw	r2,-12(fp)
   143b8:	10c00315 	stw	r3,12(r2)
    udp_pcbs = pcb;
   143bc:	e0bffd17 	ldw	r2,-12(fp)
   143c0:	d0a8e415 	stw	r2,-23664(gp)
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               (u16_t)((ntohl(pcb->local_ip.addr) >> 24) & 0xff),
               (u16_t)((ntohl(pcb->local_ip.addr) >> 16) & 0xff),
               (u16_t)((ntohl(pcb->local_ip.addr) >> 8) & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
   143c4:	0005883a 	mov	r2,zero
}
   143c8:	e037883a 	mov	sp,fp
   143cc:	dfc00117 	ldw	ra,4(sp)
   143d0:	df000017 	ldw	fp,0(sp)
   143d4:	dec00204 	addi	sp,sp,8
   143d8:	f800283a 	ret

000143dc <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
   143dc:	defff904 	addi	sp,sp,-28
   143e0:	dfc00615 	stw	ra,24(sp)
   143e4:	df000515 	stw	fp,20(sp)
   143e8:	df000504 	addi	fp,sp,20
   143ec:	e13ffd15 	stw	r4,-12(fp)
   143f0:	e17ffe15 	stw	r5,-8(fp)
   143f4:	3005883a 	mov	r2,r6
   143f8:	e0bfff0d 	sth	r2,-4(fp)
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
   143fc:	e0bffd17 	ldw	r2,-12(fp)
   14400:	1080048b 	ldhu	r2,18(r2)
   14404:	10bfffcc 	andi	r2,r2,65535
   14408:	10000d1e 	bne	r2,zero,14440 <udp_connect+0x64>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
   1440c:	e0fffd17 	ldw	r3,-12(fp)
   14410:	e0bffd17 	ldw	r2,-12(fp)
   14414:	1080048b 	ldhu	r2,18(r2)
   14418:	10bfffcc 	andi	r2,r2,65535
   1441c:	e13ffd17 	ldw	r4,-12(fp)
   14420:	180b883a 	mov	r5,r3
   14424:	100d883a 	mov	r6,r2
   14428:	00142740 	call	14274 <udp_bind>
   1442c:	e0bffc05 	stb	r2,-16(fp)
    if (err != ERR_OK)
   14430:	e0bffc07 	ldb	r2,-16(fp)
   14434:	10000226 	beq	r2,zero,14440 <udp_connect+0x64>
      return err;
   14438:	e0bffc03 	ldbu	r2,-16(fp)
   1443c:	00002706 	br	144dc <udp_connect+0x100>
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
   14440:	e0bffe17 	ldw	r2,-8(fp)
   14444:	10000626 	beq	r2,zero,14460 <udp_connect+0x84>
   14448:	e0bffe17 	ldw	r2,-8(fp)
   1444c:	10c0000b 	ldhu	r3,0(r2)
   14450:	1080008b 	ldhu	r2,2(r2)
   14454:	1004943a 	slli	r2,r2,16
   14458:	10c4b03a 	or	r2,r2,r3
   1445c:	00000106 	br	14464 <udp_connect+0x88>
   14460:	0005883a 	mov	r2,zero
   14464:	e0fffd17 	ldw	r3,-12(fp)
   14468:	18800115 	stw	r2,4(r3)
  pcb->remote_port = port;
   1446c:	e0bffd17 	ldw	r2,-12(fp)
   14470:	e0ffff0b 	ldhu	r3,-4(fp)
   14474:	10c0050d 	sth	r3,20(r2)
  pcb->flags |= UDP_FLAGS_CONNECTED;
   14478:	e0bffd17 	ldw	r2,-12(fp)
   1447c:	10800403 	ldbu	r2,16(r2)
   14480:	10800114 	ori	r2,r2,4
   14484:	1007883a 	mov	r3,r2
   14488:	e0bffd17 	ldw	r2,-12(fp)
   1448c:	10c00405 	stb	r3,16(r2)
               (u16_t)((ntohl(pcb->remote_ip.addr) >> 16) & 0xff),
               (u16_t)((ntohl(pcb->remote_ip.addr) >> 8) & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
   14490:	d0a8e417 	ldw	r2,-23664(gp)
   14494:	e0bffb15 	stw	r2,-20(fp)
   14498:	00000806 	br	144bc <udp_connect+0xe0>
    if (pcb == ipcb) {
   1449c:	e0fffd17 	ldw	r3,-12(fp)
   144a0:	e0bffb17 	ldw	r2,-20(fp)
   144a4:	1880021e 	bne	r3,r2,144b0 <udp_connect+0xd4>
      /* already on the list, just return */
      return ERR_OK;
   144a8:	0005883a 	mov	r2,zero
   144ac:	00000b06 	br	144dc <udp_connect+0x100>
               (u16_t)((ntohl(pcb->remote_ip.addr) >> 16) & 0xff),
               (u16_t)((ntohl(pcb->remote_ip.addr) >> 8) & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
   144b0:	e0bffb17 	ldw	r2,-20(fp)
   144b4:	10800317 	ldw	r2,12(r2)
   144b8:	e0bffb15 	stw	r2,-20(fp)
   144bc:	e0bffb17 	ldw	r2,-20(fp)
   144c0:	103ff61e 	bne	r2,zero,1449c <udp_connect+0xc0>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
   144c4:	d0e8e417 	ldw	r3,-23664(gp)
   144c8:	e0bffd17 	ldw	r2,-12(fp)
   144cc:	10c00315 	stw	r3,12(r2)
  udp_pcbs = pcb;
   144d0:	e0bffd17 	ldw	r2,-12(fp)
   144d4:	d0a8e415 	stw	r2,-23664(gp)
  return ERR_OK;
   144d8:	0005883a 	mov	r2,zero
}
   144dc:	e037883a 	mov	sp,fp
   144e0:	dfc00117 	ldw	ra,4(sp)
   144e4:	df000017 	ldw	fp,0(sp)
   144e8:	dec00204 	addi	sp,sp,8
   144ec:	f800283a 	ret

000144f0 <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
   144f0:	defffe04 	addi	sp,sp,-8
   144f4:	df000115 	stw	fp,4(sp)
   144f8:	df000104 	addi	fp,sp,4
   144fc:	e13fff15 	stw	r4,-4(fp)
  /* reset remote address association */
  ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
   14500:	008000f4 	movhi	r2,3
   14504:	108d2104 	addi	r2,r2,13444
   14508:	10c0000b 	ldhu	r3,0(r2)
   1450c:	1080008b 	ldhu	r2,2(r2)
   14510:	1004943a 	slli	r2,r2,16
   14514:	10c4b03a 	or	r2,r2,r3
   14518:	1007883a 	mov	r3,r2
   1451c:	e0bfff17 	ldw	r2,-4(fp)
   14520:	10c00115 	stw	r3,4(r2)
  pcb->remote_port = 0;
   14524:	e0bfff17 	ldw	r2,-4(fp)
   14528:	1000050d 	sth	zero,20(r2)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
   1452c:	e0bfff17 	ldw	r2,-4(fp)
   14530:	10c00403 	ldbu	r3,16(r2)
   14534:	00bffec4 	movi	r2,-5
   14538:	1884703a 	and	r2,r3,r2
   1453c:	1007883a 	mov	r3,r2
   14540:	e0bfff17 	ldw	r2,-4(fp)
   14544:	10c00405 	stb	r3,16(r2)
}
   14548:	e037883a 	mov	sp,fp
   1454c:	df000017 	ldw	fp,0(sp)
   14550:	dec00104 	addi	sp,sp,4
   14554:	f800283a 	ret

00014558 <udp_recv>:
void
udp_recv(struct udp_pcb *pcb,
         void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
                       struct ip_addr *addr, u16_t port),
         void *recv_arg)
{
   14558:	defffc04 	addi	sp,sp,-16
   1455c:	df000315 	stw	fp,12(sp)
   14560:	df000304 	addi	fp,sp,12
   14564:	e13ffd15 	stw	r4,-12(fp)
   14568:	e17ffe15 	stw	r5,-8(fp)
   1456c:	e1bfff15 	stw	r6,-4(fp)
  /* remember recv() callback and user data */
  pcb->recv = recv;
   14570:	e0bffd17 	ldw	r2,-12(fp)
   14574:	e0fffe17 	ldw	r3,-8(fp)
   14578:	10c00615 	stw	r3,24(r2)
  pcb->recv_arg = recv_arg;
   1457c:	e0bffd17 	ldw	r2,-12(fp)
   14580:	e0ffff17 	ldw	r3,-4(fp)
   14584:	10c00715 	stw	r3,28(r2)
}
   14588:	e037883a 	mov	sp,fp
   1458c:	df000017 	ldw	fp,0(sp)
   14590:	dec00104 	addi	sp,sp,4
   14594:	f800283a 	ret

00014598 <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
   14598:	defffc04 	addi	sp,sp,-16
   1459c:	dfc00315 	stw	ra,12(sp)
   145a0:	df000215 	stw	fp,8(sp)
   145a4:	df000204 	addi	fp,sp,8
   145a8:	e13fff15 	stw	r4,-4(fp)
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
   145ac:	d0e8e417 	ldw	r3,-23664(gp)
   145b0:	e0bfff17 	ldw	r2,-4(fp)
   145b4:	1880041e 	bne	r3,r2,145c8 <udp_remove+0x30>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
   145b8:	d0a8e417 	ldw	r2,-23664(gp)
   145bc:	10800317 	ldw	r2,12(r2)
   145c0:	d0a8e415 	stw	r2,-23664(gp)
   145c4:	00001306 	br	14614 <udp_remove+0x7c>
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
   145c8:	d0a8e417 	ldw	r2,-23664(gp)
   145cc:	e0bffe15 	stw	r2,-8(fp)
   145d0:	00000e06 	br	1460c <udp_remove+0x74>
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
   145d4:	e0bffe17 	ldw	r2,-8(fp)
   145d8:	10800317 	ldw	r2,12(r2)
   145dc:	10000826 	beq	r2,zero,14600 <udp_remove+0x68>
   145e0:	e0bffe17 	ldw	r2,-8(fp)
   145e4:	10c00317 	ldw	r3,12(r2)
   145e8:	e0bfff17 	ldw	r2,-4(fp)
   145ec:	1880041e 	bne	r3,r2,14600 <udp_remove+0x68>
        /* remove pcb from list */
        pcb2->next = pcb->next;
   145f0:	e0bfff17 	ldw	r2,-4(fp)
   145f4:	10c00317 	ldw	r3,12(r2)
   145f8:	e0bffe17 	ldw	r2,-8(fp)
   145fc:	10c00315 	stw	r3,12(r2)
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
   14600:	e0bffe17 	ldw	r2,-8(fp)
   14604:	10800317 	ldw	r2,12(r2)
   14608:	e0bffe15 	stw	r2,-8(fp)
   1460c:	e0bffe17 	ldw	r2,-8(fp)
   14610:	103ff01e 	bne	r2,zero,145d4 <udp_remove+0x3c>
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  memp_free(MEMP_UDP_PCB, pcb);
   14614:	01000044 	movi	r4,1
   14618:	e17fff17 	ldw	r5,-4(fp)
   1461c:	00090cc0 	call	90cc <memp_free>
}
   14620:	e037883a 	mov	sp,fp
   14624:	dfc00117 	ldw	ra,4(sp)
   14628:	df000017 	ldw	fp,0(sp)
   1462c:	dec00204 	addi	sp,sp,8
   14630:	f800283a 	ret

00014634 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
   14634:	defffd04 	addi	sp,sp,-12
   14638:	dfc00215 	stw	ra,8(sp)
   1463c:	df000115 	stw	fp,4(sp)
   14640:	df000104 	addi	fp,sp,4
  struct udp_pcb *pcb;
  pcb = memp_malloc(MEMP_UDP_PCB);
   14644:	01000044 	movi	r4,1
   14648:	0008ef00 	call	8ef0 <memp_malloc>
   1464c:	e0bfff15 	stw	r2,-4(fp)
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
   14650:	e0bfff17 	ldw	r2,-4(fp)
   14654:	10000726 	beq	r2,zero,14674 <udp_new+0x40>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
   14658:	e13fff17 	ldw	r4,-4(fp)
   1465c:	000b883a 	mov	r5,zero
   14660:	01800804 	movi	r6,32
   14664:	00165b80 	call	165b8 <memset>
    pcb->ttl = UDP_TTL;
   14668:	e0bfff17 	ldw	r2,-4(fp)
   1466c:	00ffffc4 	movi	r3,-1
   14670:	10c002c5 	stb	r3,11(r2)
  }
  return pcb;
   14674:	e0bfff17 	ldw	r2,-4(fp)
}
   14678:	e037883a 	mov	sp,fp
   1467c:	dfc00117 	ldw	ra,4(sp)
   14680:	df000017 	ldw	fp,0(sp)
   14684:	dec00204 	addi	sp,sp,8
   14688:	f800283a 	ret

0001468c <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
   1468c:	defffc04 	addi	sp,sp,-16
   14690:	dfc00315 	stw	ra,12(sp)
   14694:	df000215 	stw	fp,8(sp)
   14698:	df000204 	addi	fp,sp,8
   1469c:	e13fff15 	stw	r4,-4(fp)
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
   146a0:	e0bfff17 	ldw	r2,-4(fp)
   146a4:	1000091e 	bne	r2,zero,146cc <free_etharp_q+0x40>
   146a8:	010000f4 	movhi	r4,3
   146ac:	213b8204 	addi	r4,r4,-4600
   146b0:	014000f4 	movhi	r5,3
   146b4:	297b8c04 	addi	r5,r5,-4560
   146b8:	01802484 	movi	r6,146
   146bc:	01c000f4 	movhi	r7,3
   146c0:	39fb8f04 	addi	r7,r7,-4548
   146c4:	00166c00 	call	166c0 <printf>
   146c8:	003fff06 	br	146c8 <free_etharp_q+0x3c>
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
   146cc:	e0bfff17 	ldw	r2,-4(fp)
   146d0:	10800117 	ldw	r2,4(r2)
   146d4:	1000211e 	bne	r2,zero,1475c <free_etharp_q+0xd0>
   146d8:	010000f4 	movhi	r4,3
   146dc:	213b8204 	addi	r4,r4,-4600
   146e0:	014000f4 	movhi	r5,3
   146e4:	297b9504 	addi	r5,r5,-4524
   146e8:	018024c4 	movi	r6,147
   146ec:	01c000f4 	movhi	r7,3
   146f0:	39fb8f04 	addi	r7,r7,-4548
   146f4:	00166c00 	call	166c0 <printf>
   146f8:	003fff06 	br	146f8 <free_etharp_q+0x6c>
  while (q) {
    r = q;
   146fc:	e0bfff17 	ldw	r2,-4(fp)
   14700:	e0bffe15 	stw	r2,-8(fp)
    q = q->next;
   14704:	e0bfff17 	ldw	r2,-4(fp)
   14708:	10800017 	ldw	r2,0(r2)
   1470c:	e0bfff15 	stw	r2,-4(fp)
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
   14710:	e0bffe17 	ldw	r2,-8(fp)
   14714:	10800117 	ldw	r2,4(r2)
   14718:	1000091e 	bne	r2,zero,14740 <free_etharp_q+0xb4>
   1471c:	010000f4 	movhi	r4,3
   14720:	213b8204 	addi	r4,r4,-4600
   14724:	014000f4 	movhi	r5,3
   14728:	297b9904 	addi	r5,r5,-4508
   1472c:	018025c4 	movi	r6,151
   14730:	01c000f4 	movhi	r7,3
   14734:	39fb8f04 	addi	r7,r7,-4548
   14738:	00166c00 	call	166c0 <printf>
   1473c:	003fff06 	br	1473c <free_etharp_q+0xb0>
    pbuf_free(r->p);
   14740:	e0bffe17 	ldw	r2,-8(fp)
   14744:	10800117 	ldw	r2,4(r2)
   14748:	1009883a 	mov	r4,r2
   1474c:	000a16c0 	call	a16c <pbuf_free>
    memp_free(MEMP_ARP_QUEUE, r);
   14750:	01000184 	movi	r4,6
   14754:	e17ffe17 	ldw	r5,-8(fp)
   14758:	00090cc0 	call	90cc <memp_free>
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
   1475c:	e0bfff17 	ldw	r2,-4(fp)
   14760:	103fe61e 	bne	r2,zero,146fc <free_etharp_q+0x70>
    q = q->next;
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
    memp_free(MEMP_ARP_QUEUE, r);
  }
}
   14764:	e037883a 	mov	sp,fp
   14768:	dfc00117 	ldw	ra,4(sp)
   1476c:	df000017 	ldw	fp,0(sp)
   14770:	dec00204 	addi	sp,sp,8
   14774:	f800283a 	ret

00014778 <etharp_tmr>:
 * This function should be called every ETHARP_TMR_INTERVAL microseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
   14778:	defffd04 	addi	sp,sp,-12
   1477c:	dfc00215 	stw	ra,8(sp)
   14780:	df000115 	stw	fp,4(sp)
   14784:	df000104 	addi	fp,sp,4
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
   14788:	e03fff05 	stb	zero,-4(fp)
   1478c:	00005306 	br	148dc <etharp_tmr+0x164>
    arp_table[i].ctime++;
   14790:	e0bfff03 	ldbu	r2,-4(fp)
   14794:	01000134 	movhi	r4,4
   14798:	210cff04 	addi	r4,r4,13308
   1479c:	10c00724 	muli	r3,r2,28
   147a0:	20c7883a 	add	r3,r4,r3
   147a4:	18c00504 	addi	r3,r3,20
   147a8:	18c00003 	ldbu	r3,0(r3)
   147ac:	18c00044 	addi	r3,r3,1
   147b0:	01000134 	movhi	r4,4
   147b4:	210cff04 	addi	r4,r4,13308
   147b8:	10800724 	muli	r2,r2,28
   147bc:	2085883a 	add	r2,r4,r2
   147c0:	10800504 	addi	r2,r2,20
   147c4:	10c00005 	stb	r3,0(r2)
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
   147c8:	e0bfff03 	ldbu	r2,-4(fp)
   147cc:	00c00134 	movhi	r3,4
   147d0:	18ccff04 	addi	r3,r3,13308
   147d4:	10800724 	muli	r2,r2,28
   147d8:	1885883a 	add	r2,r3,r2
   147dc:	10800404 	addi	r2,r2,16
   147e0:	10800017 	ldw	r2,0(r2)
   147e4:	10800098 	cmpnei	r2,r2,2
   147e8:	10000a1e 	bne	r2,zero,14814 <etharp_tmr+0x9c>
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
   147ec:	e0bfff03 	ldbu	r2,-4(fp)
   147f0:	00c00134 	movhi	r3,4
   147f4:	18ccff04 	addi	r3,r3,13308
   147f8:	10800724 	muli	r2,r2,28
   147fc:	1885883a 	add	r2,r3,r2
   14800:	10800504 	addi	r2,r2,20
   14804:	10800003 	ldbu	r2,0(r2)

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
   14808:	10803fcc 	andi	r2,r2,255
   1480c:	10803c28 	cmpgeui	r2,r2,240
   14810:	1000131e 	bne	r2,zero,14860 <etharp_tmr+0xe8>
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
   14814:	e0bfff03 	ldbu	r2,-4(fp)
   14818:	00c00134 	movhi	r3,4
   1481c:	18ccff04 	addi	r3,r3,13308
   14820:	10800724 	muli	r2,r2,28
   14824:	1885883a 	add	r2,r3,r2
   14828:	10800404 	addi	r2,r2,16
   1482c:	10800017 	ldw	r2,0(r2)
  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
   14830:	10800058 	cmpnei	r2,r2,1
   14834:	1000261e 	bne	r2,zero,148d0 <etharp_tmr+0x158>
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
         (arp_table[i].ctime >= ARP_MAXPENDING))) {
   14838:	e0bfff03 	ldbu	r2,-4(fp)
   1483c:	00c00134 	movhi	r3,4
   14840:	18ccff04 	addi	r3,r3,13308
   14844:	10800724 	muli	r2,r2,28
   14848:	1885883a 	add	r2,r3,r2
   1484c:	10800504 	addi	r2,r2,20
   14850:	10800003 	ldbu	r2,0(r2)
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
   14854:	10803fcc 	andi	r2,r2,255
   14858:	108000b0 	cmpltui	r2,r2,2
   1485c:	10001c1e 	bne	r2,zero,148d0 <etharp_tmr+0x158>
      /* clean up entries that have just been expired */
      /* remove from SNMP ARP index tree */
      snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
#if ARP_QUEUEING
      /* and empty packet queue */
      if (arp_table[i].q != NULL) {
   14860:	e0bfff03 	ldbu	r2,-4(fp)
   14864:	00c00134 	movhi	r3,4
   14868:	18ccff04 	addi	r3,r3,13308
   1486c:	10800724 	muli	r2,r2,28
   14870:	1885883a 	add	r2,r3,r2
   14874:	10800017 	ldw	r2,0(r2)
   14878:	10000e26 	beq	r2,zero,148b4 <etharp_tmr+0x13c>
        /* remove all queued packets */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
        free_etharp_q(arp_table[i].q);
   1487c:	e0bfff03 	ldbu	r2,-4(fp)
   14880:	00c00134 	movhi	r3,4
   14884:	18ccff04 	addi	r3,r3,13308
   14888:	10800724 	muli	r2,r2,28
   1488c:	1885883a 	add	r2,r3,r2
   14890:	10800017 	ldw	r2,0(r2)
   14894:	1009883a 	mov	r4,r2
   14898:	001468c0 	call	1468c <free_etharp_q>
        arp_table[i].q = NULL;
   1489c:	e0bfff03 	ldbu	r2,-4(fp)
   148a0:	00c00134 	movhi	r3,4
   148a4:	18ccff04 	addi	r3,r3,13308
   148a8:	10800724 	muli	r2,r2,28
   148ac:	1885883a 	add	r2,r3,r2
   148b0:	10000015 	stw	zero,0(r2)
      }
#endif
      /* recycle entry for re-use */      
      arp_table[i].state = ETHARP_STATE_EMPTY;
   148b4:	e0bfff03 	ldbu	r2,-4(fp)
   148b8:	00c00134 	movhi	r3,4
   148bc:	18ccff04 	addi	r3,r3,13308
   148c0:	10800724 	muli	r2,r2,28
   148c4:	1885883a 	add	r2,r3,r2
   148c8:	10800404 	addi	r2,r2,16
   148cc:	10000015 	stw	zero,0(r2)
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
   148d0:	e0bfff03 	ldbu	r2,-4(fp)
   148d4:	10800044 	addi	r2,r2,1
   148d8:	e0bfff05 	stb	r2,-4(fp)
   148dc:	e0bfff03 	ldbu	r2,-4(fp)
   148e0:	108002b0 	cmpltui	r2,r2,10
   148e4:	103faa1e 	bne	r2,zero,14790 <etharp_tmr+0x18>
    if (arp_table[i].state == ETHARP_STATE_PENDING) {
        /* resend an ARP query here? */
    }
#endif
  }
}
   148e8:	e037883a 	mov	sp,fp
   148ec:	dfc00117 	ldw	ra,4(sp)
   148f0:	df000017 	ldw	fp,0(sp)
   148f4:	dec00204 	addi	sp,sp,8
   148f8:	f800283a 	ret

000148fc <find_entry>:
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
   148fc:	defffa04 	addi	sp,sp,-24
   14900:	dfc00515 	stw	ra,20(sp)
   14904:	df000415 	stw	fp,16(sp)
   14908:	df000404 	addi	fp,sp,16
   1490c:	e13ffe15 	stw	r4,-8(fp)
   14910:	2805883a 	mov	r2,r5
   14914:	e0bfff05 	stb	r2,-4(fp)
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
   14918:	00800284 	movi	r2,10
   1491c:	e0bffc05 	stb	r2,-16(fp)
   14920:	00800284 	movi	r2,10
   14924:	e0bffc45 	stb	r2,-15(fp)
  s8_t empty = ARP_TABLE_SIZE;
   14928:	00800284 	movi	r2,10
   1492c:	e0bffc85 	stb	r2,-14(fp)
  u8_t i = 0, age_pending = 0, age_stable = 0;
   14930:	e03ffcc5 	stb	zero,-13(fp)
   14934:	e03ffd05 	stb	zero,-12(fp)
   14938:	e03ffd45 	stb	zero,-11(fp)
#if ARP_QUEUEING
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
   1493c:	00800284 	movi	r2,10
   14940:	e0bffd85 	stb	r2,-10(fp)
  /* its age */
  u8_t age_queue = 0;
   14944:	e03ffdc5 	stb	zero,-9(fp)
#endif

  /* First, test if the last call to this function asked for the
   * same address. If so, we're really fast! */
  if (ipaddr) {
   14948:	e0bffe17 	ldw	r2,-8(fp)
   1494c:	10002326 	beq	r2,zero,149dc <find_entry+0xe0>
          return per_pcb_cache;
        }
      }
    }
#else /* #if LWIP_NETIF_HWADDRHINT */
    if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
   14950:	d0a8e503 	ldbu	r2,-23660(gp)
   14954:	10803fcc 	andi	r2,r2,255
   14958:	00c00134 	movhi	r3,4
   1495c:	18ccff04 	addi	r3,r3,13308
   14960:	10800724 	muli	r2,r2,28
   14964:	1885883a 	add	r2,r3,r2
   14968:	10800404 	addi	r2,r2,16
   1496c:	10800017 	ldw	r2,0(r2)
   14970:	10800098 	cmpnei	r2,r2,2
   14974:	1000191e 	bne	r2,zero,149dc <find_entry+0xe0>
      /* the cached entry is stable */
      if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
   14978:	e0bffe17 	ldw	r2,-8(fp)
   1497c:	10c0000b 	ldhu	r3,0(r2)
   14980:	1080008b 	ldhu	r2,2(r2)
   14984:	1004943a 	slli	r2,r2,16
   14988:	10c4b03a 	or	r2,r2,r3
   1498c:	1007883a 	mov	r3,r2
   14990:	d0a8e503 	ldbu	r2,-23660(gp)
   14994:	10803fcc 	andi	r2,r2,255
   14998:	01000134 	movhi	r4,4
   1499c:	210cff04 	addi	r4,r4,13308
   149a0:	10800724 	muli	r2,r2,28
   149a4:	2085883a 	add	r2,r4,r2
   149a8:	10800104 	addi	r2,r2,4
   149ac:	10800017 	ldw	r2,0(r2)
   149b0:	18800a1e 	bne	r3,r2,149dc <find_entry+0xe0>
        /* cached entry was the right one! */
        ETHARP_STATS_INC(etharp.cachehit);
   149b4:	00800134 	movhi	r2,4
   149b8:	108d9504 	addi	r2,r2,13908
   149bc:	10800b8b 	ldhu	r2,46(r2)
   149c0:	10800044 	addi	r2,r2,1
   149c4:	1007883a 	mov	r3,r2
   149c8:	00800134 	movhi	r2,4
   149cc:	108d9504 	addi	r2,r2,13908
   149d0:	10c00b8d 	sth	r3,46(r2)
        return etharp_cached_entry;
   149d4:	d0a8e503 	ldbu	r2,-23660(gp)
   149d8:	00010606 	br	14df4 <find_entry+0x4f8>
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
   149dc:	e03ffcc5 	stb	zero,-13(fp)
   149e0:	00009006 	br	14c24 <find_entry+0x328>
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
   149e4:	e0bffc87 	ldb	r2,-14(fp)
   149e8:	10800298 	cmpnei	r2,r2,10
   149ec:	10000b1e 	bne	r2,zero,14a1c <find_entry+0x120>
   149f0:	e0bffcc3 	ldbu	r2,-13(fp)
   149f4:	00c00134 	movhi	r3,4
   149f8:	18ccff04 	addi	r3,r3,13308
   149fc:	10800724 	muli	r2,r2,28
   14a00:	1885883a 	add	r2,r3,r2
   14a04:	10800404 	addi	r2,r2,16
   14a08:	10800017 	ldw	r2,0(r2)
   14a0c:	1000031e 	bne	r2,zero,14a1c <find_entry+0x120>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
   14a10:	e0bffcc3 	ldbu	r2,-13(fp)
   14a14:	e0bffc85 	stb	r2,-14(fp)
   14a18:	00007f06 	br	14c18 <find_entry+0x31c>
    }
    /* pending entry? */
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
   14a1c:	e0bffcc3 	ldbu	r2,-13(fp)
   14a20:	00c00134 	movhi	r3,4
   14a24:	18ccff04 	addi	r3,r3,13308
   14a28:	10800724 	muli	r2,r2,28
   14a2c:	1885883a 	add	r2,r3,r2
   14a30:	10800404 	addi	r2,r2,16
   14a34:	10800017 	ldw	r2,0(r2)
   14a38:	10800058 	cmpnei	r2,r2,1
   14a3c:	1000451e 	bne	r2,zero,14b54 <find_entry+0x258>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
   14a40:	e0bffe17 	ldw	r2,-8(fp)
   14a44:	10001226 	beq	r2,zero,14a90 <find_entry+0x194>
   14a48:	e0bffe17 	ldw	r2,-8(fp)
   14a4c:	10c0000b 	ldhu	r3,0(r2)
   14a50:	1080008b 	ldhu	r2,2(r2)
   14a54:	1004943a 	slli	r2,r2,16
   14a58:	10c4b03a 	or	r2,r2,r3
   14a5c:	1007883a 	mov	r3,r2
   14a60:	e0bffcc3 	ldbu	r2,-13(fp)
   14a64:	01000134 	movhi	r4,4
   14a68:	210cff04 	addi	r4,r4,13308
   14a6c:	10800724 	muli	r2,r2,28
   14a70:	2085883a 	add	r2,r4,r2
   14a74:	10800104 	addi	r2,r2,4
   14a78:	10800017 	ldw	r2,0(r2)
   14a7c:	1880041e 	bne	r3,r2,14a90 <find_entry+0x194>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching pending entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
   14a80:	e0bffcc3 	ldbu	r2,-13(fp)
   14a84:	d0a8e505 	stb	r2,-23660(gp)
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
   14a88:	e0bffcc3 	ldbu	r2,-13(fp)
   14a8c:	0000d906 	br	14df4 <find_entry+0x4f8>
#if ARP_QUEUEING
      /* pending with queued packets? */
      } else if (arp_table[i].q != NULL) {
   14a90:	e0bffcc3 	ldbu	r2,-13(fp)
   14a94:	00c00134 	movhi	r3,4
   14a98:	18ccff04 	addi	r3,r3,13308
   14a9c:	10800724 	muli	r2,r2,28
   14aa0:	1885883a 	add	r2,r3,r2
   14aa4:	10800017 	ldw	r2,0(r2)
   14aa8:	10001526 	beq	r2,zero,14b00 <find_entry+0x204>
        if (arp_table[i].ctime >= age_queue) {
   14aac:	e0bffcc3 	ldbu	r2,-13(fp)
   14ab0:	00c00134 	movhi	r3,4
   14ab4:	18ccff04 	addi	r3,r3,13308
   14ab8:	10800724 	muli	r2,r2,28
   14abc:	1885883a 	add	r2,r3,r2
   14ac0:	10800504 	addi	r2,r2,20
   14ac4:	10800003 	ldbu	r2,0(r2)
   14ac8:	10c03fcc 	andi	r3,r2,255
   14acc:	e0bffdc3 	ldbu	r2,-9(fp)
   14ad0:	18805136 	bltu	r3,r2,14c18 <find_entry+0x31c>
          old_queue = i;
   14ad4:	e0bffcc3 	ldbu	r2,-13(fp)
   14ad8:	e0bffd85 	stb	r2,-10(fp)
          age_queue = arp_table[i].ctime;
   14adc:	e0bffcc3 	ldbu	r2,-13(fp)
   14ae0:	00c00134 	movhi	r3,4
   14ae4:	18ccff04 	addi	r3,r3,13308
   14ae8:	10800724 	muli	r2,r2,28
   14aec:	1885883a 	add	r2,r3,r2
   14af0:	10800504 	addi	r2,r2,20
   14af4:	10800003 	ldbu	r2,0(r2)
   14af8:	e0bffdc5 	stb	r2,-9(fp)
   14afc:	00004606 	br	14c18 <find_entry+0x31c>
        }
#endif
      /* pending without queued packets? */
      } else {
        if (arp_table[i].ctime >= age_pending) {
   14b00:	e0bffcc3 	ldbu	r2,-13(fp)
   14b04:	00c00134 	movhi	r3,4
   14b08:	18ccff04 	addi	r3,r3,13308
   14b0c:	10800724 	muli	r2,r2,28
   14b10:	1885883a 	add	r2,r3,r2
   14b14:	10800504 	addi	r2,r2,20
   14b18:	10800003 	ldbu	r2,0(r2)
   14b1c:	10c03fcc 	andi	r3,r2,255
   14b20:	e0bffd03 	ldbu	r2,-12(fp)
   14b24:	18803c36 	bltu	r3,r2,14c18 <find_entry+0x31c>
          old_pending = i;
   14b28:	e0bffcc3 	ldbu	r2,-13(fp)
   14b2c:	e0bffc05 	stb	r2,-16(fp)
          age_pending = arp_table[i].ctime;
   14b30:	e0bffcc3 	ldbu	r2,-13(fp)
   14b34:	00c00134 	movhi	r3,4
   14b38:	18ccff04 	addi	r3,r3,13308
   14b3c:	10800724 	muli	r2,r2,28
   14b40:	1885883a 	add	r2,r3,r2
   14b44:	10800504 	addi	r2,r2,20
   14b48:	10800003 	ldbu	r2,0(r2)
   14b4c:	e0bffd05 	stb	r2,-12(fp)
   14b50:	00003106 	br	14c18 <find_entry+0x31c>
        }
      }        
    }
    /* stable entry? */
    else if (arp_table[i].state == ETHARP_STATE_STABLE) {
   14b54:	e0bffcc3 	ldbu	r2,-13(fp)
   14b58:	00c00134 	movhi	r3,4
   14b5c:	18ccff04 	addi	r3,r3,13308
   14b60:	10800724 	muli	r2,r2,28
   14b64:	1885883a 	add	r2,r3,r2
   14b68:	10800404 	addi	r2,r2,16
   14b6c:	10800017 	ldw	r2,0(r2)
   14b70:	10800098 	cmpnei	r2,r2,2
   14b74:	1000281e 	bne	r2,zero,14c18 <find_entry+0x31c>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
   14b78:	e0bffe17 	ldw	r2,-8(fp)
   14b7c:	10001226 	beq	r2,zero,14bc8 <find_entry+0x2cc>
   14b80:	e0bffe17 	ldw	r2,-8(fp)
   14b84:	10c0000b 	ldhu	r3,0(r2)
   14b88:	1080008b 	ldhu	r2,2(r2)
   14b8c:	1004943a 	slli	r2,r2,16
   14b90:	10c4b03a 	or	r2,r2,r3
   14b94:	1007883a 	mov	r3,r2
   14b98:	e0bffcc3 	ldbu	r2,-13(fp)
   14b9c:	01000134 	movhi	r4,4
   14ba0:	210cff04 	addi	r4,r4,13308
   14ba4:	10800724 	muli	r2,r2,28
   14ba8:	2085883a 	add	r2,r4,r2
   14bac:	10800104 	addi	r2,r2,4
   14bb0:	10800017 	ldw	r2,0(r2)
   14bb4:	1880041e 	bne	r3,r2,14bc8 <find_entry+0x2cc>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching stable entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
   14bb8:	e0bffcc3 	ldbu	r2,-13(fp)
   14bbc:	d0a8e505 	stb	r2,-23660(gp)
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
   14bc0:	e0bffcc3 	ldbu	r2,-13(fp)
   14bc4:	00008b06 	br	14df4 <find_entry+0x4f8>
      /* remember entry with oldest stable entry in oldest, its age in maxtime */
      } else if (arp_table[i].ctime >= age_stable) {
   14bc8:	e0bffcc3 	ldbu	r2,-13(fp)
   14bcc:	00c00134 	movhi	r3,4
   14bd0:	18ccff04 	addi	r3,r3,13308
   14bd4:	10800724 	muli	r2,r2,28
   14bd8:	1885883a 	add	r2,r3,r2
   14bdc:	10800504 	addi	r2,r2,20
   14be0:	10800003 	ldbu	r2,0(r2)
   14be4:	10c03fcc 	andi	r3,r2,255
   14be8:	e0bffd43 	ldbu	r2,-11(fp)
   14bec:	18800a36 	bltu	r3,r2,14c18 <find_entry+0x31c>
        old_stable = i;
   14bf0:	e0bffcc3 	ldbu	r2,-13(fp)
   14bf4:	e0bffc45 	stb	r2,-15(fp)
        age_stable = arp_table[i].ctime;
   14bf8:	e0bffcc3 	ldbu	r2,-13(fp)
   14bfc:	00c00134 	movhi	r3,4
   14c00:	18ccff04 	addi	r3,r3,13308
   14c04:	10800724 	muli	r2,r2,28
   14c08:	1885883a 	add	r2,r3,r2
   14c0c:	10800504 	addi	r2,r2,20
   14c10:	10800003 	ldbu	r2,0(r2)
   14c14:	e0bffd45 	stb	r2,-11(fp)
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
   14c18:	e0bffcc3 	ldbu	r2,-13(fp)
   14c1c:	10800044 	addi	r2,r2,1
   14c20:	e0bffcc5 	stb	r2,-13(fp)
   14c24:	e0bffcc3 	ldbu	r2,-13(fp)
   14c28:	108002b0 	cmpltui	r2,r2,10
   14c2c:	103f6d1e 	bne	r2,zero,149e4 <find_entry+0xe8>
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
   14c30:	e0bffc87 	ldb	r2,-14(fp)
   14c34:	10800298 	cmpnei	r2,r2,10
   14c38:	1000031e 	bne	r2,zero,14c48 <find_entry+0x34c>
   14c3c:	e0bfff03 	ldbu	r2,-4(fp)
   14c40:	1080004c 	andi	r2,r2,1
   14c44:	10000326 	beq	r2,zero,14c54 <find_entry+0x358>
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
   14c48:	e0bfff03 	ldbu	r2,-4(fp)
   14c4c:	1080008c 	andi	r2,r2,2
   14c50:	10000226 	beq	r2,zero,14c5c <find_entry+0x360>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
   14c54:	00bfffc4 	movi	r2,-1
   14c58:	00006606 	br	14df4 <find_entry+0x4f8>
   * 
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
   14c5c:	e0bffc87 	ldb	r2,-14(fp)
   14c60:	10800288 	cmpgei	r2,r2,10
   14c64:	1000031e 	bne	r2,zero,14c74 <find_entry+0x378>
    i = empty;
   14c68:	e0bffc83 	ldbu	r2,-14(fp)
   14c6c:	e0bffcc5 	stb	r2,-13(fp)
   14c70:	00003106 	br	14d38 <find_entry+0x43c>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  }
  /* 2) found recyclable stable entry? */
  else if (old_stable < ARP_TABLE_SIZE) {
   14c74:	e0bffc47 	ldb	r2,-15(fp)
   14c78:	10800288 	cmpgei	r2,r2,10
   14c7c:	1000121e 	bne	r2,zero,14cc8 <find_entry+0x3cc>
    /* recycle oldest stable*/
    i = old_stable;
   14c80:	e0bffc43 	ldbu	r2,-15(fp)
   14c84:	e0bffcc5 	stb	r2,-13(fp)
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
#if ARP_QUEUEING
    /* no queued packets should exist on stable entries */
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
   14c88:	e0bffcc3 	ldbu	r2,-13(fp)
   14c8c:	00c00134 	movhi	r3,4
   14c90:	18ccff04 	addi	r3,r3,13308
   14c94:	10800724 	muli	r2,r2,28
   14c98:	1885883a 	add	r2,r3,r2
   14c9c:	10800017 	ldw	r2,0(r2)
   14ca0:	10002526 	beq	r2,zero,14d38 <find_entry+0x43c>
   14ca4:	010000f4 	movhi	r4,3
   14ca8:	213b8204 	addi	r4,r4,-4600
   14cac:	014000f4 	movhi	r5,3
   14cb0:	297b9d04 	addi	r5,r5,-4492
   14cb4:	01805d04 	movi	r6,372
   14cb8:	01c000f4 	movhi	r7,3
   14cbc:	39fb8f04 	addi	r7,r7,-4548
   14cc0:	00166c00 	call	166c0 <printf>
   14cc4:	003fff06 	br	14cc4 <find_entry+0x3c8>
#endif
  /* 3) found recyclable pending entry without queued packets? */
  } else if (old_pending < ARP_TABLE_SIZE) {
   14cc8:	e0bffc07 	ldb	r2,-16(fp)
   14ccc:	10800288 	cmpgei	r2,r2,10
   14cd0:	1000031e 	bne	r2,zero,14ce0 <find_entry+0x3e4>
    /* recycle oldest pending */
    i = old_pending;
   14cd4:	e0bffc03 	ldbu	r2,-16(fp)
   14cd8:	e0bffcc5 	stb	r2,-13(fp)
   14cdc:	00001606 	br	14d38 <find_entry+0x43c>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
#if ARP_QUEUEING
  /* 4) found recyclable pending entry with queued packets? */
  } else if (old_queue < ARP_TABLE_SIZE) {
   14ce0:	e0bffd87 	ldb	r2,-10(fp)
   14ce4:	10800288 	cmpgei	r2,r2,10
   14ce8:	1000111e 	bne	r2,zero,14d30 <find_entry+0x434>
    /* recycle oldest pending */
    i = old_queue;
   14cec:	e0bffd83 	ldbu	r2,-10(fp)
   14cf0:	e0bffcc5 	stb	r2,-13(fp)
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
   14cf4:	e0bffcc3 	ldbu	r2,-13(fp)
   14cf8:	00c00134 	movhi	r3,4
   14cfc:	18ccff04 	addi	r3,r3,13308
   14d00:	10800724 	muli	r2,r2,28
   14d04:	1885883a 	add	r2,r3,r2
   14d08:	10800017 	ldw	r2,0(r2)
   14d0c:	1009883a 	mov	r4,r2
   14d10:	001468c0 	call	1468c <free_etharp_q>
    arp_table[i].q = NULL;
   14d14:	e0bffcc3 	ldbu	r2,-13(fp)
   14d18:	00c00134 	movhi	r3,4
   14d1c:	18ccff04 	addi	r3,r3,13308
   14d20:	10800724 	muli	r2,r2,28
   14d24:	1885883a 	add	r2,r3,r2
   14d28:	10000015 	stw	zero,0(r2)
   14d2c:	00000206 	br	14d38 <find_entry+0x43c>
#endif
    /* no empty or recyclable entries found */
  } else {
    return (s8_t)ERR_MEM;
   14d30:	00bfffc4 	movi	r2,-1
   14d34:	00002f06 	br	14df4 <find_entry+0x4f8>
  }

  /* { empty or recyclable entry found } */
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
   14d38:	e0bffcc3 	ldbu	r2,-13(fp)
   14d3c:	108002b0 	cmpltui	r2,r2,10
   14d40:	1000091e 	bne	r2,zero,14d68 <find_entry+0x46c>
   14d44:	010000f4 	movhi	r4,3
   14d48:	213b8204 	addi	r4,r4,-4600
   14d4c:	014000f4 	movhi	r5,3
   14d50:	297ba304 	addi	r5,r5,-4468
   14d54:	01806284 	movi	r6,394
   14d58:	01c000f4 	movhi	r7,3
   14d5c:	39fb8f04 	addi	r7,r7,-4548
   14d60:	00166c00 	call	166c0 <printf>
   14d64:	003fff06 	br	14d64 <find_entry+0x468>
  if (arp_table[i].state != ETHARP_STATE_EMPTY)
  {
    snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  }
  /* recycle entry (no-op for an already empty entry) */
  arp_table[i].state = ETHARP_STATE_EMPTY;
   14d68:	e0bffcc3 	ldbu	r2,-13(fp)
   14d6c:	00c00134 	movhi	r3,4
   14d70:	18ccff04 	addi	r3,r3,13308
   14d74:	10800724 	muli	r2,r2,28
   14d78:	1885883a 	add	r2,r3,r2
   14d7c:	10800404 	addi	r2,r2,16
   14d80:	10000015 	stw	zero,0(r2)

  /* IP address given? */
  if (ipaddr != NULL) {
   14d84:	e0bffe17 	ldw	r2,-8(fp)
   14d88:	10001026 	beq	r2,zero,14dcc <find_entry+0x4d0>
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
   14d8c:	e0fffcc3 	ldbu	r3,-13(fp)
   14d90:	e0bffe17 	ldw	r2,-8(fp)
   14d94:	10000626 	beq	r2,zero,14db0 <find_entry+0x4b4>
   14d98:	e0bffe17 	ldw	r2,-8(fp)
   14d9c:	1100000b 	ldhu	r4,0(r2)
   14da0:	1080008b 	ldhu	r2,2(r2)
   14da4:	1004943a 	slli	r2,r2,16
   14da8:	1104b03a 	or	r2,r2,r4
   14dac:	00000106 	br	14db4 <find_entry+0x4b8>
   14db0:	0005883a 	mov	r2,zero
   14db4:	01000134 	movhi	r4,4
   14db8:	210cff04 	addi	r4,r4,13308
   14dbc:	18c00724 	muli	r3,r3,28
   14dc0:	20c7883a 	add	r3,r4,r3
   14dc4:	18c00104 	addi	r3,r3,4
   14dc8:	18800015 	stw	r2,0(r3)
  }
  arp_table[i].ctime = 0;
   14dcc:	e0bffcc3 	ldbu	r2,-13(fp)
   14dd0:	00c00134 	movhi	r3,4
   14dd4:	18ccff04 	addi	r3,r3,13308
   14dd8:	10800724 	muli	r2,r2,28
   14ddc:	1885883a 	add	r2,r3,r2
   14de0:	10800504 	addi	r2,r2,20
   14de4:	10000005 	stb	zero,0(r2)
#if LWIP_NETIF_HWADDRHINT
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
   14de8:	e0bffcc3 	ldbu	r2,-13(fp)
   14dec:	d0a8e505 	stb	r2,-23660(gp)
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
   14df0:	e0bffcc3 	ldbu	r2,-13(fp)
}
   14df4:	e037883a 	mov	sp,fp
   14df8:	dfc00117 	ldw	ra,4(sp)
   14dfc:	df000017 	ldw	fp,0(sp)
   14e00:	dec00204 	addi	sp,sp,8
   14e04:	f800283a 	ret

00014e08 <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
   14e08:	defff804 	addi	sp,sp,-32
   14e0c:	dfc00715 	stw	ra,28(sp)
   14e10:	df000615 	stw	fp,24(sp)
   14e14:	df000604 	addi	fp,sp,24
   14e18:	e13ffc15 	stw	r4,-16(fp)
   14e1c:	e17ffd15 	stw	r5,-12(fp)
   14e20:	e1bffe15 	stw	r6,-8(fp)
   14e24:	e1ffff15 	stw	r7,-4(fp)
  struct eth_hdr *ethhdr = p->payload;
   14e28:	e0bffd17 	ldw	r2,-12(fp)
   14e2c:	10800117 	ldw	r2,4(r2)
   14e30:	e0bffb15 	stw	r2,-20(fp)
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
   14e34:	e0bffc17 	ldw	r2,-16(fp)
   14e38:	10800983 	ldbu	r2,38(r2)
   14e3c:	10803fcc 	andi	r2,r2,255
   14e40:	108001a0 	cmpeqi	r2,r2,6
   14e44:	1000091e 	bne	r2,zero,14e6c <etharp_send_ip+0x64>
   14e48:	010000f4 	movhi	r4,3
   14e4c:	213b8204 	addi	r4,r4,-4600
   14e50:	014000f4 	movhi	r5,3
   14e54:	297ba804 	addi	r5,r5,-4448
   14e58:	01806c84 	movi	r6,434
   14e5c:	01c000f4 	movhi	r7,3
   14e60:	39fb8f04 	addi	r7,r7,-4548
   14e64:	00166c00 	call	166c0 <printf>
   14e68:	003fff06 	br	14e68 <etharp_send_ip+0x60>
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
   14e6c:	00800184 	movi	r2,6
   14e70:	e0bffa05 	stb	r2,-24(fp)
  while(k > 0) {
   14e74:	00001406 	br	14ec8 <etharp_send_ip+0xc0>
    k--;
   14e78:	e0bffa03 	ldbu	r2,-24(fp)
   14e7c:	10bfffc4 	addi	r2,r2,-1
   14e80:	e0bffa05 	stb	r2,-24(fp)
    ethhdr->dest.addr[k] = dst->addr[k];
   14e84:	e0bffa03 	ldbu	r2,-24(fp)
   14e88:	e0fffa03 	ldbu	r3,-24(fp)
   14e8c:	e13fff17 	ldw	r4,-4(fp)
   14e90:	20c7883a 	add	r3,r4,r3
   14e94:	18c00003 	ldbu	r3,0(r3)
   14e98:	e13ffb17 	ldw	r4,-20(fp)
   14e9c:	2085883a 	add	r2,r4,r2
   14ea0:	10c00085 	stb	r3,2(r2)
    ethhdr->src.addr[k]  = src->addr[k];
   14ea4:	e0bffa03 	ldbu	r2,-24(fp)
   14ea8:	e0fffa03 	ldbu	r3,-24(fp)
   14eac:	e13ffe17 	ldw	r4,-8(fp)
   14eb0:	20c7883a 	add	r3,r4,r3
   14eb4:	18c00003 	ldbu	r3,0(r3)
   14eb8:	e13ffb17 	ldw	r4,-20(fp)
   14ebc:	2085883a 	add	r2,r4,r2
   14ec0:	10800204 	addi	r2,r2,8
   14ec4:	10c00005 	stb	r3,0(r2)
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
   14ec8:	e0bffa03 	ldbu	r2,-24(fp)
   14ecc:	103fea1e 	bne	r2,zero,14e78 <etharp_send_ip+0x70>
    k--;
    ethhdr->dest.addr[k] = dst->addr[k];
    ethhdr->src.addr[k]  = src->addr[k];
  }
  ethhdr->type = htons(ETHTYPE_IP);
   14ed0:	e0bffb17 	ldw	r2,-20(fp)
   14ed4:	00c00204 	movi	r3,8
   14ed8:	10c0038d 	sth	r3,14(r2)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
   14edc:	e0bffc17 	ldw	r2,-16(fp)
   14ee0:	10800617 	ldw	r2,24(r2)
   14ee4:	e13ffc17 	ldw	r4,-16(fp)
   14ee8:	e17ffd17 	ldw	r5,-12(fp)
   14eec:	103ee83a 	callr	r2
}
   14ef0:	e037883a 	mov	sp,fp
   14ef4:	dfc00117 	ldw	ra,4(sp)
   14ef8:	df000017 	ldw	fp,0(sp)
   14efc:	dec00204 	addi	sp,sp,8
   14f00:	f800283a 	ret

00014f04 <update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
   14f04:	defff704 	addi	sp,sp,-36
   14f08:	dfc00815 	stw	ra,32(sp)
   14f0c:	df000715 	stw	fp,28(sp)
   14f10:	df000704 	addi	fp,sp,28
   14f14:	e13ffc15 	stw	r4,-16(fp)
   14f18:	e17ffd15 	stw	r5,-12(fp)
   14f1c:	e1bffe15 	stw	r6,-8(fp)
   14f20:	3805883a 	mov	r2,r7
   14f24:	e0bfff05 	stb	r2,-4(fp)
  s8_t i;
  u8_t k;
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry()\n"));
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
   14f28:	e0bffc17 	ldw	r2,-16(fp)
   14f2c:	10800983 	ldbu	r2,38(r2)
   14f30:	10803fcc 	andi	r2,r2,255
   14f34:	108001a0 	cmpeqi	r2,r2,6
   14f38:	1000091e 	bne	r2,zero,14f60 <update_arp_entry+0x5c>
   14f3c:	010000f4 	movhi	r4,3
   14f40:	213b8204 	addi	r4,r4,-4600
   14f44:	014000f4 	movhi	r5,3
   14f48:	297bb904 	addi	r5,r5,-4380
   14f4c:	01807604 	movi	r6,472
   14f50:	01c000f4 	movhi	r7,3
   14f54:	39fb8f04 	addi	r7,r7,-4548
   14f58:	00166c00 	call	166c0 <printf>
   14f5c:	003fff06 	br	14f5c <update_arp_entry+0x58>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
   14f60:	e0bffd17 	ldw	r2,-12(fp)
   14f64:	10001326 	beq	r2,zero,14fb4 <update_arp_entry+0xb0>
   14f68:	e0bffd17 	ldw	r2,-12(fp)
   14f6c:	10c0000b 	ldhu	r3,0(r2)
   14f70:	1080008b 	ldhu	r2,2(r2)
   14f74:	1004943a 	slli	r2,r2,16
   14f78:	10c4b03a 	or	r2,r2,r3
   14f7c:	10000d26 	beq	r2,zero,14fb4 <update_arp_entry+0xb0>
      ip_addr_isbroadcast(ipaddr, netif) ||
   14f80:	e13ffd17 	ldw	r4,-12(fp)
   14f84:	e17ffc17 	ldw	r5,-16(fp)
   14f88:	0006db00 	call	6db0 <ip_addr_isbroadcast>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
   14f8c:	10803fcc 	andi	r2,r2,255
   14f90:	1000081e 	bne	r2,zero,14fb4 <update_arp_entry+0xb0>
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
   14f94:	e0bffd17 	ldw	r2,-12(fp)
   14f98:	10c0000b 	ldhu	r3,0(r2)
   14f9c:	1080008b 	ldhu	r2,2(r2)
   14fa0:	1004943a 	slli	r2,r2,16
   14fa4:	10c4b03a 	or	r2,r2,r3
   14fa8:	10803c0c 	andi	r2,r2,240
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
      ip_addr_isbroadcast(ipaddr, netif) ||
   14fac:	10803818 	cmpnei	r2,r2,224
   14fb0:	1000021e 	bne	r2,zero,14fbc <update_arp_entry+0xb8>
      ip_addr_ismulticast(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
   14fb4:	00bffd84 	movi	r2,-10
   14fb8:	00005c06 	br	1512c <update_arp_entry+0x228>
  }
  /* find or create ARP entry */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, flags, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, flags);
   14fbc:	e0bfff03 	ldbu	r2,-4(fp)
   14fc0:	e13ffd17 	ldw	r4,-12(fp)
   14fc4:	100b883a 	mov	r5,r2
   14fc8:	00148fc0 	call	148fc <find_entry>
   14fcc:	e0bff945 	stb	r2,-27(fp)
#endif /* LWIP_NETIF_HWADDRHINT */
  /* bail out if no entry could be found */
  if (i < 0)
   14fd0:	e0bff947 	ldb	r2,-27(fp)
   14fd4:	1000020e 	bge	r2,zero,14fe0 <update_arp_entry+0xdc>
    return (err_t)i;
   14fd8:	e0bff943 	ldbu	r2,-27(fp)
   14fdc:	00005306 	br	1512c <update_arp_entry+0x228>
  
  /* mark it stable */
  arp_table[i].state = ETHARP_STATE_STABLE;
   14fe0:	e0bff947 	ldb	r2,-27(fp)
   14fe4:	00c00134 	movhi	r3,4
   14fe8:	18ccff04 	addi	r3,r3,13308
   14fec:	10800724 	muli	r2,r2,28
   14ff0:	1885883a 	add	r2,r3,r2
   14ff4:	10800404 	addi	r2,r2,16
   14ff8:	00c00084 	movi	r3,2
   14ffc:	10c00015 	stw	r3,0(r2)
  /* record network interface */
  arp_table[i].netif = netif;
   15000:	e0bff947 	ldb	r2,-27(fp)
   15004:	00c00134 	movhi	r3,4
   15008:	18ccff04 	addi	r3,r3,13308
   1500c:	10800724 	muli	r2,r2,28
   15010:	1885883a 	add	r2,r3,r2
   15014:	10800604 	addi	r2,r2,24
   15018:	e0fffc17 	ldw	r3,-16(fp)
   1501c:	10c00015 	stw	r3,0(r2)
  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
   15020:	00800184 	movi	r2,6
   15024:	e0bff905 	stb	r2,-28(fp)
  while (k > 0) {
   15028:	00001006 	br	1506c <update_arp_entry+0x168>
    k--;
   1502c:	e0bff903 	ldbu	r2,-28(fp)
   15030:	10bfffc4 	addi	r2,r2,-1
   15034:	e0bff905 	stb	r2,-28(fp)
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
   15038:	e13ff947 	ldb	r4,-27(fp)
   1503c:	e0bff903 	ldbu	r2,-28(fp)
   15040:	e0fff903 	ldbu	r3,-28(fp)
   15044:	e17ffe17 	ldw	r5,-8(fp)
   15048:	28c7883a 	add	r3,r5,r3
   1504c:	18c00003 	ldbu	r3,0(r3)
   15050:	01400134 	movhi	r5,4
   15054:	294cff04 	addi	r5,r5,13308
   15058:	21000724 	muli	r4,r4,28
   1505c:	2909883a 	add	r4,r5,r4
   15060:	2085883a 	add	r2,r4,r2
   15064:	10800204 	addi	r2,r2,8
   15068:	10c00005 	stb	r3,0(r2)
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
   1506c:	e0bff903 	ldbu	r2,-28(fp)
   15070:	103fee1e 	bne	r2,zero,1502c <update_arp_entry+0x128>
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
   15074:	e0bff947 	ldb	r2,-27(fp)
   15078:	00c00134 	movhi	r3,4
   1507c:	18ccff04 	addi	r3,r3,13308
   15080:	10800724 	muli	r2,r2,28
   15084:	1885883a 	add	r2,r3,r2
   15088:	10800504 	addi	r2,r2,20
   1508c:	10000005 	stb	zero,0(r2)
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
   15090:	00001e06 	br	1510c <update_arp_entry+0x208>
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
   15094:	e0bff947 	ldb	r2,-27(fp)
   15098:	00c00134 	movhi	r3,4
   1509c:	18ccff04 	addi	r3,r3,13308
   150a0:	10800724 	muli	r2,r2,28
   150a4:	1885883a 	add	r2,r3,r2
   150a8:	10800017 	ldw	r2,0(r2)
   150ac:	e0bffa15 	stw	r2,-24(fp)
    /* pop first item off the queue */
    arp_table[i].q = q->next;
   150b0:	e0bff947 	ldb	r2,-27(fp)
   150b4:	e0fffa17 	ldw	r3,-24(fp)
   150b8:	18c00017 	ldw	r3,0(r3)
   150bc:	01000134 	movhi	r4,4
   150c0:	210cff04 	addi	r4,r4,13308
   150c4:	10800724 	muli	r2,r2,28
   150c8:	2085883a 	add	r2,r4,r2
   150cc:	10c00015 	stw	r3,0(r2)
    /* get the packet pointer */
    p = q->p;
   150d0:	e0bffa17 	ldw	r2,-24(fp)
   150d4:	10800117 	ldw	r2,4(r2)
   150d8:	e0bffb15 	stw	r2,-20(fp)
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
   150dc:	01000184 	movi	r4,6
   150e0:	e17ffa17 	ldw	r5,-24(fp)
   150e4:	00090cc0 	call	90cc <memp_free>
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
   150e8:	e0bffc17 	ldw	r2,-16(fp)
   150ec:	108009c4 	addi	r2,r2,39
   150f0:	e13ffc17 	ldw	r4,-16(fp)
   150f4:	e17ffb17 	ldw	r5,-20(fp)
   150f8:	100d883a 	mov	r6,r2
   150fc:	e1fffe17 	ldw	r7,-8(fp)
   15100:	0014e080 	call	14e08 <etharp_send_ip>
    /* free the queued IP packet */
    pbuf_free(p);
   15104:	e13ffb17 	ldw	r4,-20(fp)
   15108:	000a16c0 	call	a16c <pbuf_free>
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
   1510c:	e0bff947 	ldb	r2,-27(fp)
   15110:	00c00134 	movhi	r3,4
   15114:	18ccff04 	addi	r3,r3,13308
   15118:	10800724 	muli	r2,r2,28
   1511c:	1885883a 	add	r2,r3,r2
   15120:	10800017 	ldw	r2,0(r2)
   15124:	103fdb1e 	bne	r2,zero,15094 <update_arp_entry+0x190>
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
    /* free the queued IP packet */
    pbuf_free(p);
  }
#endif
  return ERR_OK;
   15128:	0005883a 	mov	r2,zero
}
   1512c:	e037883a 	mov	sp,fp
   15130:	dfc00117 	ldw	ra,4(sp)
   15134:	df000017 	ldw	fp,0(sp)
   15138:	dec00204 	addi	sp,sp,8
   1513c:	f800283a 	ret

00015140 <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
         struct eth_addr **eth_ret, struct ip_addr **ip_ret)
{
   15140:	defff904 	addi	sp,sp,-28
   15144:	dfc00615 	stw	ra,24(sp)
   15148:	df000515 	stw	fp,20(sp)
   1514c:	df000504 	addi	fp,sp,20
   15150:	e13ffc15 	stw	r4,-16(fp)
   15154:	e17ffd15 	stw	r5,-12(fp)
   15158:	e1bffe15 	stw	r6,-8(fp)
   1515c:	e1ffff15 	stw	r7,-4(fp)
  LWIP_UNUSED_ARG(netif);

#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_FIND_ONLY);
   15160:	e13ffd17 	ldw	r4,-12(fp)
   15164:	01400084 	movi	r5,2
   15168:	00148fc0 	call	148fc <find_entry>
   1516c:	e0bffb05 	stb	r2,-20(fp)
#endif /* LWIP_NETIF_HWADDRHINT */
  if((i >= 0) && arp_table[i].state == ETHARP_STATE_STABLE) {
   15170:	e0bffb07 	ldb	r2,-20(fp)
   15174:	10001b16 	blt	r2,zero,151e4 <etharp_find_addr+0xa4>
   15178:	e0bffb07 	ldb	r2,-20(fp)
   1517c:	00c00134 	movhi	r3,4
   15180:	18ccff04 	addi	r3,r3,13308
   15184:	10800724 	muli	r2,r2,28
   15188:	1885883a 	add	r2,r3,r2
   1518c:	10800404 	addi	r2,r2,16
   15190:	10800017 	ldw	r2,0(r2)
   15194:	10800098 	cmpnei	r2,r2,2
   15198:	1000121e 	bne	r2,zero,151e4 <etharp_find_addr+0xa4>
      *eth_ret = &arp_table[i].ethaddr;
   1519c:	e0bffb07 	ldb	r2,-20(fp)
   151a0:	10800724 	muli	r2,r2,28
   151a4:	10c00204 	addi	r3,r2,8
   151a8:	00800134 	movhi	r2,4
   151ac:	108cff04 	addi	r2,r2,13308
   151b0:	1887883a 	add	r3,r3,r2
   151b4:	e0bffe17 	ldw	r2,-8(fp)
   151b8:	10c00015 	stw	r3,0(r2)
      *ip_ret = &arp_table[i].ipaddr;
   151bc:	e0bffb07 	ldb	r2,-20(fp)
   151c0:	10800724 	muli	r2,r2,28
   151c4:	10c00104 	addi	r3,r2,4
   151c8:	00800134 	movhi	r2,4
   151cc:	108cff04 	addi	r2,r2,13308
   151d0:	1887883a 	add	r3,r3,r2
   151d4:	e0bfff17 	ldw	r2,-4(fp)
   151d8:	10c00015 	stw	r3,0(r2)
      return i;
   151dc:	e0bffb03 	ldbu	r2,-20(fp)
   151e0:	00000106 	br	151e8 <etharp_find_addr+0xa8>
  }
  return -1;
   151e4:	00bfffc4 	movi	r2,-1
}
   151e8:	e037883a 	mov	sp,fp
   151ec:	dfc00117 	ldw	ra,4(sp)
   151f0:	df000017 	ldw	fp,0(sp)
   151f4:	dec00204 	addi	sp,sp,8
   151f8:	f800283a 	ret

000151fc <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
   151fc:	defffa04 	addi	sp,sp,-24
   15200:	dfc00515 	stw	ra,20(sp)
   15204:	df000415 	stw	fp,16(sp)
   15208:	df000404 	addi	fp,sp,16
   1520c:	e13ffe15 	stw	r4,-8(fp)
   15210:	e17fff15 	stw	r5,-4(fp)
  struct eth_hdr *ethhdr;
  struct ip_hdr *iphdr;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
   15214:	e0bffe17 	ldw	r2,-8(fp)
   15218:	1000091e 	bne	r2,zero,15240 <etharp_ip_input+0x44>
   1521c:	010000f4 	movhi	r4,3
   15220:	213b8204 	addi	r4,r4,-4600
   15224:	014000f4 	movhi	r5,3
   15228:	297bc304 	addi	r5,r5,-4340
   1522c:	01809204 	movi	r6,584
   15230:	01c000f4 	movhi	r7,3
   15234:	39fb8f04 	addi	r7,r7,-4548
   15238:	00166c00 	call	166c0 <printf>
   1523c:	003fff06 	br	1523c <etharp_ip_input+0x40>
  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  ethhdr = p->payload;
   15240:	e0bfff17 	ldw	r2,-4(fp)
   15244:	10800117 	ldw	r2,4(r2)
   15248:	e0bffc15 	stw	r2,-16(fp)
  iphdr = (struct ip_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
   1524c:	e0bffc17 	ldw	r2,-16(fp)
   15250:	10800404 	addi	r2,r2,16
   15254:	e0bffd15 	stw	r2,-12(fp)
    iphdr = (struct ip_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(iphdr->src), &(netif->ip_addr), &(netif->netmask))) {
   15258:	e0bffd17 	ldw	r2,-12(fp)
   1525c:	10c0030b 	ldhu	r3,12(r2)
   15260:	1080038b 	ldhu	r2,14(r2)
   15264:	1004943a 	slli	r2,r2,16
   15268:	10c4b03a 	or	r2,r2,r3
   1526c:	1007883a 	mov	r3,r2
   15270:	e0bffe17 	ldw	r2,-8(fp)
   15274:	10800117 	ldw	r2,4(r2)
   15278:	1886f03a 	xor	r3,r3,r2
   1527c:	e0bffe17 	ldw	r2,-8(fp)
   15280:	10800217 	ldw	r2,8(r2)
   15284:	1884703a 	and	r2,r3,r2
   15288:	10000a1e 	bne	r2,zero,152b4 <etharp_ip_input+0xb8>

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(iphdr->src), &(ethhdr->src), 0);
   1528c:	e0bffd17 	ldw	r2,-12(fp)
   15290:	10c00304 	addi	r3,r2,12
   15294:	e0bffc17 	ldw	r2,-16(fp)
   15298:	10800204 	addi	r2,r2,8
   1529c:	e13ffe17 	ldw	r4,-8(fp)
   152a0:	180b883a 	mov	r5,r3
   152a4:	100d883a 	mov	r6,r2
   152a8:	000f883a 	mov	r7,zero
   152ac:	0014f040 	call	14f04 <update_arp_entry>
   152b0:	00000106 	br	152b8 <etharp_ip_input+0xbc>
#endif /* ETHARP_SUPPORT_VLAN */

  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(iphdr->src), &(netif->ip_addr), &(netif->netmask))) {
    /* do nothing */
    return;
   152b4:	0001883a 	nop
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(iphdr->src), &(ethhdr->src), 0);
}
   152b8:	e037883a 	mov	sp,fp
   152bc:	dfc00117 	ldw	ra,4(sp)
   152c0:	df000017 	ldw	fp,0(sp)
   152c4:	dec00204 	addi	sp,sp,8
   152c8:	f800283a 	ret

000152cc <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
   152cc:	defff604 	addi	sp,sp,-40
   152d0:	dfc00915 	stw	ra,36(sp)
   152d4:	df000815 	stw	fp,32(sp)
   152d8:	df000804 	addi	fp,sp,32
   152dc:	e13ffd15 	stw	r4,-12(fp)
   152e0:	e17ffe15 	stw	r5,-8(fp)
   152e4:	e1bfff15 	stw	r6,-4(fp)
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
   152e8:	e0bffd17 	ldw	r2,-12(fp)
   152ec:	1000091e 	bne	r2,zero,15314 <etharp_arp_input+0x48>
   152f0:	010000f4 	movhi	r4,3
   152f4:	213b8204 	addi	r4,r4,-4600
   152f8:	014000f4 	movhi	r5,3
   152fc:	297bc304 	addi	r5,r5,-4340
   15300:	01809f44 	movi	r6,637
   15304:	01c000f4 	movhi	r7,3
   15308:	39fb8f04 	addi	r7,r7,-4548
   1530c:	00166c00 	call	166c0 <printf>
   15310:	003fff06 	br	15310 <etharp_arp_input+0x44>
  
  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < SIZEOF_ETHARP_PACKET) {
   15314:	e0bfff17 	ldw	r2,-4(fp)
   15318:	1080028b 	ldhu	r2,10(r2)
   1531c:	10bfffcc 	andi	r2,r2,65535
   15320:	10800b28 	cmpgeui	r2,r2,44
   15324:	1000131e 	bne	r2,zero,15374 <etharp_arp_input+0xa8>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len,
      (s16_t)SIZEOF_ETHARP_PACKET));
    ETHARP_STATS_INC(etharp.lenerr);
   15328:	00800134 	movhi	r2,4
   1532c:	108d9504 	addi	r2,r2,13908
   15330:	1080088b 	ldhu	r2,34(r2)
   15334:	10800044 	addi	r2,r2,1
   15338:	1007883a 	mov	r3,r2
   1533c:	00800134 	movhi	r2,4
   15340:	108d9504 	addi	r2,r2,13908
   15344:	10c0088d 	sth	r3,34(r2)
    ETHARP_STATS_INC(etharp.drop);
   15348:	00800134 	movhi	r2,4
   1534c:	108d9504 	addi	r2,r2,13908
   15350:	1080078b 	ldhu	r2,30(r2)
   15354:	10800044 	addi	r2,r2,1
   15358:	1007883a 	mov	r3,r2
   1535c:	00800134 	movhi	r2,4
   15360:	108d9504 	addi	r2,r2,13908
   15364:	10c0078d 	sth	r3,30(r2)
    pbuf_free(p);
   15368:	e13fff17 	ldw	r4,-4(fp)
   1536c:	000a16c0 	call	a16c <pbuf_free>
   15370:	0000d106 	br	156b8 <etharp_arp_input+0x3ec>
    return;
  }

  ethhdr = p->payload;
   15374:	e0bfff17 	ldw	r2,-4(fp)
   15378:	10800117 	ldw	r2,4(r2)
   1537c:	e0bff915 	stw	r2,-28(fp)
  hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
   15380:	e0bff917 	ldw	r2,-28(fp)
   15384:	10800404 	addi	r2,r2,16
   15388:	e0bffa15 	stw	r2,-24(fp)
    hdr = (struct etharp_hdr *)(((u8_t*)ethhdr) + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
   1538c:	e0bffa17 	ldw	r2,-24(fp)
   15390:	1080000b 	ldhu	r2,0(r2)
   15394:	10bfffcc 	andi	r2,r2,65535
   15398:	10804018 	cmpnei	r2,r2,256
   1539c:	10000f1e 	bne	r2,zero,153dc <etharp_arp_input+0x110>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
   153a0:	e0bffa17 	ldw	r2,-24(fp)
   153a4:	1080010b 	ldhu	r2,4(r2)
    hdr = (struct etharp_hdr *)(((u8_t*)ethhdr) + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
   153a8:	10bfffcc 	andi	r2,r2,65535
   153ac:	10810198 	cmpnei	r2,r2,1030
   153b0:	10000a1e 	bne	r2,zero,153dc <etharp_arp_input+0x110>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
   153b4:	e0bffa17 	ldw	r2,-24(fp)
   153b8:	1080008b 	ldhu	r2,2(r2)
  }
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
   153bc:	10bfffcc 	andi	r2,r2,65535
   153c0:	10800218 	cmpnei	r2,r2,8
   153c4:	1000051e 	bne	r2,zero,153dc <etharp_arp_input+0x110>
      (hdr->proto != htons(ETHTYPE_IP)) ||
      (ethhdr->type != htons(ETHTYPE_ARP)))  {
   153c8:	e0bff917 	ldw	r2,-28(fp)
   153cc:	1080038b 	ldhu	r2,14(r2)
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
   153d0:	10bfffcc 	andi	r2,r2,65535
   153d4:	10818220 	cmpeqi	r2,r2,1544
   153d8:	1000131e 	bne	r2,zero,15428 <etharp_arp_input+0x15c>
      (ethhdr->type != htons(ETHTYPE_ARP)))  {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, ARPH_HWLEN(hdr), hdr->proto, ARPH_PROTOLEN(hdr), ethhdr->type));
    ETHARP_STATS_INC(etharp.proterr);
   153dc:	00800134 	movhi	r2,4
   153e0:	108d9504 	addi	r2,r2,13908
   153e4:	10800a0b 	ldhu	r2,40(r2)
   153e8:	10800044 	addi	r2,r2,1
   153ec:	1007883a 	mov	r3,r2
   153f0:	00800134 	movhi	r2,4
   153f4:	108d9504 	addi	r2,r2,13908
   153f8:	10c00a0d 	sth	r3,40(r2)
    ETHARP_STATS_INC(etharp.drop);
   153fc:	00800134 	movhi	r2,4
   15400:	108d9504 	addi	r2,r2,13908
   15404:	1080078b 	ldhu	r2,30(r2)
   15408:	10800044 	addi	r2,r2,1
   1540c:	1007883a 	mov	r3,r2
   15410:	00800134 	movhi	r2,4
   15414:	108d9504 	addi	r2,r2,13908
   15418:	10c0078d 	sth	r3,30(r2)
    pbuf_free(p);
   1541c:	e13fff17 	ldw	r4,-4(fp)
   15420:	000a16c0 	call	a16c <pbuf_free>
   15424:	0000a406 	br	156b8 <etharp_arp_input+0x3ec>
    return;
  }
  ETHARP_STATS_INC(etharp.recv);
   15428:	00800134 	movhi	r2,4
   1542c:	108d9504 	addi	r2,r2,13908
   15430:	1080068b 	ldhu	r2,26(r2)
   15434:	10800044 	addi	r2,r2,1
   15438:	1007883a 	mov	r3,r2
   1543c:	00800134 	movhi	r2,4
   15440:	108d9504 	addi	r2,r2,13908
   15444:	10c0068d 	sth	r3,26(r2)
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
   15448:	e0bffa17 	ldw	r2,-24(fp)
   1544c:	10c0038b 	ldhu	r3,14(r2)
   15450:	e0fffb0d 	sth	r3,-20(fp)
   15454:	1080040b 	ldhu	r2,16(r2)
   15458:	e0bffb8d 	sth	r2,-18(fp)
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
   1545c:	e0bffa17 	ldw	r2,-24(fp)
   15460:	10c0060b 	ldhu	r3,24(r2)
   15464:	e0fffc0d 	sth	r3,-16(fp)
   15468:	1080068b 	ldhu	r2,26(r2)
   1546c:	e0bffc8d 	sth	r2,-14(fp)

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
   15470:	e0bffd17 	ldw	r2,-12(fp)
   15474:	10800117 	ldw	r2,4(r2)
   15478:	1000021e 	bne	r2,zero,15484 <etharp_arp_input+0x1b8>
    for_us = 0;
   1547c:	e03ff845 	stb	zero,-31(fp)
   15480:	00000506 	br	15498 <etharp_arp_input+0x1cc>
  } else {
    /* ARP packet directed to us? */
    for_us = ip_addr_cmp(&dipaddr, &(netif->ip_addr));
   15484:	e0fffc17 	ldw	r3,-16(fp)
   15488:	e0bffd17 	ldw	r2,-12(fp)
   1548c:	10800117 	ldw	r2,4(r2)
   15490:	1885003a 	cmpeq	r2,r3,r2
   15494:	e0bff845 	stb	r2,-31(fp)
  }

  /* ARP message directed to us? */
  if (for_us) {
   15498:	e0bff843 	ldbu	r2,-31(fp)
   1549c:	10000926 	beq	r2,zero,154c4 <etharp_arp_input+0x1f8>
    /* add IP address in ARP cache; assume requester wants to talk to us.
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
   154a0:	e0bffa17 	ldw	r2,-24(fp)
   154a4:	10800204 	addi	r2,r2,8
   154a8:	e0fffb04 	addi	r3,fp,-20
   154ac:	e13ffd17 	ldw	r4,-12(fp)
   154b0:	180b883a 	mov	r5,r3
   154b4:	100d883a 	mov	r6,r2
   154b8:	01c00044 	movi	r7,1
   154bc:	0014f040 	call	14f04 <update_arp_entry>
   154c0:	00000806 	br	154e4 <etharp_arp_input+0x218>
  /* ARP message not directed to us? */
  } else {
    /* update the source IP address in the cache, if present */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
   154c4:	e0bffa17 	ldw	r2,-24(fp)
   154c8:	10800204 	addi	r2,r2,8
   154cc:	e0fffb04 	addi	r3,fp,-20
   154d0:	e13ffd17 	ldw	r4,-12(fp)
   154d4:	180b883a 	mov	r5,r3
   154d8:	100d883a 	mov	r6,r2
   154dc:	000f883a 	mov	r7,zero
   154e0:	0014f040 	call	14f04 <update_arp_entry>
  }

  /* now act on the message itself */
  switch (htons(hdr->opcode)) {
   154e4:	e0bffa17 	ldw	r2,-24(fp)
   154e8:	1080018b 	ldhu	r2,6(r2)
   154ec:	10bfffcc 	andi	r2,r2,65535
   154f0:	1004d23a 	srli	r2,r2,8
   154f4:	10ffffcc 	andi	r3,r2,65535
   154f8:	e0bffa17 	ldw	r2,-24(fp)
   154fc:	1080018b 	ldhu	r2,6(r2)
   15500:	10bfffcc 	andi	r2,r2,65535
   15504:	1004923a 	slli	r2,r2,8
   15508:	10bfffcc 	andi	r2,r2,65535
   1550c:	1884b03a 	or	r2,r3,r2
   15510:	10c00060 	cmpeqi	r3,r2,1
   15514:	1800031e 	bne	r3,zero,15524 <etharp_arp_input+0x258>
   15518:	108000a0 	cmpeqi	r2,r2,2
   1551c:	1000551e 	bne	r2,zero,15674 <etharp_arp_input+0x3a8>
   15520:	00005906 	br	15688 <etharp_arp_input+0x3bc>
     * reply. In any case, we time-stamp any existing ARP entry,
     * and possiby send out an IP packet that was queued on it. */

    LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
    /* ARP request for our address? */
    if (for_us) {
   15524:	e0bff843 	ldbu	r2,-31(fp)
   15528:	10006026 	beq	r2,zero,156ac <etharp_arp_input+0x3e0>

      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* Re-use pbuf to send ARP reply.
         Since we are re-using an existing pbuf, we can't call etharp_raw since
         that would allocate a new pbuf. */
      hdr->opcode = htons(ARP_REPLY);
   1552c:	e0bffa17 	ldw	r2,-24(fp)
   15530:	00c08004 	movi	r3,512
   15534:	10c0018d 	sth	r3,6(r2)

      hdr->dipaddr = hdr->sipaddr;
   15538:	e0bffa17 	ldw	r2,-24(fp)
   1553c:	e0fffa17 	ldw	r3,-24(fp)
   15540:	1900038b 	ldhu	r4,14(r3)
   15544:	1100060d 	sth	r4,24(r2)
   15548:	18c0040b 	ldhu	r3,16(r3)
   1554c:	10c0068d 	sth	r3,26(r2)
      SMEMCPY(&hdr->sipaddr, &netif->ip_addr, sizeof(hdr->sipaddr));
   15550:	e0bffa17 	ldw	r2,-24(fp)
   15554:	10c00384 	addi	r3,r2,14
   15558:	e0bffd17 	ldw	r2,-12(fp)
   1555c:	10800104 	addi	r2,r2,4
   15560:	1809883a 	mov	r4,r3
   15564:	100b883a 	mov	r5,r2
   15568:	01800104 	movi	r6,4
   1556c:	00164c00 	call	164c0 <memcpy>

      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
   15570:	e0bffd17 	ldw	r2,-12(fp)
   15574:	10800983 	ldbu	r2,38(r2)
   15578:	10803fcc 	andi	r2,r2,255
   1557c:	108001a0 	cmpeqi	r2,r2,6
   15580:	1000091e 	bne	r2,zero,155a8 <etharp_arp_input+0x2dc>
   15584:	010000f4 	movhi	r4,3
   15588:	213b8204 	addi	r4,r4,-4600
   1558c:	014000f4 	movhi	r5,3
   15590:	297ba804 	addi	r5,r5,-4448
   15594:	0180b5c4 	movi	r6,727
   15598:	01c000f4 	movhi	r7,3
   1559c:	39fb8f04 	addi	r7,r7,-4548
   155a0:	00166c00 	call	166c0 <printf>
   155a4:	003fff06 	br	155a4 <etharp_arp_input+0x2d8>
                  (netif->hwaddr_len == ETHARP_HWADDR_LEN));
      i = ETHARP_HWADDR_LEN;
   155a8:	00800184 	movi	r2,6
   155ac:	e0bff805 	stb	r2,-32(fp)
      /* If we are using Link-Local, ARP packets must be broadcast on the
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
   155b0:	00002806 	br	15654 <etharp_arp_input+0x388>
        i--;
   155b4:	e0bff803 	ldbu	r2,-32(fp)
   155b8:	10bfffc4 	addi	r2,r2,-1
   155bc:	e0bff805 	stb	r2,-32(fp)
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
   155c0:	e0bff803 	ldbu	r2,-32(fp)
   155c4:	e0fff803 	ldbu	r3,-32(fp)
   155c8:	e13ffa17 	ldw	r4,-24(fp)
   155cc:	20c7883a 	add	r3,r4,r3
   155d0:	18c00204 	addi	r3,r3,8
   155d4:	18c00003 	ldbu	r3,0(r3)
   155d8:	e13ffa17 	ldw	r4,-24(fp)
   155dc:	2085883a 	add	r2,r4,r2
   155e0:	10800404 	addi	r2,r2,16
   155e4:	10c00085 	stb	r3,2(r2)
#if LWIP_AUTOIP
        ethhdr->dest.addr[i] = ethdst_hwaddr[i];
#else  /* LWIP_AUTOIP */
        ethhdr->dest.addr[i] = hdr->shwaddr.addr[i];
   155e8:	e0bff803 	ldbu	r2,-32(fp)
   155ec:	e0fff803 	ldbu	r3,-32(fp)
   155f0:	e13ffa17 	ldw	r4,-24(fp)
   155f4:	20c7883a 	add	r3,r4,r3
   155f8:	18c00204 	addi	r3,r3,8
   155fc:	18c00003 	ldbu	r3,0(r3)
   15600:	e13ff917 	ldw	r4,-28(fp)
   15604:	2085883a 	add	r2,r4,r2
   15608:	10c00085 	stb	r3,2(r2)
#endif /* LWIP_AUTOIP */
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
   1560c:	e0bff803 	ldbu	r2,-32(fp)
   15610:	e0fff803 	ldbu	r3,-32(fp)
   15614:	e13ffe17 	ldw	r4,-8(fp)
   15618:	20c7883a 	add	r3,r4,r3
   1561c:	18c00003 	ldbu	r3,0(r3)
   15620:	e13ffa17 	ldw	r4,-24(fp)
   15624:	2085883a 	add	r2,r4,r2
   15628:	10800204 	addi	r2,r2,8
   1562c:	10c00005 	stb	r3,0(r2)
        ethhdr->src.addr[i] = ethaddr->addr[i];
   15630:	e0bff803 	ldbu	r2,-32(fp)
   15634:	e0fff803 	ldbu	r3,-32(fp)
   15638:	e13ffe17 	ldw	r4,-8(fp)
   1563c:	20c7883a 	add	r3,r4,r3
   15640:	18c00003 	ldbu	r3,0(r3)
   15644:	e13ff917 	ldw	r4,-28(fp)
   15648:	2085883a 	add	r2,r4,r2
   1564c:	10800204 	addi	r2,r2,8
   15650:	10c00005 	stb	r3,0(r2)
      /* If we are using Link-Local, ARP packets must be broadcast on the
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
   15654:	e0bff803 	ldbu	r2,-32(fp)
   15658:	103fd61e 	bne	r2,zero,155b4 <etharp_arp_input+0x2e8>

      /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
   1565c:	e0bffd17 	ldw	r2,-12(fp)
   15660:	10800617 	ldw	r2,24(r2)
   15664:	e13ffd17 	ldw	r4,-12(fp)
   15668:	e17fff17 	ldw	r5,-4(fp)
   1566c:	103ee83a 	callr	r2
    /* request was not directed to us */
    } else {
      /* { for_us == 0 and netif->ip_addr.addr != 0 } */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP request was not for us.\n"));
    }
    break;
   15670:	00000e06 	br	156ac <etharp_arp_input+0x3e0>
#if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
    /* DHCP wants to know about ARP replies from any host with an
     * IP address also offered to us by the DHCP server. We do not
     * want to take a duplicate IP address on a single network.
     * @todo How should we handle redundant (fail-over) interfaces? */
    dhcp_arp_reply(netif, &sipaddr);
   15674:	e0bffb04 	addi	r2,fp,-20
   15678:	e13ffd17 	ldw	r4,-12(fp)
   1567c:	100b883a 	mov	r5,r2
   15680:	0002a800 	call	2a80 <dhcp_arp_reply>
#endif
    break;
   15684:	00000a06 	br	156b0 <etharp_arp_input+0x3e4>
  default:
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
   15688:	00800134 	movhi	r2,4
   1568c:	108d9504 	addi	r2,r2,13908
   15690:	10800b0b 	ldhu	r2,44(r2)
   15694:	10800044 	addi	r2,r2,1
   15698:	1007883a 	mov	r3,r2
   1569c:	00800134 	movhi	r2,4
   156a0:	108d9504 	addi	r2,r2,13908
   156a4:	10c00b0d 	sth	r3,44(r2)
    break;
   156a8:	00000106 	br	156b0 <etharp_arp_input+0x3e4>
    /* request was not directed to us */
    } else {
      /* { for_us == 0 and netif->ip_addr.addr != 0 } */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP request was not for us.\n"));
    }
    break;
   156ac:	0001883a 	nop
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
   156b0:	e13fff17 	ldw	r4,-4(fp)
   156b4:	000a16c0 	call	a16c <pbuf_free>
}
   156b8:	e037883a 	mov	sp,fp
   156bc:	dfc00117 	ldw	ra,4(sp)
   156c0:	df000017 	ldw	fp,0(sp)
   156c4:	dec00204 	addi	sp,sp,8
   156c8:	f800283a 	ret

000156cc <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, struct ip_addr *ipaddr)
{
   156cc:	defff804 	addi	sp,sp,-32
   156d0:	dfc00715 	stw	ra,28(sp)
   156d4:	df000615 	stw	fp,24(sp)
   156d8:	df000604 	addi	fp,sp,24
   156dc:	e13ffd15 	stw	r4,-12(fp)
   156e0:	e17ffe15 	stw	r5,-8(fp)
   156e4:	e1bfff15 	stw	r6,-4(fp)
  struct eth_addr *dest, mcastaddr;

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
   156e8:	e13ffe17 	ldw	r4,-8(fp)
   156ec:	01400404 	movi	r5,16
   156f0:	0009f740 	call	9f74 <pbuf_header>
   156f4:	10803fcc 	andi	r2,r2,255
   156f8:	10000a26 	beq	r2,zero,15724 <etharp_output+0x58>
    /* bail out */
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("etharp_output: could not allocate room for header.\n"));
    LINK_STATS_INC(link.lenerr);
   156fc:	00800134 	movhi	r2,4
   15700:	108d9504 	addi	r2,r2,13908
   15704:	1080028b 	ldhu	r2,10(r2)
   15708:	10800044 	addi	r2,r2,1
   1570c:	1007883a 	mov	r3,r2
   15710:	00800134 	movhi	r2,4
   15714:	108d9504 	addi	r2,r2,13908
   15718:	10c0028d 	sth	r3,10(r2)
    return ERR_BUF;
   1571c:	00bfff84 	movi	r2,-2
   15720:	00008106 	br	15928 <etharp_output+0x25c>
  }

  /* assume unresolved Ethernet address */
  dest = NULL;
   15724:	e03ffa15 	stw	zero,-24(fp)
  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
   15728:	e13fff17 	ldw	r4,-4(fp)
   1572c:	e17ffd17 	ldw	r5,-12(fp)
   15730:	0006db00 	call	6db0 <ip_addr_isbroadcast>
   15734:	10803fcc 	andi	r2,r2,255
   15738:	10000326 	beq	r2,zero,15748 <etharp_output+0x7c>
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
   1573c:	d0a00704 	addi	r2,gp,-32740
   15740:	e0bffa15 	stw	r2,-24(fp)
   15744:	00007106 	br	1590c <etharp_output+0x240>
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
   15748:	e0bfff17 	ldw	r2,-4(fp)
   1574c:	10c0000b 	ldhu	r3,0(r2)
   15750:	1080008b 	ldhu	r2,2(r2)
   15754:	1004943a 	slli	r2,r2,16
   15758:	10c4b03a 	or	r2,r2,r3
   1575c:	10803c0c 	andi	r2,r2,240
   15760:	10803818 	cmpnei	r2,r2,224
   15764:	10004e1e 	bne	r2,zero,158a0 <etharp_output+0x1d4>
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = 0x01;
   15768:	00800044 	movi	r2,1
   1576c:	e0bffb05 	stb	r2,-20(fp)
    mcastaddr.addr[1] = 0x00;
   15770:	e03ffb45 	stb	zero,-19(fp)
    mcastaddr.addr[2] = 0x5e;
   15774:	00801784 	movi	r2,94
   15778:	e0bffb85 	stb	r2,-18(fp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
   1577c:	e0bfff17 	ldw	r2,-4(fp)
   15780:	10c0000b 	ldhu	r3,0(r2)
   15784:	1080008b 	ldhu	r2,2(r2)
   15788:	1004943a 	slli	r2,r2,16
   1578c:	10c4b03a 	or	r2,r2,r3
   15790:	1006d63a 	srli	r3,r2,24
   15794:	e0bfff17 	ldw	r2,-4(fp)
   15798:	1100000b 	ldhu	r4,0(r2)
   1579c:	1080008b 	ldhu	r2,2(r2)
   157a0:	1004943a 	slli	r2,r2,16
   157a4:	1104b03a 	or	r2,r2,r4
   157a8:	1004d23a 	srli	r2,r2,8
   157ac:	10bfc00c 	andi	r2,r2,65280
   157b0:	1886b03a 	or	r3,r3,r2
   157b4:	e0bfff17 	ldw	r2,-4(fp)
   157b8:	1100000b 	ldhu	r4,0(r2)
   157bc:	1080008b 	ldhu	r2,2(r2)
   157c0:	1004943a 	slli	r2,r2,16
   157c4:	1104b03a 	or	r2,r2,r4
   157c8:	10bfc00c 	andi	r2,r2,65280
   157cc:	1004923a 	slli	r2,r2,8
   157d0:	1886b03a 	or	r3,r3,r2
   157d4:	e0bfff17 	ldw	r2,-4(fp)
   157d8:	1100000b 	ldhu	r4,0(r2)
   157dc:	1080008b 	ldhu	r2,2(r2)
   157e0:	1004943a 	slli	r2,r2,16
   157e4:	1104b03a 	or	r2,r2,r4
   157e8:	1004963a 	slli	r2,r2,24
   157ec:	1884b03a 	or	r2,r3,r2
   157f0:	1004d43a 	srli	r2,r2,16
   157f4:	10801fcc 	andi	r2,r2,127
   157f8:	e0bffbc5 	stb	r2,-17(fp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
   157fc:	e0bfff17 	ldw	r2,-4(fp)
   15800:	10c0000b 	ldhu	r3,0(r2)
   15804:	1080008b 	ldhu	r2,2(r2)
   15808:	1004943a 	slli	r2,r2,16
   1580c:	10c4b03a 	or	r2,r2,r3
   15810:	1006d63a 	srli	r3,r2,24
   15814:	e0bfff17 	ldw	r2,-4(fp)
   15818:	1100000b 	ldhu	r4,0(r2)
   1581c:	1080008b 	ldhu	r2,2(r2)
   15820:	1004943a 	slli	r2,r2,16
   15824:	1104b03a 	or	r2,r2,r4
   15828:	1004d23a 	srli	r2,r2,8
   1582c:	10bfc00c 	andi	r2,r2,65280
   15830:	1886b03a 	or	r3,r3,r2
   15834:	e0bfff17 	ldw	r2,-4(fp)
   15838:	1100000b 	ldhu	r4,0(r2)
   1583c:	1080008b 	ldhu	r2,2(r2)
   15840:	1004943a 	slli	r2,r2,16
   15844:	1104b03a 	or	r2,r2,r4
   15848:	10bfc00c 	andi	r2,r2,65280
   1584c:	1004923a 	slli	r2,r2,8
   15850:	1886b03a 	or	r3,r3,r2
   15854:	e0bfff17 	ldw	r2,-4(fp)
   15858:	1100000b 	ldhu	r4,0(r2)
   1585c:	1080008b 	ldhu	r2,2(r2)
   15860:	1004943a 	slli	r2,r2,16
   15864:	1104b03a 	or	r2,r2,r4
   15868:	1004963a 	slli	r2,r2,24
   1586c:	1884b03a 	or	r2,r3,r2
   15870:	1004d23a 	srli	r2,r2,8
   15874:	e0bffc05 	stb	r2,-16(fp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
   15878:	e0bfff17 	ldw	r2,-4(fp)
   1587c:	10c0000b 	ldhu	r3,0(r2)
   15880:	1080008b 	ldhu	r2,2(r2)
   15884:	1004943a 	slli	r2,r2,16
   15888:	10c4b03a 	or	r2,r2,r3
   1588c:	1004d63a 	srli	r2,r2,24
   15890:	e0bffc45 	stb	r2,-15(fp)
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
   15894:	e0bffb04 	addi	r2,fp,-20
   15898:	e0bffa15 	stw	r2,-24(fp)
   1589c:	00001b06 	br	1590c <etharp_output+0x240>
  /* unicast destination IP address? */
  } else {
    /* outside local network? */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
   158a0:	e0bfff17 	ldw	r2,-4(fp)
   158a4:	10c0000b 	ldhu	r3,0(r2)
   158a8:	1080008b 	ldhu	r2,2(r2)
   158ac:	1004943a 	slli	r2,r2,16
   158b0:	10c4b03a 	or	r2,r2,r3
   158b4:	1007883a 	mov	r3,r2
   158b8:	e0bffd17 	ldw	r2,-12(fp)
   158bc:	10800117 	ldw	r2,4(r2)
   158c0:	1886f03a 	xor	r3,r3,r2
   158c4:	e0bffd17 	ldw	r2,-12(fp)
   158c8:	10800217 	ldw	r2,8(r2)
   158cc:	1884703a 	and	r2,r3,r2
   158d0:	10000926 	beq	r2,zero,158f8 <etharp_output+0x22c>
      /* interface has default gateway? */
      if (netif->gw.addr != 0) {
   158d4:	e0bffd17 	ldw	r2,-12(fp)
   158d8:	10800317 	ldw	r2,12(r2)
   158dc:	10000426 	beq	r2,zero,158f0 <etharp_output+0x224>
        /* send to hardware address of default gateway IP address */
        ipaddr = &(netif->gw);
   158e0:	e0bffd17 	ldw	r2,-12(fp)
   158e4:	10800304 	addi	r2,r2,12
   158e8:	e0bfff15 	stw	r2,-4(fp)
   158ec:	00000206 	br	158f8 <etharp_output+0x22c>
      /* no default gateway available */
      } else {
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
   158f0:	00bfff04 	movi	r2,-4
   158f4:	00000c06 	br	15928 <etharp_output+0x25c>
      }
    }
    /* queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, ipaddr, q);
   158f8:	e13ffd17 	ldw	r4,-12(fp)
   158fc:	e17fff17 	ldw	r5,-4(fp)
   15900:	e1bffe17 	ldw	r6,-8(fp)
   15904:	001593c0 	call	1593c <etharp_query>
   15908:	00000706 	br	15928 <etharp_output+0x25c>
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
   1590c:	e0bffd17 	ldw	r2,-12(fp)
   15910:	108009c4 	addi	r2,r2,39
   15914:	e13ffd17 	ldw	r4,-12(fp)
   15918:	e17ffe17 	ldw	r5,-8(fp)
   1591c:	100d883a 	mov	r6,r2
   15920:	e1fffa17 	ldw	r7,-24(fp)
   15924:	0014e080 	call	14e08 <etharp_send_ip>
}
   15928:	e037883a 	mov	sp,fp
   1592c:	dfc00117 	ldw	ra,4(sp)
   15930:	df000017 	ldw	fp,0(sp)
   15934:	dec00204 	addi	sp,sp,8
   15938:	f800283a 	ret

0001593c <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
   1593c:	defff404 	addi	sp,sp,-48
   15940:	dfc00b15 	stw	ra,44(sp)
   15944:	df000a15 	stw	fp,40(sp)
   15948:	df000a04 	addi	fp,sp,40
   1594c:	e13ffd15 	stw	r4,-12(fp)
   15950:	e17ffe15 	stw	r5,-8(fp)
   15954:	e1bfff15 	stw	r6,-4(fp)
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
   15958:	e0bffd17 	ldw	r2,-12(fp)
   1595c:	108009c4 	addi	r2,r2,39
   15960:	e0bffa15 	stw	r2,-24(fp)
  err_t result = ERR_MEM;
   15964:	00bfffc4 	movi	r2,-1
   15968:	e0bff605 	stb	r2,-40(fp)
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
   1596c:	e13ffe17 	ldw	r4,-8(fp)
   15970:	e17ffd17 	ldw	r5,-12(fp)
   15974:	0006db00 	call	6db0 <ip_addr_isbroadcast>
   15978:	10803fcc 	andi	r2,r2,255
   1597c:	1000101e 	bne	r2,zero,159c0 <etharp_query+0x84>
      ip_addr_ismulticast(ipaddr) ||
   15980:	e0bffe17 	ldw	r2,-8(fp)
   15984:	10c0000b 	ldhu	r3,0(r2)
   15988:	1080008b 	ldhu	r2,2(r2)
   1598c:	1004943a 	slli	r2,r2,16
   15990:	10c4b03a 	or	r2,r2,r3
   15994:	10803c0c 	andi	r2,r2,240
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
   15998:	10803820 	cmpeqi	r2,r2,224
   1599c:	1000081e 	bne	r2,zero,159c0 <etharp_query+0x84>
      ip_addr_ismulticast(ipaddr) ||
   159a0:	e0bffe17 	ldw	r2,-8(fp)
   159a4:	10000626 	beq	r2,zero,159c0 <etharp_query+0x84>
      ip_addr_isany(ipaddr)) {
   159a8:	e0bffe17 	ldw	r2,-8(fp)
   159ac:	10c0000b 	ldhu	r3,0(r2)
   159b0:	1080008b 	ldhu	r2,2(r2)
   159b4:	1004943a 	slli	r2,r2,16
   159b8:	10c4b03a 	or	r2,r2,r3
   159bc:	1000021e 	bne	r2,zero,159c8 <etharp_query+0x8c>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
   159c0:	00bffd84 	movi	r2,-10
   159c4:	0000e606 	br	15d60 <etharp_query+0x424>

  /* find entry in ARP cache, ask to create entry if queueing packet */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_TRY_HARD, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_TRY_HARD);
   159c8:	e13ffe17 	ldw	r4,-8(fp)
   159cc:	01400044 	movi	r5,1
   159d0:	00148fc0 	call	148fc <find_entry>
   159d4:	e0bffb05 	stb	r2,-20(fp)
#endif /* LWIP_NETIF_HWADDRHINT */

  /* could not find or create entry? */
  if (i < 0) {
   159d8:	e0bffb07 	ldb	r2,-20(fp)
   159dc:	10000c0e 	bge	r2,zero,15a10 <etharp_query+0xd4>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not create ARP entry\n"));
    if (q) {
   159e0:	e0bfff17 	ldw	r2,-4(fp)
   159e4:	10000826 	beq	r2,zero,15a08 <etharp_query+0xcc>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: packet dropped\n"));
      ETHARP_STATS_INC(etharp.memerr);
   159e8:	00800134 	movhi	r2,4
   159ec:	108d9504 	addi	r2,r2,13908
   159f0:	1080090b 	ldhu	r2,36(r2)
   159f4:	10800044 	addi	r2,r2,1
   159f8:	1007883a 	mov	r3,r2
   159fc:	00800134 	movhi	r2,4
   15a00:	108d9504 	addi	r2,r2,13908
   15a04:	10c0090d 	sth	r3,36(r2)
    }
    return (err_t)i;
   15a08:	e0bffb03 	ldbu	r2,-20(fp)
   15a0c:	0000d406 	br	15d60 <etharp_query+0x424>
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
   15a10:	e0bffb07 	ldb	r2,-20(fp)
   15a14:	00c00134 	movhi	r3,4
   15a18:	18ccff04 	addi	r3,r3,13308
   15a1c:	10800724 	muli	r2,r2,28
   15a20:	1885883a 	add	r2,r3,r2
   15a24:	10800404 	addi	r2,r2,16
   15a28:	10800017 	ldw	r2,0(r2)
   15a2c:	1000081e 	bne	r2,zero,15a50 <etharp_query+0x114>
    arp_table[i].state = ETHARP_STATE_PENDING;
   15a30:	e0bffb07 	ldb	r2,-20(fp)
   15a34:	00c00134 	movhi	r3,4
   15a38:	18ccff04 	addi	r3,r3,13308
   15a3c:	10800724 	muli	r2,r2,28
   15a40:	1885883a 	add	r2,r3,r2
   15a44:	10800404 	addi	r2,r2,16
   15a48:	00c00044 	movi	r3,1
   15a4c:	10c00015 	stw	r3,0(r2)
  }

  /* { i is either a STABLE or (new or existing) PENDING entry } */
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
   15a50:	e0bffb07 	ldb	r2,-20(fp)
   15a54:	00c00134 	movhi	r3,4
   15a58:	18ccff04 	addi	r3,r3,13308
   15a5c:	10800724 	muli	r2,r2,28
   15a60:	1885883a 	add	r2,r3,r2
   15a64:	10800404 	addi	r2,r2,16
   15a68:	10800017 	ldw	r2,0(r2)
   15a6c:	10800060 	cmpeqi	r2,r2,1
   15a70:	1000121e 	bne	r2,zero,15abc <etharp_query+0x180>
   15a74:	e0bffb07 	ldb	r2,-20(fp)
   15a78:	00c00134 	movhi	r3,4
   15a7c:	18ccff04 	addi	r3,r3,13308
   15a80:	10800724 	muli	r2,r2,28
   15a84:	1885883a 	add	r2,r3,r2
   15a88:	10800404 	addi	r2,r2,16
   15a8c:	10800017 	ldw	r2,0(r2)
   15a90:	108000a0 	cmpeqi	r2,r2,2
   15a94:	1000091e 	bne	r2,zero,15abc <etharp_query+0x180>
   15a98:	010000f4 	movhi	r4,3
   15a9c:	213b8204 	addi	r4,r4,-4600
   15aa0:	014000f4 	movhi	r5,3
   15aa4:	297bc704 	addi	r5,r5,-4324
   15aa8:	0180e8c4 	movi	r6,931
   15aac:	01c000f4 	movhi	r7,3
   15ab0:	39fb8f04 	addi	r7,r7,-4548
   15ab4:	00166c00 	call	166c0 <printf>
   15ab8:	003fff06 	br	15ab8 <etharp_query+0x17c>
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
   15abc:	e0bffb07 	ldb	r2,-20(fp)
   15ac0:	00c00134 	movhi	r3,4
   15ac4:	18ccff04 	addi	r3,r3,13308
   15ac8:	10800724 	muli	r2,r2,28
   15acc:	1885883a 	add	r2,r3,r2
   15ad0:	10800404 	addi	r2,r2,16
   15ad4:	10800017 	ldw	r2,0(r2)
   15ad8:	10800060 	cmpeqi	r2,r2,1
   15adc:	1000021e 	bne	r2,zero,15ae8 <etharp_query+0x1ac>
   15ae0:	e0bfff17 	ldw	r2,-4(fp)
   15ae4:	1000041e 	bne	r2,zero,15af8 <etharp_query+0x1bc>
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
   15ae8:	e13ffd17 	ldw	r4,-12(fp)
   15aec:	e17ffe17 	ldw	r5,-8(fp)
   15af0:	0015ff80 	call	15ff8 <etharp_request>
   15af4:	e0bff605 	stb	r2,-40(fp)
         etharp_query again could lead to sending the queued packets. */
    }
  }
  
  /* packet given? */
  if (q != NULL) {
   15af8:	e0bfff17 	ldw	r2,-4(fp)
   15afc:	10009726 	beq	r2,zero,15d5c <etharp_query+0x420>
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
   15b00:	e0bffb07 	ldb	r2,-20(fp)
   15b04:	00c00134 	movhi	r3,4
   15b08:	18ccff04 	addi	r3,r3,13308
   15b0c:	10800724 	muli	r2,r2,28
   15b10:	1885883a 	add	r2,r3,r2
   15b14:	10800404 	addi	r2,r2,16
   15b18:	10800017 	ldw	r2,0(r2)
   15b1c:	10800098 	cmpnei	r2,r2,2
   15b20:	10000d1e 	bne	r2,zero,15b58 <etharp_query+0x21c>
      /* we have a valid IP->Ethernet address mapping */
      /* send the packet */
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
   15b24:	e0bffb07 	ldb	r2,-20(fp)
   15b28:	10800724 	muli	r2,r2,28
   15b2c:	10c00204 	addi	r3,r2,8
   15b30:	00800134 	movhi	r2,4
   15b34:	108cff04 	addi	r2,r2,13308
   15b38:	1885883a 	add	r2,r3,r2
   15b3c:	e13ffd17 	ldw	r4,-12(fp)
   15b40:	e17fff17 	ldw	r5,-4(fp)
   15b44:	e1bffa17 	ldw	r6,-24(fp)
   15b48:	100f883a 	mov	r7,r2
   15b4c:	0014e080 	call	14e08 <etharp_send_ip>
   15b50:	e0bff605 	stb	r2,-40(fp)
   15b54:	00008106 	br	15d5c <etharp_query+0x420>
    /* pending entry? (either just created or already pending */
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
   15b58:	e0bffb07 	ldb	r2,-20(fp)
   15b5c:	00c00134 	movhi	r3,4
   15b60:	18ccff04 	addi	r3,r3,13308
   15b64:	10800724 	muli	r2,r2,28
   15b68:	1885883a 	add	r2,r3,r2
   15b6c:	10800404 	addi	r2,r2,16
   15b70:	10800017 	ldw	r2,0(r2)
   15b74:	10800058 	cmpnei	r2,r2,1
   15b78:	1000781e 	bne	r2,zero,15d5c <etharp_query+0x420>
#if ARP_QUEUEING /* queue the given q packet */
      struct pbuf *p;
      int copy_needed = 0;
   15b7c:	e03ff815 	stw	zero,-32(fp)
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
   15b80:	e0bfff17 	ldw	r2,-4(fp)
   15b84:	e0bff715 	stw	r2,-36(fp)
      while (p) {
   15b88:	00001e06 	br	15c04 <etharp_query+0x2c8>
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
   15b8c:	e0bff717 	ldw	r2,-36(fp)
   15b90:	10c0028b 	ldhu	r3,10(r2)
   15b94:	e0bff717 	ldw	r2,-36(fp)
   15b98:	1080020b 	ldhu	r2,8(r2)
   15b9c:	18ffffcc 	andi	r3,r3,65535
   15ba0:	10bfffcc 	andi	r2,r2,65535
   15ba4:	18800c1e 	bne	r3,r2,15bd8 <etharp_query+0x29c>
   15ba8:	e0bff717 	ldw	r2,-36(fp)
   15bac:	10800017 	ldw	r2,0(r2)
   15bb0:	10000926 	beq	r2,zero,15bd8 <etharp_query+0x29c>
   15bb4:	010000f4 	movhi	r4,3
   15bb8:	213b8204 	addi	r4,r4,-4600
   15bbc:	014000f4 	movhi	r5,3
   15bc0:	297bd104 	addi	r5,r5,-4284
   15bc4:	0180f084 	movi	r6,962
   15bc8:	01c000f4 	movhi	r7,3
   15bcc:	39fb8f04 	addi	r7,r7,-4548
   15bd0:	00166c00 	call	166c0 <printf>
   15bd4:	003fff06 	br	15bd4 <etharp_query+0x298>
        if(p->type != PBUF_ROM) {
   15bd8:	e0bff717 	ldw	r2,-36(fp)
   15bdc:	10800303 	ldbu	r2,12(r2)
   15be0:	10803fcc 	andi	r2,r2,255
   15be4:	10800060 	cmpeqi	r2,r2,1
   15be8:	1000031e 	bne	r2,zero,15bf8 <etharp_query+0x2bc>
          copy_needed = 1;
   15bec:	00800044 	movi	r2,1
   15bf0:	e0bff815 	stw	r2,-32(fp)
          break;
   15bf4:	00000506 	br	15c0c <etharp_query+0x2d0>
        }
        p = p->next;
   15bf8:	e0bff717 	ldw	r2,-36(fp)
   15bfc:	10800017 	ldw	r2,0(r2)
   15c00:	e0bff715 	stw	r2,-36(fp)
      int copy_needed = 0;
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
   15c04:	e0bff717 	ldw	r2,-36(fp)
   15c08:	103fe01e 	bne	r2,zero,15b8c <etharp_query+0x250>
          copy_needed = 1;
          break;
        }
        p = p->next;
      }
      if(copy_needed) {
   15c0c:	e0bff817 	ldw	r2,-32(fp)
   15c10:	10001526 	beq	r2,zero,15c68 <etharp_query+0x32c>
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
   15c14:	e0bff717 	ldw	r2,-36(fp)
   15c18:	1080020b 	ldhu	r2,8(r2)
   15c1c:	10bfffcc 	andi	r2,r2,65535
   15c20:	010000c4 	movi	r4,3
   15c24:	100b883a 	mov	r5,r2
   15c28:	000d883a 	mov	r6,zero
   15c2c:	00097b00 	call	97b0 <pbuf_alloc>
   15c30:	e0bff715 	stw	r2,-36(fp)
        if(p != NULL) {
   15c34:	e0bff717 	ldw	r2,-36(fp)
   15c38:	10000f26 	beq	r2,zero,15c78 <etharp_query+0x33c>
          if (pbuf_copy(p, q) != ERR_OK) {
   15c3c:	e13ff717 	ldw	r4,-36(fp)
   15c40:	e17fff17 	ldw	r5,-4(fp)
   15c44:	000a6700 	call	a670 <pbuf_copy>
   15c48:	10803fcc 	andi	r2,r2,255
   15c4c:	1080201c 	xori	r2,r2,128
   15c50:	10bfe004 	addi	r2,r2,-128
   15c54:	10000826 	beq	r2,zero,15c78 <etharp_query+0x33c>
            pbuf_free(p);
   15c58:	e13ff717 	ldw	r4,-36(fp)
   15c5c:	000a16c0 	call	a16c <pbuf_free>
            p = NULL;
   15c60:	e03ff715 	stw	zero,-36(fp)
   15c64:	00000406 	br	15c78 <etharp_query+0x33c>
          }
        }
      } else {
        /* referencing the old pbuf is enough */
        p = q;
   15c68:	e0bfff17 	ldw	r2,-4(fp)
   15c6c:	e0bff715 	stw	r2,-36(fp)
        pbuf_ref(p);
   15c70:	e13ff717 	ldw	r4,-36(fp)
   15c74:	000a3840 	call	a384 <pbuf_ref>
      }
      /* packet could be taken over? */
      if (p != NULL) {
   15c78:	e0bff717 	ldw	r2,-36(fp)
   15c7c:	10002f26 	beq	r2,zero,15d3c <etharp_query+0x400>
        /* queue packet ... */
        struct etharp_q_entry *new_entry;
        /* allocate a new arp queue entry */
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
   15c80:	01000184 	movi	r4,6
   15c84:	0008ef00 	call	8ef0 <memp_malloc>
   15c88:	e0bffc15 	stw	r2,-16(fp)
        if (new_entry != NULL) {
   15c8c:	e0bffc17 	ldw	r2,-16(fp)
   15c90:	10002726 	beq	r2,zero,15d30 <etharp_query+0x3f4>
          new_entry->next = 0;
   15c94:	e0bffc17 	ldw	r2,-16(fp)
   15c98:	10000015 	stw	zero,0(r2)
          new_entry->p = p;
   15c9c:	e0bffc17 	ldw	r2,-16(fp)
   15ca0:	e0fff717 	ldw	r3,-36(fp)
   15ca4:	10c00115 	stw	r3,4(r2)
          if(arp_table[i].q != NULL) {
   15ca8:	e0bffb07 	ldb	r2,-20(fp)
   15cac:	00c00134 	movhi	r3,4
   15cb0:	18ccff04 	addi	r3,r3,13308
   15cb4:	10800724 	muli	r2,r2,28
   15cb8:	1885883a 	add	r2,r3,r2
   15cbc:	10800017 	ldw	r2,0(r2)
   15cc0:	10001226 	beq	r2,zero,15d0c <etharp_query+0x3d0>
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
   15cc4:	e0bffb07 	ldb	r2,-20(fp)
   15cc8:	00c00134 	movhi	r3,4
   15ccc:	18ccff04 	addi	r3,r3,13308
   15cd0:	10800724 	muli	r2,r2,28
   15cd4:	1885883a 	add	r2,r3,r2
   15cd8:	10800017 	ldw	r2,0(r2)
   15cdc:	e0bff915 	stw	r2,-28(fp)
            while (r->next != NULL) {
   15ce0:	00000306 	br	15cf0 <etharp_query+0x3b4>
              r = r->next;
   15ce4:	e0bff917 	ldw	r2,-28(fp)
   15ce8:	10800017 	ldw	r2,0(r2)
   15cec:	e0bff915 	stw	r2,-28(fp)
          new_entry->p = p;
          if(arp_table[i].q != NULL) {
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
            while (r->next != NULL) {
   15cf0:	e0bff917 	ldw	r2,-28(fp)
   15cf4:	10800017 	ldw	r2,0(r2)
   15cf8:	103ffa1e 	bne	r2,zero,15ce4 <etharp_query+0x3a8>
              r = r->next;
            }
            r->next = new_entry;
   15cfc:	e0bff917 	ldw	r2,-28(fp)
   15d00:	e0fffc17 	ldw	r3,-16(fp)
   15d04:	10c00015 	stw	r3,0(r2)
   15d08:	00000706 	br	15d28 <etharp_query+0x3ec>
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
   15d0c:	e0bffb07 	ldb	r2,-20(fp)
   15d10:	00c00134 	movhi	r3,4
   15d14:	18ccff04 	addi	r3,r3,13308
   15d18:	10800724 	muli	r2,r2,28
   15d1c:	1885883a 	add	r2,r3,r2
   15d20:	e0fffc17 	ldw	r3,-16(fp)
   15d24:	10c00015 	stw	r3,0(r2)
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
   15d28:	e03ff605 	stb	zero,-40(fp)
   15d2c:	00000b06 	br	15d5c <etharp_query+0x420>
        } else {
          /* the pool MEMP_ARP_QUEUE is empty */
          pbuf_free(p);
   15d30:	e13ff717 	ldw	r4,-36(fp)
   15d34:	000a16c0 	call	a16c <pbuf_free>
   15d38:	00000806 	br	15d5c <etharp_query+0x420>
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
          /* { result == ERR_MEM } through initialization */
        }
      } else {
        ETHARP_STATS_INC(etharp.memerr);
   15d3c:	00800134 	movhi	r2,4
   15d40:	108d9504 	addi	r2,r2,13908
   15d44:	1080090b 	ldhu	r2,36(r2)
   15d48:	10800044 	addi	r2,r2,1
   15d4c:	1007883a 	mov	r3,r2
   15d50:	00800134 	movhi	r2,4
   15d54:	108d9504 	addi	r2,r2,13908
   15d58:	10c0090d 	sth	r3,36(r2)
      /* { result == ERR_MEM } through initialization */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: Ethernet destination address unknown, queueing disabled, packet %p dropped\n", (void *)q));
#endif
    }
  }
  return result;
   15d5c:	e0bff603 	ldbu	r2,-40(fp)
}
   15d60:	e037883a 	mov	sp,fp
   15d64:	dfc00117 	ldw	ra,4(sp)
   15d68:	df000017 	ldw	fp,0(sp)
   15d6c:	dec00204 	addi	sp,sp,8
   15d70:	f800283a 	ret

00015d74 <etharp_raw>:
etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
           const struct eth_addr *ethdst_addr,
           const struct eth_addr *hwsrc_addr, const struct ip_addr *ipsrc_addr,
           const struct eth_addr *hwdst_addr, const struct ip_addr *ipdst_addr,
           const u16_t opcode)
{
   15d74:	defff504 	addi	sp,sp,-44
   15d78:	dfc00a15 	stw	ra,40(sp)
   15d7c:	df000915 	stw	fp,36(sp)
   15d80:	df000904 	addi	fp,sp,36
   15d84:	e13ffb15 	stw	r4,-20(fp)
   15d88:	e17ffc15 	stw	r5,-16(fp)
   15d8c:	e1bffd15 	stw	r6,-12(fp)
   15d90:	e1fffe15 	stw	r7,-8(fp)
   15d94:	e0800517 	ldw	r2,20(fp)
   15d98:	e0bfff0d 	sth	r2,-4(fp)
  struct pbuf *p;
  err_t result = ERR_OK;
   15d9c:	e03ff745 	stb	zero,-35(fp)
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
   15da0:	010000c4 	movi	r4,3
   15da4:	01400b04 	movi	r5,44
   15da8:	000d883a 	mov	r6,zero
   15dac:	00097b00 	call	97b0 <pbuf_alloc>
   15db0:	e0bff815 	stw	r2,-32(fp)
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
   15db4:	e0bff817 	ldw	r2,-32(fp)
   15db8:	10000a1e 	bne	r2,zero,15de4 <etharp_raw+0x70>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
   15dbc:	00800134 	movhi	r2,4
   15dc0:	108d9504 	addi	r2,r2,13908
   15dc4:	1080090b 	ldhu	r2,36(r2)
   15dc8:	10800044 	addi	r2,r2,1
   15dcc:	1007883a 	mov	r3,r2
   15dd0:	00800134 	movhi	r2,4
   15dd4:	108d9504 	addi	r2,r2,13908
   15dd8:	10c0090d 	sth	r3,36(r2)
    return ERR_MEM;
   15ddc:	00bfffc4 	movi	r2,-1
   15de0:	00008006 	br	15fe4 <etharp_raw+0x270>
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
   15de4:	e0bff817 	ldw	r2,-32(fp)
   15de8:	1080028b 	ldhu	r2,10(r2)
   15dec:	10bfffcc 	andi	r2,r2,65535
   15df0:	10800b28 	cmpgeui	r2,r2,44
   15df4:	1000091e 	bne	r2,zero,15e1c <etharp_raw+0xa8>
   15df8:	010000f4 	movhi	r4,3
   15dfc:	213b8204 	addi	r4,r4,-4600
   15e00:	014000f4 	movhi	r5,3
   15e04:	297bd804 	addi	r5,r5,-4256
   15e08:	01810bc4 	movi	r6,1071
   15e0c:	01c000f4 	movhi	r7,3
   15e10:	39fb8f04 	addi	r7,r7,-4548
   15e14:	00166c00 	call	166c0 <printf>
   15e18:	003fff06 	br	15e18 <etharp_raw+0xa4>
              (p->len >= SIZEOF_ETHARP_PACKET));

  ethhdr = p->payload;
   15e1c:	e0bff817 	ldw	r2,-32(fp)
   15e20:	10800117 	ldw	r2,4(r2)
   15e24:	e0bff915 	stw	r2,-28(fp)
  hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
   15e28:	e0bff917 	ldw	r2,-28(fp)
   15e2c:	10800404 	addi	r2,r2,16
   15e30:	e0bffa15 	stw	r2,-24(fp)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
   15e34:	e0bfff0b 	ldhu	r2,-4(fp)
   15e38:	1004d23a 	srli	r2,r2,8
   15e3c:	1007883a 	mov	r3,r2
   15e40:	e0bfff0b 	ldhu	r2,-4(fp)
   15e44:	1004923a 	slli	r2,r2,8
   15e48:	1884b03a 	or	r2,r3,r2
   15e4c:	1007883a 	mov	r3,r2
   15e50:	e0bffa17 	ldw	r2,-24(fp)
   15e54:	10c0018d 	sth	r3,6(r2)

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
   15e58:	e0bffb17 	ldw	r2,-20(fp)
   15e5c:	10800983 	ldbu	r2,38(r2)
   15e60:	10803fcc 	andi	r2,r2,255
   15e64:	108001a0 	cmpeqi	r2,r2,6
   15e68:	1000091e 	bne	r2,zero,15e90 <etharp_raw+0x11c>
   15e6c:	010000f4 	movhi	r4,3
   15e70:	213b8204 	addi	r4,r4,-4600
   15e74:	014000f4 	movhi	r5,3
   15e78:	297ba804 	addi	r5,r5,-4448
   15e7c:	01810dc4 	movi	r6,1079
   15e80:	01c000f4 	movhi	r7,3
   15e84:	39fb8f04 	addi	r7,r7,-4548
   15e88:	00166c00 	call	166c0 <printf>
   15e8c:	003fff06 	br	15e8c <etharp_raw+0x118>
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
   15e90:	00800184 	movi	r2,6
   15e94:	e0bff705 	stb	r2,-36(fp)
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
   15e98:	00002606 	br	15f34 <etharp_raw+0x1c0>
    k--;
   15e9c:	e0bff703 	ldbu	r2,-36(fp)
   15ea0:	10bfffc4 	addi	r2,r2,-1
   15ea4:	e0bff705 	stb	r2,-36(fp)
    /* Write the ARP MAC-Addresses */
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
   15ea8:	e0bff703 	ldbu	r2,-36(fp)
   15eac:	e0fff703 	ldbu	r3,-36(fp)
   15eb0:	e13ffe17 	ldw	r4,-8(fp)
   15eb4:	20c7883a 	add	r3,r4,r3
   15eb8:	18c00003 	ldbu	r3,0(r3)
   15ebc:	e13ffa17 	ldw	r4,-24(fp)
   15ec0:	2085883a 	add	r2,r4,r2
   15ec4:	10800204 	addi	r2,r2,8
   15ec8:	10c00005 	stb	r3,0(r2)
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
   15ecc:	e0bff703 	ldbu	r2,-36(fp)
   15ed0:	e0fff703 	ldbu	r3,-36(fp)
   15ed4:	e1000317 	ldw	r4,12(fp)
   15ed8:	20c7883a 	add	r3,r4,r3
   15edc:	18c00003 	ldbu	r3,0(r3)
   15ee0:	e13ffa17 	ldw	r4,-24(fp)
   15ee4:	2085883a 	add	r2,r4,r2
   15ee8:	10800404 	addi	r2,r2,16
   15eec:	10c00085 	stb	r3,2(r2)
    /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
    ethhdr->dest.addr[k] = ethdst_hwaddr[k];
#else  /* LWIP_AUTOIP */
    ethhdr->dest.addr[k] = ethdst_addr->addr[k];
   15ef0:	e0bff703 	ldbu	r2,-36(fp)
   15ef4:	e0fff703 	ldbu	r3,-36(fp)
   15ef8:	e13ffd17 	ldw	r4,-12(fp)
   15efc:	20c7883a 	add	r3,r4,r3
   15f00:	18c00003 	ldbu	r3,0(r3)
   15f04:	e13ff917 	ldw	r4,-28(fp)
   15f08:	2085883a 	add	r2,r4,r2
   15f0c:	10c00085 	stb	r3,2(r2)
#endif /* LWIP_AUTOIP */
    ethhdr->src.addr[k]  = ethsrc_addr->addr[k];
   15f10:	e0bff703 	ldbu	r2,-36(fp)
   15f14:	e0fff703 	ldbu	r3,-36(fp)
   15f18:	e13ffc17 	ldw	r4,-16(fp)
   15f1c:	20c7883a 	add	r3,r4,r3
   15f20:	18c00003 	ldbu	r3,0(r3)
   15f24:	e13ff917 	ldw	r4,-28(fp)
   15f28:	2085883a 	add	r2,r4,r2
   15f2c:	10800204 	addi	r2,r2,8
   15f30:	10c00005 	stb	r3,0(r2)
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
   15f34:	e0bff703 	ldbu	r2,-36(fp)
   15f38:	103fd81e 	bne	r2,zero,15e9c <etharp_raw+0x128>
#else  /* LWIP_AUTOIP */
    ethhdr->dest.addr[k] = ethdst_addr->addr[k];
#endif /* LWIP_AUTOIP */
    ethhdr->src.addr[k]  = ethsrc_addr->addr[k];
  }
  hdr->sipaddr = *(struct ip_addr2 *)ipsrc_addr;
   15f3c:	e0bffa17 	ldw	r2,-24(fp)
   15f40:	e0c00217 	ldw	r3,8(fp)
   15f44:	1900000b 	ldhu	r4,0(r3)
   15f48:	1100038d 	sth	r4,14(r2)
   15f4c:	18c0008b 	ldhu	r3,2(r3)
   15f50:	10c0040d 	sth	r3,16(r2)
  hdr->dipaddr = *(struct ip_addr2 *)ipdst_addr;
   15f54:	e0bffa17 	ldw	r2,-24(fp)
   15f58:	e0c00417 	ldw	r3,16(fp)
   15f5c:	1900000b 	ldhu	r4,0(r3)
   15f60:	1100060d 	sth	r4,24(r2)
   15f64:	18c0008b 	ldhu	r3,2(r3)
   15f68:	10c0068d 	sth	r3,26(r2)

  hdr->hwtype = htons(HWTYPE_ETHERNET);
   15f6c:	e0bffa17 	ldw	r2,-24(fp)
   15f70:	00c04004 	movi	r3,256
   15f74:	10c0000d 	sth	r3,0(r2)
  hdr->proto = htons(ETHTYPE_IP);
   15f78:	e0bffa17 	ldw	r2,-24(fp)
   15f7c:	00c00204 	movi	r3,8
   15f80:	10c0008d 	sth	r3,2(r2)
  /* set hwlen and protolen together */
  hdr->_hwlen_protolen = htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr));
   15f84:	e0bffa17 	ldw	r2,-24(fp)
   15f88:	00c10184 	movi	r3,1030
   15f8c:	10c0010d 	sth	r3,4(r2)

  ethhdr->type = htons(ETHTYPE_ARP);
   15f90:	e0bff917 	ldw	r2,-28(fp)
   15f94:	00c18204 	movi	r3,1544
   15f98:	10c0038d 	sth	r3,14(r2)
  /* send ARP query */
  result = netif->linkoutput(netif, p);
   15f9c:	e0bffb17 	ldw	r2,-20(fp)
   15fa0:	10800617 	ldw	r2,24(r2)
   15fa4:	e13ffb17 	ldw	r4,-20(fp)
   15fa8:	e17ff817 	ldw	r5,-32(fp)
   15fac:	103ee83a 	callr	r2
   15fb0:	e0bff745 	stb	r2,-35(fp)
  ETHARP_STATS_INC(etharp.xmit);
   15fb4:	00800134 	movhi	r2,4
   15fb8:	108d9504 	addi	r2,r2,13908
   15fbc:	1080060b 	ldhu	r2,24(r2)
   15fc0:	10800044 	addi	r2,r2,1
   15fc4:	1007883a 	mov	r3,r2
   15fc8:	00800134 	movhi	r2,4
   15fcc:	108d9504 	addi	r2,r2,13908
   15fd0:	10c0060d 	sth	r3,24(r2)
  /* free ARP query packet */
  pbuf_free(p);
   15fd4:	e13ff817 	ldw	r4,-32(fp)
   15fd8:	000a16c0 	call	a16c <pbuf_free>
  p = NULL;
   15fdc:	e03ff815 	stw	zero,-32(fp)
  /* could not allocate pbuf for ARP request */

  return result;
   15fe0:	e0bff743 	ldbu	r2,-35(fp)
}
   15fe4:	e037883a 	mov	sp,fp
   15fe8:	dfc00117 	ldw	ra,4(sp)
   15fec:	df000017 	ldw	fp,0(sp)
   15ff0:	dec00204 	addi	sp,sp,8
   15ff4:	f800283a 	ret

00015ff8 <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
   15ff8:	defff804 	addi	sp,sp,-32
   15ffc:	dfc00715 	stw	ra,28(sp)
   16000:	df000615 	stw	fp,24(sp)
   16004:	df000604 	addi	fp,sp,24
   16008:	e13ffe15 	stw	r4,-8(fp)
   1600c:	e17fff15 	stw	r5,-4(fp)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
   16010:	e0bffe17 	ldw	r2,-8(fp)
   16014:	10c009c4 	addi	r3,r2,39
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
   16018:	e0bffe17 	ldw	r2,-8(fp)
   1601c:	108009c4 	addi	r2,r2,39
   16020:	e13ffe17 	ldw	r4,-8(fp)
   16024:	21000104 	addi	r4,r4,4
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
   16028:	d9000015 	stw	r4,0(sp)
   1602c:	d1200884 	addi	r4,gp,-32734
   16030:	d9000115 	stw	r4,4(sp)
   16034:	e13fff17 	ldw	r4,-4(fp)
   16038:	d9000215 	stw	r4,8(sp)
   1603c:	01000044 	movi	r4,1
   16040:	d9000315 	stw	r4,12(sp)
   16044:	e13ffe17 	ldw	r4,-8(fp)
   16048:	180b883a 	mov	r5,r3
   1604c:	d1a00704 	addi	r6,gp,-32740
   16050:	100f883a 	mov	r7,r2
   16054:	0015d740 	call	15d74 <etharp_raw>
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
   16058:	e037883a 	mov	sp,fp
   1605c:	dfc00117 	ldw	ra,4(sp)
   16060:	df000017 	ldw	fp,0(sp)
   16064:	dec00204 	addi	sp,sp,8
   16068:	f800283a 	ret

0001606c <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
   1606c:	defffa04 	addi	sp,sp,-24
   16070:	dfc00515 	stw	ra,20(sp)
   16074:	df000415 	stw	fp,16(sp)
   16078:	df000404 	addi	fp,sp,16
   1607c:	e13ffe15 	stw	r4,-8(fp)
   16080:	e17fff15 	stw	r5,-4(fp)
  struct eth_hdr* ethhdr;
  u16_t type;

  /* points to packet payload, which starts with an Ethernet header */
  ethhdr = p->payload;
   16084:	e0bffe17 	ldw	r2,-8(fp)
   16088:	10800117 	ldw	r2,4(r2)
   1608c:	e0bffc15 	stw	r2,-16(fp)
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  type = htons(ethhdr->type);
   16090:	e0bffc17 	ldw	r2,-16(fp)
   16094:	1080038b 	ldhu	r2,14(r2)
   16098:	10bfffcc 	andi	r2,r2,65535
   1609c:	1004d23a 	srli	r2,r2,8
   160a0:	1007883a 	mov	r3,r2
   160a4:	e0bffc17 	ldw	r2,-16(fp)
   160a8:	1080038b 	ldhu	r2,14(r2)
   160ac:	10bfffcc 	andi	r2,r2,65535
   160b0:	1004923a 	slli	r2,r2,8
   160b4:	1884b03a 	or	r2,r3,r2
   160b8:	e0bffd0d 	sth	r2,-12(fp)
#endif /* ETHARP_VLAN_CHECK */
    type = htons(vlan->tpid);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  switch (type) {
   160bc:	e0bffd0b 	ldhu	r2,-12(fp)
   160c0:	10c20020 	cmpeqi	r3,r2,2048
   160c4:	1800031e 	bne	r3,zero,160d4 <ethernet_input+0x68>
   160c8:	108201a0 	cmpeqi	r2,r2,2054
   160cc:	1000161e 	bne	r2,zero,16128 <ethernet_input+0xbc>
   160d0:	00001c06 	br	16144 <ethernet_input+0xd8>
    /* IP packet? */
    case ETHTYPE_IP:
#if ETHARP_TRUST_IP_MAC
      /* update ARP table */
      etharp_ip_input(netif, p);
   160d4:	e13fff17 	ldw	r4,-4(fp)
   160d8:	e17ffe17 	ldw	r5,-8(fp)
   160dc:	00151fc0 	call	151fc <etharp_ip_input>
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -(s16_t)SIZEOF_ETH_HDR)) {
   160e0:	e13ffe17 	ldw	r4,-8(fp)
   160e4:	017ffc04 	movi	r5,-16
   160e8:	0009f740 	call	9f74 <pbuf_header>
   160ec:	10803fcc 	andi	r2,r2,255
   160f0:	10000926 	beq	r2,zero,16118 <ethernet_input+0xac>
        LWIP_ASSERT("Can't move over header in packet", 0);
   160f4:	010000f4 	movhi	r4,3
   160f8:	213b8204 	addi	r4,r4,-4600
   160fc:	014000f4 	movhi	r5,3
   16100:	297be504 	addi	r5,r5,-4204
   16104:	01812884 	movi	r6,1186
   16108:	01c000f4 	movhi	r7,3
   1610c:	39fb8f04 	addi	r7,r7,-4548
   16110:	00166c00 	call	166c0 <printf>
   16114:	003fff06 	br	16114 <ethernet_input+0xa8>
        pbuf_free(p);
        p = NULL;
      } else {
        /* pass to IP layer */
        ip_input(p, netif);
   16118:	e13ffe17 	ldw	r4,-8(fp)
   1611c:	e17fff17 	ldw	r5,-4(fp)
   16120:	00062900 	call	6290 <ip_input>
      }
      break;
   16124:	00001b06 	br	16194 <ethernet_input+0x128>
      
    case ETHTYPE_ARP:
      /* pass p to ARP module */
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
   16128:	e0bfff17 	ldw	r2,-4(fp)
   1612c:	108009c4 	addi	r2,r2,39
   16130:	e13fff17 	ldw	r4,-4(fp)
   16134:	100b883a 	mov	r5,r2
   16138:	e1bffe17 	ldw	r6,-8(fp)
   1613c:	00152cc0 	call	152cc <etharp_arp_input>
      break;
   16140:	00001406 	br	16194 <ethernet_input+0x128>
      pppoe_data_input(netif, p);
      break;
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
   16144:	00800134 	movhi	r2,4
   16148:	108d9504 	addi	r2,r2,13908
   1614c:	10800a0b 	ldhu	r2,40(r2)
   16150:	10800044 	addi	r2,r2,1
   16154:	1007883a 	mov	r3,r2
   16158:	00800134 	movhi	r2,4
   1615c:	108d9504 	addi	r2,r2,13908
   16160:	10c00a0d 	sth	r3,40(r2)
      ETHARP_STATS_INC(etharp.drop);
   16164:	00800134 	movhi	r2,4
   16168:	108d9504 	addi	r2,r2,13908
   1616c:	1080078b 	ldhu	r2,30(r2)
   16170:	10800044 	addi	r2,r2,1
   16174:	1007883a 	mov	r3,r2
   16178:	00800134 	movhi	r2,4
   1617c:	108d9504 	addi	r2,r2,13908
   16180:	10c0078d 	sth	r3,30(r2)
      pbuf_free(p);
   16184:	e13ffe17 	ldw	r4,-8(fp)
   16188:	000a16c0 	call	a16c <pbuf_free>
      p = NULL;
   1618c:	e03ffe15 	stw	zero,-8(fp)
      break;
   16190:	0001883a 	nop
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
   16194:	0005883a 	mov	r2,zero
}
   16198:	e037883a 	mov	sp,fp
   1619c:	dfc00117 	ldw	ra,4(sp)
   161a0:	df000017 	ldw	fp,0(sp)
   161a4:	dec00204 	addi	sp,sp,8
   161a8:	f800283a 	ret

000161ac <lwipAlarmCallback>:
static alt_u32  lwipTicksPer250mS;
static alt_u32  lwip250mStimer;

//  Alarm callback function.
alt_u32 lwipAlarmCallback(void* context)
{
   161ac:	defffe04 	addi	sp,sp,-8
   161b0:	df000115 	stw	fp,4(sp)
   161b4:	df000104 	addi	fp,sp,4
   161b8:	e13fff15 	stw	r4,-4(fp)
    lwipProcessTimerFlag = 1;          //  Set flag to process timers
   161bc:	00800044 	movi	r2,1
   161c0:	d0a8e615 	stw	r2,-23656(gp)
    return lwipTicksPer250mS;
   161c4:	d0a8e717 	ldw	r2,-23652(gp)
}
   161c8:	e037883a 	mov	sp,fp
   161cc:	df000017 	ldw	fp,0(sp)
   161d0:	dec00104 	addi	sp,sp,4
   161d4:	f800283a 	ret

000161d8 <main>:

//  Define netif for lwIP
struct netif    alteraTseNetif;

int main()
{
   161d8:	defffb04 	addi	sp,sp,-20
   161dc:	dfc00415 	stw	ra,16(sp)
   161e0:	df000315 	stw	fp,12(sp)
   161e4:	df000304 	addi	fp,sp,12
static struct ip_addr   ip_zero = { 0 };
void httpd_init(void);

    printf("Running...\n");
   161e8:	010000f4 	movhi	r4,3
   161ec:	213bee04 	addi	r4,r4,-4168
   161f0:	00169500 	call	16950 <puts>
    lwip250mStimer = 0;
   161f4:	d028e815 	stw	zero,-23648(gp)
    lwipProcessTimerFlag = 0;
   161f8:	d028e615 	stw	zero,-23656(gp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
   161fc:	008000f4 	movhi	r2,3
   16200:	10961504 	addi	r2,r2,22612
   16204:	10800017 	ldw	r2,0(r2)
    lwipTicksPer250mS = alt_ticks_per_second() / 4;
   16208:	1004d0ba 	srli	r2,r2,2
   1620c:	d0a8e715 	stw	r2,-23652(gp)
    if (alt_alarm_start (&lwipAlarm, lwipTicksPer250mS, lwipAlarmCallback, NULL) < 0)
   16210:	d0a8e717 	ldw	r2,-23652(gp)
   16214:	01000134 	movhi	r4,4
   16218:	210d4504 	addi	r4,r4,13588
   1621c:	100b883a 	mov	r5,r2
   16220:	01800074 	movhi	r6,1
   16224:	31986b04 	addi	r6,r6,25004
   16228:	000f883a 	mov	r7,zero
   1622c:	001fbb40 	call	1fbb4 <alt_alarm_start>
   16230:	1000040e 	bge	r2,zero,16244 <main+0x6c>
        {
        printf ("System clock is required!\n");
   16234:	010000f4 	movhi	r4,3
   16238:	213bf104 	addi	r4,r4,-4156
   1623c:	00169500 	call	16950 <puts>
        for(;;);
   16240:	003fff06 	br	16240 <main+0x68>
        }
    
    //  Load platform specific MAC address into netif
    alteraTseNetif.hwaddr[0] = 0x00;
   16244:	00800134 	movhi	r2,4
   16248:	108ddb04 	addi	r2,r2,14188
   1624c:	100009c5 	stb	zero,39(r2)
    alteraTseNetif.hwaddr[1] = 0x07;
   16250:	00800134 	movhi	r2,4
   16254:	108ddb04 	addi	r2,r2,14188
   16258:	00c001c4 	movi	r3,7
   1625c:	10c00a05 	stb	r3,40(r2)
    alteraTseNetif.hwaddr[2] = 0xab;
   16260:	00800134 	movhi	r2,4
   16264:	108ddb04 	addi	r2,r2,14188
   16268:	00ffeac4 	movi	r3,-85
   1626c:	10c00a45 	stb	r3,41(r2)
    alteraTseNetif.hwaddr[3] = 0xf0;
   16270:	00800134 	movhi	r2,4
   16274:	108ddb04 	addi	r2,r2,14188
   16278:	00fffc04 	movi	r3,-16
   1627c:	10c00a85 	stb	r3,42(r2)
    alteraTseNetif.hwaddr[4] = 0x0d;
   16280:	00800134 	movhi	r2,4
   16284:	108ddb04 	addi	r2,r2,14188
   16288:	00c00344 	movi	r3,13
   1628c:	10c00ac5 	stb	r3,43(r2)
    alteraTseNetif.hwaddr[5] = 0xba;
   16290:	00800134 	movhi	r2,4
   16294:	108ddb04 	addi	r2,r2,14188
   16298:	00ffee84 	movi	r3,-70
   1629c:	10c00b05 	stb	r3,44(r2)

    //  Initialize lwIP, Altera TSE and the ethernetif
    lwip_init();
   162a0:	0004da40 	call	4da4 <lwip_init>
    if(netif_add(&alteraTseNetif, &ip_zero, &ip_zero, &ip_zero, alteraTseNetif.state, ethernetif_init, ethernet_input) == NULL)
   162a4:	00800134 	movhi	r2,4
   162a8:	108ddb04 	addi	r2,r2,14188
   162ac:	10800717 	ldw	r2,28(r2)
   162b0:	d8800015 	stw	r2,0(sp)
   162b4:	00800034 	movhi	r2,0
   162b8:	10810604 	addi	r2,r2,1048
   162bc:	d8800115 	stw	r2,4(sp)
   162c0:	00800074 	movhi	r2,1
   162c4:	10981b04 	addi	r2,r2,24684
   162c8:	d8800215 	stw	r2,8(sp)
   162cc:	01000134 	movhi	r4,4
   162d0:	210ddb04 	addi	r4,r4,14188
   162d4:	d168e904 	addi	r5,gp,-23644
   162d8:	d1a8e904 	addi	r6,gp,-23644
   162dc:	d1e8e904 	addi	r7,gp,-23644
   162e0:	00091c40 	call	91c4 <netif_add>
   162e4:	1000041e 	bne	r2,zero,162f8 <main+0x120>
        {
        printf( "Fatal error initializing...\n" );
   162e8:	010000f4 	movhi	r4,3
   162ec:	213bf804 	addi	r4,r4,-4128
   162f0:	00169500 	call	16950 <puts>
        for(;;);
   162f4:	003fff06 	br	162f4 <main+0x11c>
        }
    netif_set_default(&alteraTseNetif);
   162f8:	01000134 	movhi	r4,4
   162fc:	210ddb04 	addi	r4,r4,14188
   16300:	00096880 	call	9688 <netif_set_default>
    
    // Initialize Altera TSE in a loop if waiting for a link
    printf("Waiting for link...");
   16304:	010000f4 	movhi	r4,3
   16308:	213bff04 	addi	r4,r4,-4100
   1630c:	00166c00 	call	166c0 <printf>
    while(((struct ethernetif *) alteraTseNetif.state)->link_alive!=1)
   16310:	00001006 	br	16354 <main+0x17c>
        {
        mSdelay(1000);
   16314:	010003f4 	movhi	r4,15
   16318:	21109004 	addi	r4,r4,16960
   1631c:	002081c0 	call	2081c <usleep>
        putchar('.');
   16320:	008000f4 	movhi	r2,3
   16324:	108d2b04 	addi	r2,r2,13484
   16328:	10800017 	ldw	r2,0(r2)
   1632c:	10800217 	ldw	r2,8(r2)
   16330:	01000b84 	movi	r4,46
   16334:	100b883a 	mov	r5,r2
   16338:	00167b80 	call	167b8 <putc>
        tse_mac_init(0, alteraTseNetif.state);
   1633c:	00800134 	movhi	r2,4
   16340:	108ddb04 	addi	r2,r2,14188
   16344:	10800717 	ldw	r2,28(r2)
   16348:	0009883a 	mov	r4,zero
   1634c:	100b883a 	mov	r5,r2
   16350:	0000c780 	call	c78 <tse_mac_init>
        }
    netif_set_default(&alteraTseNetif);
    
    // Initialize Altera TSE in a loop if waiting for a link
    printf("Waiting for link...");
    while(((struct ethernetif *) alteraTseNetif.state)->link_alive!=1)
   16354:	00800134 	movhi	r2,4
   16358:	108ddb04 	addi	r2,r2,14188
   1635c:	10800717 	ldw	r2,28(r2)
   16360:	10800217 	ldw	r2,8(r2)
   16364:	10800058 	cmpnei	r2,r2,1
   16368:	103fea1e 	bne	r2,zero,16314 <main+0x13c>
        {
        mSdelay(1000);
        putchar('.');
        tse_mac_init(0, alteraTseNetif.state);
        }
    printf("OK\n");
   1636c:	010000f4 	movhi	r4,3
   16370:	213c0404 	addi	r4,r4,-4080
   16374:	00169500 	call	16950 <puts>
            lwipProcessTimers();
        //  Poll lwIP for incoming packets.
        ethernetif_input(&alteraTseNetif);
        }
#else
    STATIC_IP;
   16378:	d0a8ea0b 	ldhu	r2,-23640(gp)
   1637c:	1004703a 	and	r2,r2,zero
   16380:	10862b14 	ori	r2,r2,6316
   16384:	d0a8ea0d 	sth	r2,-23640(gp)
   16388:	008000f4 	movhi	r2,3
   1638c:	10960a84 	addi	r2,r2,22570
   16390:	10c0000b 	ldhu	r3,0(r2)
   16394:	1806703a 	and	r3,r3,zero
   16398:	18c802d4 	ori	r3,r3,8203
   1639c:	10c0000d 	sth	r3,0(r2)
    netif_set_ipaddr(&alteraTseNetif, &lwipStaticIp);
   163a0:	01000134 	movhi	r4,4
   163a4:	210ddb04 	addi	r4,r4,14188
   163a8:	d168ea04 	addi	r5,gp,-23640
   163ac:	00094900 	call	9490 <netif_set_ipaddr>
    netif_set_up(&alteraTseNetif);
   163b0:	01000134 	movhi	r4,4
   163b4:	210ddb04 	addi	r4,r4,14188
   163b8:	00096b00 	call	96b0 <netif_set_up>
#endif
    printf("IP address: %s\n", ip_ntoa(&alteraTseNetif.ip_addr));
   163bc:	00800134 	movhi	r2,4
   163c0:	108ddc04 	addi	r2,r2,14192
   163c4:	11000017 	ldw	r4,0(r2)
   163c8:	0005ba00 	call	5ba0 <inet_ntoa>
   163cc:	010000f4 	movhi	r4,3
   163d0:	213c0504 	addi	r4,r4,-4076
   163d4:	100b883a 	mov	r5,r2
   163d8:	00166c00 	call	166c0 <printf>

#if BUILD_HTTPD
    httpd_init();
   163dc:	0000c0c0 	call	c0c <httpd_init>
#endif
    //  This is the main loop for lwIP - other processing can be done by calling application functions.
    for(;;)
        {
        //  Process lwIP timer dependent code
        if(lwipProcessTimerFlag)
   163e0:	d0a8e617 	ldw	r2,-23656(gp)
   163e4:	10000126 	beq	r2,zero,163ec <main+0x214>
            lwipProcessTimers();
   163e8:	00163fc0 	call	163fc <lwipProcessTimers>
        //  Poll lwIP for incoming packets.
        ethernetif_input(&alteraTseNetif);
   163ec:	01000134 	movhi	r4,4
   163f0:	210ddb04 	addi	r4,r4,14188
   163f4:	00003340 	call	334 <ethernetif_input>
        }
   163f8:	003ff906 	br	163e0 <main+0x208>

000163fc <lwipProcessTimers>:
    return 0;
}

//  Run this every 250mS to update lwIP timers
void        lwipProcessTimers(void)
{
   163fc:	defffe04 	addi	sp,sp,-8
   16400:	dfc00115 	stw	ra,4(sp)
   16404:	df000015 	stw	fp,0(sp)
   16408:	d839883a 	mov	fp,sp
    lwipProcessTimerFlag = 0;
   1640c:	d028e615 	stw	zero,-23656(gp)
    lwip250mStimer += 250;
   16410:	d0a8e817 	ldw	r2,-23648(gp)
   16414:	10803e84 	addi	r2,r2,250
   16418:	d0a8e815 	stw	r2,-23648(gp)
    if( (lwip250mStimer % TCP_TMR_INTERVAL) == 0 ) { tcp_tmr(); }
   1641c:	d0a8e817 	ldw	r2,-23648(gp)
   16420:	00c03e84 	movi	r3,250
   16424:	10c7203a 	divu	r3,r2,r3
   16428:	18c03ea4 	muli	r3,r3,250
   1642c:	10c5c83a 	sub	r2,r2,r3
   16430:	1000011e 	bne	r2,zero,16438 <lwipProcessTimers+0x3c>
   16434:	000b2300 	call	b230 <tcp_tmr>
    if( (lwip250mStimer % ARP_TMR_INTERVAL) == 0 ) { etharp_tmr(); }
   16438:	d0a8e817 	ldw	r2,-23648(gp)
   1643c:	00c4e204 	movi	r3,5000
   16440:	10c7203a 	divu	r3,r2,r3
   16444:	18c4e224 	muli	r3,r3,5000
   16448:	10c5c83a 	sub	r2,r2,r3
   1644c:	1000011e 	bne	r2,zero,16454 <lwipProcessTimers+0x58>
   16450:	00147780 	call	14778 <etharp_tmr>
#if IP_REASSEMBLY
    if( (lwip250mStimer % IP_TMR_INTERVAL) == 0 ) { ip_reass_tmr(); }
   16454:	d0a8e817 	ldw	r2,-23648(gp)
   16458:	00c0fa04 	movi	r3,1000
   1645c:	10c7203a 	divu	r3,r2,r3
   16460:	18c0fa24 	muli	r3,r3,1000
   16464:	10c5c83a 	sub	r2,r2,r3
   16468:	1000011e 	bne	r2,zero,16470 <lwipProcessTimers+0x74>
   1646c:	0006ea00 	call	6ea0 <ip_reass_tmr>
#endif
#if LWIP_IGMP
    if( (lwip250mStimer % IGMP_TMR_INTERVAL ) == 0 ) { igmp_tmr(); } 
#endif
#if LWIP_DHCP
    if( (lwip250mStimer % DHCP_FINE_TIMER_MSECS ) == 0 ) { dhcp_fine_tmr(); }
   16470:	d0a8e817 	ldw	r2,-23648(gp)
   16474:	00c07d04 	movi	r3,500
   16478:	10c7203a 	divu	r3,r2,r3
   1647c:	18c07d24 	muli	r3,r3,500
   16480:	10c5c83a 	sub	r2,r2,r3
   16484:	1000011e 	bne	r2,zero,1648c <lwipProcessTimers+0x90>
   16488:	0001e9c0 	call	1e9c <dhcp_fine_tmr>
    if( (lwip250mStimer % (DHCP_COARSE_TIMER_SECS*1000) ) == 0 ) { dhcp_coarse_tmr(); }
   1648c:	d0a8e817 	ldw	r2,-23648(gp)
   16490:	00fa9814 	movui	r3,60000
   16494:	10c9203a 	divu	r4,r2,r3
   16498:	00fa9814 	movui	r3,60000
   1649c:	20c7383a 	mul	r3,r4,r3
   164a0:	10c5c83a 	sub	r2,r2,r3
   164a4:	1000011e 	bne	r2,zero,164ac <lwipProcessTimers+0xb0>
   164a8:	0001de80 	call	1de8 <dhcp_coarse_tmr>
#endif
#if LWIP_DNS
    if( (lwip250mStimer % DNS_TMR_INTERVAL) == 0 ) { dns_tmr(); }
#endif
}
   164ac:	e037883a 	mov	sp,fp
   164b0:	dfc00117 	ldw	ra,4(sp)
   164b4:	df000017 	ldw	fp,0(sp)
   164b8:	dec00204 	addi	sp,sp,8
   164bc:	f800283a 	ret

000164c0 <memcpy>:
   164c0:	00c003c4 	movi	r3,15
   164c4:	2005883a 	mov	r2,r4
   164c8:	3009883a 	mov	r4,r6
   164cc:	1980032e 	bgeu	r3,r6,164dc <memcpy+0x1c>
   164d0:	2886b03a 	or	r3,r5,r2
   164d4:	18c000cc 	andi	r3,r3,3
   164d8:	18000926 	beq	r3,zero,16500 <memcpy+0x40>
   164dc:	1007883a 	mov	r3,r2
   164e0:	290f883a 	add	r7,r5,r4
   164e4:	20000526 	beq	r4,zero,164fc <memcpy+0x3c>
   164e8:	29800003 	ldbu	r6,0(r5)
   164ec:	18c00044 	addi	r3,r3,1
   164f0:	29400044 	addi	r5,r5,1
   164f4:	19bfffc5 	stb	r6,-1(r3)
   164f8:	29fffb1e 	bne	r5,r7,164e8 <memcpy+0x28>
   164fc:	f800283a 	ret
   16500:	327ffc04 	addi	r9,r6,-16
   16504:	4812d13a 	srli	r9,r9,4
   16508:	11000404 	addi	r4,r2,16
   1650c:	1007883a 	mov	r3,r2
   16510:	4810913a 	slli	r8,r9,4
   16514:	280f883a 	mov	r7,r5
   16518:	2209883a 	add	r4,r4,r8
   1651c:	3a000017 	ldw	r8,0(r7)
   16520:	18c00404 	addi	r3,r3,16
   16524:	39c00404 	addi	r7,r7,16
   16528:	1a3ffc15 	stw	r8,-16(r3)
   1652c:	3a3ffd17 	ldw	r8,-12(r7)
   16530:	1a3ffd15 	stw	r8,-12(r3)
   16534:	3a3ffe17 	ldw	r8,-8(r7)
   16538:	1a3ffe15 	stw	r8,-8(r3)
   1653c:	3a3fff17 	ldw	r8,-4(r7)
   16540:	1a3fff15 	stw	r8,-4(r3)
   16544:	193ff51e 	bne	r3,r4,1651c <memcpy+0x5c>
   16548:	49c00044 	addi	r7,r9,1
   1654c:	380e913a 	slli	r7,r7,4
   16550:	310003cc 	andi	r4,r6,15
   16554:	018000c4 	movi	r6,3
   16558:	11c7883a 	add	r3,r2,r7
   1655c:	29cb883a 	add	r5,r5,r7
   16560:	313fdf2e 	bgeu	r6,r4,164e0 <memcpy+0x20>
   16564:	213fff04 	addi	r4,r4,-4
   16568:	2014d0ba 	srli	r10,r4,2
   1656c:	1a400104 	addi	r9,r3,4
   16570:	180d883a 	mov	r6,r3
   16574:	528f883a 	add	r7,r10,r10
   16578:	39cf883a 	add	r7,r7,r7
   1657c:	49d3883a 	add	r9,r9,r7
   16580:	280f883a 	mov	r7,r5
   16584:	3a000017 	ldw	r8,0(r7)
   16588:	31800104 	addi	r6,r6,4
   1658c:	39c00104 	addi	r7,r7,4
   16590:	323fff15 	stw	r8,-4(r6)
   16594:	327ffb1e 	bne	r6,r9,16584 <memcpy+0xc4>
   16598:	51800044 	addi	r6,r10,1
   1659c:	52bfff24 	muli	r10,r10,-4
   165a0:	318d883a 	add	r6,r6,r6
   165a4:	318d883a 	add	r6,r6,r6
   165a8:	5109883a 	add	r4,r10,r4
   165ac:	298b883a 	add	r5,r5,r6
   165b0:	1987883a 	add	r3,r3,r6
   165b4:	003fca06 	br	164e0 <memcpy+0x20>

000165b8 <memset>:
   165b8:	00c000c4 	movi	r3,3
   165bc:	2005883a 	mov	r2,r4
   165c0:	29403fcc 	andi	r5,r5,255
   165c4:	19802d2e 	bgeu	r3,r6,1667c <memset+0xc4>
   165c8:	20c6703a 	and	r3,r4,r3
   165cc:	18002e1e 	bne	r3,zero,16688 <memset+0xd0>
   165d0:	2806923a 	slli	r3,r5,8
   165d4:	010003c4 	movi	r4,15
   165d8:	3011883a 	mov	r8,r6
   165dc:	1946b03a 	or	r3,r3,r5
   165e0:	180e943a 	slli	r7,r3,16
   165e4:	38ceb03a 	or	r7,r7,r3
   165e8:	1007883a 	mov	r3,r2
   165ec:	21800f2e 	bgeu	r4,r6,1662c <memset+0x74>
   165f0:	19c00015 	stw	r7,0(r3)
   165f4:	19c00115 	stw	r7,4(r3)
   165f8:	19c00215 	stw	r7,8(r3)
   165fc:	19c00315 	stw	r7,12(r3)
   16600:	423ffc04 	addi	r8,r8,-16
   16604:	18c00404 	addi	r3,r3,16
   16608:	223ff936 	bltu	r4,r8,165f0 <memset+0x38>
   1660c:	30fffc04 	addi	r3,r6,-16
   16610:	1806d13a 	srli	r3,r3,4
   16614:	318003cc 	andi	r6,r6,15
   16618:	010000c4 	movi	r4,3
   1661c:	18c00044 	addi	r3,r3,1
   16620:	1806913a 	slli	r3,r3,4
   16624:	10c7883a 	add	r3,r2,r3
   16628:	21800e2e 	bgeu	r4,r6,16664 <memset+0xac>
   1662c:	1813883a 	mov	r9,r3
   16630:	3011883a 	mov	r8,r6
   16634:	010000c4 	movi	r4,3
   16638:	49c00015 	stw	r7,0(r9)
   1663c:	423fff04 	addi	r8,r8,-4
   16640:	4a400104 	addi	r9,r9,4
   16644:	223ffc36 	bltu	r4,r8,16638 <memset+0x80>
   16648:	313fff04 	addi	r4,r6,-4
   1664c:	2008d0ba 	srli	r4,r4,2
   16650:	318000cc 	andi	r6,r6,3
   16654:	21000044 	addi	r4,r4,1
   16658:	2109883a 	add	r4,r4,r4
   1665c:	2109883a 	add	r4,r4,r4
   16660:	1907883a 	add	r3,r3,r4
   16664:	30000a26 	beq	r6,zero,16690 <memset+0xd8>
   16668:	198d883a 	add	r6,r3,r6
   1666c:	19400005 	stb	r5,0(r3)
   16670:	18c00044 	addi	r3,r3,1
   16674:	19bffd1e 	bne	r3,r6,1666c <memset+0xb4>
   16678:	f800283a 	ret
   1667c:	2007883a 	mov	r3,r4
   16680:	303ff91e 	bne	r6,zero,16668 <memset+0xb0>
   16684:	00000206 	br	16690 <memset+0xd8>
   16688:	2007883a 	mov	r3,r4
   1668c:	003ff606 	br	16668 <memset+0xb0>
   16690:	f800283a 	ret

00016694 <_printf_r>:
   16694:	defffd04 	addi	sp,sp,-12
   16698:	dfc00015 	stw	ra,0(sp)
   1669c:	d9800115 	stw	r6,4(sp)
   166a0:	d9c00215 	stw	r7,8(sp)
   166a4:	280d883a 	mov	r6,r5
   166a8:	21400217 	ldw	r5,8(r4)
   166ac:	d9c00104 	addi	r7,sp,4
   166b0:	0016bc40 	call	16bc4 <___vfprintf_internal_r>
   166b4:	dfc00017 	ldw	ra,0(sp)
   166b8:	dec00304 	addi	sp,sp,12
   166bc:	f800283a 	ret

000166c0 <printf>:
   166c0:	defffc04 	addi	sp,sp,-16
   166c4:	dfc00015 	stw	ra,0(sp)
   166c8:	d9400115 	stw	r5,4(sp)
   166cc:	d9800215 	stw	r6,8(sp)
   166d0:	d9c00315 	stw	r7,12(sp)
   166d4:	008000f4 	movhi	r2,3
   166d8:	108d2b04 	addi	r2,r2,13484
   166dc:	10800017 	ldw	r2,0(r2)
   166e0:	200b883a 	mov	r5,r4
   166e4:	d9800104 	addi	r6,sp,4
   166e8:	11000217 	ldw	r4,8(r2)
   166ec:	00189bc0 	call	189bc <__vfprintf_internal>
   166f0:	dfc00017 	ldw	ra,0(sp)
   166f4:	dec00404 	addi	sp,sp,16
   166f8:	f800283a 	ret

000166fc <_putc_r>:
   166fc:	defffc04 	addi	sp,sp,-16
   16700:	dc000215 	stw	r16,8(sp)
   16704:	dfc00315 	stw	ra,12(sp)
   16708:	2021883a 	mov	r16,r4
   1670c:	20000226 	beq	r4,zero,16718 <_putc_r+0x1c>
   16710:	20800e17 	ldw	r2,56(r4)
   16714:	10001d26 	beq	r2,zero,1678c <_putc_r+0x90>
   16718:	30800217 	ldw	r2,8(r6)
   1671c:	10bfffc4 	addi	r2,r2,-1
   16720:	30800215 	stw	r2,8(r6)
   16724:	10000a16 	blt	r2,zero,16750 <_putc_r+0x54>
   16728:	30800017 	ldw	r2,0(r6)
   1672c:	11400005 	stb	r5,0(r2)
   16730:	30800017 	ldw	r2,0(r6)
   16734:	10c00044 	addi	r3,r2,1
   16738:	10800003 	ldbu	r2,0(r2)
   1673c:	30c00015 	stw	r3,0(r6)
   16740:	dfc00317 	ldw	ra,12(sp)
   16744:	dc000217 	ldw	r16,8(sp)
   16748:	dec00404 	addi	sp,sp,16
   1674c:	f800283a 	ret
   16750:	30c00617 	ldw	r3,24(r6)
   16754:	10c01316 	blt	r2,r3,167a4 <_putc_r+0xa8>
   16758:	30800017 	ldw	r2,0(r6)
   1675c:	01000284 	movi	r4,10
   16760:	11400005 	stb	r5,0(r2)
   16764:	30c00017 	ldw	r3,0(r6)
   16768:	19400003 	ldbu	r5,0(r3)
   1676c:	29000d26 	beq	r5,r4,167a4 <_putc_r+0xa8>
   16770:	18c00044 	addi	r3,r3,1
   16774:	2805883a 	mov	r2,r5
   16778:	30c00015 	stw	r3,0(r6)
   1677c:	dfc00317 	ldw	ra,12(sp)
   16780:	dc000217 	ldw	r16,8(sp)
   16784:	dec00404 	addi	sp,sp,16
   16788:	f800283a 	ret
   1678c:	d9400015 	stw	r5,0(sp)
   16790:	d9800115 	stw	r6,4(sp)
   16794:	001a7780 	call	1a778 <__sinit>
   16798:	d9800117 	ldw	r6,4(sp)
   1679c:	d9400017 	ldw	r5,0(sp)
   167a0:	003fdd06 	br	16718 <_putc_r+0x1c>
   167a4:	8009883a 	mov	r4,r16
   167a8:	dfc00317 	ldw	ra,12(sp)
   167ac:	dc000217 	ldw	r16,8(sp)
   167b0:	dec00404 	addi	sp,sp,16
   167b4:	00189e01 	jmpi	189e0 <__swbuf_r>

000167b8 <putc>:
   167b8:	defffc04 	addi	sp,sp,-16
   167bc:	dc400115 	stw	r17,4(sp)
   167c0:	044000f4 	movhi	r17,3
   167c4:	8c4d2b04 	addi	r17,r17,13484
   167c8:	88800017 	ldw	r2,0(r17)
   167cc:	dc800215 	stw	r18,8(sp)
   167d0:	dc000015 	stw	r16,0(sp)
   167d4:	dfc00315 	stw	ra,12(sp)
   167d8:	2025883a 	mov	r18,r4
   167dc:	2821883a 	mov	r16,r5
   167e0:	10000226 	beq	r2,zero,167ec <putc+0x34>
   167e4:	10c00e17 	ldw	r3,56(r2)
   167e8:	18002126 	beq	r3,zero,16870 <putc+0xb8>
   167ec:	80800217 	ldw	r2,8(r16)
   167f0:	10bfffc4 	addi	r2,r2,-1
   167f4:	80800215 	stw	r2,8(r16)
   167f8:	10000c16 	blt	r2,zero,1682c <putc+0x74>
   167fc:	80800017 	ldw	r2,0(r16)
   16800:	14800005 	stb	r18,0(r2)
   16804:	80800017 	ldw	r2,0(r16)
   16808:	10c00044 	addi	r3,r2,1
   1680c:	10800003 	ldbu	r2,0(r2)
   16810:	80c00015 	stw	r3,0(r16)
   16814:	dfc00317 	ldw	ra,12(sp)
   16818:	dc800217 	ldw	r18,8(sp)
   1681c:	dc400117 	ldw	r17,4(sp)
   16820:	dc000017 	ldw	r16,0(sp)
   16824:	dec00404 	addi	sp,sp,16
   16828:	f800283a 	ret
   1682c:	80c00617 	ldw	r3,24(r16)
   16830:	10c01216 	blt	r2,r3,1687c <putc+0xc4>
   16834:	80800017 	ldw	r2,0(r16)
   16838:	01000284 	movi	r4,10
   1683c:	14800005 	stb	r18,0(r2)
   16840:	80c00017 	ldw	r3,0(r16)
   16844:	19400003 	ldbu	r5,0(r3)
   16848:	29001526 	beq	r5,r4,168a0 <putc+0xe8>
   1684c:	18c00044 	addi	r3,r3,1
   16850:	2805883a 	mov	r2,r5
   16854:	80c00015 	stw	r3,0(r16)
   16858:	dfc00317 	ldw	ra,12(sp)
   1685c:	dc800217 	ldw	r18,8(sp)
   16860:	dc400117 	ldw	r17,4(sp)
   16864:	dc000017 	ldw	r16,0(sp)
   16868:	dec00404 	addi	sp,sp,16
   1686c:	f800283a 	ret
   16870:	1009883a 	mov	r4,r2
   16874:	001a7780 	call	1a778 <__sinit>
   16878:	003fdc06 	br	167ec <putc+0x34>
   1687c:	89000017 	ldw	r4,0(r17)
   16880:	900b883a 	mov	r5,r18
   16884:	800d883a 	mov	r6,r16
   16888:	dfc00317 	ldw	ra,12(sp)
   1688c:	dc800217 	ldw	r18,8(sp)
   16890:	dc400117 	ldw	r17,4(sp)
   16894:	dc000017 	ldw	r16,0(sp)
   16898:	dec00404 	addi	sp,sp,16
   1689c:	00189e01 	jmpi	189e0 <__swbuf_r>
   168a0:	89000017 	ldw	r4,0(r17)
   168a4:	003ff706 	br	16884 <putc+0xcc>

000168a8 <_putchar_r>:
   168a8:	21800217 	ldw	r6,8(r4)
   168ac:	00166fc1 	jmpi	166fc <_putc_r>

000168b0 <putchar>:
   168b0:	008000f4 	movhi	r2,3
   168b4:	108d2b04 	addi	r2,r2,13484
   168b8:	10800017 	ldw	r2,0(r2)
   168bc:	200b883a 	mov	r5,r4
   168c0:	11800217 	ldw	r6,8(r2)
   168c4:	1009883a 	mov	r4,r2
   168c8:	00166fc1 	jmpi	166fc <_putc_r>

000168cc <_puts_r>:
   168cc:	defff604 	addi	sp,sp,-40
   168d0:	dc400815 	stw	r17,32(sp)
   168d4:	2023883a 	mov	r17,r4
   168d8:	2809883a 	mov	r4,r5
   168dc:	dc000715 	stw	r16,28(sp)
   168e0:	dfc00915 	stw	ra,36(sp)
   168e4:	2821883a 	mov	r16,r5
   168e8:	0016a080 	call	16a08 <strlen>
   168ec:	10c00044 	addi	r3,r2,1
   168f0:	d8800115 	stw	r2,4(sp)
   168f4:	89400217 	ldw	r5,8(r17)
   168f8:	008000f4 	movhi	r2,3
   168fc:	10bc0a04 	addi	r2,r2,-4056
   16900:	d8800215 	stw	r2,8(sp)
   16904:	00800044 	movi	r2,1
   16908:	d8800315 	stw	r2,12(sp)
   1690c:	8809883a 	mov	r4,r17
   16910:	00800084 	movi	r2,2
   16914:	d9800404 	addi	r6,sp,16
   16918:	dc000015 	stw	r16,0(sp)
   1691c:	d8c00615 	stw	r3,24(sp)
   16920:	dec00415 	stw	sp,16(sp)
   16924:	d8800515 	stw	r2,20(sp)
   16928:	001adcc0 	call	1adcc <__sfvwrite_r>
   1692c:	1000061e 	bne	r2,zero,16948 <_puts_r+0x7c>
   16930:	00800284 	movi	r2,10
   16934:	dfc00917 	ldw	ra,36(sp)
   16938:	dc400817 	ldw	r17,32(sp)
   1693c:	dc000717 	ldw	r16,28(sp)
   16940:	dec00a04 	addi	sp,sp,40
   16944:	f800283a 	ret
   16948:	00bfffc4 	movi	r2,-1
   1694c:	003ff906 	br	16934 <_puts_r+0x68>

00016950 <puts>:
   16950:	008000f4 	movhi	r2,3
   16954:	108d2b04 	addi	r2,r2,13484
   16958:	200b883a 	mov	r5,r4
   1695c:	11000017 	ldw	r4,0(r2)
   16960:	00168cc1 	jmpi	168cc <_puts_r>

00016964 <strcmp>:
   16964:	2904b03a 	or	r2,r5,r4
   16968:	108000cc 	andi	r2,r2,3
   1696c:	1000171e 	bne	r2,zero,169cc <strcmp+0x68>
   16970:	20800017 	ldw	r2,0(r4)
   16974:	28c00017 	ldw	r3,0(r5)
   16978:	10c0141e 	bne	r2,r3,169cc <strcmp+0x68>
   1697c:	027fbff4 	movhi	r9,65279
   16980:	4a7fbfc4 	addi	r9,r9,-257
   16984:	1247883a 	add	r3,r2,r9
   16988:	0084303a 	nor	r2,zero,r2
   1698c:	1884703a 	and	r2,r3,r2
   16990:	02202074 	movhi	r8,32897
   16994:	42202004 	addi	r8,r8,-32640
   16998:	1204703a 	and	r2,r2,r8
   1699c:	10000226 	beq	r2,zero,169a8 <strcmp+0x44>
   169a0:	00001706 	br	16a00 <strcmp+0x9c>
   169a4:	3000161e 	bne	r6,zero,16a00 <strcmp+0x9c>
   169a8:	21000104 	addi	r4,r4,4
   169ac:	20800017 	ldw	r2,0(r4)
   169b0:	29400104 	addi	r5,r5,4
   169b4:	28c00017 	ldw	r3,0(r5)
   169b8:	124f883a 	add	r7,r2,r9
   169bc:	008c303a 	nor	r6,zero,r2
   169c0:	398c703a 	and	r6,r7,r6
   169c4:	320c703a 	and	r6,r6,r8
   169c8:	10fff626 	beq	r2,r3,169a4 <strcmp+0x40>
   169cc:	20800007 	ldb	r2,0(r4)
   169d0:	1000051e 	bne	r2,zero,169e8 <strcmp+0x84>
   169d4:	00000606 	br	169f0 <strcmp+0x8c>
   169d8:	21000044 	addi	r4,r4,1
   169dc:	20800007 	ldb	r2,0(r4)
   169e0:	29400044 	addi	r5,r5,1
   169e4:	10000226 	beq	r2,zero,169f0 <strcmp+0x8c>
   169e8:	28c00007 	ldb	r3,0(r5)
   169ec:	10fffa26 	beq	r2,r3,169d8 <strcmp+0x74>
   169f0:	20c00003 	ldbu	r3,0(r4)
   169f4:	28800003 	ldbu	r2,0(r5)
   169f8:	1885c83a 	sub	r2,r3,r2
   169fc:	f800283a 	ret
   16a00:	0005883a 	mov	r2,zero
   16a04:	f800283a 	ret

00016a08 <strlen>:
   16a08:	208000cc 	andi	r2,r4,3
   16a0c:	10001f1e 	bne	r2,zero,16a8c <strlen+0x84>
   16a10:	20800017 	ldw	r2,0(r4)
   16a14:	01ffbff4 	movhi	r7,65279
   16a18:	39ffbfc4 	addi	r7,r7,-257
   16a1c:	01a02074 	movhi	r6,32897
   16a20:	31a02004 	addi	r6,r6,-32640
   16a24:	11c7883a 	add	r3,r2,r7
   16a28:	0084303a 	nor	r2,zero,r2
   16a2c:	1886703a 	and	r3,r3,r2
   16a30:	1986703a 	and	r3,r3,r6
   16a34:	2005883a 	mov	r2,r4
   16a38:	1800101e 	bne	r3,zero,16a7c <strlen+0x74>
   16a3c:	10800104 	addi	r2,r2,4
   16a40:	10c00017 	ldw	r3,0(r2)
   16a44:	19cb883a 	add	r5,r3,r7
   16a48:	00c6303a 	nor	r3,zero,r3
   16a4c:	28c6703a 	and	r3,r5,r3
   16a50:	1986703a 	and	r3,r3,r6
   16a54:	1800091e 	bne	r3,zero,16a7c <strlen+0x74>
   16a58:	10800104 	addi	r2,r2,4
   16a5c:	10c00017 	ldw	r3,0(r2)
   16a60:	19cb883a 	add	r5,r3,r7
   16a64:	00c6303a 	nor	r3,zero,r3
   16a68:	28c6703a 	and	r3,r5,r3
   16a6c:	1986703a 	and	r3,r3,r6
   16a70:	183ff226 	beq	r3,zero,16a3c <strlen+0x34>
   16a74:	00000106 	br	16a7c <strlen+0x74>
   16a78:	10800044 	addi	r2,r2,1
   16a7c:	10c00007 	ldb	r3,0(r2)
   16a80:	183ffd1e 	bne	r3,zero,16a78 <strlen+0x70>
   16a84:	1105c83a 	sub	r2,r2,r4
   16a88:	f800283a 	ret
   16a8c:	2005883a 	mov	r2,r4
   16a90:	003ffa06 	br	16a7c <strlen+0x74>

00016a94 <strncmp>:
   16a94:	30001826 	beq	r6,zero,16af8 <strncmp+0x64>
   16a98:	2904b03a 	or	r2,r5,r4
   16a9c:	108000cc 	andi	r2,r2,3
   16aa0:	10001726 	beq	r2,zero,16b00 <strncmp+0x6c>
   16aa4:	31bfffc4 	addi	r6,r6,-1
   16aa8:	20800007 	ldb	r2,0(r4)
   16aac:	28c00007 	ldb	r3,0(r5)
   16ab0:	10c0331e 	bne	r2,r3,16b80 <strncmp+0xec>
   16ab4:	30001026 	beq	r6,zero,16af8 <strncmp+0x64>
   16ab8:	10000f26 	beq	r2,zero,16af8 <strncmp+0x64>
   16abc:	20800044 	addi	r2,r4,1
   16ac0:	29400044 	addi	r5,r5,1
   16ac4:	2189883a 	add	r4,r4,r6
   16ac8:	00000406 	br	16adc <strncmp+0x48>
   16acc:	11000a26 	beq	r2,r4,16af8 <strncmp+0x64>
   16ad0:	18000926 	beq	r3,zero,16af8 <strncmp+0x64>
   16ad4:	10800044 	addi	r2,r2,1
   16ad8:	29400044 	addi	r5,r5,1
   16adc:	10c00007 	ldb	r3,0(r2)
   16ae0:	29800007 	ldb	r6,0(r5)
   16ae4:	19bff926 	beq	r3,r6,16acc <strncmp+0x38>
   16ae8:	10c00003 	ldbu	r3,0(r2)
   16aec:	28800003 	ldbu	r2,0(r5)
   16af0:	1885c83a 	sub	r2,r3,r2
   16af4:	f800283a 	ret
   16af8:	0005883a 	mov	r2,zero
   16afc:	f800283a 	ret
   16b00:	024000c4 	movi	r9,3
   16b04:	49bfe72e 	bgeu	r9,r6,16aa4 <strncmp+0x10>
   16b08:	20800017 	ldw	r2,0(r4)
   16b0c:	28c00017 	ldw	r3,0(r5)
   16b10:	10ffe41e 	bne	r2,r3,16aa4 <strncmp+0x10>
   16b14:	30ffff04 	addi	r3,r6,-4
   16b18:	183ff726 	beq	r3,zero,16af8 <strncmp+0x64>
   16b1c:	02ffbff4 	movhi	r11,65279
   16b20:	5affbfc4 	addi	r11,r11,-257
   16b24:	12cd883a 	add	r6,r2,r11
   16b28:	0084303a 	nor	r2,zero,r2
   16b2c:	3084703a 	and	r2,r6,r2
   16b30:	02a02074 	movhi	r10,32897
   16b34:	52a02004 	addi	r10,r10,-32640
   16b38:	1284703a 	and	r2,r2,r10
   16b3c:	10000b26 	beq	r2,zero,16b6c <strncmp+0xd8>
   16b40:	003fed06 	br	16af8 <strncmp+0x64>
   16b44:	21800017 	ldw	r6,0(r4)
   16b48:	28800017 	ldw	r2,0(r5)
   16b4c:	32d1883a 	add	r8,r6,r11
   16b50:	018e303a 	nor	r7,zero,r6
   16b54:	41ce703a 	and	r7,r8,r7
   16b58:	3a8e703a 	and	r7,r7,r10
   16b5c:	30800a1e 	bne	r6,r2,16b88 <strncmp+0xf4>
   16b60:	18ffff04 	addi	r3,r3,-4
   16b64:	183fe426 	beq	r3,zero,16af8 <strncmp+0x64>
   16b68:	383fe31e 	bne	r7,zero,16af8 <strncmp+0x64>
   16b6c:	21000104 	addi	r4,r4,4
   16b70:	29400104 	addi	r5,r5,4
   16b74:	48fff336 	bltu	r9,r3,16b44 <strncmp+0xb0>
   16b78:	19bfffc4 	addi	r6,r3,-1
   16b7c:	183fca1e 	bne	r3,zero,16aa8 <strncmp+0x14>
   16b80:	2005883a 	mov	r2,r4
   16b84:	003fd806 	br	16ae8 <strncmp+0x54>
   16b88:	19bfffc4 	addi	r6,r3,-1
   16b8c:	003fc606 	br	16aa8 <strncmp+0x14>

00016b90 <__sprint_r>:
   16b90:	30800217 	ldw	r2,8(r6)
   16b94:	defffe04 	addi	sp,sp,-8
   16b98:	dc000015 	stw	r16,0(sp)
   16b9c:	dfc00115 	stw	ra,4(sp)
   16ba0:	3021883a 	mov	r16,r6
   16ba4:	10000226 	beq	r2,zero,16bb0 <__sprint_r+0x20>
   16ba8:	001adcc0 	call	1adcc <__sfvwrite_r>
   16bac:	80000215 	stw	zero,8(r16)
   16bb0:	80000115 	stw	zero,4(r16)
   16bb4:	dfc00117 	ldw	ra,4(sp)
   16bb8:	dc000017 	ldw	r16,0(sp)
   16bbc:	dec00204 	addi	sp,sp,8
   16bc0:	f800283a 	ret

00016bc4 <___vfprintf_internal_r>:
   16bc4:	defeb904 	addi	sp,sp,-1308
   16bc8:	dc013d15 	stw	r16,1268(sp)
   16bcc:	d9013015 	stw	r4,1216(sp)
   16bd0:	dfc14615 	stw	ra,1304(sp)
   16bd4:	df014515 	stw	fp,1300(sp)
   16bd8:	ddc14415 	stw	r23,1296(sp)
   16bdc:	dd814315 	stw	r22,1292(sp)
   16be0:	dd414215 	stw	r21,1288(sp)
   16be4:	dd014115 	stw	r20,1284(sp)
   16be8:	dcc14015 	stw	r19,1280(sp)
   16bec:	dc813f15 	stw	r18,1276(sp)
   16bf0:	dc413e15 	stw	r17,1272(sp)
   16bf4:	d9412915 	stw	r5,1188(sp)
   16bf8:	3021883a 	mov	r16,r6
   16bfc:	d9c12d15 	stw	r7,1204(sp)
   16c00:	001b4b80 	call	1b4b8 <_localeconv_r>
   16c04:	10800017 	ldw	r2,0(r2)
   16c08:	d9013017 	ldw	r4,1216(sp)
   16c0c:	d8013315 	stw	zero,1228(sp)
   16c10:	d8813715 	stw	r2,1244(sp)
   16c14:	d8013415 	stw	zero,1232(sp)
   16c18:	20000226 	beq	r4,zero,16c24 <___vfprintf_internal_r+0x60>
   16c1c:	20800e17 	ldw	r2,56(r4)
   16c20:	10019826 	beq	r2,zero,17284 <___vfprintf_internal_r+0x6c0>
   16c24:	da012917 	ldw	r8,1188(sp)
   16c28:	4080030b 	ldhu	r2,12(r8)
   16c2c:	10c0020c 	andi	r3,r2,8
   16c30:	18ffffcc 	andi	r3,r3,65535
   16c34:	18e0001c 	xori	r3,r3,32768
   16c38:	18e00004 	addi	r3,r3,-32768
   16c3c:	18013a26 	beq	r3,zero,17128 <___vfprintf_internal_r+0x564>
   16c40:	40c00417 	ldw	r3,16(r8)
   16c44:	18013826 	beq	r3,zero,17128 <___vfprintf_internal_r+0x564>
   16c48:	1100068c 	andi	r4,r2,26
   16c4c:	00c00284 	movi	r3,10
   16c50:	20c13e26 	beq	r4,r3,1714c <___vfprintf_internal_r+0x588>
   16c54:	da010dc4 	addi	r8,sp,1079
   16c58:	d8800404 	addi	r2,sp,16
   16c5c:	da012615 	stw	r8,1176(sp)
   16c60:	d8811b15 	stw	r2,1132(sp)
   16c64:	1013883a 	mov	r9,r2
   16c68:	d8812617 	ldw	r2,1176(sp)
   16c6c:	da010e04 	addi	r8,sp,1080
   16c70:	dc413017 	ldw	r17,1216(sp)
   16c74:	da012715 	stw	r8,1180(sp)
   16c78:	4091c83a 	sub	r8,r8,r2
   16c7c:	d8011d15 	stw	zero,1140(sp)
   16c80:	d8011c15 	stw	zero,1136(sp)
   16c84:	802b883a 	mov	r21,r16
   16c88:	d8013215 	stw	zero,1224(sp)
   16c8c:	d8013615 	stw	zero,1240(sp)
   16c90:	d8013515 	stw	zero,1236(sp)
   16c94:	d8012c15 	stw	zero,1200(sp)
   16c98:	da013915 	stw	r8,1252(sp)
   16c9c:	a8800007 	ldb	r2,0(r21)
   16ca0:	1002ec26 	beq	r2,zero,17854 <___vfprintf_internal_r+0xc90>
   16ca4:	00c00944 	movi	r3,37
   16ca8:	a825883a 	mov	r18,r21
   16cac:	10c0021e 	bne	r2,r3,16cb8 <___vfprintf_internal_r+0xf4>
   16cb0:	00001406 	br	16d04 <___vfprintf_internal_r+0x140>
   16cb4:	10c00326 	beq	r2,r3,16cc4 <___vfprintf_internal_r+0x100>
   16cb8:	94800044 	addi	r18,r18,1
   16cbc:	90800007 	ldb	r2,0(r18)
   16cc0:	103ffc1e 	bne	r2,zero,16cb4 <___vfprintf_internal_r+0xf0>
   16cc4:	9561c83a 	sub	r16,r18,r21
   16cc8:	80000e26 	beq	r16,zero,16d04 <___vfprintf_internal_r+0x140>
   16ccc:	da011d17 	ldw	r8,1140(sp)
   16cd0:	d8c11c17 	ldw	r3,1136(sp)
   16cd4:	4d400015 	stw	r21,0(r9)
   16cd8:	4c000115 	stw	r16,4(r9)
   16cdc:	4411883a 	add	r8,r8,r16
   16ce0:	18c00044 	addi	r3,r3,1
   16ce4:	da011d15 	stw	r8,1140(sp)
   16ce8:	d8c11c15 	stw	r3,1136(sp)
   16cec:	008001c4 	movi	r2,7
   16cf0:	10c15d16 	blt	r2,r3,17268 <___vfprintf_internal_r+0x6a4>
   16cf4:	4a400204 	addi	r9,r9,8
   16cf8:	d8812c17 	ldw	r2,1200(sp)
   16cfc:	1405883a 	add	r2,r2,r16
   16d00:	d8812c15 	stw	r2,1200(sp)
   16d04:	90800007 	ldb	r2,0(r18)
   16d08:	10013b26 	beq	r2,zero,171f8 <___vfprintf_internal_r+0x634>
   16d0c:	95400044 	addi	r21,r18,1
   16d10:	94800047 	ldb	r18,1(r18)
   16d14:	d8012585 	stb	zero,1174(sp)
   16d18:	073fffc4 	movi	fp,-1
   16d1c:	d8012e15 	stw	zero,1208(sp)
   16d20:	0021883a 	mov	r16,zero
   16d24:	00c01604 	movi	r3,88
   16d28:	01400244 	movi	r5,9
   16d2c:	02800a84 	movi	r10,42
   16d30:	01c01b04 	movi	r7,108
   16d34:	01800ac4 	movi	r6,43
   16d38:	02c00804 	movi	r11,32
   16d3c:	ad400044 	addi	r21,r21,1
   16d40:	90bff804 	addi	r2,r18,-32
   16d44:	1880092e 	bgeu	r3,r2,16d6c <___vfprintf_internal_r+0x1a8>
   16d48:	90012b26 	beq	r18,zero,171f8 <___vfprintf_internal_r+0x634>
   16d4c:	00c00044 	movi	r3,1
   16d50:	d8c12815 	stw	r3,1184(sp)
   16d54:	dc810405 	stb	r18,1040(sp)
   16d58:	d8012585 	stb	zero,1174(sp)
   16d5c:	d8c12b15 	stw	r3,1196(sp)
   16d60:	dcc10404 	addi	r19,sp,1040
   16d64:	d8013115 	stw	zero,1220(sp)
   16d68:	00008806 	br	16f8c <___vfprintf_internal_r+0x3c8>
   16d6c:	1085883a 	add	r2,r2,r2
   16d70:	1085883a 	add	r2,r2,r2
   16d74:	01000074 	movhi	r4,1
   16d78:	211b6204 	addi	r4,r4,28040
   16d7c:	1105883a 	add	r2,r2,r4
   16d80:	10800017 	ldw	r2,0(r2)
   16d84:	1000683a 	jmp	r2
   16d88:	0001733c 	xorhi	zero,zero,1484
   16d8c:	00016d48 	cmpgei	zero,zero,1461
   16d90:	00016d48 	cmpgei	zero,zero,1461
   16d94:	00017350 	cmplti	zero,zero,1485
   16d98:	00016d48 	cmpgei	zero,zero,1461
   16d9c:	00016d48 	cmpgei	zero,zero,1461
   16da0:	00016d48 	cmpgei	zero,zero,1461
   16da4:	00016d48 	cmpgei	zero,zero,1461
   16da8:	00016d48 	cmpgei	zero,zero,1461
   16dac:	00016d48 	cmpgei	zero,zero,1461
   16db0:	00017438 	rdprs	zero,zero,1488
   16db4:	000172f4 	movhi	zero,1483
   16db8:	00016d48 	cmpgei	zero,zero,1461
   16dbc:	0001711c 	xori	zero,zero,1476
   16dc0:	00017300 	call	1730 <tse_mac_raw_send+0x120>
   16dc4:	00016d48 	cmpgei	zero,zero,1461
   16dc8:	0001735c 	xori	zero,zero,1485
   16dcc:	0001745c 	xori	zero,zero,1489
   16dd0:	0001745c 	xori	zero,zero,1489
   16dd4:	0001745c 	xori	zero,zero,1489
   16dd8:	0001745c 	xori	zero,zero,1489
   16ddc:	0001745c 	xori	zero,zero,1489
   16de0:	0001745c 	xori	zero,zero,1489
   16de4:	0001745c 	xori	zero,zero,1489
   16de8:	0001745c 	xori	zero,zero,1489
   16dec:	0001745c 	xori	zero,zero,1489
   16df0:	00016d48 	cmpgei	zero,zero,1461
   16df4:	00016d48 	cmpgei	zero,zero,1461
   16df8:	00016d48 	cmpgei	zero,zero,1461
   16dfc:	00016d48 	cmpgei	zero,zero,1461
   16e00:	00016d48 	cmpgei	zero,zero,1461
   16e04:	00016d48 	cmpgei	zero,zero,1461
   16e08:	00016d48 	cmpgei	zero,zero,1461
   16e0c:	00016d48 	cmpgei	zero,zero,1461
   16e10:	00016d48 	cmpgei	zero,zero,1461
   16e14:	00016d48 	cmpgei	zero,zero,1461
   16e18:	000170b8 	rdprs	zero,zero,1474
   16e1c:	00017484 	movi	zero,1490
   16e20:	00016d48 	cmpgei	zero,zero,1461
   16e24:	00017484 	movi	zero,1490
   16e28:	00016d48 	cmpgei	zero,zero,1461
   16e2c:	00016d48 	cmpgei	zero,zero,1461
   16e30:	00016d48 	cmpgei	zero,zero,1461
   16e34:	00016d48 	cmpgei	zero,zero,1461
   16e38:	000175f4 	movhi	zero,1495
   16e3c:	00016d48 	cmpgei	zero,zero,1461
   16e40:	00016d48 	cmpgei	zero,zero,1461
   16e44:	00017080 	call	1708 <tse_mac_raw_send+0xf8>
   16e48:	00016d48 	cmpgei	zero,zero,1461
   16e4c:	00016d48 	cmpgei	zero,zero,1461
   16e50:	00016d48 	cmpgei	zero,zero,1461
   16e54:	00016d48 	cmpgei	zero,zero,1461
   16e58:	00016d48 	cmpgei	zero,zero,1461
   16e5c:	00016eec 	andhi	zero,zero,1467
   16e60:	00016d48 	cmpgei	zero,zero,1461
   16e64:	00016d48 	cmpgei	zero,zero,1461
   16e68:	00017368 	cmpgeui	zero,zero,1485
   16e6c:	00016d48 	cmpgei	zero,zero,1461
   16e70:	00016d48 	cmpgei	zero,zero,1461
   16e74:	00016d48 	cmpgei	zero,zero,1461
   16e78:	00016d48 	cmpgei	zero,zero,1461
   16e7c:	00016d48 	cmpgei	zero,zero,1461
   16e80:	00016d48 	cmpgei	zero,zero,1461
   16e84:	00016d48 	cmpgei	zero,zero,1461
   16e88:	00016d48 	cmpgei	zero,zero,1461
   16e8c:	00016d48 	cmpgei	zero,zero,1461
   16e90:	00016d48 	cmpgei	zero,zero,1461
   16e94:	000173dc 	xori	zero,zero,1487
   16e98:	000170bc 	xorhi	zero,zero,1474
   16e9c:	00017484 	movi	zero,1490
   16ea0:	00017484 	movi	zero,1490
   16ea4:	00017484 	movi	zero,1490
   16ea8:	000173bc 	xorhi	zero,zero,1486
   16eac:	000170bc 	xorhi	zero,zero,1474
   16eb0:	00016d48 	cmpgei	zero,zero,1461
   16eb4:	00016d48 	cmpgei	zero,zero,1461
   16eb8:	000173c8 	cmpgei	zero,zero,1487
   16ebc:	00016d48 	cmpgei	zero,zero,1461
   16ec0:	0001740c 	andi	zero,zero,1488
   16ec4:	00017084 	movi	zero,1474
   16ec8:	0001750c 	andi	zero,zero,1492
   16ecc:	00017558 	cmpnei	zero,zero,1493
   16ed0:	00016d48 	cmpgei	zero,zero,1461
   16ed4:	00017564 	muli	zero,zero,1493
   16ed8:	00016d48 	cmpgei	zero,zero,1461
   16edc:	00016ef0 	cmpltui	zero,zero,1467
   16ee0:	00016d48 	cmpgei	zero,zero,1461
   16ee4:	00016d48 	cmpgei	zero,zero,1461
   16ee8:	000175c0 	call	175c <tse_mac_raw_send+0x14c>
   16eec:	84000414 	ori	r16,r16,16
   16ef0:	8080080c 	andi	r2,r16,32
   16ef4:	1000f51e 	bne	r2,zero,172cc <___vfprintf_internal_r+0x708>
   16ef8:	8080040c 	andi	r2,r16,16
   16efc:	10042c26 	beq	r2,zero,17fb0 <___vfprintf_internal_r+0x13ec>
   16f00:	da012d17 	ldw	r8,1204(sp)
   16f04:	002d883a 	mov	r22,zero
   16f08:	00c00044 	movi	r3,1
   16f0c:	45c00017 	ldw	r23,0(r8)
   16f10:	42000104 	addi	r8,r8,4
   16f14:	da012d15 	stw	r8,1204(sp)
   16f18:	b805883a 	mov	r2,r23
   16f1c:	d8012585 	stb	zero,1174(sp)
   16f20:	e0000216 	blt	fp,zero,16f2c <___vfprintf_internal_r+0x368>
   16f24:	013fdfc4 	movi	r4,-129
   16f28:	8120703a 	and	r16,r16,r4
   16f2c:	1002671e 	bne	r2,zero,178cc <___vfprintf_internal_r+0xd08>
   16f30:	e002661e 	bne	fp,zero,178cc <___vfprintf_internal_r+0xd08>
   16f34:	18c03fcc 	andi	r3,r3,255
   16f38:	1803561e 	bne	r3,zero,17c94 <___vfprintf_internal_r+0x10d0>
   16f3c:	8080004c 	andi	r2,r16,1
   16f40:	10035426 	beq	r2,zero,17c94 <___vfprintf_internal_r+0x10d0>
   16f44:	da013917 	ldw	r8,1252(sp)
   16f48:	00800c04 	movi	r2,48
   16f4c:	d8810dc5 	stb	r2,1079(sp)
   16f50:	da012b15 	stw	r8,1196(sp)
   16f54:	dcc10dc4 	addi	r19,sp,1079
   16f58:	d8812b17 	ldw	r2,1196(sp)
   16f5c:	d8812815 	stw	r2,1184(sp)
   16f60:	1700010e 	bge	r2,fp,16f68 <___vfprintf_internal_r+0x3a4>
   16f64:	df012815 	stw	fp,1184(sp)
   16f68:	d8812583 	ldbu	r2,1174(sp)
   16f6c:	df013115 	stw	fp,1220(sp)
   16f70:	10803fcc 	andi	r2,r2,255
   16f74:	1080201c 	xori	r2,r2,128
   16f78:	10bfe004 	addi	r2,r2,-128
   16f7c:	10000326 	beq	r2,zero,16f8c <___vfprintf_internal_r+0x3c8>
   16f80:	da012817 	ldw	r8,1184(sp)
   16f84:	42000044 	addi	r8,r8,1
   16f88:	da012815 	stw	r8,1184(sp)
   16f8c:	80c0008c 	andi	r3,r16,2
   16f90:	d8c12a15 	stw	r3,1192(sp)
   16f94:	18000326 	beq	r3,zero,16fa4 <___vfprintf_internal_r+0x3e0>
   16f98:	da012817 	ldw	r8,1184(sp)
   16f9c:	42000084 	addi	r8,r8,2
   16fa0:	da012815 	stw	r8,1184(sp)
   16fa4:	80c0210c 	andi	r3,r16,132
   16fa8:	d8c12f15 	stw	r3,1212(sp)
   16fac:	1801941e 	bne	r3,zero,17600 <___vfprintf_internal_r+0xa3c>
   16fb0:	da012e17 	ldw	r8,1208(sp)
   16fb4:	d8c12817 	ldw	r3,1184(sp)
   16fb8:	40edc83a 	sub	r22,r8,r3
   16fbc:	0581900e 	bge	zero,r22,17600 <___vfprintf_internal_r+0xa3c>
   16fc0:	02800404 	movi	r10,16
   16fc4:	da011d17 	ldw	r8,1140(sp)
   16fc8:	d8c11c17 	ldw	r3,1136(sp)
   16fcc:	05c000f4 	movhi	r23,3
   16fd0:	bdfc1b84 	addi	r23,r23,-3986
   16fd4:	5580200e 	bge	r10,r22,17058 <___vfprintf_internal_r+0x494>
   16fd8:	dc813815 	stw	r18,1248(sp)
   16fdc:	5039883a 	mov	fp,r10
   16fe0:	b825883a 	mov	r18,r23
   16fe4:	050001c4 	movi	r20,7
   16fe8:	b02f883a 	mov	r23,r22
   16fec:	802d883a 	mov	r22,r16
   16ff0:	dc012917 	ldw	r16,1188(sp)
   16ff4:	00000306 	br	17004 <___vfprintf_internal_r+0x440>
   16ff8:	bdfffc04 	addi	r23,r23,-16
   16ffc:	4a400204 	addi	r9,r9,8
   17000:	e5c0110e 	bge	fp,r23,17048 <___vfprintf_internal_r+0x484>
   17004:	4c800015 	stw	r18,0(r9)
   17008:	4f000115 	stw	fp,4(r9)
   1700c:	42000404 	addi	r8,r8,16
   17010:	18c00044 	addi	r3,r3,1
   17014:	da011d15 	stw	r8,1140(sp)
   17018:	d8c11c15 	stw	r3,1136(sp)
   1701c:	a0fff60e 	bge	r20,r3,16ff8 <___vfprintf_internal_r+0x434>
   17020:	8809883a 	mov	r4,r17
   17024:	800b883a 	mov	r5,r16
   17028:	d9811b04 	addi	r6,sp,1132
   1702c:	0016b900 	call	16b90 <__sprint_r>
   17030:	1000771e 	bne	r2,zero,17210 <___vfprintf_internal_r+0x64c>
   17034:	bdfffc04 	addi	r23,r23,-16
   17038:	da011d17 	ldw	r8,1140(sp)
   1703c:	d8c11c17 	ldw	r3,1136(sp)
   17040:	da400404 	addi	r9,sp,16
   17044:	e5ffef16 	blt	fp,r23,17004 <___vfprintf_internal_r+0x440>
   17048:	b021883a 	mov	r16,r22
   1704c:	b82d883a 	mov	r22,r23
   17050:	902f883a 	mov	r23,r18
   17054:	dc813817 	ldw	r18,1248(sp)
   17058:	4dc00015 	stw	r23,0(r9)
   1705c:	4d800115 	stw	r22,4(r9)
   17060:	4591883a 	add	r8,r8,r22
   17064:	18c00044 	addi	r3,r3,1
   17068:	da011d15 	stw	r8,1140(sp)
   1706c:	d8c11c15 	stw	r3,1136(sp)
   17070:	008001c4 	movi	r2,7
   17074:	10c36d16 	blt	r2,r3,17e2c <___vfprintf_internal_r+0x1268>
   17078:	4a400204 	addi	r9,r9,8
   1707c:	00016206 	br	17608 <___vfprintf_internal_r+0xa44>
   17080:	84000414 	ori	r16,r16,16
   17084:	8080080c 	andi	r2,r16,32
   17088:	1000801e 	bne	r2,zero,1728c <___vfprintf_internal_r+0x6c8>
   1708c:	8080040c 	andi	r2,r16,16
   17090:	1003da26 	beq	r2,zero,17ffc <___vfprintf_internal_r+0x1438>
   17094:	d8c12d17 	ldw	r3,1204(sp)
   17098:	002d883a 	mov	r22,zero
   1709c:	1dc00017 	ldw	r23,0(r3)
   170a0:	18c00104 	addi	r3,r3,4
   170a4:	d8c12d15 	stw	r3,1204(sp)
   170a8:	b805883a 	mov	r2,r23
   170ac:	0007883a 	mov	r3,zero
   170b0:	d8012585 	stb	zero,1174(sp)
   170b4:	003f9a06 	br	16f20 <___vfprintf_internal_r+0x35c>
   170b8:	84000414 	ori	r16,r16,16
   170bc:	8080080c 	andi	r2,r16,32
   170c0:	10007b1e 	bne	r2,zero,172b0 <___vfprintf_internal_r+0x6ec>
   170c4:	8080040c 	andi	r2,r16,16
   170c8:	1003ed26 	beq	r2,zero,18080 <___vfprintf_internal_r+0x14bc>
   170cc:	d9012d17 	ldw	r4,1204(sp)
   170d0:	25c00017 	ldw	r23,0(r4)
   170d4:	21000104 	addi	r4,r4,4
   170d8:	d9012d15 	stw	r4,1204(sp)
   170dc:	b82dd7fa 	srai	r22,r23,31
   170e0:	b005883a 	mov	r2,r22
   170e4:	1003230e 	bge	r2,zero,17d74 <___vfprintf_internal_r+0x11b0>
   170e8:	05efc83a 	sub	r23,zero,r23
   170ec:	b804c03a 	cmpne	r2,r23,zero
   170f0:	05adc83a 	sub	r22,zero,r22
   170f4:	b0adc83a 	sub	r22,r22,r2
   170f8:	00800b44 	movi	r2,45
   170fc:	d8812585 	stb	r2,1174(sp)
   17100:	00c00044 	movi	r3,1
   17104:	bd84b03a 	or	r2,r23,r22
   17108:	003f8506 	br	16f20 <___vfprintf_internal_r+0x35c>
   1710c:	da012e17 	ldw	r8,1208(sp)
   17110:	d8812d15 	stw	r2,1204(sp)
   17114:	0211c83a 	sub	r8,zero,r8
   17118:	da012e15 	stw	r8,1208(sp)
   1711c:	84000114 	ori	r16,r16,4
   17120:	ac800007 	ldb	r18,0(r21)
   17124:	003f0506 	br	16d3c <___vfprintf_internal_r+0x178>
   17128:	d9013017 	ldw	r4,1216(sp)
   1712c:	d9412917 	ldw	r5,1188(sp)
   17130:	0018b380 	call	18b38 <__swsetup_r>
   17134:	10003d1e 	bne	r2,zero,1722c <___vfprintf_internal_r+0x668>
   17138:	d8c12917 	ldw	r3,1188(sp)
   1713c:	1880030b 	ldhu	r2,12(r3)
   17140:	00c00284 	movi	r3,10
   17144:	1100068c 	andi	r4,r2,26
   17148:	20fec21e 	bne	r4,r3,16c54 <___vfprintf_internal_r+0x90>
   1714c:	d9012917 	ldw	r4,1188(sp)
   17150:	20c0038b 	ldhu	r3,14(r4)
   17154:	193fffcc 	andi	r4,r3,65535
   17158:	2120001c 	xori	r4,r4,32768
   1715c:	21200004 	addi	r4,r4,-32768
   17160:	203ebc16 	blt	r4,zero,16c54 <___vfprintf_internal_r+0x90>
   17164:	da012917 	ldw	r8,1188(sp)
   17168:	d9013017 	ldw	r4,1216(sp)
   1716c:	d9c12d17 	ldw	r7,1204(sp)
   17170:	42800717 	ldw	r10,28(r8)
   17174:	42400917 	ldw	r9,36(r8)
   17178:	10bfff4c 	andi	r2,r2,65533
   1717c:	02010004 	movi	r8,1024
   17180:	d881070d 	sth	r2,1052(sp)
   17184:	d9410404 	addi	r5,sp,1040
   17188:	d8800404 	addi	r2,sp,16
   1718c:	800d883a 	mov	r6,r16
   17190:	d8c1078d 	sth	r3,1054(sp)
   17194:	da810b15 	stw	r10,1068(sp)
   17198:	da410d15 	stw	r9,1076(sp)
   1719c:	d8810415 	stw	r2,1040(sp)
   171a0:	d8810815 	stw	r2,1056(sp)
   171a4:	da010615 	stw	r8,1048(sp)
   171a8:	da010915 	stw	r8,1060(sp)
   171ac:	d8010a15 	stw	zero,1064(sp)
   171b0:	0016bc40 	call	16bc4 <___vfprintf_internal_r>
   171b4:	d8812c15 	stw	r2,1200(sp)
   171b8:	10000416 	blt	r2,zero,171cc <___vfprintf_internal_r+0x608>
   171bc:	d9013017 	ldw	r4,1216(sp)
   171c0:	d9410404 	addi	r5,sp,1040
   171c4:	001a4d00 	call	1a4d0 <_fflush_r>
   171c8:	1005d81e 	bne	r2,zero,1892c <___vfprintf_internal_r+0x1d68>
   171cc:	d881070b 	ldhu	r2,1052(sp)
   171d0:	1080100c 	andi	r2,r2,64
   171d4:	10bfffcc 	andi	r2,r2,65535
   171d8:	10a0001c 	xori	r2,r2,32768
   171dc:	10a00004 	addi	r2,r2,-32768
   171e0:	10001426 	beq	r2,zero,17234 <___vfprintf_internal_r+0x670>
   171e4:	d8c12917 	ldw	r3,1188(sp)
   171e8:	1880030b 	ldhu	r2,12(r3)
   171ec:	10801014 	ori	r2,r2,64
   171f0:	1880030d 	sth	r2,12(r3)
   171f4:	00000f06 	br	17234 <___vfprintf_internal_r+0x670>
   171f8:	d8811d17 	ldw	r2,1140(sp)
   171fc:	10000426 	beq	r2,zero,17210 <___vfprintf_internal_r+0x64c>
   17200:	d9013017 	ldw	r4,1216(sp)
   17204:	d9412917 	ldw	r5,1188(sp)
   17208:	d9811b04 	addi	r6,sp,1132
   1720c:	0016b900 	call	16b90 <__sprint_r>
   17210:	d8c12917 	ldw	r3,1188(sp)
   17214:	1880030b 	ldhu	r2,12(r3)
   17218:	1080100c 	andi	r2,r2,64
   1721c:	10bfffcc 	andi	r2,r2,65535
   17220:	10a0001c 	xori	r2,r2,32768
   17224:	10a00004 	addi	r2,r2,-32768
   17228:	10000226 	beq	r2,zero,17234 <___vfprintf_internal_r+0x670>
   1722c:	00bfffc4 	movi	r2,-1
   17230:	d8812c15 	stw	r2,1200(sp)
   17234:	d8812c17 	ldw	r2,1200(sp)
   17238:	dfc14617 	ldw	ra,1304(sp)
   1723c:	df014517 	ldw	fp,1300(sp)
   17240:	ddc14417 	ldw	r23,1296(sp)
   17244:	dd814317 	ldw	r22,1292(sp)
   17248:	dd414217 	ldw	r21,1288(sp)
   1724c:	dd014117 	ldw	r20,1284(sp)
   17250:	dcc14017 	ldw	r19,1280(sp)
   17254:	dc813f17 	ldw	r18,1276(sp)
   17258:	dc413e17 	ldw	r17,1272(sp)
   1725c:	dc013d17 	ldw	r16,1268(sp)
   17260:	dec14704 	addi	sp,sp,1308
   17264:	f800283a 	ret
   17268:	d9412917 	ldw	r5,1188(sp)
   1726c:	8809883a 	mov	r4,r17
   17270:	d9811b04 	addi	r6,sp,1132
   17274:	0016b900 	call	16b90 <__sprint_r>
   17278:	103fe51e 	bne	r2,zero,17210 <___vfprintf_internal_r+0x64c>
   1727c:	da400404 	addi	r9,sp,16
   17280:	003e9d06 	br	16cf8 <___vfprintf_internal_r+0x134>
   17284:	001a7780 	call	1a778 <__sinit>
   17288:	003e6606 	br	16c24 <___vfprintf_internal_r+0x60>
   1728c:	d8812d17 	ldw	r2,1204(sp)
   17290:	0007883a 	mov	r3,zero
   17294:	15c00017 	ldw	r23,0(r2)
   17298:	15800117 	ldw	r22,4(r2)
   1729c:	10800204 	addi	r2,r2,8
   172a0:	d8812d15 	stw	r2,1204(sp)
   172a4:	d8012585 	stb	zero,1174(sp)
   172a8:	bd84b03a 	or	r2,r23,r22
   172ac:	003f1c06 	br	16f20 <___vfprintf_internal_r+0x35c>
   172b0:	d8c12d17 	ldw	r3,1204(sp)
   172b4:	18800117 	ldw	r2,4(r3)
   172b8:	1dc00017 	ldw	r23,0(r3)
   172bc:	18c00204 	addi	r3,r3,8
   172c0:	d8c12d15 	stw	r3,1204(sp)
   172c4:	102d883a 	mov	r22,r2
   172c8:	003f8606 	br	170e4 <___vfprintf_internal_r+0x520>
   172cc:	d8c12d17 	ldw	r3,1204(sp)
   172d0:	d9012d17 	ldw	r4,1204(sp)
   172d4:	1dc00017 	ldw	r23,0(r3)
   172d8:	1d800117 	ldw	r22,4(r3)
   172dc:	21000204 	addi	r4,r4,8
   172e0:	00c00044 	movi	r3,1
   172e4:	d9012d15 	stw	r4,1204(sp)
   172e8:	bd84b03a 	or	r2,r23,r22
   172ec:	d8012585 	stb	zero,1174(sp)
   172f0:	003f0b06 	br	16f20 <___vfprintf_internal_r+0x35c>
   172f4:	d9812585 	stb	r6,1174(sp)
   172f8:	ac800007 	ldb	r18,0(r21)
   172fc:	003e8f06 	br	16d3c <___vfprintf_internal_r+0x178>
   17300:	ac800007 	ldb	r18,0(r21)
   17304:	a9000044 	addi	r4,r21,1
   17308:	92857d26 	beq	r18,r10,18900 <___vfprintf_internal_r+0x1d3c>
   1730c:	90bff404 	addi	r2,r18,-48
   17310:	0039883a 	mov	fp,zero
   17314:	28800736 	bltu	r5,r2,17334 <___vfprintf_internal_r+0x770>
   17318:	24800007 	ldb	r18,0(r4)
   1731c:	e70002a4 	muli	fp,fp,10
   17320:	21000044 	addi	r4,r4,1
   17324:	1739883a 	add	fp,r2,fp
   17328:	90bff404 	addi	r2,r18,-48
   1732c:	28bffa2e 	bgeu	r5,r2,17318 <___vfprintf_internal_r+0x754>
   17330:	e0044216 	blt	fp,zero,1843c <___vfprintf_internal_r+0x1878>
   17334:	202b883a 	mov	r21,r4
   17338:	003e8106 	br	16d40 <___vfprintf_internal_r+0x17c>
   1733c:	d8812587 	ldb	r2,1174(sp)
   17340:	1003581e 	bne	r2,zero,180a4 <___vfprintf_internal_r+0x14e0>
   17344:	dac12585 	stb	r11,1174(sp)
   17348:	ac800007 	ldb	r18,0(r21)
   1734c:	003e7b06 	br	16d3c <___vfprintf_internal_r+0x178>
   17350:	84000054 	ori	r16,r16,1
   17354:	ac800007 	ldb	r18,0(r21)
   17358:	003e7806 	br	16d3c <___vfprintf_internal_r+0x178>
   1735c:	84002014 	ori	r16,r16,128
   17360:	ac800007 	ldb	r18,0(r21)
   17364:	003e7506 	br	16d3c <___vfprintf_internal_r+0x178>
   17368:	020000f4 	movhi	r8,3
   1736c:	423c0f04 	addi	r8,r8,-4036
   17370:	da013615 	stw	r8,1240(sp)
   17374:	8080080c 	andi	r2,r16,32
   17378:	10009626 	beq	r2,zero,175d4 <___vfprintf_internal_r+0xa10>
   1737c:	d8812d17 	ldw	r2,1204(sp)
   17380:	15c00017 	ldw	r23,0(r2)
   17384:	15800117 	ldw	r22,4(r2)
   17388:	10800204 	addi	r2,r2,8
   1738c:	d8812d15 	stw	r2,1204(sp)
   17390:	8080004c 	andi	r2,r16,1
   17394:	1002ae26 	beq	r2,zero,17e50 <___vfprintf_internal_r+0x128c>
   17398:	bd84b03a 	or	r2,r23,r22
   1739c:	10032a26 	beq	r2,zero,18048 <___vfprintf_internal_r+0x1484>
   173a0:	00c00c04 	movi	r3,48
   173a4:	d8c12505 	stb	r3,1172(sp)
   173a8:	dc812545 	stb	r18,1173(sp)
   173ac:	84000094 	ori	r16,r16,2
   173b0:	00c00084 	movi	r3,2
   173b4:	d8012585 	stb	zero,1174(sp)
   173b8:	003ed906 	br	16f20 <___vfprintf_internal_r+0x35c>
   173bc:	84001014 	ori	r16,r16,64
   173c0:	ac800007 	ldb	r18,0(r21)
   173c4:	003e5d06 	br	16d3c <___vfprintf_internal_r+0x178>
   173c8:	ac800007 	ldb	r18,0(r21)
   173cc:	a805883a 	mov	r2,r21
   173d0:	91c43226 	beq	r18,r7,1849c <___vfprintf_internal_r+0x18d8>
   173d4:	84000414 	ori	r16,r16,16
   173d8:	003e5806 	br	16d3c <___vfprintf_internal_r+0x178>
   173dc:	d8c12d17 	ldw	r3,1204(sp)
   173e0:	02000044 	movi	r8,1
   173e4:	da012815 	stw	r8,1184(sp)
   173e8:	18800017 	ldw	r2,0(r3)
   173ec:	18c00104 	addi	r3,r3,4
   173f0:	d8012585 	stb	zero,1174(sp)
   173f4:	d8810405 	stb	r2,1040(sp)
   173f8:	d8c12d15 	stw	r3,1204(sp)
   173fc:	da012b15 	stw	r8,1196(sp)
   17400:	dcc10404 	addi	r19,sp,1040
   17404:	d8013115 	stw	zero,1220(sp)
   17408:	003ee006 	br	16f8c <___vfprintf_internal_r+0x3c8>
   1740c:	8080080c 	andi	r2,r16,32
   17410:	10031026 	beq	r2,zero,18054 <___vfprintf_internal_r+0x1490>
   17414:	d9012d17 	ldw	r4,1204(sp)
   17418:	da012c17 	ldw	r8,1200(sp)
   1741c:	20800017 	ldw	r2,0(r4)
   17420:	4007d7fa 	srai	r3,r8,31
   17424:	21000104 	addi	r4,r4,4
   17428:	d9012d15 	stw	r4,1204(sp)
   1742c:	12000015 	stw	r8,0(r2)
   17430:	10c00115 	stw	r3,4(r2)
   17434:	003e1906 	br	16c9c <___vfprintf_internal_r+0xd8>
   17438:	da012d17 	ldw	r8,1204(sp)
   1743c:	d9012d17 	ldw	r4,1204(sp)
   17440:	42000017 	ldw	r8,0(r8)
   17444:	20800104 	addi	r2,r4,4
   17448:	da012e15 	stw	r8,1208(sp)
   1744c:	403f2f16 	blt	r8,zero,1710c <___vfprintf_internal_r+0x548>
   17450:	d8812d15 	stw	r2,1204(sp)
   17454:	ac800007 	ldb	r18,0(r21)
   17458:	003e3806 	br	16d3c <___vfprintf_internal_r+0x178>
   1745c:	0009883a 	mov	r4,zero
   17460:	90bff404 	addi	r2,r18,-48
   17464:	ac800007 	ldb	r18,0(r21)
   17468:	210002a4 	muli	r4,r4,10
   1746c:	ad400044 	addi	r21,r21,1
   17470:	2089883a 	add	r4,r4,r2
   17474:	90bff404 	addi	r2,r18,-48
   17478:	28bffa2e 	bgeu	r5,r2,17464 <___vfprintf_internal_r+0x8a0>
   1747c:	d9012e15 	stw	r4,1208(sp)
   17480:	003e2f06 	br	16d40 <___vfprintf_internal_r+0x17c>
   17484:	8080020c 	andi	r2,r16,8
   17488:	1002d426 	beq	r2,zero,17fdc <___vfprintf_internal_r+0x1418>
   1748c:	d8c12d17 	ldw	r3,1204(sp)
   17490:	1d800017 	ldw	r22,0(r3)
   17494:	1d000117 	ldw	r20,4(r3)
   17498:	18c00204 	addi	r3,r3,8
   1749c:	d8c12d15 	stw	r3,1204(sp)
   174a0:	dd813315 	stw	r22,1228(sp)
   174a4:	dd013415 	stw	r20,1232(sp)
   174a8:	b009883a 	mov	r4,r22
   174ac:	a00b883a 	mov	r5,r20
   174b0:	da413c15 	stw	r9,1264(sp)
   174b4:	001d5dc0 	call	1d5dc <__isinfd>
   174b8:	da413c17 	ldw	r9,1264(sp)
   174bc:	b009883a 	mov	r4,r22
   174c0:	a00b883a 	mov	r5,r20
   174c4:	10035726 	beq	r2,zero,18224 <___vfprintf_internal_r+0x1660>
   174c8:	000d883a 	mov	r6,zero
   174cc:	000f883a 	mov	r7,zero
   174d0:	001f1d80 	call	1f1d8 <__ltdf2>
   174d4:	da413c17 	ldw	r9,1264(sp)
   174d8:	10041b16 	blt	r2,zero,18548 <___vfprintf_internal_r+0x1984>
   174dc:	d8812583 	ldbu	r2,1174(sp)
   174e0:	00c011c4 	movi	r3,71
   174e4:	1c830b16 	blt	r3,r18,18114 <___vfprintf_internal_r+0x1550>
   174e8:	04c000f4 	movhi	r19,3
   174ec:	9cfc0b04 	addi	r19,r19,-4052
   174f0:	020000c4 	movi	r8,3
   174f4:	00ffdfc4 	movi	r3,-129
   174f8:	da012815 	stw	r8,1184(sp)
   174fc:	80e0703a 	and	r16,r16,r3
   17500:	da012b15 	stw	r8,1196(sp)
   17504:	d8013115 	stw	zero,1220(sp)
   17508:	003e9906 	br	16f70 <___vfprintf_internal_r+0x3ac>
   1750c:	d8812d17 	ldw	r2,1204(sp)
   17510:	d8c12d17 	ldw	r3,1204(sp)
   17514:	020000f4 	movhi	r8,3
   17518:	423c1404 	addi	r8,r8,-4016
   1751c:	15c00017 	ldw	r23,0(r2)
   17520:	00800c04 	movi	r2,48
   17524:	18c00104 	addi	r3,r3,4
   17528:	d8812505 	stb	r2,1172(sp)
   1752c:	00801e04 	movi	r2,120
   17530:	d8812545 	stb	r2,1173(sp)
   17534:	d8c12d15 	stw	r3,1204(sp)
   17538:	002d883a 	mov	r22,zero
   1753c:	84000094 	ori	r16,r16,2
   17540:	da013615 	stw	r8,1240(sp)
   17544:	00c00084 	movi	r3,2
   17548:	04801e04 	movi	r18,120
   1754c:	b805883a 	mov	r2,r23
   17550:	d8012585 	stb	zero,1174(sp)
   17554:	003e7206 	br	16f20 <___vfprintf_internal_r+0x35c>
   17558:	84000814 	ori	r16,r16,32
   1755c:	ac800007 	ldb	r18,0(r21)
   17560:	003df606 	br	16d3c <___vfprintf_internal_r+0x178>
   17564:	d8812d17 	ldw	r2,1204(sp)
   17568:	d8012585 	stb	zero,1174(sp)
   1756c:	14c00017 	ldw	r19,0(r2)
   17570:	15c00104 	addi	r23,r2,4
   17574:	98040126 	beq	r19,zero,1857c <___vfprintf_internal_r+0x19b8>
   17578:	9809883a 	mov	r4,r19
   1757c:	e003dd16 	blt	fp,zero,184f4 <___vfprintf_internal_r+0x1930>
   17580:	000b883a 	mov	r5,zero
   17584:	e00d883a 	mov	r6,fp
   17588:	da413c15 	stw	r9,1264(sp)
   1758c:	001be180 	call	1be18 <memchr>
   17590:	da413c17 	ldw	r9,1264(sp)
   17594:	10042e26 	beq	r2,zero,18650 <___vfprintf_internal_r+0x1a8c>
   17598:	14c5c83a 	sub	r2,r2,r19
   1759c:	d8812b15 	stw	r2,1196(sp)
   175a0:	e083790e 	bge	fp,r2,18388 <___vfprintf_internal_r+0x17c4>
   175a4:	df012815 	stw	fp,1184(sp)
   175a8:	e0049516 	blt	fp,zero,18800 <___vfprintf_internal_r+0x1c3c>
   175ac:	d8812583 	ldbu	r2,1174(sp)
   175b0:	df012b15 	stw	fp,1196(sp)
   175b4:	ddc12d15 	stw	r23,1204(sp)
   175b8:	d8013115 	stw	zero,1220(sp)
   175bc:	003e6c06 	br	16f70 <___vfprintf_internal_r+0x3ac>
   175c0:	020000f4 	movhi	r8,3
   175c4:	423c1404 	addi	r8,r8,-4016
   175c8:	da013615 	stw	r8,1240(sp)
   175cc:	8080080c 	andi	r2,r16,32
   175d0:	103f6a1e 	bne	r2,zero,1737c <___vfprintf_internal_r+0x7b8>
   175d4:	8080040c 	andi	r2,r16,16
   175d8:	10029326 	beq	r2,zero,18028 <___vfprintf_internal_r+0x1464>
   175dc:	d8c12d17 	ldw	r3,1204(sp)
   175e0:	002d883a 	mov	r22,zero
   175e4:	1dc00017 	ldw	r23,0(r3)
   175e8:	18c00104 	addi	r3,r3,4
   175ec:	d8c12d15 	stw	r3,1204(sp)
   175f0:	003f6706 	br	17390 <___vfprintf_internal_r+0x7cc>
   175f4:	84000214 	ori	r16,r16,8
   175f8:	ac800007 	ldb	r18,0(r21)
   175fc:	003dcf06 	br	16d3c <___vfprintf_internal_r+0x178>
   17600:	da011d17 	ldw	r8,1140(sp)
   17604:	d8c11c17 	ldw	r3,1136(sp)
   17608:	d8812587 	ldb	r2,1174(sp)
   1760c:	10000b26 	beq	r2,zero,1763c <___vfprintf_internal_r+0xa78>
   17610:	d8812584 	addi	r2,sp,1174
   17614:	48800015 	stw	r2,0(r9)
   17618:	00800044 	movi	r2,1
   1761c:	48800115 	stw	r2,4(r9)
   17620:	4091883a 	add	r8,r8,r2
   17624:	1887883a 	add	r3,r3,r2
   17628:	da011d15 	stw	r8,1140(sp)
   1762c:	d8c11c15 	stw	r3,1136(sp)
   17630:	008001c4 	movi	r2,7
   17634:	10c18516 	blt	r2,r3,17c4c <___vfprintf_internal_r+0x1088>
   17638:	4a400204 	addi	r9,r9,8
   1763c:	d9012a17 	ldw	r4,1192(sp)
   17640:	20000b26 	beq	r4,zero,17670 <___vfprintf_internal_r+0xaac>
   17644:	d8812504 	addi	r2,sp,1172
   17648:	48800015 	stw	r2,0(r9)
   1764c:	00800084 	movi	r2,2
   17650:	48800115 	stw	r2,4(r9)
   17654:	4091883a 	add	r8,r8,r2
   17658:	18c00044 	addi	r3,r3,1
   1765c:	da011d15 	stw	r8,1140(sp)
   17660:	d8c11c15 	stw	r3,1136(sp)
   17664:	008001c4 	movi	r2,7
   17668:	10c18116 	blt	r2,r3,17c70 <___vfprintf_internal_r+0x10ac>
   1766c:	4a400204 	addi	r9,r9,8
   17670:	d9012f17 	ldw	r4,1212(sp)
   17674:	00802004 	movi	r2,128
   17678:	2080fc26 	beq	r4,r2,17a6c <___vfprintf_internal_r+0xea8>
   1767c:	d8813117 	ldw	r2,1220(sp)
   17680:	d9012b17 	ldw	r4,1196(sp)
   17684:	112fc83a 	sub	r23,r2,r4
   17688:	05c02a0e 	bge	zero,r23,17734 <___vfprintf_internal_r+0xb70>
   1768c:	07000404 	movi	fp,16
   17690:	050000f4 	movhi	r20,3
   17694:	a53c1f84 	addi	r20,r20,-3970
   17698:	e5c01d0e 	bge	fp,r23,17710 <___vfprintf_internal_r+0xb4c>
   1769c:	dc812a15 	stw	r18,1192(sp)
   176a0:	058001c4 	movi	r22,7
   176a4:	a025883a 	mov	r18,r20
   176a8:	8029883a 	mov	r20,r16
   176ac:	dc012917 	ldw	r16,1188(sp)
   176b0:	00000306 	br	176c0 <___vfprintf_internal_r+0xafc>
   176b4:	bdfffc04 	addi	r23,r23,-16
   176b8:	4a400204 	addi	r9,r9,8
   176bc:	e5c0110e 	bge	fp,r23,17704 <___vfprintf_internal_r+0xb40>
   176c0:	4c800015 	stw	r18,0(r9)
   176c4:	4f000115 	stw	fp,4(r9)
   176c8:	42000404 	addi	r8,r8,16
   176cc:	18c00044 	addi	r3,r3,1
   176d0:	da011d15 	stw	r8,1140(sp)
   176d4:	d8c11c15 	stw	r3,1136(sp)
   176d8:	b0fff60e 	bge	r22,r3,176b4 <___vfprintf_internal_r+0xaf0>
   176dc:	8809883a 	mov	r4,r17
   176e0:	800b883a 	mov	r5,r16
   176e4:	d9811b04 	addi	r6,sp,1132
   176e8:	0016b900 	call	16b90 <__sprint_r>
   176ec:	103ec81e 	bne	r2,zero,17210 <___vfprintf_internal_r+0x64c>
   176f0:	bdfffc04 	addi	r23,r23,-16
   176f4:	da011d17 	ldw	r8,1140(sp)
   176f8:	d8c11c17 	ldw	r3,1136(sp)
   176fc:	da400404 	addi	r9,sp,16
   17700:	e5ffef16 	blt	fp,r23,176c0 <___vfprintf_internal_r+0xafc>
   17704:	a021883a 	mov	r16,r20
   17708:	9029883a 	mov	r20,r18
   1770c:	dc812a17 	ldw	r18,1192(sp)
   17710:	4d000015 	stw	r20,0(r9)
   17714:	4dc00115 	stw	r23,4(r9)
   17718:	45d1883a 	add	r8,r8,r23
   1771c:	18c00044 	addi	r3,r3,1
   17720:	da011d15 	stw	r8,1140(sp)
   17724:	d8c11c15 	stw	r3,1136(sp)
   17728:	008001c4 	movi	r2,7
   1772c:	10c13e16 	blt	r2,r3,17c28 <___vfprintf_internal_r+0x1064>
   17730:	4a400204 	addi	r9,r9,8
   17734:	8080400c 	andi	r2,r16,256
   17738:	1000831e 	bne	r2,zero,17948 <___vfprintf_internal_r+0xd84>
   1773c:	d8812b17 	ldw	r2,1196(sp)
   17740:	4cc00015 	stw	r19,0(r9)
   17744:	48800115 	stw	r2,4(r9)
   17748:	4091883a 	add	r8,r8,r2
   1774c:	18c00044 	addi	r3,r3,1
   17750:	da011d15 	stw	r8,1140(sp)
   17754:	d8c11c15 	stw	r3,1136(sp)
   17758:	008001c4 	movi	r2,7
   1775c:	10c05316 	blt	r2,r3,178ac <___vfprintf_internal_r+0xce8>
   17760:	4a400204 	addi	r9,r9,8
   17764:	8400010c 	andi	r16,r16,4
   17768:	80002e26 	beq	r16,zero,17824 <___vfprintf_internal_r+0xc60>
   1776c:	d8812e17 	ldw	r2,1208(sp)
   17770:	d8c12817 	ldw	r3,1184(sp)
   17774:	10e1c83a 	sub	r16,r2,r3
   17778:	04002a0e 	bge	zero,r16,17824 <___vfprintf_internal_r+0xc60>
   1777c:	04800404 	movi	r18,16
   17780:	d8c11c17 	ldw	r3,1136(sp)
   17784:	05c000f4 	movhi	r23,3
   17788:	bdfc1b84 	addi	r23,r23,-3986
   1778c:	9400170e 	bge	r18,r16,177ec <___vfprintf_internal_r+0xc28>
   17790:	04c001c4 	movi	r19,7
   17794:	dd012917 	ldw	r20,1188(sp)
   17798:	00000306 	br	177a8 <___vfprintf_internal_r+0xbe4>
   1779c:	843ffc04 	addi	r16,r16,-16
   177a0:	4a400204 	addi	r9,r9,8
   177a4:	9400110e 	bge	r18,r16,177ec <___vfprintf_internal_r+0xc28>
   177a8:	4dc00015 	stw	r23,0(r9)
   177ac:	4c800115 	stw	r18,4(r9)
   177b0:	42000404 	addi	r8,r8,16
   177b4:	18c00044 	addi	r3,r3,1
   177b8:	da011d15 	stw	r8,1140(sp)
   177bc:	d8c11c15 	stw	r3,1136(sp)
   177c0:	98fff60e 	bge	r19,r3,1779c <___vfprintf_internal_r+0xbd8>
   177c4:	8809883a 	mov	r4,r17
   177c8:	a00b883a 	mov	r5,r20
   177cc:	d9811b04 	addi	r6,sp,1132
   177d0:	0016b900 	call	16b90 <__sprint_r>
   177d4:	103e8e1e 	bne	r2,zero,17210 <___vfprintf_internal_r+0x64c>
   177d8:	843ffc04 	addi	r16,r16,-16
   177dc:	da011d17 	ldw	r8,1140(sp)
   177e0:	d8c11c17 	ldw	r3,1136(sp)
   177e4:	da400404 	addi	r9,sp,16
   177e8:	943fef16 	blt	r18,r16,177a8 <___vfprintf_internal_r+0xbe4>
   177ec:	4dc00015 	stw	r23,0(r9)
   177f0:	4c000115 	stw	r16,4(r9)
   177f4:	8211883a 	add	r8,r16,r8
   177f8:	18c00044 	addi	r3,r3,1
   177fc:	da011d15 	stw	r8,1140(sp)
   17800:	d8c11c15 	stw	r3,1136(sp)
   17804:	008001c4 	movi	r2,7
   17808:	10c0060e 	bge	r2,r3,17824 <___vfprintf_internal_r+0xc60>
   1780c:	d9412917 	ldw	r5,1188(sp)
   17810:	8809883a 	mov	r4,r17
   17814:	d9811b04 	addi	r6,sp,1132
   17818:	0016b900 	call	16b90 <__sprint_r>
   1781c:	103e7c1e 	bne	r2,zero,17210 <___vfprintf_internal_r+0x64c>
   17820:	da011d17 	ldw	r8,1140(sp)
   17824:	dd012817 	ldw	r20,1184(sp)
   17828:	d9012e17 	ldw	r4,1208(sp)
   1782c:	a100010e 	bge	r20,r4,17834 <___vfprintf_internal_r+0xc70>
   17830:	2029883a 	mov	r20,r4
   17834:	d8812c17 	ldw	r2,1200(sp)
   17838:	1505883a 	add	r2,r2,r20
   1783c:	d8812c15 	stw	r2,1200(sp)
   17840:	4000b91e 	bne	r8,zero,17b28 <___vfprintf_internal_r+0xf64>
   17844:	d8011c15 	stw	zero,1136(sp)
   17848:	a8800007 	ldb	r2,0(r21)
   1784c:	da400404 	addi	r9,sp,16
   17850:	103d141e 	bne	r2,zero,16ca4 <___vfprintf_internal_r+0xe0>
   17854:	a825883a 	mov	r18,r21
   17858:	003d2a06 	br	16d04 <___vfprintf_internal_r+0x140>
   1785c:	d9412917 	ldw	r5,1188(sp)
   17860:	8809883a 	mov	r4,r17
   17864:	d9811b04 	addi	r6,sp,1132
   17868:	0016b900 	call	16b90 <__sprint_r>
   1786c:	103e681e 	bne	r2,zero,17210 <___vfprintf_internal_r+0x64c>
   17870:	da011d17 	ldw	r8,1140(sp)
   17874:	da400404 	addi	r9,sp,16
   17878:	8080004c 	andi	r2,r16,1
   1787c:	103fb926 	beq	r2,zero,17764 <___vfprintf_internal_r+0xba0>
   17880:	d8c11c17 	ldw	r3,1136(sp)
   17884:	d9013717 	ldw	r4,1244(sp)
   17888:	00800044 	movi	r2,1
   1788c:	48800115 	stw	r2,4(r9)
   17890:	49000015 	stw	r4,0(r9)
   17894:	4091883a 	add	r8,r8,r2
   17898:	1887883a 	add	r3,r3,r2
   1789c:	da011d15 	stw	r8,1140(sp)
   178a0:	d8c11c15 	stw	r3,1136(sp)
   178a4:	008001c4 	movi	r2,7
   178a8:	10ffad0e 	bge	r2,r3,17760 <___vfprintf_internal_r+0xb9c>
   178ac:	d9412917 	ldw	r5,1188(sp)
   178b0:	8809883a 	mov	r4,r17
   178b4:	d9811b04 	addi	r6,sp,1132
   178b8:	0016b900 	call	16b90 <__sprint_r>
   178bc:	103e541e 	bne	r2,zero,17210 <___vfprintf_internal_r+0x64c>
   178c0:	da400404 	addi	r9,sp,16
   178c4:	da011d17 	ldw	r8,1140(sp)
   178c8:	003fa606 	br	17764 <___vfprintf_internal_r+0xba0>
   178cc:	18803fcc 	andi	r2,r3,255
   178d0:	00c00044 	movi	r3,1
   178d4:	10c10126 	beq	r2,r3,17cdc <___vfprintf_internal_r+0x1118>
   178d8:	00c00084 	movi	r3,2
   178dc:	10c0f026 	beq	r2,r3,17ca0 <___vfprintf_internal_r+0x10dc>
   178e0:	d8c10dc4 	addi	r3,sp,1079
   178e4:	b808d0fa 	srli	r4,r23,3
   178e8:	b00a977a 	slli	r5,r22,29
   178ec:	b02cd0fa 	srli	r22,r22,3
   178f0:	bdc001cc 	andi	r23,r23,7
   178f4:	b8800c04 	addi	r2,r23,48
   178f8:	292eb03a 	or	r23,r5,r4
   178fc:	18800005 	stb	r2,0(r3)
   17900:	bd88b03a 	or	r4,r23,r22
   17904:	1827883a 	mov	r19,r3
   17908:	18ffffc4 	addi	r3,r3,-1
   1790c:	203ff51e 	bne	r4,zero,178e4 <___vfprintf_internal_r+0xd20>
   17910:	8100004c 	andi	r4,r16,1
   17914:	980b883a 	mov	r5,r19
   17918:	20000726 	beq	r4,zero,17938 <___vfprintf_internal_r+0xd74>
   1791c:	10803fcc 	andi	r2,r2,255
   17920:	1080201c 	xori	r2,r2,128
   17924:	10bfe004 	addi	r2,r2,-128
   17928:	01000c04 	movi	r4,48
   1792c:	11000226 	beq	r2,r4,17938 <___vfprintf_internal_r+0xd74>
   17930:	1827883a 	mov	r19,r3
   17934:	293fffc5 	stb	r4,-1(r5)
   17938:	d8812717 	ldw	r2,1180(sp)
   1793c:	14c5c83a 	sub	r2,r2,r19
   17940:	d8812b15 	stw	r2,1196(sp)
   17944:	003d8406 	br	16f58 <___vfprintf_internal_r+0x394>
   17948:	00801944 	movi	r2,101
   1794c:	14807c0e 	bge	r2,r18,17b40 <___vfprintf_internal_r+0xf7c>
   17950:	d9013317 	ldw	r4,1228(sp)
   17954:	d9413417 	ldw	r5,1232(sp)
   17958:	000d883a 	mov	r6,zero
   1795c:	000f883a 	mov	r7,zero
   17960:	d8c13b15 	stw	r3,1260(sp)
   17964:	da013a15 	stw	r8,1256(sp)
   17968:	da413c15 	stw	r9,1264(sp)
   1796c:	001f0580 	call	1f058 <__eqdf2>
   17970:	d8c13b17 	ldw	r3,1260(sp)
   17974:	da013a17 	ldw	r8,1256(sp)
   17978:	da413c17 	ldw	r9,1264(sp)
   1797c:	1001001e 	bne	r2,zero,17d80 <___vfprintf_internal_r+0x11bc>
   17980:	008000f4 	movhi	r2,3
   17984:	10bc1b04 	addi	r2,r2,-3988
   17988:	48800015 	stw	r2,0(r9)
   1798c:	00800044 	movi	r2,1
   17990:	48800115 	stw	r2,4(r9)
   17994:	4091883a 	add	r8,r8,r2
   17998:	1887883a 	add	r3,r3,r2
   1799c:	da011d15 	stw	r8,1140(sp)
   179a0:	d8c11c15 	stw	r3,1136(sp)
   179a4:	008001c4 	movi	r2,7
   179a8:	10c1dd16 	blt	r2,r3,18120 <___vfprintf_internal_r+0x155c>
   179ac:	4a400204 	addi	r9,r9,8
   179b0:	d8812417 	ldw	r2,1168(sp)
   179b4:	d8c13217 	ldw	r3,1224(sp)
   179b8:	10c00216 	blt	r2,r3,179c4 <___vfprintf_internal_r+0xe00>
   179bc:	8080004c 	andi	r2,r16,1
   179c0:	103f6826 	beq	r2,zero,17764 <___vfprintf_internal_r+0xba0>
   179c4:	d8c11c17 	ldw	r3,1136(sp)
   179c8:	d9013717 	ldw	r4,1244(sp)
   179cc:	00800044 	movi	r2,1
   179d0:	48800115 	stw	r2,4(r9)
   179d4:	49000015 	stw	r4,0(r9)
   179d8:	4091883a 	add	r8,r8,r2
   179dc:	1887883a 	add	r3,r3,r2
   179e0:	da011d15 	stw	r8,1140(sp)
   179e4:	d8c11c15 	stw	r3,1136(sp)
   179e8:	008001c4 	movi	r2,7
   179ec:	10c2af16 	blt	r2,r3,184ac <___vfprintf_internal_r+0x18e8>
   179f0:	4a400204 	addi	r9,r9,8
   179f4:	d8813217 	ldw	r2,1224(sp)
   179f8:	14bfffc4 	addi	r18,r2,-1
   179fc:	04bf590e 	bge	zero,r18,17764 <___vfprintf_internal_r+0xba0>
   17a00:	04c00404 	movi	r19,16
   17a04:	d8c11c17 	ldw	r3,1136(sp)
   17a08:	050000f4 	movhi	r20,3
   17a0c:	a53c1f84 	addi	r20,r20,-3970
   17a10:	9c81630e 	bge	r19,r18,17fa0 <___vfprintf_internal_r+0x13dc>
   17a14:	058001c4 	movi	r22,7
   17a18:	ddc12917 	ldw	r23,1188(sp)
   17a1c:	00000306 	br	17a2c <___vfprintf_internal_r+0xe68>
   17a20:	4a400204 	addi	r9,r9,8
   17a24:	94bffc04 	addi	r18,r18,-16
   17a28:	9c815d0e 	bge	r19,r18,17fa0 <___vfprintf_internal_r+0x13dc>
   17a2c:	4d000015 	stw	r20,0(r9)
   17a30:	4cc00115 	stw	r19,4(r9)
   17a34:	42000404 	addi	r8,r8,16
   17a38:	18c00044 	addi	r3,r3,1
   17a3c:	da011d15 	stw	r8,1140(sp)
   17a40:	d8c11c15 	stw	r3,1136(sp)
   17a44:	b0fff60e 	bge	r22,r3,17a20 <___vfprintf_internal_r+0xe5c>
   17a48:	8809883a 	mov	r4,r17
   17a4c:	b80b883a 	mov	r5,r23
   17a50:	d9811b04 	addi	r6,sp,1132
   17a54:	0016b900 	call	16b90 <__sprint_r>
   17a58:	103ded1e 	bne	r2,zero,17210 <___vfprintf_internal_r+0x64c>
   17a5c:	da011d17 	ldw	r8,1140(sp)
   17a60:	d8c11c17 	ldw	r3,1136(sp)
   17a64:	da400404 	addi	r9,sp,16
   17a68:	003fee06 	br	17a24 <___vfprintf_internal_r+0xe60>
   17a6c:	d8812e17 	ldw	r2,1208(sp)
   17a70:	d9012817 	ldw	r4,1184(sp)
   17a74:	112fc83a 	sub	r23,r2,r4
   17a78:	05ff000e 	bge	zero,r23,1767c <___vfprintf_internal_r+0xab8>
   17a7c:	07000404 	movi	fp,16
   17a80:	050000f4 	movhi	r20,3
   17a84:	a53c1f84 	addi	r20,r20,-3970
   17a88:	e5c01d0e 	bge	fp,r23,17b00 <___vfprintf_internal_r+0xf3c>
   17a8c:	dc812a15 	stw	r18,1192(sp)
   17a90:	058001c4 	movi	r22,7
   17a94:	a025883a 	mov	r18,r20
   17a98:	8029883a 	mov	r20,r16
   17a9c:	dc012917 	ldw	r16,1188(sp)
   17aa0:	00000306 	br	17ab0 <___vfprintf_internal_r+0xeec>
   17aa4:	bdfffc04 	addi	r23,r23,-16
   17aa8:	4a400204 	addi	r9,r9,8
   17aac:	e5c0110e 	bge	fp,r23,17af4 <___vfprintf_internal_r+0xf30>
   17ab0:	4c800015 	stw	r18,0(r9)
   17ab4:	4f000115 	stw	fp,4(r9)
   17ab8:	42000404 	addi	r8,r8,16
   17abc:	18c00044 	addi	r3,r3,1
   17ac0:	da011d15 	stw	r8,1140(sp)
   17ac4:	d8c11c15 	stw	r3,1136(sp)
   17ac8:	b0fff60e 	bge	r22,r3,17aa4 <___vfprintf_internal_r+0xee0>
   17acc:	8809883a 	mov	r4,r17
   17ad0:	800b883a 	mov	r5,r16
   17ad4:	d9811b04 	addi	r6,sp,1132
   17ad8:	0016b900 	call	16b90 <__sprint_r>
   17adc:	103dcc1e 	bne	r2,zero,17210 <___vfprintf_internal_r+0x64c>
   17ae0:	bdfffc04 	addi	r23,r23,-16
   17ae4:	da011d17 	ldw	r8,1140(sp)
   17ae8:	d8c11c17 	ldw	r3,1136(sp)
   17aec:	da400404 	addi	r9,sp,16
   17af0:	e5ffef16 	blt	fp,r23,17ab0 <___vfprintf_internal_r+0xeec>
   17af4:	a021883a 	mov	r16,r20
   17af8:	9029883a 	mov	r20,r18
   17afc:	dc812a17 	ldw	r18,1192(sp)
   17b00:	4d000015 	stw	r20,0(r9)
   17b04:	4dc00115 	stw	r23,4(r9)
   17b08:	45d1883a 	add	r8,r8,r23
   17b0c:	18c00044 	addi	r3,r3,1
   17b10:	da011d15 	stw	r8,1140(sp)
   17b14:	d8c11c15 	stw	r3,1136(sp)
   17b18:	008001c4 	movi	r2,7
   17b1c:	10c11716 	blt	r2,r3,17f7c <___vfprintf_internal_r+0x13b8>
   17b20:	4a400204 	addi	r9,r9,8
   17b24:	003ed506 	br	1767c <___vfprintf_internal_r+0xab8>
   17b28:	d9412917 	ldw	r5,1188(sp)
   17b2c:	8809883a 	mov	r4,r17
   17b30:	d9811b04 	addi	r6,sp,1132
   17b34:	0016b900 	call	16b90 <__sprint_r>
   17b38:	103f4226 	beq	r2,zero,17844 <___vfprintf_internal_r+0xc80>
   17b3c:	003db406 	br	17210 <___vfprintf_internal_r+0x64c>
   17b40:	d9013217 	ldw	r4,1224(sp)
   17b44:	00800044 	movi	r2,1
   17b48:	4cc00015 	stw	r19,0(r9)
   17b4c:	1100e10e 	bge	r2,r4,17ed4 <___vfprintf_internal_r+0x1310>
   17b50:	00800044 	movi	r2,1
   17b54:	48800115 	stw	r2,4(r9)
   17b58:	4091883a 	add	r8,r8,r2
   17b5c:	1887883a 	add	r3,r3,r2
   17b60:	da011d15 	stw	r8,1140(sp)
   17b64:	d8c11c15 	stw	r3,1136(sp)
   17b68:	008001c4 	movi	r2,7
   17b6c:	10c0ed16 	blt	r2,r3,17f24 <___vfprintf_internal_r+0x1360>
   17b70:	4a400204 	addi	r9,r9,8
   17b74:	d8813717 	ldw	r2,1244(sp)
   17b78:	48800015 	stw	r2,0(r9)
   17b7c:	00800044 	movi	r2,1
   17b80:	48800115 	stw	r2,4(r9)
   17b84:	4091883a 	add	r8,r8,r2
   17b88:	1887883a 	add	r3,r3,r2
   17b8c:	da011d15 	stw	r8,1140(sp)
   17b90:	d8c11c15 	stw	r3,1136(sp)
   17b94:	008001c4 	movi	r2,7
   17b98:	10c0eb16 	blt	r2,r3,17f48 <___vfprintf_internal_r+0x1384>
   17b9c:	4c800204 	addi	r18,r9,8
   17ba0:	d9013317 	ldw	r4,1228(sp)
   17ba4:	d9413417 	ldw	r5,1232(sp)
   17ba8:	000d883a 	mov	r6,zero
   17bac:	000f883a 	mov	r7,zero
   17bb0:	d8c13b15 	stw	r3,1260(sp)
   17bb4:	da013a15 	stw	r8,1256(sp)
   17bb8:	001f0b40 	call	1f0b4 <__nedf2>
   17bbc:	d8c13b17 	ldw	r3,1260(sp)
   17bc0:	da013a17 	ldw	r8,1256(sp)
   17bc4:	1000a626 	beq	r2,zero,17e60 <___vfprintf_internal_r+0x129c>
   17bc8:	d9013217 	ldw	r4,1224(sp)
   17bcc:	9cc00044 	addi	r19,r19,1
   17bd0:	94c00015 	stw	r19,0(r18)
   17bd4:	20bfffc4 	addi	r2,r4,-1
   17bd8:	90800115 	stw	r2,4(r18)
   17bdc:	4091883a 	add	r8,r8,r2
   17be0:	18c00044 	addi	r3,r3,1
   17be4:	da011d15 	stw	r8,1140(sp)
   17be8:	d8c11c15 	stw	r3,1136(sp)
   17bec:	008001c4 	movi	r2,7
   17bf0:	10c0c316 	blt	r2,r3,17f00 <___vfprintf_internal_r+0x133c>
   17bf4:	94800204 	addi	r18,r18,8
   17bf8:	d9013517 	ldw	r4,1236(sp)
   17bfc:	d8811fc4 	addi	r2,sp,1151
   17c00:	90800015 	stw	r2,0(r18)
   17c04:	91000115 	stw	r4,4(r18)
   17c08:	4111883a 	add	r8,r8,r4
   17c0c:	18c00044 	addi	r3,r3,1
   17c10:	da011d15 	stw	r8,1140(sp)
   17c14:	d8c11c15 	stw	r3,1136(sp)
   17c18:	008001c4 	movi	r2,7
   17c1c:	10ff2316 	blt	r2,r3,178ac <___vfprintf_internal_r+0xce8>
   17c20:	92400204 	addi	r9,r18,8
   17c24:	003ecf06 	br	17764 <___vfprintf_internal_r+0xba0>
   17c28:	d9412917 	ldw	r5,1188(sp)
   17c2c:	8809883a 	mov	r4,r17
   17c30:	d9811b04 	addi	r6,sp,1132
   17c34:	0016b900 	call	16b90 <__sprint_r>
   17c38:	103d751e 	bne	r2,zero,17210 <___vfprintf_internal_r+0x64c>
   17c3c:	da011d17 	ldw	r8,1140(sp)
   17c40:	d8c11c17 	ldw	r3,1136(sp)
   17c44:	da400404 	addi	r9,sp,16
   17c48:	003eba06 	br	17734 <___vfprintf_internal_r+0xb70>
   17c4c:	d9412917 	ldw	r5,1188(sp)
   17c50:	8809883a 	mov	r4,r17
   17c54:	d9811b04 	addi	r6,sp,1132
   17c58:	0016b900 	call	16b90 <__sprint_r>
   17c5c:	103d6c1e 	bne	r2,zero,17210 <___vfprintf_internal_r+0x64c>
   17c60:	da011d17 	ldw	r8,1140(sp)
   17c64:	d8c11c17 	ldw	r3,1136(sp)
   17c68:	da400404 	addi	r9,sp,16
   17c6c:	003e7306 	br	1763c <___vfprintf_internal_r+0xa78>
   17c70:	d9412917 	ldw	r5,1188(sp)
   17c74:	8809883a 	mov	r4,r17
   17c78:	d9811b04 	addi	r6,sp,1132
   17c7c:	0016b900 	call	16b90 <__sprint_r>
   17c80:	103d631e 	bne	r2,zero,17210 <___vfprintf_internal_r+0x64c>
   17c84:	da011d17 	ldw	r8,1140(sp)
   17c88:	d8c11c17 	ldw	r3,1136(sp)
   17c8c:	da400404 	addi	r9,sp,16
   17c90:	003e7706 	br	17670 <___vfprintf_internal_r+0xaac>
   17c94:	d8012b15 	stw	zero,1196(sp)
   17c98:	dcc10e04 	addi	r19,sp,1080
   17c9c:	003cae06 	br	16f58 <___vfprintf_internal_r+0x394>
   17ca0:	d9413617 	ldw	r5,1240(sp)
   17ca4:	d8810dc4 	addi	r2,sp,1079
   17ca8:	b8c003cc 	andi	r3,r23,15
   17cac:	b008973a 	slli	r4,r22,28
   17cb0:	28c7883a 	add	r3,r5,r3
   17cb4:	b82ed13a 	srli	r23,r23,4
   17cb8:	18c00003 	ldbu	r3,0(r3)
   17cbc:	b02cd13a 	srli	r22,r22,4
   17cc0:	25eeb03a 	or	r23,r4,r23
   17cc4:	10c00005 	stb	r3,0(r2)
   17cc8:	bd86b03a 	or	r3,r23,r22
   17ccc:	1027883a 	mov	r19,r2
   17cd0:	10bfffc4 	addi	r2,r2,-1
   17cd4:	183ff41e 	bne	r3,zero,17ca8 <___vfprintf_internal_r+0x10e4>
   17cd8:	003f1706 	br	17938 <___vfprintf_internal_r+0xd74>
   17cdc:	b0025826 	beq	r22,zero,18640 <___vfprintf_internal_r+0x1a7c>
   17ce0:	b807883a 	mov	r3,r23
   17ce4:	d8810dc4 	addi	r2,sp,1079
   17ce8:	882f883a 	mov	r23,r17
   17cec:	04c00244 	movi	r19,9
   17cf0:	8023883a 	mov	r17,r16
   17cf4:	da412815 	stw	r9,1184(sp)
   17cf8:	1821883a 	mov	r16,r3
   17cfc:	8009883a 	mov	r4,r16
   17d00:	b00b883a 	mov	r5,r22
   17d04:	01800284 	movi	r6,10
   17d08:	000f883a 	mov	r7,zero
   17d0c:	1029883a 	mov	r20,r2
   17d10:	001e22c0 	call	1e22c <__umoddi3>
   17d14:	10800c04 	addi	r2,r2,48
   17d18:	8009883a 	mov	r4,r16
   17d1c:	b00b883a 	mov	r5,r22
   17d20:	a0800005 	stb	r2,0(r20)
   17d24:	01800284 	movi	r6,10
   17d28:	000f883a 	mov	r7,zero
   17d2c:	001dc640 	call	1dc64 <__udivdi3>
   17d30:	1021883a 	mov	r16,r2
   17d34:	182d883a 	mov	r22,r3
   17d38:	a0bfffc4 	addi	r2,r20,-1
   17d3c:	183fef1e 	bne	r3,zero,17cfc <___vfprintf_internal_r+0x1138>
   17d40:	9c3fee36 	bltu	r19,r16,17cfc <___vfprintf_internal_r+0x1138>
   17d44:	da412817 	ldw	r9,1184(sp)
   17d48:	8005883a 	mov	r2,r16
   17d4c:	8821883a 	mov	r16,r17
   17d50:	b823883a 	mov	r17,r23
   17d54:	102f883a 	mov	r23,r2
   17d58:	d8812717 	ldw	r2,1180(sp)
   17d5c:	a4ffffc4 	addi	r19,r20,-1
   17d60:	bdc00c04 	addi	r23,r23,48
   17d64:	14c5c83a 	sub	r2,r2,r19
   17d68:	a5ffffc5 	stb	r23,-1(r20)
   17d6c:	d8812b15 	stw	r2,1196(sp)
   17d70:	003c7906 	br	16f58 <___vfprintf_internal_r+0x394>
   17d74:	00c00044 	movi	r3,1
   17d78:	bd84b03a 	or	r2,r23,r22
   17d7c:	003c6806 	br	16f20 <___vfprintf_internal_r+0x35c>
   17d80:	dc812417 	ldw	r18,1168(sp)
   17d84:	0480ee0e 	bge	zero,r18,18140 <___vfprintf_internal_r+0x157c>
   17d88:	d9013217 	ldw	r4,1224(sp)
   17d8c:	4cc00015 	stw	r19,0(r9)
   17d90:	9100c616 	blt	r18,r4,180ac <___vfprintf_internal_r+0x14e8>
   17d94:	49000115 	stw	r4,4(r9)
   17d98:	4111883a 	add	r8,r8,r4
   17d9c:	18c00044 	addi	r3,r3,1
   17da0:	da011d15 	stw	r8,1140(sp)
   17da4:	d8c11c15 	stw	r3,1136(sp)
   17da8:	008001c4 	movi	r2,7
   17dac:	10c20916 	blt	r2,r3,185d4 <___vfprintf_internal_r+0x1a10>
   17db0:	4a400204 	addi	r9,r9,8
   17db4:	d8813217 	ldw	r2,1224(sp)
   17db8:	90a5c83a 	sub	r18,r18,r2
   17dbc:	04beae0e 	bge	zero,r18,17878 <___vfprintf_internal_r+0xcb4>
   17dc0:	04c00404 	movi	r19,16
   17dc4:	d8c11c17 	ldw	r3,1136(sp)
   17dc8:	050000f4 	movhi	r20,3
   17dcc:	a53c1f84 	addi	r20,r20,-3970
   17dd0:	9c81be0e 	bge	r19,r18,184cc <___vfprintf_internal_r+0x1908>
   17dd4:	058001c4 	movi	r22,7
   17dd8:	ddc12917 	ldw	r23,1188(sp)
   17ddc:	00000306 	br	17dec <___vfprintf_internal_r+0x1228>
   17de0:	4a400204 	addi	r9,r9,8
   17de4:	94bffc04 	addi	r18,r18,-16
   17de8:	9c81b80e 	bge	r19,r18,184cc <___vfprintf_internal_r+0x1908>
   17dec:	4d000015 	stw	r20,0(r9)
   17df0:	4cc00115 	stw	r19,4(r9)
   17df4:	42000404 	addi	r8,r8,16
   17df8:	18c00044 	addi	r3,r3,1
   17dfc:	da011d15 	stw	r8,1140(sp)
   17e00:	d8c11c15 	stw	r3,1136(sp)
   17e04:	b0fff60e 	bge	r22,r3,17de0 <___vfprintf_internal_r+0x121c>
   17e08:	8809883a 	mov	r4,r17
   17e0c:	b80b883a 	mov	r5,r23
   17e10:	d9811b04 	addi	r6,sp,1132
   17e14:	0016b900 	call	16b90 <__sprint_r>
   17e18:	103cfd1e 	bne	r2,zero,17210 <___vfprintf_internal_r+0x64c>
   17e1c:	da011d17 	ldw	r8,1140(sp)
   17e20:	d8c11c17 	ldw	r3,1136(sp)
   17e24:	da400404 	addi	r9,sp,16
   17e28:	003fee06 	br	17de4 <___vfprintf_internal_r+0x1220>
   17e2c:	d9412917 	ldw	r5,1188(sp)
   17e30:	8809883a 	mov	r4,r17
   17e34:	d9811b04 	addi	r6,sp,1132
   17e38:	0016b900 	call	16b90 <__sprint_r>
   17e3c:	103cf41e 	bne	r2,zero,17210 <___vfprintf_internal_r+0x64c>
   17e40:	da011d17 	ldw	r8,1140(sp)
   17e44:	d8c11c17 	ldw	r3,1136(sp)
   17e48:	da400404 	addi	r9,sp,16
   17e4c:	003dee06 	br	17608 <___vfprintf_internal_r+0xa44>
   17e50:	00c00084 	movi	r3,2
   17e54:	bd84b03a 	or	r2,r23,r22
   17e58:	d8012585 	stb	zero,1174(sp)
   17e5c:	003c3006 	br	16f20 <___vfprintf_internal_r+0x35c>
   17e60:	d8813217 	ldw	r2,1224(sp)
   17e64:	14ffffc4 	addi	r19,r2,-1
   17e68:	04ff630e 	bge	zero,r19,17bf8 <___vfprintf_internal_r+0x1034>
   17e6c:	05800404 	movi	r22,16
   17e70:	050000f4 	movhi	r20,3
   17e74:	a53c1f84 	addi	r20,r20,-3970
   17e78:	b4c03c0e 	bge	r22,r19,17f6c <___vfprintf_internal_r+0x13a8>
   17e7c:	05c001c4 	movi	r23,7
   17e80:	df012917 	ldw	fp,1188(sp)
   17e84:	00000306 	br	17e94 <___vfprintf_internal_r+0x12d0>
   17e88:	94800204 	addi	r18,r18,8
   17e8c:	9cfffc04 	addi	r19,r19,-16
   17e90:	b4c0360e 	bge	r22,r19,17f6c <___vfprintf_internal_r+0x13a8>
   17e94:	95000015 	stw	r20,0(r18)
   17e98:	95800115 	stw	r22,4(r18)
   17e9c:	42000404 	addi	r8,r8,16
   17ea0:	18c00044 	addi	r3,r3,1
   17ea4:	da011d15 	stw	r8,1140(sp)
   17ea8:	d8c11c15 	stw	r3,1136(sp)
   17eac:	b8fff60e 	bge	r23,r3,17e88 <___vfprintf_internal_r+0x12c4>
   17eb0:	8809883a 	mov	r4,r17
   17eb4:	e00b883a 	mov	r5,fp
   17eb8:	d9811b04 	addi	r6,sp,1132
   17ebc:	0016b900 	call	16b90 <__sprint_r>
   17ec0:	103cd31e 	bne	r2,zero,17210 <___vfprintf_internal_r+0x64c>
   17ec4:	da011d17 	ldw	r8,1140(sp)
   17ec8:	d8c11c17 	ldw	r3,1136(sp)
   17ecc:	dc800404 	addi	r18,sp,16
   17ed0:	003fee06 	br	17e8c <___vfprintf_internal_r+0x12c8>
   17ed4:	8088703a 	and	r4,r16,r2
   17ed8:	203f1d1e 	bne	r4,zero,17b50 <___vfprintf_internal_r+0xf8c>
   17edc:	48800115 	stw	r2,4(r9)
   17ee0:	42000044 	addi	r8,r8,1
   17ee4:	18c00044 	addi	r3,r3,1
   17ee8:	da011d15 	stw	r8,1140(sp)
   17eec:	d8c11c15 	stw	r3,1136(sp)
   17ef0:	008001c4 	movi	r2,7
   17ef4:	10c00216 	blt	r2,r3,17f00 <___vfprintf_internal_r+0x133c>
   17ef8:	4c800204 	addi	r18,r9,8
   17efc:	003f3e06 	br	17bf8 <___vfprintf_internal_r+0x1034>
   17f00:	d9412917 	ldw	r5,1188(sp)
   17f04:	8809883a 	mov	r4,r17
   17f08:	d9811b04 	addi	r6,sp,1132
   17f0c:	0016b900 	call	16b90 <__sprint_r>
   17f10:	103cbf1e 	bne	r2,zero,17210 <___vfprintf_internal_r+0x64c>
   17f14:	dc800404 	addi	r18,sp,16
   17f18:	da011d17 	ldw	r8,1140(sp)
   17f1c:	d8c11c17 	ldw	r3,1136(sp)
   17f20:	003f3506 	br	17bf8 <___vfprintf_internal_r+0x1034>
   17f24:	d9412917 	ldw	r5,1188(sp)
   17f28:	8809883a 	mov	r4,r17
   17f2c:	d9811b04 	addi	r6,sp,1132
   17f30:	0016b900 	call	16b90 <__sprint_r>
   17f34:	103cb61e 	bne	r2,zero,17210 <___vfprintf_internal_r+0x64c>
   17f38:	da011d17 	ldw	r8,1140(sp)
   17f3c:	d8c11c17 	ldw	r3,1136(sp)
   17f40:	da400404 	addi	r9,sp,16
   17f44:	003f0b06 	br	17b74 <___vfprintf_internal_r+0xfb0>
   17f48:	d9412917 	ldw	r5,1188(sp)
   17f4c:	8809883a 	mov	r4,r17
   17f50:	d9811b04 	addi	r6,sp,1132
   17f54:	0016b900 	call	16b90 <__sprint_r>
   17f58:	103cad1e 	bne	r2,zero,17210 <___vfprintf_internal_r+0x64c>
   17f5c:	da011d17 	ldw	r8,1140(sp)
   17f60:	d8c11c17 	ldw	r3,1136(sp)
   17f64:	dc800404 	addi	r18,sp,16
   17f68:	003f0d06 	br	17ba0 <___vfprintf_internal_r+0xfdc>
   17f6c:	95000015 	stw	r20,0(r18)
   17f70:	94c00115 	stw	r19,4(r18)
   17f74:	44d1883a 	add	r8,r8,r19
   17f78:	003f1906 	br	17be0 <___vfprintf_internal_r+0x101c>
   17f7c:	d9412917 	ldw	r5,1188(sp)
   17f80:	8809883a 	mov	r4,r17
   17f84:	d9811b04 	addi	r6,sp,1132
   17f88:	0016b900 	call	16b90 <__sprint_r>
   17f8c:	103ca01e 	bne	r2,zero,17210 <___vfprintf_internal_r+0x64c>
   17f90:	da011d17 	ldw	r8,1140(sp)
   17f94:	d8c11c17 	ldw	r3,1136(sp)
   17f98:	da400404 	addi	r9,sp,16
   17f9c:	003db706 	br	1767c <___vfprintf_internal_r+0xab8>
   17fa0:	4d000015 	stw	r20,0(r9)
   17fa4:	4c800115 	stw	r18,4(r9)
   17fa8:	4491883a 	add	r8,r8,r18
   17fac:	003de706 	br	1774c <___vfprintf_internal_r+0xb88>
   17fb0:	8080100c 	andi	r2,r16,64
   17fb4:	10010226 	beq	r2,zero,183c0 <___vfprintf_internal_r+0x17fc>
   17fb8:	d8812d17 	ldw	r2,1204(sp)
   17fbc:	002d883a 	mov	r22,zero
   17fc0:	00c00044 	movi	r3,1
   17fc4:	15c0000b 	ldhu	r23,0(r2)
   17fc8:	10800104 	addi	r2,r2,4
   17fcc:	d8812d15 	stw	r2,1204(sp)
   17fd0:	d8012585 	stb	zero,1174(sp)
   17fd4:	b805883a 	mov	r2,r23
   17fd8:	003bd106 	br	16f20 <___vfprintf_internal_r+0x35c>
   17fdc:	d9012d17 	ldw	r4,1204(sp)
   17fe0:	25800017 	ldw	r22,0(r4)
   17fe4:	25000117 	ldw	r20,4(r4)
   17fe8:	21000204 	addi	r4,r4,8
   17fec:	d9012d15 	stw	r4,1204(sp)
   17ff0:	dd813315 	stw	r22,1228(sp)
   17ff4:	dd013415 	stw	r20,1232(sp)
   17ff8:	003d2b06 	br	174a8 <___vfprintf_internal_r+0x8e4>
   17ffc:	8080100c 	andi	r2,r16,64
   18000:	1000fe26 	beq	r2,zero,183fc <___vfprintf_internal_r+0x1838>
   18004:	d9012d17 	ldw	r4,1204(sp)
   18008:	002d883a 	mov	r22,zero
   1800c:	0007883a 	mov	r3,zero
   18010:	25c0000b 	ldhu	r23,0(r4)
   18014:	21000104 	addi	r4,r4,4
   18018:	d9012d15 	stw	r4,1204(sp)
   1801c:	b805883a 	mov	r2,r23
   18020:	d8012585 	stb	zero,1174(sp)
   18024:	003bbe06 	br	16f20 <___vfprintf_internal_r+0x35c>
   18028:	8080100c 	andi	r2,r16,64
   1802c:	1000ed26 	beq	r2,zero,183e4 <___vfprintf_internal_r+0x1820>
   18030:	d9012d17 	ldw	r4,1204(sp)
   18034:	002d883a 	mov	r22,zero
   18038:	25c0000b 	ldhu	r23,0(r4)
   1803c:	21000104 	addi	r4,r4,4
   18040:	d9012d15 	stw	r4,1204(sp)
   18044:	003cd206 	br	17390 <___vfprintf_internal_r+0x7cc>
   18048:	00c00084 	movi	r3,2
   1804c:	d8012585 	stb	zero,1174(sp)
   18050:	003bb306 	br	16f20 <___vfprintf_internal_r+0x35c>
   18054:	8080040c 	andi	r2,r16,16
   18058:	1000f11e 	bne	r2,zero,18420 <___vfprintf_internal_r+0x185c>
   1805c:	8400100c 	andi	r16,r16,64
   18060:	80015526 	beq	r16,zero,185b8 <___vfprintf_internal_r+0x19f4>
   18064:	da012d17 	ldw	r8,1204(sp)
   18068:	d8c12c17 	ldw	r3,1200(sp)
   1806c:	40800017 	ldw	r2,0(r8)
   18070:	42000104 	addi	r8,r8,4
   18074:	da012d15 	stw	r8,1204(sp)
   18078:	10c0000d 	sth	r3,0(r2)
   1807c:	003b0706 	br	16c9c <___vfprintf_internal_r+0xd8>
   18080:	8080100c 	andi	r2,r16,64
   18084:	1000c726 	beq	r2,zero,183a4 <___vfprintf_internal_r+0x17e0>
   18088:	da012d17 	ldw	r8,1204(sp)
   1808c:	45c0000f 	ldh	r23,0(r8)
   18090:	42000104 	addi	r8,r8,4
   18094:	da012d15 	stw	r8,1204(sp)
   18098:	b82dd7fa 	srai	r22,r23,31
   1809c:	b005883a 	mov	r2,r22
   180a0:	003c1006 	br	170e4 <___vfprintf_internal_r+0x520>
   180a4:	ac800007 	ldb	r18,0(r21)
   180a8:	003b2406 	br	16d3c <___vfprintf_internal_r+0x178>
   180ac:	4c800115 	stw	r18,4(r9)
   180b0:	9211883a 	add	r8,r18,r8
   180b4:	18c00044 	addi	r3,r3,1
   180b8:	da011d15 	stw	r8,1140(sp)
   180bc:	d8c11c15 	stw	r3,1136(sp)
   180c0:	008001c4 	movi	r2,7
   180c4:	10c15416 	blt	r2,r3,18618 <___vfprintf_internal_r+0x1a54>
   180c8:	4a400204 	addi	r9,r9,8
   180cc:	d8813717 	ldw	r2,1244(sp)
   180d0:	9ca7883a 	add	r19,r19,r18
   180d4:	48800015 	stw	r2,0(r9)
   180d8:	00800044 	movi	r2,1
   180dc:	48800115 	stw	r2,4(r9)
   180e0:	4091883a 	add	r8,r8,r2
   180e4:	1887883a 	add	r3,r3,r2
   180e8:	da011d15 	stw	r8,1140(sp)
   180ec:	d8c11c15 	stw	r3,1136(sp)
   180f0:	008001c4 	movi	r2,7
   180f4:	10c14016 	blt	r2,r3,185f8 <___vfprintf_internal_r+0x1a34>
   180f8:	4a400204 	addi	r9,r9,8
   180fc:	d9013217 	ldw	r4,1224(sp)
   18100:	da011d17 	ldw	r8,1140(sp)
   18104:	d8c11c17 	ldw	r3,1136(sp)
   18108:	24a5c83a 	sub	r18,r4,r18
   1810c:	4cc00015 	stw	r19,0(r9)
   18110:	003fa406 	br	17fa4 <___vfprintf_internal_r+0x13e0>
   18114:	04c000f4 	movhi	r19,3
   18118:	9cfc0c04 	addi	r19,r19,-4048
   1811c:	003cf406 	br	174f0 <___vfprintf_internal_r+0x92c>
   18120:	d9412917 	ldw	r5,1188(sp)
   18124:	8809883a 	mov	r4,r17
   18128:	d9811b04 	addi	r6,sp,1132
   1812c:	0016b900 	call	16b90 <__sprint_r>
   18130:	103c371e 	bne	r2,zero,17210 <___vfprintf_internal_r+0x64c>
   18134:	da011d17 	ldw	r8,1140(sp)
   18138:	da400404 	addi	r9,sp,16
   1813c:	003e1c06 	br	179b0 <___vfprintf_internal_r+0xdec>
   18140:	008000f4 	movhi	r2,3
   18144:	10bc1b04 	addi	r2,r2,-3988
   18148:	48800015 	stw	r2,0(r9)
   1814c:	00800044 	movi	r2,1
   18150:	48800115 	stw	r2,4(r9)
   18154:	4091883a 	add	r8,r8,r2
   18158:	1887883a 	add	r3,r3,r2
   1815c:	da011d15 	stw	r8,1140(sp)
   18160:	d8c11c15 	stw	r3,1136(sp)
   18164:	008001c4 	movi	r2,7
   18168:	10c0c316 	blt	r2,r3,18478 <___vfprintf_internal_r+0x18b4>
   1816c:	4a400204 	addi	r9,r9,8
   18170:	9000041e 	bne	r18,zero,18184 <___vfprintf_internal_r+0x15c0>
   18174:	d8c13217 	ldw	r3,1224(sp)
   18178:	1800021e 	bne	r3,zero,18184 <___vfprintf_internal_r+0x15c0>
   1817c:	8080004c 	andi	r2,r16,1
   18180:	103d7826 	beq	r2,zero,17764 <___vfprintf_internal_r+0xba0>
   18184:	d8c11c17 	ldw	r3,1136(sp)
   18188:	d9013717 	ldw	r4,1244(sp)
   1818c:	00800044 	movi	r2,1
   18190:	48800115 	stw	r2,4(r9)
   18194:	49000015 	stw	r4,0(r9)
   18198:	4091883a 	add	r8,r8,r2
   1819c:	1887883a 	add	r3,r3,r2
   181a0:	da011d15 	stw	r8,1140(sp)
   181a4:	d8c11c15 	stw	r3,1136(sp)
   181a8:	008001c4 	movi	r2,7
   181ac:	10c12e16 	blt	r2,r3,18668 <___vfprintf_internal_r+0x1aa4>
   181b0:	4a400204 	addi	r9,r9,8
   181b4:	04a5c83a 	sub	r18,zero,r18
   181b8:	0480de0e 	bge	zero,r18,18534 <___vfprintf_internal_r+0x1970>
   181bc:	05800404 	movi	r22,16
   181c0:	050000f4 	movhi	r20,3
   181c4:	a53c1f84 	addi	r20,r20,-3970
   181c8:	b480e20e 	bge	r22,r18,18554 <___vfprintf_internal_r+0x1990>
   181cc:	05c001c4 	movi	r23,7
   181d0:	df012917 	ldw	fp,1188(sp)
   181d4:	00000306 	br	181e4 <___vfprintf_internal_r+0x1620>
   181d8:	4a400204 	addi	r9,r9,8
   181dc:	94bffc04 	addi	r18,r18,-16
   181e0:	b480dc0e 	bge	r22,r18,18554 <___vfprintf_internal_r+0x1990>
   181e4:	4d000015 	stw	r20,0(r9)
   181e8:	4d800115 	stw	r22,4(r9)
   181ec:	42000404 	addi	r8,r8,16
   181f0:	18c00044 	addi	r3,r3,1
   181f4:	da011d15 	stw	r8,1140(sp)
   181f8:	d8c11c15 	stw	r3,1136(sp)
   181fc:	b8fff60e 	bge	r23,r3,181d8 <___vfprintf_internal_r+0x1614>
   18200:	8809883a 	mov	r4,r17
   18204:	e00b883a 	mov	r5,fp
   18208:	d9811b04 	addi	r6,sp,1132
   1820c:	0016b900 	call	16b90 <__sprint_r>
   18210:	103bff1e 	bne	r2,zero,17210 <___vfprintf_internal_r+0x64c>
   18214:	da011d17 	ldw	r8,1140(sp)
   18218:	d8c11c17 	ldw	r3,1136(sp)
   1821c:	da400404 	addi	r9,sp,16
   18220:	003fee06 	br	181dc <___vfprintf_internal_r+0x1618>
   18224:	da413c15 	stw	r9,1264(sp)
   18228:	001d6140 	call	1d614 <__isnand>
   1822c:	da413c17 	ldw	r9,1264(sp)
   18230:	1000851e 	bne	r2,zero,18448 <___vfprintf_internal_r+0x1884>
   18234:	00bfffc4 	movi	r2,-1
   18238:	e0817626 	beq	fp,r2,18814 <___vfprintf_internal_r+0x1c50>
   1823c:	008019c4 	movi	r2,103
   18240:	90817126 	beq	r18,r2,18808 <___vfprintf_internal_r+0x1c44>
   18244:	008011c4 	movi	r2,71
   18248:	90816f26 	beq	r18,r2,18808 <___vfprintf_internal_r+0x1c44>
   1824c:	82004014 	ori	r8,r16,256
   18250:	da012a15 	stw	r8,1192(sp)
   18254:	a0017116 	blt	r20,zero,1881c <___vfprintf_internal_r+0x1c58>
   18258:	d8012f05 	stb	zero,1212(sp)
   1825c:	00801984 	movi	r2,102
   18260:	90811226 	beq	r18,r2,186ac <___vfprintf_internal_r+0x1ae8>
   18264:	00801184 	movi	r2,70
   18268:	90811026 	beq	r18,r2,186ac <___vfprintf_internal_r+0x1ae8>
   1826c:	00801944 	movi	r2,101
   18270:	90819b26 	beq	r18,r2,188e0 <___vfprintf_internal_r+0x1d1c>
   18274:	00801144 	movi	r2,69
   18278:	90819926 	beq	r18,r2,188e0 <___vfprintf_internal_r+0x1d1c>
   1827c:	e02f883a 	mov	r23,fp
   18280:	d8812404 	addi	r2,sp,1168
   18284:	d8800115 	stw	r2,4(sp)
   18288:	d8812304 	addi	r2,sp,1164
   1828c:	d8800215 	stw	r2,8(sp)
   18290:	d8812204 	addi	r2,sp,1160
   18294:	ddc00015 	stw	r23,0(sp)
   18298:	d8800315 	stw	r2,12(sp)
   1829c:	8809883a 	mov	r4,r17
   182a0:	b00b883a 	mov	r5,r22
   182a4:	a00d883a 	mov	r6,r20
   182a8:	01c00084 	movi	r7,2
   182ac:	da413c15 	stw	r9,1264(sp)
   182b0:	0018eb40 	call	18eb4 <_dtoa_r>
   182b4:	1027883a 	mov	r19,r2
   182b8:	008019c4 	movi	r2,103
   182bc:	da413c17 	ldw	r9,1264(sp)
   182c0:	90818c1e 	bne	r18,r2,188f4 <___vfprintf_internal_r+0x1d30>
   182c4:	8080004c 	andi	r2,r16,1
   182c8:	10017926 	beq	r2,zero,188b0 <___vfprintf_internal_r+0x1cec>
   182cc:	00801184 	movi	r2,70
   182d0:	9dc7883a 	add	r3,r19,r23
   182d4:	90810626 	beq	r18,r2,186f0 <___vfprintf_internal_r+0x1b2c>
   182d8:	b009883a 	mov	r4,r22
   182dc:	a00b883a 	mov	r5,r20
   182e0:	000d883a 	mov	r6,zero
   182e4:	000f883a 	mov	r7,zero
   182e8:	d8c13b15 	stw	r3,1260(sp)
   182ec:	da413c15 	stw	r9,1264(sp)
   182f0:	001f0580 	call	1f058 <__eqdf2>
   182f4:	d8c13b17 	ldw	r3,1260(sp)
   182f8:	da413c17 	ldw	r9,1264(sp)
   182fc:	10000726 	beq	r2,zero,1831c <___vfprintf_internal_r+0x1758>
   18300:	d8812217 	ldw	r2,1160(sp)
   18304:	10c1962e 	bgeu	r2,r3,18960 <___vfprintf_internal_r+0x1d9c>
   18308:	01000c04 	movi	r4,48
   1830c:	11000005 	stb	r4,0(r2)
   18310:	10800044 	addi	r2,r2,1
   18314:	d8812215 	stw	r2,1160(sp)
   18318:	10fffc1e 	bne	r2,r3,1830c <___vfprintf_internal_r+0x1748>
   1831c:	1cc7c83a 	sub	r3,r3,r19
   18320:	d8c13215 	stw	r3,1224(sp)
   18324:	008019c4 	movi	r2,103
   18328:	90810626 	beq	r18,r2,18744 <___vfprintf_internal_r+0x1b80>
   1832c:	008011c4 	movi	r2,71
   18330:	90810426 	beq	r18,r2,18744 <___vfprintf_internal_r+0x1b80>
   18334:	00801984 	movi	r2,102
   18338:	90819a1e 	bne	r18,r2,189a4 <___vfprintf_internal_r+0x1de0>
   1833c:	d8812417 	ldw	r2,1168(sp)
   18340:	d8812b15 	stw	r2,1196(sp)
   18344:	0081880e 	bge	zero,r2,18968 <___vfprintf_internal_r+0x1da4>
   18348:	e000021e 	bne	fp,zero,18354 <___vfprintf_internal_r+0x1790>
   1834c:	8400004c 	andi	r16,r16,1
   18350:	80000426 	beq	r16,zero,18364 <___vfprintf_internal_r+0x17a0>
   18354:	d8812b17 	ldw	r2,1196(sp)
   18358:	e2000044 	addi	r8,fp,1
   1835c:	1205883a 	add	r2,r2,r8
   18360:	d8812b15 	stw	r2,1196(sp)
   18364:	d8812815 	stw	r2,1184(sp)
   18368:	10011716 	blt	r2,zero,187c8 <___vfprintf_internal_r+0x1c04>
   1836c:	ddc12f07 	ldb	r23,1212(sp)
   18370:	b800ca26 	beq	r23,zero,1869c <___vfprintf_internal_r+0x1ad8>
   18374:	00800b44 	movi	r2,45
   18378:	d8812585 	stb	r2,1174(sp)
   1837c:	dc012a17 	ldw	r16,1192(sp)
   18380:	d8013115 	stw	zero,1220(sp)
   18384:	003afe06 	br	16f80 <___vfprintf_internal_r+0x3bc>
   18388:	d8812b17 	ldw	r2,1196(sp)
   1838c:	d8812815 	stw	r2,1184(sp)
   18390:	10005e16 	blt	r2,zero,1850c <___vfprintf_internal_r+0x1948>
   18394:	d8812583 	ldbu	r2,1174(sp)
   18398:	ddc12d15 	stw	r23,1204(sp)
   1839c:	d8013115 	stw	zero,1220(sp)
   183a0:	003af306 	br	16f70 <___vfprintf_internal_r+0x3ac>
   183a4:	d8812d17 	ldw	r2,1204(sp)
   183a8:	15c00017 	ldw	r23,0(r2)
   183ac:	10800104 	addi	r2,r2,4
   183b0:	d8812d15 	stw	r2,1204(sp)
   183b4:	b82dd7fa 	srai	r22,r23,31
   183b8:	b005883a 	mov	r2,r22
   183bc:	003b4906 	br	170e4 <___vfprintf_internal_r+0x520>
   183c0:	d8c12d17 	ldw	r3,1204(sp)
   183c4:	002d883a 	mov	r22,zero
   183c8:	1dc00017 	ldw	r23,0(r3)
   183cc:	18c00104 	addi	r3,r3,4
   183d0:	d8c12d15 	stw	r3,1204(sp)
   183d4:	b805883a 	mov	r2,r23
   183d8:	00c00044 	movi	r3,1
   183dc:	d8012585 	stb	zero,1174(sp)
   183e0:	003acf06 	br	16f20 <___vfprintf_internal_r+0x35c>
   183e4:	da012d17 	ldw	r8,1204(sp)
   183e8:	002d883a 	mov	r22,zero
   183ec:	45c00017 	ldw	r23,0(r8)
   183f0:	42000104 	addi	r8,r8,4
   183f4:	da012d15 	stw	r8,1204(sp)
   183f8:	003be506 	br	17390 <___vfprintf_internal_r+0x7cc>
   183fc:	da012d17 	ldw	r8,1204(sp)
   18400:	002d883a 	mov	r22,zero
   18404:	0007883a 	mov	r3,zero
   18408:	45c00017 	ldw	r23,0(r8)
   1840c:	42000104 	addi	r8,r8,4
   18410:	da012d15 	stw	r8,1204(sp)
   18414:	b805883a 	mov	r2,r23
   18418:	d8012585 	stb	zero,1174(sp)
   1841c:	003ac006 	br	16f20 <___vfprintf_internal_r+0x35c>
   18420:	d8c12d17 	ldw	r3,1204(sp)
   18424:	d9012c17 	ldw	r4,1200(sp)
   18428:	18800017 	ldw	r2,0(r3)
   1842c:	18c00104 	addi	r3,r3,4
   18430:	d8c12d15 	stw	r3,1204(sp)
   18434:	11000015 	stw	r4,0(r2)
   18438:	003a1806 	br	16c9c <___vfprintf_internal_r+0xd8>
   1843c:	073fffc4 	movi	fp,-1
   18440:	202b883a 	mov	r21,r4
   18444:	003a3e06 	br	16d40 <___vfprintf_internal_r+0x17c>
   18448:	008011c4 	movi	r2,71
   1844c:	14809016 	blt	r2,r18,18690 <___vfprintf_internal_r+0x1acc>
   18450:	04c000f4 	movhi	r19,3
   18454:	9cfc0d04 	addi	r19,r19,-4044
   18458:	00c000c4 	movi	r3,3
   1845c:	00bfdfc4 	movi	r2,-129
   18460:	80a0703a 	and	r16,r16,r2
   18464:	d8c12815 	stw	r3,1184(sp)
   18468:	d8812583 	ldbu	r2,1174(sp)
   1846c:	d8c12b15 	stw	r3,1196(sp)
   18470:	d8013115 	stw	zero,1220(sp)
   18474:	003abe06 	br	16f70 <___vfprintf_internal_r+0x3ac>
   18478:	d9412917 	ldw	r5,1188(sp)
   1847c:	8809883a 	mov	r4,r17
   18480:	d9811b04 	addi	r6,sp,1132
   18484:	0016b900 	call	16b90 <__sprint_r>
   18488:	103b611e 	bne	r2,zero,17210 <___vfprintf_internal_r+0x64c>
   1848c:	dc812417 	ldw	r18,1168(sp)
   18490:	da011d17 	ldw	r8,1140(sp)
   18494:	da400404 	addi	r9,sp,16
   18498:	003f3506 	br	18170 <___vfprintf_internal_r+0x15ac>
   1849c:	ad400044 	addi	r21,r21,1
   184a0:	84000814 	ori	r16,r16,32
   184a4:	14800047 	ldb	r18,1(r2)
   184a8:	003a2406 	br	16d3c <___vfprintf_internal_r+0x178>
   184ac:	d9412917 	ldw	r5,1188(sp)
   184b0:	8809883a 	mov	r4,r17
   184b4:	d9811b04 	addi	r6,sp,1132
   184b8:	0016b900 	call	16b90 <__sprint_r>
   184bc:	103b541e 	bne	r2,zero,17210 <___vfprintf_internal_r+0x64c>
   184c0:	da011d17 	ldw	r8,1140(sp)
   184c4:	da400404 	addi	r9,sp,16
   184c8:	003d4a06 	br	179f4 <___vfprintf_internal_r+0xe30>
   184cc:	4d000015 	stw	r20,0(r9)
   184d0:	4c800115 	stw	r18,4(r9)
   184d4:	4491883a 	add	r8,r8,r18
   184d8:	18c00044 	addi	r3,r3,1
   184dc:	da011d15 	stw	r8,1140(sp)
   184e0:	d8c11c15 	stw	r3,1136(sp)
   184e4:	008001c4 	movi	r2,7
   184e8:	10fcdc16 	blt	r2,r3,1785c <___vfprintf_internal_r+0xc98>
   184ec:	4a400204 	addi	r9,r9,8
   184f0:	003ce106 	br	17878 <___vfprintf_internal_r+0xcb4>
   184f4:	da413c15 	stw	r9,1264(sp)
   184f8:	0016a080 	call	16a08 <strlen>
   184fc:	d8812b15 	stw	r2,1196(sp)
   18500:	d8812815 	stw	r2,1184(sp)
   18504:	da413c17 	ldw	r9,1264(sp)
   18508:	103fa20e 	bge	r2,zero,18394 <___vfprintf_internal_r+0x17d0>
   1850c:	d8012815 	stw	zero,1184(sp)
   18510:	003fa006 	br	18394 <___vfprintf_internal_r+0x17d0>
   18514:	d9412917 	ldw	r5,1188(sp)
   18518:	8809883a 	mov	r4,r17
   1851c:	d9811b04 	addi	r6,sp,1132
   18520:	0016b900 	call	16b90 <__sprint_r>
   18524:	103b3a1e 	bne	r2,zero,17210 <___vfprintf_internal_r+0x64c>
   18528:	da011d17 	ldw	r8,1140(sp)
   1852c:	d8c11c17 	ldw	r3,1136(sp)
   18530:	da400404 	addi	r9,sp,16
   18534:	d8813217 	ldw	r2,1224(sp)
   18538:	4cc00015 	stw	r19,0(r9)
   1853c:	48800115 	stw	r2,4(r9)
   18540:	4091883a 	add	r8,r8,r2
   18544:	003c8106 	br	1774c <___vfprintf_internal_r+0xb88>
   18548:	00800b44 	movi	r2,45
   1854c:	d8812585 	stb	r2,1174(sp)
   18550:	003be306 	br	174e0 <___vfprintf_internal_r+0x91c>
   18554:	4d000015 	stw	r20,0(r9)
   18558:	4c800115 	stw	r18,4(r9)
   1855c:	4491883a 	add	r8,r8,r18
   18560:	18c00044 	addi	r3,r3,1
   18564:	da011d15 	stw	r8,1140(sp)
   18568:	d8c11c15 	stw	r3,1136(sp)
   1856c:	008001c4 	movi	r2,7
   18570:	10ffe816 	blt	r2,r3,18514 <___vfprintf_internal_r+0x1950>
   18574:	4a400204 	addi	r9,r9,8
   18578:	003fee06 	br	18534 <___vfprintf_internal_r+0x1970>
   1857c:	df012b15 	stw	fp,1196(sp)
   18580:	00800184 	movi	r2,6
   18584:	1700072e 	bgeu	r2,fp,185a4 <___vfprintf_internal_r+0x19e0>
   18588:	d8812b15 	stw	r2,1196(sp)
   1858c:	d8812815 	stw	r2,1184(sp)
   18590:	ddc12d15 	stw	r23,1204(sp)
   18594:	04c000f4 	movhi	r19,3
   18598:	9cfc1904 	addi	r19,r19,-3996
   1859c:	d8013115 	stw	zero,1220(sp)
   185a0:	003a7a06 	br	16f8c <___vfprintf_internal_r+0x3c8>
   185a4:	d8812b17 	ldw	r2,1196(sp)
   185a8:	d8812815 	stw	r2,1184(sp)
   185ac:	103ff80e 	bge	r2,zero,18590 <___vfprintf_internal_r+0x19cc>
   185b0:	d8012815 	stw	zero,1184(sp)
   185b4:	003ff606 	br	18590 <___vfprintf_internal_r+0x19cc>
   185b8:	d9012d17 	ldw	r4,1204(sp)
   185bc:	da012c17 	ldw	r8,1200(sp)
   185c0:	20800017 	ldw	r2,0(r4)
   185c4:	21000104 	addi	r4,r4,4
   185c8:	d9012d15 	stw	r4,1204(sp)
   185cc:	12000015 	stw	r8,0(r2)
   185d0:	0039b206 	br	16c9c <___vfprintf_internal_r+0xd8>
   185d4:	d9412917 	ldw	r5,1188(sp)
   185d8:	8809883a 	mov	r4,r17
   185dc:	d9811b04 	addi	r6,sp,1132
   185e0:	0016b900 	call	16b90 <__sprint_r>
   185e4:	103b0a1e 	bne	r2,zero,17210 <___vfprintf_internal_r+0x64c>
   185e8:	dc812417 	ldw	r18,1168(sp)
   185ec:	da011d17 	ldw	r8,1140(sp)
   185f0:	da400404 	addi	r9,sp,16
   185f4:	003def06 	br	17db4 <___vfprintf_internal_r+0x11f0>
   185f8:	d9412917 	ldw	r5,1188(sp)
   185fc:	8809883a 	mov	r4,r17
   18600:	d9811b04 	addi	r6,sp,1132
   18604:	0016b900 	call	16b90 <__sprint_r>
   18608:	103b011e 	bne	r2,zero,17210 <___vfprintf_internal_r+0x64c>
   1860c:	dc812417 	ldw	r18,1168(sp)
   18610:	da400404 	addi	r9,sp,16
   18614:	003eb906 	br	180fc <___vfprintf_internal_r+0x1538>
   18618:	d9412917 	ldw	r5,1188(sp)
   1861c:	8809883a 	mov	r4,r17
   18620:	d9811b04 	addi	r6,sp,1132
   18624:	0016b900 	call	16b90 <__sprint_r>
   18628:	103af91e 	bne	r2,zero,17210 <___vfprintf_internal_r+0x64c>
   1862c:	dc812417 	ldw	r18,1168(sp)
   18630:	da011d17 	ldw	r8,1140(sp)
   18634:	d8c11c17 	ldw	r3,1136(sp)
   18638:	da400404 	addi	r9,sp,16
   1863c:	003ea306 	br	180cc <___vfprintf_internal_r+0x1508>
   18640:	00800244 	movi	r2,9
   18644:	15fda636 	bltu	r2,r23,17ce0 <___vfprintf_internal_r+0x111c>
   18648:	dd010e04 	addi	r20,sp,1080
   1864c:	003dc206 	br	17d58 <___vfprintf_internal_r+0x1194>
   18650:	df012815 	stw	fp,1184(sp)
   18654:	d8812583 	ldbu	r2,1174(sp)
   18658:	df012b15 	stw	fp,1196(sp)
   1865c:	ddc12d15 	stw	r23,1204(sp)
   18660:	d8013115 	stw	zero,1220(sp)
   18664:	003a4206 	br	16f70 <___vfprintf_internal_r+0x3ac>
   18668:	d9412917 	ldw	r5,1188(sp)
   1866c:	8809883a 	mov	r4,r17
   18670:	d9811b04 	addi	r6,sp,1132
   18674:	0016b900 	call	16b90 <__sprint_r>
   18678:	103ae51e 	bne	r2,zero,17210 <___vfprintf_internal_r+0x64c>
   1867c:	dc812417 	ldw	r18,1168(sp)
   18680:	da011d17 	ldw	r8,1140(sp)
   18684:	d8c11c17 	ldw	r3,1136(sp)
   18688:	da400404 	addi	r9,sp,16
   1868c:	003ec906 	br	181b4 <___vfprintf_internal_r+0x15f0>
   18690:	04c000f4 	movhi	r19,3
   18694:	9cfc0e04 	addi	r19,r19,-4040
   18698:	003f6f06 	br	18458 <___vfprintf_internal_r+0x1894>
   1869c:	d8812583 	ldbu	r2,1174(sp)
   186a0:	dc012a17 	ldw	r16,1192(sp)
   186a4:	d8013115 	stw	zero,1220(sp)
   186a8:	003a3106 	br	16f70 <___vfprintf_internal_r+0x3ac>
   186ac:	d8812404 	addi	r2,sp,1168
   186b0:	d8800115 	stw	r2,4(sp)
   186b4:	d8812304 	addi	r2,sp,1164
   186b8:	d8800215 	stw	r2,8(sp)
   186bc:	d8812204 	addi	r2,sp,1160
   186c0:	df000015 	stw	fp,0(sp)
   186c4:	d8800315 	stw	r2,12(sp)
   186c8:	8809883a 	mov	r4,r17
   186cc:	b00b883a 	mov	r5,r22
   186d0:	a00d883a 	mov	r6,r20
   186d4:	01c000c4 	movi	r7,3
   186d8:	da413c15 	stw	r9,1264(sp)
   186dc:	0018eb40 	call	18eb4 <_dtoa_r>
   186e0:	da413c17 	ldw	r9,1264(sp)
   186e4:	1027883a 	mov	r19,r2
   186e8:	1707883a 	add	r3,r2,fp
   186ec:	e02f883a 	mov	r23,fp
   186f0:	99000007 	ldb	r4,0(r19)
   186f4:	00800c04 	movi	r2,48
   186f8:	20800326 	beq	r4,r2,18708 <___vfprintf_internal_r+0x1b44>
   186fc:	da812417 	ldw	r10,1168(sp)
   18700:	1a87883a 	add	r3,r3,r10
   18704:	003ef406 	br	182d8 <___vfprintf_internal_r+0x1714>
   18708:	b009883a 	mov	r4,r22
   1870c:	a00b883a 	mov	r5,r20
   18710:	000d883a 	mov	r6,zero
   18714:	000f883a 	mov	r7,zero
   18718:	d8c13b15 	stw	r3,1260(sp)
   1871c:	da413c15 	stw	r9,1264(sp)
   18720:	001f0b40 	call	1f0b4 <__nedf2>
   18724:	d8c13b17 	ldw	r3,1260(sp)
   18728:	da413c17 	ldw	r9,1264(sp)
   1872c:	103ff326 	beq	r2,zero,186fc <___vfprintf_internal_r+0x1b38>
   18730:	00800044 	movi	r2,1
   18734:	15d5c83a 	sub	r10,r2,r23
   18738:	da812415 	stw	r10,1168(sp)
   1873c:	1a87883a 	add	r3,r3,r10
   18740:	003ee506 	br	182d8 <___vfprintf_internal_r+0x1714>
   18744:	d8812417 	ldw	r2,1168(sp)
   18748:	d8812b15 	stw	r2,1196(sp)
   1874c:	1029883a 	mov	r20,r2
   18750:	00bfff44 	movi	r2,-3
   18754:	a0800116 	blt	r20,r2,1875c <___vfprintf_internal_r+0x1b98>
   18758:	e5001d0e 	bge	fp,r20,187d0 <___vfprintf_internal_r+0x1c0c>
   1875c:	94bfff84 	addi	r18,r18,-2
   18760:	a53fffc4 	addi	r20,r20,-1
   18764:	dd012415 	stw	r20,1168(sp)
   18768:	dc811fc5 	stb	r18,1151(sp)
   1876c:	a0007816 	blt	r20,zero,18950 <___vfprintf_internal_r+0x1d8c>
   18770:	00800ac4 	movi	r2,43
   18774:	d8812005 	stb	r2,1152(sp)
   18778:	00800244 	movi	r2,9
   1877c:	15002b16 	blt	r2,r20,1882c <___vfprintf_internal_r+0x1c68>
   18780:	00800c04 	movi	r2,48
   18784:	a5000c04 	addi	r20,r20,48
   18788:	d8812045 	stb	r2,1153(sp)
   1878c:	dd012085 	stb	r20,1154(sp)
   18790:	d8c120c4 	addi	r3,sp,1155
   18794:	d8811fc4 	addi	r2,sp,1151
   18798:	da013217 	ldw	r8,1224(sp)
   1879c:	1885c83a 	sub	r2,r3,r2
   187a0:	d8813515 	stw	r2,1236(sp)
   187a4:	4085883a 	add	r2,r8,r2
   187a8:	d8812b15 	stw	r2,1196(sp)
   187ac:	00800044 	movi	r2,1
   187b0:	1200610e 	bge	r2,r8,18938 <___vfprintf_internal_r+0x1d74>
   187b4:	d8812b17 	ldw	r2,1196(sp)
   187b8:	10800044 	addi	r2,r2,1
   187bc:	d8812b15 	stw	r2,1196(sp)
   187c0:	d8812815 	stw	r2,1184(sp)
   187c4:	103ee90e 	bge	r2,zero,1836c <___vfprintf_internal_r+0x17a8>
   187c8:	d8012815 	stw	zero,1184(sp)
   187cc:	003ee706 	br	1836c <___vfprintf_internal_r+0x17a8>
   187d0:	d8812b17 	ldw	r2,1196(sp)
   187d4:	da013217 	ldw	r8,1224(sp)
   187d8:	12003716 	blt	r2,r8,188b8 <___vfprintf_internal_r+0x1cf4>
   187dc:	8400004c 	andi	r16,r16,1
   187e0:	80000326 	beq	r16,zero,187f0 <___vfprintf_internal_r+0x1c2c>
   187e4:	d8812b17 	ldw	r2,1196(sp)
   187e8:	10800044 	addi	r2,r2,1
   187ec:	d8812b15 	stw	r2,1196(sp)
   187f0:	d8812815 	stw	r2,1184(sp)
   187f4:	10003716 	blt	r2,zero,188d4 <___vfprintf_internal_r+0x1d10>
   187f8:	048019c4 	movi	r18,103
   187fc:	003edb06 	br	1836c <___vfprintf_internal_r+0x17a8>
   18800:	d8012815 	stw	zero,1184(sp)
   18804:	003b6906 	br	175ac <___vfprintf_internal_r+0x9e8>
   18808:	e03e901e 	bne	fp,zero,1824c <___vfprintf_internal_r+0x1688>
   1880c:	07000044 	movi	fp,1
   18810:	003e8e06 	br	1824c <___vfprintf_internal_r+0x1688>
   18814:	07000184 	movi	fp,6
   18818:	003e8c06 	br	1824c <___vfprintf_internal_r+0x1688>
   1881c:	00c00b44 	movi	r3,45
   18820:	a520003c 	xorhi	r20,r20,32768
   18824:	d8c12f05 	stb	r3,1212(sp)
   18828:	003e8c06 	br	1825c <___vfprintf_internal_r+0x1698>
   1882c:	d8c11f84 	addi	r3,sp,1150
   18830:	102f883a 	mov	r23,r2
   18834:	4839883a 	mov	fp,r9
   18838:	a009883a 	mov	r4,r20
   1883c:	01400284 	movi	r5,10
   18840:	182d883a 	mov	r22,r3
   18844:	001f5bc0 	call	1f5bc <__modsi3>
   18848:	10800c04 	addi	r2,r2,48
   1884c:	a009883a 	mov	r4,r20
   18850:	b0800005 	stb	r2,0(r22)
   18854:	01400284 	movi	r5,10
   18858:	001f56c0 	call	1f56c <__divsi3>
   1885c:	1029883a 	mov	r20,r2
   18860:	b0ffffc4 	addi	r3,r22,-1
   18864:	b8bff416 	blt	r23,r2,18838 <___vfprintf_internal_r+0x1c74>
   18868:	11400c04 	addi	r5,r2,48
   1886c:	b17fffc5 	stb	r5,-1(r22)
   18870:	d8811fc4 	addi	r2,sp,1151
   18874:	e013883a 	mov	r9,fp
   18878:	1880482e 	bgeu	r3,r2,1899c <___vfprintf_internal_r+0x1dd8>
   1887c:	b007883a 	mov	r3,r22
   18880:	d9012044 	addi	r4,sp,1153
   18884:	00000206 	br	18890 <___vfprintf_internal_r+0x1ccc>
   18888:	19400003 	ldbu	r5,0(r3)
   1888c:	18c00044 	addi	r3,r3,1
   18890:	21400005 	stb	r5,0(r4)
   18894:	21000044 	addi	r4,r4,1
   18898:	10fffb1e 	bne	r2,r3,18888 <___vfprintf_internal_r+0x1cc4>
   1889c:	d8c12004 	addi	r3,sp,1152
   188a0:	1d87c83a 	sub	r3,r3,r22
   188a4:	d9012044 	addi	r4,sp,1153
   188a8:	20c7883a 	add	r3,r4,r3
   188ac:	003fba06 	br	18798 <___vfprintf_internal_r+0x1bd4>
   188b0:	d8c12217 	ldw	r3,1160(sp)
   188b4:	003e9906 	br	1831c <___vfprintf_internal_r+0x1758>
   188b8:	05000b0e 	bge	zero,r20,188e8 <___vfprintf_internal_r+0x1d24>
   188bc:	05000044 	movi	r20,1
   188c0:	da013217 	ldw	r8,1224(sp)
   188c4:	a229883a 	add	r20,r20,r8
   188c8:	dd012b15 	stw	r20,1196(sp)
   188cc:	dd012815 	stw	r20,1184(sp)
   188d0:	a03fc90e 	bge	r20,zero,187f8 <___vfprintf_internal_r+0x1c34>
   188d4:	d8012815 	stw	zero,1184(sp)
   188d8:	048019c4 	movi	r18,103
   188dc:	003ea306 	br	1836c <___vfprintf_internal_r+0x17a8>
   188e0:	e5c00044 	addi	r23,fp,1
   188e4:	003e6606 	br	18280 <___vfprintf_internal_r+0x16bc>
   188e8:	00800084 	movi	r2,2
   188ec:	1529c83a 	sub	r20,r2,r20
   188f0:	003ff306 	br	188c0 <___vfprintf_internal_r+0x1cfc>
   188f4:	008011c4 	movi	r2,71
   188f8:	90be7226 	beq	r18,r2,182c4 <___vfprintf_internal_r+0x1700>
   188fc:	003e7306 	br	182cc <___vfprintf_internal_r+0x1708>
   18900:	d8812d17 	ldw	r2,1204(sp)
   18904:	ac800043 	ldbu	r18,1(r21)
   18908:	202b883a 	mov	r21,r4
   1890c:	17000017 	ldw	fp,0(r2)
   18910:	10800104 	addi	r2,r2,4
   18914:	d8812d15 	stw	r2,1204(sp)
   18918:	e0001b16 	blt	fp,zero,18988 <___vfprintf_internal_r+0x1dc4>
   1891c:	94803fcc 	andi	r18,r18,255
   18920:	9480201c 	xori	r18,r18,128
   18924:	94bfe004 	addi	r18,r18,-128
   18928:	00390406 	br	16d3c <___vfprintf_internal_r+0x178>
   1892c:	00bfffc4 	movi	r2,-1
   18930:	d8812c15 	stw	r2,1200(sp)
   18934:	003a2506 	br	171cc <___vfprintf_internal_r+0x608>
   18938:	80a0703a 	and	r16,r16,r2
   1893c:	803f9d1e 	bne	r16,zero,187b4 <___vfprintf_internal_r+0x1bf0>
   18940:	d8812b17 	ldw	r2,1196(sp)
   18944:	d8812815 	stw	r2,1184(sp)
   18948:	103e880e 	bge	r2,zero,1836c <___vfprintf_internal_r+0x17a8>
   1894c:	003f9e06 	br	187c8 <___vfprintf_internal_r+0x1c04>
   18950:	00800b44 	movi	r2,45
   18954:	0529c83a 	sub	r20,zero,r20
   18958:	d8812005 	stb	r2,1152(sp)
   1895c:	003f8606 	br	18778 <___vfprintf_internal_r+0x1bb4>
   18960:	1007883a 	mov	r3,r2
   18964:	003e6d06 	br	1831c <___vfprintf_internal_r+0x1758>
   18968:	e000021e 	bne	fp,zero,18974 <___vfprintf_internal_r+0x1db0>
   1896c:	8400004c 	andi	r16,r16,1
   18970:	80000e26 	beq	r16,zero,189ac <___vfprintf_internal_r+0x1de8>
   18974:	e7000084 	addi	fp,fp,2
   18978:	df012b15 	stw	fp,1196(sp)
   1897c:	df012815 	stw	fp,1184(sp)
   18980:	e03e7a0e 	bge	fp,zero,1836c <___vfprintf_internal_r+0x17a8>
   18984:	003f9006 	br	187c8 <___vfprintf_internal_r+0x1c04>
   18988:	94803fcc 	andi	r18,r18,255
   1898c:	9480201c 	xori	r18,r18,128
   18990:	073fffc4 	movi	fp,-1
   18994:	94bfe004 	addi	r18,r18,-128
   18998:	0038e806 	br	16d3c <___vfprintf_internal_r+0x178>
   1899c:	d8c12044 	addi	r3,sp,1153
   189a0:	003f7d06 	br	18798 <___vfprintf_internal_r+0x1bd4>
   189a4:	dd012417 	ldw	r20,1168(sp)
   189a8:	003f6d06 	br	18760 <___vfprintf_internal_r+0x1b9c>
   189ac:	00c00044 	movi	r3,1
   189b0:	d8c12815 	stw	r3,1184(sp)
   189b4:	d8c12b15 	stw	r3,1196(sp)
   189b8:	003e6c06 	br	1836c <___vfprintf_internal_r+0x17a8>

000189bc <__vfprintf_internal>:
   189bc:	008000f4 	movhi	r2,3
   189c0:	108d2b04 	addi	r2,r2,13484
   189c4:	2007883a 	mov	r3,r4
   189c8:	11000017 	ldw	r4,0(r2)
   189cc:	2805883a 	mov	r2,r5
   189d0:	300f883a 	mov	r7,r6
   189d4:	180b883a 	mov	r5,r3
   189d8:	100d883a 	mov	r6,r2
   189dc:	0016bc41 	jmpi	16bc4 <___vfprintf_internal_r>

000189e0 <__swbuf_r>:
   189e0:	defffc04 	addi	sp,sp,-16
   189e4:	dc800215 	stw	r18,8(sp)
   189e8:	dc400115 	stw	r17,4(sp)
   189ec:	dc000015 	stw	r16,0(sp)
   189f0:	dfc00315 	stw	ra,12(sp)
   189f4:	2023883a 	mov	r17,r4
   189f8:	2825883a 	mov	r18,r5
   189fc:	3021883a 	mov	r16,r6
   18a00:	20000226 	beq	r4,zero,18a0c <__swbuf_r+0x2c>
   18a04:	20800e17 	ldw	r2,56(r4)
   18a08:	10003b26 	beq	r2,zero,18af8 <__swbuf_r+0x118>
   18a0c:	8080030b 	ldhu	r2,12(r16)
   18a10:	80c00617 	ldw	r3,24(r16)
   18a14:	1080020c 	andi	r2,r2,8
   18a18:	10bfffcc 	andi	r2,r2,65535
   18a1c:	10a0001c 	xori	r2,r2,32768
   18a20:	80c00215 	stw	r3,8(r16)
   18a24:	10a00004 	addi	r2,r2,-32768
   18a28:	10002226 	beq	r2,zero,18ab4 <__swbuf_r+0xd4>
   18a2c:	80800417 	ldw	r2,16(r16)
   18a30:	10002026 	beq	r2,zero,18ab4 <__swbuf_r+0xd4>
   18a34:	80c00017 	ldw	r3,0(r16)
   18a38:	81000517 	ldw	r4,20(r16)
   18a3c:	94803fcc 	andi	r18,r18,255
   18a40:	1885c83a 	sub	r2,r3,r2
   18a44:	1100250e 	bge	r2,r4,18adc <__swbuf_r+0xfc>
   18a48:	10800044 	addi	r2,r2,1
   18a4c:	81400217 	ldw	r5,8(r16)
   18a50:	19000044 	addi	r4,r3,1
   18a54:	297fffc4 	addi	r5,r5,-1
   18a58:	81400215 	stw	r5,8(r16)
   18a5c:	1c800005 	stb	r18,0(r3)
   18a60:	80c00517 	ldw	r3,20(r16)
   18a64:	81000015 	stw	r4,0(r16)
   18a68:	18800c26 	beq	r3,r2,18a9c <__swbuf_r+0xbc>
   18a6c:	8080030b 	ldhu	r2,12(r16)
   18a70:	1080004c 	andi	r2,r2,1
   18a74:	10000226 	beq	r2,zero,18a80 <__swbuf_r+0xa0>
   18a78:	00800284 	movi	r2,10
   18a7c:	90800726 	beq	r18,r2,18a9c <__swbuf_r+0xbc>
   18a80:	9005883a 	mov	r2,r18
   18a84:	dfc00317 	ldw	ra,12(sp)
   18a88:	dc800217 	ldw	r18,8(sp)
   18a8c:	dc400117 	ldw	r17,4(sp)
   18a90:	dc000017 	ldw	r16,0(sp)
   18a94:	dec00404 	addi	sp,sp,16
   18a98:	f800283a 	ret
   18a9c:	8809883a 	mov	r4,r17
   18aa0:	800b883a 	mov	r5,r16
   18aa4:	001a4d00 	call	1a4d0 <_fflush_r>
   18aa8:	103ff526 	beq	r2,zero,18a80 <__swbuf_r+0xa0>
   18aac:	04bfffc4 	movi	r18,-1
   18ab0:	003ff306 	br	18a80 <__swbuf_r+0xa0>
   18ab4:	8809883a 	mov	r4,r17
   18ab8:	800b883a 	mov	r5,r16
   18abc:	0018b380 	call	18b38 <__swsetup_r>
   18ac0:	10000f1e 	bne	r2,zero,18b00 <__swbuf_r+0x120>
   18ac4:	80800417 	ldw	r2,16(r16)
   18ac8:	80c00017 	ldw	r3,0(r16)
   18acc:	81000517 	ldw	r4,20(r16)
   18ad0:	94803fcc 	andi	r18,r18,255
   18ad4:	1885c83a 	sub	r2,r3,r2
   18ad8:	113fdb16 	blt	r2,r4,18a48 <__swbuf_r+0x68>
   18adc:	8809883a 	mov	r4,r17
   18ae0:	800b883a 	mov	r5,r16
   18ae4:	001a4d00 	call	1a4d0 <_fflush_r>
   18ae8:	103ff01e 	bne	r2,zero,18aac <__swbuf_r+0xcc>
   18aec:	80c00017 	ldw	r3,0(r16)
   18af0:	00800044 	movi	r2,1
   18af4:	003fd506 	br	18a4c <__swbuf_r+0x6c>
   18af8:	001a7780 	call	1a778 <__sinit>
   18afc:	003fc306 	br	18a0c <__swbuf_r+0x2c>
   18b00:	8080030b 	ldhu	r2,12(r16)
   18b04:	04bfffc4 	movi	r18,-1
   18b08:	10801014 	ori	r2,r2,64
   18b0c:	8080030d 	sth	r2,12(r16)
   18b10:	00800244 	movi	r2,9
   18b14:	88800015 	stw	r2,0(r17)
   18b18:	003fd906 	br	18a80 <__swbuf_r+0xa0>

00018b1c <__swbuf>:
   18b1c:	00c000f4 	movhi	r3,3
   18b20:	18cd2b04 	addi	r3,r3,13484
   18b24:	2005883a 	mov	r2,r4
   18b28:	19000017 	ldw	r4,0(r3)
   18b2c:	280d883a 	mov	r6,r5
   18b30:	100b883a 	mov	r5,r2
   18b34:	00189e01 	jmpi	189e0 <__swbuf_r>

00018b38 <__swsetup_r>:
   18b38:	008000f4 	movhi	r2,3
   18b3c:	108d2b04 	addi	r2,r2,13484
   18b40:	10800017 	ldw	r2,0(r2)
   18b44:	defffd04 	addi	sp,sp,-12
   18b48:	dc400115 	stw	r17,4(sp)
   18b4c:	dc000015 	stw	r16,0(sp)
   18b50:	dfc00215 	stw	ra,8(sp)
   18b54:	2023883a 	mov	r17,r4
   18b58:	2821883a 	mov	r16,r5
   18b5c:	10000226 	beq	r2,zero,18b68 <__swsetup_r+0x30>
   18b60:	10c00e17 	ldw	r3,56(r2)
   18b64:	18003d26 	beq	r3,zero,18c5c <__swsetup_r+0x124>
   18b68:	8080030b 	ldhu	r2,12(r16)
   18b6c:	10c0020c 	andi	r3,r2,8
   18b70:	18ffffcc 	andi	r3,r3,65535
   18b74:	18e0001c 	xori	r3,r3,32768
   18b78:	18e00004 	addi	r3,r3,-32768
   18b7c:	18001226 	beq	r3,zero,18bc8 <__swsetup_r+0x90>
   18b80:	80c00417 	ldw	r3,16(r16)
   18b84:	18001f26 	beq	r3,zero,18c04 <__swsetup_r+0xcc>
   18b88:	1100004c 	andi	r4,r2,1
   18b8c:	2000261e 	bne	r4,zero,18c28 <__swsetup_r+0xf0>
   18b90:	1080008c 	andi	r2,r2,2
   18b94:	10bfffcc 	andi	r2,r2,65535
   18b98:	10a0001c 	xori	r2,r2,32768
   18b9c:	10a00004 	addi	r2,r2,-32768
   18ba0:	1000311e 	bne	r2,zero,18c68 <__swsetup_r+0x130>
   18ba4:	80800517 	ldw	r2,20(r16)
   18ba8:	80800215 	stw	r2,8(r16)
   18bac:	18002326 	beq	r3,zero,18c3c <__swsetup_r+0x104>
   18bb0:	0005883a 	mov	r2,zero
   18bb4:	dfc00217 	ldw	ra,8(sp)
   18bb8:	dc400117 	ldw	r17,4(sp)
   18bbc:	dc000017 	ldw	r16,0(sp)
   18bc0:	dec00304 	addi	sp,sp,12
   18bc4:	f800283a 	ret
   18bc8:	10c0040c 	andi	r3,r2,16
   18bcc:	18ffffcc 	andi	r3,r3,65535
   18bd0:	18e0001c 	xori	r3,r3,32768
   18bd4:	18e00004 	addi	r3,r3,-32768
   18bd8:	18001e26 	beq	r3,zero,18c54 <__swsetup_r+0x11c>
   18bdc:	10c0010c 	andi	r3,r2,4
   18be0:	18ffffcc 	andi	r3,r3,65535
   18be4:	18e0001c 	xori	r3,r3,32768
   18be8:	18e00004 	addi	r3,r3,-32768
   18bec:	1800211e 	bne	r3,zero,18c74 <__swsetup_r+0x13c>
   18bf0:	80c00417 	ldw	r3,16(r16)
   18bf4:	11400214 	ori	r5,r2,8
   18bf8:	8140030d 	sth	r5,12(r16)
   18bfc:	2805883a 	mov	r2,r5
   18c00:	183fe11e 	bne	r3,zero,18b88 <__swsetup_r+0x50>
   18c04:	1140a00c 	andi	r5,r2,640
   18c08:	01008004 	movi	r4,512
   18c0c:	293fde26 	beq	r5,r4,18b88 <__swsetup_r+0x50>
   18c10:	8809883a 	mov	r4,r17
   18c14:	800b883a 	mov	r5,r16
   18c18:	001b4ec0 	call	1b4ec <__smakebuf_r>
   18c1c:	8080030b 	ldhu	r2,12(r16)
   18c20:	80c00417 	ldw	r3,16(r16)
   18c24:	003fd806 	br	18b88 <__swsetup_r+0x50>
   18c28:	80800517 	ldw	r2,20(r16)
   18c2c:	80000215 	stw	zero,8(r16)
   18c30:	0085c83a 	sub	r2,zero,r2
   18c34:	80800615 	stw	r2,24(r16)
   18c38:	183fdd1e 	bne	r3,zero,18bb0 <__swsetup_r+0x78>
   18c3c:	8080030b 	ldhu	r2,12(r16)
   18c40:	1080200c 	andi	r2,r2,128
   18c44:	10bfffcc 	andi	r2,r2,65535
   18c48:	10a0001c 	xori	r2,r2,32768
   18c4c:	10a00004 	addi	r2,r2,-32768
   18c50:	103fd826 	beq	r2,zero,18bb4 <__swsetup_r+0x7c>
   18c54:	00bfffc4 	movi	r2,-1
   18c58:	003fd606 	br	18bb4 <__swsetup_r+0x7c>
   18c5c:	1009883a 	mov	r4,r2
   18c60:	001a7780 	call	1a778 <__sinit>
   18c64:	003fc006 	br	18b68 <__swsetup_r+0x30>
   18c68:	0005883a 	mov	r2,zero
   18c6c:	80800215 	stw	r2,8(r16)
   18c70:	003fce06 	br	18bac <__swsetup_r+0x74>
   18c74:	81400c17 	ldw	r5,48(r16)
   18c78:	28000626 	beq	r5,zero,18c94 <__swsetup_r+0x15c>
   18c7c:	80c01004 	addi	r3,r16,64
   18c80:	28c00326 	beq	r5,r3,18c90 <__swsetup_r+0x158>
   18c84:	8809883a 	mov	r4,r17
   18c88:	001aafc0 	call	1aafc <_free_r>
   18c8c:	8080030b 	ldhu	r2,12(r16)
   18c90:	80000c15 	stw	zero,48(r16)
   18c94:	80c00417 	ldw	r3,16(r16)
   18c98:	013ff6c4 	movi	r4,-37
   18c9c:	2084703a 	and	r2,r4,r2
   18ca0:	80000115 	stw	zero,4(r16)
   18ca4:	80c00015 	stw	r3,0(r16)
   18ca8:	003fd206 	br	18bf4 <__swsetup_r+0xbc>

00018cac <quorem>:
   18cac:	defff704 	addi	sp,sp,-36
   18cb0:	dc400115 	stw	r17,4(sp)
   18cb4:	20800417 	ldw	r2,16(r4)
   18cb8:	2c400417 	ldw	r17,16(r5)
   18cbc:	dd800615 	stw	r22,24(sp)
   18cc0:	dd400515 	stw	r21,20(sp)
   18cc4:	dfc00815 	stw	ra,32(sp)
   18cc8:	ddc00715 	stw	r23,28(sp)
   18ccc:	dd000415 	stw	r20,16(sp)
   18cd0:	dcc00315 	stw	r19,12(sp)
   18cd4:	dc800215 	stw	r18,8(sp)
   18cd8:	dc000015 	stw	r16,0(sp)
   18cdc:	202b883a 	mov	r21,r4
   18ce0:	282d883a 	mov	r22,r5
   18ce4:	14407116 	blt	r2,r17,18eac <quorem+0x200>
   18ce8:	88800104 	addi	r2,r17,4
   18cec:	1085883a 	add	r2,r2,r2
   18cf0:	1085883a 	add	r2,r2,r2
   18cf4:	28a7883a 	add	r19,r5,r2
   18cf8:	2085883a 	add	r2,r4,r2
   18cfc:	15c00017 	ldw	r23,0(r2)
   18d00:	99400017 	ldw	r5,0(r19)
   18d04:	8c7fffc4 	addi	r17,r17,-1
   18d08:	b809883a 	mov	r4,r23
   18d0c:	29400044 	addi	r5,r5,1
   18d10:	001f6180 	call	1f618 <__udivsi3>
   18d14:	1025883a 	mov	r18,r2
   18d18:	b4000504 	addi	r16,r22,20
   18d1c:	ad000504 	addi	r20,r21,20
   18d20:	10002d26 	beq	r2,zero,18dd8 <quorem+0x12c>
   18d24:	800d883a 	mov	r6,r16
   18d28:	a007883a 	mov	r3,r20
   18d2c:	000f883a 	mov	r7,zero
   18d30:	0005883a 	mov	r2,zero
   18d34:	32c00017 	ldw	r11,0(r6)
   18d38:	1a400017 	ldw	r9,0(r3)
   18d3c:	31800104 	addi	r6,r6,4
   18d40:	5abfffcc 	andi	r10,r11,65535
   18d44:	5495383a 	mul	r10,r10,r18
   18d48:	5816d43a 	srli	r11,r11,16
   18d4c:	4a3fffcc 	andi	r8,r9,65535
   18d50:	3a95883a 	add	r10,r7,r10
   18d54:	500ed43a 	srli	r7,r10,16
   18d58:	5c97383a 	mul	r11,r11,r18
   18d5c:	4085883a 	add	r2,r8,r2
   18d60:	52bfffcc 	andi	r10,r10,65535
   18d64:	1291c83a 	sub	r8,r2,r10
   18d68:	4804d43a 	srli	r2,r9,16
   18d6c:	3acf883a 	add	r7,r7,r11
   18d70:	4015d43a 	srai	r10,r8,16
   18d74:	393fffcc 	andi	r4,r7,65535
   18d78:	1105c83a 	sub	r2,r2,r4
   18d7c:	1285883a 	add	r2,r2,r10
   18d80:	1880008d 	sth	r2,2(r3)
   18d84:	1a00000d 	sth	r8,0(r3)
   18d88:	380ed43a 	srli	r7,r7,16
   18d8c:	1005d43a 	srai	r2,r2,16
   18d90:	18c00104 	addi	r3,r3,4
   18d94:	99bfe72e 	bgeu	r19,r6,18d34 <quorem+0x88>
   18d98:	b8000f1e 	bne	r23,zero,18dd8 <quorem+0x12c>
   18d9c:	88800144 	addi	r2,r17,5
   18da0:	1085883a 	add	r2,r2,r2
   18da4:	1085883a 	add	r2,r2,r2
   18da8:	a887883a 	add	r3,r21,r2
   18dac:	18bfff04 	addi	r2,r3,-4
   18db0:	a080082e 	bgeu	r20,r2,18dd4 <quorem+0x128>
   18db4:	18ffff17 	ldw	r3,-4(r3)
   18db8:	18000326 	beq	r3,zero,18dc8 <quorem+0x11c>
   18dbc:	00000506 	br	18dd4 <quorem+0x128>
   18dc0:	10c00017 	ldw	r3,0(r2)
   18dc4:	1800031e 	bne	r3,zero,18dd4 <quorem+0x128>
   18dc8:	10bfff04 	addi	r2,r2,-4
   18dcc:	8c7fffc4 	addi	r17,r17,-1
   18dd0:	a0bffb36 	bltu	r20,r2,18dc0 <quorem+0x114>
   18dd4:	ac400415 	stw	r17,16(r21)
   18dd8:	a809883a 	mov	r4,r21
   18ddc:	b00b883a 	mov	r5,r22
   18de0:	001c8dc0 	call	1c8dc <__mcmp>
   18de4:	10002516 	blt	r2,zero,18e7c <quorem+0x1d0>
   18de8:	94800044 	addi	r18,r18,1
   18dec:	a007883a 	mov	r3,r20
   18df0:	000b883a 	mov	r5,zero
   18df4:	1a000017 	ldw	r8,0(r3)
   18df8:	81c00017 	ldw	r7,0(r16)
   18dfc:	84000104 	addi	r16,r16,4
   18e00:	41bfffcc 	andi	r6,r8,65535
   18e04:	38bfffcc 	andi	r2,r7,65535
   18e08:	314b883a 	add	r5,r6,r5
   18e0c:	288dc83a 	sub	r6,r5,r2
   18e10:	380ed43a 	srli	r7,r7,16
   18e14:	400ad43a 	srli	r5,r8,16
   18e18:	3005d43a 	srai	r2,r6,16
   18e1c:	1980000d 	sth	r6,0(r3)
   18e20:	29cbc83a 	sub	r5,r5,r7
   18e24:	288b883a 	add	r5,r5,r2
   18e28:	1940008d 	sth	r5,2(r3)
   18e2c:	280bd43a 	srai	r5,r5,16
   18e30:	18c00104 	addi	r3,r3,4
   18e34:	9c3fef2e 	bgeu	r19,r16,18df4 <quorem+0x148>
   18e38:	88800144 	addi	r2,r17,5
   18e3c:	1085883a 	add	r2,r2,r2
   18e40:	1085883a 	add	r2,r2,r2
   18e44:	a885883a 	add	r2,r21,r2
   18e48:	10c00017 	ldw	r3,0(r2)
   18e4c:	18000b1e 	bne	r3,zero,18e7c <quorem+0x1d0>
   18e50:	10ffff04 	addi	r3,r2,-4
   18e54:	a0c0082e 	bgeu	r20,r3,18e78 <quorem+0x1cc>
   18e58:	10bfff17 	ldw	r2,-4(r2)
   18e5c:	10000326 	beq	r2,zero,18e6c <quorem+0x1c0>
   18e60:	00000506 	br	18e78 <quorem+0x1cc>
   18e64:	18800017 	ldw	r2,0(r3)
   18e68:	1000031e 	bne	r2,zero,18e78 <quorem+0x1cc>
   18e6c:	18ffff04 	addi	r3,r3,-4
   18e70:	8c7fffc4 	addi	r17,r17,-1
   18e74:	a0fffb36 	bltu	r20,r3,18e64 <quorem+0x1b8>
   18e78:	ac400415 	stw	r17,16(r21)
   18e7c:	9005883a 	mov	r2,r18
   18e80:	dfc00817 	ldw	ra,32(sp)
   18e84:	ddc00717 	ldw	r23,28(sp)
   18e88:	dd800617 	ldw	r22,24(sp)
   18e8c:	dd400517 	ldw	r21,20(sp)
   18e90:	dd000417 	ldw	r20,16(sp)
   18e94:	dcc00317 	ldw	r19,12(sp)
   18e98:	dc800217 	ldw	r18,8(sp)
   18e9c:	dc400117 	ldw	r17,4(sp)
   18ea0:	dc000017 	ldw	r16,0(sp)
   18ea4:	dec00904 	addi	sp,sp,36
   18ea8:	f800283a 	ret
   18eac:	0005883a 	mov	r2,zero
   18eb0:	003ff306 	br	18e80 <quorem+0x1d4>

00018eb4 <_dtoa_r>:
   18eb4:	20801017 	ldw	r2,64(r4)
   18eb8:	deffdf04 	addi	sp,sp,-132
   18ebc:	dcc01a15 	stw	r19,104(sp)
   18ec0:	dc801915 	stw	r18,100(sp)
   18ec4:	dc401815 	stw	r17,96(sp)
   18ec8:	dc001715 	stw	r16,92(sp)
   18ecc:	dfc02015 	stw	ra,128(sp)
   18ed0:	df001f15 	stw	fp,124(sp)
   18ed4:	ddc01e15 	stw	r23,120(sp)
   18ed8:	dd801d15 	stw	r22,116(sp)
   18edc:	dd401c15 	stw	r21,112(sp)
   18ee0:	dd001b15 	stw	r20,108(sp)
   18ee4:	d9400315 	stw	r5,12(sp)
   18ee8:	d9c00415 	stw	r7,16(sp)
   18eec:	2021883a 	mov	r16,r4
   18ef0:	3025883a 	mov	r18,r6
   18ef4:	dcc02317 	ldw	r19,140(sp)
   18ef8:	3023883a 	mov	r17,r6
   18efc:	10000826 	beq	r2,zero,18f20 <_dtoa_r+0x6c>
   18f00:	20c01117 	ldw	r3,68(r4)
   18f04:	01800044 	movi	r6,1
   18f08:	100b883a 	mov	r5,r2
   18f0c:	30cc983a 	sll	r6,r6,r3
   18f10:	10c00115 	stw	r3,4(r2)
   18f14:	11800215 	stw	r6,8(r2)
   18f18:	001c0e00 	call	1c0e0 <_Bfree>
   18f1c:	80001015 	stw	zero,64(r16)
   18f20:	90002f16 	blt	r18,zero,18fe0 <_dtoa_r+0x12c>
   18f24:	98000015 	stw	zero,0(r19)
   18f28:	90dffc2c 	andhi	r3,r18,32752
   18f2c:	009ffc34 	movhi	r2,32752
   18f30:	18801c26 	beq	r3,r2,18fa4 <_dtoa_r+0xf0>
   18f34:	d9000317 	ldw	r4,12(sp)
   18f38:	880b883a 	mov	r5,r17
   18f3c:	000d883a 	mov	r6,zero
   18f40:	000f883a 	mov	r7,zero
   18f44:	001f0580 	call	1f058 <__eqdf2>
   18f48:	10002c1e 	bne	r2,zero,18ffc <_dtoa_r+0x148>
   18f4c:	d9002217 	ldw	r4,136(sp)
   18f50:	d9c02417 	ldw	r7,144(sp)
   18f54:	00800044 	movi	r2,1
   18f58:	20800015 	stw	r2,0(r4)
   18f5c:	38019426 	beq	r7,zero,195b0 <_dtoa_r+0x6fc>
   18f60:	008000f4 	movhi	r2,3
   18f64:	10bc1b44 	addi	r2,r2,-3987
   18f68:	38800015 	stw	r2,0(r7)
   18f6c:	15ffffc4 	addi	r23,r2,-1
   18f70:	b805883a 	mov	r2,r23
   18f74:	dfc02017 	ldw	ra,128(sp)
   18f78:	df001f17 	ldw	fp,124(sp)
   18f7c:	ddc01e17 	ldw	r23,120(sp)
   18f80:	dd801d17 	ldw	r22,116(sp)
   18f84:	dd401c17 	ldw	r21,112(sp)
   18f88:	dd001b17 	ldw	r20,108(sp)
   18f8c:	dcc01a17 	ldw	r19,104(sp)
   18f90:	dc801917 	ldw	r18,100(sp)
   18f94:	dc401817 	ldw	r17,96(sp)
   18f98:	dc001717 	ldw	r16,92(sp)
   18f9c:	dec02104 	addi	sp,sp,132
   18fa0:	f800283a 	ret
   18fa4:	d8c02217 	ldw	r3,136(sp)
   18fa8:	d9000317 	ldw	r4,12(sp)
   18fac:	0089c3c4 	movi	r2,9999
   18fb0:	18800015 	stw	r2,0(r3)
   18fb4:	20016c26 	beq	r4,zero,19568 <_dtoa_r+0x6b4>
   18fb8:	05c000f4 	movhi	r23,3
   18fbc:	bdfc2704 	addi	r23,r23,-3940
   18fc0:	d9c02417 	ldw	r7,144(sp)
   18fc4:	383fea26 	beq	r7,zero,18f70 <_dtoa_r+0xbc>
   18fc8:	b88000c7 	ldb	r2,3(r23)
   18fcc:	10016d1e 	bne	r2,zero,19584 <_dtoa_r+0x6d0>
   18fd0:	b88000c4 	addi	r2,r23,3
   18fd4:	d8c02417 	ldw	r3,144(sp)
   18fd8:	18800015 	stw	r2,0(r3)
   18fdc:	003fe406 	br	18f70 <_dtoa_r+0xbc>
   18fe0:	04600034 	movhi	r17,32768
   18fe4:	8c7fffc4 	addi	r17,r17,-1
   18fe8:	9462703a 	and	r17,r18,r17
   18fec:	00800044 	movi	r2,1
   18ff0:	98800015 	stw	r2,0(r19)
   18ff4:	8825883a 	mov	r18,r17
   18ff8:	003fcb06 	br	18f28 <_dtoa_r+0x74>
   18ffc:	d9400317 	ldw	r5,12(sp)
   19000:	9028d53a 	srli	r20,r18,20
   19004:	d8800204 	addi	r2,sp,8
   19008:	d8800015 	stw	r2,0(sp)
   1900c:	8009883a 	mov	r4,r16
   19010:	880d883a 	mov	r6,r17
   19014:	d9c00104 	addi	r7,sp,4
   19018:	001cc840 	call	1cc84 <__d2b>
   1901c:	a501ffcc 	andi	r20,r20,2047
   19020:	1039883a 	mov	fp,r2
   19024:	a001591e 	bne	r20,zero,1958c <_dtoa_r+0x6d8>
   19028:	dd400217 	ldw	r21,8(sp)
   1902c:	dd000117 	ldw	r20,4(sp)
   19030:	00befbc4 	movi	r2,-1041
   19034:	ad29883a 	add	r20,r21,r20
   19038:	a082d216 	blt	r20,r2,19b84 <_dtoa_r+0xcd0>
   1903c:	d8c00317 	ldw	r3,12(sp)
   19040:	013f0384 	movi	r4,-1010
   19044:	2509c83a 	sub	r4,r4,r20
   19048:	a0810484 	addi	r2,r20,1042
   1904c:	9124983a 	sll	r18,r18,r4
   19050:	1884d83a 	srl	r2,r3,r2
   19054:	9088b03a 	or	r4,r18,r2
   19058:	001f3dc0 	call	1f3dc <__floatunsidf>
   1905c:	1009883a 	mov	r4,r2
   19060:	017f8434 	movhi	r5,65040
   19064:	00800044 	movi	r2,1
   19068:	194b883a 	add	r5,r3,r5
   1906c:	a53fffc4 	addi	r20,r20,-1
   19070:	d8800f15 	stw	r2,60(sp)
   19074:	000d883a 	mov	r6,zero
   19078:	01cffe34 	movhi	r7,16376
   1907c:	001eb600 	call	1eb60 <__subdf3>
   19080:	1009883a 	mov	r4,r2
   19084:	180b883a 	mov	r5,r3
   19088:	0198dbf4 	movhi	r6,25455
   1908c:	3190d844 	addi	r6,r6,17249
   19090:	01cff4f4 	movhi	r7,16339
   19094:	39e1e9c4 	addi	r7,r7,-30809
   19098:	001ebc00 	call	1ebc0 <__muldf3>
   1909c:	180b883a 	mov	r5,r3
   190a0:	01a2d874 	movhi	r6,35681
   190a4:	31b22cc4 	addi	r6,r6,-14157
   190a8:	01cff1f4 	movhi	r7,16327
   190ac:	39e28a04 	addi	r7,r7,-30168
   190b0:	1009883a 	mov	r4,r2
   190b4:	001eb0c0 	call	1eb0c <__adddf3>
   190b8:	a009883a 	mov	r4,r20
   190bc:	1027883a 	mov	r19,r2
   190c0:	1825883a 	mov	r18,r3
   190c4:	001f2340 	call	1f234 <__floatsidf>
   190c8:	1009883a 	mov	r4,r2
   190cc:	180b883a 	mov	r5,r3
   190d0:	019427f4 	movhi	r6,20639
   190d4:	319e7ec4 	addi	r6,r6,31227
   190d8:	01cff4f4 	movhi	r7,16339
   190dc:	39d104c4 	addi	r7,r7,17427
   190e0:	001ebc00 	call	1ebc0 <__muldf3>
   190e4:	9809883a 	mov	r4,r19
   190e8:	900b883a 	mov	r5,r18
   190ec:	100d883a 	mov	r6,r2
   190f0:	180f883a 	mov	r7,r3
   190f4:	001eb0c0 	call	1eb0c <__adddf3>
   190f8:	1009883a 	mov	r4,r2
   190fc:	180b883a 	mov	r5,r3
   19100:	1027883a 	mov	r19,r2
   19104:	1825883a 	mov	r18,r3
   19108:	001f3080 	call	1f308 <__fixdfsi>
   1910c:	9809883a 	mov	r4,r19
   19110:	900b883a 	mov	r5,r18
   19114:	000d883a 	mov	r6,zero
   19118:	000f883a 	mov	r7,zero
   1911c:	d8800615 	stw	r2,24(sp)
   19120:	001f1d80 	call	1f1d8 <__ltdf2>
   19124:	10027e16 	blt	r2,zero,19b20 <_dtoa_r+0xc6c>
   19128:	d8c00617 	ldw	r3,24(sp)
   1912c:	00800584 	movi	r2,22
   19130:	10c26c36 	bltu	r2,r3,19ae4 <_dtoa_r+0xc30>
   19134:	180490fa 	slli	r2,r3,3
   19138:	00c000f4 	movhi	r3,3
   1913c:	18fc4c04 	addi	r3,r3,-3792
   19140:	d9800317 	ldw	r6,12(sp)
   19144:	1885883a 	add	r2,r3,r2
   19148:	11000017 	ldw	r4,0(r2)
   1914c:	11400117 	ldw	r5,4(r2)
   19150:	880f883a 	mov	r7,r17
   19154:	001f1100 	call	1f110 <__gtdf2>
   19158:	00828f0e 	bge	zero,r2,19b98 <_dtoa_r+0xce4>
   1915c:	d8800617 	ldw	r2,24(sp)
   19160:	d8000d15 	stw	zero,52(sp)
   19164:	10bfffc4 	addi	r2,r2,-1
   19168:	d8800615 	stw	r2,24(sp)
   1916c:	ad29c83a 	sub	r20,r21,r20
   19170:	a53fffc4 	addi	r20,r20,-1
   19174:	a0026616 	blt	r20,zero,19b10 <_dtoa_r+0xc5c>
   19178:	dd000715 	stw	r20,28(sp)
   1917c:	d8000815 	stw	zero,32(sp)
   19180:	d8800617 	ldw	r2,24(sp)
   19184:	10025a16 	blt	r2,zero,19af0 <_dtoa_r+0xc3c>
   19188:	d8c00717 	ldw	r3,28(sp)
   1918c:	d8800b15 	stw	r2,44(sp)
   19190:	d8000a15 	stw	zero,40(sp)
   19194:	1887883a 	add	r3,r3,r2
   19198:	d8c00715 	stw	r3,28(sp)
   1919c:	d9c00417 	ldw	r7,16(sp)
   191a0:	00800244 	movi	r2,9
   191a4:	11c10536 	bltu	r2,r7,195bc <_dtoa_r+0x708>
   191a8:	00800144 	movi	r2,5
   191ac:	11c4c60e 	bge	r2,r7,1a4c8 <_dtoa_r+0x1614>
   191b0:	39ffff04 	addi	r7,r7,-4
   191b4:	d9c00415 	stw	r7,16(sp)
   191b8:	0027883a 	mov	r19,zero
   191bc:	d9c00417 	ldw	r7,16(sp)
   191c0:	008000c4 	movi	r2,3
   191c4:	3883a226 	beq	r7,r2,1a050 <_dtoa_r+0x119c>
   191c8:	11c2bc16 	blt	r2,r7,19cbc <_dtoa_r+0xe08>
   191cc:	00800084 	movi	r2,2
   191d0:	3880fb1e 	bne	r7,r2,195c0 <_dtoa_r+0x70c>
   191d4:	d8000c15 	stw	zero,48(sp)
   191d8:	d9002117 	ldw	r4,132(sp)
   191dc:	0103ae0e 	bge	zero,r4,1a098 <_dtoa_r+0x11e4>
   191e0:	2025883a 	mov	r18,r4
   191e4:	d9000e15 	stw	r4,56(sp)
   191e8:	d9000915 	stw	r4,36(sp)
   191ec:	80001115 	stw	zero,68(r16)
   191f0:	008005c4 	movi	r2,23
   191f4:	1484b22e 	bgeu	r2,r18,1a4c0 <_dtoa_r+0x160c>
   191f8:	00c00044 	movi	r3,1
   191fc:	00800104 	movi	r2,4
   19200:	1085883a 	add	r2,r2,r2
   19204:	11000504 	addi	r4,r2,20
   19208:	180b883a 	mov	r5,r3
   1920c:	18c00044 	addi	r3,r3,1
   19210:	913ffb2e 	bgeu	r18,r4,19200 <_dtoa_r+0x34c>
   19214:	81401115 	stw	r5,68(r16)
   19218:	8009883a 	mov	r4,r16
   1921c:	001c0380 	call	1c038 <_Balloc>
   19220:	102f883a 	mov	r23,r2
   19224:	80801015 	stw	r2,64(r16)
   19228:	00800384 	movi	r2,14
   1922c:	1480f036 	bltu	r2,r18,195f0 <_dtoa_r+0x73c>
   19230:	9800ef26 	beq	r19,zero,195f0 <_dtoa_r+0x73c>
   19234:	d8800617 	ldw	r2,24(sp)
   19238:	00839c0e 	bge	zero,r2,1a0ac <_dtoa_r+0x11f8>
   1923c:	d8c00617 	ldw	r3,24(sp)
   19240:	108003cc 	andi	r2,r2,15
   19244:	100490fa 	slli	r2,r2,3
   19248:	182bd13a 	srai	r21,r3,4
   1924c:	00c000f4 	movhi	r3,3
   19250:	18fc4c04 	addi	r3,r3,-3792
   19254:	1885883a 	add	r2,r3,r2
   19258:	a8c0040c 	andi	r3,r21,16
   1925c:	12800017 	ldw	r10,0(r2)
   19260:	15800117 	ldw	r22,4(r2)
   19264:	18038726 	beq	r3,zero,1a084 <_dtoa_r+0x11d0>
   19268:	008000f4 	movhi	r2,3
   1926c:	10bc4204 	addi	r2,r2,-3832
   19270:	11800817 	ldw	r6,32(r2)
   19274:	11c00917 	ldw	r7,36(r2)
   19278:	d9000317 	ldw	r4,12(sp)
   1927c:	880b883a 	mov	r5,r17
   19280:	da801515 	stw	r10,84(sp)
   19284:	001eea40 	call	1eea4 <__divdf3>
   19288:	da801517 	ldw	r10,84(sp)
   1928c:	d8801015 	stw	r2,64(sp)
   19290:	1829883a 	mov	r20,r3
   19294:	ad4003cc 	andi	r21,r21,15
   19298:	048000c4 	movi	r18,3
   1929c:	a8001126 	beq	r21,zero,192e4 <_dtoa_r+0x430>
   192a0:	04c000f4 	movhi	r19,3
   192a4:	9cfc4204 	addi	r19,r19,-3832
   192a8:	5005883a 	mov	r2,r10
   192ac:	b007883a 	mov	r3,r22
   192b0:	a980004c 	andi	r6,r21,1
   192b4:	1009883a 	mov	r4,r2
   192b8:	a82bd07a 	srai	r21,r21,1
   192bc:	180b883a 	mov	r5,r3
   192c0:	30000426 	beq	r6,zero,192d4 <_dtoa_r+0x420>
   192c4:	99800017 	ldw	r6,0(r19)
   192c8:	99c00117 	ldw	r7,4(r19)
   192cc:	94800044 	addi	r18,r18,1
   192d0:	001ebc00 	call	1ebc0 <__muldf3>
   192d4:	9cc00204 	addi	r19,r19,8
   192d8:	a83ff51e 	bne	r21,zero,192b0 <_dtoa_r+0x3fc>
   192dc:	1015883a 	mov	r10,r2
   192e0:	182d883a 	mov	r22,r3
   192e4:	d9001017 	ldw	r4,64(sp)
   192e8:	a00b883a 	mov	r5,r20
   192ec:	500d883a 	mov	r6,r10
   192f0:	b00f883a 	mov	r7,r22
   192f4:	001eea40 	call	1eea4 <__divdf3>
   192f8:	1027883a 	mov	r19,r2
   192fc:	1829883a 	mov	r20,r3
   19300:	d8c00d17 	ldw	r3,52(sp)
   19304:	18000626 	beq	r3,zero,19320 <_dtoa_r+0x46c>
   19308:	9809883a 	mov	r4,r19
   1930c:	a00b883a 	mov	r5,r20
   19310:	000d883a 	mov	r6,zero
   19314:	01cffc34 	movhi	r7,16368
   19318:	001f1d80 	call	1f1d8 <__ltdf2>
   1931c:	10040e16 	blt	r2,zero,1a358 <_dtoa_r+0x14a4>
   19320:	9009883a 	mov	r4,r18
   19324:	001f2340 	call	1f234 <__floatsidf>
   19328:	1009883a 	mov	r4,r2
   1932c:	180b883a 	mov	r5,r3
   19330:	980d883a 	mov	r6,r19
   19334:	a00f883a 	mov	r7,r20
   19338:	001ebc00 	call	1ebc0 <__muldf3>
   1933c:	1009883a 	mov	r4,r2
   19340:	180b883a 	mov	r5,r3
   19344:	000d883a 	mov	r6,zero
   19348:	01d00734 	movhi	r7,16412
   1934c:	001eb0c0 	call	1eb0c <__adddf3>
   19350:	057f3034 	movhi	r21,64704
   19354:	1d6b883a 	add	r21,r3,r21
   19358:	d8c00917 	ldw	r3,36(sp)
   1935c:	1025883a 	mov	r18,r2
   19360:	18031f26 	beq	r3,zero,19fe0 <_dtoa_r+0x112c>
   19364:	d8800617 	ldw	r2,24(sp)
   19368:	dac00917 	ldw	r11,36(sp)
   1936c:	d8801315 	stw	r2,76(sp)
   19370:	d8c00c17 	ldw	r3,48(sp)
   19374:	18039026 	beq	r3,zero,1a1b8 <_dtoa_r+0x1304>
   19378:	58bfffc4 	addi	r2,r11,-1
   1937c:	100490fa 	slli	r2,r2,3
   19380:	00c000f4 	movhi	r3,3
   19384:	18fc4c04 	addi	r3,r3,-3792
   19388:	0009883a 	mov	r4,zero
   1938c:	1885883a 	add	r2,r3,r2
   19390:	11800017 	ldw	r6,0(r2)
   19394:	11c00117 	ldw	r7,4(r2)
   19398:	014ff834 	movhi	r5,16352
   1939c:	dac01615 	stw	r11,88(sp)
   193a0:	001eea40 	call	1eea4 <__divdf3>
   193a4:	900d883a 	mov	r6,r18
   193a8:	a80f883a 	mov	r7,r21
   193ac:	1009883a 	mov	r4,r2
   193b0:	180b883a 	mov	r5,r3
   193b4:	001eb600 	call	1eb60 <__subdf3>
   193b8:	a00b883a 	mov	r5,r20
   193bc:	9809883a 	mov	r4,r19
   193c0:	182b883a 	mov	r21,r3
   193c4:	d8801015 	stw	r2,64(sp)
   193c8:	001f3080 	call	1f308 <__fixdfsi>
   193cc:	1009883a 	mov	r4,r2
   193d0:	d8801515 	stw	r2,84(sp)
   193d4:	001f2340 	call	1f234 <__floatsidf>
   193d8:	9809883a 	mov	r4,r19
   193dc:	a00b883a 	mov	r5,r20
   193e0:	100d883a 	mov	r6,r2
   193e4:	180f883a 	mov	r7,r3
   193e8:	001eb600 	call	1eb60 <__subdf3>
   193ec:	da401517 	ldw	r9,84(sp)
   193f0:	d9001017 	ldw	r4,64(sp)
   193f4:	a80b883a 	mov	r5,r21
   193f8:	4d000c04 	addi	r20,r9,48
   193fc:	bd000005 	stb	r20,0(r23)
   19400:	100d883a 	mov	r6,r2
   19404:	180f883a 	mov	r7,r3
   19408:	bd800044 	addi	r22,r23,1
   1940c:	1025883a 	mov	r18,r2
   19410:	1827883a 	mov	r19,r3
   19414:	001f1100 	call	1f110 <__gtdf2>
   19418:	00842216 	blt	zero,r2,1a4a4 <_dtoa_r+0x15f0>
   1941c:	0009883a 	mov	r4,zero
   19420:	014ffc34 	movhi	r5,16368
   19424:	900d883a 	mov	r6,r18
   19428:	980f883a 	mov	r7,r19
   1942c:	001eb600 	call	1eb60 <__subdf3>
   19430:	d9001017 	ldw	r4,64(sp)
   19434:	a80b883a 	mov	r5,r21
   19438:	100d883a 	mov	r6,r2
   1943c:	180f883a 	mov	r7,r3
   19440:	001f1100 	call	1f110 <__gtdf2>
   19444:	dac01617 	ldw	r11,88(sp)
   19448:	00841316 	blt	zero,r2,1a498 <_dtoa_r+0x15e4>
   1944c:	00800044 	movi	r2,1
   19450:	12c0670e 	bge	r2,r11,195f0 <_dtoa_r+0x73c>
   19454:	bad7883a 	add	r11,r23,r11
   19458:	df001115 	stw	fp,68(sp)
   1945c:	dc401215 	stw	r17,72(sp)
   19460:	5839883a 	mov	fp,r11
   19464:	dc401017 	ldw	r17,64(sp)
   19468:	00000806 	br	1948c <_dtoa_r+0x5d8>
   1946c:	001eb600 	call	1eb60 <__subdf3>
   19470:	1009883a 	mov	r4,r2
   19474:	180b883a 	mov	r5,r3
   19478:	880d883a 	mov	r6,r17
   1947c:	a80f883a 	mov	r7,r21
   19480:	001f1d80 	call	1f1d8 <__ltdf2>
   19484:	1003ee16 	blt	r2,zero,1a440 <_dtoa_r+0x158c>
   19488:	b703f126 	beq	r22,fp,1a450 <_dtoa_r+0x159c>
   1948c:	8809883a 	mov	r4,r17
   19490:	a80b883a 	mov	r5,r21
   19494:	000d883a 	mov	r6,zero
   19498:	01d00934 	movhi	r7,16420
   1949c:	001ebc00 	call	1ebc0 <__muldf3>
   194a0:	000d883a 	mov	r6,zero
   194a4:	01d00934 	movhi	r7,16420
   194a8:	9009883a 	mov	r4,r18
   194ac:	980b883a 	mov	r5,r19
   194b0:	1023883a 	mov	r17,r2
   194b4:	182b883a 	mov	r21,r3
   194b8:	001ebc00 	call	1ebc0 <__muldf3>
   194bc:	180b883a 	mov	r5,r3
   194c0:	1009883a 	mov	r4,r2
   194c4:	1825883a 	mov	r18,r3
   194c8:	1027883a 	mov	r19,r2
   194cc:	001f3080 	call	1f308 <__fixdfsi>
   194d0:	1009883a 	mov	r4,r2
   194d4:	1029883a 	mov	r20,r2
   194d8:	001f2340 	call	1f234 <__floatsidf>
   194dc:	9809883a 	mov	r4,r19
   194e0:	900b883a 	mov	r5,r18
   194e4:	100d883a 	mov	r6,r2
   194e8:	180f883a 	mov	r7,r3
   194ec:	001eb600 	call	1eb60 <__subdf3>
   194f0:	a5000c04 	addi	r20,r20,48
   194f4:	b5000005 	stb	r20,0(r22)
   194f8:	1009883a 	mov	r4,r2
   194fc:	180b883a 	mov	r5,r3
   19500:	880d883a 	mov	r6,r17
   19504:	a80f883a 	mov	r7,r21
   19508:	1025883a 	mov	r18,r2
   1950c:	1827883a 	mov	r19,r3
   19510:	001f1d80 	call	1f1d8 <__ltdf2>
   19514:	b5800044 	addi	r22,r22,1
   19518:	0009883a 	mov	r4,zero
   1951c:	014ffc34 	movhi	r5,16368
   19520:	900d883a 	mov	r6,r18
   19524:	980f883a 	mov	r7,r19
   19528:	103fd00e 	bge	r2,zero,1946c <_dtoa_r+0x5b8>
   1952c:	d9001317 	ldw	r4,76(sp)
   19530:	df001117 	ldw	fp,68(sp)
   19534:	d9000615 	stw	r4,24(sp)
   19538:	8009883a 	mov	r4,r16
   1953c:	e00b883a 	mov	r5,fp
   19540:	001c0e00 	call	1c0e0 <_Bfree>
   19544:	d9c00617 	ldw	r7,24(sp)
   19548:	d8c02217 	ldw	r3,136(sp)
   1954c:	d9002417 	ldw	r4,144(sp)
   19550:	b0000005 	stb	zero,0(r22)
   19554:	38800044 	addi	r2,r7,1
   19558:	18800015 	stw	r2,0(r3)
   1955c:	203e8426 	beq	r4,zero,18f70 <_dtoa_r+0xbc>
   19560:	25800015 	stw	r22,0(r4)
   19564:	003e8206 	br	18f70 <_dtoa_r+0xbc>
   19568:	00800434 	movhi	r2,16
   1956c:	10bfffc4 	addi	r2,r2,-1
   19570:	90a4703a 	and	r18,r18,r2
   19574:	903e901e 	bne	r18,zero,18fb8 <_dtoa_r+0x104>
   19578:	05c000f4 	movhi	r23,3
   1957c:	bdfc2404 	addi	r23,r23,-3952
   19580:	003e8f06 	br	18fc0 <_dtoa_r+0x10c>
   19584:	b8800204 	addi	r2,r23,8
   19588:	003e9206 	br	18fd4 <_dtoa_r+0x120>
   1958c:	01400434 	movhi	r5,16
   19590:	297fffc4 	addi	r5,r5,-1
   19594:	894a703a 	and	r5,r17,r5
   19598:	d9000317 	ldw	r4,12(sp)
   1959c:	294ffc34 	orhi	r5,r5,16368
   195a0:	a53f0044 	addi	r20,r20,-1023
   195a4:	dd400217 	ldw	r21,8(sp)
   195a8:	d8000f15 	stw	zero,60(sp)
   195ac:	003eb106 	br	19074 <_dtoa_r+0x1c0>
   195b0:	05c000f4 	movhi	r23,3
   195b4:	bdfc1b04 	addi	r23,r23,-3988
   195b8:	003e6d06 	br	18f70 <_dtoa_r+0xbc>
   195bc:	d8000415 	stw	zero,16(sp)
   195c0:	80001115 	stw	zero,68(r16)
   195c4:	8009883a 	mov	r4,r16
   195c8:	000b883a 	mov	r5,zero
   195cc:	001c0380 	call	1c038 <_Balloc>
   195d0:	01ffffc4 	movi	r7,-1
   195d4:	102f883a 	mov	r23,r2
   195d8:	80801015 	stw	r2,64(r16)
   195dc:	00800044 	movi	r2,1
   195e0:	d9c00915 	stw	r7,36(sp)
   195e4:	d8002115 	stw	zero,132(sp)
   195e8:	d9c00e15 	stw	r7,56(sp)
   195ec:	d8800c15 	stw	r2,48(sp)
   195f0:	d8800117 	ldw	r2,4(sp)
   195f4:	10008b16 	blt	r2,zero,19824 <_dtoa_r+0x970>
   195f8:	d9000617 	ldw	r4,24(sp)
   195fc:	00c00384 	movi	r3,14
   19600:	19008816 	blt	r3,r4,19824 <_dtoa_r+0x970>
   19604:	200490fa 	slli	r2,r4,3
   19608:	d9c02117 	ldw	r7,132(sp)
   1960c:	00c000f4 	movhi	r3,3
   19610:	18fc4c04 	addi	r3,r3,-3792
   19614:	1885883a 	add	r2,r3,r2
   19618:	14800017 	ldw	r18,0(r2)
   1961c:	14c00117 	ldw	r19,4(r2)
   19620:	3801c916 	blt	r7,zero,19d48 <_dtoa_r+0xe94>
   19624:	d9000317 	ldw	r4,12(sp)
   19628:	900d883a 	mov	r6,r18
   1962c:	980f883a 	mov	r7,r19
   19630:	880b883a 	mov	r5,r17
   19634:	001eea40 	call	1eea4 <__divdf3>
   19638:	180b883a 	mov	r5,r3
   1963c:	1009883a 	mov	r4,r2
   19640:	001f3080 	call	1f308 <__fixdfsi>
   19644:	1009883a 	mov	r4,r2
   19648:	102b883a 	mov	r21,r2
   1964c:	001f2340 	call	1f234 <__floatsidf>
   19650:	1009883a 	mov	r4,r2
   19654:	180b883a 	mov	r5,r3
   19658:	900d883a 	mov	r6,r18
   1965c:	980f883a 	mov	r7,r19
   19660:	001ebc00 	call	1ebc0 <__muldf3>
   19664:	d9000317 	ldw	r4,12(sp)
   19668:	880b883a 	mov	r5,r17
   1966c:	100d883a 	mov	r6,r2
   19670:	180f883a 	mov	r7,r3
   19674:	001eb600 	call	1eb60 <__subdf3>
   19678:	d9c00917 	ldw	r7,36(sp)
   1967c:	1009883a 	mov	r4,r2
   19680:	a8800c04 	addi	r2,r21,48
   19684:	b8800005 	stb	r2,0(r23)
   19688:	01800044 	movi	r6,1
   1968c:	180b883a 	mov	r5,r3
   19690:	2005883a 	mov	r2,r4
   19694:	bd800044 	addi	r22,r23,1
   19698:	39803726 	beq	r7,r6,19778 <_dtoa_r+0x8c4>
   1969c:	000d883a 	mov	r6,zero
   196a0:	01d00934 	movhi	r7,16420
   196a4:	001ebc00 	call	1ebc0 <__muldf3>
   196a8:	1009883a 	mov	r4,r2
   196ac:	180b883a 	mov	r5,r3
   196b0:	000d883a 	mov	r6,zero
   196b4:	000f883a 	mov	r7,zero
   196b8:	1029883a 	mov	r20,r2
   196bc:	1823883a 	mov	r17,r3
   196c0:	001f0580 	call	1f058 <__eqdf2>
   196c4:	103f9c26 	beq	r2,zero,19538 <_dtoa_r+0x684>
   196c8:	dd400917 	ldw	r21,36(sp)
   196cc:	dc000415 	stw	r16,16(sp)
   196d0:	00000906 	br	196f8 <_dtoa_r+0x844>
   196d4:	001ebc00 	call	1ebc0 <__muldf3>
   196d8:	1009883a 	mov	r4,r2
   196dc:	180b883a 	mov	r5,r3
   196e0:	000d883a 	mov	r6,zero
   196e4:	000f883a 	mov	r7,zero
   196e8:	1029883a 	mov	r20,r2
   196ec:	1823883a 	mov	r17,r3
   196f0:	001f0580 	call	1f058 <__eqdf2>
   196f4:	10022926 	beq	r2,zero,19f9c <_dtoa_r+0x10e8>
   196f8:	900d883a 	mov	r6,r18
   196fc:	980f883a 	mov	r7,r19
   19700:	a009883a 	mov	r4,r20
   19704:	880b883a 	mov	r5,r17
   19708:	001eea40 	call	1eea4 <__divdf3>
   1970c:	180b883a 	mov	r5,r3
   19710:	1009883a 	mov	r4,r2
   19714:	001f3080 	call	1f308 <__fixdfsi>
   19718:	1009883a 	mov	r4,r2
   1971c:	1021883a 	mov	r16,r2
   19720:	001f2340 	call	1f234 <__floatsidf>
   19724:	1009883a 	mov	r4,r2
   19728:	180b883a 	mov	r5,r3
   1972c:	900d883a 	mov	r6,r18
   19730:	980f883a 	mov	r7,r19
   19734:	001ebc00 	call	1ebc0 <__muldf3>
   19738:	a009883a 	mov	r4,r20
   1973c:	880b883a 	mov	r5,r17
   19740:	100d883a 	mov	r6,r2
   19744:	180f883a 	mov	r7,r3
   19748:	001eb600 	call	1eb60 <__subdf3>
   1974c:	82400c04 	addi	r9,r16,48
   19750:	b2400005 	stb	r9,0(r22)
   19754:	b5800044 	addi	r22,r22,1
   19758:	b5d3c83a 	sub	r9,r22,r23
   1975c:	000d883a 	mov	r6,zero
   19760:	01d00934 	movhi	r7,16420
   19764:	1009883a 	mov	r4,r2
   19768:	180b883a 	mov	r5,r3
   1976c:	aa7fd91e 	bne	r21,r9,196d4 <_dtoa_r+0x820>
   19770:	802b883a 	mov	r21,r16
   19774:	dc000417 	ldw	r16,16(sp)
   19778:	1009883a 	mov	r4,r2
   1977c:	180b883a 	mov	r5,r3
   19780:	100d883a 	mov	r6,r2
   19784:	180f883a 	mov	r7,r3
   19788:	001eb0c0 	call	1eb0c <__adddf3>
   1978c:	9009883a 	mov	r4,r18
   19790:	980b883a 	mov	r5,r19
   19794:	100d883a 	mov	r6,r2
   19798:	180f883a 	mov	r7,r3
   1979c:	1023883a 	mov	r17,r2
   197a0:	1829883a 	mov	r20,r3
   197a4:	001f1d80 	call	1f1d8 <__ltdf2>
   197a8:	10000816 	blt	r2,zero,197cc <_dtoa_r+0x918>
   197ac:	9009883a 	mov	r4,r18
   197b0:	980b883a 	mov	r5,r19
   197b4:	880d883a 	mov	r6,r17
   197b8:	a00f883a 	mov	r7,r20
   197bc:	001f0580 	call	1f058 <__eqdf2>
   197c0:	103f5d1e 	bne	r2,zero,19538 <_dtoa_r+0x684>
   197c4:	ad40004c 	andi	r21,r21,1
   197c8:	a83f5b26 	beq	r21,zero,19538 <_dtoa_r+0x684>
   197cc:	b53fffc3 	ldbu	r20,-1(r22)
   197d0:	b0ffff84 	addi	r3,r22,-2
   197d4:	01400e44 	movi	r5,57
   197d8:	00000306 	br	197e8 <_dtoa_r+0x934>
   197dc:	1d000003 	ldbu	r20,0(r3)
   197e0:	102d883a 	mov	r22,r2
   197e4:	18ffffc4 	addi	r3,r3,-1
   197e8:	a1003fcc 	andi	r4,r20,255
   197ec:	2100201c 	xori	r4,r4,128
   197f0:	213fe004 	addi	r4,r4,-128
   197f4:	b0bfffc4 	addi	r2,r22,-1
   197f8:	2142ca1e 	bne	r4,r5,1a324 <_dtoa_r+0x1470>
   197fc:	b8bff71e 	bne	r23,r2,197dc <_dtoa_r+0x928>
   19800:	d8800617 	ldw	r2,24(sp)
   19804:	05000c44 	movi	r20,49
   19808:	10800044 	addi	r2,r2,1
   1980c:	d8800615 	stw	r2,24(sp)
   19810:	00800c04 	movi	r2,48
   19814:	b8800005 	stb	r2,0(r23)
   19818:	b805883a 	mov	r2,r23
   1981c:	15000005 	stb	r20,0(r2)
   19820:	003f4506 	br	19538 <_dtoa_r+0x684>
   19824:	d9c00c17 	ldw	r7,48(sp)
   19828:	3800c926 	beq	r7,zero,19b50 <_dtoa_r+0xc9c>
   1982c:	d9c00417 	ldw	r7,16(sp)
   19830:	00c00044 	movi	r3,1
   19834:	19c16c0e 	bge	r3,r7,19de8 <_dtoa_r+0xf34>
   19838:	d9000917 	ldw	r4,36(sp)
   1983c:	d9c00a17 	ldw	r7,40(sp)
   19840:	24ffffc4 	addi	r19,r4,-1
   19844:	3cc20716 	blt	r7,r19,1a064 <_dtoa_r+0x11b0>
   19848:	3ce7c83a 	sub	r19,r7,r19
   1984c:	d9c00917 	ldw	r7,36(sp)
   19850:	3802ae16 	blt	r7,zero,1a30c <_dtoa_r+0x1458>
   19854:	dc800817 	ldw	r18,32(sp)
   19858:	d8800917 	ldw	r2,36(sp)
   1985c:	d8c00817 	ldw	r3,32(sp)
   19860:	d9c00717 	ldw	r7,28(sp)
   19864:	8009883a 	mov	r4,r16
   19868:	1887883a 	add	r3,r3,r2
   1986c:	388f883a 	add	r7,r7,r2
   19870:	01400044 	movi	r5,1
   19874:	d8c00815 	stw	r3,32(sp)
   19878:	d9c00715 	stw	r7,28(sp)
   1987c:	001c4380 	call	1c438 <__i2b>
   19880:	102b883a 	mov	r21,r2
   19884:	90000a26 	beq	r18,zero,198b0 <_dtoa_r+0x9fc>
   19888:	d8800717 	ldw	r2,28(sp)
   1988c:	0080080e 	bge	zero,r2,198b0 <_dtoa_r+0x9fc>
   19890:	90812b16 	blt	r18,r2,19d40 <_dtoa_r+0xe8c>
   19894:	d8c00817 	ldw	r3,32(sp)
   19898:	d9000717 	ldw	r4,28(sp)
   1989c:	90a5c83a 	sub	r18,r18,r2
   198a0:	1887c83a 	sub	r3,r3,r2
   198a4:	2089c83a 	sub	r4,r4,r2
   198a8:	d8c00815 	stw	r3,32(sp)
   198ac:	d9000715 	stw	r4,28(sp)
   198b0:	d9c00a17 	ldw	r7,40(sp)
   198b4:	01c0140e 	bge	zero,r7,19908 <_dtoa_r+0xa54>
   198b8:	d8800c17 	ldw	r2,48(sp)
   198bc:	1001de26 	beq	r2,zero,1a038 <_dtoa_r+0x1184>
   198c0:	04c00e0e 	bge	zero,r19,198fc <_dtoa_r+0xa48>
   198c4:	a80b883a 	mov	r5,r21
   198c8:	8009883a 	mov	r4,r16
   198cc:	980d883a 	mov	r6,r19
   198d0:	001c6540 	call	1c654 <__pow5mult>
   198d4:	e00d883a 	mov	r6,fp
   198d8:	8009883a 	mov	r4,r16
   198dc:	100b883a 	mov	r5,r2
   198e0:	102b883a 	mov	r21,r2
   198e4:	001c4740 	call	1c474 <__multiply>
   198e8:	1029883a 	mov	r20,r2
   198ec:	e00b883a 	mov	r5,fp
   198f0:	8009883a 	mov	r4,r16
   198f4:	001c0e00 	call	1c0e0 <_Bfree>
   198f8:	a039883a 	mov	fp,r20
   198fc:	d8c00a17 	ldw	r3,40(sp)
   19900:	1ccdc83a 	sub	r6,r3,r19
   19904:	3001291e 	bne	r6,zero,19dac <_dtoa_r+0xef8>
   19908:	8009883a 	mov	r4,r16
   1990c:	01400044 	movi	r5,1
   19910:	001c4380 	call	1c438 <__i2b>
   19914:	d9000b17 	ldw	r4,44(sp)
   19918:	1029883a 	mov	r20,r2
   1991c:	0100050e 	bge	zero,r4,19934 <_dtoa_r+0xa80>
   19920:	d9800b17 	ldw	r6,44(sp)
   19924:	8009883a 	mov	r4,r16
   19928:	100b883a 	mov	r5,r2
   1992c:	001c6540 	call	1c654 <__pow5mult>
   19930:	1029883a 	mov	r20,r2
   19934:	d9c00417 	ldw	r7,16(sp)
   19938:	00800044 	movi	r2,1
   1993c:	11c0f00e 	bge	r2,r7,19d00 <_dtoa_r+0xe4c>
   19940:	0023883a 	mov	r17,zero
   19944:	d8800b17 	ldw	r2,44(sp)
   19948:	1001741e 	bne	r2,zero,19f1c <_dtoa_r+0x1068>
   1994c:	00800044 	movi	r2,1
   19950:	d8c00717 	ldw	r3,28(sp)
   19954:	10c5883a 	add	r2,r2,r3
   19958:	108007cc 	andi	r2,r2,31
   1995c:	10008026 	beq	r2,zero,19b60 <_dtoa_r+0xcac>
   19960:	01000804 	movi	r4,32
   19964:	2089c83a 	sub	r4,r4,r2
   19968:	00c00104 	movi	r3,4
   1996c:	1902d00e 	bge	r3,r4,1a4b0 <_dtoa_r+0x15fc>
   19970:	d9000817 	ldw	r4,32(sp)
   19974:	d9c00717 	ldw	r7,28(sp)
   19978:	00c00704 	movi	r3,28
   1997c:	1885c83a 	sub	r2,r3,r2
   19980:	2089883a 	add	r4,r4,r2
   19984:	388f883a 	add	r7,r7,r2
   19988:	d9000815 	stw	r4,32(sp)
   1998c:	90a5883a 	add	r18,r18,r2
   19990:	d9c00715 	stw	r7,28(sp)
   19994:	d9c00817 	ldw	r7,32(sp)
   19998:	01c0050e 	bge	zero,r7,199b0 <_dtoa_r+0xafc>
   1999c:	e00b883a 	mov	r5,fp
   199a0:	8009883a 	mov	r4,r16
   199a4:	380d883a 	mov	r6,r7
   199a8:	001c7800 	call	1c780 <__lshift>
   199ac:	1039883a 	mov	fp,r2
   199b0:	d8800717 	ldw	r2,28(sp)
   199b4:	0080050e 	bge	zero,r2,199cc <_dtoa_r+0xb18>
   199b8:	a00b883a 	mov	r5,r20
   199bc:	8009883a 	mov	r4,r16
   199c0:	100d883a 	mov	r6,r2
   199c4:	001c7800 	call	1c780 <__lshift>
   199c8:	1029883a 	mov	r20,r2
   199cc:	d8c00d17 	ldw	r3,52(sp)
   199d0:	1801401e 	bne	r3,zero,19ed4 <_dtoa_r+0x1020>
   199d4:	d8800917 	ldw	r2,36(sp)
   199d8:	00815a0e 	bge	zero,r2,19f44 <_dtoa_r+0x1090>
   199dc:	d8c00c17 	ldw	r3,48(sp)
   199e0:	18006f1e 	bne	r3,zero,19ba0 <_dtoa_r+0xcec>
   199e4:	b823883a 	mov	r17,r23
   199e8:	dc800917 	ldw	r18,36(sp)
   199ec:	00000206 	br	199f8 <_dtoa_r+0xb44>
   199f0:	001c1080 	call	1c108 <__multadd>
   199f4:	1039883a 	mov	fp,r2
   199f8:	e009883a 	mov	r4,fp
   199fc:	a00b883a 	mov	r5,r20
   19a00:	0018cac0 	call	18cac <quorem>
   19a04:	10800c04 	addi	r2,r2,48
   19a08:	88800005 	stb	r2,0(r17)
   19a0c:	8c400044 	addi	r17,r17,1
   19a10:	8dc7c83a 	sub	r3,r17,r23
   19a14:	8009883a 	mov	r4,r16
   19a18:	e00b883a 	mov	r5,fp
   19a1c:	01800284 	movi	r6,10
   19a20:	000f883a 	mov	r7,zero
   19a24:	1cbff216 	blt	r3,r18,199f0 <_dtoa_r+0xb3c>
   19a28:	dd800917 	ldw	r22,36(sp)
   19a2c:	1007883a 	mov	r3,r2
   19a30:	05823a0e 	bge	zero,r22,1a31c <_dtoa_r+0x1468>
   19a34:	bdad883a 	add	r22,r23,r22
   19a38:	0023883a 	mov	r17,zero
   19a3c:	e00b883a 	mov	r5,fp
   19a40:	01800044 	movi	r6,1
   19a44:	8009883a 	mov	r4,r16
   19a48:	d8c01515 	stw	r3,84(sp)
   19a4c:	001c7800 	call	1c780 <__lshift>
   19a50:	1009883a 	mov	r4,r2
   19a54:	a00b883a 	mov	r5,r20
   19a58:	1039883a 	mov	fp,r2
   19a5c:	001c8dc0 	call	1c8dc <__mcmp>
   19a60:	d8c01517 	ldw	r3,84(sp)
   19a64:	0080d60e 	bge	zero,r2,19dc0 <_dtoa_r+0xf0c>
   19a68:	b13fffc3 	ldbu	r4,-1(r22)
   19a6c:	b0ffff84 	addi	r3,r22,-2
   19a70:	01800e44 	movi	r6,57
   19a74:	00000306 	br	19a84 <_dtoa_r+0xbd0>
   19a78:	19000003 	ldbu	r4,0(r3)
   19a7c:	102d883a 	mov	r22,r2
   19a80:	18ffffc4 	addi	r3,r3,-1
   19a84:	21403fcc 	andi	r5,r4,255
   19a88:	2940201c 	xori	r5,r5,128
   19a8c:	297fe004 	addi	r5,r5,-128
   19a90:	b0bfffc4 	addi	r2,r22,-1
   19a94:	2981a71e 	bne	r5,r6,1a134 <_dtoa_r+0x1280>
   19a98:	b8bff71e 	bne	r23,r2,19a78 <_dtoa_r+0xbc4>
   19a9c:	d8800617 	ldw	r2,24(sp)
   19aa0:	10800044 	addi	r2,r2,1
   19aa4:	d8800615 	stw	r2,24(sp)
   19aa8:	00800c44 	movi	r2,49
   19aac:	b8800005 	stb	r2,0(r23)
   19ab0:	8009883a 	mov	r4,r16
   19ab4:	a00b883a 	mov	r5,r20
   19ab8:	001c0e00 	call	1c0e0 <_Bfree>
   19abc:	a83e9e26 	beq	r21,zero,19538 <_dtoa_r+0x684>
   19ac0:	88000426 	beq	r17,zero,19ad4 <_dtoa_r+0xc20>
   19ac4:	8d400326 	beq	r17,r21,19ad4 <_dtoa_r+0xc20>
   19ac8:	8009883a 	mov	r4,r16
   19acc:	880b883a 	mov	r5,r17
   19ad0:	001c0e00 	call	1c0e0 <_Bfree>
   19ad4:	8009883a 	mov	r4,r16
   19ad8:	a80b883a 	mov	r5,r21
   19adc:	001c0e00 	call	1c0e0 <_Bfree>
   19ae0:	003e9506 	br	19538 <_dtoa_r+0x684>
   19ae4:	00c00044 	movi	r3,1
   19ae8:	d8c00d15 	stw	r3,52(sp)
   19aec:	003d9f06 	br	1916c <_dtoa_r+0x2b8>
   19af0:	d9000817 	ldw	r4,32(sp)
   19af4:	d8800617 	ldw	r2,24(sp)
   19af8:	d8000b15 	stw	zero,44(sp)
   19afc:	2089c83a 	sub	r4,r4,r2
   19b00:	0087c83a 	sub	r3,zero,r2
   19b04:	d9000815 	stw	r4,32(sp)
   19b08:	d8c00a15 	stw	r3,40(sp)
   19b0c:	003da306 	br	1919c <_dtoa_r+0x2e8>
   19b10:	0529c83a 	sub	r20,zero,r20
   19b14:	dd000815 	stw	r20,32(sp)
   19b18:	d8000715 	stw	zero,28(sp)
   19b1c:	003d9806 	br	19180 <_dtoa_r+0x2cc>
   19b20:	d9000617 	ldw	r4,24(sp)
   19b24:	001f2340 	call	1f234 <__floatsidf>
   19b28:	1009883a 	mov	r4,r2
   19b2c:	180b883a 	mov	r5,r3
   19b30:	980d883a 	mov	r6,r19
   19b34:	900f883a 	mov	r7,r18
   19b38:	001f0b40 	call	1f0b4 <__nedf2>
   19b3c:	103d7a26 	beq	r2,zero,19128 <_dtoa_r+0x274>
   19b40:	d8800617 	ldw	r2,24(sp)
   19b44:	10bfffc4 	addi	r2,r2,-1
   19b48:	d8800615 	stw	r2,24(sp)
   19b4c:	003d7606 	br	19128 <_dtoa_r+0x274>
   19b50:	dcc00a17 	ldw	r19,40(sp)
   19b54:	dc800817 	ldw	r18,32(sp)
   19b58:	002b883a 	mov	r21,zero
   19b5c:	003f4906 	br	19884 <_dtoa_r+0x9d0>
   19b60:	00800704 	movi	r2,28
   19b64:	d8c00817 	ldw	r3,32(sp)
   19b68:	d9000717 	ldw	r4,28(sp)
   19b6c:	90a5883a 	add	r18,r18,r2
   19b70:	1887883a 	add	r3,r3,r2
   19b74:	2089883a 	add	r4,r4,r2
   19b78:	d8c00815 	stw	r3,32(sp)
   19b7c:	d9000715 	stw	r4,28(sp)
   19b80:	003f8406 	br	19994 <_dtoa_r+0xae0>
   19b84:	d9c00317 	ldw	r7,12(sp)
   19b88:	013efb84 	movi	r4,-1042
   19b8c:	2509c83a 	sub	r4,r4,r20
   19b90:	3908983a 	sll	r4,r7,r4
   19b94:	003d3006 	br	19058 <_dtoa_r+0x1a4>
   19b98:	d8000d15 	stw	zero,52(sp)
   19b9c:	003d7306 	br	1916c <_dtoa_r+0x2b8>
   19ba0:	0480050e 	bge	zero,r18,19bb8 <_dtoa_r+0xd04>
   19ba4:	a80b883a 	mov	r5,r21
   19ba8:	8009883a 	mov	r4,r16
   19bac:	900d883a 	mov	r6,r18
   19bb0:	001c7800 	call	1c780 <__lshift>
   19bb4:	102b883a 	mov	r21,r2
   19bb8:	8801611e 	bne	r17,zero,1a140 <_dtoa_r+0x128c>
   19bbc:	a827883a 	mov	r19,r21
   19bc0:	d8c00317 	ldw	r3,12(sp)
   19bc4:	d9000917 	ldw	r4,36(sp)
   19bc8:	b8bfffc4 	addi	r2,r23,-1
   19bcc:	18c0004c 	andi	r3,r3,1
   19bd0:	1105883a 	add	r2,r2,r4
   19bd4:	b825883a 	mov	r18,r23
   19bd8:	d8800515 	stw	r2,20(sp)
   19bdc:	a823883a 	mov	r17,r21
   19be0:	d8c00315 	stw	r3,12(sp)
   19be4:	ddc00715 	stw	r23,28(sp)
   19be8:	e009883a 	mov	r4,fp
   19bec:	a00b883a 	mov	r5,r20
   19bf0:	0018cac0 	call	18cac <quorem>
   19bf4:	e009883a 	mov	r4,fp
   19bf8:	880b883a 	mov	r5,r17
   19bfc:	102d883a 	mov	r22,r2
   19c00:	001c8dc0 	call	1c8dc <__mcmp>
   19c04:	980d883a 	mov	r6,r19
   19c08:	8009883a 	mov	r4,r16
   19c0c:	a00b883a 	mov	r5,r20
   19c10:	102b883a 	mov	r21,r2
   19c14:	001c9340 	call	1c934 <__mdiff>
   19c18:	100d883a 	mov	r6,r2
   19c1c:	10800317 	ldw	r2,12(r2)
   19c20:	b5c00c04 	addi	r23,r22,48
   19c24:	10008c26 	beq	r2,zero,19e58 <_dtoa_r+0xfa4>
   19c28:	8009883a 	mov	r4,r16
   19c2c:	300b883a 	mov	r5,r6
   19c30:	001c0e00 	call	1c0e0 <_Bfree>
   19c34:	00800044 	movi	r2,1
   19c38:	a8007116 	blt	r21,zero,19e00 <_dtoa_r+0xf4c>
   19c3c:	a800041e 	bne	r21,zero,19c50 <_dtoa_r+0xd9c>
   19c40:	d9c00417 	ldw	r7,16(sp)
   19c44:	3800021e 	bne	r7,zero,19c50 <_dtoa_r+0xd9c>
   19c48:	d8c00317 	ldw	r3,12(sp)
   19c4c:	18006c26 	beq	r3,zero,19e00 <_dtoa_r+0xf4c>
   19c50:	00814c16 	blt	zero,r2,1a184 <_dtoa_r+0x12d0>
   19c54:	d8c00517 	ldw	r3,20(sp)
   19c58:	95400044 	addi	r21,r18,1
   19c5c:	95c00005 	stb	r23,0(r18)
   19c60:	a82d883a 	mov	r22,r21
   19c64:	90c14d26 	beq	r18,r3,1a19c <_dtoa_r+0x12e8>
   19c68:	e00b883a 	mov	r5,fp
   19c6c:	8009883a 	mov	r4,r16
   19c70:	01800284 	movi	r6,10
   19c74:	000f883a 	mov	r7,zero
   19c78:	001c1080 	call	1c108 <__multadd>
   19c7c:	1039883a 	mov	fp,r2
   19c80:	8cc08b26 	beq	r17,r19,19eb0 <_dtoa_r+0xffc>
   19c84:	880b883a 	mov	r5,r17
   19c88:	01800284 	movi	r6,10
   19c8c:	000f883a 	mov	r7,zero
   19c90:	8009883a 	mov	r4,r16
   19c94:	001c1080 	call	1c108 <__multadd>
   19c98:	980b883a 	mov	r5,r19
   19c9c:	8009883a 	mov	r4,r16
   19ca0:	01800284 	movi	r6,10
   19ca4:	000f883a 	mov	r7,zero
   19ca8:	1023883a 	mov	r17,r2
   19cac:	001c1080 	call	1c108 <__multadd>
   19cb0:	1027883a 	mov	r19,r2
   19cb4:	a825883a 	mov	r18,r21
   19cb8:	003fcb06 	br	19be8 <_dtoa_r+0xd34>
   19cbc:	d9c00417 	ldw	r7,16(sp)
   19cc0:	00800104 	movi	r2,4
   19cc4:	3880e426 	beq	r7,r2,1a058 <_dtoa_r+0x11a4>
   19cc8:	00800144 	movi	r2,5
   19ccc:	38be3c1e 	bne	r7,r2,195c0 <_dtoa_r+0x70c>
   19cd0:	00c00044 	movi	r3,1
   19cd4:	d8c00c15 	stw	r3,48(sp)
   19cd8:	d9c02117 	ldw	r7,132(sp)
   19cdc:	d8800617 	ldw	r2,24(sp)
   19ce0:	388f883a 	add	r7,r7,r2
   19ce4:	3c800044 	addi	r18,r7,1
   19ce8:	d9c00e15 	stw	r7,56(sp)
   19cec:	dc800915 	stw	r18,36(sp)
   19cf0:	04bd3e16 	blt	zero,r18,191ec <_dtoa_r+0x338>
   19cf4:	80001115 	stw	zero,68(r16)
   19cf8:	000b883a 	mov	r5,zero
   19cfc:	003d4606 	br	19218 <_dtoa_r+0x364>
   19d00:	d8c00317 	ldw	r3,12(sp)
   19d04:	183f0e1e 	bne	r3,zero,19940 <_dtoa_r+0xa8c>
   19d08:	00c00434 	movhi	r3,16
   19d0c:	18ffffc4 	addi	r3,r3,-1
   19d10:	88c6703a 	and	r3,r17,r3
   19d14:	183f0a1e 	bne	r3,zero,19940 <_dtoa_r+0xa8c>
   19d18:	8c5ffc2c 	andhi	r17,r17,32752
   19d1c:	883f0826 	beq	r17,zero,19940 <_dtoa_r+0xa8c>
   19d20:	d9000817 	ldw	r4,32(sp)
   19d24:	d9c00717 	ldw	r7,28(sp)
   19d28:	1023883a 	mov	r17,r2
   19d2c:	2089883a 	add	r4,r4,r2
   19d30:	388f883a 	add	r7,r7,r2
   19d34:	d9000815 	stw	r4,32(sp)
   19d38:	d9c00715 	stw	r7,28(sp)
   19d3c:	003f0106 	br	19944 <_dtoa_r+0xa90>
   19d40:	9005883a 	mov	r2,r18
   19d44:	003ed306 	br	19894 <_dtoa_r+0x9e0>
   19d48:	d8800917 	ldw	r2,36(sp)
   19d4c:	00be3516 	blt	zero,r2,19624 <_dtoa_r+0x770>
   19d50:	1000b61e 	bne	r2,zero,1a02c <_dtoa_r+0x1178>
   19d54:	9009883a 	mov	r4,r18
   19d58:	980b883a 	mov	r5,r19
   19d5c:	000d883a 	mov	r6,zero
   19d60:	01d00534 	movhi	r7,16404
   19d64:	001ebc00 	call	1ebc0 <__muldf3>
   19d68:	d9800317 	ldw	r6,12(sp)
   19d6c:	1009883a 	mov	r4,r2
   19d70:	180b883a 	mov	r5,r3
   19d74:	880f883a 	mov	r7,r17
   19d78:	001f1740 	call	1f174 <__gedf2>
   19d7c:	0029883a 	mov	r20,zero
   19d80:	002b883a 	mov	r21,zero
   19d84:	10007e16 	blt	r2,zero,19f80 <_dtoa_r+0x10cc>
   19d88:	d8802117 	ldw	r2,132(sp)
   19d8c:	b82d883a 	mov	r22,r23
   19d90:	0084303a 	nor	r2,zero,r2
   19d94:	d8800615 	stw	r2,24(sp)
   19d98:	8009883a 	mov	r4,r16
   19d9c:	a00b883a 	mov	r5,r20
   19da0:	001c0e00 	call	1c0e0 <_Bfree>
   19da4:	a83f4b1e 	bne	r21,zero,19ad4 <_dtoa_r+0xc20>
   19da8:	003de306 	br	19538 <_dtoa_r+0x684>
   19dac:	e00b883a 	mov	r5,fp
   19db0:	8009883a 	mov	r4,r16
   19db4:	001c6540 	call	1c654 <__pow5mult>
   19db8:	1039883a 	mov	fp,r2
   19dbc:	003ed206 	br	19908 <_dtoa_r+0xa54>
   19dc0:	1000021e 	bne	r2,zero,19dcc <_dtoa_r+0xf18>
   19dc4:	18c0004c 	andi	r3,r3,1
   19dc8:	183f271e 	bne	r3,zero,19a68 <_dtoa_r+0xbb4>
   19dcc:	01000c04 	movi	r4,48
   19dd0:	00000106 	br	19dd8 <_dtoa_r+0xf24>
   19dd4:	102d883a 	mov	r22,r2
   19dd8:	b0bfffc4 	addi	r2,r22,-1
   19ddc:	10c00007 	ldb	r3,0(r2)
   19de0:	193ffc26 	beq	r3,r4,19dd4 <_dtoa_r+0xf20>
   19de4:	003f3206 	br	19ab0 <_dtoa_r+0xbfc>
   19de8:	d8c00f17 	ldw	r3,60(sp)
   19dec:	18015026 	beq	r3,zero,1a330 <_dtoa_r+0x147c>
   19df0:	10810cc4 	addi	r2,r2,1075
   19df4:	dcc00a17 	ldw	r19,40(sp)
   19df8:	dc800817 	ldw	r18,32(sp)
   19dfc:	003e9706 	br	1985c <_dtoa_r+0x9a8>
   19e00:	b807883a 	mov	r3,r23
   19e04:	182b883a 	mov	r21,r3
   19e08:	ddc00717 	ldw	r23,28(sp)
   19e0c:	00800e0e 	bge	zero,r2,19e48 <_dtoa_r+0xf94>
   19e10:	e00b883a 	mov	r5,fp
   19e14:	01800044 	movi	r6,1
   19e18:	8009883a 	mov	r4,r16
   19e1c:	d8c01515 	stw	r3,84(sp)
   19e20:	001c7800 	call	1c780 <__lshift>
   19e24:	1009883a 	mov	r4,r2
   19e28:	a00b883a 	mov	r5,r20
   19e2c:	1039883a 	mov	fp,r2
   19e30:	001c8dc0 	call	1c8dc <__mcmp>
   19e34:	d8c01517 	ldw	r3,84(sp)
   19e38:	0081880e 	bge	zero,r2,1a45c <_dtoa_r+0x15a8>
   19e3c:	00800e44 	movi	r2,57
   19e40:	b0c00c44 	addi	r3,r22,49
   19e44:	a8816326 	beq	r21,r2,1a3d4 <_dtoa_r+0x1520>
   19e48:	90c00005 	stb	r3,0(r18)
   19e4c:	95800044 	addi	r22,r18,1
   19e50:	982b883a 	mov	r21,r19
   19e54:	003f1606 	br	19ab0 <_dtoa_r+0xbfc>
   19e58:	300b883a 	mov	r5,r6
   19e5c:	e009883a 	mov	r4,fp
   19e60:	d9801515 	stw	r6,84(sp)
   19e64:	001c8dc0 	call	1c8dc <__mcmp>
   19e68:	d9801517 	ldw	r6,84(sp)
   19e6c:	8009883a 	mov	r4,r16
   19e70:	d8801515 	stw	r2,84(sp)
   19e74:	300b883a 	mov	r5,r6
   19e78:	001c0e00 	call	1c0e0 <_Bfree>
   19e7c:	d8801517 	ldw	r2,84(sp)
   19e80:	103f6d1e 	bne	r2,zero,19c38 <_dtoa_r+0xd84>
   19e84:	d9c00417 	ldw	r7,16(sp)
   19e88:	383f6b1e 	bne	r7,zero,19c38 <_dtoa_r+0xd84>
   19e8c:	d8c00317 	ldw	r3,12(sp)
   19e90:	183f691e 	bne	r3,zero,19c38 <_dtoa_r+0xd84>
   19e94:	b807883a 	mov	r3,r23
   19e98:	00800e44 	movi	r2,57
   19e9c:	ddc00717 	ldw	r23,28(sp)
   19ea0:	18814c26 	beq	r3,r2,1a3d4 <_dtoa_r+0x1520>
   19ea4:	057fe80e 	bge	zero,r21,19e48 <_dtoa_r+0xf94>
   19ea8:	b0c00c44 	addi	r3,r22,49
   19eac:	003fe606 	br	19e48 <_dtoa_r+0xf94>
   19eb0:	880b883a 	mov	r5,r17
   19eb4:	8009883a 	mov	r4,r16
   19eb8:	01800284 	movi	r6,10
   19ebc:	000f883a 	mov	r7,zero
   19ec0:	001c1080 	call	1c108 <__multadd>
   19ec4:	1023883a 	mov	r17,r2
   19ec8:	1027883a 	mov	r19,r2
   19ecc:	a825883a 	mov	r18,r21
   19ed0:	003f4506 	br	19be8 <_dtoa_r+0xd34>
   19ed4:	e009883a 	mov	r4,fp
   19ed8:	a00b883a 	mov	r5,r20
   19edc:	001c8dc0 	call	1c8dc <__mcmp>
   19ee0:	103ebc0e 	bge	r2,zero,199d4 <_dtoa_r+0xb20>
   19ee4:	e00b883a 	mov	r5,fp
   19ee8:	8009883a 	mov	r4,r16
   19eec:	01800284 	movi	r6,10
   19ef0:	000f883a 	mov	r7,zero
   19ef4:	001c1080 	call	1c108 <__multadd>
   19ef8:	1039883a 	mov	fp,r2
   19efc:	d8800617 	ldw	r2,24(sp)
   19f00:	d8c00c17 	ldw	r3,48(sp)
   19f04:	10bfffc4 	addi	r2,r2,-1
   19f08:	d8800615 	stw	r2,24(sp)
   19f0c:	1801571e 	bne	r3,zero,1a46c <_dtoa_r+0x15b8>
   19f10:	d9c00e17 	ldw	r7,56(sp)
   19f14:	d9c00915 	stw	r7,36(sp)
   19f18:	003eae06 	br	199d4 <_dtoa_r+0xb20>
   19f1c:	a0800417 	ldw	r2,16(r20)
   19f20:	10800104 	addi	r2,r2,4
   19f24:	1085883a 	add	r2,r2,r2
   19f28:	1085883a 	add	r2,r2,r2
   19f2c:	a085883a 	add	r2,r20,r2
   19f30:	11000017 	ldw	r4,0(r2)
   19f34:	001c3200 	call	1c320 <__hi0bits>
   19f38:	00c00804 	movi	r3,32
   19f3c:	1885c83a 	sub	r2,r3,r2
   19f40:	003e8306 	br	19950 <_dtoa_r+0xa9c>
   19f44:	d9c00417 	ldw	r7,16(sp)
   19f48:	00800084 	movi	r2,2
   19f4c:	11fea30e 	bge	r2,r7,199dc <_dtoa_r+0xb28>
   19f50:	d8800917 	ldw	r2,36(sp)
   19f54:	103f8c1e 	bne	r2,zero,19d88 <_dtoa_r+0xed4>
   19f58:	a00b883a 	mov	r5,r20
   19f5c:	8009883a 	mov	r4,r16
   19f60:	01800144 	movi	r6,5
   19f64:	000f883a 	mov	r7,zero
   19f68:	001c1080 	call	1c108 <__multadd>
   19f6c:	e009883a 	mov	r4,fp
   19f70:	100b883a 	mov	r5,r2
   19f74:	1029883a 	mov	r20,r2
   19f78:	001c8dc0 	call	1c8dc <__mcmp>
   19f7c:	00bf820e 	bge	zero,r2,19d88 <_dtoa_r+0xed4>
   19f80:	00800c44 	movi	r2,49
   19f84:	b8800005 	stb	r2,0(r23)
   19f88:	d8800617 	ldw	r2,24(sp)
   19f8c:	bd800044 	addi	r22,r23,1
   19f90:	10800044 	addi	r2,r2,1
   19f94:	d8800615 	stw	r2,24(sp)
   19f98:	003f7f06 	br	19d98 <_dtoa_r+0xee4>
   19f9c:	dc000417 	ldw	r16,16(sp)
   19fa0:	003d6506 	br	19538 <_dtoa_r+0x684>
   19fa4:	9009883a 	mov	r4,r18
   19fa8:	001f2340 	call	1f234 <__floatsidf>
   19fac:	1009883a 	mov	r4,r2
   19fb0:	180b883a 	mov	r5,r3
   19fb4:	980d883a 	mov	r6,r19
   19fb8:	a00f883a 	mov	r7,r20
   19fbc:	001ebc00 	call	1ebc0 <__muldf3>
   19fc0:	1009883a 	mov	r4,r2
   19fc4:	180b883a 	mov	r5,r3
   19fc8:	000d883a 	mov	r6,zero
   19fcc:	01d00734 	movhi	r7,16412
   19fd0:	001eb0c0 	call	1eb0c <__adddf3>
   19fd4:	057f3034 	movhi	r21,64704
   19fd8:	1025883a 	mov	r18,r2
   19fdc:	1d6b883a 	add	r21,r3,r21
   19fe0:	9809883a 	mov	r4,r19
   19fe4:	a00b883a 	mov	r5,r20
   19fe8:	000d883a 	mov	r6,zero
   19fec:	01d00534 	movhi	r7,16404
   19ff0:	001eb600 	call	1eb60 <__subdf3>
   19ff4:	1009883a 	mov	r4,r2
   19ff8:	180b883a 	mov	r5,r3
   19ffc:	900d883a 	mov	r6,r18
   1a000:	a80f883a 	mov	r7,r21
   1a004:	1027883a 	mov	r19,r2
   1a008:	1829883a 	mov	r20,r3
   1a00c:	001f1100 	call	1f110 <__gtdf2>
   1a010:	00806616 	blt	zero,r2,1a1ac <_dtoa_r+0x12f8>
   1a014:	a9e0003c 	xorhi	r7,r21,32768
   1a018:	9809883a 	mov	r4,r19
   1a01c:	a00b883a 	mov	r5,r20
   1a020:	900d883a 	mov	r6,r18
   1a024:	001f1d80 	call	1f1d8 <__ltdf2>
   1a028:	103d710e 	bge	r2,zero,195f0 <_dtoa_r+0x73c>
   1a02c:	0029883a 	mov	r20,zero
   1a030:	002b883a 	mov	r21,zero
   1a034:	003f5406 	br	19d88 <_dtoa_r+0xed4>
   1a038:	d9800a17 	ldw	r6,40(sp)
   1a03c:	e00b883a 	mov	r5,fp
   1a040:	8009883a 	mov	r4,r16
   1a044:	001c6540 	call	1c654 <__pow5mult>
   1a048:	1039883a 	mov	fp,r2
   1a04c:	003e2e06 	br	19908 <_dtoa_r+0xa54>
   1a050:	d8000c15 	stw	zero,48(sp)
   1a054:	003f2006 	br	19cd8 <_dtoa_r+0xe24>
   1a058:	00800044 	movi	r2,1
   1a05c:	d8800c15 	stw	r2,48(sp)
   1a060:	003c5d06 	br	191d8 <_dtoa_r+0x324>
   1a064:	d8c00a17 	ldw	r3,40(sp)
   1a068:	d9000b17 	ldw	r4,44(sp)
   1a06c:	dcc00a15 	stw	r19,40(sp)
   1a070:	98c5c83a 	sub	r2,r19,r3
   1a074:	2089883a 	add	r4,r4,r2
   1a078:	d9000b15 	stw	r4,44(sp)
   1a07c:	0027883a 	mov	r19,zero
   1a080:	003df206 	br	1984c <_dtoa_r+0x998>
   1a084:	d9000317 	ldw	r4,12(sp)
   1a088:	8829883a 	mov	r20,r17
   1a08c:	04800084 	movi	r18,2
   1a090:	d9001015 	stw	r4,64(sp)
   1a094:	003c8106 	br	1929c <_dtoa_r+0x3e8>
   1a098:	04800044 	movi	r18,1
   1a09c:	dc800e15 	stw	r18,56(sp)
   1a0a0:	dc800915 	stw	r18,36(sp)
   1a0a4:	dc802115 	stw	r18,132(sp)
   1a0a8:	003f1206 	br	19cf4 <_dtoa_r+0xe40>
   1a0ac:	d8800617 	ldw	r2,24(sp)
   1a0b0:	00abc83a 	sub	r21,zero,r2
   1a0b4:	a800a426 	beq	r21,zero,1a348 <_dtoa_r+0x1494>
   1a0b8:	a88003cc 	andi	r2,r21,15
   1a0bc:	100490fa 	slli	r2,r2,3
   1a0c0:	00c000f4 	movhi	r3,3
   1a0c4:	18fc4c04 	addi	r3,r3,-3792
   1a0c8:	d9000317 	ldw	r4,12(sp)
   1a0cc:	1885883a 	add	r2,r3,r2
   1a0d0:	11800017 	ldw	r6,0(r2)
   1a0d4:	11c00117 	ldw	r7,4(r2)
   1a0d8:	a82bd13a 	srai	r21,r21,4
   1a0dc:	880b883a 	mov	r5,r17
   1a0e0:	001ebc00 	call	1ebc0 <__muldf3>
   1a0e4:	1027883a 	mov	r19,r2
   1a0e8:	1829883a 	mov	r20,r3
   1a0ec:	a800e826 	beq	r21,zero,1a490 <_dtoa_r+0x15dc>
   1a0f0:	058000f4 	movhi	r22,3
   1a0f4:	b5bc4204 	addi	r22,r22,-3832
   1a0f8:	04800084 	movi	r18,2
   1a0fc:	a980004c 	andi	r6,r21,1
   1a100:	1009883a 	mov	r4,r2
   1a104:	a82bd07a 	srai	r21,r21,1
   1a108:	180b883a 	mov	r5,r3
   1a10c:	30000426 	beq	r6,zero,1a120 <_dtoa_r+0x126c>
   1a110:	b1800017 	ldw	r6,0(r22)
   1a114:	b1c00117 	ldw	r7,4(r22)
   1a118:	94800044 	addi	r18,r18,1
   1a11c:	001ebc00 	call	1ebc0 <__muldf3>
   1a120:	b5800204 	addi	r22,r22,8
   1a124:	a83ff51e 	bne	r21,zero,1a0fc <_dtoa_r+0x1248>
   1a128:	1027883a 	mov	r19,r2
   1a12c:	1829883a 	mov	r20,r3
   1a130:	003c7306 	br	19300 <_dtoa_r+0x44c>
   1a134:	21000044 	addi	r4,r4,1
   1a138:	11000005 	stb	r4,0(r2)
   1a13c:	003e5c06 	br	19ab0 <_dtoa_r+0xbfc>
   1a140:	a9400117 	ldw	r5,4(r21)
   1a144:	8009883a 	mov	r4,r16
   1a148:	001c0380 	call	1c038 <_Balloc>
   1a14c:	a9800417 	ldw	r6,16(r21)
   1a150:	11000304 	addi	r4,r2,12
   1a154:	a9400304 	addi	r5,r21,12
   1a158:	31800084 	addi	r6,r6,2
   1a15c:	318d883a 	add	r6,r6,r6
   1a160:	318d883a 	add	r6,r6,r6
   1a164:	1023883a 	mov	r17,r2
   1a168:	00164c00 	call	164c0 <memcpy>
   1a16c:	8009883a 	mov	r4,r16
   1a170:	880b883a 	mov	r5,r17
   1a174:	01800044 	movi	r6,1
   1a178:	001c7800 	call	1c780 <__lshift>
   1a17c:	1027883a 	mov	r19,r2
   1a180:	003e8f06 	br	19bc0 <_dtoa_r+0xd0c>
   1a184:	b807883a 	mov	r3,r23
   1a188:	00800e44 	movi	r2,57
   1a18c:	ddc00717 	ldw	r23,28(sp)
   1a190:	18809026 	beq	r3,r2,1a3d4 <_dtoa_r+0x1520>
   1a194:	18c00044 	addi	r3,r3,1
   1a198:	003f2b06 	br	19e48 <_dtoa_r+0xf94>
   1a19c:	b807883a 	mov	r3,r23
   1a1a0:	982b883a 	mov	r21,r19
   1a1a4:	ddc00717 	ldw	r23,28(sp)
   1a1a8:	003e2406 	br	19a3c <_dtoa_r+0xb88>
   1a1ac:	0029883a 	mov	r20,zero
   1a1b0:	002b883a 	mov	r21,zero
   1a1b4:	003f7206 	br	19f80 <_dtoa_r+0x10cc>
   1a1b8:	593fffc4 	addi	r4,r11,-1
   1a1bc:	200490fa 	slli	r2,r4,3
   1a1c0:	00c000f4 	movhi	r3,3
   1a1c4:	18fc4c04 	addi	r3,r3,-3792
   1a1c8:	d9001015 	stw	r4,64(sp)
   1a1cc:	1885883a 	add	r2,r3,r2
   1a1d0:	11000017 	ldw	r4,0(r2)
   1a1d4:	11400117 	ldw	r5,4(r2)
   1a1d8:	900d883a 	mov	r6,r18
   1a1dc:	a80f883a 	mov	r7,r21
   1a1e0:	dac01615 	stw	r11,88(sp)
   1a1e4:	001ebc00 	call	1ebc0 <__muldf3>
   1a1e8:	a00b883a 	mov	r5,r20
   1a1ec:	9809883a 	mov	r4,r19
   1a1f0:	d8c01215 	stw	r3,72(sp)
   1a1f4:	d8801115 	stw	r2,68(sp)
   1a1f8:	001f3080 	call	1f308 <__fixdfsi>
   1a1fc:	1009883a 	mov	r4,r2
   1a200:	1025883a 	mov	r18,r2
   1a204:	001f2340 	call	1f234 <__floatsidf>
   1a208:	9809883a 	mov	r4,r19
   1a20c:	a00b883a 	mov	r5,r20
   1a210:	100d883a 	mov	r6,r2
   1a214:	180f883a 	mov	r7,r3
   1a218:	94800c04 	addi	r18,r18,48
   1a21c:	001eb600 	call	1eb60 <__subdf3>
   1a220:	bc800005 	stb	r18,0(r23)
   1a224:	dac01617 	ldw	r11,88(sp)
   1a228:	102b883a 	mov	r21,r2
   1a22c:	00800044 	movi	r2,1
   1a230:	bd800044 	addi	r22,r23,1
   1a234:	1815883a 	mov	r10,r3
   1a238:	58802226 	beq	r11,r2,1a2c4 <_dtoa_r+0x1410>
   1a23c:	bad7883a 	add	r11,r23,r11
   1a240:	dc001415 	stw	r16,80(sp)
   1a244:	a805883a 	mov	r2,r21
   1a248:	b027883a 	mov	r19,r22
   1a24c:	5821883a 	mov	r16,r11
   1a250:	882b883a 	mov	r21,r17
   1a254:	000d883a 	mov	r6,zero
   1a258:	01d00934 	movhi	r7,16420
   1a25c:	1009883a 	mov	r4,r2
   1a260:	180b883a 	mov	r5,r3
   1a264:	001ebc00 	call	1ebc0 <__muldf3>
   1a268:	180b883a 	mov	r5,r3
   1a26c:	1009883a 	mov	r4,r2
   1a270:	1829883a 	mov	r20,r3
   1a274:	1023883a 	mov	r17,r2
   1a278:	001f3080 	call	1f308 <__fixdfsi>
   1a27c:	1009883a 	mov	r4,r2
   1a280:	1025883a 	mov	r18,r2
   1a284:	001f2340 	call	1f234 <__floatsidf>
   1a288:	8809883a 	mov	r4,r17
   1a28c:	a00b883a 	mov	r5,r20
   1a290:	100d883a 	mov	r6,r2
   1a294:	180f883a 	mov	r7,r3
   1a298:	94800c04 	addi	r18,r18,48
   1a29c:	001eb600 	call	1eb60 <__subdf3>
   1a2a0:	9cc00044 	addi	r19,r19,1
   1a2a4:	9cbfffc5 	stb	r18,-1(r19)
   1a2a8:	9c3fea1e 	bne	r19,r16,1a254 <_dtoa_r+0x13a0>
   1a2ac:	1815883a 	mov	r10,r3
   1a2b0:	d8c01017 	ldw	r3,64(sp)
   1a2b4:	dc001417 	ldw	r16,80(sp)
   1a2b8:	a823883a 	mov	r17,r21
   1a2bc:	b0ed883a 	add	r22,r22,r3
   1a2c0:	102b883a 	mov	r21,r2
   1a2c4:	d9001117 	ldw	r4,68(sp)
   1a2c8:	d9401217 	ldw	r5,72(sp)
   1a2cc:	000d883a 	mov	r6,zero
   1a2d0:	01cff834 	movhi	r7,16352
   1a2d4:	da801515 	stw	r10,84(sp)
   1a2d8:	001eb0c0 	call	1eb0c <__adddf3>
   1a2dc:	da801517 	ldw	r10,84(sp)
   1a2e0:	1009883a 	mov	r4,r2
   1a2e4:	180b883a 	mov	r5,r3
   1a2e8:	500f883a 	mov	r7,r10
   1a2ec:	a80d883a 	mov	r6,r21
   1a2f0:	001f1d80 	call	1f1d8 <__ltdf2>
   1a2f4:	da801517 	ldw	r10,84(sp)
   1a2f8:	10003b0e 	bge	r2,zero,1a3e8 <_dtoa_r+0x1534>
   1a2fc:	d9c01317 	ldw	r7,76(sp)
   1a300:	b53fffc3 	ldbu	r20,-1(r22)
   1a304:	d9c00615 	stw	r7,24(sp)
   1a308:	003d3106 	br	197d0 <_dtoa_r+0x91c>
   1a30c:	d8800817 	ldw	r2,32(sp)
   1a310:	11e5c83a 	sub	r18,r2,r7
   1a314:	0005883a 	mov	r2,zero
   1a318:	003d5006 	br	1985c <_dtoa_r+0x9a8>
   1a31c:	05800044 	movi	r22,1
   1a320:	003dc406 	br	19a34 <_dtoa_r+0xb80>
   1a324:	a5000044 	addi	r20,r20,1
   1a328:	15000005 	stb	r20,0(r2)
   1a32c:	003c8206 	br	19538 <_dtoa_r+0x684>
   1a330:	d8800217 	ldw	r2,8(sp)
   1a334:	00c00d84 	movi	r3,54
   1a338:	dcc00a17 	ldw	r19,40(sp)
   1a33c:	1885c83a 	sub	r2,r3,r2
   1a340:	dc800817 	ldw	r18,32(sp)
   1a344:	003d4506 	br	1985c <_dtoa_r+0x9a8>
   1a348:	dcc00317 	ldw	r19,12(sp)
   1a34c:	8829883a 	mov	r20,r17
   1a350:	04800084 	movi	r18,2
   1a354:	003bea06 	br	19300 <_dtoa_r+0x44c>
   1a358:	d9000917 	ldw	r4,36(sp)
   1a35c:	203f1126 	beq	r4,zero,19fa4 <_dtoa_r+0x10f0>
   1a360:	d9c00e17 	ldw	r7,56(sp)
   1a364:	01fca20e 	bge	zero,r7,195f0 <_dtoa_r+0x73c>
   1a368:	a00b883a 	mov	r5,r20
   1a36c:	9809883a 	mov	r4,r19
   1a370:	000d883a 	mov	r6,zero
   1a374:	01d00934 	movhi	r7,16420
   1a378:	001ebc00 	call	1ebc0 <__muldf3>
   1a37c:	91000044 	addi	r4,r18,1
   1a380:	1027883a 	mov	r19,r2
   1a384:	1829883a 	mov	r20,r3
   1a388:	001f2340 	call	1f234 <__floatsidf>
   1a38c:	9809883a 	mov	r4,r19
   1a390:	a00b883a 	mov	r5,r20
   1a394:	100d883a 	mov	r6,r2
   1a398:	180f883a 	mov	r7,r3
   1a39c:	001ebc00 	call	1ebc0 <__muldf3>
   1a3a0:	1009883a 	mov	r4,r2
   1a3a4:	180b883a 	mov	r5,r3
   1a3a8:	000d883a 	mov	r6,zero
   1a3ac:	01d00734 	movhi	r7,16412
   1a3b0:	001eb0c0 	call	1eb0c <__adddf3>
   1a3b4:	1025883a 	mov	r18,r2
   1a3b8:	d8800617 	ldw	r2,24(sp)
   1a3bc:	057f3034 	movhi	r21,64704
   1a3c0:	1d6b883a 	add	r21,r3,r21
   1a3c4:	10bfffc4 	addi	r2,r2,-1
   1a3c8:	d8801315 	stw	r2,76(sp)
   1a3cc:	dac00e17 	ldw	r11,56(sp)
   1a3d0:	003be706 	br	19370 <_dtoa_r+0x4bc>
   1a3d4:	01000e44 	movi	r4,57
   1a3d8:	91000005 	stb	r4,0(r18)
   1a3dc:	95800044 	addi	r22,r18,1
   1a3e0:	982b883a 	mov	r21,r19
   1a3e4:	003da106 	br	19a6c <_dtoa_r+0xbb8>
   1a3e8:	d9801117 	ldw	r6,68(sp)
   1a3ec:	d9c01217 	ldw	r7,72(sp)
   1a3f0:	0009883a 	mov	r4,zero
   1a3f4:	014ff834 	movhi	r5,16352
   1a3f8:	da801515 	stw	r10,84(sp)
   1a3fc:	001eb600 	call	1eb60 <__subdf3>
   1a400:	da801517 	ldw	r10,84(sp)
   1a404:	1009883a 	mov	r4,r2
   1a408:	180b883a 	mov	r5,r3
   1a40c:	a80d883a 	mov	r6,r21
   1a410:	500f883a 	mov	r7,r10
   1a414:	001f1100 	call	1f110 <__gtdf2>
   1a418:	00bc750e 	bge	zero,r2,195f0 <_dtoa_r+0x73c>
   1a41c:	01000c04 	movi	r4,48
   1a420:	00000106 	br	1a428 <_dtoa_r+0x1574>
   1a424:	102d883a 	mov	r22,r2
   1a428:	b0bfffc4 	addi	r2,r22,-1
   1a42c:	10c00007 	ldb	r3,0(r2)
   1a430:	193ffc26 	beq	r3,r4,1a424 <_dtoa_r+0x1570>
   1a434:	d8801317 	ldw	r2,76(sp)
   1a438:	d8800615 	stw	r2,24(sp)
   1a43c:	003c3e06 	br	19538 <_dtoa_r+0x684>
   1a440:	d9001317 	ldw	r4,76(sp)
   1a444:	df001117 	ldw	fp,68(sp)
   1a448:	d9000615 	stw	r4,24(sp)
   1a44c:	003ce006 	br	197d0 <_dtoa_r+0x91c>
   1a450:	df001117 	ldw	fp,68(sp)
   1a454:	dc401217 	ldw	r17,72(sp)
   1a458:	003c6506 	br	195f0 <_dtoa_r+0x73c>
   1a45c:	103e7a1e 	bne	r2,zero,19e48 <_dtoa_r+0xf94>
   1a460:	1880004c 	andi	r2,r3,1
   1a464:	103e7826 	beq	r2,zero,19e48 <_dtoa_r+0xf94>
   1a468:	003e7406 	br	19e3c <_dtoa_r+0xf88>
   1a46c:	8009883a 	mov	r4,r16
   1a470:	a80b883a 	mov	r5,r21
   1a474:	01800284 	movi	r6,10
   1a478:	000f883a 	mov	r7,zero
   1a47c:	001c1080 	call	1c108 <__multadd>
   1a480:	d9000e17 	ldw	r4,56(sp)
   1a484:	102b883a 	mov	r21,r2
   1a488:	d9000915 	stw	r4,36(sp)
   1a48c:	003d5106 	br	199d4 <_dtoa_r+0xb20>
   1a490:	04800084 	movi	r18,2
   1a494:	003b9a06 	br	19300 <_dtoa_r+0x44c>
   1a498:	d8c01317 	ldw	r3,76(sp)
   1a49c:	d8c00615 	stw	r3,24(sp)
   1a4a0:	003ccb06 	br	197d0 <_dtoa_r+0x91c>
   1a4a4:	d8c01317 	ldw	r3,76(sp)
   1a4a8:	d8c00615 	stw	r3,24(sp)
   1a4ac:	003c2206 	br	19538 <_dtoa_r+0x684>
   1a4b0:	20fd3826 	beq	r4,r3,19994 <_dtoa_r+0xae0>
   1a4b4:	00c00f04 	movi	r3,60
   1a4b8:	1885c83a 	sub	r2,r3,r2
   1a4bc:	003da906 	br	19b64 <_dtoa_r+0xcb0>
   1a4c0:	000b883a 	mov	r5,zero
   1a4c4:	003b5406 	br	19218 <_dtoa_r+0x364>
   1a4c8:	04c00044 	movi	r19,1
   1a4cc:	003b3b06 	br	191bc <_dtoa_r+0x308>

0001a4d0 <_fflush_r>:
   1a4d0:	defffb04 	addi	sp,sp,-20
   1a4d4:	dcc00315 	stw	r19,12(sp)
   1a4d8:	dc400115 	stw	r17,4(sp)
   1a4dc:	dfc00415 	stw	ra,16(sp)
   1a4e0:	dc800215 	stw	r18,8(sp)
   1a4e4:	dc000015 	stw	r16,0(sp)
   1a4e8:	2027883a 	mov	r19,r4
   1a4ec:	2823883a 	mov	r17,r5
   1a4f0:	20000226 	beq	r4,zero,1a4fc <_fflush_r+0x2c>
   1a4f4:	20800e17 	ldw	r2,56(r4)
   1a4f8:	10005726 	beq	r2,zero,1a658 <_fflush_r+0x188>
   1a4fc:	8880030b 	ldhu	r2,12(r17)
   1a500:	10c0020c 	andi	r3,r2,8
   1a504:	18ffffcc 	andi	r3,r3,65535
   1a508:	18e0001c 	xori	r3,r3,32768
   1a50c:	18e00004 	addi	r3,r3,-32768
   1a510:	1800311e 	bne	r3,zero,1a5d8 <_fflush_r+0x108>
   1a514:	89000117 	ldw	r4,4(r17)
   1a518:	10c20014 	ori	r3,r2,2048
   1a51c:	88c0030d 	sth	r3,12(r17)
   1a520:	180b883a 	mov	r5,r3
   1a524:	0100520e 	bge	zero,r4,1a670 <_fflush_r+0x1a0>
   1a528:	88c00a17 	ldw	r3,40(r17)
   1a52c:	18002226 	beq	r3,zero,1a5b8 <_fflush_r+0xe8>
   1a530:	1084000c 	andi	r2,r2,4096
   1a534:	10bfffcc 	andi	r2,r2,65535
   1a538:	10a0001c 	xori	r2,r2,32768
   1a53c:	10a00004 	addi	r2,r2,-32768
   1a540:	10004e26 	beq	r2,zero,1a67c <_fflush_r+0x1ac>
   1a544:	8c001417 	ldw	r16,80(r17)
   1a548:	2940010c 	andi	r5,r5,4
   1a54c:	297fffcc 	andi	r5,r5,65535
   1a550:	2960001c 	xori	r5,r5,32768
   1a554:	29600004 	addi	r5,r5,-32768
   1a558:	28000626 	beq	r5,zero,1a574 <_fflush_r+0xa4>
   1a55c:	89000117 	ldw	r4,4(r17)
   1a560:	88800c17 	ldw	r2,48(r17)
   1a564:	8121c83a 	sub	r16,r16,r4
   1a568:	10000226 	beq	r2,zero,1a574 <_fflush_r+0xa4>
   1a56c:	88800f17 	ldw	r2,60(r17)
   1a570:	80a1c83a 	sub	r16,r16,r2
   1a574:	89400717 	ldw	r5,28(r17)
   1a578:	9809883a 	mov	r4,r19
   1a57c:	800d883a 	mov	r6,r16
   1a580:	000f883a 	mov	r7,zero
   1a584:	183ee83a 	callr	r3
   1a588:	8080281e 	bne	r16,r2,1a62c <_fflush_r+0x15c>
   1a58c:	8880030b 	ldhu	r2,12(r17)
   1a590:	88c00417 	ldw	r3,16(r17)
   1a594:	88000115 	stw	zero,4(r17)
   1a598:	113dffcc 	andi	r4,r2,63487
   1a59c:	1084000c 	andi	r2,r2,4096
   1a5a0:	10bfffcc 	andi	r2,r2,65535
   1a5a4:	10a0001c 	xori	r2,r2,32768
   1a5a8:	8900030d 	sth	r4,12(r17)
   1a5ac:	88c00015 	stw	r3,0(r17)
   1a5b0:	10a00004 	addi	r2,r2,-32768
   1a5b4:	10002c1e 	bne	r2,zero,1a668 <_fflush_r+0x198>
   1a5b8:	0005883a 	mov	r2,zero
   1a5bc:	dfc00417 	ldw	ra,16(sp)
   1a5c0:	dcc00317 	ldw	r19,12(sp)
   1a5c4:	dc800217 	ldw	r18,8(sp)
   1a5c8:	dc400117 	ldw	r17,4(sp)
   1a5cc:	dc000017 	ldw	r16,0(sp)
   1a5d0:	dec00504 	addi	sp,sp,20
   1a5d4:	f800283a 	ret
   1a5d8:	8c800417 	ldw	r18,16(r17)
   1a5dc:	903ff626 	beq	r18,zero,1a5b8 <_fflush_r+0xe8>
   1a5e0:	8c000017 	ldw	r16,0(r17)
   1a5e4:	108000cc 	andi	r2,r2,3
   1a5e8:	8c800015 	stw	r18,0(r17)
   1a5ec:	84a1c83a 	sub	r16,r16,r18
   1a5f0:	10001b1e 	bne	r2,zero,1a660 <_fflush_r+0x190>
   1a5f4:	88800517 	ldw	r2,20(r17)
   1a5f8:	88800215 	stw	r2,8(r17)
   1a5fc:	04000316 	blt	zero,r16,1a60c <_fflush_r+0x13c>
   1a600:	003fed06 	br	1a5b8 <_fflush_r+0xe8>
   1a604:	90a5883a 	add	r18,r18,r2
   1a608:	043feb0e 	bge	zero,r16,1a5b8 <_fflush_r+0xe8>
   1a60c:	88800917 	ldw	r2,36(r17)
   1a610:	89400717 	ldw	r5,28(r17)
   1a614:	800f883a 	mov	r7,r16
   1a618:	900d883a 	mov	r6,r18
   1a61c:	9809883a 	mov	r4,r19
   1a620:	103ee83a 	callr	r2
   1a624:	80a1c83a 	sub	r16,r16,r2
   1a628:	00bff616 	blt	zero,r2,1a604 <_fflush_r+0x134>
   1a62c:	88c0030b 	ldhu	r3,12(r17)
   1a630:	00bfffc4 	movi	r2,-1
   1a634:	18c01014 	ori	r3,r3,64
   1a638:	88c0030d 	sth	r3,12(r17)
   1a63c:	dfc00417 	ldw	ra,16(sp)
   1a640:	dcc00317 	ldw	r19,12(sp)
   1a644:	dc800217 	ldw	r18,8(sp)
   1a648:	dc400117 	ldw	r17,4(sp)
   1a64c:	dc000017 	ldw	r16,0(sp)
   1a650:	dec00504 	addi	sp,sp,20
   1a654:	f800283a 	ret
   1a658:	001a7780 	call	1a778 <__sinit>
   1a65c:	003fa706 	br	1a4fc <_fflush_r+0x2c>
   1a660:	0005883a 	mov	r2,zero
   1a664:	003fe406 	br	1a5f8 <_fflush_r+0x128>
   1a668:	8c001415 	stw	r16,80(r17)
   1a66c:	003fd206 	br	1a5b8 <_fflush_r+0xe8>
   1a670:	88c00f17 	ldw	r3,60(r17)
   1a674:	00ffac16 	blt	zero,r3,1a528 <_fflush_r+0x58>
   1a678:	003fcf06 	br	1a5b8 <_fflush_r+0xe8>
   1a67c:	89400717 	ldw	r5,28(r17)
   1a680:	9809883a 	mov	r4,r19
   1a684:	000d883a 	mov	r6,zero
   1a688:	01c00044 	movi	r7,1
   1a68c:	183ee83a 	callr	r3
   1a690:	1021883a 	mov	r16,r2
   1a694:	00bfffc4 	movi	r2,-1
   1a698:	80800326 	beq	r16,r2,1a6a8 <_fflush_r+0x1d8>
   1a69c:	8940030b 	ldhu	r5,12(r17)
   1a6a0:	88c00a17 	ldw	r3,40(r17)
   1a6a4:	003fa806 	br	1a548 <_fflush_r+0x78>
   1a6a8:	98c00017 	ldw	r3,0(r19)
   1a6ac:	00800744 	movi	r2,29
   1a6b0:	18bfde1e 	bne	r3,r2,1a62c <_fflush_r+0x15c>
   1a6b4:	003fc006 	br	1a5b8 <_fflush_r+0xe8>

0001a6b8 <fflush>:
   1a6b8:	200b883a 	mov	r5,r4
   1a6bc:	20000426 	beq	r4,zero,1a6d0 <fflush+0x18>
   1a6c0:	008000f4 	movhi	r2,3
   1a6c4:	108d2b04 	addi	r2,r2,13484
   1a6c8:	11000017 	ldw	r4,0(r2)
   1a6cc:	001a4d01 	jmpi	1a4d0 <_fflush_r>
   1a6d0:	008000f4 	movhi	r2,3
   1a6d4:	108d2a04 	addi	r2,r2,13480
   1a6d8:	11000017 	ldw	r4,0(r2)
   1a6dc:	014000b4 	movhi	r5,2
   1a6e0:	29693404 	addi	r5,r5,-23344
   1a6e4:	001b3581 	jmpi	1b358 <_fwalk_reent>

0001a6e8 <__fp_lock>:
   1a6e8:	0005883a 	mov	r2,zero
   1a6ec:	f800283a 	ret

0001a6f0 <__fp_unlock>:
   1a6f0:	0005883a 	mov	r2,zero
   1a6f4:	f800283a 	ret

0001a6f8 <_cleanup_r>:
   1a6f8:	014000b4 	movhi	r5,2
   1a6fc:	2976ab04 	addi	r5,r5,-9556
   1a700:	001b2b01 	jmpi	1b2b0 <_fwalk>

0001a704 <__sfmoreglue>:
   1a704:	defffc04 	addi	sp,sp,-16
   1a708:	dc400115 	stw	r17,4(sp)
   1a70c:	2c401724 	muli	r17,r5,92
   1a710:	dc800215 	stw	r18,8(sp)
   1a714:	2825883a 	mov	r18,r5
   1a718:	89400304 	addi	r5,r17,12
   1a71c:	dc000015 	stw	r16,0(sp)
   1a720:	dfc00315 	stw	ra,12(sp)
   1a724:	001b6940 	call	1b694 <_malloc_r>
   1a728:	1021883a 	mov	r16,r2
   1a72c:	10000726 	beq	r2,zero,1a74c <__sfmoreglue+0x48>
   1a730:	11000304 	addi	r4,r2,12
   1a734:	10000015 	stw	zero,0(r2)
   1a738:	14800115 	stw	r18,4(r2)
   1a73c:	11000215 	stw	r4,8(r2)
   1a740:	000b883a 	mov	r5,zero
   1a744:	880d883a 	mov	r6,r17
   1a748:	00165b80 	call	165b8 <memset>
   1a74c:	8005883a 	mov	r2,r16
   1a750:	dfc00317 	ldw	ra,12(sp)
   1a754:	dc800217 	ldw	r18,8(sp)
   1a758:	dc400117 	ldw	r17,4(sp)
   1a75c:	dc000017 	ldw	r16,0(sp)
   1a760:	dec00404 	addi	sp,sp,16
   1a764:	f800283a 	ret

0001a768 <_cleanup>:
   1a768:	008000f4 	movhi	r2,3
   1a76c:	108d2a04 	addi	r2,r2,13480
   1a770:	11000017 	ldw	r4,0(r2)
   1a774:	001a6f81 	jmpi	1a6f8 <_cleanup_r>

0001a778 <__sinit>:
   1a778:	20800e17 	ldw	r2,56(r4)
   1a77c:	1000401e 	bne	r2,zero,1a880 <__sinit+0x108>
   1a780:	21400117 	ldw	r5,4(r4)
   1a784:	018000b4 	movhi	r6,2
   1a788:	31a9be04 	addi	r6,r6,-22792
   1a78c:	20c00217 	ldw	r3,8(r4)
   1a790:	21800f15 	stw	r6,60(r4)
   1a794:	2080bb04 	addi	r2,r4,748
   1a798:	02400044 	movi	r9,1
   1a79c:	018000c4 	movi	r6,3
   1a7a0:	2180b915 	stw	r6,740(r4)
   1a7a4:	2080ba15 	stw	r2,744(r4)
   1a7a8:	22400e15 	stw	r9,56(r4)
   1a7ac:	20800317 	ldw	r2,12(r4)
   1a7b0:	2000b815 	stw	zero,736(r4)
   1a7b4:	020000b4 	movhi	r8,2
   1a7b8:	4235a904 	addi	r8,r8,-10588
   1a7bc:	01c000b4 	movhi	r7,2
   1a7c0:	39f5be04 	addi	r7,r7,-10504
   1a7c4:	018000b4 	movhi	r6,2
   1a7c8:	31b5e004 	addi	r6,r6,-10368
   1a7cc:	010000b4 	movhi	r4,2
   1a7d0:	2135f704 	addi	r4,r4,-10276
   1a7d4:	02800104 	movi	r10,4
   1a7d8:	28000015 	stw	zero,0(r5)
   1a7dc:	28000115 	stw	zero,4(r5)
   1a7e0:	28000215 	stw	zero,8(r5)
   1a7e4:	2a80030d 	sth	r10,12(r5)
   1a7e8:	2800038d 	sth	zero,14(r5)
   1a7ec:	28000415 	stw	zero,16(r5)
   1a7f0:	28000515 	stw	zero,20(r5)
   1a7f4:	28000615 	stw	zero,24(r5)
   1a7f8:	29400715 	stw	r5,28(r5)
   1a7fc:	2a000815 	stw	r8,32(r5)
   1a800:	29c00915 	stw	r7,36(r5)
   1a804:	29800a15 	stw	r6,40(r5)
   1a808:	29000b15 	stw	r4,44(r5)
   1a80c:	01400284 	movi	r5,10
   1a810:	18000015 	stw	zero,0(r3)
   1a814:	18000115 	stw	zero,4(r3)
   1a818:	18000215 	stw	zero,8(r3)
   1a81c:	1940030d 	sth	r5,12(r3)
   1a820:	1a40038d 	sth	r9,14(r3)
   1a824:	18000415 	stw	zero,16(r3)
   1a828:	18000515 	stw	zero,20(r3)
   1a82c:	18000615 	stw	zero,24(r3)
   1a830:	18c00715 	stw	r3,28(r3)
   1a834:	1a000815 	stw	r8,32(r3)
   1a838:	19c00915 	stw	r7,36(r3)
   1a83c:	19800a15 	stw	r6,40(r3)
   1a840:	19000b15 	stw	r4,44(r3)
   1a844:	00c00484 	movi	r3,18
   1a848:	10c0030d 	sth	r3,12(r2)
   1a84c:	00c00084 	movi	r3,2
   1a850:	10000015 	stw	zero,0(r2)
   1a854:	10000115 	stw	zero,4(r2)
   1a858:	10000215 	stw	zero,8(r2)
   1a85c:	10c0038d 	sth	r3,14(r2)
   1a860:	10000415 	stw	zero,16(r2)
   1a864:	10000515 	stw	zero,20(r2)
   1a868:	10000615 	stw	zero,24(r2)
   1a86c:	10800715 	stw	r2,28(r2)
   1a870:	12000815 	stw	r8,32(r2)
   1a874:	11c00915 	stw	r7,36(r2)
   1a878:	11800a15 	stw	r6,40(r2)
   1a87c:	11000b15 	stw	r4,44(r2)
   1a880:	f800283a 	ret

0001a884 <__sfp>:
   1a884:	defffc04 	addi	sp,sp,-16
   1a888:	008000f4 	movhi	r2,3
   1a88c:	108d2a04 	addi	r2,r2,13480
   1a890:	dc400115 	stw	r17,4(sp)
   1a894:	14400017 	ldw	r17,0(r2)
   1a898:	dc800215 	stw	r18,8(sp)
   1a89c:	dfc00315 	stw	ra,12(sp)
   1a8a0:	88800e17 	ldw	r2,56(r17)
   1a8a4:	dc000015 	stw	r16,0(sp)
   1a8a8:	2025883a 	mov	r18,r4
   1a8ac:	10002826 	beq	r2,zero,1a950 <__sfp+0xcc>
   1a8b0:	8c40b804 	addi	r17,r17,736
   1a8b4:	043fffc4 	movi	r16,-1
   1a8b8:	89400117 	ldw	r5,4(r17)
   1a8bc:	88800217 	ldw	r2,8(r17)
   1a8c0:	297fffc4 	addi	r5,r5,-1
   1a8c4:	28000a16 	blt	r5,zero,1a8f0 <__sfp+0x6c>
   1a8c8:	10c0030f 	ldh	r3,12(r2)
   1a8cc:	18000c26 	beq	r3,zero,1a900 <__sfp+0x7c>
   1a8d0:	10c01a04 	addi	r3,r2,104
   1a8d4:	00000206 	br	1a8e0 <__sfp+0x5c>
   1a8d8:	19bfe90f 	ldh	r6,-92(r3)
   1a8dc:	30000826 	beq	r6,zero,1a900 <__sfp+0x7c>
   1a8e0:	297fffc4 	addi	r5,r5,-1
   1a8e4:	18bffd04 	addi	r2,r3,-12
   1a8e8:	18c01704 	addi	r3,r3,92
   1a8ec:	2c3ffa1e 	bne	r5,r16,1a8d8 <__sfp+0x54>
   1a8f0:	88800017 	ldw	r2,0(r17)
   1a8f4:	10001926 	beq	r2,zero,1a95c <__sfp+0xd8>
   1a8f8:	1023883a 	mov	r17,r2
   1a8fc:	003fee06 	br	1a8b8 <__sfp+0x34>
   1a900:	00ffffc4 	movi	r3,-1
   1a904:	10c0038d 	sth	r3,14(r2)
   1a908:	00c00044 	movi	r3,1
   1a90c:	10c0030d 	sth	r3,12(r2)
   1a910:	10000015 	stw	zero,0(r2)
   1a914:	10000215 	stw	zero,8(r2)
   1a918:	10000115 	stw	zero,4(r2)
   1a91c:	10000415 	stw	zero,16(r2)
   1a920:	10000515 	stw	zero,20(r2)
   1a924:	10000615 	stw	zero,24(r2)
   1a928:	10000c15 	stw	zero,48(r2)
   1a92c:	10000d15 	stw	zero,52(r2)
   1a930:	10001115 	stw	zero,68(r2)
   1a934:	10001215 	stw	zero,72(r2)
   1a938:	dfc00317 	ldw	ra,12(sp)
   1a93c:	dc800217 	ldw	r18,8(sp)
   1a940:	dc400117 	ldw	r17,4(sp)
   1a944:	dc000017 	ldw	r16,0(sp)
   1a948:	dec00404 	addi	sp,sp,16
   1a94c:	f800283a 	ret
   1a950:	8809883a 	mov	r4,r17
   1a954:	001a7780 	call	1a778 <__sinit>
   1a958:	003fd506 	br	1a8b0 <__sfp+0x2c>
   1a95c:	9009883a 	mov	r4,r18
   1a960:	01400104 	movi	r5,4
   1a964:	001a7040 	call	1a704 <__sfmoreglue>
   1a968:	88800015 	stw	r2,0(r17)
   1a96c:	103fe21e 	bne	r2,zero,1a8f8 <__sfp+0x74>
   1a970:	00800304 	movi	r2,12
   1a974:	90800015 	stw	r2,0(r18)
   1a978:	0005883a 	mov	r2,zero
   1a97c:	003fee06 	br	1a938 <__sfp+0xb4>

0001a980 <__sfp_lock_acquire>:
   1a980:	f800283a 	ret

0001a984 <__sfp_lock_release>:
   1a984:	f800283a 	ret

0001a988 <__sinit_lock_acquire>:
   1a988:	f800283a 	ret

0001a98c <__sinit_lock_release>:
   1a98c:	f800283a 	ret

0001a990 <__fp_lock_all>:
   1a990:	008000f4 	movhi	r2,3
   1a994:	108d2b04 	addi	r2,r2,13484
   1a998:	11000017 	ldw	r4,0(r2)
   1a99c:	014000b4 	movhi	r5,2
   1a9a0:	2969ba04 	addi	r5,r5,-22808
   1a9a4:	001b2b01 	jmpi	1b2b0 <_fwalk>

0001a9a8 <__fp_unlock_all>:
   1a9a8:	008000f4 	movhi	r2,3
   1a9ac:	108d2b04 	addi	r2,r2,13484
   1a9b0:	11000017 	ldw	r4,0(r2)
   1a9b4:	014000b4 	movhi	r5,2
   1a9b8:	2969bc04 	addi	r5,r5,-22800
   1a9bc:	001b2b01 	jmpi	1b2b0 <_fwalk>

0001a9c0 <_malloc_trim_r>:
   1a9c0:	defffb04 	addi	sp,sp,-20
   1a9c4:	dcc00315 	stw	r19,12(sp)
   1a9c8:	dc800215 	stw	r18,8(sp)
   1a9cc:	dc400115 	stw	r17,4(sp)
   1a9d0:	dc000015 	stw	r16,0(sp)
   1a9d4:	2827883a 	mov	r19,r5
   1a9d8:	dfc00415 	stw	ra,16(sp)
   1a9dc:	044000f4 	movhi	r17,3
   1a9e0:	8c45bc04 	addi	r17,r17,5872
   1a9e4:	2021883a 	mov	r16,r4
   1a9e8:	00202d40 	call	202d4 <__malloc_lock>
   1a9ec:	88800217 	ldw	r2,8(r17)
   1a9f0:	14800117 	ldw	r18,4(r2)
   1a9f4:	00bfff04 	movi	r2,-4
   1a9f8:	90a4703a 	and	r18,r18,r2
   1a9fc:	9083fbc4 	addi	r2,r18,4079
   1aa00:	14e7c83a 	sub	r19,r2,r19
   1aa04:	9826d33a 	srli	r19,r19,12
   1aa08:	0083ffc4 	movi	r2,4095
   1aa0c:	9cffffc4 	addi	r19,r19,-1
   1aa10:	9826933a 	slli	r19,r19,12
   1aa14:	14c0060e 	bge	r2,r19,1aa30 <_malloc_trim_r+0x70>
   1aa18:	8009883a 	mov	r4,r16
   1aa1c:	000b883a 	mov	r5,zero
   1aa20:	001d6400 	call	1d640 <_sbrk_r>
   1aa24:	88c00217 	ldw	r3,8(r17)
   1aa28:	1c87883a 	add	r3,r3,r18
   1aa2c:	10c00a26 	beq	r2,r3,1aa58 <_malloc_trim_r+0x98>
   1aa30:	8009883a 	mov	r4,r16
   1aa34:	00202f40 	call	202f4 <__malloc_unlock>
   1aa38:	0005883a 	mov	r2,zero
   1aa3c:	dfc00417 	ldw	ra,16(sp)
   1aa40:	dcc00317 	ldw	r19,12(sp)
   1aa44:	dc800217 	ldw	r18,8(sp)
   1aa48:	dc400117 	ldw	r17,4(sp)
   1aa4c:	dc000017 	ldw	r16,0(sp)
   1aa50:	dec00504 	addi	sp,sp,20
   1aa54:	f800283a 	ret
   1aa58:	8009883a 	mov	r4,r16
   1aa5c:	04cbc83a 	sub	r5,zero,r19
   1aa60:	001d6400 	call	1d640 <_sbrk_r>
   1aa64:	00ffffc4 	movi	r3,-1
   1aa68:	10c01326 	beq	r2,r3,1aab8 <_malloc_trim_r+0xf8>
   1aa6c:	00800134 	movhi	r2,4
   1aa70:	108d4b04 	addi	r2,r2,13612
   1aa74:	11000017 	ldw	r4,0(r2)
   1aa78:	88c00217 	ldw	r3,8(r17)
   1aa7c:	94e5c83a 	sub	r18,r18,r19
   1aa80:	94800054 	ori	r18,r18,1
   1aa84:	24e7c83a 	sub	r19,r4,r19
   1aa88:	1c800115 	stw	r18,4(r3)
   1aa8c:	8009883a 	mov	r4,r16
   1aa90:	14c00015 	stw	r19,0(r2)
   1aa94:	00202f40 	call	202f4 <__malloc_unlock>
   1aa98:	00800044 	movi	r2,1
   1aa9c:	dfc00417 	ldw	ra,16(sp)
   1aaa0:	dcc00317 	ldw	r19,12(sp)
   1aaa4:	dc800217 	ldw	r18,8(sp)
   1aaa8:	dc400117 	ldw	r17,4(sp)
   1aaac:	dc000017 	ldw	r16,0(sp)
   1aab0:	dec00504 	addi	sp,sp,20
   1aab4:	f800283a 	ret
   1aab8:	8009883a 	mov	r4,r16
   1aabc:	000b883a 	mov	r5,zero
   1aac0:	001d6400 	call	1d640 <_sbrk_r>
   1aac4:	88c00217 	ldw	r3,8(r17)
   1aac8:	014003c4 	movi	r5,15
   1aacc:	10c9c83a 	sub	r4,r2,r3
   1aad0:	293fd70e 	bge	r5,r4,1aa30 <_malloc_trim_r+0x70>
   1aad4:	014000f4 	movhi	r5,3
   1aad8:	294d2d04 	addi	r5,r5,13492
   1aadc:	29400017 	ldw	r5,0(r5)
   1aae0:	21000054 	ori	r4,r4,1
   1aae4:	19000115 	stw	r4,4(r3)
   1aae8:	1145c83a 	sub	r2,r2,r5
   1aaec:	01400134 	movhi	r5,4
   1aaf0:	294d4b04 	addi	r5,r5,13612
   1aaf4:	28800015 	stw	r2,0(r5)
   1aaf8:	003fcd06 	br	1aa30 <_malloc_trim_r+0x70>

0001aafc <_free_r>:
   1aafc:	defffd04 	addi	sp,sp,-12
   1ab00:	dc400115 	stw	r17,4(sp)
   1ab04:	dc000015 	stw	r16,0(sp)
   1ab08:	dfc00215 	stw	ra,8(sp)
   1ab0c:	2821883a 	mov	r16,r5
   1ab10:	2023883a 	mov	r17,r4
   1ab14:	28004b26 	beq	r5,zero,1ac44 <_free_r+0x148>
   1ab18:	00202d40 	call	202d4 <__malloc_lock>
   1ab1c:	823fff17 	ldw	r8,-4(r16)
   1ab20:	00bfff84 	movi	r2,-2
   1ab24:	81bffe04 	addi	r6,r16,-8
   1ab28:	4084703a 	and	r2,r8,r2
   1ab2c:	3087883a 	add	r3,r6,r2
   1ab30:	014000f4 	movhi	r5,3
   1ab34:	2945bc04 	addi	r5,r5,5872
   1ab38:	1a400117 	ldw	r9,4(r3)
   1ab3c:	29000217 	ldw	r4,8(r5)
   1ab40:	01ffff04 	movi	r7,-4
   1ab44:	49ce703a 	and	r7,r9,r7
   1ab48:	20c06526 	beq	r4,r3,1ace0 <_free_r+0x1e4>
   1ab4c:	19c00115 	stw	r7,4(r3)
   1ab50:	4200004c 	andi	r8,r8,1
   1ab54:	40003026 	beq	r8,zero,1ac18 <_free_r+0x11c>
   1ab58:	0009883a 	mov	r4,zero
   1ab5c:	19d1883a 	add	r8,r3,r7
   1ab60:	42000117 	ldw	r8,4(r8)
   1ab64:	4200004c 	andi	r8,r8,1
   1ab68:	4000061e 	bne	r8,zero,1ab84 <_free_r+0x88>
   1ab6c:	11c5883a 	add	r2,r2,r7
   1ab70:	19c00217 	ldw	r7,8(r3)
   1ab74:	20004e26 	beq	r4,zero,1acb0 <_free_r+0x1b4>
   1ab78:	18c00317 	ldw	r3,12(r3)
   1ab7c:	38c00315 	stw	r3,12(r7)
   1ab80:	19c00215 	stw	r7,8(r3)
   1ab84:	11c00054 	ori	r7,r2,1
   1ab88:	3087883a 	add	r3,r6,r2
   1ab8c:	31c00115 	stw	r7,4(r6)
   1ab90:	18800015 	stw	r2,0(r3)
   1ab94:	20001a1e 	bne	r4,zero,1ac00 <_free_r+0x104>
   1ab98:	00c07fc4 	movi	r3,511
   1ab9c:	18802e2e 	bgeu	r3,r2,1ac58 <_free_r+0x15c>
   1aba0:	1006d27a 	srli	r3,r2,9
   1aba4:	01000104 	movi	r4,4
   1aba8:	20c06636 	bltu	r4,r3,1ad44 <_free_r+0x248>
   1abac:	1008d1ba 	srli	r4,r2,6
   1abb0:	21000e04 	addi	r4,r4,56
   1abb4:	210f883a 	add	r7,r4,r4
   1abb8:	39cf883a 	add	r7,r7,r7
   1abbc:	39cf883a 	add	r7,r7,r7
   1abc0:	29cf883a 	add	r7,r5,r7
   1abc4:	38c00217 	ldw	r3,8(r7)
   1abc8:	014000f4 	movhi	r5,3
   1abcc:	2945bc04 	addi	r5,r5,5872
   1abd0:	19c06126 	beq	r3,r7,1ad58 <_free_r+0x25c>
   1abd4:	013fff04 	movi	r4,-4
   1abd8:	19400117 	ldw	r5,4(r3)
   1abdc:	290a703a 	and	r5,r5,r4
   1abe0:	1140022e 	bgeu	r2,r5,1abec <_free_r+0xf0>
   1abe4:	18c00217 	ldw	r3,8(r3)
   1abe8:	38fffb1e 	bne	r7,r3,1abd8 <_free_r+0xdc>
   1abec:	18800317 	ldw	r2,12(r3)
   1abf0:	30800315 	stw	r2,12(r6)
   1abf4:	30c00215 	stw	r3,8(r6)
   1abf8:	11800215 	stw	r6,8(r2)
   1abfc:	19800315 	stw	r6,12(r3)
   1ac00:	8809883a 	mov	r4,r17
   1ac04:	dfc00217 	ldw	ra,8(sp)
   1ac08:	dc400117 	ldw	r17,4(sp)
   1ac0c:	dc000017 	ldw	r16,0(sp)
   1ac10:	dec00304 	addi	sp,sp,12
   1ac14:	00202f41 	jmpi	202f4 <__malloc_unlock>
   1ac18:	813ffe17 	ldw	r4,-8(r16)
   1ac1c:	2a400204 	addi	r9,r5,8
   1ac20:	310dc83a 	sub	r6,r6,r4
   1ac24:	32000217 	ldw	r8,8(r6)
   1ac28:	1105883a 	add	r2,r2,r4
   1ac2c:	42404326 	beq	r8,r9,1ad3c <_free_r+0x240>
   1ac30:	32400317 	ldw	r9,12(r6)
   1ac34:	0009883a 	mov	r4,zero
   1ac38:	42400315 	stw	r9,12(r8)
   1ac3c:	4a000215 	stw	r8,8(r9)
   1ac40:	003fc606 	br	1ab5c <_free_r+0x60>
   1ac44:	dfc00217 	ldw	ra,8(sp)
   1ac48:	dc400117 	ldw	r17,4(sp)
   1ac4c:	dc000017 	ldw	r16,0(sp)
   1ac50:	dec00304 	addi	sp,sp,12
   1ac54:	f800283a 	ret
   1ac58:	1004d0fa 	srli	r2,r2,3
   1ac5c:	02000044 	movi	r8,1
   1ac60:	29c00117 	ldw	r7,4(r5)
   1ac64:	1087883a 	add	r3,r2,r2
   1ac68:	18c7883a 	add	r3,r3,r3
   1ac6c:	1005d0ba 	srai	r2,r2,2
   1ac70:	18c7883a 	add	r3,r3,r3
   1ac74:	28c7883a 	add	r3,r5,r3
   1ac78:	19000217 	ldw	r4,8(r3)
   1ac7c:	4084983a 	sll	r2,r8,r2
   1ac80:	30c00315 	stw	r3,12(r6)
   1ac84:	31000215 	stw	r4,8(r6)
   1ac88:	11c4b03a 	or	r2,r2,r7
   1ac8c:	21800315 	stw	r6,12(r4)
   1ac90:	8809883a 	mov	r4,r17
   1ac94:	28800115 	stw	r2,4(r5)
   1ac98:	19800215 	stw	r6,8(r3)
   1ac9c:	dfc00217 	ldw	ra,8(sp)
   1aca0:	dc400117 	ldw	r17,4(sp)
   1aca4:	dc000017 	ldw	r16,0(sp)
   1aca8:	dec00304 	addi	sp,sp,12
   1acac:	00202f41 	jmpi	202f4 <__malloc_unlock>
   1acb0:	020000f4 	movhi	r8,3
   1acb4:	4205be04 	addi	r8,r8,5880
   1acb8:	3a3faf1e 	bne	r7,r8,1ab78 <_free_r+0x7c>
   1acbc:	29800515 	stw	r6,20(r5)
   1acc0:	29800415 	stw	r6,16(r5)
   1acc4:	11000054 	ori	r4,r2,1
   1acc8:	3087883a 	add	r3,r6,r2
   1accc:	31c00315 	stw	r7,12(r6)
   1acd0:	31c00215 	stw	r7,8(r6)
   1acd4:	31000115 	stw	r4,4(r6)
   1acd8:	18800015 	stw	r2,0(r3)
   1acdc:	003fc806 	br	1ac00 <_free_r+0x104>
   1ace0:	4200004c 	andi	r8,r8,1
   1ace4:	3885883a 	add	r2,r7,r2
   1ace8:	4000071e 	bne	r8,zero,1ad08 <_free_r+0x20c>
   1acec:	81fffe17 	ldw	r7,-8(r16)
   1acf0:	31cdc83a 	sub	r6,r6,r7
   1acf4:	30c00317 	ldw	r3,12(r6)
   1acf8:	31000217 	ldw	r4,8(r6)
   1acfc:	11c5883a 	add	r2,r2,r7
   1ad00:	20c00315 	stw	r3,12(r4)
   1ad04:	19000215 	stw	r4,8(r3)
   1ad08:	00c000f4 	movhi	r3,3
   1ad0c:	18cd2e04 	addi	r3,r3,13496
   1ad10:	18c00017 	ldw	r3,0(r3)
   1ad14:	11000054 	ori	r4,r2,1
   1ad18:	31000115 	stw	r4,4(r6)
   1ad1c:	29800215 	stw	r6,8(r5)
   1ad20:	10ffb736 	bltu	r2,r3,1ac00 <_free_r+0x104>
   1ad24:	008000f4 	movhi	r2,3
   1ad28:	10961004 	addi	r2,r2,22592
   1ad2c:	11400017 	ldw	r5,0(r2)
   1ad30:	8809883a 	mov	r4,r17
   1ad34:	001a9c00 	call	1a9c0 <_malloc_trim_r>
   1ad38:	003fb106 	br	1ac00 <_free_r+0x104>
   1ad3c:	01000044 	movi	r4,1
   1ad40:	003f8606 	br	1ab5c <_free_r+0x60>
   1ad44:	01000504 	movi	r4,20
   1ad48:	20c00b36 	bltu	r4,r3,1ad78 <_free_r+0x27c>
   1ad4c:	190016c4 	addi	r4,r3,91
   1ad50:	210f883a 	add	r7,r4,r4
   1ad54:	003f9806 	br	1abb8 <_free_r+0xbc>
   1ad58:	2009d0ba 	srai	r4,r4,2
   1ad5c:	00800044 	movi	r2,1
   1ad60:	29c00117 	ldw	r7,4(r5)
   1ad64:	1108983a 	sll	r4,r2,r4
   1ad68:	1805883a 	mov	r2,r3
   1ad6c:	21c8b03a 	or	r4,r4,r7
   1ad70:	29000115 	stw	r4,4(r5)
   1ad74:	003f9e06 	br	1abf0 <_free_r+0xf4>
   1ad78:	01001504 	movi	r4,84
   1ad7c:	20c00436 	bltu	r4,r3,1ad90 <_free_r+0x294>
   1ad80:	1008d33a 	srli	r4,r2,12
   1ad84:	21001b84 	addi	r4,r4,110
   1ad88:	210f883a 	add	r7,r4,r4
   1ad8c:	003f8a06 	br	1abb8 <_free_r+0xbc>
   1ad90:	01005504 	movi	r4,340
   1ad94:	20c00436 	bltu	r4,r3,1ada8 <_free_r+0x2ac>
   1ad98:	1008d3fa 	srli	r4,r2,15
   1ad9c:	21001dc4 	addi	r4,r4,119
   1ada0:	210f883a 	add	r7,r4,r4
   1ada4:	003f8406 	br	1abb8 <_free_r+0xbc>
   1ada8:	01015504 	movi	r4,1364
   1adac:	20c00436 	bltu	r4,r3,1adc0 <_free_r+0x2c4>
   1adb0:	1008d4ba 	srli	r4,r2,18
   1adb4:	21001f04 	addi	r4,r4,124
   1adb8:	210f883a 	add	r7,r4,r4
   1adbc:	003f7e06 	br	1abb8 <_free_r+0xbc>
   1adc0:	01c03f04 	movi	r7,252
   1adc4:	01001f84 	movi	r4,126
   1adc8:	003f7b06 	br	1abb8 <_free_r+0xbc>

0001adcc <__sfvwrite_r>:
   1adcc:	30800217 	ldw	r2,8(r6)
   1add0:	defff504 	addi	sp,sp,-44
   1add4:	dd400615 	stw	r21,24(sp)
   1add8:	dd000515 	stw	r20,20(sp)
   1addc:	dc000115 	stw	r16,4(sp)
   1ade0:	dfc00a15 	stw	ra,40(sp)
   1ade4:	df000915 	stw	fp,36(sp)
   1ade8:	ddc00815 	stw	r23,32(sp)
   1adec:	dd800715 	stw	r22,28(sp)
   1adf0:	dcc00415 	stw	r19,16(sp)
   1adf4:	dc800315 	stw	r18,12(sp)
   1adf8:	dc400215 	stw	r17,8(sp)
   1adfc:	3029883a 	mov	r20,r6
   1ae00:	202b883a 	mov	r21,r4
   1ae04:	2821883a 	mov	r16,r5
   1ae08:	10002126 	beq	r2,zero,1ae90 <__sfvwrite_r+0xc4>
   1ae0c:	2880030b 	ldhu	r2,12(r5)
   1ae10:	10c0020c 	andi	r3,r2,8
   1ae14:	18ffffcc 	andi	r3,r3,65535
   1ae18:	18e0001c 	xori	r3,r3,32768
   1ae1c:	18e00004 	addi	r3,r3,-32768
   1ae20:	18002826 	beq	r3,zero,1aec4 <__sfvwrite_r+0xf8>
   1ae24:	28c00417 	ldw	r3,16(r5)
   1ae28:	18002626 	beq	r3,zero,1aec4 <__sfvwrite_r+0xf8>
   1ae2c:	10c0008c 	andi	r3,r2,2
   1ae30:	18ffffcc 	andi	r3,r3,65535
   1ae34:	18e0001c 	xori	r3,r3,32768
   1ae38:	18e00004 	addi	r3,r3,-32768
   1ae3c:	a4400017 	ldw	r17,0(r20)
   1ae40:	18002b26 	beq	r3,zero,1aef0 <__sfvwrite_r+0x124>
   1ae44:	0027883a 	mov	r19,zero
   1ae48:	0025883a 	mov	r18,zero
   1ae4c:	05810004 	movi	r22,1024
   1ae50:	980d883a 	mov	r6,r19
   1ae54:	a809883a 	mov	r4,r21
   1ae58:	90004f26 	beq	r18,zero,1af98 <__sfvwrite_r+0x1cc>
   1ae5c:	900f883a 	mov	r7,r18
   1ae60:	81400717 	ldw	r5,28(r16)
   1ae64:	b480012e 	bgeu	r22,r18,1ae6c <__sfvwrite_r+0xa0>
   1ae68:	01c10004 	movi	r7,1024
   1ae6c:	80800917 	ldw	r2,36(r16)
   1ae70:	103ee83a 	callr	r2
   1ae74:	0080540e 	bge	zero,r2,1afc8 <__sfvwrite_r+0x1fc>
   1ae78:	a0c00217 	ldw	r3,8(r20)
   1ae7c:	98a7883a 	add	r19,r19,r2
   1ae80:	90a5c83a 	sub	r18,r18,r2
   1ae84:	1885c83a 	sub	r2,r3,r2
   1ae88:	a0800215 	stw	r2,8(r20)
   1ae8c:	103ff01e 	bne	r2,zero,1ae50 <__sfvwrite_r+0x84>
   1ae90:	0005883a 	mov	r2,zero
   1ae94:	dfc00a17 	ldw	ra,40(sp)
   1ae98:	df000917 	ldw	fp,36(sp)
   1ae9c:	ddc00817 	ldw	r23,32(sp)
   1aea0:	dd800717 	ldw	r22,28(sp)
   1aea4:	dd400617 	ldw	r21,24(sp)
   1aea8:	dd000517 	ldw	r20,20(sp)
   1aeac:	dcc00417 	ldw	r19,16(sp)
   1aeb0:	dc800317 	ldw	r18,12(sp)
   1aeb4:	dc400217 	ldw	r17,8(sp)
   1aeb8:	dc000117 	ldw	r16,4(sp)
   1aebc:	dec00b04 	addi	sp,sp,44
   1aec0:	f800283a 	ret
   1aec4:	a809883a 	mov	r4,r21
   1aec8:	800b883a 	mov	r5,r16
   1aecc:	0018b380 	call	18b38 <__swsetup_r>
   1aed0:	1000f01e 	bne	r2,zero,1b294 <__sfvwrite_r+0x4c8>
   1aed4:	8080030b 	ldhu	r2,12(r16)
   1aed8:	a4400017 	ldw	r17,0(r20)
   1aedc:	10c0008c 	andi	r3,r2,2
   1aee0:	18ffffcc 	andi	r3,r3,65535
   1aee4:	18e0001c 	xori	r3,r3,32768
   1aee8:	18e00004 	addi	r3,r3,-32768
   1aeec:	183fd51e 	bne	r3,zero,1ae44 <__sfvwrite_r+0x78>
   1aef0:	10c0004c 	andi	r3,r2,1
   1aef4:	002d883a 	mov	r22,zero
   1aef8:	1800381e 	bne	r3,zero,1afdc <__sfvwrite_r+0x210>
   1aefc:	0025883a 	mov	r18,zero
   1af00:	90002126 	beq	r18,zero,1af88 <__sfvwrite_r+0x1bc>
   1af04:	10c0800c 	andi	r3,r2,512
   1af08:	18ffffcc 	andi	r3,r3,65535
   1af0c:	18e0001c 	xori	r3,r3,32768
   1af10:	18e00004 	addi	r3,r3,-32768
   1af14:	84c00217 	ldw	r19,8(r16)
   1af18:	18006b26 	beq	r3,zero,1b0c8 <__sfvwrite_r+0x2fc>
   1af1c:	980f883a 	mov	r7,r19
   1af20:	94c08636 	bltu	r18,r19,1b13c <__sfvwrite_r+0x370>
   1af24:	10c1200c 	andi	r3,r2,1152
   1af28:	18009f1e 	bne	r3,zero,1b1a8 <__sfvwrite_r+0x3dc>
   1af2c:	81000017 	ldw	r4,0(r16)
   1af30:	982f883a 	mov	r23,r19
   1af34:	9039883a 	mov	fp,r18
   1af38:	9027883a 	mov	r19,r18
   1af3c:	380d883a 	mov	r6,r7
   1af40:	b00b883a 	mov	r5,r22
   1af44:	d9c00015 	stw	r7,0(sp)
   1af48:	001bf100 	call	1bf10 <memmove>
   1af4c:	d9c00017 	ldw	r7,0(sp)
   1af50:	81000217 	ldw	r4,8(r16)
   1af54:	80800017 	ldw	r2,0(r16)
   1af58:	25efc83a 	sub	r23,r4,r23
   1af5c:	11cf883a 	add	r7,r2,r7
   1af60:	85c00215 	stw	r23,8(r16)
   1af64:	81c00015 	stw	r7,0(r16)
   1af68:	a0800217 	ldw	r2,8(r20)
   1af6c:	b72d883a 	add	r22,r22,fp
   1af70:	9725c83a 	sub	r18,r18,fp
   1af74:	14e7c83a 	sub	r19,r2,r19
   1af78:	a4c00215 	stw	r19,8(r20)
   1af7c:	983fc426 	beq	r19,zero,1ae90 <__sfvwrite_r+0xc4>
   1af80:	8080030b 	ldhu	r2,12(r16)
   1af84:	903fdf1e 	bne	r18,zero,1af04 <__sfvwrite_r+0x138>
   1af88:	8d800017 	ldw	r22,0(r17)
   1af8c:	8c800117 	ldw	r18,4(r17)
   1af90:	8c400204 	addi	r17,r17,8
   1af94:	003fda06 	br	1af00 <__sfvwrite_r+0x134>
   1af98:	8cc00017 	ldw	r19,0(r17)
   1af9c:	8c800117 	ldw	r18,4(r17)
   1afa0:	8c400204 	addi	r17,r17,8
   1afa4:	003faa06 	br	1ae50 <__sfvwrite_r+0x84>
   1afa8:	001cfe00 	call	1cfe0 <_realloc_r>
   1afac:	102f883a 	mov	r23,r2
   1afb0:	10009f1e 	bne	r2,zero,1b230 <__sfvwrite_r+0x464>
   1afb4:	81400417 	ldw	r5,16(r16)
   1afb8:	a809883a 	mov	r4,r21
   1afbc:	001aafc0 	call	1aafc <_free_r>
   1afc0:	00800304 	movi	r2,12
   1afc4:	a8800015 	stw	r2,0(r21)
   1afc8:	80c0030b 	ldhu	r3,12(r16)
   1afcc:	00bfffc4 	movi	r2,-1
   1afd0:	18c01014 	ori	r3,r3,64
   1afd4:	80c0030d 	sth	r3,12(r16)
   1afd8:	003fae06 	br	1ae94 <__sfvwrite_r+0xc8>
   1afdc:	0007883a 	mov	r3,zero
   1afe0:	0039883a 	mov	fp,zero
   1afe4:	0025883a 	mov	r18,zero
   1afe8:	90001e26 	beq	r18,zero,1b064 <__sfvwrite_r+0x298>
   1afec:	18006526 	beq	r3,zero,1b184 <__sfvwrite_r+0x3b8>
   1aff0:	b02f883a 	mov	r23,r22
   1aff4:	9580012e 	bgeu	r18,r22,1affc <__sfvwrite_r+0x230>
   1aff8:	902f883a 	mov	r23,r18
   1affc:	81000017 	ldw	r4,0(r16)
   1b000:	80800417 	ldw	r2,16(r16)
   1b004:	84c00217 	ldw	r19,8(r16)
   1b008:	81c00517 	ldw	r7,20(r16)
   1b00c:	1100022e 	bgeu	r2,r4,1b018 <__sfvwrite_r+0x24c>
   1b010:	99e7883a 	add	r19,r19,r7
   1b014:	9dc01816 	blt	r19,r23,1b078 <__sfvwrite_r+0x2ac>
   1b018:	b9c03b16 	blt	r23,r7,1b108 <__sfvwrite_r+0x33c>
   1b01c:	80800917 	ldw	r2,36(r16)
   1b020:	81400717 	ldw	r5,28(r16)
   1b024:	a809883a 	mov	r4,r21
   1b028:	d8c00015 	stw	r3,0(sp)
   1b02c:	e00d883a 	mov	r6,fp
   1b030:	103ee83a 	callr	r2
   1b034:	1027883a 	mov	r19,r2
   1b038:	d8c00017 	ldw	r3,0(sp)
   1b03c:	00bfe20e 	bge	zero,r2,1afc8 <__sfvwrite_r+0x1fc>
   1b040:	b4edc83a 	sub	r22,r22,r19
   1b044:	b0001a26 	beq	r22,zero,1b0b0 <__sfvwrite_r+0x2e4>
   1b048:	a0800217 	ldw	r2,8(r20)
   1b04c:	e4f9883a 	add	fp,fp,r19
   1b050:	94e5c83a 	sub	r18,r18,r19
   1b054:	14e7c83a 	sub	r19,r2,r19
   1b058:	a4c00215 	stw	r19,8(r20)
   1b05c:	983f8c26 	beq	r19,zero,1ae90 <__sfvwrite_r+0xc4>
   1b060:	903fe21e 	bne	r18,zero,1afec <__sfvwrite_r+0x220>
   1b064:	8f000017 	ldw	fp,0(r17)
   1b068:	8c800117 	ldw	r18,4(r17)
   1b06c:	0007883a 	mov	r3,zero
   1b070:	8c400204 	addi	r17,r17,8
   1b074:	003fdc06 	br	1afe8 <__sfvwrite_r+0x21c>
   1b078:	e00b883a 	mov	r5,fp
   1b07c:	980d883a 	mov	r6,r19
   1b080:	d8c00015 	stw	r3,0(sp)
   1b084:	001bf100 	call	1bf10 <memmove>
   1b088:	80800017 	ldw	r2,0(r16)
   1b08c:	a809883a 	mov	r4,r21
   1b090:	800b883a 	mov	r5,r16
   1b094:	14c5883a 	add	r2,r2,r19
   1b098:	80800015 	stw	r2,0(r16)
   1b09c:	001a4d00 	call	1a4d0 <_fflush_r>
   1b0a0:	d8c00017 	ldw	r3,0(sp)
   1b0a4:	103fc81e 	bne	r2,zero,1afc8 <__sfvwrite_r+0x1fc>
   1b0a8:	b4edc83a 	sub	r22,r22,r19
   1b0ac:	b03fe61e 	bne	r22,zero,1b048 <__sfvwrite_r+0x27c>
   1b0b0:	a809883a 	mov	r4,r21
   1b0b4:	800b883a 	mov	r5,r16
   1b0b8:	001a4d00 	call	1a4d0 <_fflush_r>
   1b0bc:	103fc21e 	bne	r2,zero,1afc8 <__sfvwrite_r+0x1fc>
   1b0c0:	0007883a 	mov	r3,zero
   1b0c4:	003fe006 	br	1b048 <__sfvwrite_r+0x27c>
   1b0c8:	81000017 	ldw	r4,0(r16)
   1b0cc:	80800417 	ldw	r2,16(r16)
   1b0d0:	1100022e 	bgeu	r2,r4,1b0dc <__sfvwrite_r+0x310>
   1b0d4:	9839883a 	mov	fp,r19
   1b0d8:	9c806036 	bltu	r19,r18,1b25c <__sfvwrite_r+0x490>
   1b0dc:	81c00517 	ldw	r7,20(r16)
   1b0e0:	91c01c36 	bltu	r18,r7,1b154 <__sfvwrite_r+0x388>
   1b0e4:	80800917 	ldw	r2,36(r16)
   1b0e8:	81400717 	ldw	r5,28(r16)
   1b0ec:	a809883a 	mov	r4,r21
   1b0f0:	b00d883a 	mov	r6,r22
   1b0f4:	103ee83a 	callr	r2
   1b0f8:	1027883a 	mov	r19,r2
   1b0fc:	00bfb20e 	bge	zero,r2,1afc8 <__sfvwrite_r+0x1fc>
   1b100:	1039883a 	mov	fp,r2
   1b104:	003f9806 	br	1af68 <__sfvwrite_r+0x19c>
   1b108:	b80d883a 	mov	r6,r23
   1b10c:	e00b883a 	mov	r5,fp
   1b110:	d8c00015 	stw	r3,0(sp)
   1b114:	001bf100 	call	1bf10 <memmove>
   1b118:	80800217 	ldw	r2,8(r16)
   1b11c:	81000017 	ldw	r4,0(r16)
   1b120:	b827883a 	mov	r19,r23
   1b124:	15c5c83a 	sub	r2,r2,r23
   1b128:	25ef883a 	add	r23,r4,r23
   1b12c:	80800215 	stw	r2,8(r16)
   1b130:	85c00015 	stw	r23,0(r16)
   1b134:	d8c00017 	ldw	r3,0(sp)
   1b138:	003fc106 	br	1b040 <__sfvwrite_r+0x274>
   1b13c:	81000017 	ldw	r4,0(r16)
   1b140:	902f883a 	mov	r23,r18
   1b144:	9039883a 	mov	fp,r18
   1b148:	9027883a 	mov	r19,r18
   1b14c:	900f883a 	mov	r7,r18
   1b150:	003f7a06 	br	1af3c <__sfvwrite_r+0x170>
   1b154:	b00b883a 	mov	r5,r22
   1b158:	900d883a 	mov	r6,r18
   1b15c:	001bf100 	call	1bf10 <memmove>
   1b160:	80c00217 	ldw	r3,8(r16)
   1b164:	80800017 	ldw	r2,0(r16)
   1b168:	9027883a 	mov	r19,r18
   1b16c:	1c87c83a 	sub	r3,r3,r18
   1b170:	1485883a 	add	r2,r2,r18
   1b174:	80c00215 	stw	r3,8(r16)
   1b178:	80800015 	stw	r2,0(r16)
   1b17c:	9039883a 	mov	fp,r18
   1b180:	003f7906 	br	1af68 <__sfvwrite_r+0x19c>
   1b184:	e009883a 	mov	r4,fp
   1b188:	01400284 	movi	r5,10
   1b18c:	900d883a 	mov	r6,r18
   1b190:	001be180 	call	1be18 <memchr>
   1b194:	10003c26 	beq	r2,zero,1b288 <__sfvwrite_r+0x4bc>
   1b198:	15800044 	addi	r22,r2,1
   1b19c:	b72dc83a 	sub	r22,r22,fp
   1b1a0:	00c00044 	movi	r3,1
   1b1a4:	003f9206 	br	1aff0 <__sfvwrite_r+0x224>
   1b1a8:	81000517 	ldw	r4,20(r16)
   1b1ac:	81400417 	ldw	r5,16(r16)
   1b1b0:	80c00017 	ldw	r3,0(r16)
   1b1b4:	210d883a 	add	r6,r4,r4
   1b1b8:	3109883a 	add	r4,r6,r4
   1b1bc:	2026d7fa 	srli	r19,r4,31
   1b1c0:	1979c83a 	sub	fp,r3,r5
   1b1c4:	e1800044 	addi	r6,fp,1
   1b1c8:	9909883a 	add	r4,r19,r4
   1b1cc:	2027d07a 	srai	r19,r4,1
   1b1d0:	3489883a 	add	r4,r6,r18
   1b1d4:	980d883a 	mov	r6,r19
   1b1d8:	9900022e 	bgeu	r19,r4,1b1e4 <__sfvwrite_r+0x418>
   1b1dc:	2027883a 	mov	r19,r4
   1b1e0:	200d883a 	mov	r6,r4
   1b1e4:	1081000c 	andi	r2,r2,1024
   1b1e8:	10bfffcc 	andi	r2,r2,65535
   1b1ec:	10a0001c 	xori	r2,r2,32768
   1b1f0:	10a00004 	addi	r2,r2,-32768
   1b1f4:	a809883a 	mov	r4,r21
   1b1f8:	103f6b26 	beq	r2,zero,1afa8 <__sfvwrite_r+0x1dc>
   1b1fc:	300b883a 	mov	r5,r6
   1b200:	001b6940 	call	1b694 <_malloc_r>
   1b204:	102f883a 	mov	r23,r2
   1b208:	103f6d26 	beq	r2,zero,1afc0 <__sfvwrite_r+0x1f4>
   1b20c:	81400417 	ldw	r5,16(r16)
   1b210:	1009883a 	mov	r4,r2
   1b214:	e00d883a 	mov	r6,fp
   1b218:	00164c00 	call	164c0 <memcpy>
   1b21c:	8080030b 	ldhu	r2,12(r16)
   1b220:	00fedfc4 	movi	r3,-1153
   1b224:	10c4703a 	and	r2,r2,r3
   1b228:	10802014 	ori	r2,r2,128
   1b22c:	8080030d 	sth	r2,12(r16)
   1b230:	bf09883a 	add	r4,r23,fp
   1b234:	9f07c83a 	sub	r3,r19,fp
   1b238:	85c00415 	stw	r23,16(r16)
   1b23c:	84c00515 	stw	r19,20(r16)
   1b240:	81000015 	stw	r4,0(r16)
   1b244:	902f883a 	mov	r23,r18
   1b248:	80c00215 	stw	r3,8(r16)
   1b24c:	9039883a 	mov	fp,r18
   1b250:	9027883a 	mov	r19,r18
   1b254:	900f883a 	mov	r7,r18
   1b258:	003f3806 	br	1af3c <__sfvwrite_r+0x170>
   1b25c:	b00b883a 	mov	r5,r22
   1b260:	980d883a 	mov	r6,r19
   1b264:	001bf100 	call	1bf10 <memmove>
   1b268:	80800017 	ldw	r2,0(r16)
   1b26c:	a809883a 	mov	r4,r21
   1b270:	800b883a 	mov	r5,r16
   1b274:	14c5883a 	add	r2,r2,r19
   1b278:	80800015 	stw	r2,0(r16)
   1b27c:	001a4d00 	call	1a4d0 <_fflush_r>
   1b280:	103f3926 	beq	r2,zero,1af68 <__sfvwrite_r+0x19c>
   1b284:	003f5006 	br	1afc8 <__sfvwrite_r+0x1fc>
   1b288:	95800044 	addi	r22,r18,1
   1b28c:	00c00044 	movi	r3,1
   1b290:	003f5706 	br	1aff0 <__sfvwrite_r+0x224>
   1b294:	80c0030b 	ldhu	r3,12(r16)
   1b298:	00bfffc4 	movi	r2,-1
   1b29c:	18c01014 	ori	r3,r3,64
   1b2a0:	80c0030d 	sth	r3,12(r16)
   1b2a4:	00c00244 	movi	r3,9
   1b2a8:	a8c00015 	stw	r3,0(r21)
   1b2ac:	003ef906 	br	1ae94 <__sfvwrite_r+0xc8>

0001b2b0 <_fwalk>:
   1b2b0:	defff904 	addi	sp,sp,-28
   1b2b4:	dcc00315 	stw	r19,12(sp)
   1b2b8:	24c0b804 	addi	r19,r4,736
   1b2bc:	dd400515 	stw	r21,20(sp)
   1b2c0:	dd000415 	stw	r20,16(sp)
   1b2c4:	dfc00615 	stw	ra,24(sp)
   1b2c8:	dc800215 	stw	r18,8(sp)
   1b2cc:	dc400115 	stw	r17,4(sp)
   1b2d0:	dc000015 	stw	r16,0(sp)
   1b2d4:	282b883a 	mov	r21,r5
   1b2d8:	0029883a 	mov	r20,zero
   1b2dc:	001a9800 	call	1a980 <__sfp_lock_acquire>
   1b2e0:	98001226 	beq	r19,zero,1b32c <_fwalk+0x7c>
   1b2e4:	04bfffc4 	movi	r18,-1
   1b2e8:	9c400117 	ldw	r17,4(r19)
   1b2ec:	9c000217 	ldw	r16,8(r19)
   1b2f0:	8c7fffc4 	addi	r17,r17,-1
   1b2f4:	88000b16 	blt	r17,zero,1b324 <_fwalk+0x74>
   1b2f8:	84000304 	addi	r16,r16,12
   1b2fc:	80c0000f 	ldh	r3,0(r16)
   1b300:	8c7fffc4 	addi	r17,r17,-1
   1b304:	813ffd04 	addi	r4,r16,-12
   1b308:	18000426 	beq	r3,zero,1b31c <_fwalk+0x6c>
   1b30c:	80c0008f 	ldh	r3,2(r16)
   1b310:	1c800226 	beq	r3,r18,1b31c <_fwalk+0x6c>
   1b314:	a83ee83a 	callr	r21
   1b318:	a0a8b03a 	or	r20,r20,r2
   1b31c:	84001704 	addi	r16,r16,92
   1b320:	8cbff61e 	bne	r17,r18,1b2fc <_fwalk+0x4c>
   1b324:	9cc00017 	ldw	r19,0(r19)
   1b328:	983fef1e 	bne	r19,zero,1b2e8 <_fwalk+0x38>
   1b32c:	001a9840 	call	1a984 <__sfp_lock_release>
   1b330:	a005883a 	mov	r2,r20
   1b334:	dfc00617 	ldw	ra,24(sp)
   1b338:	dd400517 	ldw	r21,20(sp)
   1b33c:	dd000417 	ldw	r20,16(sp)
   1b340:	dcc00317 	ldw	r19,12(sp)
   1b344:	dc800217 	ldw	r18,8(sp)
   1b348:	dc400117 	ldw	r17,4(sp)
   1b34c:	dc000017 	ldw	r16,0(sp)
   1b350:	dec00704 	addi	sp,sp,28
   1b354:	f800283a 	ret

0001b358 <_fwalk_reent>:
   1b358:	defff804 	addi	sp,sp,-32
   1b35c:	dcc00315 	stw	r19,12(sp)
   1b360:	24c0b804 	addi	r19,r4,736
   1b364:	dd800615 	stw	r22,24(sp)
   1b368:	dd400515 	stw	r21,20(sp)
   1b36c:	dd000415 	stw	r20,16(sp)
   1b370:	dfc00715 	stw	ra,28(sp)
   1b374:	dc800215 	stw	r18,8(sp)
   1b378:	dc400115 	stw	r17,4(sp)
   1b37c:	dc000015 	stw	r16,0(sp)
   1b380:	2029883a 	mov	r20,r4
   1b384:	282b883a 	mov	r21,r5
   1b388:	002d883a 	mov	r22,zero
   1b38c:	001a9800 	call	1a980 <__sfp_lock_acquire>
   1b390:	98001326 	beq	r19,zero,1b3e0 <_fwalk_reent+0x88>
   1b394:	04bfffc4 	movi	r18,-1
   1b398:	9c400117 	ldw	r17,4(r19)
   1b39c:	9c000217 	ldw	r16,8(r19)
   1b3a0:	8c7fffc4 	addi	r17,r17,-1
   1b3a4:	88000c16 	blt	r17,zero,1b3d8 <_fwalk_reent+0x80>
   1b3a8:	84000304 	addi	r16,r16,12
   1b3ac:	80c0000f 	ldh	r3,0(r16)
   1b3b0:	8c7fffc4 	addi	r17,r17,-1
   1b3b4:	817ffd04 	addi	r5,r16,-12
   1b3b8:	18000526 	beq	r3,zero,1b3d0 <_fwalk_reent+0x78>
   1b3bc:	80c0008f 	ldh	r3,2(r16)
   1b3c0:	a009883a 	mov	r4,r20
   1b3c4:	1c800226 	beq	r3,r18,1b3d0 <_fwalk_reent+0x78>
   1b3c8:	a83ee83a 	callr	r21
   1b3cc:	b0acb03a 	or	r22,r22,r2
   1b3d0:	84001704 	addi	r16,r16,92
   1b3d4:	8cbff51e 	bne	r17,r18,1b3ac <_fwalk_reent+0x54>
   1b3d8:	9cc00017 	ldw	r19,0(r19)
   1b3dc:	983fee1e 	bne	r19,zero,1b398 <_fwalk_reent+0x40>
   1b3e0:	001a9840 	call	1a984 <__sfp_lock_release>
   1b3e4:	b005883a 	mov	r2,r22
   1b3e8:	dfc00717 	ldw	ra,28(sp)
   1b3ec:	dd800617 	ldw	r22,24(sp)
   1b3f0:	dd400517 	ldw	r21,20(sp)
   1b3f4:	dd000417 	ldw	r20,16(sp)
   1b3f8:	dcc00317 	ldw	r19,12(sp)
   1b3fc:	dc800217 	ldw	r18,8(sp)
   1b400:	dc400117 	ldw	r17,4(sp)
   1b404:	dc000017 	ldw	r16,0(sp)
   1b408:	dec00804 	addi	sp,sp,32
   1b40c:	f800283a 	ret

0001b410 <_setlocale_r>:
   1b410:	defffc04 	addi	sp,sp,-16
   1b414:	dc800215 	stw	r18,8(sp)
   1b418:	dc400115 	stw	r17,4(sp)
   1b41c:	dc000015 	stw	r16,0(sp)
   1b420:	dfc00315 	stw	ra,12(sp)
   1b424:	3021883a 	mov	r16,r6
   1b428:	2023883a 	mov	r17,r4
   1b42c:	2825883a 	mov	r18,r5
   1b430:	30001626 	beq	r6,zero,1b48c <_setlocale_r+0x7c>
   1b434:	3009883a 	mov	r4,r6
   1b438:	014000f4 	movhi	r5,3
   1b43c:	297c0904 	addi	r5,r5,-4060
   1b440:	00169640 	call	16964 <strcmp>
   1b444:	10000a1e 	bne	r2,zero,1b470 <_setlocale_r+0x60>
   1b448:	8c800c15 	stw	r18,48(r17)
   1b44c:	8c000d15 	stw	r16,52(r17)
   1b450:	008000f4 	movhi	r2,3
   1b454:	10bc0904 	addi	r2,r2,-4060
   1b458:	dfc00317 	ldw	ra,12(sp)
   1b45c:	dc800217 	ldw	r18,8(sp)
   1b460:	dc400117 	ldw	r17,4(sp)
   1b464:	dc000017 	ldw	r16,0(sp)
   1b468:	dec00404 	addi	sp,sp,16
   1b46c:	f800283a 	ret
   1b470:	8009883a 	mov	r4,r16
   1b474:	014000f4 	movhi	r5,3
   1b478:	297c1304 	addi	r5,r5,-4020
   1b47c:	00169640 	call	16964 <strcmp>
   1b480:	103ff126 	beq	r2,zero,1b448 <_setlocale_r+0x38>
   1b484:	0005883a 	mov	r2,zero
   1b488:	003ff306 	br	1b458 <_setlocale_r+0x48>
   1b48c:	008000f4 	movhi	r2,3
   1b490:	10bc0904 	addi	r2,r2,-4060
   1b494:	dfc00317 	ldw	ra,12(sp)
   1b498:	dc800217 	ldw	r18,8(sp)
   1b49c:	dc400117 	ldw	r17,4(sp)
   1b4a0:	dc000017 	ldw	r16,0(sp)
   1b4a4:	dec00404 	addi	sp,sp,16
   1b4a8:	f800283a 	ret

0001b4ac <__locale_charset>:
   1b4ac:	008000f4 	movhi	r2,3
   1b4b0:	10bc2804 	addi	r2,r2,-3936
   1b4b4:	f800283a 	ret

0001b4b8 <_localeconv_r>:
   1b4b8:	008000f4 	movhi	r2,3
   1b4bc:	10bc2c04 	addi	r2,r2,-3920
   1b4c0:	f800283a 	ret

0001b4c4 <setlocale>:
   1b4c4:	00c000f4 	movhi	r3,3
   1b4c8:	18cd2b04 	addi	r3,r3,13484
   1b4cc:	2005883a 	mov	r2,r4
   1b4d0:	19000017 	ldw	r4,0(r3)
   1b4d4:	280d883a 	mov	r6,r5
   1b4d8:	100b883a 	mov	r5,r2
   1b4dc:	001b4101 	jmpi	1b410 <_setlocale_r>

0001b4e0 <localeconv>:
   1b4e0:	008000f4 	movhi	r2,3
   1b4e4:	10bc2c04 	addi	r2,r2,-3920
   1b4e8:	f800283a 	ret

0001b4ec <__smakebuf_r>:
   1b4ec:	2880030b 	ldhu	r2,12(r5)
   1b4f0:	deffed04 	addi	sp,sp,-76
   1b4f4:	dc401015 	stw	r17,64(sp)
   1b4f8:	10c0008c 	andi	r3,r2,2
   1b4fc:	18ffffcc 	andi	r3,r3,65535
   1b500:	18e0001c 	xori	r3,r3,32768
   1b504:	dc000f15 	stw	r16,60(sp)
   1b508:	dfc01215 	stw	ra,72(sp)
   1b50c:	dc801115 	stw	r18,68(sp)
   1b510:	18e00004 	addi	r3,r3,-32768
   1b514:	2821883a 	mov	r16,r5
   1b518:	2023883a 	mov	r17,r4
   1b51c:	1800381e 	bne	r3,zero,1b600 <__smakebuf_r+0x114>
   1b520:	2940038f 	ldh	r5,14(r5)
   1b524:	28002d16 	blt	r5,zero,1b5dc <__smakebuf_r+0xf0>
   1b528:	d80d883a 	mov	r6,sp
   1b52c:	001dac00 	call	1dac0 <_fstat_r>
   1b530:	10002916 	blt	r2,zero,1b5d8 <__smakebuf_r+0xec>
   1b534:	d8800117 	ldw	r2,4(sp)
   1b538:	00e00014 	movui	r3,32768
   1b53c:	10bc000c 	andi	r2,r2,61440
   1b540:	10c03c26 	beq	r2,r3,1b634 <__smakebuf_r+0x148>
   1b544:	80c0030b 	ldhu	r3,12(r16)
   1b548:	18c20014 	ori	r3,r3,2048
   1b54c:	80c0030d 	sth	r3,12(r16)
   1b550:	00c80004 	movi	r3,8192
   1b554:	10c00c1e 	bne	r2,r3,1b588 <__smakebuf_r+0x9c>
   1b558:	8140038f 	ldh	r5,14(r16)
   1b55c:	8809883a 	mov	r4,r17
   1b560:	001db280 	call	1db28 <_isatty_r>
   1b564:	10000826 	beq	r2,zero,1b588 <__smakebuf_r+0x9c>
   1b568:	80c0030b 	ldhu	r3,12(r16)
   1b56c:	808010c4 	addi	r2,r16,67
   1b570:	80800015 	stw	r2,0(r16)
   1b574:	18c00054 	ori	r3,r3,1
   1b578:	80800415 	stw	r2,16(r16)
   1b57c:	00800044 	movi	r2,1
   1b580:	80c0030d 	sth	r3,12(r16)
   1b584:	80800515 	stw	r2,20(r16)
   1b588:	04810004 	movi	r18,1024
   1b58c:	8809883a 	mov	r4,r17
   1b590:	900b883a 	mov	r5,r18
   1b594:	001b6940 	call	1b694 <_malloc_r>
   1b598:	10003026 	beq	r2,zero,1b65c <__smakebuf_r+0x170>
   1b59c:	80c0030b 	ldhu	r3,12(r16)
   1b5a0:	010000b4 	movhi	r4,2
   1b5a4:	2129be04 	addi	r4,r4,-22792
   1b5a8:	89000f15 	stw	r4,60(r17)
   1b5ac:	18c02014 	ori	r3,r3,128
   1b5b0:	80c0030d 	sth	r3,12(r16)
   1b5b4:	80800015 	stw	r2,0(r16)
   1b5b8:	80800415 	stw	r2,16(r16)
   1b5bc:	84800515 	stw	r18,20(r16)
   1b5c0:	dfc01217 	ldw	ra,72(sp)
   1b5c4:	dc801117 	ldw	r18,68(sp)
   1b5c8:	dc401017 	ldw	r17,64(sp)
   1b5cc:	dc000f17 	ldw	r16,60(sp)
   1b5d0:	dec01304 	addi	sp,sp,76
   1b5d4:	f800283a 	ret
   1b5d8:	8080030b 	ldhu	r2,12(r16)
   1b5dc:	10c0200c 	andi	r3,r2,128
   1b5e0:	18ffffcc 	andi	r3,r3,65535
   1b5e4:	18e0001c 	xori	r3,r3,32768
   1b5e8:	18e00004 	addi	r3,r3,-32768
   1b5ec:	18000f1e 	bne	r3,zero,1b62c <__smakebuf_r+0x140>
   1b5f0:	04810004 	movi	r18,1024
   1b5f4:	10820014 	ori	r2,r2,2048
   1b5f8:	8080030d 	sth	r2,12(r16)
   1b5fc:	003fe306 	br	1b58c <__smakebuf_r+0xa0>
   1b600:	288010c4 	addi	r2,r5,67
   1b604:	28800015 	stw	r2,0(r5)
   1b608:	28800415 	stw	r2,16(r5)
   1b60c:	00800044 	movi	r2,1
   1b610:	28800515 	stw	r2,20(r5)
   1b614:	dfc01217 	ldw	ra,72(sp)
   1b618:	dc801117 	ldw	r18,68(sp)
   1b61c:	dc401017 	ldw	r17,64(sp)
   1b620:	dc000f17 	ldw	r16,60(sp)
   1b624:	dec01304 	addi	sp,sp,76
   1b628:	f800283a 	ret
   1b62c:	04801004 	movi	r18,64
   1b630:	003ff006 	br	1b5f4 <__smakebuf_r+0x108>
   1b634:	81000a17 	ldw	r4,40(r16)
   1b638:	00c000b4 	movhi	r3,2
   1b63c:	18f5e004 	addi	r3,r3,-10368
   1b640:	20ffc01e 	bne	r4,r3,1b544 <__smakebuf_r+0x58>
   1b644:	8080030b 	ldhu	r2,12(r16)
   1b648:	00c10004 	movi	r3,1024
   1b64c:	80c01315 	stw	r3,76(r16)
   1b650:	10c4b03a 	or	r2,r2,r3
   1b654:	8080030d 	sth	r2,12(r16)
   1b658:	003fcb06 	br	1b588 <__smakebuf_r+0x9c>
   1b65c:	8080030b 	ldhu	r2,12(r16)
   1b660:	10c0800c 	andi	r3,r2,512
   1b664:	18ffffcc 	andi	r3,r3,65535
   1b668:	18e0001c 	xori	r3,r3,32768
   1b66c:	18e00004 	addi	r3,r3,-32768
   1b670:	183fd31e 	bne	r3,zero,1b5c0 <__smakebuf_r+0xd4>
   1b674:	10800094 	ori	r2,r2,2
   1b678:	80c010c4 	addi	r3,r16,67
   1b67c:	8080030d 	sth	r2,12(r16)
   1b680:	00800044 	movi	r2,1
   1b684:	80c00015 	stw	r3,0(r16)
   1b688:	80c00415 	stw	r3,16(r16)
   1b68c:	80800515 	stw	r2,20(r16)
   1b690:	003fcb06 	br	1b5c0 <__smakebuf_r+0xd4>

0001b694 <_malloc_r>:
   1b694:	defff604 	addi	sp,sp,-40
   1b698:	dc800215 	stw	r18,8(sp)
   1b69c:	dfc00915 	stw	ra,36(sp)
   1b6a0:	df000815 	stw	fp,32(sp)
   1b6a4:	ddc00715 	stw	r23,28(sp)
   1b6a8:	dd800615 	stw	r22,24(sp)
   1b6ac:	dd400515 	stw	r21,20(sp)
   1b6b0:	dd000415 	stw	r20,16(sp)
   1b6b4:	dcc00315 	stw	r19,12(sp)
   1b6b8:	dc400115 	stw	r17,4(sp)
   1b6bc:	dc000015 	stw	r16,0(sp)
   1b6c0:	288002c4 	addi	r2,r5,11
   1b6c4:	00c00584 	movi	r3,22
   1b6c8:	2025883a 	mov	r18,r4
   1b6cc:	18802b2e 	bgeu	r3,r2,1b77c <_malloc_r+0xe8>
   1b6d0:	047ffe04 	movi	r17,-8
   1b6d4:	1462703a 	and	r17,r2,r17
   1b6d8:	88002a16 	blt	r17,zero,1b784 <_malloc_r+0xf0>
   1b6dc:	89402936 	bltu	r17,r5,1b784 <_malloc_r+0xf0>
   1b6e0:	9009883a 	mov	r4,r18
   1b6e4:	00202d40 	call	202d4 <__malloc_lock>
   1b6e8:	00807dc4 	movi	r2,503
   1b6ec:	14402936 	bltu	r2,r17,1b794 <_malloc_r+0x100>
   1b6f0:	8808d0fa 	srli	r4,r17,3
   1b6f4:	04c000f4 	movhi	r19,3
   1b6f8:	9cc5bc04 	addi	r19,r19,5872
   1b6fc:	2105883a 	add	r2,r4,r4
   1b700:	1085883a 	add	r2,r2,r2
   1b704:	1085883a 	add	r2,r2,r2
   1b708:	9885883a 	add	r2,r19,r2
   1b70c:	14000317 	ldw	r16,12(r2)
   1b710:	80815526 	beq	r16,r2,1bc68 <_malloc_r+0x5d4>
   1b714:	81000117 	ldw	r4,4(r16)
   1b718:	00bfff04 	movi	r2,-4
   1b71c:	80c00317 	ldw	r3,12(r16)
   1b720:	2084703a 	and	r2,r4,r2
   1b724:	8085883a 	add	r2,r16,r2
   1b728:	11800117 	ldw	r6,4(r2)
   1b72c:	81400217 	ldw	r5,8(r16)
   1b730:	9009883a 	mov	r4,r18
   1b734:	31800054 	ori	r6,r6,1
   1b738:	11800115 	stw	r6,4(r2)
   1b73c:	28c00315 	stw	r3,12(r5)
   1b740:	19400215 	stw	r5,8(r3)
   1b744:	00202f40 	call	202f4 <__malloc_unlock>
   1b748:	80800204 	addi	r2,r16,8
   1b74c:	dfc00917 	ldw	ra,36(sp)
   1b750:	df000817 	ldw	fp,32(sp)
   1b754:	ddc00717 	ldw	r23,28(sp)
   1b758:	dd800617 	ldw	r22,24(sp)
   1b75c:	dd400517 	ldw	r21,20(sp)
   1b760:	dd000417 	ldw	r20,16(sp)
   1b764:	dcc00317 	ldw	r19,12(sp)
   1b768:	dc800217 	ldw	r18,8(sp)
   1b76c:	dc400117 	ldw	r17,4(sp)
   1b770:	dc000017 	ldw	r16,0(sp)
   1b774:	dec00a04 	addi	sp,sp,40
   1b778:	f800283a 	ret
   1b77c:	04400404 	movi	r17,16
   1b780:	897fd72e 	bgeu	r17,r5,1b6e0 <_malloc_r+0x4c>
   1b784:	00800304 	movi	r2,12
   1b788:	90800015 	stw	r2,0(r18)
   1b78c:	0005883a 	mov	r2,zero
   1b790:	003fee06 	br	1b74c <_malloc_r+0xb8>
   1b794:	8808d27a 	srli	r4,r17,9
   1b798:	20007126 	beq	r4,zero,1b960 <_malloc_r+0x2cc>
   1b79c:	00800104 	movi	r2,4
   1b7a0:	1100eb36 	bltu	r2,r4,1bb50 <_malloc_r+0x4bc>
   1b7a4:	8808d1ba 	srli	r4,r17,6
   1b7a8:	21000e04 	addi	r4,r4,56
   1b7ac:	210b883a 	add	r5,r4,r4
   1b7b0:	294b883a 	add	r5,r5,r5
   1b7b4:	294b883a 	add	r5,r5,r5
   1b7b8:	04c000f4 	movhi	r19,3
   1b7bc:	9cc5bc04 	addi	r19,r19,5872
   1b7c0:	994b883a 	add	r5,r19,r5
   1b7c4:	2c000317 	ldw	r16,12(r5)
   1b7c8:	2c000e26 	beq	r5,r16,1b804 <_malloc_r+0x170>
   1b7cc:	80c00117 	ldw	r3,4(r16)
   1b7d0:	01ffff04 	movi	r7,-4
   1b7d4:	018003c4 	movi	r6,15
   1b7d8:	19c6703a 	and	r3,r3,r7
   1b7dc:	1c45c83a 	sub	r2,r3,r17
   1b7e0:	30800716 	blt	r6,r2,1b800 <_malloc_r+0x16c>
   1b7e4:	1000610e 	bge	r2,zero,1b96c <_malloc_r+0x2d8>
   1b7e8:	84000317 	ldw	r16,12(r16)
   1b7ec:	2c000526 	beq	r5,r16,1b804 <_malloc_r+0x170>
   1b7f0:	80c00117 	ldw	r3,4(r16)
   1b7f4:	19c6703a 	and	r3,r3,r7
   1b7f8:	1c45c83a 	sub	r2,r3,r17
   1b7fc:	30bff90e 	bge	r6,r2,1b7e4 <_malloc_r+0x150>
   1b800:	213fffc4 	addi	r4,r4,-1
   1b804:	21000044 	addi	r4,r4,1
   1b808:	9c000417 	ldw	r16,16(r19)
   1b80c:	00c000f4 	movhi	r3,3
   1b810:	18c5bc04 	addi	r3,r3,5872
   1b814:	1a400204 	addi	r9,r3,8
   1b818:	8240ff26 	beq	r16,r9,1bc18 <_malloc_r+0x584>
   1b81c:	81400117 	ldw	r5,4(r16)
   1b820:	00bfff04 	movi	r2,-4
   1b824:	018003c4 	movi	r6,15
   1b828:	2884703a 	and	r2,r5,r2
   1b82c:	144bc83a 	sub	r5,r2,r17
   1b830:	3140ea16 	blt	r6,r5,1bbdc <_malloc_r+0x548>
   1b834:	1a400515 	stw	r9,20(r3)
   1b838:	1a400415 	stw	r9,16(r3)
   1b83c:	2800570e 	bge	r5,zero,1b99c <_malloc_r+0x308>
   1b840:	01407fc4 	movi	r5,511
   1b844:	2880ca36 	bltu	r5,r2,1bb70 <_malloc_r+0x4dc>
   1b848:	1004d0fa 	srli	r2,r2,3
   1b84c:	02000044 	movi	r8,1
   1b850:	19c00117 	ldw	r7,4(r3)
   1b854:	108b883a 	add	r5,r2,r2
   1b858:	294b883a 	add	r5,r5,r5
   1b85c:	1005d0ba 	srai	r2,r2,2
   1b860:	294b883a 	add	r5,r5,r5
   1b864:	28cb883a 	add	r5,r5,r3
   1b868:	29800217 	ldw	r6,8(r5)
   1b86c:	4084983a 	sll	r2,r8,r2
   1b870:	81400315 	stw	r5,12(r16)
   1b874:	81800215 	stw	r6,8(r16)
   1b878:	11c4b03a 	or	r2,r2,r7
   1b87c:	18800115 	stw	r2,4(r3)
   1b880:	2c000215 	stw	r16,8(r5)
   1b884:	34000315 	stw	r16,12(r6)
   1b888:	200bd0ba 	srai	r5,r4,2
   1b88c:	00c00044 	movi	r3,1
   1b890:	194a983a 	sll	r5,r3,r5
   1b894:	11404936 	bltu	r2,r5,1b9bc <_malloc_r+0x328>
   1b898:	1146703a 	and	r3,r2,r5
   1b89c:	18000a1e 	bne	r3,zero,1b8c8 <_malloc_r+0x234>
   1b8a0:	00ffff04 	movi	r3,-4
   1b8a4:	294b883a 	add	r5,r5,r5
   1b8a8:	20c8703a 	and	r4,r4,r3
   1b8ac:	1146703a 	and	r3,r2,r5
   1b8b0:	21000104 	addi	r4,r4,4
   1b8b4:	1800041e 	bne	r3,zero,1b8c8 <_malloc_r+0x234>
   1b8b8:	294b883a 	add	r5,r5,r5
   1b8bc:	1146703a 	and	r3,r2,r5
   1b8c0:	21000104 	addi	r4,r4,4
   1b8c4:	183ffc26 	beq	r3,zero,1b8b8 <_malloc_r+0x224>
   1b8c8:	023fff04 	movi	r8,-4
   1b8cc:	01c003c4 	movi	r7,15
   1b8d0:	2105883a 	add	r2,r4,r4
   1b8d4:	1085883a 	add	r2,r2,r2
   1b8d8:	1085883a 	add	r2,r2,r2
   1b8dc:	9899883a 	add	r12,r19,r2
   1b8e0:	62800304 	addi	r10,r12,12
   1b8e4:	2017883a 	mov	r11,r4
   1b8e8:	54000017 	ldw	r16,0(r10)
   1b8ec:	51bffd04 	addi	r6,r10,-12
   1b8f0:	8180041e 	bne	r16,r6,1b904 <_malloc_r+0x270>
   1b8f4:	0000ca06 	br	1bc20 <_malloc_r+0x58c>
   1b8f8:	10001c0e 	bge	r2,zero,1b96c <_malloc_r+0x2d8>
   1b8fc:	84000317 	ldw	r16,12(r16)
   1b900:	8180c726 	beq	r16,r6,1bc20 <_malloc_r+0x58c>
   1b904:	80c00117 	ldw	r3,4(r16)
   1b908:	1a06703a 	and	r3,r3,r8
   1b90c:	1c45c83a 	sub	r2,r3,r17
   1b910:	38bff90e 	bge	r7,r2,1b8f8 <_malloc_r+0x264>
   1b914:	81000317 	ldw	r4,12(r16)
   1b918:	81400217 	ldw	r5,8(r16)
   1b91c:	8447883a 	add	r3,r16,r17
   1b920:	8c400054 	ori	r17,r17,1
   1b924:	29000315 	stw	r4,12(r5)
   1b928:	21400215 	stw	r5,8(r4)
   1b92c:	84400115 	stw	r17,4(r16)
   1b930:	1889883a 	add	r4,r3,r2
   1b934:	11400054 	ori	r5,r2,1
   1b938:	98c00515 	stw	r3,20(r19)
   1b93c:	98c00415 	stw	r3,16(r19)
   1b940:	20800015 	stw	r2,0(r4)
   1b944:	1a400315 	stw	r9,12(r3)
   1b948:	1a400215 	stw	r9,8(r3)
   1b94c:	19400115 	stw	r5,4(r3)
   1b950:	9009883a 	mov	r4,r18
   1b954:	00202f40 	call	202f4 <__malloc_unlock>
   1b958:	80800204 	addi	r2,r16,8
   1b95c:	003f7b06 	br	1b74c <_malloc_r+0xb8>
   1b960:	8808d0fa 	srli	r4,r17,3
   1b964:	210b883a 	add	r5,r4,r4
   1b968:	003f9106 	br	1b7b0 <_malloc_r+0x11c>
   1b96c:	80c7883a 	add	r3,r16,r3
   1b970:	19400117 	ldw	r5,4(r3)
   1b974:	80800317 	ldw	r2,12(r16)
   1b978:	81000217 	ldw	r4,8(r16)
   1b97c:	29400054 	ori	r5,r5,1
   1b980:	19400115 	stw	r5,4(r3)
   1b984:	20800315 	stw	r2,12(r4)
   1b988:	11000215 	stw	r4,8(r2)
   1b98c:	9009883a 	mov	r4,r18
   1b990:	00202f40 	call	202f4 <__malloc_unlock>
   1b994:	80800204 	addi	r2,r16,8
   1b998:	003f6c06 	br	1b74c <_malloc_r+0xb8>
   1b99c:	8085883a 	add	r2,r16,r2
   1b9a0:	10c00117 	ldw	r3,4(r2)
   1b9a4:	9009883a 	mov	r4,r18
   1b9a8:	18c00054 	ori	r3,r3,1
   1b9ac:	10c00115 	stw	r3,4(r2)
   1b9b0:	00202f40 	call	202f4 <__malloc_unlock>
   1b9b4:	80800204 	addi	r2,r16,8
   1b9b8:	003f6406 	br	1b74c <_malloc_r+0xb8>
   1b9bc:	9c000217 	ldw	r16,8(r19)
   1b9c0:	00bfff04 	movi	r2,-4
   1b9c4:	85400117 	ldw	r21,4(r16)
   1b9c8:	a8aa703a 	and	r21,r21,r2
   1b9cc:	ac400336 	bltu	r21,r17,1b9dc <_malloc_r+0x348>
   1b9d0:	ac45c83a 	sub	r2,r21,r17
   1b9d4:	00c003c4 	movi	r3,15
   1b9d8:	18805316 	blt	r3,r2,1bb28 <_malloc_r+0x494>
   1b9dc:	d5e8f017 	ldw	r23,-23616(gp)
   1b9e0:	d0e00d17 	ldw	r3,-32716(gp)
   1b9e4:	00bfffc4 	movi	r2,-1
   1b9e8:	8579883a 	add	fp,r16,r21
   1b9ec:	8def883a 	add	r23,r17,r23
   1b9f0:	1880d226 	beq	r3,r2,1bd3c <_malloc_r+0x6a8>
   1b9f4:	bdc403c4 	addi	r23,r23,4111
   1b9f8:	00bc0004 	movi	r2,-4096
   1b9fc:	b8ae703a 	and	r23,r23,r2
   1ba00:	9009883a 	mov	r4,r18
   1ba04:	b80b883a 	mov	r5,r23
   1ba08:	001d6400 	call	1d640 <_sbrk_r>
   1ba0c:	1029883a 	mov	r20,r2
   1ba10:	00bfffc4 	movi	r2,-1
   1ba14:	a080d126 	beq	r20,r2,1bd5c <_malloc_r+0x6c8>
   1ba18:	a7009f36 	bltu	r20,fp,1bc98 <_malloc_r+0x604>
   1ba1c:	05800134 	movhi	r22,4
   1ba20:	b58d4b04 	addi	r22,r22,13612
   1ba24:	b0800017 	ldw	r2,0(r22)
   1ba28:	b885883a 	add	r2,r23,r2
   1ba2c:	b0800015 	stw	r2,0(r22)
   1ba30:	e500cf26 	beq	fp,r20,1bd70 <_malloc_r+0x6dc>
   1ba34:	d1200d17 	ldw	r4,-32716(gp)
   1ba38:	00ffffc4 	movi	r3,-1
   1ba3c:	20c0e026 	beq	r4,r3,1bdc0 <_malloc_r+0x72c>
   1ba40:	a739c83a 	sub	fp,r20,fp
   1ba44:	1705883a 	add	r2,r2,fp
   1ba48:	b0800015 	stw	r2,0(r22)
   1ba4c:	a08001cc 	andi	r2,r20,7
   1ba50:	1000a526 	beq	r2,zero,1bce8 <_malloc_r+0x654>
   1ba54:	a0a9c83a 	sub	r20,r20,r2
   1ba58:	00c40204 	movi	r3,4104
   1ba5c:	a5000204 	addi	r20,r20,8
   1ba60:	1885c83a 	sub	r2,r3,r2
   1ba64:	a5c7883a 	add	r3,r20,r23
   1ba68:	18c3ffcc 	andi	r3,r3,4095
   1ba6c:	10efc83a 	sub	r23,r2,r3
   1ba70:	9009883a 	mov	r4,r18
   1ba74:	b80b883a 	mov	r5,r23
   1ba78:	001d6400 	call	1d640 <_sbrk_r>
   1ba7c:	00ffffc4 	movi	r3,-1
   1ba80:	10c0cc26 	beq	r2,r3,1bdb4 <_malloc_r+0x720>
   1ba84:	1505c83a 	sub	r2,r2,r20
   1ba88:	b887883a 	add	r3,r23,r2
   1ba8c:	18c00054 	ori	r3,r3,1
   1ba90:	b0800017 	ldw	r2,0(r22)
   1ba94:	9d000215 	stw	r20,8(r19)
   1ba98:	a0c00115 	stw	r3,4(r20)
   1ba9c:	b885883a 	add	r2,r23,r2
   1baa0:	b0800015 	stw	r2,0(r22)
   1baa4:	84c00e26 	beq	r16,r19,1bae0 <_malloc_r+0x44c>
   1baa8:	00c003c4 	movi	r3,15
   1baac:	1d40902e 	bgeu	r3,r21,1bcf0 <_malloc_r+0x65c>
   1bab0:	ad7ffd04 	addi	r21,r21,-12
   1bab4:	013ffe04 	movi	r4,-8
   1bab8:	a908703a 	and	r4,r21,r4
   1babc:	810b883a 	add	r5,r16,r4
   1bac0:	01800144 	movi	r6,5
   1bac4:	29800115 	stw	r6,4(r5)
   1bac8:	29800215 	stw	r6,8(r5)
   1bacc:	81400117 	ldw	r5,4(r16)
   1bad0:	2940004c 	andi	r5,r5,1
   1bad4:	214ab03a 	or	r5,r4,r5
   1bad8:	81400115 	stw	r5,4(r16)
   1badc:	1900ae36 	bltu	r3,r4,1bd98 <_malloc_r+0x704>
   1bae0:	d0e8ef17 	ldw	r3,-23620(gp)
   1bae4:	1880012e 	bgeu	r3,r2,1baec <_malloc_r+0x458>
   1bae8:	d0a8ef15 	stw	r2,-23620(gp)
   1baec:	d0e8ee17 	ldw	r3,-23624(gp)
   1baf0:	9c000217 	ldw	r16,8(r19)
   1baf4:	1880012e 	bgeu	r3,r2,1bafc <_malloc_r+0x468>
   1baf8:	d0a8ee15 	stw	r2,-23624(gp)
   1bafc:	80c00117 	ldw	r3,4(r16)
   1bb00:	00bfff04 	movi	r2,-4
   1bb04:	1886703a 	and	r3,r3,r2
   1bb08:	1c45c83a 	sub	r2,r3,r17
   1bb0c:	1c400236 	bltu	r3,r17,1bb18 <_malloc_r+0x484>
   1bb10:	00c003c4 	movi	r3,15
   1bb14:	18800416 	blt	r3,r2,1bb28 <_malloc_r+0x494>
   1bb18:	9009883a 	mov	r4,r18
   1bb1c:	00202f40 	call	202f4 <__malloc_unlock>
   1bb20:	0005883a 	mov	r2,zero
   1bb24:	003f0906 	br	1b74c <_malloc_r+0xb8>
   1bb28:	88c00054 	ori	r3,r17,1
   1bb2c:	10800054 	ori	r2,r2,1
   1bb30:	80c00115 	stw	r3,4(r16)
   1bb34:	8463883a 	add	r17,r16,r17
   1bb38:	88800115 	stw	r2,4(r17)
   1bb3c:	9009883a 	mov	r4,r18
   1bb40:	9c400215 	stw	r17,8(r19)
   1bb44:	00202f40 	call	202f4 <__malloc_unlock>
   1bb48:	80800204 	addi	r2,r16,8
   1bb4c:	003eff06 	br	1b74c <_malloc_r+0xb8>
   1bb50:	00800504 	movi	r2,20
   1bb54:	1100492e 	bgeu	r2,r4,1bc7c <_malloc_r+0x5e8>
   1bb58:	00801504 	movi	r2,84
   1bb5c:	11005c36 	bltu	r2,r4,1bcd0 <_malloc_r+0x63c>
   1bb60:	8808d33a 	srli	r4,r17,12
   1bb64:	21001b84 	addi	r4,r4,110
   1bb68:	210b883a 	add	r5,r4,r4
   1bb6c:	003f1006 	br	1b7b0 <_malloc_r+0x11c>
   1bb70:	1006d27a 	srli	r3,r2,9
   1bb74:	01400104 	movi	r5,4
   1bb78:	28c0432e 	bgeu	r5,r3,1bc88 <_malloc_r+0x5f4>
   1bb7c:	01400504 	movi	r5,20
   1bb80:	28c07036 	bltu	r5,r3,1bd44 <_malloc_r+0x6b0>
   1bb84:	194016c4 	addi	r5,r3,91
   1bb88:	294d883a 	add	r6,r5,r5
   1bb8c:	318d883a 	add	r6,r6,r6
   1bb90:	318d883a 	add	r6,r6,r6
   1bb94:	998d883a 	add	r6,r19,r6
   1bb98:	30c00217 	ldw	r3,8(r6)
   1bb9c:	01c000f4 	movhi	r7,3
   1bba0:	39c5bc04 	addi	r7,r7,5872
   1bba4:	19805726 	beq	r3,r6,1bd04 <_malloc_r+0x670>
   1bba8:	01ffff04 	movi	r7,-4
   1bbac:	19400117 	ldw	r5,4(r3)
   1bbb0:	29ca703a 	and	r5,r5,r7
   1bbb4:	1140022e 	bgeu	r2,r5,1bbc0 <_malloc_r+0x52c>
   1bbb8:	18c00217 	ldw	r3,8(r3)
   1bbbc:	30fffb1e 	bne	r6,r3,1bbac <_malloc_r+0x518>
   1bbc0:	19400317 	ldw	r5,12(r3)
   1bbc4:	98800117 	ldw	r2,4(r19)
   1bbc8:	81400315 	stw	r5,12(r16)
   1bbcc:	80c00215 	stw	r3,8(r16)
   1bbd0:	2c000215 	stw	r16,8(r5)
   1bbd4:	1c000315 	stw	r16,12(r3)
   1bbd8:	003f2b06 	br	1b888 <_malloc_r+0x1f4>
   1bbdc:	8445883a 	add	r2,r16,r17
   1bbe0:	8c400054 	ori	r17,r17,1
   1bbe4:	18800515 	stw	r2,20(r3)
   1bbe8:	18800415 	stw	r2,16(r3)
   1bbec:	29000054 	ori	r4,r5,1
   1bbf0:	1147883a 	add	r3,r2,r5
   1bbf4:	84400115 	stw	r17,4(r16)
   1bbf8:	11000115 	stw	r4,4(r2)
   1bbfc:	12400315 	stw	r9,12(r2)
   1bc00:	12400215 	stw	r9,8(r2)
   1bc04:	19400015 	stw	r5,0(r3)
   1bc08:	9009883a 	mov	r4,r18
   1bc0c:	00202f40 	call	202f4 <__malloc_unlock>
   1bc10:	80800204 	addi	r2,r16,8
   1bc14:	003ecd06 	br	1b74c <_malloc_r+0xb8>
   1bc18:	18800117 	ldw	r2,4(r3)
   1bc1c:	003f1a06 	br	1b888 <_malloc_r+0x1f4>
   1bc20:	5ac00044 	addi	r11,r11,1
   1bc24:	588000cc 	andi	r2,r11,3
   1bc28:	52800204 	addi	r10,r10,8
   1bc2c:	103f2e1e 	bne	r2,zero,1b8e8 <_malloc_r+0x254>
   1bc30:	20c000cc 	andi	r3,r4,3
   1bc34:	60bffe04 	addi	r2,r12,-8
   1bc38:	18006f26 	beq	r3,zero,1bdf8 <_malloc_r+0x764>
   1bc3c:	63000017 	ldw	r12,0(r12)
   1bc40:	213fffc4 	addi	r4,r4,-1
   1bc44:	60bffa26 	beq	r12,r2,1bc30 <_malloc_r+0x59c>
   1bc48:	98800117 	ldw	r2,4(r19)
   1bc4c:	294b883a 	add	r5,r5,r5
   1bc50:	117f5a36 	bltu	r2,r5,1b9bc <_malloc_r+0x328>
   1bc54:	283f5926 	beq	r5,zero,1b9bc <_malloc_r+0x328>
   1bc58:	1146703a 	and	r3,r2,r5
   1bc5c:	18001626 	beq	r3,zero,1bcb8 <_malloc_r+0x624>
   1bc60:	5809883a 	mov	r4,r11
   1bc64:	003f1a06 	br	1b8d0 <_malloc_r+0x23c>
   1bc68:	80800204 	addi	r2,r16,8
   1bc6c:	84000517 	ldw	r16,20(r16)
   1bc70:	143ea81e 	bne	r2,r16,1b714 <_malloc_r+0x80>
   1bc74:	21000084 	addi	r4,r4,2
   1bc78:	003ee306 	br	1b808 <_malloc_r+0x174>
   1bc7c:	210016c4 	addi	r4,r4,91
   1bc80:	210b883a 	add	r5,r4,r4
   1bc84:	003eca06 	br	1b7b0 <_malloc_r+0x11c>
   1bc88:	100ad1ba 	srli	r5,r2,6
   1bc8c:	29400e04 	addi	r5,r5,56
   1bc90:	294d883a 	add	r6,r5,r5
   1bc94:	003fbd06 	br	1bb8c <_malloc_r+0x4f8>
   1bc98:	84ff6026 	beq	r16,r19,1ba1c <_malloc_r+0x388>
   1bc9c:	008000f4 	movhi	r2,3
   1bca0:	1085bc04 	addi	r2,r2,5872
   1bca4:	14000217 	ldw	r16,8(r2)
   1bca8:	00bfff04 	movi	r2,-4
   1bcac:	80c00117 	ldw	r3,4(r16)
   1bcb0:	1886703a 	and	r3,r3,r2
   1bcb4:	003f9406 	br	1bb08 <_malloc_r+0x474>
   1bcb8:	294b883a 	add	r5,r5,r5
   1bcbc:	1146703a 	and	r3,r2,r5
   1bcc0:	5ac00104 	addi	r11,r11,4
   1bcc4:	183ffc26 	beq	r3,zero,1bcb8 <_malloc_r+0x624>
   1bcc8:	5809883a 	mov	r4,r11
   1bccc:	003f0006 	br	1b8d0 <_malloc_r+0x23c>
   1bcd0:	00805504 	movi	r2,340
   1bcd4:	11001336 	bltu	r2,r4,1bd24 <_malloc_r+0x690>
   1bcd8:	8808d3fa 	srli	r4,r17,15
   1bcdc:	21001dc4 	addi	r4,r4,119
   1bce0:	210b883a 	add	r5,r4,r4
   1bce4:	003eb206 	br	1b7b0 <_malloc_r+0x11c>
   1bce8:	00840004 	movi	r2,4096
   1bcec:	003f5d06 	br	1ba64 <_malloc_r+0x3d0>
   1bcf0:	00800044 	movi	r2,1
   1bcf4:	a0800115 	stw	r2,4(r20)
   1bcf8:	a021883a 	mov	r16,r20
   1bcfc:	0007883a 	mov	r3,zero
   1bd00:	003f8106 	br	1bb08 <_malloc_r+0x474>
   1bd04:	280bd0ba 	srai	r5,r5,2
   1bd08:	01800044 	movi	r6,1
   1bd0c:	38800117 	ldw	r2,4(r7)
   1bd10:	314c983a 	sll	r6,r6,r5
   1bd14:	180b883a 	mov	r5,r3
   1bd18:	3084b03a 	or	r2,r6,r2
   1bd1c:	38800115 	stw	r2,4(r7)
   1bd20:	003fa906 	br	1bbc8 <_malloc_r+0x534>
   1bd24:	00815504 	movi	r2,1364
   1bd28:	11001836 	bltu	r2,r4,1bd8c <_malloc_r+0x6f8>
   1bd2c:	8808d4ba 	srli	r4,r17,18
   1bd30:	21001f04 	addi	r4,r4,124
   1bd34:	210b883a 	add	r5,r4,r4
   1bd38:	003e9d06 	br	1b7b0 <_malloc_r+0x11c>
   1bd3c:	bdc00404 	addi	r23,r23,16
   1bd40:	003f2f06 	br	1ba00 <_malloc_r+0x36c>
   1bd44:	01401504 	movi	r5,84
   1bd48:	28c01f36 	bltu	r5,r3,1bdc8 <_malloc_r+0x734>
   1bd4c:	100ad33a 	srli	r5,r2,12
   1bd50:	29401b84 	addi	r5,r5,110
   1bd54:	294d883a 	add	r6,r5,r5
   1bd58:	003f8c06 	br	1bb8c <_malloc_r+0x4f8>
   1bd5c:	9c000217 	ldw	r16,8(r19)
   1bd60:	00bfff04 	movi	r2,-4
   1bd64:	80c00117 	ldw	r3,4(r16)
   1bd68:	1886703a 	and	r3,r3,r2
   1bd6c:	003f6606 	br	1bb08 <_malloc_r+0x474>
   1bd70:	e0c3ffcc 	andi	r3,fp,4095
   1bd74:	183f2f1e 	bne	r3,zero,1ba34 <_malloc_r+0x3a0>
   1bd78:	98c00217 	ldw	r3,8(r19)
   1bd7c:	bd49883a 	add	r4,r23,r21
   1bd80:	21000054 	ori	r4,r4,1
   1bd84:	19000115 	stw	r4,4(r3)
   1bd88:	003f5506 	br	1bae0 <_malloc_r+0x44c>
   1bd8c:	01403f04 	movi	r5,252
   1bd90:	01001f84 	movi	r4,126
   1bd94:	003e8606 	br	1b7b0 <_malloc_r+0x11c>
   1bd98:	9009883a 	mov	r4,r18
   1bd9c:	81400204 	addi	r5,r16,8
   1bda0:	001aafc0 	call	1aafc <_free_r>
   1bda4:	00800134 	movhi	r2,4
   1bda8:	108d4b04 	addi	r2,r2,13612
   1bdac:	10800017 	ldw	r2,0(r2)
   1bdb0:	003f4b06 	br	1bae0 <_malloc_r+0x44c>
   1bdb4:	00c00044 	movi	r3,1
   1bdb8:	002f883a 	mov	r23,zero
   1bdbc:	003f3406 	br	1ba90 <_malloc_r+0x3fc>
   1bdc0:	d5200d15 	stw	r20,-32716(gp)
   1bdc4:	003f2106 	br	1ba4c <_malloc_r+0x3b8>
   1bdc8:	01405504 	movi	r5,340
   1bdcc:	28c00436 	bltu	r5,r3,1bde0 <_malloc_r+0x74c>
   1bdd0:	100ad3fa 	srli	r5,r2,15
   1bdd4:	29401dc4 	addi	r5,r5,119
   1bdd8:	294d883a 	add	r6,r5,r5
   1bddc:	003f6b06 	br	1bb8c <_malloc_r+0x4f8>
   1bde0:	01415504 	movi	r5,1364
   1bde4:	28c00936 	bltu	r5,r3,1be0c <_malloc_r+0x778>
   1bde8:	100ad4ba 	srli	r5,r2,18
   1bdec:	29401f04 	addi	r5,r5,124
   1bdf0:	294d883a 	add	r6,r5,r5
   1bdf4:	003f6506 	br	1bb8c <_malloc_r+0x4f8>
   1bdf8:	98800117 	ldw	r2,4(r19)
   1bdfc:	0146303a 	nor	r3,zero,r5
   1be00:	1884703a 	and	r2,r3,r2
   1be04:	98800115 	stw	r2,4(r19)
   1be08:	003f9006 	br	1bc4c <_malloc_r+0x5b8>
   1be0c:	01803f04 	movi	r6,252
   1be10:	01401f84 	movi	r5,126
   1be14:	003f5d06 	br	1bb8c <_malloc_r+0x4f8>

0001be18 <memchr>:
   1be18:	008000c4 	movi	r2,3
   1be1c:	29403fcc 	andi	r5,r5,255
   1be20:	1180282e 	bgeu	r2,r6,1bec4 <memchr+0xac>
   1be24:	2086703a 	and	r3,r4,r2
   1be28:	1800351e 	bne	r3,zero,1bf00 <memchr+0xe8>
   1be2c:	2816923a 	slli	r11,r5,8
   1be30:	2093883a 	add	r9,r4,r2
   1be34:	22000084 	addi	r8,r4,2
   1be38:	5957883a 	add	r11,r11,r5
   1be3c:	5816923a 	slli	r11,r11,8
   1be40:	20c00044 	addi	r3,r4,1
   1be44:	037fbff4 	movhi	r13,65279
   1be48:	6b7fbfc4 	addi	r13,r13,-257
   1be4c:	5957883a 	add	r11,r11,r5
   1be50:	5816923a 	slli	r11,r11,8
   1be54:	03202074 	movhi	r12,32897
   1be58:	63202004 	addi	r12,r12,-32640
   1be5c:	101d883a 	mov	r14,r2
   1be60:	5957883a 	add	r11,r11,r5
   1be64:	21c00017 	ldw	r7,0(r4)
   1be68:	31bfff04 	addi	r6,r6,-4
   1be6c:	1805883a 	mov	r2,r3
   1be70:	3acef03a 	xor	r7,r7,r11
   1be74:	3b55883a 	add	r10,r7,r13
   1be78:	01ce303a 	nor	r7,zero,r7
   1be7c:	51ce703a 	and	r7,r10,r7
   1be80:	3b0e703a 	and	r7,r7,r12
   1be84:	38000a26 	beq	r7,zero,1beb0 <memchr+0x98>
   1be88:	21c00003 	ldbu	r7,0(r4)
   1be8c:	39401e26 	beq	r7,r5,1bf08 <memchr+0xf0>
   1be90:	19c00003 	ldbu	r7,0(r3)
   1be94:	39401926 	beq	r7,r5,1befc <memchr+0xe4>
   1be98:	41c00003 	ldbu	r7,0(r8)
   1be9c:	4005883a 	mov	r2,r8
   1bea0:	39401626 	beq	r7,r5,1befc <memchr+0xe4>
   1bea4:	49c00003 	ldbu	r7,0(r9)
   1bea8:	4805883a 	mov	r2,r9
   1beac:	39401326 	beq	r7,r5,1befc <memchr+0xe4>
   1beb0:	21000104 	addi	r4,r4,4
   1beb4:	4a400104 	addi	r9,r9,4
   1beb8:	42000104 	addi	r8,r8,4
   1bebc:	18c00104 	addi	r3,r3,4
   1bec0:	71bfe836 	bltu	r14,r6,1be64 <memchr+0x4c>
   1bec4:	2005883a 	mov	r2,r4
   1bec8:	30000a26 	beq	r6,zero,1bef4 <memchr+0xdc>
   1becc:	10c00003 	ldbu	r3,0(r2)
   1bed0:	19400a26 	beq	r3,r5,1befc <memchr+0xe4>
   1bed4:	10c00044 	addi	r3,r2,1
   1bed8:	118d883a 	add	r6,r2,r6
   1bedc:	00000306 	br	1beec <memchr+0xd4>
   1bee0:	11000003 	ldbu	r4,0(r2)
   1bee4:	18c00044 	addi	r3,r3,1
   1bee8:	21400426 	beq	r4,r5,1befc <memchr+0xe4>
   1beec:	1805883a 	mov	r2,r3
   1bef0:	19bffb1e 	bne	r3,r6,1bee0 <memchr+0xc8>
   1bef4:	0005883a 	mov	r2,zero
   1bef8:	f800283a 	ret
   1befc:	f800283a 	ret
   1bf00:	2005883a 	mov	r2,r4
   1bf04:	003ff106 	br	1becc <memchr+0xb4>
   1bf08:	2005883a 	mov	r2,r4
   1bf0c:	f800283a 	ret

0001bf10 <memmove>:
   1bf10:	2005883a 	mov	r2,r4
   1bf14:	300f883a 	mov	r7,r6
   1bf18:	29000b2e 	bgeu	r5,r4,1bf48 <memmove+0x38>
   1bf1c:	2987883a 	add	r3,r5,r6
   1bf20:	20c0092e 	bgeu	r4,r3,1bf48 <memmove+0x38>
   1bf24:	218b883a 	add	r5,r4,r6
   1bf28:	198fc83a 	sub	r7,r3,r6
   1bf2c:	30003f26 	beq	r6,zero,1c02c <memmove+0x11c>
   1bf30:	18ffffc4 	addi	r3,r3,-1
   1bf34:	19000003 	ldbu	r4,0(r3)
   1bf38:	297fffc4 	addi	r5,r5,-1
   1bf3c:	29000005 	stb	r4,0(r5)
   1bf40:	19fffb1e 	bne	r3,r7,1bf30 <memmove+0x20>
   1bf44:	f800283a 	ret
   1bf48:	00c003c4 	movi	r3,15
   1bf4c:	1980382e 	bgeu	r3,r6,1c030 <memmove+0x120>
   1bf50:	2886b03a 	or	r3,r5,r2
   1bf54:	18c000cc 	andi	r3,r3,3
   1bf58:	1800351e 	bne	r3,zero,1c030 <memmove+0x120>
   1bf5c:	327ffc04 	addi	r9,r6,-16
   1bf60:	4812d13a 	srli	r9,r9,4
   1bf64:	12000404 	addi	r8,r2,16
   1bf68:	1007883a 	mov	r3,r2
   1bf6c:	4808913a 	slli	r4,r9,4
   1bf70:	280f883a 	mov	r7,r5
   1bf74:	4111883a 	add	r8,r8,r4
   1bf78:	39000017 	ldw	r4,0(r7)
   1bf7c:	18c00404 	addi	r3,r3,16
   1bf80:	39c00404 	addi	r7,r7,16
   1bf84:	193ffc15 	stw	r4,-16(r3)
   1bf88:	393ffd17 	ldw	r4,-12(r7)
   1bf8c:	193ffd15 	stw	r4,-12(r3)
   1bf90:	393ffe17 	ldw	r4,-8(r7)
   1bf94:	193ffe15 	stw	r4,-8(r3)
   1bf98:	393fff17 	ldw	r4,-4(r7)
   1bf9c:	193fff15 	stw	r4,-4(r3)
   1bfa0:	1a3ff51e 	bne	r3,r8,1bf78 <memmove+0x68>
   1bfa4:	49000044 	addi	r4,r9,1
   1bfa8:	2008913a 	slli	r4,r4,4
   1bfac:	31c003cc 	andi	r7,r6,15
   1bfb0:	1107883a 	add	r3,r2,r4
   1bfb4:	290b883a 	add	r5,r5,r4
   1bfb8:	010000c4 	movi	r4,3
   1bfbc:	21c0142e 	bgeu	r4,r7,1c010 <memmove+0x100>
   1bfc0:	39ffff04 	addi	r7,r7,-4
   1bfc4:	3814d0ba 	srli	r10,r7,2
   1bfc8:	1a400104 	addi	r9,r3,4
   1bfcc:	180d883a 	mov	r6,r3
   1bfd0:	5289883a 	add	r4,r10,r10
   1bfd4:	2109883a 	add	r4,r4,r4
   1bfd8:	4913883a 	add	r9,r9,r4
   1bfdc:	2809883a 	mov	r4,r5
   1bfe0:	22000017 	ldw	r8,0(r4)
   1bfe4:	31800104 	addi	r6,r6,4
   1bfe8:	21000104 	addi	r4,r4,4
   1bfec:	323fff15 	stw	r8,-4(r6)
   1bff0:	327ffb1e 	bne	r6,r9,1bfe0 <memmove+0xd0>
   1bff4:	51000044 	addi	r4,r10,1
   1bff8:	52bfff24 	muli	r10,r10,-4
   1bffc:	2109883a 	add	r4,r4,r4
   1c000:	2109883a 	add	r4,r4,r4
   1c004:	51cf883a 	add	r7,r10,r7
   1c008:	290b883a 	add	r5,r5,r4
   1c00c:	1907883a 	add	r3,r3,r4
   1c010:	38000626 	beq	r7,zero,1c02c <memmove+0x11c>
   1c014:	19cf883a 	add	r7,r3,r7
   1c018:	29800003 	ldbu	r6,0(r5)
   1c01c:	18c00044 	addi	r3,r3,1
   1c020:	29400044 	addi	r5,r5,1
   1c024:	19bfffc5 	stb	r6,-1(r3)
   1c028:	19fffb1e 	bne	r3,r7,1c018 <memmove+0x108>
   1c02c:	f800283a 	ret
   1c030:	1007883a 	mov	r3,r2
   1c034:	003ff606 	br	1c010 <memmove+0x100>

0001c038 <_Balloc>:
   1c038:	20801317 	ldw	r2,76(r4)
   1c03c:	defffc04 	addi	sp,sp,-16
   1c040:	dc400115 	stw	r17,4(sp)
   1c044:	dc000015 	stw	r16,0(sp)
   1c048:	dfc00315 	stw	ra,12(sp)
   1c04c:	dc800215 	stw	r18,8(sp)
   1c050:	2023883a 	mov	r17,r4
   1c054:	2821883a 	mov	r16,r5
   1c058:	10000f26 	beq	r2,zero,1c098 <_Balloc+0x60>
   1c05c:	8407883a 	add	r3,r16,r16
   1c060:	18c7883a 	add	r3,r3,r3
   1c064:	10c7883a 	add	r3,r2,r3
   1c068:	18800017 	ldw	r2,0(r3)
   1c06c:	10001126 	beq	r2,zero,1c0b4 <_Balloc+0x7c>
   1c070:	11000017 	ldw	r4,0(r2)
   1c074:	19000015 	stw	r4,0(r3)
   1c078:	10000415 	stw	zero,16(r2)
   1c07c:	10000315 	stw	zero,12(r2)
   1c080:	dfc00317 	ldw	ra,12(sp)
   1c084:	dc800217 	ldw	r18,8(sp)
   1c088:	dc400117 	ldw	r17,4(sp)
   1c08c:	dc000017 	ldw	r16,0(sp)
   1c090:	dec00404 	addi	sp,sp,16
   1c094:	f800283a 	ret
   1c098:	01400104 	movi	r5,4
   1c09c:	01800404 	movi	r6,16
   1c0a0:	001d8500 	call	1d850 <_calloc_r>
   1c0a4:	88801315 	stw	r2,76(r17)
   1c0a8:	103fec1e 	bne	r2,zero,1c05c <_Balloc+0x24>
   1c0ac:	0005883a 	mov	r2,zero
   1c0b0:	003ff306 	br	1c080 <_Balloc+0x48>
   1c0b4:	01400044 	movi	r5,1
   1c0b8:	2c24983a 	sll	r18,r5,r16
   1c0bc:	8809883a 	mov	r4,r17
   1c0c0:	91800144 	addi	r6,r18,5
   1c0c4:	318d883a 	add	r6,r6,r6
   1c0c8:	318d883a 	add	r6,r6,r6
   1c0cc:	001d8500 	call	1d850 <_calloc_r>
   1c0d0:	103ff626 	beq	r2,zero,1c0ac <_Balloc+0x74>
   1c0d4:	14000115 	stw	r16,4(r2)
   1c0d8:	14800215 	stw	r18,8(r2)
   1c0dc:	003fe606 	br	1c078 <_Balloc+0x40>

0001c0e0 <_Bfree>:
   1c0e0:	28000826 	beq	r5,zero,1c104 <_Bfree+0x24>
   1c0e4:	28c00117 	ldw	r3,4(r5)
   1c0e8:	20801317 	ldw	r2,76(r4)
   1c0ec:	18c7883a 	add	r3,r3,r3
   1c0f0:	18c7883a 	add	r3,r3,r3
   1c0f4:	10c5883a 	add	r2,r2,r3
   1c0f8:	10c00017 	ldw	r3,0(r2)
   1c0fc:	28c00015 	stw	r3,0(r5)
   1c100:	11400015 	stw	r5,0(r2)
   1c104:	f800283a 	ret

0001c108 <__multadd>:
   1c108:	defffa04 	addi	sp,sp,-24
   1c10c:	dc000115 	stw	r16,4(sp)
   1c110:	2c000417 	ldw	r16,16(r5)
   1c114:	dc800315 	stw	r18,12(sp)
   1c118:	dc400215 	stw	r17,8(sp)
   1c11c:	dfc00515 	stw	ra,20(sp)
   1c120:	dcc00415 	stw	r19,16(sp)
   1c124:	2823883a 	mov	r17,r5
   1c128:	2025883a 	mov	r18,r4
   1c12c:	28c00504 	addi	r3,r5,20
   1c130:	0011883a 	mov	r8,zero
   1c134:	1a800017 	ldw	r10,0(r3)
   1c138:	18c00104 	addi	r3,r3,4
   1c13c:	42000044 	addi	r8,r8,1
   1c140:	527fffcc 	andi	r9,r10,65535
   1c144:	4993383a 	mul	r9,r9,r6
   1c148:	5014d43a 	srli	r10,r10,16
   1c14c:	49d3883a 	add	r9,r9,r7
   1c150:	480ed43a 	srli	r7,r9,16
   1c154:	5195383a 	mul	r10,r10,r6
   1c158:	4a7fffcc 	andi	r9,r9,65535
   1c15c:	3a8f883a 	add	r7,r7,r10
   1c160:	3814943a 	slli	r10,r7,16
   1c164:	380ed43a 	srli	r7,r7,16
   1c168:	5253883a 	add	r9,r10,r9
   1c16c:	1a7fff15 	stw	r9,-4(r3)
   1c170:	443ff016 	blt	r8,r16,1c134 <__multadd+0x2c>
   1c174:	38000926 	beq	r7,zero,1c19c <__multadd+0x94>
   1c178:	88800217 	ldw	r2,8(r17)
   1c17c:	80800f0e 	bge	r16,r2,1c1bc <__multadd+0xb4>
   1c180:	80800144 	addi	r2,r16,5
   1c184:	1085883a 	add	r2,r2,r2
   1c188:	1085883a 	add	r2,r2,r2
   1c18c:	8885883a 	add	r2,r17,r2
   1c190:	84000044 	addi	r16,r16,1
   1c194:	11c00015 	stw	r7,0(r2)
   1c198:	8c000415 	stw	r16,16(r17)
   1c19c:	8805883a 	mov	r2,r17
   1c1a0:	dfc00517 	ldw	ra,20(sp)
   1c1a4:	dcc00417 	ldw	r19,16(sp)
   1c1a8:	dc800317 	ldw	r18,12(sp)
   1c1ac:	dc400217 	ldw	r17,8(sp)
   1c1b0:	dc000117 	ldw	r16,4(sp)
   1c1b4:	dec00604 	addi	sp,sp,24
   1c1b8:	f800283a 	ret
   1c1bc:	89400117 	ldw	r5,4(r17)
   1c1c0:	9009883a 	mov	r4,r18
   1c1c4:	d9c00015 	stw	r7,0(sp)
   1c1c8:	29400044 	addi	r5,r5,1
   1c1cc:	001c0380 	call	1c038 <_Balloc>
   1c1d0:	89800417 	ldw	r6,16(r17)
   1c1d4:	89400304 	addi	r5,r17,12
   1c1d8:	11000304 	addi	r4,r2,12
   1c1dc:	31800084 	addi	r6,r6,2
   1c1e0:	318d883a 	add	r6,r6,r6
   1c1e4:	318d883a 	add	r6,r6,r6
   1c1e8:	1027883a 	mov	r19,r2
   1c1ec:	00164c00 	call	164c0 <memcpy>
   1c1f0:	88c00117 	ldw	r3,4(r17)
   1c1f4:	90801317 	ldw	r2,76(r18)
   1c1f8:	d9c00017 	ldw	r7,0(sp)
   1c1fc:	18c7883a 	add	r3,r3,r3
   1c200:	18c7883a 	add	r3,r3,r3
   1c204:	10c5883a 	add	r2,r2,r3
   1c208:	10c00017 	ldw	r3,0(r2)
   1c20c:	88c00015 	stw	r3,0(r17)
   1c210:	14400015 	stw	r17,0(r2)
   1c214:	9823883a 	mov	r17,r19
   1c218:	003fd906 	br	1c180 <__multadd+0x78>

0001c21c <__s2b>:
   1c21c:	defff904 	addi	sp,sp,-28
   1c220:	dd000415 	stw	r20,16(sp)
   1c224:	dc400115 	stw	r17,4(sp)
   1c228:	2829883a 	mov	r20,r5
   1c22c:	2023883a 	mov	r17,r4
   1c230:	01400244 	movi	r5,9
   1c234:	39000204 	addi	r4,r7,8
   1c238:	dcc00315 	stw	r19,12(sp)
   1c23c:	dc800215 	stw	r18,8(sp)
   1c240:	dfc00615 	stw	ra,24(sp)
   1c244:	dd400515 	stw	r21,20(sp)
   1c248:	dc000015 	stw	r16,0(sp)
   1c24c:	3825883a 	mov	r18,r7
   1c250:	3027883a 	mov	r19,r6
   1c254:	001f56c0 	call	1f56c <__divsi3>
   1c258:	00c00044 	movi	r3,1
   1c25c:	000b883a 	mov	r5,zero
   1c260:	1880030e 	bge	r3,r2,1c270 <__s2b+0x54>
   1c264:	18c7883a 	add	r3,r3,r3
   1c268:	29400044 	addi	r5,r5,1
   1c26c:	18bffd16 	blt	r3,r2,1c264 <__s2b+0x48>
   1c270:	8809883a 	mov	r4,r17
   1c274:	001c0380 	call	1c038 <_Balloc>
   1c278:	d8c00717 	ldw	r3,28(sp)
   1c27c:	10c00515 	stw	r3,20(r2)
   1c280:	00c00044 	movi	r3,1
   1c284:	10c00415 	stw	r3,16(r2)
   1c288:	00c00244 	movi	r3,9
   1c28c:	1cc0210e 	bge	r3,r19,1c314 <__s2b+0xf8>
   1c290:	a0eb883a 	add	r21,r20,r3
   1c294:	a821883a 	mov	r16,r21
   1c298:	a4e9883a 	add	r20,r20,r19
   1c29c:	81c00007 	ldb	r7,0(r16)
   1c2a0:	8809883a 	mov	r4,r17
   1c2a4:	84000044 	addi	r16,r16,1
   1c2a8:	100b883a 	mov	r5,r2
   1c2ac:	01800284 	movi	r6,10
   1c2b0:	39fff404 	addi	r7,r7,-48
   1c2b4:	001c1080 	call	1c108 <__multadd>
   1c2b8:	853ff81e 	bne	r16,r20,1c29c <__s2b+0x80>
   1c2bc:	ace1883a 	add	r16,r21,r19
   1c2c0:	843ffe04 	addi	r16,r16,-8
   1c2c4:	9c800a0e 	bge	r19,r18,1c2f0 <__s2b+0xd4>
   1c2c8:	94e5c83a 	sub	r18,r18,r19
   1c2cc:	84a5883a 	add	r18,r16,r18
   1c2d0:	81c00007 	ldb	r7,0(r16)
   1c2d4:	8809883a 	mov	r4,r17
   1c2d8:	84000044 	addi	r16,r16,1
   1c2dc:	100b883a 	mov	r5,r2
   1c2e0:	01800284 	movi	r6,10
   1c2e4:	39fff404 	addi	r7,r7,-48
   1c2e8:	001c1080 	call	1c108 <__multadd>
   1c2ec:	84bff81e 	bne	r16,r18,1c2d0 <__s2b+0xb4>
   1c2f0:	dfc00617 	ldw	ra,24(sp)
   1c2f4:	dd400517 	ldw	r21,20(sp)
   1c2f8:	dd000417 	ldw	r20,16(sp)
   1c2fc:	dcc00317 	ldw	r19,12(sp)
   1c300:	dc800217 	ldw	r18,8(sp)
   1c304:	dc400117 	ldw	r17,4(sp)
   1c308:	dc000017 	ldw	r16,0(sp)
   1c30c:	dec00704 	addi	sp,sp,28
   1c310:	f800283a 	ret
   1c314:	a4000284 	addi	r16,r20,10
   1c318:	1827883a 	mov	r19,r3
   1c31c:	003fe906 	br	1c2c4 <__s2b+0xa8>

0001c320 <__hi0bits>:
   1c320:	20bfffec 	andhi	r2,r4,65535
   1c324:	1000141e 	bne	r2,zero,1c378 <__hi0bits+0x58>
   1c328:	2008943a 	slli	r4,r4,16
   1c32c:	00800404 	movi	r2,16
   1c330:	20ffc02c 	andhi	r3,r4,65280
   1c334:	1800021e 	bne	r3,zero,1c340 <__hi0bits+0x20>
   1c338:	2008923a 	slli	r4,r4,8
   1c33c:	10800204 	addi	r2,r2,8
   1c340:	20fc002c 	andhi	r3,r4,61440
   1c344:	1800021e 	bne	r3,zero,1c350 <__hi0bits+0x30>
   1c348:	2008913a 	slli	r4,r4,4
   1c34c:	10800104 	addi	r2,r2,4
   1c350:	20f0002c 	andhi	r3,r4,49152
   1c354:	1800031e 	bne	r3,zero,1c364 <__hi0bits+0x44>
   1c358:	2109883a 	add	r4,r4,r4
   1c35c:	10800084 	addi	r2,r2,2
   1c360:	2109883a 	add	r4,r4,r4
   1c364:	20000316 	blt	r4,zero,1c374 <__hi0bits+0x54>
   1c368:	2110002c 	andhi	r4,r4,16384
   1c36c:	2000041e 	bne	r4,zero,1c380 <__hi0bits+0x60>
   1c370:	00800804 	movi	r2,32
   1c374:	f800283a 	ret
   1c378:	0005883a 	mov	r2,zero
   1c37c:	003fec06 	br	1c330 <__hi0bits+0x10>
   1c380:	10800044 	addi	r2,r2,1
   1c384:	f800283a 	ret

0001c388 <__lo0bits>:
   1c388:	20c00017 	ldw	r3,0(r4)
   1c38c:	188001cc 	andi	r2,r3,7
   1c390:	10000826 	beq	r2,zero,1c3b4 <__lo0bits+0x2c>
   1c394:	1880004c 	andi	r2,r3,1
   1c398:	1000211e 	bne	r2,zero,1c420 <__lo0bits+0x98>
   1c39c:	1880008c 	andi	r2,r3,2
   1c3a0:	1000211e 	bne	r2,zero,1c428 <__lo0bits+0xa0>
   1c3a4:	1806d0ba 	srli	r3,r3,2
   1c3a8:	00800084 	movi	r2,2
   1c3ac:	20c00015 	stw	r3,0(r4)
   1c3b0:	f800283a 	ret
   1c3b4:	18bfffcc 	andi	r2,r3,65535
   1c3b8:	10001326 	beq	r2,zero,1c408 <__lo0bits+0x80>
   1c3bc:	0005883a 	mov	r2,zero
   1c3c0:	19403fcc 	andi	r5,r3,255
   1c3c4:	2800021e 	bne	r5,zero,1c3d0 <__lo0bits+0x48>
   1c3c8:	1806d23a 	srli	r3,r3,8
   1c3cc:	10800204 	addi	r2,r2,8
   1c3d0:	194003cc 	andi	r5,r3,15
   1c3d4:	2800021e 	bne	r5,zero,1c3e0 <__lo0bits+0x58>
   1c3d8:	1806d13a 	srli	r3,r3,4
   1c3dc:	10800104 	addi	r2,r2,4
   1c3e0:	194000cc 	andi	r5,r3,3
   1c3e4:	2800021e 	bne	r5,zero,1c3f0 <__lo0bits+0x68>
   1c3e8:	1806d0ba 	srli	r3,r3,2
   1c3ec:	10800084 	addi	r2,r2,2
   1c3f0:	1940004c 	andi	r5,r3,1
   1c3f4:	2800081e 	bne	r5,zero,1c418 <__lo0bits+0x90>
   1c3f8:	1806d07a 	srli	r3,r3,1
   1c3fc:	1800051e 	bne	r3,zero,1c414 <__lo0bits+0x8c>
   1c400:	00800804 	movi	r2,32
   1c404:	f800283a 	ret
   1c408:	1806d43a 	srli	r3,r3,16
   1c40c:	00800404 	movi	r2,16
   1c410:	003feb06 	br	1c3c0 <__lo0bits+0x38>
   1c414:	10800044 	addi	r2,r2,1
   1c418:	20c00015 	stw	r3,0(r4)
   1c41c:	f800283a 	ret
   1c420:	0005883a 	mov	r2,zero
   1c424:	f800283a 	ret
   1c428:	1806d07a 	srli	r3,r3,1
   1c42c:	00800044 	movi	r2,1
   1c430:	20c00015 	stw	r3,0(r4)
   1c434:	f800283a 	ret

0001c438 <__i2b>:
   1c438:	defffd04 	addi	sp,sp,-12
   1c43c:	dc000015 	stw	r16,0(sp)
   1c440:	04000044 	movi	r16,1
   1c444:	dc400115 	stw	r17,4(sp)
   1c448:	2823883a 	mov	r17,r5
   1c44c:	800b883a 	mov	r5,r16
   1c450:	dfc00215 	stw	ra,8(sp)
   1c454:	001c0380 	call	1c038 <_Balloc>
   1c458:	14400515 	stw	r17,20(r2)
   1c45c:	14000415 	stw	r16,16(r2)
   1c460:	dfc00217 	ldw	ra,8(sp)
   1c464:	dc400117 	ldw	r17,4(sp)
   1c468:	dc000017 	ldw	r16,0(sp)
   1c46c:	dec00304 	addi	sp,sp,12
   1c470:	f800283a 	ret

0001c474 <__multiply>:
   1c474:	defffa04 	addi	sp,sp,-24
   1c478:	dcc00315 	stw	r19,12(sp)
   1c47c:	dc400115 	stw	r17,4(sp)
   1c480:	34c00417 	ldw	r19,16(r6)
   1c484:	2c400417 	ldw	r17,16(r5)
   1c488:	dd000415 	stw	r20,16(sp)
   1c48c:	dc800215 	stw	r18,8(sp)
   1c490:	dfc00515 	stw	ra,20(sp)
   1c494:	dc000015 	stw	r16,0(sp)
   1c498:	2825883a 	mov	r18,r5
   1c49c:	3029883a 	mov	r20,r6
   1c4a0:	8cc0050e 	bge	r17,r19,1c4b8 <__multiply+0x44>
   1c4a4:	8807883a 	mov	r3,r17
   1c4a8:	3025883a 	mov	r18,r6
   1c4ac:	9823883a 	mov	r17,r19
   1c4b0:	2829883a 	mov	r20,r5
   1c4b4:	1827883a 	mov	r19,r3
   1c4b8:	90800217 	ldw	r2,8(r18)
   1c4bc:	8ce1883a 	add	r16,r17,r19
   1c4c0:	91400117 	ldw	r5,4(r18)
   1c4c4:	1400010e 	bge	r2,r16,1c4cc <__multiply+0x58>
   1c4c8:	29400044 	addi	r5,r5,1
   1c4cc:	001c0380 	call	1c038 <_Balloc>
   1c4d0:	83c00144 	addi	r15,r16,5
   1c4d4:	7bdf883a 	add	r15,r15,r15
   1c4d8:	7bdf883a 	add	r15,r15,r15
   1c4dc:	13800504 	addi	r14,r2,20
   1c4e0:	13df883a 	add	r15,r2,r15
   1c4e4:	7007883a 	mov	r3,r14
   1c4e8:	73c0032e 	bgeu	r14,r15,1c4f8 <__multiply+0x84>
   1c4ec:	18000015 	stw	zero,0(r3)
   1c4f0:	18c00104 	addi	r3,r3,4
   1c4f4:	1bfffd36 	bltu	r3,r15,1c4ec <__multiply+0x78>
   1c4f8:	99800144 	addi	r6,r19,5
   1c4fc:	8b000144 	addi	r12,r17,5
   1c500:	318d883a 	add	r6,r6,r6
   1c504:	6319883a 	add	r12,r12,r12
   1c508:	318d883a 	add	r6,r6,r6
   1c50c:	6319883a 	add	r12,r12,r12
   1c510:	a3400504 	addi	r13,r20,20
   1c514:	a18d883a 	add	r6,r20,r6
   1c518:	94400504 	addi	r17,r18,20
   1c51c:	9319883a 	add	r12,r18,r12
   1c520:	6980392e 	bgeu	r13,r6,1c608 <__multiply+0x194>
   1c524:	6a800017 	ldw	r10,0(r13)
   1c528:	52ffffcc 	andi	r11,r10,65535
   1c52c:	58001826 	beq	r11,zero,1c590 <__multiply+0x11c>
   1c530:	7007883a 	mov	r3,r14
   1c534:	8809883a 	mov	r4,r17
   1c538:	000b883a 	mov	r5,zero
   1c53c:	22400017 	ldw	r9,0(r4)
   1c540:	1a000017 	ldw	r8,0(r3)
   1c544:	21000104 	addi	r4,r4,4
   1c548:	49ffffcc 	andi	r7,r9,65535
   1c54c:	3acf383a 	mul	r7,r7,r11
   1c550:	4812d43a 	srli	r9,r9,16
   1c554:	42bfffcc 	andi	r10,r8,65535
   1c558:	3a8f883a 	add	r7,r7,r10
   1c55c:	394f883a 	add	r7,r7,r5
   1c560:	4010d43a 	srli	r8,r8,16
   1c564:	4acb383a 	mul	r5,r9,r11
   1c568:	3814d43a 	srli	r10,r7,16
   1c56c:	19c0000d 	sth	r7,0(r3)
   1c570:	2a0b883a 	add	r5,r5,r8
   1c574:	2a8b883a 	add	r5,r5,r10
   1c578:	1940008d 	sth	r5,2(r3)
   1c57c:	280ad43a 	srli	r5,r5,16
   1c580:	18c00104 	addi	r3,r3,4
   1c584:	233fed36 	bltu	r4,r12,1c53c <__multiply+0xc8>
   1c588:	19400015 	stw	r5,0(r3)
   1c58c:	6a800017 	ldw	r10,0(r13)
   1c590:	5014d43a 	srli	r10,r10,16
   1c594:	50001926 	beq	r10,zero,1c5fc <__multiply+0x188>
   1c598:	71400017 	ldw	r5,0(r14)
   1c59c:	7007883a 	mov	r3,r14
   1c5a0:	8809883a 	mov	r4,r17
   1c5a4:	280f883a 	mov	r7,r5
   1c5a8:	0017883a 	mov	r11,zero
   1c5ac:	22400017 	ldw	r9,0(r4)
   1c5b0:	380ed43a 	srli	r7,r7,16
   1c5b4:	1940000d 	sth	r5,0(r3)
   1c5b8:	4a3fffcc 	andi	r8,r9,65535
   1c5bc:	4291383a 	mul	r8,r8,r10
   1c5c0:	4812d43a 	srli	r9,r9,16
   1c5c4:	18c00104 	addi	r3,r3,4
   1c5c8:	41d1883a 	add	r8,r8,r7
   1c5cc:	19c00017 	ldw	r7,0(r3)
   1c5d0:	42d1883a 	add	r8,r8,r11
   1c5d4:	4a93383a 	mul	r9,r9,r10
   1c5d8:	1a3fff8d 	sth	r8,-2(r3)
   1c5dc:	4010d43a 	srli	r8,r8,16
   1c5e0:	397fffcc 	andi	r5,r7,65535
   1c5e4:	2a4b883a 	add	r5,r5,r9
   1c5e8:	2a0b883a 	add	r5,r5,r8
   1c5ec:	21000104 	addi	r4,r4,4
   1c5f0:	2816d43a 	srli	r11,r5,16
   1c5f4:	233fed36 	bltu	r4,r12,1c5ac <__multiply+0x138>
   1c5f8:	19400015 	stw	r5,0(r3)
   1c5fc:	6b400104 	addi	r13,r13,4
   1c600:	73800104 	addi	r14,r14,4
   1c604:	69bfc736 	bltu	r13,r6,1c524 <__multiply+0xb0>
   1c608:	0400090e 	bge	zero,r16,1c630 <__multiply+0x1bc>
   1c60c:	78ffff17 	ldw	r3,-4(r15)
   1c610:	7bffff04 	addi	r15,r15,-4
   1c614:	18000326 	beq	r3,zero,1c624 <__multiply+0x1b0>
   1c618:	00000506 	br	1c630 <__multiply+0x1bc>
   1c61c:	78c00017 	ldw	r3,0(r15)
   1c620:	1800031e 	bne	r3,zero,1c630 <__multiply+0x1bc>
   1c624:	843fffc4 	addi	r16,r16,-1
   1c628:	7bffff04 	addi	r15,r15,-4
   1c62c:	803ffb1e 	bne	r16,zero,1c61c <__multiply+0x1a8>
   1c630:	14000415 	stw	r16,16(r2)
   1c634:	dfc00517 	ldw	ra,20(sp)
   1c638:	dd000417 	ldw	r20,16(sp)
   1c63c:	dcc00317 	ldw	r19,12(sp)
   1c640:	dc800217 	ldw	r18,8(sp)
   1c644:	dc400117 	ldw	r17,4(sp)
   1c648:	dc000017 	ldw	r16,0(sp)
   1c64c:	dec00604 	addi	sp,sp,24
   1c650:	f800283a 	ret

0001c654 <__pow5mult>:
   1c654:	defffb04 	addi	sp,sp,-20
   1c658:	dcc00315 	stw	r19,12(sp)
   1c65c:	dc800215 	stw	r18,8(sp)
   1c660:	dc000015 	stw	r16,0(sp)
   1c664:	dfc00415 	stw	ra,16(sp)
   1c668:	dc400115 	stw	r17,4(sp)
   1c66c:	308000cc 	andi	r2,r6,3
   1c670:	3021883a 	mov	r16,r6
   1c674:	2027883a 	mov	r19,r4
   1c678:	2825883a 	mov	r18,r5
   1c67c:	10002e1e 	bne	r2,zero,1c738 <__pow5mult+0xe4>
   1c680:	8021d0ba 	srai	r16,r16,2
   1c684:	80001a26 	beq	r16,zero,1c6f0 <__pow5mult+0x9c>
   1c688:	9c401217 	ldw	r17,72(r19)
   1c68c:	8800061e 	bne	r17,zero,1c6a8 <__pow5mult+0x54>
   1c690:	00003406 	br	1c764 <__pow5mult+0x110>
   1c694:	8021d07a 	srai	r16,r16,1
   1c698:	80001526 	beq	r16,zero,1c6f0 <__pow5mult+0x9c>
   1c69c:	88c00017 	ldw	r3,0(r17)
   1c6a0:	18001b26 	beq	r3,zero,1c710 <__pow5mult+0xbc>
   1c6a4:	1823883a 	mov	r17,r3
   1c6a8:	80c0004c 	andi	r3,r16,1
   1c6ac:	183ff926 	beq	r3,zero,1c694 <__pow5mult+0x40>
   1c6b0:	900b883a 	mov	r5,r18
   1c6b4:	880d883a 	mov	r6,r17
   1c6b8:	9809883a 	mov	r4,r19
   1c6bc:	001c4740 	call	1c474 <__multiply>
   1c6c0:	90001b26 	beq	r18,zero,1c730 <__pow5mult+0xdc>
   1c6c4:	91000117 	ldw	r4,4(r18)
   1c6c8:	98c01317 	ldw	r3,76(r19)
   1c6cc:	8021d07a 	srai	r16,r16,1
   1c6d0:	2109883a 	add	r4,r4,r4
   1c6d4:	2109883a 	add	r4,r4,r4
   1c6d8:	1907883a 	add	r3,r3,r4
   1c6dc:	19000017 	ldw	r4,0(r3)
   1c6e0:	91000015 	stw	r4,0(r18)
   1c6e4:	1c800015 	stw	r18,0(r3)
   1c6e8:	1025883a 	mov	r18,r2
   1c6ec:	803feb1e 	bne	r16,zero,1c69c <__pow5mult+0x48>
   1c6f0:	9005883a 	mov	r2,r18
   1c6f4:	dfc00417 	ldw	ra,16(sp)
   1c6f8:	dcc00317 	ldw	r19,12(sp)
   1c6fc:	dc800217 	ldw	r18,8(sp)
   1c700:	dc400117 	ldw	r17,4(sp)
   1c704:	dc000017 	ldw	r16,0(sp)
   1c708:	dec00504 	addi	sp,sp,20
   1c70c:	f800283a 	ret
   1c710:	880b883a 	mov	r5,r17
   1c714:	880d883a 	mov	r6,r17
   1c718:	9809883a 	mov	r4,r19
   1c71c:	001c4740 	call	1c474 <__multiply>
   1c720:	88800015 	stw	r2,0(r17)
   1c724:	10000015 	stw	zero,0(r2)
   1c728:	1023883a 	mov	r17,r2
   1c72c:	003fde06 	br	1c6a8 <__pow5mult+0x54>
   1c730:	1025883a 	mov	r18,r2
   1c734:	003fd706 	br	1c694 <__pow5mult+0x40>
   1c738:	10bfffc4 	addi	r2,r2,-1
   1c73c:	1085883a 	add	r2,r2,r2
   1c740:	00c000f4 	movhi	r3,3
   1c744:	18fc7e04 	addi	r3,r3,-3592
   1c748:	1085883a 	add	r2,r2,r2
   1c74c:	1885883a 	add	r2,r3,r2
   1c750:	11800017 	ldw	r6,0(r2)
   1c754:	000f883a 	mov	r7,zero
   1c758:	001c1080 	call	1c108 <__multadd>
   1c75c:	1025883a 	mov	r18,r2
   1c760:	003fc706 	br	1c680 <__pow5mult+0x2c>
   1c764:	9809883a 	mov	r4,r19
   1c768:	01409c44 	movi	r5,625
   1c76c:	001c4380 	call	1c438 <__i2b>
   1c770:	98801215 	stw	r2,72(r19)
   1c774:	1023883a 	mov	r17,r2
   1c778:	10000015 	stw	zero,0(r2)
   1c77c:	003fca06 	br	1c6a8 <__pow5mult+0x54>

0001c780 <__lshift>:
   1c780:	defff904 	addi	sp,sp,-28
   1c784:	dd400515 	stw	r21,20(sp)
   1c788:	dc400115 	stw	r17,4(sp)
   1c78c:	2d400417 	ldw	r21,16(r5)
   1c790:	3023d17a 	srai	r17,r6,5
   1c794:	28800217 	ldw	r2,8(r5)
   1c798:	dd000415 	stw	r20,16(sp)
   1c79c:	8d6b883a 	add	r21,r17,r21
   1c7a0:	dcc00315 	stw	r19,12(sp)
   1c7a4:	dc800215 	stw	r18,8(sp)
   1c7a8:	dc000015 	stw	r16,0(sp)
   1c7ac:	dfc00615 	stw	ra,24(sp)
   1c7b0:	ac000044 	addi	r16,r21,1
   1c7b4:	2825883a 	mov	r18,r5
   1c7b8:	3029883a 	mov	r20,r6
   1c7bc:	2027883a 	mov	r19,r4
   1c7c0:	29400117 	ldw	r5,4(r5)
   1c7c4:	1400030e 	bge	r2,r16,1c7d4 <__lshift+0x54>
   1c7c8:	1085883a 	add	r2,r2,r2
   1c7cc:	29400044 	addi	r5,r5,1
   1c7d0:	143ffd16 	blt	r2,r16,1c7c8 <__lshift+0x48>
   1c7d4:	9809883a 	mov	r4,r19
   1c7d8:	001c0380 	call	1c038 <_Balloc>
   1c7dc:	10c00504 	addi	r3,r2,20
   1c7e0:	0440090e 	bge	zero,r17,1c808 <__lshift+0x88>
   1c7e4:	000f883a 	mov	r7,zero
   1c7e8:	18000015 	stw	zero,0(r3)
   1c7ec:	39c00044 	addi	r7,r7,1
   1c7f0:	18c00104 	addi	r3,r3,4
   1c7f4:	3c7ffc1e 	bne	r7,r17,1c7e8 <__lshift+0x68>
   1c7f8:	38c00144 	addi	r3,r7,5
   1c7fc:	18c7883a 	add	r3,r3,r3
   1c800:	18c7883a 	add	r3,r3,r3
   1c804:	10c7883a 	add	r3,r2,r3
   1c808:	92000417 	ldw	r8,16(r18)
   1c80c:	a18007cc 	andi	r6,r20,31
   1c810:	91c00504 	addi	r7,r18,20
   1c814:	42000144 	addi	r8,r8,5
   1c818:	4211883a 	add	r8,r8,r8
   1c81c:	4211883a 	add	r8,r8,r8
   1c820:	9211883a 	add	r8,r18,r8
   1c824:	30002226 	beq	r6,zero,1c8b0 <__lshift+0x130>
   1c828:	02800804 	movi	r10,32
   1c82c:	5195c83a 	sub	r10,r10,r6
   1c830:	000b883a 	mov	r5,zero
   1c834:	3a400017 	ldw	r9,0(r7)
   1c838:	18c00104 	addi	r3,r3,4
   1c83c:	39c00104 	addi	r7,r7,4
   1c840:	4992983a 	sll	r9,r9,r6
   1c844:	2a4ab03a 	or	r5,r5,r9
   1c848:	197fff15 	stw	r5,-4(r3)
   1c84c:	397fff17 	ldw	r5,-4(r7)
   1c850:	2a8ad83a 	srl	r5,r5,r10
   1c854:	3a3ff736 	bltu	r7,r8,1c834 <__lshift+0xb4>
   1c858:	19400015 	stw	r5,0(r3)
   1c85c:	28000126 	beq	r5,zero,1c864 <__lshift+0xe4>
   1c860:	ac000084 	addi	r16,r21,2
   1c864:	91000117 	ldw	r4,4(r18)
   1c868:	98c01317 	ldw	r3,76(r19)
   1c86c:	843fffc4 	addi	r16,r16,-1
   1c870:	2109883a 	add	r4,r4,r4
   1c874:	2109883a 	add	r4,r4,r4
   1c878:	1907883a 	add	r3,r3,r4
   1c87c:	19000017 	ldw	r4,0(r3)
   1c880:	14000415 	stw	r16,16(r2)
   1c884:	91000015 	stw	r4,0(r18)
   1c888:	1c800015 	stw	r18,0(r3)
   1c88c:	dfc00617 	ldw	ra,24(sp)
   1c890:	dd400517 	ldw	r21,20(sp)
   1c894:	dd000417 	ldw	r20,16(sp)
   1c898:	dcc00317 	ldw	r19,12(sp)
   1c89c:	dc800217 	ldw	r18,8(sp)
   1c8a0:	dc400117 	ldw	r17,4(sp)
   1c8a4:	dc000017 	ldw	r16,0(sp)
   1c8a8:	dec00704 	addi	sp,sp,28
   1c8ac:	f800283a 	ret
   1c8b0:	39400017 	ldw	r5,0(r7)
   1c8b4:	18c00104 	addi	r3,r3,4
   1c8b8:	39c00104 	addi	r7,r7,4
   1c8bc:	197fff15 	stw	r5,-4(r3)
   1c8c0:	3a3fe82e 	bgeu	r7,r8,1c864 <__lshift+0xe4>
   1c8c4:	39400017 	ldw	r5,0(r7)
   1c8c8:	18c00104 	addi	r3,r3,4
   1c8cc:	39c00104 	addi	r7,r7,4
   1c8d0:	197fff15 	stw	r5,-4(r3)
   1c8d4:	3a3ff636 	bltu	r7,r8,1c8b0 <__lshift+0x130>
   1c8d8:	003fe206 	br	1c864 <__lshift+0xe4>

0001c8dc <__mcmp>:
   1c8dc:	20800417 	ldw	r2,16(r4)
   1c8e0:	28c00417 	ldw	r3,16(r5)
   1c8e4:	10c5c83a 	sub	r2,r2,r3
   1c8e8:	10000f1e 	bne	r2,zero,1c928 <__mcmp+0x4c>
   1c8ec:	18c00144 	addi	r3,r3,5
   1c8f0:	18c7883a 	add	r3,r3,r3
   1c8f4:	18c7883a 	add	r3,r3,r3
   1c8f8:	21c00504 	addi	r7,r4,20
   1c8fc:	28cb883a 	add	r5,r5,r3
   1c900:	20c9883a 	add	r4,r4,r3
   1c904:	213fff04 	addi	r4,r4,-4
   1c908:	297fff04 	addi	r5,r5,-4
   1c90c:	21800017 	ldw	r6,0(r4)
   1c910:	28c00017 	ldw	r3,0(r5)
   1c914:	30c0021e 	bne	r6,r3,1c920 <__mcmp+0x44>
   1c918:	393ffa36 	bltu	r7,r4,1c904 <__mcmp+0x28>
   1c91c:	f800283a 	ret
   1c920:	30c00236 	bltu	r6,r3,1c92c <__mcmp+0x50>
   1c924:	00800044 	movi	r2,1
   1c928:	f800283a 	ret
   1c92c:	00bfffc4 	movi	r2,-1
   1c930:	f800283a 	ret

0001c934 <__mdiff>:
   1c934:	defffb04 	addi	sp,sp,-20
   1c938:	dc000015 	stw	r16,0(sp)
   1c93c:	2821883a 	mov	r16,r5
   1c940:	dc800215 	stw	r18,8(sp)
   1c944:	300b883a 	mov	r5,r6
   1c948:	2025883a 	mov	r18,r4
   1c94c:	8009883a 	mov	r4,r16
   1c950:	dc400115 	stw	r17,4(sp)
   1c954:	dfc00415 	stw	ra,16(sp)
   1c958:	dcc00315 	stw	r19,12(sp)
   1c95c:	3023883a 	mov	r17,r6
   1c960:	001c8dc0 	call	1c8dc <__mcmp>
   1c964:	10005026 	beq	r2,zero,1caa8 <__mdiff+0x174>
   1c968:	10004a16 	blt	r2,zero,1ca94 <__mdiff+0x160>
   1c96c:	0027883a 	mov	r19,zero
   1c970:	81400117 	ldw	r5,4(r16)
   1c974:	9009883a 	mov	r4,r18
   1c978:	001c0380 	call	1c038 <_Balloc>
   1c97c:	82400417 	ldw	r9,16(r16)
   1c980:	89800417 	ldw	r6,16(r17)
   1c984:	14c00315 	stw	r19,12(r2)
   1c988:	4b800144 	addi	r14,r9,5
   1c98c:	31800144 	addi	r6,r6,5
   1c990:	739d883a 	add	r14,r14,r14
   1c994:	318d883a 	add	r6,r6,r6
   1c998:	739d883a 	add	r14,r14,r14
   1c99c:	318d883a 	add	r6,r6,r6
   1c9a0:	81c00504 	addi	r7,r16,20
   1c9a4:	839d883a 	add	r14,r16,r14
   1c9a8:	8a000504 	addi	r8,r17,20
   1c9ac:	898d883a 	add	r6,r17,r6
   1c9b0:	10c00504 	addi	r3,r2,20
   1c9b4:	0009883a 	mov	r4,zero
   1c9b8:	3b000017 	ldw	r12,0(r7)
   1c9bc:	42c00017 	ldw	r11,0(r8)
   1c9c0:	42000104 	addi	r8,r8,4
   1c9c4:	62bfffcc 	andi	r10,r12,65535
   1c9c8:	5b7fffcc 	andi	r13,r11,65535
   1c9cc:	5109883a 	add	r4,r10,r4
   1c9d0:	2355c83a 	sub	r10,r4,r13
   1c9d4:	5816d43a 	srli	r11,r11,16
   1c9d8:	6008d43a 	srli	r4,r12,16
   1c9dc:	501bd43a 	srai	r13,r10,16
   1c9e0:	1a80000d 	sth	r10,0(r3)
   1c9e4:	22c9c83a 	sub	r4,r4,r11
   1c9e8:	2349883a 	add	r4,r4,r13
   1c9ec:	1900008d 	sth	r4,2(r3)
   1c9f0:	39c00104 	addi	r7,r7,4
   1c9f4:	2009d43a 	srai	r4,r4,16
   1c9f8:	18c00104 	addi	r3,r3,4
   1c9fc:	41bfee36 	bltu	r8,r6,1c9b8 <__mdiff+0x84>
   1ca00:	180b883a 	mov	r5,r3
   1ca04:	3815883a 	mov	r10,r7
   1ca08:	3b80132e 	bgeu	r7,r14,1ca58 <__mdiff+0x124>
   1ca0c:	3a000017 	ldw	r8,0(r7)
   1ca10:	18c00104 	addi	r3,r3,4
   1ca14:	39c00104 	addi	r7,r7,4
   1ca18:	41bfffcc 	andi	r6,r8,65535
   1ca1c:	310d883a 	add	r6,r6,r4
   1ca20:	3009d43a 	srai	r4,r6,16
   1ca24:	4010d43a 	srli	r8,r8,16
   1ca28:	19bfff0d 	sth	r6,-4(r3)
   1ca2c:	2209883a 	add	r4,r4,r8
   1ca30:	193fff8d 	sth	r4,-2(r3)
   1ca34:	2009d43a 	srai	r4,r4,16
   1ca38:	3bbff436 	bltu	r7,r14,1ca0c <__mdiff+0xd8>
   1ca3c:	0286303a 	nor	r3,zero,r10
   1ca40:	1b87883a 	add	r3,r3,r14
   1ca44:	1806d0ba 	srli	r3,r3,2
   1ca48:	18c00044 	addi	r3,r3,1
   1ca4c:	18c7883a 	add	r3,r3,r3
   1ca50:	18c7883a 	add	r3,r3,r3
   1ca54:	28c7883a 	add	r3,r5,r3
   1ca58:	193fff17 	ldw	r4,-4(r3)
   1ca5c:	18ffff04 	addi	r3,r3,-4
   1ca60:	2000041e 	bne	r4,zero,1ca74 <__mdiff+0x140>
   1ca64:	18ffff04 	addi	r3,r3,-4
   1ca68:	19000017 	ldw	r4,0(r3)
   1ca6c:	4a7fffc4 	addi	r9,r9,-1
   1ca70:	203ffc26 	beq	r4,zero,1ca64 <__mdiff+0x130>
   1ca74:	12400415 	stw	r9,16(r2)
   1ca78:	dfc00417 	ldw	ra,16(sp)
   1ca7c:	dcc00317 	ldw	r19,12(sp)
   1ca80:	dc800217 	ldw	r18,8(sp)
   1ca84:	dc400117 	ldw	r17,4(sp)
   1ca88:	dc000017 	ldw	r16,0(sp)
   1ca8c:	dec00504 	addi	sp,sp,20
   1ca90:	f800283a 	ret
   1ca94:	8005883a 	mov	r2,r16
   1ca98:	04c00044 	movi	r19,1
   1ca9c:	8821883a 	mov	r16,r17
   1caa0:	1023883a 	mov	r17,r2
   1caa4:	003fb206 	br	1c970 <__mdiff+0x3c>
   1caa8:	9009883a 	mov	r4,r18
   1caac:	000b883a 	mov	r5,zero
   1cab0:	001c0380 	call	1c038 <_Balloc>
   1cab4:	00c00044 	movi	r3,1
   1cab8:	10c00415 	stw	r3,16(r2)
   1cabc:	10000515 	stw	zero,20(r2)
   1cac0:	dfc00417 	ldw	ra,16(sp)
   1cac4:	dcc00317 	ldw	r19,12(sp)
   1cac8:	dc800217 	ldw	r18,8(sp)
   1cacc:	dc400117 	ldw	r17,4(sp)
   1cad0:	dc000017 	ldw	r16,0(sp)
   1cad4:	dec00504 	addi	sp,sp,20
   1cad8:	f800283a 	ret

0001cadc <__ulp>:
   1cadc:	295ffc2c 	andhi	r5,r5,32752
   1cae0:	00bf3034 	movhi	r2,64704
   1cae4:	2887883a 	add	r3,r5,r2
   1cae8:	00c0020e 	bge	zero,r3,1caf4 <__ulp+0x18>
   1caec:	0005883a 	mov	r2,zero
   1caf0:	f800283a 	ret
   1caf4:	00c7c83a 	sub	r3,zero,r3
   1caf8:	1805d53a 	srai	r2,r3,20
   1cafc:	00c004c4 	movi	r3,19
   1cb00:	18800a0e 	bge	r3,r2,1cb2c <__ulp+0x50>
   1cb04:	01000c84 	movi	r4,50
   1cb08:	0007883a 	mov	r3,zero
   1cb0c:	20800516 	blt	r4,r2,1cb24 <__ulp+0x48>
   1cb10:	01000cc4 	movi	r4,51
   1cb14:	2085c83a 	sub	r2,r4,r2
   1cb18:	01000044 	movi	r4,1
   1cb1c:	2084983a 	sll	r2,r4,r2
   1cb20:	f800283a 	ret
   1cb24:	00800044 	movi	r2,1
   1cb28:	f800283a 	ret
   1cb2c:	00c00234 	movhi	r3,8
   1cb30:	1887d83a 	sra	r3,r3,r2
   1cb34:	0005883a 	mov	r2,zero
   1cb38:	f800283a 	ret

0001cb3c <__b2d>:
   1cb3c:	defffa04 	addi	sp,sp,-24
   1cb40:	dc000015 	stw	r16,0(sp)
   1cb44:	24000417 	ldw	r16,16(r4)
   1cb48:	dc400115 	stw	r17,4(sp)
   1cb4c:	dcc00315 	stw	r19,12(sp)
   1cb50:	84000144 	addi	r16,r16,5
   1cb54:	8421883a 	add	r16,r16,r16
   1cb58:	8421883a 	add	r16,r16,r16
   1cb5c:	2421883a 	add	r16,r4,r16
   1cb60:	847fff17 	ldw	r17,-4(r16)
   1cb64:	24c00504 	addi	r19,r4,20
   1cb68:	dd000415 	stw	r20,16(sp)
   1cb6c:	8809883a 	mov	r4,r17
   1cb70:	dc800215 	stw	r18,8(sp)
   1cb74:	2829883a 	mov	r20,r5
   1cb78:	dfc00515 	stw	ra,20(sp)
   1cb7c:	001c3200 	call	1c320 <__hi0bits>
   1cb80:	00c00804 	movi	r3,32
   1cb84:	1887c83a 	sub	r3,r3,r2
   1cb88:	a0c00015 	stw	r3,0(r20)
   1cb8c:	00c00284 	movi	r3,10
   1cb90:	84bfff04 	addi	r18,r16,-4
   1cb94:	18801216 	blt	r3,r2,1cbe0 <__b2d+0xa4>
   1cb98:	010002c4 	movi	r4,11
   1cb9c:	2089c83a 	sub	r4,r4,r2
   1cba0:	8906d83a 	srl	r3,r17,r4
   1cba4:	18cffc34 	orhi	r3,r3,16368
   1cba8:	9c80322e 	bgeu	r19,r18,1cc74 <__b2d+0x138>
   1cbac:	817ffe17 	ldw	r5,-8(r16)
   1cbb0:	2908d83a 	srl	r4,r5,r4
   1cbb4:	10800544 	addi	r2,r2,21
   1cbb8:	88a2983a 	sll	r17,r17,r2
   1cbbc:	2444b03a 	or	r2,r4,r17
   1cbc0:	dfc00517 	ldw	ra,20(sp)
   1cbc4:	dd000417 	ldw	r20,16(sp)
   1cbc8:	dcc00317 	ldw	r19,12(sp)
   1cbcc:	dc800217 	ldw	r18,8(sp)
   1cbd0:	dc400117 	ldw	r17,4(sp)
   1cbd4:	dc000017 	ldw	r16,0(sp)
   1cbd8:	dec00604 	addi	sp,sp,24
   1cbdc:	f800283a 	ret
   1cbe0:	9c801636 	bltu	r19,r18,1cc3c <__b2d+0x100>
   1cbe4:	113ffd44 	addi	r4,r2,-11
   1cbe8:	000b883a 	mov	r5,zero
   1cbec:	20001726 	beq	r4,zero,1cc4c <__b2d+0x110>
   1cbf0:	00c00ac4 	movi	r3,43
   1cbf4:	1885c83a 	sub	r2,r3,r2
   1cbf8:	8906983a 	sll	r3,r17,r4
   1cbfc:	288cd83a 	srl	r6,r5,r2
   1cc00:	18cffc34 	orhi	r3,r3,16368
   1cc04:	1986b03a 	or	r3,r3,r6
   1cc08:	9c801c2e 	bgeu	r19,r18,1cc7c <__b2d+0x140>
   1cc0c:	91bfff17 	ldw	r6,-4(r18)
   1cc10:	3084d83a 	srl	r2,r6,r2
   1cc14:	2908983a 	sll	r4,r5,r4
   1cc18:	1104b03a 	or	r2,r2,r4
   1cc1c:	dfc00517 	ldw	ra,20(sp)
   1cc20:	dd000417 	ldw	r20,16(sp)
   1cc24:	dcc00317 	ldw	r19,12(sp)
   1cc28:	dc800217 	ldw	r18,8(sp)
   1cc2c:	dc400117 	ldw	r17,4(sp)
   1cc30:	dc000017 	ldw	r16,0(sp)
   1cc34:	dec00604 	addi	sp,sp,24
   1cc38:	f800283a 	ret
   1cc3c:	113ffd44 	addi	r4,r2,-11
   1cc40:	84bffe04 	addi	r18,r16,-8
   1cc44:	817ffe17 	ldw	r5,-8(r16)
   1cc48:	203fe91e 	bne	r4,zero,1cbf0 <__b2d+0xb4>
   1cc4c:	88cffc34 	orhi	r3,r17,16368
   1cc50:	2805883a 	mov	r2,r5
   1cc54:	dfc00517 	ldw	ra,20(sp)
   1cc58:	dd000417 	ldw	r20,16(sp)
   1cc5c:	dcc00317 	ldw	r19,12(sp)
   1cc60:	dc800217 	ldw	r18,8(sp)
   1cc64:	dc400117 	ldw	r17,4(sp)
   1cc68:	dc000017 	ldw	r16,0(sp)
   1cc6c:	dec00604 	addi	sp,sp,24
   1cc70:	f800283a 	ret
   1cc74:	0009883a 	mov	r4,zero
   1cc78:	003fce06 	br	1cbb4 <__b2d+0x78>
   1cc7c:	0005883a 	mov	r2,zero
   1cc80:	003fe406 	br	1cc14 <__b2d+0xd8>

0001cc84 <__d2b>:
   1cc84:	defff804 	addi	sp,sp,-32
   1cc88:	dc400315 	stw	r17,12(sp)
   1cc8c:	3023883a 	mov	r17,r6
   1cc90:	dc800415 	stw	r18,16(sp)
   1cc94:	8824907a 	slli	r18,r17,1
   1cc98:	dcc00515 	stw	r19,20(sp)
   1cc9c:	2827883a 	mov	r19,r5
   1cca0:	9024d57a 	srli	r18,r18,21
   1cca4:	01400044 	movi	r5,1
   1cca8:	dd000615 	stw	r20,24(sp)
   1ccac:	dc000215 	stw	r16,8(sp)
   1ccb0:	dfc00715 	stw	ra,28(sp)
   1ccb4:	3829883a 	mov	r20,r7
   1ccb8:	001c0380 	call	1c038 <_Balloc>
   1ccbc:	1021883a 	mov	r16,r2
   1ccc0:	00800434 	movhi	r2,16
   1ccc4:	10bfffc4 	addi	r2,r2,-1
   1ccc8:	88a2703a 	and	r17,r17,r2
   1cccc:	90000126 	beq	r18,zero,1ccd4 <__d2b+0x50>
   1ccd0:	8c400434 	orhi	r17,r17,16
   1ccd4:	dc400015 	stw	r17,0(sp)
   1ccd8:	98002226 	beq	r19,zero,1cd64 <__d2b+0xe0>
   1ccdc:	d9000104 	addi	r4,sp,4
   1cce0:	dcc00115 	stw	r19,4(sp)
   1cce4:	001c3880 	call	1c388 <__lo0bits>
   1cce8:	d8c00017 	ldw	r3,0(sp)
   1ccec:	10002d1e 	bne	r2,zero,1cda4 <__d2b+0x120>
   1ccf0:	d9000117 	ldw	r4,4(sp)
   1ccf4:	81000515 	stw	r4,20(r16)
   1ccf8:	1823003a 	cmpeq	r17,r3,zero
   1ccfc:	01000084 	movi	r4,2
   1cd00:	2463c83a 	sub	r17,r4,r17
   1cd04:	80c00615 	stw	r3,24(r16)
   1cd08:	84400415 	stw	r17,16(r16)
   1cd0c:	90001d1e 	bne	r18,zero,1cd84 <__d2b+0x100>
   1cd10:	88c00104 	addi	r3,r17,4
   1cd14:	18c7883a 	add	r3,r3,r3
   1cd18:	18c7883a 	add	r3,r3,r3
   1cd1c:	80c7883a 	add	r3,r16,r3
   1cd20:	19000017 	ldw	r4,0(r3)
   1cd24:	10bef384 	addi	r2,r2,-1074
   1cd28:	a0800015 	stw	r2,0(r20)
   1cd2c:	001c3200 	call	1c320 <__hi0bits>
   1cd30:	8822917a 	slli	r17,r17,5
   1cd34:	d8c00817 	ldw	r3,32(sp)
   1cd38:	8885c83a 	sub	r2,r17,r2
   1cd3c:	18800015 	stw	r2,0(r3)
   1cd40:	8005883a 	mov	r2,r16
   1cd44:	dfc00717 	ldw	ra,28(sp)
   1cd48:	dd000617 	ldw	r20,24(sp)
   1cd4c:	dcc00517 	ldw	r19,20(sp)
   1cd50:	dc800417 	ldw	r18,16(sp)
   1cd54:	dc400317 	ldw	r17,12(sp)
   1cd58:	dc000217 	ldw	r16,8(sp)
   1cd5c:	dec00804 	addi	sp,sp,32
   1cd60:	f800283a 	ret
   1cd64:	d809883a 	mov	r4,sp
   1cd68:	001c3880 	call	1c388 <__lo0bits>
   1cd6c:	d8c00017 	ldw	r3,0(sp)
   1cd70:	04400044 	movi	r17,1
   1cd74:	84400415 	stw	r17,16(r16)
   1cd78:	80c00515 	stw	r3,20(r16)
   1cd7c:	10800804 	addi	r2,r2,32
   1cd80:	903fe326 	beq	r18,zero,1cd10 <__d2b+0x8c>
   1cd84:	00c00d44 	movi	r3,53
   1cd88:	94bef344 	addi	r18,r18,-1075
   1cd8c:	90a5883a 	add	r18,r18,r2
   1cd90:	1885c83a 	sub	r2,r3,r2
   1cd94:	d8c00817 	ldw	r3,32(sp)
   1cd98:	a4800015 	stw	r18,0(r20)
   1cd9c:	18800015 	stw	r2,0(r3)
   1cda0:	003fe706 	br	1cd40 <__d2b+0xbc>
   1cda4:	01000804 	movi	r4,32
   1cda8:	2089c83a 	sub	r4,r4,r2
   1cdac:	1908983a 	sll	r4,r3,r4
   1cdb0:	d9400117 	ldw	r5,4(sp)
   1cdb4:	1886d83a 	srl	r3,r3,r2
   1cdb8:	2148b03a 	or	r4,r4,r5
   1cdbc:	81000515 	stw	r4,20(r16)
   1cdc0:	d8c00015 	stw	r3,0(sp)
   1cdc4:	003fcc06 	br	1ccf8 <__d2b+0x74>

0001cdc8 <__ratio>:
   1cdc8:	defff904 	addi	sp,sp,-28
   1cdcc:	dc400315 	stw	r17,12(sp)
   1cdd0:	2823883a 	mov	r17,r5
   1cdd4:	d9400104 	addi	r5,sp,4
   1cdd8:	dfc00615 	stw	ra,24(sp)
   1cddc:	dcc00515 	stw	r19,20(sp)
   1cde0:	dc800415 	stw	r18,16(sp)
   1cde4:	2027883a 	mov	r19,r4
   1cde8:	dc000215 	stw	r16,8(sp)
   1cdec:	001cb3c0 	call	1cb3c <__b2d>
   1cdf0:	8809883a 	mov	r4,r17
   1cdf4:	d80b883a 	mov	r5,sp
   1cdf8:	1025883a 	mov	r18,r2
   1cdfc:	1821883a 	mov	r16,r3
   1ce00:	001cb3c0 	call	1cb3c <__b2d>
   1ce04:	99400417 	ldw	r5,16(r19)
   1ce08:	89000417 	ldw	r4,16(r17)
   1ce0c:	d9800117 	ldw	r6,4(sp)
   1ce10:	2909c83a 	sub	r4,r5,r4
   1ce14:	d9400017 	ldw	r5,0(sp)
   1ce18:	2008917a 	slli	r4,r4,5
   1ce1c:	314bc83a 	sub	r5,r6,r5
   1ce20:	290b883a 	add	r5,r5,r4
   1ce24:	01400e0e 	bge	zero,r5,1ce60 <__ratio+0x98>
   1ce28:	280a953a 	slli	r5,r5,20
   1ce2c:	2c21883a 	add	r16,r5,r16
   1ce30:	9009883a 	mov	r4,r18
   1ce34:	800b883a 	mov	r5,r16
   1ce38:	100d883a 	mov	r6,r2
   1ce3c:	180f883a 	mov	r7,r3
   1ce40:	001eea40 	call	1eea4 <__divdf3>
   1ce44:	dfc00617 	ldw	ra,24(sp)
   1ce48:	dcc00517 	ldw	r19,20(sp)
   1ce4c:	dc800417 	ldw	r18,16(sp)
   1ce50:	dc400317 	ldw	r17,12(sp)
   1ce54:	dc000217 	ldw	r16,8(sp)
   1ce58:	dec00704 	addi	sp,sp,28
   1ce5c:	f800283a 	ret
   1ce60:	280a953a 	slli	r5,r5,20
   1ce64:	1947c83a 	sub	r3,r3,r5
   1ce68:	003ff106 	br	1ce30 <__ratio+0x68>

0001ce6c <_mprec_log10>:
   1ce6c:	defffe04 	addi	sp,sp,-8
   1ce70:	dc000015 	stw	r16,0(sp)
   1ce74:	dfc00115 	stw	ra,4(sp)
   1ce78:	008005c4 	movi	r2,23
   1ce7c:	2021883a 	mov	r16,r4
   1ce80:	11000d0e 	bge	r2,r4,1ceb8 <_mprec_log10+0x4c>
   1ce84:	0005883a 	mov	r2,zero
   1ce88:	00cffc34 	movhi	r3,16368
   1ce8c:	843fffc4 	addi	r16,r16,-1
   1ce90:	1009883a 	mov	r4,r2
   1ce94:	180b883a 	mov	r5,r3
   1ce98:	000d883a 	mov	r6,zero
   1ce9c:	01d00934 	movhi	r7,16420
   1cea0:	001ebc00 	call	1ebc0 <__muldf3>
   1cea4:	803ff91e 	bne	r16,zero,1ce8c <_mprec_log10+0x20>
   1cea8:	dfc00117 	ldw	ra,4(sp)
   1ceac:	dc000017 	ldw	r16,0(sp)
   1ceb0:	dec00204 	addi	sp,sp,8
   1ceb4:	f800283a 	ret
   1ceb8:	202090fa 	slli	r16,r4,3
   1cebc:	008000f4 	movhi	r2,3
   1cec0:	10bc4c04 	addi	r2,r2,-3792
   1cec4:	1421883a 	add	r16,r2,r16
   1cec8:	80800017 	ldw	r2,0(r16)
   1cecc:	80c00117 	ldw	r3,4(r16)
   1ced0:	dfc00117 	ldw	ra,4(sp)
   1ced4:	dc000017 	ldw	r16,0(sp)
   1ced8:	dec00204 	addi	sp,sp,8
   1cedc:	f800283a 	ret

0001cee0 <__copybits>:
   1cee0:	297fffc4 	addi	r5,r5,-1
   1cee4:	31c00417 	ldw	r7,16(r6)
   1cee8:	2811d17a 	srai	r8,r5,5
   1ceec:	30800504 	addi	r2,r6,20
   1cef0:	39c00144 	addi	r7,r7,5
   1cef4:	42000044 	addi	r8,r8,1
   1cef8:	39cf883a 	add	r7,r7,r7
   1cefc:	4211883a 	add	r8,r8,r8
   1cf00:	39cf883a 	add	r7,r7,r7
   1cf04:	4211883a 	add	r8,r8,r8
   1cf08:	31cf883a 	add	r7,r6,r7
   1cf0c:	2211883a 	add	r8,r4,r8
   1cf10:	11c00d2e 	bgeu	r2,r7,1cf48 <__copybits+0x68>
   1cf14:	2007883a 	mov	r3,r4
   1cf18:	11400017 	ldw	r5,0(r2)
   1cf1c:	18c00104 	addi	r3,r3,4
   1cf20:	10800104 	addi	r2,r2,4
   1cf24:	197fff15 	stw	r5,-4(r3)
   1cf28:	11fffb36 	bltu	r2,r7,1cf18 <__copybits+0x38>
   1cf2c:	3985c83a 	sub	r2,r7,r6
   1cf30:	10bffac4 	addi	r2,r2,-21
   1cf34:	1004d0ba 	srli	r2,r2,2
   1cf38:	10800044 	addi	r2,r2,1
   1cf3c:	1085883a 	add	r2,r2,r2
   1cf40:	1085883a 	add	r2,r2,r2
   1cf44:	2089883a 	add	r4,r4,r2
   1cf48:	2200032e 	bgeu	r4,r8,1cf58 <__copybits+0x78>
   1cf4c:	20000015 	stw	zero,0(r4)
   1cf50:	21000104 	addi	r4,r4,4
   1cf54:	223ffd36 	bltu	r4,r8,1cf4c <__copybits+0x6c>
   1cf58:	f800283a 	ret

0001cf5c <__any_on>:
   1cf5c:	21800417 	ldw	r6,16(r4)
   1cf60:	2805d17a 	srai	r2,r5,5
   1cf64:	20c00504 	addi	r3,r4,20
   1cf68:	30800f0e 	bge	r6,r2,1cfa8 <__any_on+0x4c>
   1cf6c:	3005883a 	mov	r2,r6
   1cf70:	10800144 	addi	r2,r2,5
   1cf74:	1085883a 	add	r2,r2,r2
   1cf78:	1085883a 	add	r2,r2,r2
   1cf7c:	2089883a 	add	r4,r4,r2
   1cf80:	1900152e 	bgeu	r3,r4,1cfd8 <__any_on+0x7c>
   1cf84:	20bfff17 	ldw	r2,-4(r4)
   1cf88:	213fff04 	addi	r4,r4,-4
   1cf8c:	1000041e 	bne	r2,zero,1cfa0 <__any_on+0x44>
   1cf90:	1900112e 	bgeu	r3,r4,1cfd8 <__any_on+0x7c>
   1cf94:	213fff04 	addi	r4,r4,-4
   1cf98:	20800017 	ldw	r2,0(r4)
   1cf9c:	103ffc26 	beq	r2,zero,1cf90 <__any_on+0x34>
   1cfa0:	00800044 	movi	r2,1
   1cfa4:	f800283a 	ret
   1cfa8:	11bff10e 	bge	r2,r6,1cf70 <__any_on+0x14>
   1cfac:	294007cc 	andi	r5,r5,31
   1cfb0:	283fef26 	beq	r5,zero,1cf70 <__any_on+0x14>
   1cfb4:	11800144 	addi	r6,r2,5
   1cfb8:	318d883a 	add	r6,r6,r6
   1cfbc:	318d883a 	add	r6,r6,r6
   1cfc0:	218d883a 	add	r6,r4,r6
   1cfc4:	31800017 	ldw	r6,0(r6)
   1cfc8:	314ed83a 	srl	r7,r6,r5
   1cfcc:	394a983a 	sll	r5,r7,r5
   1cfd0:	29bff31e 	bne	r5,r6,1cfa0 <__any_on+0x44>
   1cfd4:	003fe606 	br	1cf70 <__any_on+0x14>
   1cfd8:	0005883a 	mov	r2,zero
   1cfdc:	f800283a 	ret

0001cfe0 <_realloc_r>:
   1cfe0:	defff504 	addi	sp,sp,-44
   1cfe4:	dd400615 	stw	r21,24(sp)
   1cfe8:	dc800315 	stw	r18,12(sp)
   1cfec:	dc000115 	stw	r16,4(sp)
   1cff0:	dfc00a15 	stw	ra,40(sp)
   1cff4:	df000915 	stw	fp,36(sp)
   1cff8:	ddc00815 	stw	r23,32(sp)
   1cffc:	dd800715 	stw	r22,28(sp)
   1d000:	dd000515 	stw	r20,20(sp)
   1d004:	dcc00415 	stw	r19,16(sp)
   1d008:	dc400215 	stw	r17,8(sp)
   1d00c:	2821883a 	mov	r16,r5
   1d010:	202b883a 	mov	r21,r4
   1d014:	3025883a 	mov	r18,r6
   1d018:	28009626 	beq	r5,zero,1d274 <_realloc_r+0x294>
   1d01c:	00202d40 	call	202d4 <__malloc_lock>
   1d020:	80bfff17 	ldw	r2,-4(r16)
   1d024:	04ffff04 	movi	r19,-4
   1d028:	90c002c4 	addi	r3,r18,11
   1d02c:	01000584 	movi	r4,22
   1d030:	85bffe04 	addi	r22,r16,-8
   1d034:	14e6703a 	and	r19,r2,r19
   1d038:	20c0372e 	bgeu	r4,r3,1d118 <_realloc_r+0x138>
   1d03c:	047ffe04 	movi	r17,-8
   1d040:	1c62703a 	and	r17,r3,r17
   1d044:	8807883a 	mov	r3,r17
   1d048:	88005a16 	blt	r17,zero,1d1b4 <_realloc_r+0x1d4>
   1d04c:	8c805936 	bltu	r17,r18,1d1b4 <_realloc_r+0x1d4>
   1d050:	98c0340e 	bge	r19,r3,1d124 <_realloc_r+0x144>
   1d054:	070000f4 	movhi	fp,3
   1d058:	e705bc04 	addi	fp,fp,5872
   1d05c:	e1400217 	ldw	r5,8(fp)
   1d060:	b4c9883a 	add	r4,r22,r19
   1d064:	29009026 	beq	r5,r4,1d2a8 <_realloc_r+0x2c8>
   1d068:	21800117 	ldw	r6,4(r4)
   1d06c:	01ffff84 	movi	r7,-2
   1d070:	31ce703a 	and	r7,r6,r7
   1d074:	21cf883a 	add	r7,r4,r7
   1d078:	39c00117 	ldw	r7,4(r7)
   1d07c:	39c0004c 	andi	r7,r7,1
   1d080:	38004326 	beq	r7,zero,1d190 <_realloc_r+0x1b0>
   1d084:	000d883a 	mov	r6,zero
   1d088:	0009883a 	mov	r4,zero
   1d08c:	1080004c 	andi	r2,r2,1
   1d090:	10005a1e 	bne	r2,zero,1d1fc <_realloc_r+0x21c>
   1d094:	85fffe17 	ldw	r23,-8(r16)
   1d098:	00bfff04 	movi	r2,-4
   1d09c:	b5efc83a 	sub	r23,r22,r23
   1d0a0:	b9c00117 	ldw	r7,4(r23)
   1d0a4:	388e703a 	and	r7,r7,r2
   1d0a8:	3ccf883a 	add	r7,r7,r19
   1d0ac:	20005226 	beq	r4,zero,1d1f8 <_realloc_r+0x218>
   1d0b0:	31e9883a 	add	r20,r6,r7
   1d0b4:	2140c726 	beq	r4,r5,1d3d4 <_realloc_r+0x3f4>
   1d0b8:	a0c04f16 	blt	r20,r3,1d1f8 <_realloc_r+0x218>
   1d0bc:	20800317 	ldw	r2,12(r4)
   1d0c0:	20c00217 	ldw	r3,8(r4)
   1d0c4:	99bfff04 	addi	r6,r19,-4
   1d0c8:	01000904 	movi	r4,36
   1d0cc:	18800315 	stw	r2,12(r3)
   1d0d0:	10c00215 	stw	r3,8(r2)
   1d0d4:	b8c00217 	ldw	r3,8(r23)
   1d0d8:	b8800317 	ldw	r2,12(r23)
   1d0dc:	bc800204 	addi	r18,r23,8
   1d0e0:	18800315 	stw	r2,12(r3)
   1d0e4:	10c00215 	stw	r3,8(r2)
   1d0e8:	2180ed36 	bltu	r4,r6,1d4a0 <_realloc_r+0x4c0>
   1d0ec:	008004c4 	movi	r2,19
   1d0f0:	11809b2e 	bgeu	r2,r6,1d360 <_realloc_r+0x380>
   1d0f4:	80800017 	ldw	r2,0(r16)
   1d0f8:	b8800215 	stw	r2,8(r23)
   1d0fc:	80800117 	ldw	r2,4(r16)
   1d100:	b8800315 	stw	r2,12(r23)
   1d104:	008006c4 	movi	r2,27
   1d108:	1180f936 	bltu	r2,r6,1d4f0 <_realloc_r+0x510>
   1d10c:	b8800404 	addi	r2,r23,16
   1d110:	80c00204 	addi	r3,r16,8
   1d114:	00009406 	br	1d368 <_realloc_r+0x388>
   1d118:	00c00404 	movi	r3,16
   1d11c:	1823883a 	mov	r17,r3
   1d120:	003fca06 	br	1d04c <_realloc_r+0x6c>
   1d124:	9829883a 	mov	r20,r19
   1d128:	a447c83a 	sub	r3,r20,r17
   1d12c:	010003c4 	movi	r4,15
   1d130:	1080004c 	andi	r2,r2,1
   1d134:	20c02336 	bltu	r4,r3,1d1c4 <_realloc_r+0x1e4>
   1d138:	1504b03a 	or	r2,r2,r20
   1d13c:	b0800115 	stw	r2,4(r22)
   1d140:	b52d883a 	add	r22,r22,r20
   1d144:	b0800117 	ldw	r2,4(r22)
   1d148:	10800054 	ori	r2,r2,1
   1d14c:	b0800115 	stw	r2,4(r22)
   1d150:	a809883a 	mov	r4,r21
   1d154:	00202f40 	call	202f4 <__malloc_unlock>
   1d158:	8025883a 	mov	r18,r16
   1d15c:	9005883a 	mov	r2,r18
   1d160:	dfc00a17 	ldw	ra,40(sp)
   1d164:	df000917 	ldw	fp,36(sp)
   1d168:	ddc00817 	ldw	r23,32(sp)
   1d16c:	dd800717 	ldw	r22,28(sp)
   1d170:	dd400617 	ldw	r21,24(sp)
   1d174:	dd000517 	ldw	r20,20(sp)
   1d178:	dcc00417 	ldw	r19,16(sp)
   1d17c:	dc800317 	ldw	r18,12(sp)
   1d180:	dc400217 	ldw	r17,8(sp)
   1d184:	dc000117 	ldw	r16,4(sp)
   1d188:	dec00b04 	addi	sp,sp,44
   1d18c:	f800283a 	ret
   1d190:	01ffff04 	movi	r7,-4
   1d194:	31cc703a 	and	r6,r6,r7
   1d198:	34e9883a 	add	r20,r6,r19
   1d19c:	a0ffbb16 	blt	r20,r3,1d08c <_realloc_r+0xac>
   1d1a0:	20c00317 	ldw	r3,12(r4)
   1d1a4:	21000217 	ldw	r4,8(r4)
   1d1a8:	20c00315 	stw	r3,12(r4)
   1d1ac:	19000215 	stw	r4,8(r3)
   1d1b0:	003fdd06 	br	1d128 <_realloc_r+0x148>
   1d1b4:	00800304 	movi	r2,12
   1d1b8:	a8800015 	stw	r2,0(r21)
   1d1bc:	0025883a 	mov	r18,zero
   1d1c0:	003fe606 	br	1d15c <_realloc_r+0x17c>
   1d1c4:	1444b03a 	or	r2,r2,r17
   1d1c8:	b0800115 	stw	r2,4(r22)
   1d1cc:	b44b883a 	add	r5,r22,r17
   1d1d0:	18800054 	ori	r2,r3,1
   1d1d4:	28800115 	stw	r2,4(r5)
   1d1d8:	28c7883a 	add	r3,r5,r3
   1d1dc:	18800117 	ldw	r2,4(r3)
   1d1e0:	a809883a 	mov	r4,r21
   1d1e4:	29400204 	addi	r5,r5,8
   1d1e8:	10800054 	ori	r2,r2,1
   1d1ec:	18800115 	stw	r2,4(r3)
   1d1f0:	001aafc0 	call	1aafc <_free_r>
   1d1f4:	003fd606 	br	1d150 <_realloc_r+0x170>
   1d1f8:	38c0330e 	bge	r7,r3,1d2c8 <_realloc_r+0x2e8>
   1d1fc:	900b883a 	mov	r5,r18
   1d200:	a809883a 	mov	r4,r21
   1d204:	001b6940 	call	1b694 <_malloc_r>
   1d208:	1025883a 	mov	r18,r2
   1d20c:	10001626 	beq	r2,zero,1d268 <_realloc_r+0x288>
   1d210:	80bfff17 	ldw	r2,-4(r16)
   1d214:	00ffff84 	movi	r3,-2
   1d218:	913ffe04 	addi	r4,r18,-8
   1d21c:	10c6703a 	and	r3,r2,r3
   1d220:	b0c7883a 	add	r3,r22,r3
   1d224:	20c09926 	beq	r4,r3,1d48c <_realloc_r+0x4ac>
   1d228:	99bfff04 	addi	r6,r19,-4
   1d22c:	00800904 	movi	r2,36
   1d230:	11806436 	bltu	r2,r6,1d3c4 <_realloc_r+0x3e4>
   1d234:	00c004c4 	movi	r3,19
   1d238:	19804036 	bltu	r3,r6,1d33c <_realloc_r+0x35c>
   1d23c:	9005883a 	mov	r2,r18
   1d240:	8007883a 	mov	r3,r16
   1d244:	19000017 	ldw	r4,0(r3)
   1d248:	11000015 	stw	r4,0(r2)
   1d24c:	19000117 	ldw	r4,4(r3)
   1d250:	11000115 	stw	r4,4(r2)
   1d254:	18c00217 	ldw	r3,8(r3)
   1d258:	10c00215 	stw	r3,8(r2)
   1d25c:	a809883a 	mov	r4,r21
   1d260:	800b883a 	mov	r5,r16
   1d264:	001aafc0 	call	1aafc <_free_r>
   1d268:	a809883a 	mov	r4,r21
   1d26c:	00202f40 	call	202f4 <__malloc_unlock>
   1d270:	003fba06 	br	1d15c <_realloc_r+0x17c>
   1d274:	300b883a 	mov	r5,r6
   1d278:	dfc00a17 	ldw	ra,40(sp)
   1d27c:	df000917 	ldw	fp,36(sp)
   1d280:	ddc00817 	ldw	r23,32(sp)
   1d284:	dd800717 	ldw	r22,28(sp)
   1d288:	dd400617 	ldw	r21,24(sp)
   1d28c:	dd000517 	ldw	r20,20(sp)
   1d290:	dcc00417 	ldw	r19,16(sp)
   1d294:	dc800317 	ldw	r18,12(sp)
   1d298:	dc400217 	ldw	r17,8(sp)
   1d29c:	dc000117 	ldw	r16,4(sp)
   1d2a0:	dec00b04 	addi	sp,sp,44
   1d2a4:	001b6941 	jmpi	1b694 <_malloc_r>
   1d2a8:	29800117 	ldw	r6,4(r5)
   1d2ac:	013fff04 	movi	r4,-4
   1d2b0:	89c00404 	addi	r7,r17,16
   1d2b4:	310c703a 	and	r6,r6,r4
   1d2b8:	34c9883a 	add	r4,r6,r19
   1d2bc:	21c0340e 	bge	r4,r7,1d390 <_realloc_r+0x3b0>
   1d2c0:	2809883a 	mov	r4,r5
   1d2c4:	003f7106 	br	1d08c <_realloc_r+0xac>
   1d2c8:	b8800317 	ldw	r2,12(r23)
   1d2cc:	b8c00217 	ldw	r3,8(r23)
   1d2d0:	99bfff04 	addi	r6,r19,-4
   1d2d4:	01000904 	movi	r4,36
   1d2d8:	18800315 	stw	r2,12(r3)
   1d2dc:	10c00215 	stw	r3,8(r2)
   1d2e0:	bc800204 	addi	r18,r23,8
   1d2e4:	21807836 	bltu	r4,r6,1d4c8 <_realloc_r+0x4e8>
   1d2e8:	008004c4 	movi	r2,19
   1d2ec:	1180732e 	bgeu	r2,r6,1d4bc <_realloc_r+0x4dc>
   1d2f0:	80800017 	ldw	r2,0(r16)
   1d2f4:	b8800215 	stw	r2,8(r23)
   1d2f8:	80800117 	ldw	r2,4(r16)
   1d2fc:	b8800315 	stw	r2,12(r23)
   1d300:	008006c4 	movi	r2,27
   1d304:	11808936 	bltu	r2,r6,1d52c <_realloc_r+0x54c>
   1d308:	b8800404 	addi	r2,r23,16
   1d30c:	80c00204 	addi	r3,r16,8
   1d310:	19000017 	ldw	r4,0(r3)
   1d314:	9021883a 	mov	r16,r18
   1d318:	3829883a 	mov	r20,r7
   1d31c:	11000015 	stw	r4,0(r2)
   1d320:	19000117 	ldw	r4,4(r3)
   1d324:	b82d883a 	mov	r22,r23
   1d328:	11000115 	stw	r4,4(r2)
   1d32c:	18c00217 	ldw	r3,8(r3)
   1d330:	10c00215 	stw	r3,8(r2)
   1d334:	b8800117 	ldw	r2,4(r23)
   1d338:	003f7b06 	br	1d128 <_realloc_r+0x148>
   1d33c:	80c00017 	ldw	r3,0(r16)
   1d340:	90c00015 	stw	r3,0(r18)
   1d344:	80c00117 	ldw	r3,4(r16)
   1d348:	90c00115 	stw	r3,4(r18)
   1d34c:	00c006c4 	movi	r3,27
   1d350:	19804636 	bltu	r3,r6,1d46c <_realloc_r+0x48c>
   1d354:	90800204 	addi	r2,r18,8
   1d358:	80c00204 	addi	r3,r16,8
   1d35c:	003fb906 	br	1d244 <_realloc_r+0x264>
   1d360:	9005883a 	mov	r2,r18
   1d364:	8007883a 	mov	r3,r16
   1d368:	19000017 	ldw	r4,0(r3)
   1d36c:	9021883a 	mov	r16,r18
   1d370:	b82d883a 	mov	r22,r23
   1d374:	11000015 	stw	r4,0(r2)
   1d378:	19000117 	ldw	r4,4(r3)
   1d37c:	11000115 	stw	r4,4(r2)
   1d380:	18c00217 	ldw	r3,8(r3)
   1d384:	10c00215 	stw	r3,8(r2)
   1d388:	b8800117 	ldw	r2,4(r23)
   1d38c:	003f6606 	br	1d128 <_realloc_r+0x148>
   1d390:	2445c83a 	sub	r2,r4,r17
   1d394:	b46d883a 	add	r22,r22,r17
   1d398:	10800054 	ori	r2,r2,1
   1d39c:	b0800115 	stw	r2,4(r22)
   1d3a0:	80bfff17 	ldw	r2,-4(r16)
   1d3a4:	a809883a 	mov	r4,r21
   1d3a8:	e5800215 	stw	r22,8(fp)
   1d3ac:	1080004c 	andi	r2,r2,1
   1d3b0:	88a2b03a 	or	r17,r17,r2
   1d3b4:	847fff15 	stw	r17,-4(r16)
   1d3b8:	00202f40 	call	202f4 <__malloc_unlock>
   1d3bc:	8025883a 	mov	r18,r16
   1d3c0:	003f6606 	br	1d15c <_realloc_r+0x17c>
   1d3c4:	9009883a 	mov	r4,r18
   1d3c8:	800b883a 	mov	r5,r16
   1d3cc:	001bf100 	call	1bf10 <memmove>
   1d3d0:	003fa206 	br	1d25c <_realloc_r+0x27c>
   1d3d4:	88800404 	addi	r2,r17,16
   1d3d8:	a0bf8716 	blt	r20,r2,1d1f8 <_realloc_r+0x218>
   1d3dc:	b8800317 	ldw	r2,12(r23)
   1d3e0:	b8c00217 	ldw	r3,8(r23)
   1d3e4:	99bfff04 	addi	r6,r19,-4
   1d3e8:	01000904 	movi	r4,36
   1d3ec:	18800315 	stw	r2,12(r3)
   1d3f0:	10c00215 	stw	r3,8(r2)
   1d3f4:	bc800204 	addi	r18,r23,8
   1d3f8:	21806536 	bltu	r4,r6,1d590 <_realloc_r+0x5b0>
   1d3fc:	008004c4 	movi	r2,19
   1d400:	1180592e 	bgeu	r2,r6,1d568 <_realloc_r+0x588>
   1d404:	80800017 	ldw	r2,0(r16)
   1d408:	b8800215 	stw	r2,8(r23)
   1d40c:	80800117 	ldw	r2,4(r16)
   1d410:	b8800315 	stw	r2,12(r23)
   1d414:	008006c4 	movi	r2,27
   1d418:	11806136 	bltu	r2,r6,1d5a0 <_realloc_r+0x5c0>
   1d41c:	b8800404 	addi	r2,r23,16
   1d420:	80c00204 	addi	r3,r16,8
   1d424:	19000017 	ldw	r4,0(r3)
   1d428:	11000015 	stw	r4,0(r2)
   1d42c:	19000117 	ldw	r4,4(r3)
   1d430:	11000115 	stw	r4,4(r2)
   1d434:	18c00217 	ldw	r3,8(r3)
   1d438:	10c00215 	stw	r3,8(r2)
   1d43c:	a447c83a 	sub	r3,r20,r17
   1d440:	bc45883a 	add	r2,r23,r17
   1d444:	18c00054 	ori	r3,r3,1
   1d448:	10c00115 	stw	r3,4(r2)
   1d44c:	b8c00117 	ldw	r3,4(r23)
   1d450:	e0800215 	stw	r2,8(fp)
   1d454:	a809883a 	mov	r4,r21
   1d458:	1880004c 	andi	r2,r3,1
   1d45c:	88a2b03a 	or	r17,r17,r2
   1d460:	bc400115 	stw	r17,4(r23)
   1d464:	00202f40 	call	202f4 <__malloc_unlock>
   1d468:	003f3c06 	br	1d15c <_realloc_r+0x17c>
   1d46c:	80c00217 	ldw	r3,8(r16)
   1d470:	90c00215 	stw	r3,8(r18)
   1d474:	80c00317 	ldw	r3,12(r16)
   1d478:	90c00315 	stw	r3,12(r18)
   1d47c:	30802426 	beq	r6,r2,1d510 <_realloc_r+0x530>
   1d480:	90800404 	addi	r2,r18,16
   1d484:	80c00404 	addi	r3,r16,16
   1d488:	003f6e06 	br	1d244 <_realloc_r+0x264>
   1d48c:	953fff17 	ldw	r20,-4(r18)
   1d490:	00ffff04 	movi	r3,-4
   1d494:	a0e8703a 	and	r20,r20,r3
   1d498:	a4e9883a 	add	r20,r20,r19
   1d49c:	003f2206 	br	1d128 <_realloc_r+0x148>
   1d4a0:	800b883a 	mov	r5,r16
   1d4a4:	9009883a 	mov	r4,r18
   1d4a8:	001bf100 	call	1bf10 <memmove>
   1d4ac:	9021883a 	mov	r16,r18
   1d4b0:	b8800117 	ldw	r2,4(r23)
   1d4b4:	b82d883a 	mov	r22,r23
   1d4b8:	003f1b06 	br	1d128 <_realloc_r+0x148>
   1d4bc:	9005883a 	mov	r2,r18
   1d4c0:	8007883a 	mov	r3,r16
   1d4c4:	003f9206 	br	1d310 <_realloc_r+0x330>
   1d4c8:	800b883a 	mov	r5,r16
   1d4cc:	9009883a 	mov	r4,r18
   1d4d0:	d9c00015 	stw	r7,0(sp)
   1d4d4:	001bf100 	call	1bf10 <memmove>
   1d4d8:	d9c00017 	ldw	r7,0(sp)
   1d4dc:	9021883a 	mov	r16,r18
   1d4e0:	b8800117 	ldw	r2,4(r23)
   1d4e4:	3829883a 	mov	r20,r7
   1d4e8:	b82d883a 	mov	r22,r23
   1d4ec:	003f0e06 	br	1d128 <_realloc_r+0x148>
   1d4f0:	80800217 	ldw	r2,8(r16)
   1d4f4:	b8800415 	stw	r2,16(r23)
   1d4f8:	80800317 	ldw	r2,12(r16)
   1d4fc:	b8800515 	stw	r2,20(r23)
   1d500:	31001226 	beq	r6,r4,1d54c <_realloc_r+0x56c>
   1d504:	b8800604 	addi	r2,r23,24
   1d508:	80c00404 	addi	r3,r16,16
   1d50c:	003f9606 	br	1d368 <_realloc_r+0x388>
   1d510:	81000417 	ldw	r4,16(r16)
   1d514:	90800604 	addi	r2,r18,24
   1d518:	80c00604 	addi	r3,r16,24
   1d51c:	91000415 	stw	r4,16(r18)
   1d520:	81000517 	ldw	r4,20(r16)
   1d524:	91000515 	stw	r4,20(r18)
   1d528:	003f4606 	br	1d244 <_realloc_r+0x264>
   1d52c:	80800217 	ldw	r2,8(r16)
   1d530:	b8800415 	stw	r2,16(r23)
   1d534:	80800317 	ldw	r2,12(r16)
   1d538:	b8800515 	stw	r2,20(r23)
   1d53c:	31000d26 	beq	r6,r4,1d574 <_realloc_r+0x594>
   1d540:	b8800604 	addi	r2,r23,24
   1d544:	80c00404 	addi	r3,r16,16
   1d548:	003f7106 	br	1d310 <_realloc_r+0x330>
   1d54c:	81000417 	ldw	r4,16(r16)
   1d550:	b8800804 	addi	r2,r23,32
   1d554:	80c00604 	addi	r3,r16,24
   1d558:	b9000615 	stw	r4,24(r23)
   1d55c:	81000517 	ldw	r4,20(r16)
   1d560:	b9000715 	stw	r4,28(r23)
   1d564:	003f8006 	br	1d368 <_realloc_r+0x388>
   1d568:	9005883a 	mov	r2,r18
   1d56c:	8007883a 	mov	r3,r16
   1d570:	003fac06 	br	1d424 <_realloc_r+0x444>
   1d574:	81000417 	ldw	r4,16(r16)
   1d578:	b8800804 	addi	r2,r23,32
   1d57c:	80c00604 	addi	r3,r16,24
   1d580:	b9000615 	stw	r4,24(r23)
   1d584:	81000517 	ldw	r4,20(r16)
   1d588:	b9000715 	stw	r4,28(r23)
   1d58c:	003f6006 	br	1d310 <_realloc_r+0x330>
   1d590:	9009883a 	mov	r4,r18
   1d594:	800b883a 	mov	r5,r16
   1d598:	001bf100 	call	1bf10 <memmove>
   1d59c:	003fa706 	br	1d43c <_realloc_r+0x45c>
   1d5a0:	80800217 	ldw	r2,8(r16)
   1d5a4:	b8800415 	stw	r2,16(r23)
   1d5a8:	80800317 	ldw	r2,12(r16)
   1d5ac:	b8800515 	stw	r2,20(r23)
   1d5b0:	31000326 	beq	r6,r4,1d5c0 <_realloc_r+0x5e0>
   1d5b4:	b8800604 	addi	r2,r23,24
   1d5b8:	80c00404 	addi	r3,r16,16
   1d5bc:	003f9906 	br	1d424 <_realloc_r+0x444>
   1d5c0:	81000417 	ldw	r4,16(r16)
   1d5c4:	b8800804 	addi	r2,r23,32
   1d5c8:	80c00604 	addi	r3,r16,24
   1d5cc:	b9000615 	stw	r4,24(r23)
   1d5d0:	81000517 	ldw	r4,20(r16)
   1d5d4:	b9000715 	stw	r4,28(r23)
   1d5d8:	003f9206 	br	1d424 <_realloc_r+0x444>

0001d5dc <__isinfd>:
   1d5dc:	0105c83a 	sub	r2,zero,r4
   1d5e0:	1108b03a 	or	r4,r2,r4
   1d5e4:	2004d7fa 	srli	r2,r4,31
   1d5e8:	00e00034 	movhi	r3,32768
   1d5ec:	18ffffc4 	addi	r3,r3,-1
   1d5f0:	28ca703a 	and	r5,r5,r3
   1d5f4:	1144b03a 	or	r2,r2,r5
   1d5f8:	00dffc34 	movhi	r3,32752
   1d5fc:	1885c83a 	sub	r2,r3,r2
   1d600:	0087c83a 	sub	r3,zero,r2
   1d604:	1884b03a 	or	r2,r3,r2
   1d608:	1005d7fa 	srai	r2,r2,31
   1d60c:	10800044 	addi	r2,r2,1
   1d610:	f800283a 	ret

0001d614 <__isnand>:
   1d614:	0105c83a 	sub	r2,zero,r4
   1d618:	1108b03a 	or	r4,r2,r4
   1d61c:	2004d7fa 	srli	r2,r4,31
   1d620:	00e00034 	movhi	r3,32768
   1d624:	18ffffc4 	addi	r3,r3,-1
   1d628:	28ca703a 	and	r5,r5,r3
   1d62c:	1144b03a 	or	r2,r2,r5
   1d630:	00dffc34 	movhi	r3,32752
   1d634:	1885c83a 	sub	r2,r3,r2
   1d638:	1004d7fa 	srli	r2,r2,31
   1d63c:	f800283a 	ret

0001d640 <_sbrk_r>:
   1d640:	defffd04 	addi	sp,sp,-12
   1d644:	dc400115 	stw	r17,4(sp)
   1d648:	dc000015 	stw	r16,0(sp)
   1d64c:	2023883a 	mov	r17,r4
   1d650:	040000f4 	movhi	r16,3
   1d654:	84161104 	addi	r16,r16,22596
   1d658:	2809883a 	mov	r4,r5
   1d65c:	dfc00215 	stw	ra,8(sp)
   1d660:	80000015 	stw	zero,0(r16)
   1d664:	00204f40 	call	204f4 <sbrk>
   1d668:	00ffffc4 	movi	r3,-1
   1d66c:	10c00526 	beq	r2,r3,1d684 <_sbrk_r+0x44>
   1d670:	dfc00217 	ldw	ra,8(sp)
   1d674:	dc400117 	ldw	r17,4(sp)
   1d678:	dc000017 	ldw	r16,0(sp)
   1d67c:	dec00304 	addi	sp,sp,12
   1d680:	f800283a 	ret
   1d684:	80c00017 	ldw	r3,0(r16)
   1d688:	183ff926 	beq	r3,zero,1d670 <_sbrk_r+0x30>
   1d68c:	88c00015 	stw	r3,0(r17)
   1d690:	dfc00217 	ldw	ra,8(sp)
   1d694:	dc400117 	ldw	r17,4(sp)
   1d698:	dc000017 	ldw	r16,0(sp)
   1d69c:	dec00304 	addi	sp,sp,12
   1d6a0:	f800283a 	ret

0001d6a4 <__sread>:
   1d6a4:	defffe04 	addi	sp,sp,-8
   1d6a8:	dc000015 	stw	r16,0(sp)
   1d6ac:	2821883a 	mov	r16,r5
   1d6b0:	2940038f 	ldh	r5,14(r5)
   1d6b4:	dfc00115 	stw	ra,4(sp)
   1d6b8:	001dbf80 	call	1dbf8 <_read_r>
   1d6bc:	10000716 	blt	r2,zero,1d6dc <__sread+0x38>
   1d6c0:	80c01417 	ldw	r3,80(r16)
   1d6c4:	1887883a 	add	r3,r3,r2
   1d6c8:	80c01415 	stw	r3,80(r16)
   1d6cc:	dfc00117 	ldw	ra,4(sp)
   1d6d0:	dc000017 	ldw	r16,0(sp)
   1d6d4:	dec00204 	addi	sp,sp,8
   1d6d8:	f800283a 	ret
   1d6dc:	80c0030b 	ldhu	r3,12(r16)
   1d6e0:	18fbffcc 	andi	r3,r3,61439
   1d6e4:	80c0030d 	sth	r3,12(r16)
   1d6e8:	dfc00117 	ldw	ra,4(sp)
   1d6ec:	dc000017 	ldw	r16,0(sp)
   1d6f0:	dec00204 	addi	sp,sp,8
   1d6f4:	f800283a 	ret

0001d6f8 <__swrite>:
   1d6f8:	2880030b 	ldhu	r2,12(r5)
   1d6fc:	defffb04 	addi	sp,sp,-20
   1d700:	dcc00315 	stw	r19,12(sp)
   1d704:	10c0400c 	andi	r3,r2,256
   1d708:	18ffffcc 	andi	r3,r3,65535
   1d70c:	18e0001c 	xori	r3,r3,32768
   1d710:	dc800215 	stw	r18,8(sp)
   1d714:	dc400115 	stw	r17,4(sp)
   1d718:	dc000015 	stw	r16,0(sp)
   1d71c:	dfc00415 	stw	ra,16(sp)
   1d720:	18e00004 	addi	r3,r3,-32768
   1d724:	2821883a 	mov	r16,r5
   1d728:	2027883a 	mov	r19,r4
   1d72c:	3025883a 	mov	r18,r6
   1d730:	3823883a 	mov	r17,r7
   1d734:	18000526 	beq	r3,zero,1d74c <__swrite+0x54>
   1d738:	2940038f 	ldh	r5,14(r5)
   1d73c:	000d883a 	mov	r6,zero
   1d740:	01c00084 	movi	r7,2
   1d744:	001db8c0 	call	1db8c <_lseek_r>
   1d748:	8080030b 	ldhu	r2,12(r16)
   1d74c:	8140038f 	ldh	r5,14(r16)
   1d750:	10bbffcc 	andi	r2,r2,61439
   1d754:	9809883a 	mov	r4,r19
   1d758:	900d883a 	mov	r6,r18
   1d75c:	880f883a 	mov	r7,r17
   1d760:	8080030d 	sth	r2,12(r16)
   1d764:	dfc00417 	ldw	ra,16(sp)
   1d768:	dcc00317 	ldw	r19,12(sp)
   1d76c:	dc800217 	ldw	r18,8(sp)
   1d770:	dc400117 	ldw	r17,4(sp)
   1d774:	dc000017 	ldw	r16,0(sp)
   1d778:	dec00504 	addi	sp,sp,20
   1d77c:	001d7e41 	jmpi	1d7e4 <_write_r>

0001d780 <__sseek>:
   1d780:	defffe04 	addi	sp,sp,-8
   1d784:	dc000015 	stw	r16,0(sp)
   1d788:	2821883a 	mov	r16,r5
   1d78c:	2940038f 	ldh	r5,14(r5)
   1d790:	dfc00115 	stw	ra,4(sp)
   1d794:	001db8c0 	call	1db8c <_lseek_r>
   1d798:	00ffffc4 	movi	r3,-1
   1d79c:	10c00826 	beq	r2,r3,1d7c0 <__sseek+0x40>
   1d7a0:	80c0030b 	ldhu	r3,12(r16)
   1d7a4:	80801415 	stw	r2,80(r16)
   1d7a8:	18c40014 	ori	r3,r3,4096
   1d7ac:	80c0030d 	sth	r3,12(r16)
   1d7b0:	dfc00117 	ldw	ra,4(sp)
   1d7b4:	dc000017 	ldw	r16,0(sp)
   1d7b8:	dec00204 	addi	sp,sp,8
   1d7bc:	f800283a 	ret
   1d7c0:	80c0030b 	ldhu	r3,12(r16)
   1d7c4:	18fbffcc 	andi	r3,r3,61439
   1d7c8:	80c0030d 	sth	r3,12(r16)
   1d7cc:	dfc00117 	ldw	ra,4(sp)
   1d7d0:	dc000017 	ldw	r16,0(sp)
   1d7d4:	dec00204 	addi	sp,sp,8
   1d7d8:	f800283a 	ret

0001d7dc <__sclose>:
   1d7dc:	2940038f 	ldh	r5,14(r5)
   1d7e0:	001d90c1 	jmpi	1d90c <_close_r>

0001d7e4 <_write_r>:
   1d7e4:	defffd04 	addi	sp,sp,-12
   1d7e8:	dc400115 	stw	r17,4(sp)
   1d7ec:	dc000015 	stw	r16,0(sp)
   1d7f0:	2023883a 	mov	r17,r4
   1d7f4:	040000f4 	movhi	r16,3
   1d7f8:	84161104 	addi	r16,r16,22596
   1d7fc:	2809883a 	mov	r4,r5
   1d800:	300b883a 	mov	r5,r6
   1d804:	380d883a 	mov	r6,r7
   1d808:	dfc00215 	stw	ra,8(sp)
   1d80c:	80000015 	stw	zero,0(r16)
   1d810:	002089c0 	call	2089c <write>
   1d814:	00ffffc4 	movi	r3,-1
   1d818:	10c00526 	beq	r2,r3,1d830 <_write_r+0x4c>
   1d81c:	dfc00217 	ldw	ra,8(sp)
   1d820:	dc400117 	ldw	r17,4(sp)
   1d824:	dc000017 	ldw	r16,0(sp)
   1d828:	dec00304 	addi	sp,sp,12
   1d82c:	f800283a 	ret
   1d830:	80c00017 	ldw	r3,0(r16)
   1d834:	183ff926 	beq	r3,zero,1d81c <_write_r+0x38>
   1d838:	88c00015 	stw	r3,0(r17)
   1d83c:	dfc00217 	ldw	ra,8(sp)
   1d840:	dc400117 	ldw	r17,4(sp)
   1d844:	dc000017 	ldw	r16,0(sp)
   1d848:	dec00304 	addi	sp,sp,12
   1d84c:	f800283a 	ret

0001d850 <_calloc_r>:
   1d850:	314b383a 	mul	r5,r6,r5
   1d854:	defffe04 	addi	sp,sp,-8
   1d858:	dc000015 	stw	r16,0(sp)
   1d85c:	dfc00115 	stw	ra,4(sp)
   1d860:	001b6940 	call	1b694 <_malloc_r>
   1d864:	1021883a 	mov	r16,r2
   1d868:	10000c26 	beq	r2,zero,1d89c <_calloc_r+0x4c>
   1d86c:	11bfff17 	ldw	r6,-4(r2)
   1d870:	00ffff04 	movi	r3,-4
   1d874:	00800904 	movi	r2,36
   1d878:	30cc703a 	and	r6,r6,r3
   1d87c:	30cd883a 	add	r6,r6,r3
   1d880:	11801436 	bltu	r2,r6,1d8d4 <_calloc_r+0x84>
   1d884:	00c004c4 	movi	r3,19
   1d888:	19800936 	bltu	r3,r6,1d8b0 <_calloc_r+0x60>
   1d88c:	8005883a 	mov	r2,r16
   1d890:	10000015 	stw	zero,0(r2)
   1d894:	10000115 	stw	zero,4(r2)
   1d898:	10000215 	stw	zero,8(r2)
   1d89c:	8005883a 	mov	r2,r16
   1d8a0:	dfc00117 	ldw	ra,4(sp)
   1d8a4:	dc000017 	ldw	r16,0(sp)
   1d8a8:	dec00204 	addi	sp,sp,8
   1d8ac:	f800283a 	ret
   1d8b0:	80000015 	stw	zero,0(r16)
   1d8b4:	80000115 	stw	zero,4(r16)
   1d8b8:	00c006c4 	movi	r3,27
   1d8bc:	19800d2e 	bgeu	r3,r6,1d8f4 <_calloc_r+0xa4>
   1d8c0:	80000215 	stw	zero,8(r16)
   1d8c4:	80000315 	stw	zero,12(r16)
   1d8c8:	30800c26 	beq	r6,r2,1d8fc <_calloc_r+0xac>
   1d8cc:	80800404 	addi	r2,r16,16
   1d8d0:	003fef06 	br	1d890 <_calloc_r+0x40>
   1d8d4:	8009883a 	mov	r4,r16
   1d8d8:	000b883a 	mov	r5,zero
   1d8dc:	00165b80 	call	165b8 <memset>
   1d8e0:	8005883a 	mov	r2,r16
   1d8e4:	dfc00117 	ldw	ra,4(sp)
   1d8e8:	dc000017 	ldw	r16,0(sp)
   1d8ec:	dec00204 	addi	sp,sp,8
   1d8f0:	f800283a 	ret
   1d8f4:	80800204 	addi	r2,r16,8
   1d8f8:	003fe506 	br	1d890 <_calloc_r+0x40>
   1d8fc:	80000415 	stw	zero,16(r16)
   1d900:	80000515 	stw	zero,20(r16)
   1d904:	80800604 	addi	r2,r16,24
   1d908:	003fe106 	br	1d890 <_calloc_r+0x40>

0001d90c <_close_r>:
   1d90c:	defffd04 	addi	sp,sp,-12
   1d910:	dc400115 	stw	r17,4(sp)
   1d914:	dc000015 	stw	r16,0(sp)
   1d918:	2023883a 	mov	r17,r4
   1d91c:	040000f4 	movhi	r16,3
   1d920:	84161104 	addi	r16,r16,22596
   1d924:	2809883a 	mov	r4,r5
   1d928:	dfc00215 	stw	ra,8(sp)
   1d92c:	80000015 	stw	zero,0(r16)
   1d930:	001fd700 	call	1fd70 <close>
   1d934:	00ffffc4 	movi	r3,-1
   1d938:	10c00526 	beq	r2,r3,1d950 <_close_r+0x44>
   1d93c:	dfc00217 	ldw	ra,8(sp)
   1d940:	dc400117 	ldw	r17,4(sp)
   1d944:	dc000017 	ldw	r16,0(sp)
   1d948:	dec00304 	addi	sp,sp,12
   1d94c:	f800283a 	ret
   1d950:	80c00017 	ldw	r3,0(r16)
   1d954:	183ff926 	beq	r3,zero,1d93c <_close_r+0x30>
   1d958:	88c00015 	stw	r3,0(r17)
   1d95c:	dfc00217 	ldw	ra,8(sp)
   1d960:	dc400117 	ldw	r17,4(sp)
   1d964:	dc000017 	ldw	r16,0(sp)
   1d968:	dec00304 	addi	sp,sp,12
   1d96c:	f800283a 	ret

0001d970 <_fclose_r>:
   1d970:	defffc04 	addi	sp,sp,-16
   1d974:	dc400115 	stw	r17,4(sp)
   1d978:	dc000015 	stw	r16,0(sp)
   1d97c:	dfc00315 	stw	ra,12(sp)
   1d980:	dc800215 	stw	r18,8(sp)
   1d984:	2821883a 	mov	r16,r5
   1d988:	2023883a 	mov	r17,r4
   1d98c:	28003426 	beq	r5,zero,1da60 <_fclose_r+0xf0>
   1d990:	001a9800 	call	1a980 <__sfp_lock_acquire>
   1d994:	88000226 	beq	r17,zero,1d9a0 <_fclose_r+0x30>
   1d998:	88800e17 	ldw	r2,56(r17)
   1d99c:	10003826 	beq	r2,zero,1da80 <_fclose_r+0x110>
   1d9a0:	8080030f 	ldh	r2,12(r16)
   1d9a4:	10002526 	beq	r2,zero,1da3c <_fclose_r+0xcc>
   1d9a8:	8809883a 	mov	r4,r17
   1d9ac:	800b883a 	mov	r5,r16
   1d9b0:	001a4d00 	call	1a4d0 <_fflush_r>
   1d9b4:	1025883a 	mov	r18,r2
   1d9b8:	80800b17 	ldw	r2,44(r16)
   1d9bc:	10000426 	beq	r2,zero,1d9d0 <_fclose_r+0x60>
   1d9c0:	81400717 	ldw	r5,28(r16)
   1d9c4:	8809883a 	mov	r4,r17
   1d9c8:	103ee83a 	callr	r2
   1d9cc:	10003516 	blt	r2,zero,1daa4 <_fclose_r+0x134>
   1d9d0:	8080030b 	ldhu	r2,12(r16)
   1d9d4:	1080200c 	andi	r2,r2,128
   1d9d8:	10bfffcc 	andi	r2,r2,65535
   1d9dc:	10a0001c 	xori	r2,r2,32768
   1d9e0:	10a00004 	addi	r2,r2,-32768
   1d9e4:	10002b1e 	bne	r2,zero,1da94 <_fclose_r+0x124>
   1d9e8:	81400c17 	ldw	r5,48(r16)
   1d9ec:	28000526 	beq	r5,zero,1da04 <_fclose_r+0x94>
   1d9f0:	80801004 	addi	r2,r16,64
   1d9f4:	28800226 	beq	r5,r2,1da00 <_fclose_r+0x90>
   1d9f8:	8809883a 	mov	r4,r17
   1d9fc:	001aafc0 	call	1aafc <_free_r>
   1da00:	80000c15 	stw	zero,48(r16)
   1da04:	81401117 	ldw	r5,68(r16)
   1da08:	28000326 	beq	r5,zero,1da18 <_fclose_r+0xa8>
   1da0c:	8809883a 	mov	r4,r17
   1da10:	001aafc0 	call	1aafc <_free_r>
   1da14:	80001115 	stw	zero,68(r16)
   1da18:	8000030d 	sth	zero,12(r16)
   1da1c:	001a9840 	call	1a984 <__sfp_lock_release>
   1da20:	9005883a 	mov	r2,r18
   1da24:	dfc00317 	ldw	ra,12(sp)
   1da28:	dc800217 	ldw	r18,8(sp)
   1da2c:	dc400117 	ldw	r17,4(sp)
   1da30:	dc000017 	ldw	r16,0(sp)
   1da34:	dec00404 	addi	sp,sp,16
   1da38:	f800283a 	ret
   1da3c:	001a9840 	call	1a984 <__sfp_lock_release>
   1da40:	0025883a 	mov	r18,zero
   1da44:	9005883a 	mov	r2,r18
   1da48:	dfc00317 	ldw	ra,12(sp)
   1da4c:	dc800217 	ldw	r18,8(sp)
   1da50:	dc400117 	ldw	r17,4(sp)
   1da54:	dc000017 	ldw	r16,0(sp)
   1da58:	dec00404 	addi	sp,sp,16
   1da5c:	f800283a 	ret
   1da60:	0025883a 	mov	r18,zero
   1da64:	9005883a 	mov	r2,r18
   1da68:	dfc00317 	ldw	ra,12(sp)
   1da6c:	dc800217 	ldw	r18,8(sp)
   1da70:	dc400117 	ldw	r17,4(sp)
   1da74:	dc000017 	ldw	r16,0(sp)
   1da78:	dec00404 	addi	sp,sp,16
   1da7c:	f800283a 	ret
   1da80:	8809883a 	mov	r4,r17
   1da84:	001a7780 	call	1a778 <__sinit>
   1da88:	8080030f 	ldh	r2,12(r16)
   1da8c:	103fc61e 	bne	r2,zero,1d9a8 <_fclose_r+0x38>
   1da90:	003fea06 	br	1da3c <_fclose_r+0xcc>
   1da94:	81400417 	ldw	r5,16(r16)
   1da98:	8809883a 	mov	r4,r17
   1da9c:	001aafc0 	call	1aafc <_free_r>
   1daa0:	003fd106 	br	1d9e8 <_fclose_r+0x78>
   1daa4:	04bfffc4 	movi	r18,-1
   1daa8:	003fc906 	br	1d9d0 <_fclose_r+0x60>

0001daac <fclose>:
   1daac:	008000f4 	movhi	r2,3
   1dab0:	108d2b04 	addi	r2,r2,13484
   1dab4:	200b883a 	mov	r5,r4
   1dab8:	11000017 	ldw	r4,0(r2)
   1dabc:	001d9701 	jmpi	1d970 <_fclose_r>

0001dac0 <_fstat_r>:
   1dac0:	defffd04 	addi	sp,sp,-12
   1dac4:	dc400115 	stw	r17,4(sp)
   1dac8:	dc000015 	stw	r16,0(sp)
   1dacc:	2023883a 	mov	r17,r4
   1dad0:	040000f4 	movhi	r16,3
   1dad4:	84161104 	addi	r16,r16,22596
   1dad8:	2809883a 	mov	r4,r5
   1dadc:	300b883a 	mov	r5,r6
   1dae0:	dfc00215 	stw	ra,8(sp)
   1dae4:	80000015 	stw	zero,0(r16)
   1dae8:	001feb40 	call	1feb4 <fstat>
   1daec:	00ffffc4 	movi	r3,-1
   1daf0:	10c00526 	beq	r2,r3,1db08 <_fstat_r+0x48>
   1daf4:	dfc00217 	ldw	ra,8(sp)
   1daf8:	dc400117 	ldw	r17,4(sp)
   1dafc:	dc000017 	ldw	r16,0(sp)
   1db00:	dec00304 	addi	sp,sp,12
   1db04:	f800283a 	ret
   1db08:	80c00017 	ldw	r3,0(r16)
   1db0c:	183ff926 	beq	r3,zero,1daf4 <_fstat_r+0x34>
   1db10:	88c00015 	stw	r3,0(r17)
   1db14:	dfc00217 	ldw	ra,8(sp)
   1db18:	dc400117 	ldw	r17,4(sp)
   1db1c:	dc000017 	ldw	r16,0(sp)
   1db20:	dec00304 	addi	sp,sp,12
   1db24:	f800283a 	ret

0001db28 <_isatty_r>:
   1db28:	defffd04 	addi	sp,sp,-12
   1db2c:	dc400115 	stw	r17,4(sp)
   1db30:	dc000015 	stw	r16,0(sp)
   1db34:	2023883a 	mov	r17,r4
   1db38:	040000f4 	movhi	r16,3
   1db3c:	84161104 	addi	r16,r16,22596
   1db40:	2809883a 	mov	r4,r5
   1db44:	dfc00215 	stw	ra,8(sp)
   1db48:	80000015 	stw	zero,0(r16)
   1db4c:	001ffb00 	call	1ffb0 <isatty>
   1db50:	00ffffc4 	movi	r3,-1
   1db54:	10c00526 	beq	r2,r3,1db6c <_isatty_r+0x44>
   1db58:	dfc00217 	ldw	ra,8(sp)
   1db5c:	dc400117 	ldw	r17,4(sp)
   1db60:	dc000017 	ldw	r16,0(sp)
   1db64:	dec00304 	addi	sp,sp,12
   1db68:	f800283a 	ret
   1db6c:	80c00017 	ldw	r3,0(r16)
   1db70:	183ff926 	beq	r3,zero,1db58 <_isatty_r+0x30>
   1db74:	88c00015 	stw	r3,0(r17)
   1db78:	dfc00217 	ldw	ra,8(sp)
   1db7c:	dc400117 	ldw	r17,4(sp)
   1db80:	dc000017 	ldw	r16,0(sp)
   1db84:	dec00304 	addi	sp,sp,12
   1db88:	f800283a 	ret

0001db8c <_lseek_r>:
   1db8c:	defffd04 	addi	sp,sp,-12
   1db90:	dc400115 	stw	r17,4(sp)
   1db94:	dc000015 	stw	r16,0(sp)
   1db98:	2023883a 	mov	r17,r4
   1db9c:	040000f4 	movhi	r16,3
   1dba0:	84161104 	addi	r16,r16,22596
   1dba4:	2809883a 	mov	r4,r5
   1dba8:	300b883a 	mov	r5,r6
   1dbac:	380d883a 	mov	r6,r7
   1dbb0:	dfc00215 	stw	ra,8(sp)
   1dbb4:	80000015 	stw	zero,0(r16)
   1dbb8:	002018c0 	call	2018c <lseek>
   1dbbc:	00ffffc4 	movi	r3,-1
   1dbc0:	10c00526 	beq	r2,r3,1dbd8 <_lseek_r+0x4c>
   1dbc4:	dfc00217 	ldw	ra,8(sp)
   1dbc8:	dc400117 	ldw	r17,4(sp)
   1dbcc:	dc000017 	ldw	r16,0(sp)
   1dbd0:	dec00304 	addi	sp,sp,12
   1dbd4:	f800283a 	ret
   1dbd8:	80c00017 	ldw	r3,0(r16)
   1dbdc:	183ff926 	beq	r3,zero,1dbc4 <_lseek_r+0x38>
   1dbe0:	88c00015 	stw	r3,0(r17)
   1dbe4:	dfc00217 	ldw	ra,8(sp)
   1dbe8:	dc400117 	ldw	r17,4(sp)
   1dbec:	dc000017 	ldw	r16,0(sp)
   1dbf0:	dec00304 	addi	sp,sp,12
   1dbf4:	f800283a 	ret

0001dbf8 <_read_r>:
   1dbf8:	defffd04 	addi	sp,sp,-12
   1dbfc:	dc400115 	stw	r17,4(sp)
   1dc00:	dc000015 	stw	r16,0(sp)
   1dc04:	2023883a 	mov	r17,r4
   1dc08:	040000f4 	movhi	r16,3
   1dc0c:	84161104 	addi	r16,r16,22596
   1dc10:	2809883a 	mov	r4,r5
   1dc14:	300b883a 	mov	r5,r6
   1dc18:	380d883a 	mov	r6,r7
   1dc1c:	dfc00215 	stw	ra,8(sp)
   1dc20:	80000015 	stw	zero,0(r16)
   1dc24:	00203640 	call	20364 <read>
   1dc28:	00ffffc4 	movi	r3,-1
   1dc2c:	10c00526 	beq	r2,r3,1dc44 <_read_r+0x4c>
   1dc30:	dfc00217 	ldw	ra,8(sp)
   1dc34:	dc400117 	ldw	r17,4(sp)
   1dc38:	dc000017 	ldw	r16,0(sp)
   1dc3c:	dec00304 	addi	sp,sp,12
   1dc40:	f800283a 	ret
   1dc44:	80c00017 	ldw	r3,0(r16)
   1dc48:	183ff926 	beq	r3,zero,1dc30 <_read_r+0x38>
   1dc4c:	88c00015 	stw	r3,0(r17)
   1dc50:	dfc00217 	ldw	ra,8(sp)
   1dc54:	dc400117 	ldw	r17,4(sp)
   1dc58:	dc000017 	ldw	r16,0(sp)
   1dc5c:	dec00304 	addi	sp,sp,12
   1dc60:	f800283a 	ret

0001dc64 <__udivdi3>:
   1dc64:	defff504 	addi	sp,sp,-44
   1dc68:	dd000515 	stw	r20,20(sp)
   1dc6c:	dcc00415 	stw	r19,16(sp)
   1dc70:	dc800315 	stw	r18,12(sp)
   1dc74:	dc400215 	stw	r17,8(sp)
   1dc78:	dc000115 	stw	r16,4(sp)
   1dc7c:	dfc00a15 	stw	ra,40(sp)
   1dc80:	df000915 	stw	fp,36(sp)
   1dc84:	ddc00815 	stw	r23,32(sp)
   1dc88:	dd800715 	stw	r22,28(sp)
   1dc8c:	dd400615 	stw	r21,24(sp)
   1dc90:	2025883a 	mov	r18,r4
   1dc94:	2823883a 	mov	r17,r5
   1dc98:	3021883a 	mov	r16,r6
   1dc9c:	2027883a 	mov	r19,r4
   1dca0:	2829883a 	mov	r20,r5
   1dca4:	3800401e 	bne	r7,zero,1dda8 <__udivdi3+0x144>
   1dca8:	2980602e 	bgeu	r5,r6,1de2c <__udivdi3+0x1c8>
   1dcac:	00bfffd4 	movui	r2,65535
   1dcb0:	1180aa36 	bltu	r2,r6,1df5c <__udivdi3+0x2f8>
   1dcb4:	00803fc4 	movi	r2,255
   1dcb8:	11814436 	bltu	r2,r6,1e1cc <__udivdi3+0x568>
   1dcbc:	0005883a 	mov	r2,zero
   1dcc0:	0007883a 	mov	r3,zero
   1dcc4:	3084d83a 	srl	r2,r6,r2
   1dcc8:	010000f4 	movhi	r4,3
   1dccc:	213c8604 	addi	r4,r4,-3560
   1dcd0:	2085883a 	add	r2,r4,r2
   1dcd4:	10800003 	ldbu	r2,0(r2)
   1dcd8:	10c7883a 	add	r3,r2,r3
   1dcdc:	00800804 	movi	r2,32
   1dce0:	10c5c83a 	sub	r2,r2,r3
   1dce4:	10000526 	beq	r2,zero,1dcfc <__udivdi3+0x98>
   1dce8:	88a2983a 	sll	r17,r17,r2
   1dcec:	90c6d83a 	srl	r3,r18,r3
   1dcf0:	30a0983a 	sll	r16,r6,r2
   1dcf4:	90a6983a 	sll	r19,r18,r2
   1dcf8:	88e8b03a 	or	r20,r17,r3
   1dcfc:	8022d43a 	srli	r17,r16,16
   1dd00:	a009883a 	mov	r4,r20
   1dd04:	857fffcc 	andi	r21,r16,65535
   1dd08:	880b883a 	mov	r5,r17
   1dd0c:	001f6200 	call	1f620 <__umodsi3>
   1dd10:	a009883a 	mov	r4,r20
   1dd14:	880b883a 	mov	r5,r17
   1dd18:	102d883a 	mov	r22,r2
   1dd1c:	001f6180 	call	1f618 <__udivsi3>
   1dd20:	b02c943a 	slli	r22,r22,16
   1dd24:	9806d43a 	srli	r3,r19,16
   1dd28:	1549383a 	mul	r4,r2,r21
   1dd2c:	1025883a 	mov	r18,r2
   1dd30:	b0c6b03a 	or	r3,r22,r3
   1dd34:	1900052e 	bgeu	r3,r4,1dd4c <__udivdi3+0xe8>
   1dd38:	1c07883a 	add	r3,r3,r16
   1dd3c:	10bfffc4 	addi	r2,r2,-1
   1dd40:	1c000136 	bltu	r3,r16,1dd48 <__udivdi3+0xe4>
   1dd44:	19013636 	bltu	r3,r4,1e220 <__udivdi3+0x5bc>
   1dd48:	1025883a 	mov	r18,r2
   1dd4c:	1929c83a 	sub	r20,r3,r4
   1dd50:	a009883a 	mov	r4,r20
   1dd54:	880b883a 	mov	r5,r17
   1dd58:	001f6200 	call	1f620 <__umodsi3>
   1dd5c:	102d883a 	mov	r22,r2
   1dd60:	a009883a 	mov	r4,r20
   1dd64:	880b883a 	mov	r5,r17
   1dd68:	001f6180 	call	1f618 <__udivsi3>
   1dd6c:	b02c943a 	slli	r22,r22,16
   1dd70:	156b383a 	mul	r21,r2,r21
   1dd74:	9cffffcc 	andi	r19,r19,65535
   1dd78:	b4e6b03a 	or	r19,r22,r19
   1dd7c:	1009883a 	mov	r4,r2
   1dd80:	9d40052e 	bgeu	r19,r21,1dd98 <__udivdi3+0x134>
   1dd84:	9c27883a 	add	r19,r19,r16
   1dd88:	10bfffc4 	addi	r2,r2,-1
   1dd8c:	9c00f736 	bltu	r19,r16,1e16c <__udivdi3+0x508>
   1dd90:	9d40f62e 	bgeu	r19,r21,1e16c <__udivdi3+0x508>
   1dd94:	213fff84 	addi	r4,r4,-2
   1dd98:	9004943a 	slli	r2,r18,16
   1dd9c:	0007883a 	mov	r3,zero
   1dda0:	2084b03a 	or	r2,r4,r2
   1dda4:	00001506 	br	1ddfc <__udivdi3+0x198>
   1dda8:	29c06536 	bltu	r5,r7,1df40 <__udivdi3+0x2dc>
   1ddac:	00bfffd4 	movui	r2,65535
   1ddb0:	11c0652e 	bgeu	r2,r7,1df48 <__udivdi3+0x2e4>
   1ddb4:	00804034 	movhi	r2,256
   1ddb8:	10bfffc4 	addi	r2,r2,-1
   1ddbc:	11c0f736 	bltu	r2,r7,1e19c <__udivdi3+0x538>
   1ddc0:	00c00404 	movi	r3,16
   1ddc4:	180b883a 	mov	r5,r3
   1ddc8:	38c6d83a 	srl	r3,r7,r3
   1ddcc:	010000f4 	movhi	r4,3
   1ddd0:	213c8604 	addi	r4,r4,-3560
   1ddd4:	04000804 	movi	r16,32
   1ddd8:	20c7883a 	add	r3,r4,r3
   1dddc:	18800003 	ldbu	r2,0(r3)
   1dde0:	1145883a 	add	r2,r2,r5
   1dde4:	80a1c83a 	sub	r16,r16,r2
   1dde8:	8000691e 	bne	r16,zero,1df90 <__udivdi3+0x32c>
   1ddec:	0007883a 	mov	r3,zero
   1ddf0:	3c406536 	bltu	r7,r17,1df88 <__udivdi3+0x324>
   1ddf4:	9180642e 	bgeu	r18,r6,1df88 <__udivdi3+0x324>
   1ddf8:	0005883a 	mov	r2,zero
   1ddfc:	dfc00a17 	ldw	ra,40(sp)
   1de00:	df000917 	ldw	fp,36(sp)
   1de04:	ddc00817 	ldw	r23,32(sp)
   1de08:	dd800717 	ldw	r22,28(sp)
   1de0c:	dd400617 	ldw	r21,24(sp)
   1de10:	dd000517 	ldw	r20,20(sp)
   1de14:	dcc00417 	ldw	r19,16(sp)
   1de18:	dc800317 	ldw	r18,12(sp)
   1de1c:	dc400217 	ldw	r17,8(sp)
   1de20:	dc000117 	ldw	r16,4(sp)
   1de24:	dec00b04 	addi	sp,sp,44
   1de28:	f800283a 	ret
   1de2c:	3000041e 	bne	r6,zero,1de40 <__udivdi3+0x1dc>
   1de30:	01000044 	movi	r4,1
   1de34:	000b883a 	mov	r5,zero
   1de38:	001f6180 	call	1f618 <__udivsi3>
   1de3c:	1021883a 	mov	r16,r2
   1de40:	00bfffd4 	movui	r2,65535
   1de44:	14004b2e 	bgeu	r2,r16,1df74 <__udivdi3+0x310>
   1de48:	00804034 	movhi	r2,256
   1de4c:	10bfffc4 	addi	r2,r2,-1
   1de50:	1400d836 	bltu	r2,r16,1e1b4 <__udivdi3+0x550>
   1de54:	00800404 	movi	r2,16
   1de58:	1007883a 	mov	r3,r2
   1de5c:	8084d83a 	srl	r2,r16,r2
   1de60:	010000f4 	movhi	r4,3
   1de64:	213c8604 	addi	r4,r4,-3560
   1de68:	2085883a 	add	r2,r4,r2
   1de6c:	10800003 	ldbu	r2,0(r2)
   1de70:	10c7883a 	add	r3,r2,r3
   1de74:	00800804 	movi	r2,32
   1de78:	10c5c83a 	sub	r2,r2,r3
   1de7c:	1000891e 	bne	r2,zero,1e0a4 <__udivdi3+0x440>
   1de80:	8028d43a 	srli	r20,r16,16
   1de84:	8c23c83a 	sub	r17,r17,r16
   1de88:	84bfffcc 	andi	r18,r16,65535
   1de8c:	00c00044 	movi	r3,1
   1de90:	8809883a 	mov	r4,r17
   1de94:	a00b883a 	mov	r5,r20
   1de98:	d8c00015 	stw	r3,0(sp)
   1de9c:	001f6200 	call	1f620 <__umodsi3>
   1dea0:	8809883a 	mov	r4,r17
   1dea4:	a00b883a 	mov	r5,r20
   1dea8:	102b883a 	mov	r21,r2
   1deac:	001f6180 	call	1f618 <__udivsi3>
   1deb0:	a82a943a 	slli	r21,r21,16
   1deb4:	9808d43a 	srli	r4,r19,16
   1deb8:	148b383a 	mul	r5,r2,r18
   1debc:	1023883a 	mov	r17,r2
   1dec0:	a908b03a 	or	r4,r21,r4
   1dec4:	d8c00017 	ldw	r3,0(sp)
   1dec8:	2140052e 	bgeu	r4,r5,1dee0 <__udivdi3+0x27c>
   1decc:	2409883a 	add	r4,r4,r16
   1ded0:	10bfffc4 	addi	r2,r2,-1
   1ded4:	24000136 	bltu	r4,r16,1dedc <__udivdi3+0x278>
   1ded8:	2140ce36 	bltu	r4,r5,1e214 <__udivdi3+0x5b0>
   1dedc:	1023883a 	mov	r17,r2
   1dee0:	216bc83a 	sub	r21,r4,r5
   1dee4:	a809883a 	mov	r4,r21
   1dee8:	a00b883a 	mov	r5,r20
   1deec:	d8c00015 	stw	r3,0(sp)
   1def0:	001f6200 	call	1f620 <__umodsi3>
   1def4:	102d883a 	mov	r22,r2
   1def8:	a809883a 	mov	r4,r21
   1defc:	a00b883a 	mov	r5,r20
   1df00:	001f6180 	call	1f618 <__udivsi3>
   1df04:	b02c943a 	slli	r22,r22,16
   1df08:	14a5383a 	mul	r18,r2,r18
   1df0c:	9cffffcc 	andi	r19,r19,65535
   1df10:	b4e6b03a 	or	r19,r22,r19
   1df14:	1009883a 	mov	r4,r2
   1df18:	d8c00017 	ldw	r3,0(sp)
   1df1c:	9c80052e 	bgeu	r19,r18,1df34 <__udivdi3+0x2d0>
   1df20:	9c27883a 	add	r19,r19,r16
   1df24:	10bfffc4 	addi	r2,r2,-1
   1df28:	9c009236 	bltu	r19,r16,1e174 <__udivdi3+0x510>
   1df2c:	9c80912e 	bgeu	r19,r18,1e174 <__udivdi3+0x510>
   1df30:	213fff84 	addi	r4,r4,-2
   1df34:	8804943a 	slli	r2,r17,16
   1df38:	2084b03a 	or	r2,r4,r2
   1df3c:	003faf06 	br	1ddfc <__udivdi3+0x198>
   1df40:	0007883a 	mov	r3,zero
   1df44:	003fac06 	br	1ddf8 <__udivdi3+0x194>
   1df48:	00803fc4 	movi	r2,255
   1df4c:	11c09636 	bltu	r2,r7,1e1a8 <__udivdi3+0x544>
   1df50:	0007883a 	mov	r3,zero
   1df54:	000b883a 	mov	r5,zero
   1df58:	003f9b06 	br	1ddc8 <__udivdi3+0x164>
   1df5c:	00804034 	movhi	r2,256
   1df60:	10bfffc4 	addi	r2,r2,-1
   1df64:	11809636 	bltu	r2,r6,1e1c0 <__udivdi3+0x55c>
   1df68:	00800404 	movi	r2,16
   1df6c:	1007883a 	mov	r3,r2
   1df70:	003f5406 	br	1dcc4 <__udivdi3+0x60>
   1df74:	00803fc4 	movi	r2,255
   1df78:	14009736 	bltu	r2,r16,1e1d8 <__udivdi3+0x574>
   1df7c:	0005883a 	mov	r2,zero
   1df80:	0007883a 	mov	r3,zero
   1df84:	003fb506 	br	1de5c <__udivdi3+0x1f8>
   1df88:	00800044 	movi	r2,1
   1df8c:	003f9b06 	br	1ddfc <__udivdi3+0x198>
   1df90:	3086d83a 	srl	r3,r6,r2
   1df94:	3c0e983a 	sll	r7,r7,r16
   1df98:	88aad83a 	srl	r21,r17,r2
   1df9c:	9084d83a 	srl	r2,r18,r2
   1dfa0:	38e6b03a 	or	r19,r7,r3
   1dfa4:	9828d43a 	srli	r20,r19,16
   1dfa8:	8c22983a 	sll	r17,r17,r16
   1dfac:	a809883a 	mov	r4,r21
   1dfb0:	a00b883a 	mov	r5,r20
   1dfb4:	342c983a 	sll	r22,r6,r16
   1dfb8:	88a2b03a 	or	r17,r17,r2
   1dfbc:	001f6200 	call	1f620 <__umodsi3>
   1dfc0:	a809883a 	mov	r4,r21
   1dfc4:	a00b883a 	mov	r5,r20
   1dfc8:	1039883a 	mov	fp,r2
   1dfcc:	001f6180 	call	1f618 <__udivsi3>
   1dfd0:	102b883a 	mov	r21,r2
   1dfd4:	9dffffcc 	andi	r23,r19,65535
   1dfd8:	e008943a 	slli	r4,fp,16
   1dfdc:	8804d43a 	srli	r2,r17,16
   1dfe0:	adcd383a 	mul	r6,r21,r23
   1dfe4:	2088b03a 	or	r4,r4,r2
   1dfe8:	2180042e 	bgeu	r4,r6,1dffc <__udivdi3+0x398>
   1dfec:	24c9883a 	add	r4,r4,r19
   1dff0:	a8bfffc4 	addi	r2,r21,-1
   1dff4:	24c07f2e 	bgeu	r4,r19,1e1f4 <__udivdi3+0x590>
   1dff8:	102b883a 	mov	r21,r2
   1dffc:	21b9c83a 	sub	fp,r4,r6
   1e000:	e009883a 	mov	r4,fp
   1e004:	a00b883a 	mov	r5,r20
   1e008:	001f6200 	call	1f620 <__umodsi3>
   1e00c:	e009883a 	mov	r4,fp
   1e010:	a00b883a 	mov	r5,r20
   1e014:	d8800015 	stw	r2,0(sp)
   1e018:	001f6180 	call	1f618 <__udivsi3>
   1e01c:	d8c00017 	ldw	r3,0(sp)
   1e020:	15cb383a 	mul	r5,r2,r23
   1e024:	8c7fffcc 	andi	r17,r17,65535
   1e028:	1806943a 	slli	r3,r3,16
   1e02c:	1009883a 	mov	r4,r2
   1e030:	1c46b03a 	or	r3,r3,r17
   1e034:	1940042e 	bgeu	r3,r5,1e048 <__udivdi3+0x3e4>
   1e038:	1cc7883a 	add	r3,r3,r19
   1e03c:	10bfffc4 	addi	r2,r2,-1
   1e040:	1cc0682e 	bgeu	r3,r19,1e1e4 <__udivdi3+0x580>
   1e044:	1009883a 	mov	r4,r2
   1e048:	a804943a 	slli	r2,r21,16
   1e04c:	b1ffffcc 	andi	r7,r22,65535
   1e050:	b02cd43a 	srli	r22,r22,16
   1e054:	2084b03a 	or	r2,r4,r2
   1e058:	113fffcc 	andi	r4,r2,65535
   1e05c:	100cd43a 	srli	r6,r2,16
   1e060:	21d1383a 	mul	r8,r4,r7
   1e064:	2589383a 	mul	r4,r4,r22
   1e068:	31cf383a 	mul	r7,r6,r7
   1e06c:	4012d43a 	srli	r9,r8,16
   1e070:	1947c83a 	sub	r3,r3,r5
   1e074:	3909883a 	add	r4,r7,r4
   1e078:	2249883a 	add	r4,r4,r9
   1e07c:	35ad383a 	mul	r22,r6,r22
   1e080:	21c0022e 	bgeu	r4,r7,1e08c <__udivdi3+0x428>
   1e084:	01400074 	movhi	r5,1
   1e088:	b16d883a 	add	r22,r22,r5
   1e08c:	200ad43a 	srli	r5,r4,16
   1e090:	b16d883a 	add	r22,r22,r5
   1e094:	1d803e36 	bltu	r3,r22,1e190 <__udivdi3+0x52c>
   1e098:	1d803826 	beq	r3,r22,1e17c <__udivdi3+0x518>
   1e09c:	0007883a 	mov	r3,zero
   1e0a0:	003f5606 	br	1ddfc <__udivdi3+0x198>
   1e0a4:	80a0983a 	sll	r16,r16,r2
   1e0a8:	88ead83a 	srl	r21,r17,r3
   1e0ac:	90c6d83a 	srl	r3,r18,r3
   1e0b0:	8028d43a 	srli	r20,r16,16
   1e0b4:	88a2983a 	sll	r17,r17,r2
   1e0b8:	a809883a 	mov	r4,r21
   1e0bc:	a00b883a 	mov	r5,r20
   1e0c0:	88ecb03a 	or	r22,r17,r3
   1e0c4:	90a6983a 	sll	r19,r18,r2
   1e0c8:	001f6200 	call	1f620 <__umodsi3>
   1e0cc:	a809883a 	mov	r4,r21
   1e0d0:	a00b883a 	mov	r5,r20
   1e0d4:	1023883a 	mov	r17,r2
   1e0d8:	001f6180 	call	1f618 <__udivsi3>
   1e0dc:	102b883a 	mov	r21,r2
   1e0e0:	84bfffcc 	andi	r18,r16,65535
   1e0e4:	8808943a 	slli	r4,r17,16
   1e0e8:	b004d43a 	srli	r2,r22,16
   1e0ec:	ac87383a 	mul	r3,r21,r18
   1e0f0:	2088b03a 	or	r4,r4,r2
   1e0f4:	20c0062e 	bgeu	r4,r3,1e110 <__udivdi3+0x4ac>
   1e0f8:	2409883a 	add	r4,r4,r16
   1e0fc:	a8bfffc4 	addi	r2,r21,-1
   1e100:	24004236 	bltu	r4,r16,1e20c <__udivdi3+0x5a8>
   1e104:	20c0412e 	bgeu	r4,r3,1e20c <__udivdi3+0x5a8>
   1e108:	ad7fff84 	addi	r21,r21,-2
   1e10c:	2409883a 	add	r4,r4,r16
   1e110:	20efc83a 	sub	r23,r4,r3
   1e114:	b809883a 	mov	r4,r23
   1e118:	a00b883a 	mov	r5,r20
   1e11c:	001f6200 	call	1f620 <__umodsi3>
   1e120:	1023883a 	mov	r17,r2
   1e124:	a00b883a 	mov	r5,r20
   1e128:	b809883a 	mov	r4,r23
   1e12c:	001f6180 	call	1f618 <__udivsi3>
   1e130:	8822943a 	slli	r17,r17,16
   1e134:	148b383a 	mul	r5,r2,r18
   1e138:	b5bfffcc 	andi	r22,r22,65535
   1e13c:	8da2b03a 	or	r17,r17,r22
   1e140:	8940062e 	bgeu	r17,r5,1e15c <__udivdi3+0x4f8>
   1e144:	8c23883a 	add	r17,r17,r16
   1e148:	10ffffc4 	addi	r3,r2,-1
   1e14c:	8c002d36 	bltu	r17,r16,1e204 <__udivdi3+0x5a0>
   1e150:	89402c2e 	bgeu	r17,r5,1e204 <__udivdi3+0x5a0>
   1e154:	10bfff84 	addi	r2,r2,-2
   1e158:	8c23883a 	add	r17,r17,r16
   1e15c:	a806943a 	slli	r3,r21,16
   1e160:	8963c83a 	sub	r17,r17,r5
   1e164:	10c6b03a 	or	r3,r2,r3
   1e168:	003f4906 	br	1de90 <__udivdi3+0x22c>
   1e16c:	1009883a 	mov	r4,r2
   1e170:	003f0906 	br	1dd98 <__udivdi3+0x134>
   1e174:	1009883a 	mov	r4,r2
   1e178:	003f6e06 	br	1df34 <__udivdi3+0x2d0>
   1e17c:	2008943a 	slli	r4,r4,16
   1e180:	9420983a 	sll	r16,r18,r16
   1e184:	423fffcc 	andi	r8,r8,65535
   1e188:	2209883a 	add	r4,r4,r8
   1e18c:	813fc32e 	bgeu	r16,r4,1e09c <__udivdi3+0x438>
   1e190:	10bfffc4 	addi	r2,r2,-1
   1e194:	0007883a 	mov	r3,zero
   1e198:	003f1806 	br	1ddfc <__udivdi3+0x198>
   1e19c:	00c00604 	movi	r3,24
   1e1a0:	180b883a 	mov	r5,r3
   1e1a4:	003f0806 	br	1ddc8 <__udivdi3+0x164>
   1e1a8:	00c00204 	movi	r3,8
   1e1ac:	180b883a 	mov	r5,r3
   1e1b0:	003f0506 	br	1ddc8 <__udivdi3+0x164>
   1e1b4:	00800604 	movi	r2,24
   1e1b8:	1007883a 	mov	r3,r2
   1e1bc:	003f2706 	br	1de5c <__udivdi3+0x1f8>
   1e1c0:	00800604 	movi	r2,24
   1e1c4:	1007883a 	mov	r3,r2
   1e1c8:	003ebe06 	br	1dcc4 <__udivdi3+0x60>
   1e1cc:	00800204 	movi	r2,8
   1e1d0:	1007883a 	mov	r3,r2
   1e1d4:	003ebb06 	br	1dcc4 <__udivdi3+0x60>
   1e1d8:	00800204 	movi	r2,8
   1e1dc:	1007883a 	mov	r3,r2
   1e1e0:	003f1e06 	br	1de5c <__udivdi3+0x1f8>
   1e1e4:	197f972e 	bgeu	r3,r5,1e044 <__udivdi3+0x3e0>
   1e1e8:	213fff84 	addi	r4,r4,-2
   1e1ec:	1cc7883a 	add	r3,r3,r19
   1e1f0:	003f9506 	br	1e048 <__udivdi3+0x3e4>
   1e1f4:	21bf802e 	bgeu	r4,r6,1dff8 <__udivdi3+0x394>
   1e1f8:	ad7fff84 	addi	r21,r21,-2
   1e1fc:	24c9883a 	add	r4,r4,r19
   1e200:	003f7e06 	br	1dffc <__udivdi3+0x398>
   1e204:	1805883a 	mov	r2,r3
   1e208:	003fd406 	br	1e15c <__udivdi3+0x4f8>
   1e20c:	102b883a 	mov	r21,r2
   1e210:	003fbf06 	br	1e110 <__udivdi3+0x4ac>
   1e214:	8c7fff84 	addi	r17,r17,-2
   1e218:	2409883a 	add	r4,r4,r16
   1e21c:	003f3006 	br	1dee0 <__udivdi3+0x27c>
   1e220:	94bfff84 	addi	r18,r18,-2
   1e224:	1c07883a 	add	r3,r3,r16
   1e228:	003ec806 	br	1dd4c <__udivdi3+0xe8>

0001e22c <__umoddi3>:
   1e22c:	defff504 	addi	sp,sp,-44
   1e230:	dd000515 	stw	r20,20(sp)
   1e234:	dcc00415 	stw	r19,16(sp)
   1e238:	dc800315 	stw	r18,12(sp)
   1e23c:	dc400215 	stw	r17,8(sp)
   1e240:	dc000115 	stw	r16,4(sp)
   1e244:	dfc00a15 	stw	ra,40(sp)
   1e248:	df000915 	stw	fp,36(sp)
   1e24c:	ddc00815 	stw	r23,32(sp)
   1e250:	dd800715 	stw	r22,28(sp)
   1e254:	dd400615 	stw	r21,24(sp)
   1e258:	2025883a 	mov	r18,r4
   1e25c:	2823883a 	mov	r17,r5
   1e260:	3021883a 	mov	r16,r6
   1e264:	2027883a 	mov	r19,r4
   1e268:	2829883a 	mov	r20,r5
   1e26c:	3800351e 	bne	r7,zero,1e344 <__umoddi3+0x118>
   1e270:	29804d2e 	bgeu	r5,r6,1e3a8 <__umoddi3+0x17c>
   1e274:	00bfffd4 	movui	r2,65535
   1e278:	11809a36 	bltu	r2,r6,1e4e4 <__umoddi3+0x2b8>
   1e27c:	00803fc4 	movi	r2,255
   1e280:	11813936 	bltu	r2,r6,1e768 <__umoddi3+0x53c>
   1e284:	0005883a 	mov	r2,zero
   1e288:	0009883a 	mov	r4,zero
   1e28c:	3084d83a 	srl	r2,r6,r2
   1e290:	00c000f4 	movhi	r3,3
   1e294:	18fc8604 	addi	r3,r3,-3560
   1e298:	05400804 	movi	r21,32
   1e29c:	1885883a 	add	r2,r3,r2
   1e2a0:	10800003 	ldbu	r2,0(r2)
   1e2a4:	1109883a 	add	r4,r2,r4
   1e2a8:	a92bc83a 	sub	r21,r21,r4
   1e2ac:	a800ec26 	beq	r21,zero,1e660 <__umoddi3+0x434>
   1e2b0:	8d62983a 	sll	r17,r17,r21
   1e2b4:	9108d83a 	srl	r4,r18,r4
   1e2b8:	3560983a 	sll	r16,r6,r21
   1e2bc:	9566983a 	sll	r19,r18,r21
   1e2c0:	8928b03a 	or	r20,r17,r4
   1e2c4:	8022d43a 	srli	r17,r16,16
   1e2c8:	a009883a 	mov	r4,r20
   1e2cc:	84bfffcc 	andi	r18,r16,65535
   1e2d0:	880b883a 	mov	r5,r17
   1e2d4:	001f6200 	call	1f620 <__umodsi3>
   1e2d8:	a009883a 	mov	r4,r20
   1e2dc:	880b883a 	mov	r5,r17
   1e2e0:	102d883a 	mov	r22,r2
   1e2e4:	001f6180 	call	1f618 <__udivsi3>
   1e2e8:	b02c943a 	slli	r22,r22,16
   1e2ec:	9806d43a 	srli	r3,r19,16
   1e2f0:	1485383a 	mul	r2,r2,r18
   1e2f4:	b0c6b03a 	or	r3,r22,r3
   1e2f8:	1880042e 	bgeu	r3,r2,1e30c <__umoddi3+0xe0>
   1e2fc:	1c07883a 	add	r3,r3,r16
   1e300:	1c000236 	bltu	r3,r16,1e30c <__umoddi3+0xe0>
   1e304:	1880012e 	bgeu	r3,r2,1e30c <__umoddi3+0xe0>
   1e308:	1c07883a 	add	r3,r3,r16
   1e30c:	18a9c83a 	sub	r20,r3,r2
   1e310:	a009883a 	mov	r4,r20
   1e314:	880b883a 	mov	r5,r17
   1e318:	001f6200 	call	1f620 <__umodsi3>
   1e31c:	102d883a 	mov	r22,r2
   1e320:	a009883a 	mov	r4,r20
   1e324:	880b883a 	mov	r5,r17
   1e328:	001f6180 	call	1f618 <__udivsi3>
   1e32c:	b02c943a 	slli	r22,r22,16
   1e330:	1485383a 	mul	r2,r2,r18
   1e334:	9cffffcc 	andi	r19,r19,65535
   1e338:	b4e6b03a 	or	r19,r22,r19
   1e33c:	9880522e 	bgeu	r19,r2,1e488 <__umoddi3+0x25c>
   1e340:	00004d06 	br	1e478 <__umoddi3+0x24c>
   1e344:	29c05436 	bltu	r5,r7,1e498 <__umoddi3+0x26c>
   1e348:	00bfffd4 	movui	r2,65535
   1e34c:	11c0602e 	bgeu	r2,r7,1e4d0 <__umoddi3+0x2a4>
   1e350:	00804034 	movhi	r2,256
   1e354:	10bfffc4 	addi	r2,r2,-1
   1e358:	11c0f736 	bltu	r2,r7,1e738 <__umoddi3+0x50c>
   1e35c:	00c00404 	movi	r3,16
   1e360:	1827883a 	mov	r19,r3
   1e364:	38c6d83a 	srl	r3,r7,r3
   1e368:	010000f4 	movhi	r4,3
   1e36c:	213c8604 	addi	r4,r4,-3560
   1e370:	04000804 	movi	r16,32
   1e374:	20c7883a 	add	r3,r4,r3
   1e378:	18800003 	ldbu	r2,0(r3)
   1e37c:	14e7883a 	add	r19,r2,r19
   1e380:	84e1c83a 	sub	r16,r16,r19
   1e384:	8000621e 	bne	r16,zero,1e510 <__umoddi3+0x2e4>
   1e388:	3c400136 	bltu	r7,r17,1e390 <__umoddi3+0x164>
   1e38c:	91810336 	bltu	r18,r6,1e79c <__umoddi3+0x570>
   1e390:	9185c83a 	sub	r2,r18,r6
   1e394:	89e3c83a 	sub	r17,r17,r7
   1e398:	90a5803a 	cmpltu	r18,r18,r2
   1e39c:	8ca9c83a 	sub	r20,r17,r18
   1e3a0:	a007883a 	mov	r3,r20
   1e3a4:	00003e06 	br	1e4a0 <__umoddi3+0x274>
   1e3a8:	3000041e 	bne	r6,zero,1e3bc <__umoddi3+0x190>
   1e3ac:	01000044 	movi	r4,1
   1e3b0:	000b883a 	mov	r5,zero
   1e3b4:	001f6180 	call	1f618 <__udivsi3>
   1e3b8:	1021883a 	mov	r16,r2
   1e3bc:	00bfffd4 	movui	r2,65535
   1e3c0:	14004e2e 	bgeu	r2,r16,1e4fc <__umoddi3+0x2d0>
   1e3c4:	00804034 	movhi	r2,256
   1e3c8:	10bfffc4 	addi	r2,r2,-1
   1e3cc:	1400e336 	bltu	r2,r16,1e75c <__umoddi3+0x530>
   1e3d0:	00800404 	movi	r2,16
   1e3d4:	1007883a 	mov	r3,r2
   1e3d8:	8084d83a 	srl	r2,r16,r2
   1e3dc:	010000f4 	movhi	r4,3
   1e3e0:	213c8604 	addi	r4,r4,-3560
   1e3e4:	05400804 	movi	r21,32
   1e3e8:	2085883a 	add	r2,r4,r2
   1e3ec:	10800003 	ldbu	r2,0(r2)
   1e3f0:	10c7883a 	add	r3,r2,r3
   1e3f4:	a8ebc83a 	sub	r21,r21,r3
   1e3f8:	a8009b1e 	bne	r21,zero,1e668 <__umoddi3+0x43c>
   1e3fc:	8028d43a 	srli	r20,r16,16
   1e400:	8c23c83a 	sub	r17,r17,r16
   1e404:	85bfffcc 	andi	r22,r16,65535
   1e408:	8809883a 	mov	r4,r17
   1e40c:	a00b883a 	mov	r5,r20
   1e410:	001f6200 	call	1f620 <__umodsi3>
   1e414:	8809883a 	mov	r4,r17
   1e418:	a00b883a 	mov	r5,r20
   1e41c:	1025883a 	mov	r18,r2
   1e420:	001f6180 	call	1f618 <__udivsi3>
   1e424:	9024943a 	slli	r18,r18,16
   1e428:	9806d43a 	srli	r3,r19,16
   1e42c:	1585383a 	mul	r2,r2,r22
   1e430:	90c6b03a 	or	r3,r18,r3
   1e434:	1880032e 	bgeu	r3,r2,1e444 <__umoddi3+0x218>
   1e438:	1c07883a 	add	r3,r3,r16
   1e43c:	1c000136 	bltu	r3,r16,1e444 <__umoddi3+0x218>
   1e440:	1880d436 	bltu	r3,r2,1e794 <__umoddi3+0x568>
   1e444:	18a3c83a 	sub	r17,r3,r2
   1e448:	8809883a 	mov	r4,r17
   1e44c:	a00b883a 	mov	r5,r20
   1e450:	001f6200 	call	1f620 <__umodsi3>
   1e454:	1025883a 	mov	r18,r2
   1e458:	8809883a 	mov	r4,r17
   1e45c:	a00b883a 	mov	r5,r20
   1e460:	001f6180 	call	1f618 <__udivsi3>
   1e464:	9024943a 	slli	r18,r18,16
   1e468:	1585383a 	mul	r2,r2,r22
   1e46c:	9cffffcc 	andi	r19,r19,65535
   1e470:	94e6b03a 	or	r19,r18,r19
   1e474:	9880042e 	bgeu	r19,r2,1e488 <__umoddi3+0x25c>
   1e478:	9c27883a 	add	r19,r19,r16
   1e47c:	9c000236 	bltu	r19,r16,1e488 <__umoddi3+0x25c>
   1e480:	9880012e 	bgeu	r19,r2,1e488 <__umoddi3+0x25c>
   1e484:	9c27883a 	add	r19,r19,r16
   1e488:	98a7c83a 	sub	r19,r19,r2
   1e48c:	9d44d83a 	srl	r2,r19,r21
   1e490:	0007883a 	mov	r3,zero
   1e494:	00000206 	br	1e4a0 <__umoddi3+0x274>
   1e498:	2005883a 	mov	r2,r4
   1e49c:	2807883a 	mov	r3,r5
   1e4a0:	dfc00a17 	ldw	ra,40(sp)
   1e4a4:	df000917 	ldw	fp,36(sp)
   1e4a8:	ddc00817 	ldw	r23,32(sp)
   1e4ac:	dd800717 	ldw	r22,28(sp)
   1e4b0:	dd400617 	ldw	r21,24(sp)
   1e4b4:	dd000517 	ldw	r20,20(sp)
   1e4b8:	dcc00417 	ldw	r19,16(sp)
   1e4bc:	dc800317 	ldw	r18,12(sp)
   1e4c0:	dc400217 	ldw	r17,8(sp)
   1e4c4:	dc000117 	ldw	r16,4(sp)
   1e4c8:	dec00b04 	addi	sp,sp,44
   1e4cc:	f800283a 	ret
   1e4d0:	00803fc4 	movi	r2,255
   1e4d4:	11c09536 	bltu	r2,r7,1e72c <__umoddi3+0x500>
   1e4d8:	0007883a 	mov	r3,zero
   1e4dc:	0027883a 	mov	r19,zero
   1e4e0:	003fa006 	br	1e364 <__umoddi3+0x138>
   1e4e4:	00804034 	movhi	r2,256
   1e4e8:	10bfffc4 	addi	r2,r2,-1
   1e4ec:	11809536 	bltu	r2,r6,1e744 <__umoddi3+0x518>
   1e4f0:	00800404 	movi	r2,16
   1e4f4:	1009883a 	mov	r4,r2
   1e4f8:	003f6406 	br	1e28c <__umoddi3+0x60>
   1e4fc:	00803fc4 	movi	r2,255
   1e500:	14009336 	bltu	r2,r16,1e750 <__umoddi3+0x524>
   1e504:	0005883a 	mov	r2,zero
   1e508:	0007883a 	mov	r3,zero
   1e50c:	003fb206 	br	1e3d8 <__umoddi3+0x1ac>
   1e510:	34c4d83a 	srl	r2,r6,r19
   1e514:	3c0e983a 	sll	r7,r7,r16
   1e518:	8ceed83a 	srl	r23,r17,r19
   1e51c:	8c22983a 	sll	r17,r17,r16
   1e520:	38a8b03a 	or	r20,r7,r2
   1e524:	a02ad43a 	srli	r21,r20,16
   1e528:	94c4d83a 	srl	r2,r18,r19
   1e52c:	b809883a 	mov	r4,r23
   1e530:	a80b883a 	mov	r5,r21
   1e534:	88a2b03a 	or	r17,r17,r2
   1e538:	342c983a 	sll	r22,r6,r16
   1e53c:	001f6200 	call	1f620 <__umodsi3>
   1e540:	b809883a 	mov	r4,r23
   1e544:	a80b883a 	mov	r5,r21
   1e548:	d8800015 	stw	r2,0(sp)
   1e54c:	001f6180 	call	1f618 <__udivsi3>
   1e550:	d8c00017 	ldw	r3,0(sp)
   1e554:	102f883a 	mov	r23,r2
   1e558:	a73fffcc 	andi	fp,r20,65535
   1e55c:	180a943a 	slli	r5,r3,16
   1e560:	8804d43a 	srli	r2,r17,16
   1e564:	bf09383a 	mul	r4,r23,fp
   1e568:	9424983a 	sll	r18,r18,r16
   1e56c:	288ab03a 	or	r5,r5,r2
   1e570:	2900042e 	bgeu	r5,r4,1e584 <__umoddi3+0x358>
   1e574:	2d0b883a 	add	r5,r5,r20
   1e578:	b8bfffc4 	addi	r2,r23,-1
   1e57c:	2d00812e 	bgeu	r5,r20,1e784 <__umoddi3+0x558>
   1e580:	102f883a 	mov	r23,r2
   1e584:	2907c83a 	sub	r3,r5,r4
   1e588:	1809883a 	mov	r4,r3
   1e58c:	a80b883a 	mov	r5,r21
   1e590:	d8c00015 	stw	r3,0(sp)
   1e594:	001f6200 	call	1f620 <__umodsi3>
   1e598:	d8c00017 	ldw	r3,0(sp)
   1e59c:	a80b883a 	mov	r5,r21
   1e5a0:	d8800015 	stw	r2,0(sp)
   1e5a4:	1809883a 	mov	r4,r3
   1e5a8:	001f6180 	call	1f618 <__udivsi3>
   1e5ac:	d9800017 	ldw	r6,0(sp)
   1e5b0:	8c7fffcc 	andi	r17,r17,65535
   1e5b4:	3008943a 	slli	r4,r6,16
   1e5b8:	170d383a 	mul	r6,r2,fp
   1e5bc:	2448b03a 	or	r4,r4,r17
   1e5c0:	2180042e 	bgeu	r4,r6,1e5d4 <__umoddi3+0x3a8>
   1e5c4:	2509883a 	add	r4,r4,r20
   1e5c8:	10ffffc4 	addi	r3,r2,-1
   1e5cc:	2500692e 	bgeu	r4,r20,1e774 <__umoddi3+0x548>
   1e5d0:	1805883a 	mov	r2,r3
   1e5d4:	b82e943a 	slli	r23,r23,16
   1e5d8:	b010d43a 	srli	r8,r22,16
   1e5dc:	b1ffffcc 	andi	r7,r22,65535
   1e5e0:	15eeb03a 	or	r23,r2,r23
   1e5e4:	b8bfffcc 	andi	r2,r23,65535
   1e5e8:	b82ed43a 	srli	r23,r23,16
   1e5ec:	11c7383a 	mul	r3,r2,r7
   1e5f0:	1205383a 	mul	r2,r2,r8
   1e5f4:	b9cf383a 	mul	r7,r23,r7
   1e5f8:	400b883a 	mov	r5,r8
   1e5fc:	1810d43a 	srli	r8,r3,16
   1e600:	3885883a 	add	r2,r7,r2
   1e604:	2189c83a 	sub	r4,r4,r6
   1e608:	1205883a 	add	r2,r2,r8
   1e60c:	b94b383a 	mul	r5,r23,r5
   1e610:	11c0022e 	bgeu	r2,r7,1e61c <__umoddi3+0x3f0>
   1e614:	01800074 	movhi	r6,1
   1e618:	298b883a 	add	r5,r5,r6
   1e61c:	100cd43a 	srli	r6,r2,16
   1e620:	1004943a 	slli	r2,r2,16
   1e624:	18ffffcc 	andi	r3,r3,65535
   1e628:	298b883a 	add	r5,r5,r6
   1e62c:	10c5883a 	add	r2,r2,r3
   1e630:	21403836 	bltu	r4,r5,1e714 <__umoddi3+0x4e8>
   1e634:	21405c26 	beq	r4,r5,1e7a8 <__umoddi3+0x57c>
   1e638:	2147c83a 	sub	r3,r4,r5
   1e63c:	102d883a 	mov	r22,r2
   1e640:	95adc83a 	sub	r22,r18,r22
   1e644:	95a5803a 	cmpltu	r18,r18,r22
   1e648:	1c87c83a 	sub	r3,r3,r18
   1e64c:	1cc4983a 	sll	r2,r3,r19
   1e650:	b42cd83a 	srl	r22,r22,r16
   1e654:	1c06d83a 	srl	r3,r3,r16
   1e658:	1584b03a 	or	r2,r2,r22
   1e65c:	003f9006 	br	1e4a0 <__umoddi3+0x274>
   1e660:	002b883a 	mov	r21,zero
   1e664:	003f1706 	br	1e2c4 <__umoddi3+0x98>
   1e668:	8560983a 	sll	r16,r16,r21
   1e66c:	88e6d83a 	srl	r19,r17,r3
   1e670:	90c6d83a 	srl	r3,r18,r3
   1e674:	8028d43a 	srli	r20,r16,16
   1e678:	8d62983a 	sll	r17,r17,r21
   1e67c:	9809883a 	mov	r4,r19
   1e680:	a00b883a 	mov	r5,r20
   1e684:	88eeb03a 	or	r23,r17,r3
   1e688:	001f6200 	call	1f620 <__umodsi3>
   1e68c:	9809883a 	mov	r4,r19
   1e690:	a00b883a 	mov	r5,r20
   1e694:	1023883a 	mov	r17,r2
   1e698:	001f6180 	call	1f618 <__udivsi3>
   1e69c:	85bfffcc 	andi	r22,r16,65535
   1e6a0:	880a943a 	slli	r5,r17,16
   1e6a4:	b806d43a 	srli	r3,r23,16
   1e6a8:	1585383a 	mul	r2,r2,r22
   1e6ac:	9566983a 	sll	r19,r18,r21
   1e6b0:	28cab03a 	or	r5,r5,r3
   1e6b4:	2880042e 	bgeu	r5,r2,1e6c8 <__umoddi3+0x49c>
   1e6b8:	2c0b883a 	add	r5,r5,r16
   1e6bc:	2c000236 	bltu	r5,r16,1e6c8 <__umoddi3+0x49c>
   1e6c0:	2880012e 	bgeu	r5,r2,1e6c8 <__umoddi3+0x49c>
   1e6c4:	2c0b883a 	add	r5,r5,r16
   1e6c8:	28a5c83a 	sub	r18,r5,r2
   1e6cc:	9009883a 	mov	r4,r18
   1e6d0:	a00b883a 	mov	r5,r20
   1e6d4:	001f6200 	call	1f620 <__umodsi3>
   1e6d8:	1023883a 	mov	r17,r2
   1e6dc:	9009883a 	mov	r4,r18
   1e6e0:	a00b883a 	mov	r5,r20
   1e6e4:	001f6180 	call	1f618 <__udivsi3>
   1e6e8:	8822943a 	slli	r17,r17,16
   1e6ec:	1585383a 	mul	r2,r2,r22
   1e6f0:	bdffffcc 	andi	r23,r23,65535
   1e6f4:	8de2b03a 	or	r17,r17,r23
   1e6f8:	8880042e 	bgeu	r17,r2,1e70c <__umoddi3+0x4e0>
   1e6fc:	8c23883a 	add	r17,r17,r16
   1e700:	8c000236 	bltu	r17,r16,1e70c <__umoddi3+0x4e0>
   1e704:	8880012e 	bgeu	r17,r2,1e70c <__umoddi3+0x4e0>
   1e708:	8c23883a 	add	r17,r17,r16
   1e70c:	88a3c83a 	sub	r17,r17,r2
   1e710:	003f3d06 	br	1e408 <__umoddi3+0x1dc>
   1e714:	15adc83a 	sub	r22,r2,r22
   1e718:	2d07c83a 	sub	r3,r5,r20
   1e71c:	1585803a 	cmpltu	r2,r2,r22
   1e720:	1887c83a 	sub	r3,r3,r2
   1e724:	20c7c83a 	sub	r3,r4,r3
   1e728:	003fc506 	br	1e640 <__umoddi3+0x414>
   1e72c:	00c00204 	movi	r3,8
   1e730:	1827883a 	mov	r19,r3
   1e734:	003f0b06 	br	1e364 <__umoddi3+0x138>
   1e738:	00c00604 	movi	r3,24
   1e73c:	1827883a 	mov	r19,r3
   1e740:	003f0806 	br	1e364 <__umoddi3+0x138>
   1e744:	00800604 	movi	r2,24
   1e748:	1009883a 	mov	r4,r2
   1e74c:	003ecf06 	br	1e28c <__umoddi3+0x60>
   1e750:	00800204 	movi	r2,8
   1e754:	1007883a 	mov	r3,r2
   1e758:	003f1f06 	br	1e3d8 <__umoddi3+0x1ac>
   1e75c:	00800604 	movi	r2,24
   1e760:	1007883a 	mov	r3,r2
   1e764:	003f1c06 	br	1e3d8 <__umoddi3+0x1ac>
   1e768:	00800204 	movi	r2,8
   1e76c:	1009883a 	mov	r4,r2
   1e770:	003ec606 	br	1e28c <__umoddi3+0x60>
   1e774:	21bf962e 	bgeu	r4,r6,1e5d0 <__umoddi3+0x3a4>
   1e778:	10bfff84 	addi	r2,r2,-2
   1e77c:	2509883a 	add	r4,r4,r20
   1e780:	003f9406 	br	1e5d4 <__umoddi3+0x3a8>
   1e784:	293f7e2e 	bgeu	r5,r4,1e580 <__umoddi3+0x354>
   1e788:	bdffff84 	addi	r23,r23,-2
   1e78c:	2d0b883a 	add	r5,r5,r20
   1e790:	003f7c06 	br	1e584 <__umoddi3+0x358>
   1e794:	1c07883a 	add	r3,r3,r16
   1e798:	003f2a06 	br	1e444 <__umoddi3+0x218>
   1e79c:	9005883a 	mov	r2,r18
   1e7a0:	a007883a 	mov	r3,r20
   1e7a4:	003f3e06 	br	1e4a0 <__umoddi3+0x274>
   1e7a8:	90bfda36 	bltu	r18,r2,1e714 <__umoddi3+0x4e8>
   1e7ac:	102d883a 	mov	r22,r2
   1e7b0:	0007883a 	mov	r3,zero
   1e7b4:	003fa206 	br	1e640 <__umoddi3+0x414>

0001e7b8 <_fpadd_parts>:
   1e7b8:	2005883a 	mov	r2,r4
   1e7bc:	21000017 	ldw	r4,0(r4)
   1e7c0:	01c00044 	movi	r7,1
   1e7c4:	3900622e 	bgeu	r7,r4,1e950 <_fpadd_parts+0x198>
   1e7c8:	28c00017 	ldw	r3,0(r5)
   1e7cc:	38c05f2e 	bgeu	r7,r3,1e94c <_fpadd_parts+0x194>
   1e7d0:	01c00104 	movi	r7,4
   1e7d4:	21c0c626 	beq	r4,r7,1eaf0 <_fpadd_parts+0x338>
   1e7d8:	19c05c26 	beq	r3,r7,1e94c <_fpadd_parts+0x194>
   1e7dc:	01c00084 	movi	r7,2
   1e7e0:	19c06b26 	beq	r3,r7,1e990 <_fpadd_parts+0x1d8>
   1e7e4:	21c05926 	beq	r4,r7,1e94c <_fpadd_parts+0x194>
   1e7e8:	11c00217 	ldw	r7,8(r2)
   1e7ec:	2ac00217 	ldw	r11,8(r5)
   1e7f0:	13000317 	ldw	r12,12(r2)
   1e7f4:	13400417 	ldw	r13,16(r2)
   1e7f8:	3ac9c83a 	sub	r4,r7,r11
   1e7fc:	2a000317 	ldw	r8,12(r5)
   1e800:	2a400417 	ldw	r9,16(r5)
   1e804:	2015883a 	mov	r10,r4
   1e808:	20007516 	blt	r4,zero,1e9e0 <_fpadd_parts+0x228>
   1e80c:	00c00fc4 	movi	r3,63
   1e810:	1a805016 	blt	r3,r10,1e954 <_fpadd_parts+0x19c>
   1e814:	0100870e 	bge	zero,r4,1ea34 <_fpadd_parts+0x27c>
   1e818:	50fff804 	addi	r3,r10,-32
   1e81c:	18009916 	blt	r3,zero,1ea84 <_fpadd_parts+0x2cc>
   1e820:	48d6d83a 	srl	r11,r9,r3
   1e824:	001d883a 	mov	r14,zero
   1e828:	18009e16 	blt	r3,zero,1eaa4 <_fpadd_parts+0x2ec>
   1e82c:	01000044 	movi	r4,1
   1e830:	20c6983a 	sll	r3,r4,r3
   1e834:	0015883a 	mov	r10,zero
   1e838:	513fffc4 	addi	r4,r10,-1
   1e83c:	2295403a 	cmpgeu	r10,r4,r10
   1e840:	1a87c83a 	sub	r3,r3,r10
   1e844:	1a52703a 	and	r9,r3,r9
   1e848:	2210703a 	and	r8,r4,r8
   1e84c:	4250b03a 	or	r8,r8,r9
   1e850:	4010c03a 	cmpne	r8,r8,zero
   1e854:	42d0b03a 	or	r8,r8,r11
   1e858:	7013883a 	mov	r9,r14
   1e85c:	11000117 	ldw	r4,4(r2)
   1e860:	28800117 	ldw	r2,4(r5)
   1e864:	20804126 	beq	r4,r2,1e96c <_fpadd_parts+0x1b4>
   1e868:	20006326 	beq	r4,zero,1e9f8 <_fpadd_parts+0x240>
   1e86c:	4305c83a 	sub	r2,r8,r12
   1e870:	4091803a 	cmpltu	r8,r8,r2
   1e874:	4b47c83a 	sub	r3,r9,r13
   1e878:	1a07c83a 	sub	r3,r3,r8
   1e87c:	18006316 	blt	r3,zero,1ea0c <_fpadd_parts+0x254>
   1e880:	30000115 	stw	zero,4(r6)
   1e884:	31c00215 	stw	r7,8(r6)
   1e888:	30800315 	stw	r2,12(r6)
   1e88c:	30c00415 	stw	r3,16(r6)
   1e890:	11ffffc4 	addi	r7,r2,-1
   1e894:	388b403a 	cmpgeu	r5,r7,r2
   1e898:	194bc83a 	sub	r5,r3,r5
   1e89c:	01040034 	movhi	r4,4096
   1e8a0:	213fffc4 	addi	r4,r4,-1
   1e8a4:	21401736 	bltu	r4,r5,1e904 <_fpadd_parts+0x14c>
   1e8a8:	29008226 	beq	r5,r4,1eab4 <_fpadd_parts+0x2fc>
   1e8ac:	31400217 	ldw	r5,8(r6)
   1e8b0:	02840034 	movhi	r10,4096
   1e8b4:	52bfffc4 	addi	r10,r10,-1
   1e8b8:	033fff84 	movi	r12,-2
   1e8bc:	297fffc4 	addi	r5,r5,-1
   1e8c0:	00000106 	br	1e8c8 <_fpadd_parts+0x110>
   1e8c4:	3a804a26 	beq	r7,r10,1e9f0 <_fpadd_parts+0x238>
   1e8c8:	1089883a 	add	r4,r2,r2
   1e8cc:	2091803a 	cmpltu	r8,r4,r2
   1e8d0:	18c7883a 	add	r3,r3,r3
   1e8d4:	227fffc4 	addi	r9,r4,-1
   1e8d8:	40d1883a 	add	r8,r8,r3
   1e8dc:	490f403a 	cmpgeu	r7,r9,r4
   1e8e0:	41cfc83a 	sub	r7,r8,r7
   1e8e4:	2817883a 	mov	r11,r5
   1e8e8:	2005883a 	mov	r2,r4
   1e8ec:	4007883a 	mov	r3,r8
   1e8f0:	297fffc4 	addi	r5,r5,-1
   1e8f4:	51fff32e 	bgeu	r10,r7,1e8c4 <_fpadd_parts+0x10c>
   1e8f8:	31000315 	stw	r4,12(r6)
   1e8fc:	32000415 	stw	r8,16(r6)
   1e900:	32c00215 	stw	r11,8(r6)
   1e904:	010000c4 	movi	r4,3
   1e908:	31000015 	stw	r4,0(r6)
   1e90c:	01080034 	movhi	r4,8192
   1e910:	213fffc4 	addi	r4,r4,-1
   1e914:	20c00b2e 	bgeu	r4,r3,1e944 <_fpadd_parts+0x18c>
   1e918:	180e97fa 	slli	r7,r3,31
   1e91c:	1008d07a 	srli	r4,r2,1
   1e920:	31400217 	ldw	r5,8(r6)
   1e924:	1806d07a 	srli	r3,r3,1
   1e928:	1080004c 	andi	r2,r2,1
   1e92c:	3908b03a 	or	r4,r7,r4
   1e930:	1108b03a 	or	r4,r2,r4
   1e934:	29400044 	addi	r5,r5,1
   1e938:	31000315 	stw	r4,12(r6)
   1e93c:	30c00415 	stw	r3,16(r6)
   1e940:	31400215 	stw	r5,8(r6)
   1e944:	3005883a 	mov	r2,r6
   1e948:	f800283a 	ret
   1e94c:	2805883a 	mov	r2,r5
   1e950:	f800283a 	ret
   1e954:	59c01e0e 	bge	r11,r7,1e9d0 <_fpadd_parts+0x218>
   1e958:	11000117 	ldw	r4,4(r2)
   1e95c:	28800117 	ldw	r2,4(r5)
   1e960:	0011883a 	mov	r8,zero
   1e964:	0013883a 	mov	r9,zero
   1e968:	20bfbf1e 	bne	r4,r2,1e868 <_fpadd_parts+0xb0>
   1e96c:	4305883a 	add	r2,r8,r12
   1e970:	1207803a 	cmpltu	r3,r2,r8
   1e974:	4b53883a 	add	r9,r9,r13
   1e978:	1a47883a 	add	r3,r3,r9
   1e97c:	31000115 	stw	r4,4(r6)
   1e980:	31c00215 	stw	r7,8(r6)
   1e984:	30800315 	stw	r2,12(r6)
   1e988:	30c00415 	stw	r3,16(r6)
   1e98c:	003fdd06 	br	1e904 <_fpadd_parts+0x14c>
   1e990:	20ffef1e 	bne	r4,r3,1e950 <_fpadd_parts+0x198>
   1e994:	31000015 	stw	r4,0(r6)
   1e998:	10c00117 	ldw	r3,4(r2)
   1e99c:	30c00115 	stw	r3,4(r6)
   1e9a0:	10c00217 	ldw	r3,8(r2)
   1e9a4:	11000117 	ldw	r4,4(r2)
   1e9a8:	29400117 	ldw	r5,4(r5)
   1e9ac:	30c00215 	stw	r3,8(r6)
   1e9b0:	10c00317 	ldw	r3,12(r2)
   1e9b4:	2908703a 	and	r4,r5,r4
   1e9b8:	30c00315 	stw	r3,12(r6)
   1e9bc:	10c00417 	ldw	r3,16(r2)
   1e9c0:	31000115 	stw	r4,4(r6)
   1e9c4:	3005883a 	mov	r2,r6
   1e9c8:	30c00415 	stw	r3,16(r6)
   1e9cc:	f800283a 	ret
   1e9d0:	580f883a 	mov	r7,r11
   1e9d4:	0019883a 	mov	r12,zero
   1e9d8:	001b883a 	mov	r13,zero
   1e9dc:	003f9f06 	br	1e85c <_fpadd_parts+0xa4>
   1e9e0:	0115c83a 	sub	r10,zero,r4
   1e9e4:	00c00fc4 	movi	r3,63
   1e9e8:	1abfda16 	blt	r3,r10,1e954 <_fpadd_parts+0x19c>
   1e9ec:	003f8906 	br	1e814 <_fpadd_parts+0x5c>
   1e9f0:	627fb52e 	bgeu	r12,r9,1e8c8 <_fpadd_parts+0x110>
   1e9f4:	003fc006 	br	1e8f8 <_fpadd_parts+0x140>
   1e9f8:	6205c83a 	sub	r2,r12,r8
   1e9fc:	6099803a 	cmpltu	r12,r12,r2
   1ea00:	6a47c83a 	sub	r3,r13,r9
   1ea04:	1b07c83a 	sub	r3,r3,r12
   1ea08:	183f9d0e 	bge	r3,zero,1e880 <_fpadd_parts+0xc8>
   1ea0c:	0085c83a 	sub	r2,zero,r2
   1ea10:	1008c03a 	cmpne	r4,r2,zero
   1ea14:	00c7c83a 	sub	r3,zero,r3
   1ea18:	1907c83a 	sub	r3,r3,r4
   1ea1c:	01000044 	movi	r4,1
   1ea20:	31000115 	stw	r4,4(r6)
   1ea24:	31c00215 	stw	r7,8(r6)
   1ea28:	30800315 	stw	r2,12(r6)
   1ea2c:	30c00415 	stw	r3,16(r6)
   1ea30:	003f9706 	br	1e890 <_fpadd_parts+0xd8>
   1ea34:	203f8926 	beq	r4,zero,1e85c <_fpadd_parts+0xa4>
   1ea38:	50fff804 	addi	r3,r10,-32
   1ea3c:	3a8f883a 	add	r7,r7,r10
   1ea40:	18002316 	blt	r3,zero,1ead0 <_fpadd_parts+0x318>
   1ea44:	68d6d83a 	srl	r11,r13,r3
   1ea48:	001d883a 	mov	r14,zero
   1ea4c:	18001c16 	blt	r3,zero,1eac0 <_fpadd_parts+0x308>
   1ea50:	01000044 	movi	r4,1
   1ea54:	20c6983a 	sll	r3,r4,r3
   1ea58:	0015883a 	mov	r10,zero
   1ea5c:	513fffc4 	addi	r4,r10,-1
   1ea60:	2295403a 	cmpgeu	r10,r4,r10
   1ea64:	1a87c83a 	sub	r3,r3,r10
   1ea68:	1b5a703a 	and	r13,r3,r13
   1ea6c:	2318703a 	and	r12,r4,r12
   1ea70:	6358b03a 	or	r12,r12,r13
   1ea74:	6018c03a 	cmpne	r12,r12,zero
   1ea78:	62d8b03a 	or	r12,r12,r11
   1ea7c:	701b883a 	mov	r13,r14
   1ea80:	003f7606 	br	1e85c <_fpadd_parts+0xa4>
   1ea84:	4808907a 	slli	r4,r9,1
   1ea88:	02c007c4 	movi	r11,31
   1ea8c:	5a97c83a 	sub	r11,r11,r10
   1ea90:	22c8983a 	sll	r4,r4,r11
   1ea94:	4296d83a 	srl	r11,r8,r10
   1ea98:	4a9cd83a 	srl	r14,r9,r10
   1ea9c:	22d6b03a 	or	r11,r4,r11
   1eaa0:	003f6106 	br	1e828 <_fpadd_parts+0x70>
   1eaa4:	00c00044 	movi	r3,1
   1eaa8:	1a94983a 	sll	r10,r3,r10
   1eaac:	0007883a 	mov	r3,zero
   1eab0:	003f6106 	br	1e838 <_fpadd_parts+0x80>
   1eab4:	013fff84 	movi	r4,-2
   1eab8:	21ff7c2e 	bgeu	r4,r7,1e8ac <_fpadd_parts+0xf4>
   1eabc:	003f9106 	br	1e904 <_fpadd_parts+0x14c>
   1eac0:	00c00044 	movi	r3,1
   1eac4:	1a94983a 	sll	r10,r3,r10
   1eac8:	0007883a 	mov	r3,zero
   1eacc:	003fe306 	br	1ea5c <_fpadd_parts+0x2a4>
   1ead0:	6816907a 	slli	r11,r13,1
   1ead4:	010007c4 	movi	r4,31
   1ead8:	2289c83a 	sub	r4,r4,r10
   1eadc:	5908983a 	sll	r4,r11,r4
   1eae0:	6296d83a 	srl	r11,r12,r10
   1eae4:	6a9cd83a 	srl	r14,r13,r10
   1eae8:	22d6b03a 	or	r11,r4,r11
   1eaec:	003fd706 	br	1ea4c <_fpadd_parts+0x294>
   1eaf0:	193f971e 	bne	r3,r4,1e950 <_fpadd_parts+0x198>
   1eaf4:	11000117 	ldw	r4,4(r2)
   1eaf8:	28c00117 	ldw	r3,4(r5)
   1eafc:	20ff9426 	beq	r4,r3,1e950 <_fpadd_parts+0x198>
   1eb00:	008000f4 	movhi	r2,3
   1eb04:	10bc8104 	addi	r2,r2,-3580
   1eb08:	f800283a 	ret

0001eb0c <__adddf3>:
   1eb0c:	deffec04 	addi	sp,sp,-80
   1eb10:	d9001115 	stw	r4,68(sp)
   1eb14:	d9401215 	stw	r5,72(sp)
   1eb18:	d9001104 	addi	r4,sp,68
   1eb1c:	d9400a04 	addi	r5,sp,40
   1eb20:	dfc01315 	stw	ra,76(sp)
   1eb24:	d9c01015 	stw	r7,64(sp)
   1eb28:	d9800f15 	stw	r6,60(sp)
   1eb2c:	001f9580 	call	1f958 <__unpack_d>
   1eb30:	d9000f04 	addi	r4,sp,60
   1eb34:	d9400504 	addi	r5,sp,20
   1eb38:	001f9580 	call	1f958 <__unpack_d>
   1eb3c:	d9000a04 	addi	r4,sp,40
   1eb40:	d9400504 	addi	r5,sp,20
   1eb44:	d80d883a 	mov	r6,sp
   1eb48:	001e7b80 	call	1e7b8 <_fpadd_parts>
   1eb4c:	1009883a 	mov	r4,r2
   1eb50:	001f7340 	call	1f734 <__pack_d>
   1eb54:	dfc01317 	ldw	ra,76(sp)
   1eb58:	dec01404 	addi	sp,sp,80
   1eb5c:	f800283a 	ret

0001eb60 <__subdf3>:
   1eb60:	deffec04 	addi	sp,sp,-80
   1eb64:	d9001115 	stw	r4,68(sp)
   1eb68:	d9401215 	stw	r5,72(sp)
   1eb6c:	d9001104 	addi	r4,sp,68
   1eb70:	d9400a04 	addi	r5,sp,40
   1eb74:	dfc01315 	stw	ra,76(sp)
   1eb78:	d9c01015 	stw	r7,64(sp)
   1eb7c:	d9800f15 	stw	r6,60(sp)
   1eb80:	001f9580 	call	1f958 <__unpack_d>
   1eb84:	d9000f04 	addi	r4,sp,60
   1eb88:	d9400504 	addi	r5,sp,20
   1eb8c:	001f9580 	call	1f958 <__unpack_d>
   1eb90:	d8800617 	ldw	r2,24(sp)
   1eb94:	d9000a04 	addi	r4,sp,40
   1eb98:	d9400504 	addi	r5,sp,20
   1eb9c:	d80d883a 	mov	r6,sp
   1eba0:	1080005c 	xori	r2,r2,1
   1eba4:	d8800615 	stw	r2,24(sp)
   1eba8:	001e7b80 	call	1e7b8 <_fpadd_parts>
   1ebac:	1009883a 	mov	r4,r2
   1ebb0:	001f7340 	call	1f734 <__pack_d>
   1ebb4:	dfc01317 	ldw	ra,76(sp)
   1ebb8:	dec01404 	addi	sp,sp,80
   1ebbc:	f800283a 	ret

0001ebc0 <__muldf3>:
   1ebc0:	deffe404 	addi	sp,sp,-112
   1ebc4:	d9001115 	stw	r4,68(sp)
   1ebc8:	d9401215 	stw	r5,72(sp)
   1ebcc:	d9001104 	addi	r4,sp,68
   1ebd0:	d9400a04 	addi	r5,sp,40
   1ebd4:	dfc01b15 	stw	ra,108(sp)
   1ebd8:	d9800f15 	stw	r6,60(sp)
   1ebdc:	d9c01015 	stw	r7,64(sp)
   1ebe0:	ddc01a15 	stw	r23,104(sp)
   1ebe4:	dd801915 	stw	r22,100(sp)
   1ebe8:	dd401815 	stw	r21,96(sp)
   1ebec:	dd001715 	stw	r20,92(sp)
   1ebf0:	dcc01615 	stw	r19,88(sp)
   1ebf4:	dc801515 	stw	r18,84(sp)
   1ebf8:	dc401415 	stw	r17,80(sp)
   1ebfc:	dc001315 	stw	r16,76(sp)
   1ec00:	001f9580 	call	1f958 <__unpack_d>
   1ec04:	d9000f04 	addi	r4,sp,60
   1ec08:	d9400504 	addi	r5,sp,20
   1ec0c:	001f9580 	call	1f958 <__unpack_d>
   1ec10:	d8c00a17 	ldw	r3,40(sp)
   1ec14:	00800044 	movi	r2,1
   1ec18:	10c01136 	bltu	r2,r3,1ec60 <__muldf3+0xa0>
   1ec1c:	d8c00b17 	ldw	r3,44(sp)
   1ec20:	d8800617 	ldw	r2,24(sp)
   1ec24:	d9000a04 	addi	r4,sp,40
   1ec28:	1884c03a 	cmpne	r2,r3,r2
   1ec2c:	d8800b15 	stw	r2,44(sp)
   1ec30:	001f7340 	call	1f734 <__pack_d>
   1ec34:	dfc01b17 	ldw	ra,108(sp)
   1ec38:	ddc01a17 	ldw	r23,104(sp)
   1ec3c:	dd801917 	ldw	r22,100(sp)
   1ec40:	dd401817 	ldw	r21,96(sp)
   1ec44:	dd001717 	ldw	r20,92(sp)
   1ec48:	dcc01617 	ldw	r19,88(sp)
   1ec4c:	dc801517 	ldw	r18,84(sp)
   1ec50:	dc401417 	ldw	r17,80(sp)
   1ec54:	dc001317 	ldw	r16,76(sp)
   1ec58:	dec01c04 	addi	sp,sp,112
   1ec5c:	f800283a 	ret
   1ec60:	d9000517 	ldw	r4,20(sp)
   1ec64:	11000636 	bltu	r2,r4,1ec80 <__muldf3+0xc0>
   1ec68:	d8800617 	ldw	r2,24(sp)
   1ec6c:	d8c00b17 	ldw	r3,44(sp)
   1ec70:	d9000504 	addi	r4,sp,20
   1ec74:	1884c03a 	cmpne	r2,r3,r2
   1ec78:	d8800615 	stw	r2,24(sp)
   1ec7c:	003fec06 	br	1ec30 <__muldf3+0x70>
   1ec80:	00800104 	movi	r2,4
   1ec84:	1880051e 	bne	r3,r2,1ec9c <__muldf3+0xdc>
   1ec88:	00800084 	movi	r2,2
   1ec8c:	20bfe31e 	bne	r4,r2,1ec1c <__muldf3+0x5c>
   1ec90:	010000f4 	movhi	r4,3
   1ec94:	213c8104 	addi	r4,r4,-3580
   1ec98:	003fe506 	br	1ec30 <__muldf3+0x70>
   1ec9c:	2080031e 	bne	r4,r2,1ecac <__muldf3+0xec>
   1eca0:	00800084 	movi	r2,2
   1eca4:	18bffa26 	beq	r3,r2,1ec90 <__muldf3+0xd0>
   1eca8:	003fef06 	br	1ec68 <__muldf3+0xa8>
   1ecac:	00800084 	movi	r2,2
   1ecb0:	18bfda26 	beq	r3,r2,1ec1c <__muldf3+0x5c>
   1ecb4:	20bfec26 	beq	r4,r2,1ec68 <__muldf3+0xa8>
   1ecb8:	dc000d17 	ldw	r16,52(sp)
   1ecbc:	dd000817 	ldw	r20,32(sp)
   1ecc0:	dc800917 	ldw	r18,36(sp)
   1ecc4:	8009883a 	mov	r4,r16
   1ecc8:	000b883a 	mov	r5,zero
   1eccc:	a00d883a 	mov	r6,r20
   1ecd0:	000f883a 	mov	r7,zero
   1ecd4:	001f6280 	call	1f628 <__muldi3>
   1ecd8:	dc400e17 	ldw	r17,56(sp)
   1ecdc:	9009883a 	mov	r4,r18
   1ece0:	800d883a 	mov	r6,r16
   1ece4:	000b883a 	mov	r5,zero
   1ece8:	000f883a 	mov	r7,zero
   1ecec:	102f883a 	mov	r23,r2
   1ecf0:	1827883a 	mov	r19,r3
   1ecf4:	001f6280 	call	1f628 <__muldi3>
   1ecf8:	900d883a 	mov	r6,r18
   1ecfc:	8809883a 	mov	r4,r17
   1ed00:	000b883a 	mov	r5,zero
   1ed04:	000f883a 	mov	r7,zero
   1ed08:	102b883a 	mov	r21,r2
   1ed0c:	1821883a 	mov	r16,r3
   1ed10:	001f6280 	call	1f628 <__muldi3>
   1ed14:	8809883a 	mov	r4,r17
   1ed18:	000b883a 	mov	r5,zero
   1ed1c:	a00d883a 	mov	r6,r20
   1ed20:	000f883a 	mov	r7,zero
   1ed24:	102d883a 	mov	r22,r2
   1ed28:	1825883a 	mov	r18,r3
   1ed2c:	001f6280 	call	1f628 <__muldi3>
   1ed30:	154b883a 	add	r5,r2,r21
   1ed34:	2889803a 	cmpltu	r4,r5,r2
   1ed38:	1c07883a 	add	r3,r3,r16
   1ed3c:	20c9883a 	add	r4,r4,r3
   1ed40:	24004b36 	bltu	r4,r16,1ee70 <__muldf3+0x2b0>
   1ed44:	8100011e 	bne	r16,r4,1ed4c <__muldf3+0x18c>
   1ed48:	2d404936 	bltu	r5,r21,1ee70 <__muldf3+0x2b0>
   1ed4c:	0011883a 	mov	r8,zero
   1ed50:	0007883a 	mov	r3,zero
   1ed54:	2ccb883a 	add	r5,r5,r19
   1ed58:	b80d883a 	mov	r6,r23
   1ed5c:	2cc0012e 	bgeu	r5,r19,1ed64 <__muldf3+0x1a4>
   1ed60:	02000044 	movi	r8,1
   1ed64:	258f883a 	add	r7,r4,r22
   1ed68:	3909803a 	cmpltu	r4,r7,r4
   1ed6c:	da400c17 	ldw	r9,48(sp)
   1ed70:	2489883a 	add	r4,r4,r18
   1ed74:	d8800717 	ldw	r2,28(sp)
   1ed78:	20c9883a 	add	r4,r4,r3
   1ed7c:	da800b17 	ldw	r10,44(sp)
   1ed80:	d8c00617 	ldw	r3,24(sp)
   1ed84:	3a11883a 	add	r8,r7,r8
   1ed88:	4885883a 	add	r2,r9,r2
   1ed8c:	50c6c03a 	cmpne	r3,r10,r3
   1ed90:	41cf803a 	cmpltu	r7,r8,r7
   1ed94:	12400104 	addi	r9,r2,4
   1ed98:	d8c00115 	stw	r3,4(sp)
   1ed9c:	3909883a 	add	r4,r7,r4
   1eda0:	da400215 	stw	r9,8(sp)
   1eda4:	03480034 	movhi	r13,8192
   1eda8:	6b7fffc4 	addi	r13,r13,-1
   1edac:	4007883a 	mov	r3,r8
   1edb0:	6900102e 	bgeu	r13,r4,1edf4 <__muldf3+0x234>
   1edb4:	10800144 	addi	r2,r2,5
   1edb8:	180ed07a 	srli	r7,r3,1
   1edbc:	18c0004c 	andi	r3,r3,1
   1edc0:	201097fa 	slli	r8,r4,31
   1edc4:	281697fa 	slli	r11,r5,31
   1edc8:	2008d07a 	srli	r4,r4,1
   1edcc:	3014d07a 	srli	r10,r6,1
   1edd0:	2812d07a 	srli	r9,r5,1
   1edd4:	1019883a 	mov	r12,r2
   1edd8:	18000226 	beq	r3,zero,1ede4 <__muldf3+0x224>
   1eddc:	5a8cb03a 	or	r6,r11,r10
   1ede0:	49600034 	orhi	r5,r9,32768
   1ede4:	41c6b03a 	or	r3,r8,r7
   1ede8:	10800044 	addi	r2,r2,1
   1edec:	693ff236 	bltu	r13,r4,1edb8 <__muldf3+0x1f8>
   1edf0:	db000215 	stw	r12,8(sp)
   1edf4:	03440034 	movhi	r13,4096
   1edf8:	6b7fffc4 	addi	r13,r13,-1
   1edfc:	69001336 	bltu	r13,r4,1ee4c <__muldf3+0x28c>
   1ee00:	d8800217 	ldw	r2,8(sp)
   1ee04:	10bfffc4 	addi	r2,r2,-1
   1ee08:	18d3883a 	add	r9,r3,r3
   1ee0c:	48c7803a 	cmpltu	r3,r9,r3
   1ee10:	2109883a 	add	r4,r4,r4
   1ee14:	190f883a 	add	r7,r3,r4
   1ee18:	3191883a 	add	r8,r6,r6
   1ee1c:	4197803a 	cmpltu	r11,r8,r6
   1ee20:	2955883a 	add	r10,r5,r5
   1ee24:	1019883a 	mov	r12,r2
   1ee28:	4807883a 	mov	r3,r9
   1ee2c:	3809883a 	mov	r4,r7
   1ee30:	2800010e 	bge	r5,zero,1ee38 <__muldf3+0x278>
   1ee34:	48c00054 	ori	r3,r9,1
   1ee38:	400d883a 	mov	r6,r8
   1ee3c:	5a8b883a 	add	r5,r11,r10
   1ee40:	10bfffc4 	addi	r2,r2,-1
   1ee44:	69fff02e 	bgeu	r13,r7,1ee08 <__muldf3+0x248>
   1ee48:	db000215 	stw	r12,8(sp)
   1ee4c:	18803fcc 	andi	r2,r3,255
   1ee50:	01c02004 	movi	r7,128
   1ee54:	11c00926 	beq	r2,r7,1ee7c <__muldf3+0x2bc>
   1ee58:	008000c4 	movi	r2,3
   1ee5c:	d9000415 	stw	r4,16(sp)
   1ee60:	d8c00315 	stw	r3,12(sp)
   1ee64:	d8800015 	stw	r2,0(sp)
   1ee68:	d809883a 	mov	r4,sp
   1ee6c:	003f7006 	br	1ec30 <__muldf3+0x70>
   1ee70:	0011883a 	mov	r8,zero
   1ee74:	00c00044 	movi	r3,1
   1ee78:	003fb606 	br	1ed54 <__muldf3+0x194>
   1ee7c:	19c0400c 	andi	r7,r3,256
   1ee80:	383ff51e 	bne	r7,zero,1ee58 <__muldf3+0x298>
   1ee84:	314ab03a 	or	r5,r6,r5
   1ee88:	283ff326 	beq	r5,zero,1ee58 <__muldf3+0x298>
   1ee8c:	1885883a 	add	r2,r3,r2
   1ee90:	10cb803a 	cmpltu	r5,r2,r3
   1ee94:	00ffc004 	movi	r3,-256
   1ee98:	10c6703a 	and	r3,r2,r3
   1ee9c:	2909883a 	add	r4,r5,r4
   1eea0:	003fed06 	br	1ee58 <__muldf3+0x298>

0001eea4 <__divdf3>:
   1eea4:	defff104 	addi	sp,sp,-60
   1eea8:	d9000c15 	stw	r4,48(sp)
   1eeac:	d9400d15 	stw	r5,52(sp)
   1eeb0:	d9000c04 	addi	r4,sp,48
   1eeb4:	d9400504 	addi	r5,sp,20
   1eeb8:	dfc00e15 	stw	ra,56(sp)
   1eebc:	d9800a15 	stw	r6,40(sp)
   1eec0:	d9c00b15 	stw	r7,44(sp)
   1eec4:	001f9580 	call	1f958 <__unpack_d>
   1eec8:	d9000a04 	addi	r4,sp,40
   1eecc:	d80b883a 	mov	r5,sp
   1eed0:	001f9580 	call	1f958 <__unpack_d>
   1eed4:	d8c00517 	ldw	r3,20(sp)
   1eed8:	00800044 	movi	r2,1
   1eedc:	10c00536 	bltu	r2,r3,1eef4 <__divdf3+0x50>
   1eee0:	d9000504 	addi	r4,sp,20
   1eee4:	001f7340 	call	1f734 <__pack_d>
   1eee8:	dfc00e17 	ldw	ra,56(sp)
   1eeec:	dec00f04 	addi	sp,sp,60
   1eef0:	f800283a 	ret
   1eef4:	d9000017 	ldw	r4,0(sp)
   1eef8:	11000536 	bltu	r2,r4,1ef10 <__divdf3+0x6c>
   1eefc:	d809883a 	mov	r4,sp
   1ef00:	001f7340 	call	1f734 <__pack_d>
   1ef04:	dfc00e17 	ldw	ra,56(sp)
   1ef08:	dec00f04 	addi	sp,sp,60
   1ef0c:	f800283a 	ret
   1ef10:	d9800617 	ldw	r6,24(sp)
   1ef14:	d9400117 	ldw	r5,4(sp)
   1ef18:	00800104 	movi	r2,4
   1ef1c:	314af03a 	xor	r5,r6,r5
   1ef20:	d9400615 	stw	r5,24(sp)
   1ef24:	18800226 	beq	r3,r2,1ef30 <__divdf3+0x8c>
   1ef28:	01400084 	movi	r5,2
   1ef2c:	1940041e 	bne	r3,r5,1ef40 <__divdf3+0x9c>
   1ef30:	193feb1e 	bne	r3,r4,1eee0 <__divdf3+0x3c>
   1ef34:	010000f4 	movhi	r4,3
   1ef38:	213c8104 	addi	r4,r4,-3580
   1ef3c:	003fe906 	br	1eee4 <__divdf3+0x40>
   1ef40:	20803326 	beq	r4,r2,1f010 <__divdf3+0x16c>
   1ef44:	21403726 	beq	r4,r5,1f024 <__divdf3+0x180>
   1ef48:	d8800217 	ldw	r2,8(sp)
   1ef4c:	d9000717 	ldw	r4,28(sp)
   1ef50:	d8c00917 	ldw	r3,36(sp)
   1ef54:	da000417 	ldw	r8,16(sp)
   1ef58:	2089c83a 	sub	r4,r4,r2
   1ef5c:	d9000715 	stw	r4,28(sp)
   1ef60:	d8800817 	ldw	r2,32(sp)
   1ef64:	dbc00317 	ldw	r15,12(sp)
   1ef68:	1a000236 	bltu	r3,r8,1ef74 <__divdf3+0xd0>
   1ef6c:	40c0081e 	bne	r8,r3,1ef90 <__divdf3+0xec>
   1ef70:	13c0072e 	bgeu	r2,r15,1ef90 <__divdf3+0xec>
   1ef74:	108b883a 	add	r5,r2,r2
   1ef78:	288d803a 	cmpltu	r6,r5,r2
   1ef7c:	18c7883a 	add	r3,r3,r3
   1ef80:	213fffc4 	addi	r4,r4,-1
   1ef84:	2805883a 	mov	r2,r5
   1ef88:	30c7883a 	add	r3,r6,r3
   1ef8c:	d9000715 	stw	r4,28(sp)
   1ef90:	01400f44 	movi	r5,61
   1ef94:	000f883a 	mov	r7,zero
   1ef98:	01040034 	movhi	r4,4096
   1ef9c:	0019883a 	mov	r12,zero
   1efa0:	001b883a 	mov	r13,zero
   1efa4:	201697fa 	slli	r11,r4,31
   1efa8:	3814d07a 	srli	r10,r7,1
   1efac:	297fffc4 	addi	r5,r5,-1
   1efb0:	1a000936 	bltu	r3,r8,1efd8 <__divdf3+0x134>
   1efb4:	13cdc83a 	sub	r6,r2,r15
   1efb8:	1193803a 	cmpltu	r9,r2,r6
   1efbc:	1a1dc83a 	sub	r14,r3,r8
   1efc0:	40c0011e 	bne	r8,r3,1efc8 <__divdf3+0x124>
   1efc4:	13c00436 	bltu	r2,r15,1efd8 <__divdf3+0x134>
   1efc8:	3005883a 	mov	r2,r6
   1efcc:	7247c83a 	sub	r3,r14,r9
   1efd0:	61d8b03a 	or	r12,r12,r7
   1efd4:	691ab03a 	or	r13,r13,r4
   1efd8:	108d883a 	add	r6,r2,r2
   1efdc:	3093803a 	cmpltu	r9,r6,r2
   1efe0:	18c7883a 	add	r3,r3,r3
   1efe4:	5a8eb03a 	or	r7,r11,r10
   1efe8:	2008d07a 	srli	r4,r4,1
   1efec:	3005883a 	mov	r2,r6
   1eff0:	48c7883a 	add	r3,r9,r3
   1eff4:	283feb1e 	bne	r5,zero,1efa4 <__divdf3+0x100>
   1eff8:	61003fcc 	andi	r4,r12,255
   1effc:	01402004 	movi	r5,128
   1f000:	21400b26 	beq	r4,r5,1f030 <__divdf3+0x18c>
   1f004:	db000815 	stw	r12,32(sp)
   1f008:	db400915 	stw	r13,36(sp)
   1f00c:	003fb406 	br	1eee0 <__divdf3+0x3c>
   1f010:	d8000815 	stw	zero,32(sp)
   1f014:	d8000915 	stw	zero,36(sp)
   1f018:	d8000715 	stw	zero,28(sp)
   1f01c:	d9000504 	addi	r4,sp,20
   1f020:	003fb006 	br	1eee4 <__divdf3+0x40>
   1f024:	d8800515 	stw	r2,20(sp)
   1f028:	d9000504 	addi	r4,sp,20
   1f02c:	003fad06 	br	1eee4 <__divdf3+0x40>
   1f030:	6140400c 	andi	r5,r12,256
   1f034:	283ff31e 	bne	r5,zero,1f004 <__divdf3+0x160>
   1f038:	30c4b03a 	or	r2,r6,r3
   1f03c:	103ff126 	beq	r2,zero,1f004 <__divdf3+0x160>
   1f040:	6109883a 	add	r4,r12,r4
   1f044:	2305803a 	cmpltu	r2,r4,r12
   1f048:	033fc004 	movi	r12,-256
   1f04c:	2318703a 	and	r12,r4,r12
   1f050:	135b883a 	add	r13,r2,r13
   1f054:	003feb06 	br	1f004 <__divdf3+0x160>

0001f058 <__eqdf2>:
   1f058:	defff104 	addi	sp,sp,-60
   1f05c:	d9000c15 	stw	r4,48(sp)
   1f060:	d9400d15 	stw	r5,52(sp)
   1f064:	d9000c04 	addi	r4,sp,48
   1f068:	d9400504 	addi	r5,sp,20
   1f06c:	dfc00e15 	stw	ra,56(sp)
   1f070:	d9800a15 	stw	r6,40(sp)
   1f074:	d9c00b15 	stw	r7,44(sp)
   1f078:	001f9580 	call	1f958 <__unpack_d>
   1f07c:	d9000a04 	addi	r4,sp,40
   1f080:	d80b883a 	mov	r5,sp
   1f084:	001f9580 	call	1f958 <__unpack_d>
   1f088:	d8c00517 	ldw	r3,20(sp)
   1f08c:	00800044 	movi	r2,1
   1f090:	10c0052e 	bgeu	r2,r3,1f0a8 <__eqdf2+0x50>
   1f094:	d8c00017 	ldw	r3,0(sp)
   1f098:	10c0032e 	bgeu	r2,r3,1f0a8 <__eqdf2+0x50>
   1f09c:	d9000504 	addi	r4,sp,20
   1f0a0:	d80b883a 	mov	r5,sp
   1f0a4:	001fa5c0 	call	1fa5c <__fpcmp_parts_d>
   1f0a8:	dfc00e17 	ldw	ra,56(sp)
   1f0ac:	dec00f04 	addi	sp,sp,60
   1f0b0:	f800283a 	ret

0001f0b4 <__nedf2>:
   1f0b4:	defff104 	addi	sp,sp,-60
   1f0b8:	d9000c15 	stw	r4,48(sp)
   1f0bc:	d9400d15 	stw	r5,52(sp)
   1f0c0:	d9000c04 	addi	r4,sp,48
   1f0c4:	d9400504 	addi	r5,sp,20
   1f0c8:	dfc00e15 	stw	ra,56(sp)
   1f0cc:	d9800a15 	stw	r6,40(sp)
   1f0d0:	d9c00b15 	stw	r7,44(sp)
   1f0d4:	001f9580 	call	1f958 <__unpack_d>
   1f0d8:	d9000a04 	addi	r4,sp,40
   1f0dc:	d80b883a 	mov	r5,sp
   1f0e0:	001f9580 	call	1f958 <__unpack_d>
   1f0e4:	d8c00517 	ldw	r3,20(sp)
   1f0e8:	00800044 	movi	r2,1
   1f0ec:	10c0052e 	bgeu	r2,r3,1f104 <__nedf2+0x50>
   1f0f0:	d8c00017 	ldw	r3,0(sp)
   1f0f4:	10c0032e 	bgeu	r2,r3,1f104 <__nedf2+0x50>
   1f0f8:	d9000504 	addi	r4,sp,20
   1f0fc:	d80b883a 	mov	r5,sp
   1f100:	001fa5c0 	call	1fa5c <__fpcmp_parts_d>
   1f104:	dfc00e17 	ldw	ra,56(sp)
   1f108:	dec00f04 	addi	sp,sp,60
   1f10c:	f800283a 	ret

0001f110 <__gtdf2>:
   1f110:	defff104 	addi	sp,sp,-60
   1f114:	d9000c15 	stw	r4,48(sp)
   1f118:	d9400d15 	stw	r5,52(sp)
   1f11c:	d9000c04 	addi	r4,sp,48
   1f120:	d9400504 	addi	r5,sp,20
   1f124:	dfc00e15 	stw	ra,56(sp)
   1f128:	d9800a15 	stw	r6,40(sp)
   1f12c:	d9c00b15 	stw	r7,44(sp)
   1f130:	001f9580 	call	1f958 <__unpack_d>
   1f134:	d9000a04 	addi	r4,sp,40
   1f138:	d80b883a 	mov	r5,sp
   1f13c:	001f9580 	call	1f958 <__unpack_d>
   1f140:	d8c00517 	ldw	r3,20(sp)
   1f144:	00800044 	movi	r2,1
   1f148:	10c0082e 	bgeu	r2,r3,1f16c <__gtdf2+0x5c>
   1f14c:	d8c00017 	ldw	r3,0(sp)
   1f150:	10c0062e 	bgeu	r2,r3,1f16c <__gtdf2+0x5c>
   1f154:	d9000504 	addi	r4,sp,20
   1f158:	d80b883a 	mov	r5,sp
   1f15c:	001fa5c0 	call	1fa5c <__fpcmp_parts_d>
   1f160:	dfc00e17 	ldw	ra,56(sp)
   1f164:	dec00f04 	addi	sp,sp,60
   1f168:	f800283a 	ret
   1f16c:	00bfffc4 	movi	r2,-1
   1f170:	003ffb06 	br	1f160 <__gtdf2+0x50>

0001f174 <__gedf2>:
   1f174:	defff104 	addi	sp,sp,-60
   1f178:	d9000c15 	stw	r4,48(sp)
   1f17c:	d9400d15 	stw	r5,52(sp)
   1f180:	d9000c04 	addi	r4,sp,48
   1f184:	d9400504 	addi	r5,sp,20
   1f188:	dfc00e15 	stw	ra,56(sp)
   1f18c:	d9800a15 	stw	r6,40(sp)
   1f190:	d9c00b15 	stw	r7,44(sp)
   1f194:	001f9580 	call	1f958 <__unpack_d>
   1f198:	d9000a04 	addi	r4,sp,40
   1f19c:	d80b883a 	mov	r5,sp
   1f1a0:	001f9580 	call	1f958 <__unpack_d>
   1f1a4:	d8c00517 	ldw	r3,20(sp)
   1f1a8:	00800044 	movi	r2,1
   1f1ac:	10c0082e 	bgeu	r2,r3,1f1d0 <__gedf2+0x5c>
   1f1b0:	d8c00017 	ldw	r3,0(sp)
   1f1b4:	10c0062e 	bgeu	r2,r3,1f1d0 <__gedf2+0x5c>
   1f1b8:	d9000504 	addi	r4,sp,20
   1f1bc:	d80b883a 	mov	r5,sp
   1f1c0:	001fa5c0 	call	1fa5c <__fpcmp_parts_d>
   1f1c4:	dfc00e17 	ldw	ra,56(sp)
   1f1c8:	dec00f04 	addi	sp,sp,60
   1f1cc:	f800283a 	ret
   1f1d0:	00bfffc4 	movi	r2,-1
   1f1d4:	003ffb06 	br	1f1c4 <__gedf2+0x50>

0001f1d8 <__ltdf2>:
   1f1d8:	defff104 	addi	sp,sp,-60
   1f1dc:	d9000c15 	stw	r4,48(sp)
   1f1e0:	d9400d15 	stw	r5,52(sp)
   1f1e4:	d9000c04 	addi	r4,sp,48
   1f1e8:	d9400504 	addi	r5,sp,20
   1f1ec:	dfc00e15 	stw	ra,56(sp)
   1f1f0:	d9800a15 	stw	r6,40(sp)
   1f1f4:	d9c00b15 	stw	r7,44(sp)
   1f1f8:	001f9580 	call	1f958 <__unpack_d>
   1f1fc:	d9000a04 	addi	r4,sp,40
   1f200:	d80b883a 	mov	r5,sp
   1f204:	001f9580 	call	1f958 <__unpack_d>
   1f208:	d8c00517 	ldw	r3,20(sp)
   1f20c:	00800044 	movi	r2,1
   1f210:	10c0052e 	bgeu	r2,r3,1f228 <__ltdf2+0x50>
   1f214:	d8c00017 	ldw	r3,0(sp)
   1f218:	10c0032e 	bgeu	r2,r3,1f228 <__ltdf2+0x50>
   1f21c:	d9000504 	addi	r4,sp,20
   1f220:	d80b883a 	mov	r5,sp
   1f224:	001fa5c0 	call	1fa5c <__fpcmp_parts_d>
   1f228:	dfc00e17 	ldw	ra,56(sp)
   1f22c:	dec00f04 	addi	sp,sp,60
   1f230:	f800283a 	ret

0001f234 <__floatsidf>:
   1f234:	2004d7fa 	srli	r2,r4,31
   1f238:	defff904 	addi	sp,sp,-28
   1f23c:	00c000c4 	movi	r3,3
   1f240:	dfc00615 	stw	ra,24(sp)
   1f244:	dc000515 	stw	r16,20(sp)
   1f248:	d8c00015 	stw	r3,0(sp)
   1f24c:	d8800115 	stw	r2,4(sp)
   1f250:	2000081e 	bne	r4,zero,1f274 <__floatsidf+0x40>
   1f254:	00800084 	movi	r2,2
   1f258:	d8800015 	stw	r2,0(sp)
   1f25c:	d809883a 	mov	r4,sp
   1f260:	001f7340 	call	1f734 <__pack_d>
   1f264:	dfc00617 	ldw	ra,24(sp)
   1f268:	dc000517 	ldw	r16,20(sp)
   1f26c:	dec00704 	addi	sp,sp,28
   1f270:	f800283a 	ret
   1f274:	00c00f04 	movi	r3,60
   1f278:	d8c00215 	stw	r3,8(sp)
   1f27c:	10000f1e 	bne	r2,zero,1f2bc <__floatsidf+0x88>
   1f280:	2021883a 	mov	r16,r4
   1f284:	8009883a 	mov	r4,r16
   1f288:	001f6880 	call	1f688 <__clzsi2>
   1f28c:	11000744 	addi	r4,r2,29
   1f290:	0100110e 	bge	zero,r4,1f2d8 <__floatsidf+0xa4>
   1f294:	10ffff44 	addi	r3,r2,-3
   1f298:	18001216 	blt	r3,zero,1f2e4 <__floatsidf+0xb0>
   1f29c:	80c6983a 	sll	r3,r16,r3
   1f2a0:	0009883a 	mov	r4,zero
   1f2a4:	014007c4 	movi	r5,31
   1f2a8:	2885c83a 	sub	r2,r5,r2
   1f2ac:	d9000315 	stw	r4,12(sp)
   1f2b0:	d8c00415 	stw	r3,16(sp)
   1f2b4:	d8800215 	stw	r2,8(sp)
   1f2b8:	003fe806 	br	1f25c <__floatsidf+0x28>
   1f2bc:	00a00034 	movhi	r2,32768
   1f2c0:	20800e26 	beq	r4,r2,1f2fc <__floatsidf+0xc8>
   1f2c4:	0121c83a 	sub	r16,zero,r4
   1f2c8:	8009883a 	mov	r4,r16
   1f2cc:	001f6880 	call	1f688 <__clzsi2>
   1f2d0:	11000744 	addi	r4,r2,29
   1f2d4:	013fef16 	blt	zero,r4,1f294 <__floatsidf+0x60>
   1f2d8:	dc000315 	stw	r16,12(sp)
   1f2dc:	d8000415 	stw	zero,16(sp)
   1f2e0:	003fde06 	br	1f25c <__floatsidf+0x28>
   1f2e4:	800ad07a 	srli	r5,r16,1
   1f2e8:	00c007c4 	movi	r3,31
   1f2ec:	1907c83a 	sub	r3,r3,r4
   1f2f0:	28c6d83a 	srl	r3,r5,r3
   1f2f4:	8108983a 	sll	r4,r16,r4
   1f2f8:	003fea06 	br	1f2a4 <__floatsidf+0x70>
   1f2fc:	0005883a 	mov	r2,zero
   1f300:	00f07834 	movhi	r3,49632
   1f304:	003fd706 	br	1f264 <__floatsidf+0x30>

0001f308 <__fixdfsi>:
   1f308:	defff804 	addi	sp,sp,-32
   1f30c:	d9000515 	stw	r4,20(sp)
   1f310:	d9400615 	stw	r5,24(sp)
   1f314:	d9000504 	addi	r4,sp,20
   1f318:	d80b883a 	mov	r5,sp
   1f31c:	dfc00715 	stw	ra,28(sp)
   1f320:	001f9580 	call	1f958 <__unpack_d>
   1f324:	d8800017 	ldw	r2,0(sp)
   1f328:	00c00084 	movi	r3,2
   1f32c:	10c01c26 	beq	r2,r3,1f3a0 <__fixdfsi+0x98>
   1f330:	00c00044 	movi	r3,1
   1f334:	18801a2e 	bgeu	r3,r2,1f3a0 <__fixdfsi+0x98>
   1f338:	00c00104 	movi	r3,4
   1f33c:	10c01126 	beq	r2,r3,1f384 <__fixdfsi+0x7c>
   1f340:	d8800217 	ldw	r2,8(sp)
   1f344:	10001616 	blt	r2,zero,1f3a0 <__fixdfsi+0x98>
   1f348:	00c00784 	movi	r3,30
   1f34c:	18800d16 	blt	r3,r2,1f384 <__fixdfsi+0x7c>
   1f350:	00c00f04 	movi	r3,60
   1f354:	1885c83a 	sub	r2,r3,r2
   1f358:	10fff804 	addi	r3,r2,-32
   1f35c:	d9400317 	ldw	r5,12(sp)
   1f360:	d9000417 	ldw	r4,16(sp)
   1f364:	18001616 	blt	r3,zero,1f3c0 <__fixdfsi+0xb8>
   1f368:	20c4d83a 	srl	r2,r4,r3
   1f36c:	d8c00117 	ldw	r3,4(sp)
   1f370:	18000126 	beq	r3,zero,1f378 <__fixdfsi+0x70>
   1f374:	0085c83a 	sub	r2,zero,r2
   1f378:	dfc00717 	ldw	ra,28(sp)
   1f37c:	dec00804 	addi	sp,sp,32
   1f380:	f800283a 	ret
   1f384:	d8800117 	ldw	r2,4(sp)
   1f388:	1000091e 	bne	r2,zero,1f3b0 <__fixdfsi+0xa8>
   1f38c:	00a00034 	movhi	r2,32768
   1f390:	10bfffc4 	addi	r2,r2,-1
   1f394:	dfc00717 	ldw	ra,28(sp)
   1f398:	dec00804 	addi	sp,sp,32
   1f39c:	f800283a 	ret
   1f3a0:	0005883a 	mov	r2,zero
   1f3a4:	dfc00717 	ldw	ra,28(sp)
   1f3a8:	dec00804 	addi	sp,sp,32
   1f3ac:	f800283a 	ret
   1f3b0:	00a00034 	movhi	r2,32768
   1f3b4:	dfc00717 	ldw	ra,28(sp)
   1f3b8:	dec00804 	addi	sp,sp,32
   1f3bc:	f800283a 	ret
   1f3c0:	2008907a 	slli	r4,r4,1
   1f3c4:	018007c4 	movi	r6,31
   1f3c8:	308dc83a 	sub	r6,r6,r2
   1f3cc:	2188983a 	sll	r4,r4,r6
   1f3d0:	2884d83a 	srl	r2,r5,r2
   1f3d4:	2084b03a 	or	r2,r4,r2
   1f3d8:	003fe406 	br	1f36c <__fixdfsi+0x64>

0001f3dc <__floatunsidf>:
   1f3dc:	defff904 	addi	sp,sp,-28
   1f3e0:	dc000515 	stw	r16,20(sp)
   1f3e4:	dfc00615 	stw	ra,24(sp)
   1f3e8:	d8000115 	stw	zero,4(sp)
   1f3ec:	2021883a 	mov	r16,r4
   1f3f0:	20001726 	beq	r4,zero,1f450 <__floatunsidf+0x74>
   1f3f4:	008000c4 	movi	r2,3
   1f3f8:	d8800015 	stw	r2,0(sp)
   1f3fc:	00800f04 	movi	r2,60
   1f400:	d8800215 	stw	r2,8(sp)
   1f404:	001f6880 	call	1f688 <__clzsi2>
   1f408:	10c00744 	addi	r3,r2,29
   1f40c:	18001816 	blt	r3,zero,1f470 <__floatunsidf+0x94>
   1f410:	18002d26 	beq	r3,zero,1f4c8 <__floatunsidf+0xec>
   1f414:	113fff44 	addi	r4,r2,-3
   1f418:	20002e16 	blt	r4,zero,1f4d4 <__floatunsidf+0xf8>
   1f41c:	8108983a 	sll	r4,r16,r4
   1f420:	0021883a 	mov	r16,zero
   1f424:	014007c4 	movi	r5,31
   1f428:	2885c83a 	sub	r2,r5,r2
   1f42c:	dc000315 	stw	r16,12(sp)
   1f430:	d9000415 	stw	r4,16(sp)
   1f434:	d8800215 	stw	r2,8(sp)
   1f438:	d809883a 	mov	r4,sp
   1f43c:	001f7340 	call	1f734 <__pack_d>
   1f440:	dfc00617 	ldw	ra,24(sp)
   1f444:	dc000517 	ldw	r16,20(sp)
   1f448:	dec00704 	addi	sp,sp,28
   1f44c:	f800283a 	ret
   1f450:	00800084 	movi	r2,2
   1f454:	d809883a 	mov	r4,sp
   1f458:	d8800015 	stw	r2,0(sp)
   1f45c:	001f7340 	call	1f734 <__pack_d>
   1f460:	dfc00617 	ldw	ra,24(sp)
   1f464:	dc000517 	ldw	r16,20(sp)
   1f468:	dec00704 	addi	sp,sp,28
   1f46c:	f800283a 	ret
   1f470:	00c7c83a 	sub	r3,zero,r3
   1f474:	193ff804 	addi	r4,r3,-32
   1f478:	20001c16 	blt	r4,zero,1f4ec <__floatunsidf+0x110>
   1f47c:	000b883a 	mov	r5,zero
   1f480:	2009d7fa 	srai	r4,r4,31
   1f484:	80c6d83a 	srl	r3,r16,r3
   1f488:	297fffc4 	addi	r5,r5,-1
   1f48c:	2c20703a 	and	r16,r5,r16
   1f490:	8020c03a 	cmpne	r16,r16,zero
   1f494:	1906703a 	and	r3,r3,r4
   1f498:	010007c4 	movi	r4,31
   1f49c:	80c6b03a 	or	r3,r16,r3
   1f4a0:	2085c83a 	sub	r2,r4,r2
   1f4a4:	d809883a 	mov	r4,sp
   1f4a8:	d8c00315 	stw	r3,12(sp)
   1f4ac:	d8000415 	stw	zero,16(sp)
   1f4b0:	d8800215 	stw	r2,8(sp)
   1f4b4:	001f7340 	call	1f734 <__pack_d>
   1f4b8:	dfc00617 	ldw	ra,24(sp)
   1f4bc:	dc000517 	ldw	r16,20(sp)
   1f4c0:	dec00704 	addi	sp,sp,28
   1f4c4:	f800283a 	ret
   1f4c8:	dc000315 	stw	r16,12(sp)
   1f4cc:	d8000415 	stw	zero,16(sp)
   1f4d0:	003fd906 	br	1f438 <__floatunsidf+0x5c>
   1f4d4:	800ad07a 	srli	r5,r16,1
   1f4d8:	010007c4 	movi	r4,31
   1f4dc:	20c9c83a 	sub	r4,r4,r3
   1f4e0:	2908d83a 	srl	r4,r5,r4
   1f4e4:	80e0983a 	sll	r16,r16,r3
   1f4e8:	003fce06 	br	1f424 <__floatunsidf+0x48>
   1f4ec:	01400044 	movi	r5,1
   1f4f0:	28ca983a 	sll	r5,r5,r3
   1f4f4:	003fe206 	br	1f480 <__floatunsidf+0xa4>

0001f4f8 <udivmodsi4>:
   1f4f8:	2005883a 	mov	r2,r4
   1f4fc:	2900182e 	bgeu	r5,r4,1f560 <udivmodsi4+0x68>
   1f500:	28001716 	blt	r5,zero,1f560 <udivmodsi4+0x68>
   1f504:	01000804 	movi	r4,32
   1f508:	00c00044 	movi	r3,1
   1f50c:	00000206 	br	1f518 <udivmodsi4+0x20>
   1f510:	20001126 	beq	r4,zero,1f558 <udivmodsi4+0x60>
   1f514:	28000516 	blt	r5,zero,1f52c <udivmodsi4+0x34>
   1f518:	294b883a 	add	r5,r5,r5
   1f51c:	213fffc4 	addi	r4,r4,-1
   1f520:	18c7883a 	add	r3,r3,r3
   1f524:	28bffa36 	bltu	r5,r2,1f510 <udivmodsi4+0x18>
   1f528:	18000b26 	beq	r3,zero,1f558 <udivmodsi4+0x60>
   1f52c:	0009883a 	mov	r4,zero
   1f530:	11400236 	bltu	r2,r5,1f53c <udivmodsi4+0x44>
   1f534:	1145c83a 	sub	r2,r2,r5
   1f538:	20c8b03a 	or	r4,r4,r3
   1f53c:	1806d07a 	srli	r3,r3,1
   1f540:	280ad07a 	srli	r5,r5,1
   1f544:	183ffa1e 	bne	r3,zero,1f530 <udivmodsi4+0x38>
   1f548:	3000021e 	bne	r6,zero,1f554 <udivmodsi4+0x5c>
   1f54c:	2005883a 	mov	r2,r4
   1f550:	f800283a 	ret
   1f554:	f800283a 	ret
   1f558:	0009883a 	mov	r4,zero
   1f55c:	003ffa06 	br	1f548 <udivmodsi4+0x50>
   1f560:	00c00044 	movi	r3,1
   1f564:	0009883a 	mov	r4,zero
   1f568:	003ff106 	br	1f530 <udivmodsi4+0x38>

0001f56c <__divsi3>:
   1f56c:	defffe04 	addi	sp,sp,-8
   1f570:	dfc00115 	stw	ra,4(sp)
   1f574:	dc000015 	stw	r16,0(sp)
   1f578:	20000a16 	blt	r4,zero,1f5a4 <__divsi3+0x38>
   1f57c:	0021883a 	mov	r16,zero
   1f580:	28000b16 	blt	r5,zero,1f5b0 <__divsi3+0x44>
   1f584:	000d883a 	mov	r6,zero
   1f588:	001f4f80 	call	1f4f8 <udivmodsi4>
   1f58c:	80000126 	beq	r16,zero,1f594 <__divsi3+0x28>
   1f590:	0085c83a 	sub	r2,zero,r2
   1f594:	dfc00117 	ldw	ra,4(sp)
   1f598:	dc000017 	ldw	r16,0(sp)
   1f59c:	dec00204 	addi	sp,sp,8
   1f5a0:	f800283a 	ret
   1f5a4:	0109c83a 	sub	r4,zero,r4
   1f5a8:	04000044 	movi	r16,1
   1f5ac:	283ff50e 	bge	r5,zero,1f584 <__divsi3+0x18>
   1f5b0:	014bc83a 	sub	r5,zero,r5
   1f5b4:	8400005c 	xori	r16,r16,1
   1f5b8:	003ff206 	br	1f584 <__divsi3+0x18>

0001f5bc <__modsi3>:
   1f5bc:	deffff04 	addi	sp,sp,-4
   1f5c0:	dfc00015 	stw	ra,0(sp)
   1f5c4:	20000516 	blt	r4,zero,1f5dc <__modsi3+0x20>
   1f5c8:	28000c16 	blt	r5,zero,1f5fc <__modsi3+0x40>
   1f5cc:	01800044 	movi	r6,1
   1f5d0:	dfc00017 	ldw	ra,0(sp)
   1f5d4:	dec00104 	addi	sp,sp,4
   1f5d8:	001f4f81 	jmpi	1f4f8 <udivmodsi4>
   1f5dc:	0109c83a 	sub	r4,zero,r4
   1f5e0:	28000b16 	blt	r5,zero,1f610 <__modsi3+0x54>
   1f5e4:	01800044 	movi	r6,1
   1f5e8:	001f4f80 	call	1f4f8 <udivmodsi4>
   1f5ec:	0085c83a 	sub	r2,zero,r2
   1f5f0:	dfc00017 	ldw	ra,0(sp)
   1f5f4:	dec00104 	addi	sp,sp,4
   1f5f8:	f800283a 	ret
   1f5fc:	014bc83a 	sub	r5,zero,r5
   1f600:	01800044 	movi	r6,1
   1f604:	dfc00017 	ldw	ra,0(sp)
   1f608:	dec00104 	addi	sp,sp,4
   1f60c:	001f4f81 	jmpi	1f4f8 <udivmodsi4>
   1f610:	014bc83a 	sub	r5,zero,r5
   1f614:	003ff306 	br	1f5e4 <__modsi3+0x28>

0001f618 <__udivsi3>:
   1f618:	000d883a 	mov	r6,zero
   1f61c:	001f4f81 	jmpi	1f4f8 <udivmodsi4>

0001f620 <__umodsi3>:
   1f620:	01800044 	movi	r6,1
   1f624:	001f4f81 	jmpi	1f4f8 <udivmodsi4>

0001f628 <__muldi3>:
   1f628:	20bfffcc 	andi	r2,r4,65535
   1f62c:	2010d43a 	srli	r8,r4,16
   1f630:	30ffffcc 	andi	r3,r6,65535
   1f634:	3014d43a 	srli	r10,r6,16
   1f638:	1893383a 	mul	r9,r3,r2
   1f63c:	1a07383a 	mul	r3,r3,r8
   1f640:	5085383a 	mul	r2,r10,r2
   1f644:	4816d43a 	srli	r11,r9,16
   1f648:	5211383a 	mul	r8,r10,r8
   1f64c:	1885883a 	add	r2,r3,r2
   1f650:	12c5883a 	add	r2,r2,r11
   1f654:	10c0022e 	bgeu	r2,r3,1f660 <__muldi3+0x38>
   1f658:	00c00074 	movhi	r3,1
   1f65c:	40d1883a 	add	r8,r8,r3
   1f660:	1014d43a 	srli	r10,r2,16
   1f664:	21c9383a 	mul	r4,r4,r7
   1f668:	314d383a 	mul	r6,r6,r5
   1f66c:	1004943a 	slli	r2,r2,16
   1f670:	4291883a 	add	r8,r8,r10
   1f674:	4a7fffcc 	andi	r9,r9,65535
   1f678:	2187883a 	add	r3,r4,r6
   1f67c:	1245883a 	add	r2,r2,r9
   1f680:	1a07883a 	add	r3,r3,r8
   1f684:	f800283a 	ret

0001f688 <__clzsi2>:
   1f688:	00bfffd4 	movui	r2,65535
   1f68c:	11000b36 	bltu	r2,r4,1f6bc <__clzsi2+0x34>
   1f690:	00803fc4 	movi	r2,255
   1f694:	11001e2e 	bgeu	r2,r4,1f710 <__clzsi2+0x88>
   1f698:	00c00204 	movi	r3,8
   1f69c:	20c8d83a 	srl	r4,r4,r3
   1f6a0:	00c000f4 	movhi	r3,3
   1f6a4:	18fc8604 	addi	r3,r3,-3560
   1f6a8:	00800604 	movi	r2,24
   1f6ac:	1909883a 	add	r4,r3,r4
   1f6b0:	20c00003 	ldbu	r3,0(r4)
   1f6b4:	10c5c83a 	sub	r2,r2,r3
   1f6b8:	f800283a 	ret
   1f6bc:	00804034 	movhi	r2,256
   1f6c0:	10bfffc4 	addi	r2,r2,-1
   1f6c4:	11000936 	bltu	r2,r4,1f6ec <__clzsi2+0x64>
   1f6c8:	00800404 	movi	r2,16
   1f6cc:	1007883a 	mov	r3,r2
   1f6d0:	20c8d83a 	srl	r4,r4,r3
   1f6d4:	00c000f4 	movhi	r3,3
   1f6d8:	18fc8604 	addi	r3,r3,-3560
   1f6dc:	1909883a 	add	r4,r3,r4
   1f6e0:	20c00003 	ldbu	r3,0(r4)
   1f6e4:	10c5c83a 	sub	r2,r2,r3
   1f6e8:	f800283a 	ret
   1f6ec:	00c00604 	movi	r3,24
   1f6f0:	20c8d83a 	srl	r4,r4,r3
   1f6f4:	00c000f4 	movhi	r3,3
   1f6f8:	18fc8604 	addi	r3,r3,-3560
   1f6fc:	00800204 	movi	r2,8
   1f700:	1909883a 	add	r4,r3,r4
   1f704:	20c00003 	ldbu	r3,0(r4)
   1f708:	10c5c83a 	sub	r2,r2,r3
   1f70c:	f800283a 	ret
   1f710:	0007883a 	mov	r3,zero
   1f714:	20c8d83a 	srl	r4,r4,r3
   1f718:	00c000f4 	movhi	r3,3
   1f71c:	18fc8604 	addi	r3,r3,-3560
   1f720:	00800804 	movi	r2,32
   1f724:	1909883a 	add	r4,r3,r4
   1f728:	20c00003 	ldbu	r3,0(r4)
   1f72c:	10c5c83a 	sub	r2,r2,r3
   1f730:	f800283a 	ret

0001f734 <__pack_d>:
   1f734:	20800017 	ldw	r2,0(r4)
   1f738:	defff804 	addi	sp,sp,-32
   1f73c:	dcc00315 	stw	r19,12(sp)
   1f740:	dc800215 	stw	r18,8(sp)
   1f744:	dfc00715 	stw	ra,28(sp)
   1f748:	dd800615 	stw	r22,24(sp)
   1f74c:	dd400515 	stw	r21,20(sp)
   1f750:	dd000415 	stw	r20,16(sp)
   1f754:	dc400115 	stw	r17,4(sp)
   1f758:	dc000015 	stw	r16,0(sp)
   1f75c:	04800044 	movi	r18,1
   1f760:	24400317 	ldw	r17,12(r4)
   1f764:	24000417 	ldw	r16,16(r4)
   1f768:	24c00117 	ldw	r19,4(r4)
   1f76c:	9080422e 	bgeu	r18,r2,1f878 <__pack_d+0x144>
   1f770:	00c00104 	movi	r3,4
   1f774:	10c03c26 	beq	r2,r3,1f868 <__pack_d+0x134>
   1f778:	00c00084 	movi	r3,2
   1f77c:	10c01926 	beq	r2,r3,1f7e4 <__pack_d+0xb0>
   1f780:	8c04b03a 	or	r2,r17,r16
   1f784:	10001726 	beq	r2,zero,1f7e4 <__pack_d+0xb0>
   1f788:	21000217 	ldw	r4,8(r4)
   1f78c:	00bf0084 	movi	r2,-1022
   1f790:	20804016 	blt	r4,r2,1f894 <__pack_d+0x160>
   1f794:	0080ffc4 	movi	r2,1023
   1f798:	11003316 	blt	r2,r4,1f868 <__pack_d+0x134>
   1f79c:	88803fcc 	andi	r2,r17,255
   1f7a0:	00c02004 	movi	r3,128
   1f7a4:	10c02926 	beq	r2,r3,1f84c <__pack_d+0x118>
   1f7a8:	88801fc4 	addi	r2,r17,127
   1f7ac:	1463803a 	cmpltu	r17,r2,r17
   1f7b0:	8c21883a 	add	r16,r17,r16
   1f7b4:	1023883a 	mov	r17,r2
   1f7b8:	00880034 	movhi	r2,8192
   1f7bc:	10bfffc4 	addi	r2,r2,-1
   1f7c0:	14001c36 	bltu	r2,r16,1f834 <__pack_d+0x100>
   1f7c4:	2100ffc4 	addi	r4,r4,1023
   1f7c8:	8006963a 	slli	r3,r16,24
   1f7cc:	8804d23a 	srli	r2,r17,8
   1f7d0:	8020913a 	slli	r16,r16,4
   1f7d4:	2101ffcc 	andi	r4,r4,2047
   1f7d8:	1884b03a 	or	r2,r3,r2
   1f7dc:	8020d33a 	srli	r16,r16,12
   1f7e0:	00000306 	br	1f7f0 <__pack_d+0xbc>
   1f7e4:	0009883a 	mov	r4,zero
   1f7e8:	0005883a 	mov	r2,zero
   1f7ec:	0021883a 	mov	r16,zero
   1f7f0:	2008953a 	slli	r4,r4,20
   1f7f4:	982697fa 	slli	r19,r19,31
   1f7f8:	00c00434 	movhi	r3,16
   1f7fc:	18ffffc4 	addi	r3,r3,-1
   1f800:	80e0703a 	and	r16,r16,r3
   1f804:	8106b03a 	or	r3,r16,r4
   1f808:	1cc6b03a 	or	r3,r3,r19
   1f80c:	dfc00717 	ldw	ra,28(sp)
   1f810:	dd800617 	ldw	r22,24(sp)
   1f814:	dd400517 	ldw	r21,20(sp)
   1f818:	dd000417 	ldw	r20,16(sp)
   1f81c:	dcc00317 	ldw	r19,12(sp)
   1f820:	dc800217 	ldw	r18,8(sp)
   1f824:	dc400117 	ldw	r17,4(sp)
   1f828:	dc000017 	ldw	r16,0(sp)
   1f82c:	dec00804 	addi	sp,sp,32
   1f830:	f800283a 	ret
   1f834:	800697fa 	slli	r3,r16,31
   1f838:	8804d07a 	srli	r2,r17,1
   1f83c:	21010004 	addi	r4,r4,1024
   1f840:	8020d07a 	srli	r16,r16,1
   1f844:	18a2b03a 	or	r17,r3,r2
   1f848:	003fdf06 	br	1f7c8 <__pack_d+0x94>
   1f84c:	88c0400c 	andi	r3,r17,256
   1f850:	183fd926 	beq	r3,zero,1f7b8 <__pack_d+0x84>
   1f854:	8885883a 	add	r2,r17,r2
   1f858:	1463803a 	cmpltu	r17,r2,r17
   1f85c:	8c21883a 	add	r16,r17,r16
   1f860:	1023883a 	mov	r17,r2
   1f864:	003fd406 	br	1f7b8 <__pack_d+0x84>
   1f868:	0101ffc4 	movi	r4,2047
   1f86c:	0005883a 	mov	r2,zero
   1f870:	0021883a 	mov	r16,zero
   1f874:	003fde06 	br	1f7f0 <__pack_d+0xbc>
   1f878:	84000234 	orhi	r16,r16,8
   1f87c:	00c00434 	movhi	r3,16
   1f880:	18ffffc4 	addi	r3,r3,-1
   1f884:	8805883a 	mov	r2,r17
   1f888:	80e0703a 	and	r16,r16,r3
   1f88c:	0101ffc4 	movi	r4,2047
   1f890:	003fd706 	br	1f7f0 <__pack_d+0xbc>
   1f894:	1129c83a 	sub	r20,r2,r4
   1f898:	00800e04 	movi	r2,56
   1f89c:	15002716 	blt	r2,r20,1f93c <__pack_d+0x208>
   1f8a0:	800b883a 	mov	r5,r16
   1f8a4:	a00d883a 	mov	r6,r20
   1f8a8:	8809883a 	mov	r4,r17
   1f8ac:	001fb2c0 	call	1fb2c <__lshrdi3>
   1f8b0:	9009883a 	mov	r4,r18
   1f8b4:	000b883a 	mov	r5,zero
   1f8b8:	a00d883a 	mov	r6,r20
   1f8bc:	102d883a 	mov	r22,r2
   1f8c0:	182b883a 	mov	r21,r3
   1f8c4:	001fb700 	call	1fb70 <__ashldi3>
   1f8c8:	1009003a 	cmpeq	r4,r2,zero
   1f8cc:	1907c83a 	sub	r3,r3,r4
   1f8d0:	10bfffc4 	addi	r2,r2,-1
   1f8d4:	1c20703a 	and	r16,r3,r16
   1f8d8:	1444703a 	and	r2,r2,r17
   1f8dc:	1404b03a 	or	r2,r2,r16
   1f8e0:	1004c03a 	cmpne	r2,r2,zero
   1f8e4:	1584b03a 	or	r2,r2,r22
   1f8e8:	11003fcc 	andi	r4,r2,255
   1f8ec:	01402004 	movi	r5,128
   1f8f0:	a807883a 	mov	r3,r21
   1f8f4:	2140131e 	bne	r4,r5,1f944 <__pack_d+0x210>
   1f8f8:	1140400c 	andi	r5,r2,256
   1f8fc:	28000426 	beq	r5,zero,1f910 <__pack_d+0x1dc>
   1f900:	1109883a 	add	r4,r2,r4
   1f904:	2085803a 	cmpltu	r2,r4,r2
   1f908:	1547883a 	add	r3,r2,r21
   1f90c:	2005883a 	mov	r2,r4
   1f910:	1808963a 	slli	r4,r3,24
   1f914:	1004d23a 	srli	r2,r2,8
   1f918:	1820913a 	slli	r16,r3,4
   1f91c:	01440034 	movhi	r5,4096
   1f920:	297fffc4 	addi	r5,r5,-1
   1f924:	2084b03a 	or	r2,r4,r2
   1f928:	8020d33a 	srli	r16,r16,12
   1f92c:	01000044 	movi	r4,1
   1f930:	28ffaf36 	bltu	r5,r3,1f7f0 <__pack_d+0xbc>
   1f934:	0009883a 	mov	r4,zero
   1f938:	003fad06 	br	1f7f0 <__pack_d+0xbc>
   1f93c:	0005883a 	mov	r2,zero
   1f940:	0007883a 	mov	r3,zero
   1f944:	11001fc4 	addi	r4,r2,127
   1f948:	2085803a 	cmpltu	r2,r4,r2
   1f94c:	10c7883a 	add	r3,r2,r3
   1f950:	2005883a 	mov	r2,r4
   1f954:	003fee06 	br	1f910 <__pack_d+0x1dc>

0001f958 <__unpack_d>:
   1f958:	21800117 	ldw	r6,4(r4)
   1f95c:	20c00017 	ldw	r3,0(r4)
   1f960:	3004d7fa 	srli	r2,r6,31
   1f964:	3008d53a 	srli	r4,r6,20
   1f968:	28800115 	stw	r2,4(r5)
   1f96c:	2101ffcc 	andi	r4,r4,2047
   1f970:	00800434 	movhi	r2,16
   1f974:	10bfffc4 	addi	r2,r2,-1
   1f978:	3084703a 	and	r2,r6,r2
   1f97c:	20001a1e 	bne	r4,zero,1f9e8 <__unpack_d+0x90>
   1f980:	1888b03a 	or	r4,r3,r2
   1f984:	20002626 	beq	r4,zero,1fa20 <__unpack_d+0xc8>
   1f988:	1808d63a 	srli	r4,r3,24
   1f98c:	1004923a 	slli	r2,r2,8
   1f990:	01bf0084 	movi	r6,-1022
   1f994:	29800215 	stw	r6,8(r5)
   1f998:	2084b03a 	or	r2,r4,r2
   1f99c:	010000c4 	movi	r4,3
   1f9a0:	29000015 	stw	r4,0(r5)
   1f9a4:	02040034 	movhi	r8,4096
   1f9a8:	423fffc4 	addi	r8,r8,-1
   1f9ac:	1806923a 	slli	r3,r3,8
   1f9b0:	40801836 	bltu	r8,r2,1fa14 <__unpack_d+0xbc>
   1f9b4:	013f0044 	movi	r4,-1023
   1f9b8:	18cd883a 	add	r6,r3,r3
   1f9bc:	30c7803a 	cmpltu	r3,r6,r3
   1f9c0:	1085883a 	add	r2,r2,r2
   1f9c4:	1885883a 	add	r2,r3,r2
   1f9c8:	200f883a 	mov	r7,r4
   1f9cc:	3007883a 	mov	r3,r6
   1f9d0:	213fffc4 	addi	r4,r4,-1
   1f9d4:	40bff82e 	bgeu	r8,r2,1f9b8 <__unpack_d+0x60>
   1f9d8:	29c00215 	stw	r7,8(r5)
   1f9dc:	28c00315 	stw	r3,12(r5)
   1f9e0:	28800415 	stw	r2,16(r5)
   1f9e4:	f800283a 	ret
   1f9e8:	01c1ffc4 	movi	r7,2047
   1f9ec:	21c00f26 	beq	r4,r7,1fa2c <__unpack_d+0xd4>
   1f9f0:	180cd63a 	srli	r6,r3,24
   1f9f4:	1004923a 	slli	r2,r2,8
   1f9f8:	213f0044 	addi	r4,r4,-1023
   1f9fc:	1806923a 	slli	r3,r3,8
   1fa00:	3084b03a 	or	r2,r6,r2
   1fa04:	29000215 	stw	r4,8(r5)
   1fa08:	010000c4 	movi	r4,3
   1fa0c:	10840034 	orhi	r2,r2,4096
   1fa10:	29000015 	stw	r4,0(r5)
   1fa14:	28c00315 	stw	r3,12(r5)
   1fa18:	28800415 	stw	r2,16(r5)
   1fa1c:	f800283a 	ret
   1fa20:	00800084 	movi	r2,2
   1fa24:	28800015 	stw	r2,0(r5)
   1fa28:	f800283a 	ret
   1fa2c:	1888b03a 	or	r4,r3,r2
   1fa30:	20000526 	beq	r4,zero,1fa48 <__unpack_d+0xf0>
   1fa34:	3180022c 	andhi	r6,r6,8
   1fa38:	30000626 	beq	r6,zero,1fa54 <__unpack_d+0xfc>
   1fa3c:	01000044 	movi	r4,1
   1fa40:	29000015 	stw	r4,0(r5)
   1fa44:	003ff306 	br	1fa14 <__unpack_d+0xbc>
   1fa48:	00800104 	movi	r2,4
   1fa4c:	28800015 	stw	r2,0(r5)
   1fa50:	f800283a 	ret
   1fa54:	28000015 	stw	zero,0(r5)
   1fa58:	003fee06 	br	1fa14 <__unpack_d+0xbc>

0001fa5c <__fpcmp_parts_d>:
   1fa5c:	20c00017 	ldw	r3,0(r4)
   1fa60:	00800044 	movi	r2,1
   1fa64:	10c0142e 	bgeu	r2,r3,1fab8 <__fpcmp_parts_d+0x5c>
   1fa68:	29800017 	ldw	r6,0(r5)
   1fa6c:	1180122e 	bgeu	r2,r6,1fab8 <__fpcmp_parts_d+0x5c>
   1fa70:	01c00104 	movi	r7,4
   1fa74:	19c02826 	beq	r3,r7,1fb18 <__fpcmp_parts_d+0xbc>
   1fa78:	31c00926 	beq	r6,r7,1faa0 <__fpcmp_parts_d+0x44>
   1fa7c:	01c00084 	movi	r7,2
   1fa80:	19c00626 	beq	r3,r7,1fa9c <__fpcmp_parts_d+0x40>
   1fa84:	31c00a26 	beq	r6,r7,1fab0 <__fpcmp_parts_d+0x54>
   1fa88:	20c00117 	ldw	r3,4(r4)
   1fa8c:	29800117 	ldw	r6,4(r5)
   1fa90:	19800b26 	beq	r3,r6,1fac0 <__fpcmp_parts_d+0x64>
   1fa94:	1800041e 	bne	r3,zero,1faa8 <__fpcmp_parts_d+0x4c>
   1fa98:	f800283a 	ret
   1fa9c:	30c01a26 	beq	r6,r3,1fb08 <__fpcmp_parts_d+0xac>
   1faa0:	28800117 	ldw	r2,4(r5)
   1faa4:	1000041e 	bne	r2,zero,1fab8 <__fpcmp_parts_d+0x5c>
   1faa8:	00bfffc4 	movi	r2,-1
   1faac:	f800283a 	ret
   1fab0:	20800117 	ldw	r2,4(r4)
   1fab4:	103ffc1e 	bne	r2,zero,1faa8 <__fpcmp_parts_d+0x4c>
   1fab8:	00800044 	movi	r2,1
   1fabc:	f800283a 	ret
   1fac0:	21c00217 	ldw	r7,8(r4)
   1fac4:	29800217 	ldw	r6,8(r5)
   1fac8:	31c0020e 	bge	r6,r7,1fad4 <__fpcmp_parts_d+0x78>
   1facc:	183ff61e 	bne	r3,zero,1faa8 <__fpcmp_parts_d+0x4c>
   1fad0:	f800283a 	ret
   1fad4:	39800a16 	blt	r7,r6,1fb00 <__fpcmp_parts_d+0xa4>
   1fad8:	20800417 	ldw	r2,16(r4)
   1fadc:	29800417 	ldw	r6,16(r5)
   1fae0:	21c00317 	ldw	r7,12(r4)
   1fae4:	29000317 	ldw	r4,12(r5)
   1fae8:	30800936 	bltu	r6,r2,1fb10 <__fpcmp_parts_d+0xb4>
   1faec:	1180011e 	bne	r2,r6,1faf4 <__fpcmp_parts_d+0x98>
   1faf0:	21c00736 	bltu	r4,r7,1fb10 <__fpcmp_parts_d+0xb4>
   1faf4:	11800236 	bltu	r2,r6,1fb00 <__fpcmp_parts_d+0xa4>
   1faf8:	3080031e 	bne	r6,r2,1fb08 <__fpcmp_parts_d+0xac>
   1fafc:	3900022e 	bgeu	r7,r4,1fb08 <__fpcmp_parts_d+0xac>
   1fb00:	183fe926 	beq	r3,zero,1faa8 <__fpcmp_parts_d+0x4c>
   1fb04:	003fec06 	br	1fab8 <__fpcmp_parts_d+0x5c>
   1fb08:	0005883a 	mov	r2,zero
   1fb0c:	f800283a 	ret
   1fb10:	183fe926 	beq	r3,zero,1fab8 <__fpcmp_parts_d+0x5c>
   1fb14:	003fe406 	br	1faa8 <__fpcmp_parts_d+0x4c>
   1fb18:	30ffe51e 	bne	r6,r3,1fab0 <__fpcmp_parts_d+0x54>
   1fb1c:	28c00117 	ldw	r3,4(r5)
   1fb20:	20800117 	ldw	r2,4(r4)
   1fb24:	1885c83a 	sub	r2,r3,r2
   1fb28:	f800283a 	ret

0001fb2c <__lshrdi3>:
   1fb2c:	2005883a 	mov	r2,r4
   1fb30:	2807883a 	mov	r3,r5
   1fb34:	30000826 	beq	r6,zero,1fb58 <__lshrdi3+0x2c>
   1fb38:	01000804 	movi	r4,32
   1fb3c:	2189c83a 	sub	r4,r4,r6
   1fb40:	0100060e 	bge	zero,r4,1fb5c <__lshrdi3+0x30>
   1fb44:	1184d83a 	srl	r2,r2,r6
   1fb48:	2908983a 	sll	r4,r5,r4
   1fb4c:	298cd83a 	srl	r6,r5,r6
   1fb50:	2084b03a 	or	r2,r4,r2
   1fb54:	3007883a 	mov	r3,r6
   1fb58:	f800283a 	ret
   1fb5c:	0105c83a 	sub	r2,zero,r4
   1fb60:	000d883a 	mov	r6,zero
   1fb64:	2884d83a 	srl	r2,r5,r2
   1fb68:	3007883a 	mov	r3,r6
   1fb6c:	003ffa06 	br	1fb58 <__lshrdi3+0x2c>

0001fb70 <__ashldi3>:
   1fb70:	2005883a 	mov	r2,r4
   1fb74:	2807883a 	mov	r3,r5
   1fb78:	30000826 	beq	r6,zero,1fb9c <__ashldi3+0x2c>
   1fb7c:	01000804 	movi	r4,32
   1fb80:	2189c83a 	sub	r4,r4,r6
   1fb84:	0100060e 	bge	zero,r4,1fba0 <__ashldi3+0x30>
   1fb88:	1108d83a 	srl	r4,r2,r4
   1fb8c:	2986983a 	sll	r3,r5,r6
   1fb90:	118c983a 	sll	r6,r2,r6
   1fb94:	20c6b03a 	or	r3,r4,r3
   1fb98:	3005883a 	mov	r2,r6
   1fb9c:	f800283a 	ret
   1fba0:	0107c83a 	sub	r3,zero,r4
   1fba4:	000d883a 	mov	r6,zero
   1fba8:	10c6983a 	sll	r3,r2,r3
   1fbac:	3005883a 	mov	r2,r6
   1fbb0:	003ffa06 	br	1fb9c <__ashldi3+0x2c>

0001fbb4 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
   1fbb4:	defff404 	addi	sp,sp,-48
   1fbb8:	df000b15 	stw	fp,44(sp)
   1fbbc:	df000b04 	addi	fp,sp,44
   1fbc0:	e13ffc15 	stw	r4,-16(fp)
   1fbc4:	e17ffd15 	stw	r5,-12(fp)
   1fbc8:	e1bffe15 	stw	r6,-8(fp)
   1fbcc:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
   1fbd0:	e03ff515 	stw	zero,-44(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
   1fbd4:	008000f4 	movhi	r2,3
   1fbd8:	10961504 	addi	r2,r2,22612
   1fbdc:	10800017 	ldw	r2,0(r2)
  
  if (alt_ticks_per_second ())
   1fbe0:	10004a26 	beq	r2,zero,1fd0c <alt_alarm_start+0x158>
  {
    if (alarm)
   1fbe4:	e0bffc17 	ldw	r2,-16(fp)
   1fbe8:	10004626 	beq	r2,zero,1fd04 <alt_alarm_start+0x150>
    {
      alarm->callback = callback;
   1fbec:	e0bffc17 	ldw	r2,-16(fp)
   1fbf0:	e0fffe17 	ldw	r3,-8(fp)
   1fbf4:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
   1fbf8:	e0bffc17 	ldw	r2,-16(fp)
   1fbfc:	e0ffff17 	ldw	r3,-4(fp)
   1fc00:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   1fc04:	0005303a 	rdctl	r2,status
   1fc08:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   1fc0c:	e0fff717 	ldw	r3,-36(fp)
   1fc10:	00bfff84 	movi	r2,-2
   1fc14:	1884703a 	and	r2,r3,r2
   1fc18:	1001703a 	wrctl	status,r2
  
  return context;
   1fc1c:	e0bff717 	ldw	r2,-36(fp)
 
      irq_context = alt_irq_disable_all ();
   1fc20:	e0bff615 	stw	r2,-40(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
   1fc24:	008000f4 	movhi	r2,3
   1fc28:	10961604 	addi	r2,r2,22616
   1fc2c:	10800017 	ldw	r2,0(r2)
      
      current_nticks = alt_nticks();
   1fc30:	e0bff515 	stw	r2,-44(fp)
      
      alarm->time = nticks + current_nticks + 1; 
   1fc34:	e0fffd17 	ldw	r3,-12(fp)
   1fc38:	e0bff517 	ldw	r2,-44(fp)
   1fc3c:	1885883a 	add	r2,r3,r2
   1fc40:	10c00044 	addi	r3,r2,1
   1fc44:	e0bffc17 	ldw	r2,-16(fp)
   1fc48:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
   1fc4c:	e0bffc17 	ldw	r2,-16(fp)
   1fc50:	10c00217 	ldw	r3,8(r2)
   1fc54:	e0bff517 	ldw	r2,-44(fp)
   1fc58:	1880042e 	bgeu	r3,r2,1fc6c <alt_alarm_start+0xb8>
      {
        alarm->rollover = 1;
   1fc5c:	e0bffc17 	ldw	r2,-16(fp)
   1fc60:	00c00044 	movi	r3,1
   1fc64:	10c00405 	stb	r3,16(r2)
   1fc68:	00000206 	br	1fc74 <alt_alarm_start+0xc0>
      }
      else
      {
        alarm->rollover = 0;
   1fc6c:	e0bffc17 	ldw	r2,-16(fp)
   1fc70:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
   1fc74:	e0bffc17 	ldw	r2,-16(fp)
   1fc78:	00c000f4 	movhi	r3,3
   1fc7c:	18cd3604 	addi	r3,r3,13528
   1fc80:	e0fff815 	stw	r3,-32(fp)
   1fc84:	e0bff915 	stw	r2,-28(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
   1fc88:	e0bff917 	ldw	r2,-28(fp)
   1fc8c:	e0fff817 	ldw	r3,-32(fp)
   1fc90:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
   1fc94:	e0bff817 	ldw	r2,-32(fp)
   1fc98:	10c00017 	ldw	r3,0(r2)
   1fc9c:	e0bff917 	ldw	r2,-28(fp)
   1fca0:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
   1fca4:	e0bff817 	ldw	r2,-32(fp)
   1fca8:	10800017 	ldw	r2,0(r2)
   1fcac:	e0fff917 	ldw	r3,-28(fp)
   1fcb0:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
   1fcb4:	e0bff817 	ldw	r2,-32(fp)
   1fcb8:	e0fff917 	ldw	r3,-28(fp)
   1fcbc:	10c00015 	stw	r3,0(r2)
   1fcc0:	e0bff617 	ldw	r2,-40(fp)
   1fcc4:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   1fcc8:	0005303a 	rdctl	r2,status
   1fccc:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   1fcd0:	e0fffb17 	ldw	r3,-20(fp)
   1fcd4:	00bfff84 	movi	r2,-2
   1fcd8:	1884703a 	and	r2,r3,r2
   1fcdc:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   1fce0:	e0bffa17 	ldw	r2,-24(fp)
   1fce4:	1080004c 	andi	r2,r2,1
   1fce8:	e0fffb17 	ldw	r3,-20(fp)
   1fcec:	1884b03a 	or	r2,r3,r2
   1fcf0:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
   1fcf4:	e0bffb17 	ldw	r2,-20(fp)
   1fcf8:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
   1fcfc:	0005883a 	mov	r2,zero
   1fd00:	00000306 	br	1fd10 <alt_alarm_start+0x15c>
    }
    else
    {
      return -EINVAL;
   1fd04:	00bffa84 	movi	r2,-22
   1fd08:	00000106 	br	1fd10 <alt_alarm_start+0x15c>
    }
  }
  else
  {
    return -ENOTSUP;
   1fd0c:	00bfde84 	movi	r2,-134
  }
}
   1fd10:	e037883a 	mov	sp,fp
   1fd14:	df000017 	ldw	fp,0(sp)
   1fd18:	dec00104 	addi	sp,sp,4
   1fd1c:	f800283a 	ret

0001fd20 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   1fd20:	defffe04 	addi	sp,sp,-8
   1fd24:	dfc00115 	stw	ra,4(sp)
   1fd28:	df000015 	stw	fp,0(sp)
   1fd2c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   1fd30:	008000f4 	movhi	r2,3
   1fd34:	108d3404 	addi	r2,r2,13520
   1fd38:	10800017 	ldw	r2,0(r2)
   1fd3c:	10000526 	beq	r2,zero,1fd54 <alt_get_errno+0x34>
   1fd40:	008000f4 	movhi	r2,3
   1fd44:	108d3404 	addi	r2,r2,13520
   1fd48:	10800017 	ldw	r2,0(r2)
   1fd4c:	103ee83a 	callr	r2
   1fd50:	00000206 	br	1fd5c <alt_get_errno+0x3c>
   1fd54:	008000f4 	movhi	r2,3
   1fd58:	10961104 	addi	r2,r2,22596
}
   1fd5c:	e037883a 	mov	sp,fp
   1fd60:	dfc00117 	ldw	ra,4(sp)
   1fd64:	df000017 	ldw	fp,0(sp)
   1fd68:	dec00204 	addi	sp,sp,8
   1fd6c:	f800283a 	ret

0001fd70 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
   1fd70:	defffb04 	addi	sp,sp,-20
   1fd74:	dfc00415 	stw	ra,16(sp)
   1fd78:	df000315 	stw	fp,12(sp)
   1fd7c:	df000304 	addi	fp,sp,12
   1fd80:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
   1fd84:	e0bfff17 	ldw	r2,-4(fp)
   1fd88:	10000616 	blt	r2,zero,1fda4 <close+0x34>
   1fd8c:	e0bfff17 	ldw	r2,-4(fp)
   1fd90:	10c00324 	muli	r3,r2,12
   1fd94:	008000f4 	movhi	r2,3
   1fd98:	1086c804 	addi	r2,r2,6944
   1fd9c:	1885883a 	add	r2,r3,r2
   1fda0:	00000106 	br	1fda8 <close+0x38>
   1fda4:	0005883a 	mov	r2,zero
   1fda8:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
   1fdac:	e0bffd17 	ldw	r2,-12(fp)
   1fdb0:	10001826 	beq	r2,zero,1fe14 <close+0xa4>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
   1fdb4:	e0bffd17 	ldw	r2,-12(fp)
   1fdb8:	10800017 	ldw	r2,0(r2)
   1fdbc:	10800417 	ldw	r2,16(r2)
   1fdc0:	10000626 	beq	r2,zero,1fddc <close+0x6c>
   1fdc4:	e0bffd17 	ldw	r2,-12(fp)
   1fdc8:	10800017 	ldw	r2,0(r2)
   1fdcc:	10800417 	ldw	r2,16(r2)
   1fdd0:	e13ffd17 	ldw	r4,-12(fp)
   1fdd4:	103ee83a 	callr	r2
   1fdd8:	00000106 	br	1fde0 <close+0x70>
   1fddc:	0005883a 	mov	r2,zero
   1fde0:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
   1fde4:	e13fff17 	ldw	r4,-4(fp)
   1fde8:	00204540 	call	20454 <alt_release_fd>
    if (rval < 0)
   1fdec:	e0bffe17 	ldw	r2,-8(fp)
   1fdf0:	1000060e 	bge	r2,zero,1fe0c <close+0x9c>
    {
      ALT_ERRNO = -rval;
   1fdf4:	001fd200 	call	1fd20 <alt_get_errno>
   1fdf8:	e0fffe17 	ldw	r3,-8(fp)
   1fdfc:	00c7c83a 	sub	r3,zero,r3
   1fe00:	10c00015 	stw	r3,0(r2)
      return -1;
   1fe04:	00bfffc4 	movi	r2,-1
   1fe08:	00000606 	br	1fe24 <close+0xb4>
    }
    return 0;
   1fe0c:	0005883a 	mov	r2,zero
   1fe10:	00000406 	br	1fe24 <close+0xb4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
   1fe14:	001fd200 	call	1fd20 <alt_get_errno>
   1fe18:	00c01444 	movi	r3,81
   1fe1c:	10c00015 	stw	r3,0(r2)
    return -1;
   1fe20:	00bfffc4 	movi	r2,-1
  }
}
   1fe24:	e037883a 	mov	sp,fp
   1fe28:	dfc00117 	ldw	ra,4(sp)
   1fe2c:	df000017 	ldw	fp,0(sp)
   1fe30:	dec00204 	addi	sp,sp,8
   1fe34:	f800283a 	ret

0001fe38 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
   1fe38:	defffc04 	addi	sp,sp,-16
   1fe3c:	df000315 	stw	fp,12(sp)
   1fe40:	df000304 	addi	fp,sp,12
   1fe44:	e13ffd15 	stw	r4,-12(fp)
   1fe48:	e17ffe15 	stw	r5,-8(fp)
   1fe4c:	e1bfff15 	stw	r6,-4(fp)
  return len;
   1fe50:	e0bfff17 	ldw	r2,-4(fp)
}
   1fe54:	e037883a 	mov	sp,fp
   1fe58:	df000017 	ldw	fp,0(sp)
   1fe5c:	dec00104 	addi	sp,sp,4
   1fe60:	f800283a 	ret

0001fe64 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   1fe64:	defffe04 	addi	sp,sp,-8
   1fe68:	dfc00115 	stw	ra,4(sp)
   1fe6c:	df000015 	stw	fp,0(sp)
   1fe70:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   1fe74:	008000f4 	movhi	r2,3
   1fe78:	108d3404 	addi	r2,r2,13520
   1fe7c:	10800017 	ldw	r2,0(r2)
   1fe80:	10000526 	beq	r2,zero,1fe98 <alt_get_errno+0x34>
   1fe84:	008000f4 	movhi	r2,3
   1fe88:	108d3404 	addi	r2,r2,13520
   1fe8c:	10800017 	ldw	r2,0(r2)
   1fe90:	103ee83a 	callr	r2
   1fe94:	00000206 	br	1fea0 <alt_get_errno+0x3c>
   1fe98:	008000f4 	movhi	r2,3
   1fe9c:	10961104 	addi	r2,r2,22596
}
   1fea0:	e037883a 	mov	sp,fp
   1fea4:	dfc00117 	ldw	ra,4(sp)
   1fea8:	df000017 	ldw	fp,0(sp)
   1feac:	dec00204 	addi	sp,sp,8
   1feb0:	f800283a 	ret

0001feb4 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
   1feb4:	defffb04 	addi	sp,sp,-20
   1feb8:	dfc00415 	stw	ra,16(sp)
   1febc:	df000315 	stw	fp,12(sp)
   1fec0:	df000304 	addi	fp,sp,12
   1fec4:	e13ffe15 	stw	r4,-8(fp)
   1fec8:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
   1fecc:	e0bffe17 	ldw	r2,-8(fp)
   1fed0:	10000616 	blt	r2,zero,1feec <fstat+0x38>
   1fed4:	e0bffe17 	ldw	r2,-8(fp)
   1fed8:	10c00324 	muli	r3,r2,12
   1fedc:	008000f4 	movhi	r2,3
   1fee0:	1086c804 	addi	r2,r2,6944
   1fee4:	1885883a 	add	r2,r3,r2
   1fee8:	00000106 	br	1fef0 <fstat+0x3c>
   1feec:	0005883a 	mov	r2,zero
   1fef0:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
   1fef4:	e0bffd17 	ldw	r2,-12(fp)
   1fef8:	10001026 	beq	r2,zero,1ff3c <fstat+0x88>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
   1fefc:	e0bffd17 	ldw	r2,-12(fp)
   1ff00:	10800017 	ldw	r2,0(r2)
   1ff04:	10800817 	ldw	r2,32(r2)
   1ff08:	10000726 	beq	r2,zero,1ff28 <fstat+0x74>
    {
      return fd->dev->fstat(fd, st);
   1ff0c:	e0bffd17 	ldw	r2,-12(fp)
   1ff10:	10800017 	ldw	r2,0(r2)
   1ff14:	10800817 	ldw	r2,32(r2)
   1ff18:	e13ffd17 	ldw	r4,-12(fp)
   1ff1c:	e17fff17 	ldw	r5,-4(fp)
   1ff20:	103ee83a 	callr	r2
   1ff24:	00000906 	br	1ff4c <fstat+0x98>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
   1ff28:	e0bfff17 	ldw	r2,-4(fp)
   1ff2c:	00c80004 	movi	r3,8192
   1ff30:	10c00115 	stw	r3,4(r2)
      return 0;
   1ff34:	0005883a 	mov	r2,zero
   1ff38:	00000406 	br	1ff4c <fstat+0x98>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
   1ff3c:	001fe640 	call	1fe64 <alt_get_errno>
   1ff40:	00c01444 	movi	r3,81
   1ff44:	10c00015 	stw	r3,0(r2)
    return -1;
   1ff48:	00bfffc4 	movi	r2,-1
  }
}
   1ff4c:	e037883a 	mov	sp,fp
   1ff50:	dfc00117 	ldw	ra,4(sp)
   1ff54:	df000017 	ldw	fp,0(sp)
   1ff58:	dec00204 	addi	sp,sp,8
   1ff5c:	f800283a 	ret

0001ff60 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   1ff60:	defffe04 	addi	sp,sp,-8
   1ff64:	dfc00115 	stw	ra,4(sp)
   1ff68:	df000015 	stw	fp,0(sp)
   1ff6c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   1ff70:	008000f4 	movhi	r2,3
   1ff74:	108d3404 	addi	r2,r2,13520
   1ff78:	10800017 	ldw	r2,0(r2)
   1ff7c:	10000526 	beq	r2,zero,1ff94 <alt_get_errno+0x34>
   1ff80:	008000f4 	movhi	r2,3
   1ff84:	108d3404 	addi	r2,r2,13520
   1ff88:	10800017 	ldw	r2,0(r2)
   1ff8c:	103ee83a 	callr	r2
   1ff90:	00000206 	br	1ff9c <alt_get_errno+0x3c>
   1ff94:	008000f4 	movhi	r2,3
   1ff98:	10961104 	addi	r2,r2,22596
}
   1ff9c:	e037883a 	mov	sp,fp
   1ffa0:	dfc00117 	ldw	ra,4(sp)
   1ffa4:	df000017 	ldw	fp,0(sp)
   1ffa8:	dec00204 	addi	sp,sp,8
   1ffac:	f800283a 	ret

0001ffb0 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
   1ffb0:	deffed04 	addi	sp,sp,-76
   1ffb4:	dfc01215 	stw	ra,72(sp)
   1ffb8:	df001115 	stw	fp,68(sp)
   1ffbc:	df001104 	addi	fp,sp,68
   1ffc0:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
   1ffc4:	e0bfff17 	ldw	r2,-4(fp)
   1ffc8:	10000616 	blt	r2,zero,1ffe4 <isatty+0x34>
   1ffcc:	e0bfff17 	ldw	r2,-4(fp)
   1ffd0:	10c00324 	muli	r3,r2,12
   1ffd4:	008000f4 	movhi	r2,3
   1ffd8:	1086c804 	addi	r2,r2,6944
   1ffdc:	1885883a 	add	r2,r3,r2
   1ffe0:	00000106 	br	1ffe8 <isatty+0x38>
   1ffe4:	0005883a 	mov	r2,zero
   1ffe8:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
   1ffec:	e0bfef17 	ldw	r2,-68(fp)
   1fff0:	10000e26 	beq	r2,zero,2002c <isatty+0x7c>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
   1fff4:	e0bfef17 	ldw	r2,-68(fp)
   1fff8:	10800017 	ldw	r2,0(r2)
   1fffc:	10800817 	ldw	r2,32(r2)
   20000:	1000021e 	bne	r2,zero,2000c <isatty+0x5c>
    {
      return 1;
   20004:	00800044 	movi	r2,1
   20008:	00000c06 	br	2003c <isatty+0x8c>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
   2000c:	e0bff004 	addi	r2,fp,-64
   20010:	e13fff17 	ldw	r4,-4(fp)
   20014:	100b883a 	mov	r5,r2
   20018:	001feb40 	call	1feb4 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
   2001c:	e0bff117 	ldw	r2,-60(fp)
   20020:	10880020 	cmpeqi	r2,r2,8192
   20024:	10803fcc 	andi	r2,r2,255
   20028:	00000406 	br	2003c <isatty+0x8c>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
   2002c:	001ff600 	call	1ff60 <alt_get_errno>
   20030:	00c01444 	movi	r3,81
   20034:	10c00015 	stw	r3,0(r2)
    return 0;
   20038:	0005883a 	mov	r2,zero
  }
}
   2003c:	e037883a 	mov	sp,fp
   20040:	dfc00117 	ldw	ra,4(sp)
   20044:	df000017 	ldw	fp,0(sp)
   20048:	dec00204 	addi	sp,sp,8
   2004c:	f800283a 	ret

00020050 <alt_load_section>:
   20050:	defffc04 	addi	sp,sp,-16
   20054:	df000315 	stw	fp,12(sp)
   20058:	df000304 	addi	fp,sp,12
   2005c:	e13ffd15 	stw	r4,-12(fp)
   20060:	e17ffe15 	stw	r5,-8(fp)
   20064:	e1bfff15 	stw	r6,-4(fp)
   20068:	e0fffe17 	ldw	r3,-8(fp)
   2006c:	e0bffd17 	ldw	r2,-12(fp)
   20070:	18800e26 	beq	r3,r2,200ac <alt_load_section+0x5c>
   20074:	00000a06 	br	200a0 <alt_load_section+0x50>
   20078:	e0bffd17 	ldw	r2,-12(fp)
   2007c:	10c00017 	ldw	r3,0(r2)
   20080:	e0bffe17 	ldw	r2,-8(fp)
   20084:	10c00015 	stw	r3,0(r2)
   20088:	e0bffe17 	ldw	r2,-8(fp)
   2008c:	10800104 	addi	r2,r2,4
   20090:	e0bffe15 	stw	r2,-8(fp)
   20094:	e0bffd17 	ldw	r2,-12(fp)
   20098:	10800104 	addi	r2,r2,4
   2009c:	e0bffd15 	stw	r2,-12(fp)
   200a0:	e0fffe17 	ldw	r3,-8(fp)
   200a4:	e0bfff17 	ldw	r2,-4(fp)
   200a8:	18bff31e 	bne	r3,r2,20078 <alt_load_section+0x28>
   200ac:	e037883a 	mov	sp,fp
   200b0:	df000017 	ldw	fp,0(sp)
   200b4:	dec00104 	addi	sp,sp,4
   200b8:	f800283a 	ret

000200bc <alt_load>:
   200bc:	defffe04 	addi	sp,sp,-8
   200c0:	dfc00115 	stw	ra,4(sp)
   200c4:	df000015 	stw	fp,0(sp)
   200c8:	d839883a 	mov	fp,sp
   200cc:	010000f4 	movhi	r4,3
   200d0:	210d3f04 	addi	r4,r4,13564
   200d4:	014000f4 	movhi	r5,3
   200d8:	29449604 	addi	r5,r5,4696
   200dc:	018000f4 	movhi	r6,3
   200e0:	318d3f04 	addi	r6,r6,13564
   200e4:	00200500 	call	20050 <alt_load_section>
   200e8:	01000034 	movhi	r4,0
   200ec:	21000804 	addi	r4,r4,32
   200f0:	01400034 	movhi	r5,0
   200f4:	29400804 	addi	r5,r5,32
   200f8:	01800034 	movhi	r6,0
   200fc:	31800804 	addi	r6,r6,32
   20100:	00200500 	call	20050 <alt_load_section>
   20104:	010000f4 	movhi	r4,3
   20108:	21316104 	addi	r4,r4,-14972
   2010c:	014000f4 	movhi	r5,3
   20110:	29716104 	addi	r5,r5,-14972
   20114:	018000f4 	movhi	r6,3
   20118:	31849604 	addi	r6,r6,4696
   2011c:	00200500 	call	20050 <alt_load_section>
   20120:	002af240 	call	2af24 <alt_dcache_flush_all>
   20124:	002b2300 	call	2b230 <alt_icache_flush_all>
   20128:	e037883a 	mov	sp,fp
   2012c:	dfc00117 	ldw	ra,4(sp)
   20130:	df000017 	ldw	fp,0(sp)
   20134:	dec00204 	addi	sp,sp,8
   20138:	f800283a 	ret

0002013c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   2013c:	defffe04 	addi	sp,sp,-8
   20140:	dfc00115 	stw	ra,4(sp)
   20144:	df000015 	stw	fp,0(sp)
   20148:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   2014c:	008000f4 	movhi	r2,3
   20150:	108d3404 	addi	r2,r2,13520
   20154:	10800017 	ldw	r2,0(r2)
   20158:	10000526 	beq	r2,zero,20170 <alt_get_errno+0x34>
   2015c:	008000f4 	movhi	r2,3
   20160:	108d3404 	addi	r2,r2,13520
   20164:	10800017 	ldw	r2,0(r2)
   20168:	103ee83a 	callr	r2
   2016c:	00000206 	br	20178 <alt_get_errno+0x3c>
   20170:	008000f4 	movhi	r2,3
   20174:	10961104 	addi	r2,r2,22596
}
   20178:	e037883a 	mov	sp,fp
   2017c:	dfc00117 	ldw	ra,4(sp)
   20180:	df000017 	ldw	fp,0(sp)
   20184:	dec00204 	addi	sp,sp,8
   20188:	f800283a 	ret

0002018c <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
   2018c:	defff904 	addi	sp,sp,-28
   20190:	dfc00615 	stw	ra,24(sp)
   20194:	df000515 	stw	fp,20(sp)
   20198:	df000504 	addi	fp,sp,20
   2019c:	e13ffd15 	stw	r4,-12(fp)
   201a0:	e17ffe15 	stw	r5,-8(fp)
   201a4:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
   201a8:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
   201ac:	e0bffd17 	ldw	r2,-12(fp)
   201b0:	10000616 	blt	r2,zero,201cc <lseek+0x40>
   201b4:	e0bffd17 	ldw	r2,-12(fp)
   201b8:	10c00324 	muli	r3,r2,12
   201bc:	008000f4 	movhi	r2,3
   201c0:	1086c804 	addi	r2,r2,6944
   201c4:	1885883a 	add	r2,r3,r2
   201c8:	00000106 	br	201d0 <lseek+0x44>
   201cc:	0005883a 	mov	r2,zero
   201d0:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
   201d4:	e0bffc17 	ldw	r2,-16(fp)
   201d8:	10001026 	beq	r2,zero,2021c <lseek+0x90>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
   201dc:	e0bffc17 	ldw	r2,-16(fp)
   201e0:	10800017 	ldw	r2,0(r2)
   201e4:	10800717 	ldw	r2,28(r2)
   201e8:	10000926 	beq	r2,zero,20210 <lseek+0x84>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
   201ec:	e0bffc17 	ldw	r2,-16(fp)
   201f0:	10800017 	ldw	r2,0(r2)
   201f4:	10800717 	ldw	r2,28(r2)
   201f8:	e13ffc17 	ldw	r4,-16(fp)
   201fc:	e17ffe17 	ldw	r5,-8(fp)
   20200:	e1bfff17 	ldw	r6,-4(fp)
   20204:	103ee83a 	callr	r2
   20208:	e0bffb15 	stw	r2,-20(fp)
   2020c:	00000506 	br	20224 <lseek+0x98>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
   20210:	00bfde84 	movi	r2,-134
   20214:	e0bffb15 	stw	r2,-20(fp)
   20218:	00000206 	br	20224 <lseek+0x98>
    }
  }
  else  
  {
    rc = -EBADFD;
   2021c:	00bfebc4 	movi	r2,-81
   20220:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
   20224:	e0bffb17 	ldw	r2,-20(fp)
   20228:	1000060e 	bge	r2,zero,20244 <lseek+0xb8>
  {
    ALT_ERRNO = -rc;
   2022c:	002013c0 	call	2013c <alt_get_errno>
   20230:	e0fffb17 	ldw	r3,-20(fp)
   20234:	00c7c83a 	sub	r3,zero,r3
   20238:	10c00015 	stw	r3,0(r2)
    rc = -1;
   2023c:	00bfffc4 	movi	r2,-1
   20240:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
   20244:	e0bffb17 	ldw	r2,-20(fp)
}
   20248:	e037883a 	mov	sp,fp
   2024c:	dfc00117 	ldw	ra,4(sp)
   20250:	df000017 	ldw	fp,0(sp)
   20254:	dec00204 	addi	sp,sp,8
   20258:	f800283a 	ret

0002025c <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
   2025c:	defffd04 	addi	sp,sp,-12
   20260:	dfc00215 	stw	ra,8(sp)
   20264:	df000115 	stw	fp,4(sp)
   20268:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
   2026c:	0009883a 	mov	r4,zero
   20270:	00209c00 	call	209c0 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
   20274:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
   20278:	0020a000 	call	20a00 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
   2027c:	010000f4 	movhi	r4,3
   20280:	213cc904 	addi	r4,r4,-3292
   20284:	014000f4 	movhi	r5,3
   20288:	297cc904 	addi	r5,r5,-3292
   2028c:	018000f4 	movhi	r6,3
   20290:	31bcc904 	addi	r6,r6,-3292
   20294:	002b3200 	call	2b320 <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
   20298:	002b0300 	call	2b030 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
   2029c:	010000f4 	movhi	r4,3
   202a0:	212c2304 	addi	r4,r4,-20340
   202a4:	002c0f40 	call	2c0f4 <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
   202a8:	d128f217 	ldw	r4,-23608(gp)
   202ac:	d0e8f317 	ldw	r3,-23604(gp)
   202b0:	d0a8f417 	ldw	r2,-23600(gp)
   202b4:	180b883a 	mov	r5,r3
   202b8:	100d883a 	mov	r6,r2
   202bc:	00161d80 	call	161d8 <main>
   202c0:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
   202c4:	01000044 	movi	r4,1
   202c8:	001fd700 	call	1fd70 <close>
  exit (result);
   202cc:	e13fff17 	ldw	r4,-4(fp)
   202d0:	002c1080 	call	2c108 <exit>

000202d4 <__malloc_lock>:
   202d4:	defffe04 	addi	sp,sp,-8
   202d8:	df000115 	stw	fp,4(sp)
   202dc:	df000104 	addi	fp,sp,4
   202e0:	e13fff15 	stw	r4,-4(fp)
   202e4:	e037883a 	mov	sp,fp
   202e8:	df000017 	ldw	fp,0(sp)
   202ec:	dec00104 	addi	sp,sp,4
   202f0:	f800283a 	ret

000202f4 <__malloc_unlock>:
   202f4:	defffe04 	addi	sp,sp,-8
   202f8:	df000115 	stw	fp,4(sp)
   202fc:	df000104 	addi	fp,sp,4
   20300:	e13fff15 	stw	r4,-4(fp)
   20304:	e037883a 	mov	sp,fp
   20308:	df000017 	ldw	fp,0(sp)
   2030c:	dec00104 	addi	sp,sp,4
   20310:	f800283a 	ret

00020314 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   20314:	defffe04 	addi	sp,sp,-8
   20318:	dfc00115 	stw	ra,4(sp)
   2031c:	df000015 	stw	fp,0(sp)
   20320:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   20324:	008000f4 	movhi	r2,3
   20328:	108d3404 	addi	r2,r2,13520
   2032c:	10800017 	ldw	r2,0(r2)
   20330:	10000526 	beq	r2,zero,20348 <alt_get_errno+0x34>
   20334:	008000f4 	movhi	r2,3
   20338:	108d3404 	addi	r2,r2,13520
   2033c:	10800017 	ldw	r2,0(r2)
   20340:	103ee83a 	callr	r2
   20344:	00000206 	br	20350 <alt_get_errno+0x3c>
   20348:	008000f4 	movhi	r2,3
   2034c:	10961104 	addi	r2,r2,22596
}
   20350:	e037883a 	mov	sp,fp
   20354:	dfc00117 	ldw	ra,4(sp)
   20358:	df000017 	ldw	fp,0(sp)
   2035c:	dec00204 	addi	sp,sp,8
   20360:	f800283a 	ret

00020364 <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
   20364:	defff904 	addi	sp,sp,-28
   20368:	dfc00615 	stw	ra,24(sp)
   2036c:	df000515 	stw	fp,20(sp)
   20370:	df000504 	addi	fp,sp,20
   20374:	e13ffd15 	stw	r4,-12(fp)
   20378:	e17ffe15 	stw	r5,-8(fp)
   2037c:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
   20380:	e0bffd17 	ldw	r2,-12(fp)
   20384:	10000616 	blt	r2,zero,203a0 <read+0x3c>
   20388:	e0bffd17 	ldw	r2,-12(fp)
   2038c:	10c00324 	muli	r3,r2,12
   20390:	008000f4 	movhi	r2,3
   20394:	1086c804 	addi	r2,r2,6944
   20398:	1885883a 	add	r2,r3,r2
   2039c:	00000106 	br	203a4 <read+0x40>
   203a0:	0005883a 	mov	r2,zero
   203a4:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
   203a8:	e0bffb17 	ldw	r2,-20(fp)
   203ac:	10002026 	beq	r2,zero,20430 <read+0xcc>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
   203b0:	e0bffb17 	ldw	r2,-20(fp)
   203b4:	10800217 	ldw	r2,8(r2)
   203b8:	108000cc 	andi	r2,r2,3
   203bc:	10800060 	cmpeqi	r2,r2,1
   203c0:	1000171e 	bne	r2,zero,20420 <read+0xbc>
        (fd->dev->read))
   203c4:	e0bffb17 	ldw	r2,-20(fp)
   203c8:	10800017 	ldw	r2,0(r2)
   203cc:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
   203d0:	10001326 	beq	r2,zero,20420 <read+0xbc>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
   203d4:	e0bffb17 	ldw	r2,-20(fp)
   203d8:	10800017 	ldw	r2,0(r2)
   203dc:	10c00517 	ldw	r3,20(r2)
   203e0:	e0bfff17 	ldw	r2,-4(fp)
   203e4:	e13ffb17 	ldw	r4,-20(fp)
   203e8:	e17ffe17 	ldw	r5,-8(fp)
   203ec:	100d883a 	mov	r6,r2
   203f0:	183ee83a 	callr	r3
   203f4:	e0bffc15 	stw	r2,-16(fp)
   203f8:	e0bffc17 	ldw	r2,-16(fp)
   203fc:	1000060e 	bge	r2,zero,20418 <read+0xb4>
        {
          ALT_ERRNO = -rval;
   20400:	00203140 	call	20314 <alt_get_errno>
   20404:	e0fffc17 	ldw	r3,-16(fp)
   20408:	00c7c83a 	sub	r3,zero,r3
   2040c:	10c00015 	stw	r3,0(r2)
          return -1;
   20410:	00bfffc4 	movi	r2,-1
   20414:	00000a06 	br	20440 <read+0xdc>
        }
        return rval;
   20418:	e0bffc17 	ldw	r2,-16(fp)
   2041c:	00000806 	br	20440 <read+0xdc>
      }
      else
      {
        ALT_ERRNO = EACCES;
   20420:	00203140 	call	20314 <alt_get_errno>
   20424:	00c00344 	movi	r3,13
   20428:	10c00015 	stw	r3,0(r2)
   2042c:	00000306 	br	2043c <read+0xd8>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
   20430:	00203140 	call	20314 <alt_get_errno>
   20434:	00c01444 	movi	r3,81
   20438:	10c00015 	stw	r3,0(r2)
  }
  return -1;
   2043c:	00bfffc4 	movi	r2,-1
}
   20440:	e037883a 	mov	sp,fp
   20444:	dfc00117 	ldw	ra,4(sp)
   20448:	df000017 	ldw	fp,0(sp)
   2044c:	dec00204 	addi	sp,sp,8
   20450:	f800283a 	ret

00020454 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
   20454:	defffe04 	addi	sp,sp,-8
   20458:	df000115 	stw	fp,4(sp)
   2045c:	df000104 	addi	fp,sp,4
   20460:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
   20464:	e0bfff17 	ldw	r2,-4(fp)
   20468:	108000d0 	cmplti	r2,r2,3
   2046c:	10000d1e 	bne	r2,zero,204a4 <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
   20470:	00c000f4 	movhi	r3,3
   20474:	18c6c804 	addi	r3,r3,6944
   20478:	e0bfff17 	ldw	r2,-4(fp)
   2047c:	10800324 	muli	r2,r2,12
   20480:	1885883a 	add	r2,r3,r2
   20484:	10800204 	addi	r2,r2,8
   20488:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
   2048c:	00c000f4 	movhi	r3,3
   20490:	18c6c804 	addi	r3,r3,6944
   20494:	e0bfff17 	ldw	r2,-4(fp)
   20498:	10800324 	muli	r2,r2,12
   2049c:	1885883a 	add	r2,r3,r2
   204a0:	10000015 	stw	zero,0(r2)
  }
}
   204a4:	e037883a 	mov	sp,fp
   204a8:	df000017 	ldw	fp,0(sp)
   204ac:	dec00104 	addi	sp,sp,4
   204b0:	f800283a 	ret

000204b4 <alt_remap_uncached>:
 * Convert a pointer to a block of cached memory, into a block of
 * uncached memory.
 */

volatile void* alt_remap_uncached (void* ptr, alt_u32 len)
{
   204b4:	defffc04 	addi	sp,sp,-16
   204b8:	dfc00315 	stw	ra,12(sp)
   204bc:	df000215 	stw	fp,8(sp)
   204c0:	df000204 	addi	fp,sp,8
   204c4:	e13ffe15 	stw	r4,-8(fp)
   204c8:	e17fff15 	stw	r5,-4(fp)
  alt_dcache_flush (ptr, len);
   204cc:	e13ffe17 	ldw	r4,-8(fp)
   204d0:	e17fff17 	ldw	r5,-4(fp)
   204d4:	002af000 	call	2af00 <alt_dcache_flush>
  return (volatile void*) (((alt_u32) ptr) | BYPASS_DCACHE_MASK);
   204d8:	e0bffe17 	ldw	r2,-8(fp)
   204dc:	10a00034 	orhi	r2,r2,32768
}
   204e0:	e037883a 	mov	sp,fp
   204e4:	dfc00117 	ldw	ra,4(sp)
   204e8:	df000017 	ldw	fp,0(sp)
   204ec:	dec00204 	addi	sp,sp,8
   204f0:	f800283a 	ret

000204f4 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
   204f4:	defff704 	addi	sp,sp,-36
   204f8:	df000815 	stw	fp,32(sp)
   204fc:	df000804 	addi	fp,sp,32
   20500:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   20504:	0005303a 	rdctl	r2,status
   20508:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   2050c:	e0fffa17 	ldw	r3,-24(fp)
   20510:	00bfff84 	movi	r2,-2
   20514:	1884703a 	and	r2,r3,r2
   20518:	1001703a 	wrctl	status,r2
  
  return context;
   2051c:	e0bffa17 	ldw	r2,-24(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
   20520:	e0bff815 	stw	r2,-32(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
   20524:	d0a01517 	ldw	r2,-32684(gp)
   20528:	10c000c4 	addi	r3,r2,3
   2052c:	00bfff04 	movi	r2,-4
   20530:	1884703a 	and	r2,r3,r2
   20534:	d0a01515 	stw	r2,-32684(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
   20538:	d0e01517 	ldw	r3,-32684(gp)
   2053c:	e0bfff17 	ldw	r2,-4(fp)
   20540:	1885883a 	add	r2,r3,r2
   20544:	00c08034 	movhi	r3,512
   20548:	18c00004 	addi	r3,r3,0
   2054c:	1880112e 	bgeu	r3,r2,20594 <sbrk+0xa0>
   20550:	e0bff817 	ldw	r2,-32(fp)
   20554:	e0bffb15 	stw	r2,-20(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   20558:	0005303a 	rdctl	r2,status
   2055c:	e0bffc15 	stw	r2,-16(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   20560:	e0fffc17 	ldw	r3,-16(fp)
   20564:	00bfff84 	movi	r2,-2
   20568:	1884703a 	and	r2,r3,r2
   2056c:	e0bffc15 	stw	r2,-16(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   20570:	e0bffb17 	ldw	r2,-20(fp)
   20574:	1080004c 	andi	r2,r2,1
   20578:	e0fffc17 	ldw	r3,-16(fp)
   2057c:	1884b03a 	or	r2,r3,r2
   20580:	e0bffc15 	stw	r2,-16(fp)
  
  NIOS2_WRITE_STATUS (status);
   20584:	e0bffc17 	ldw	r2,-16(fp)
   20588:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
   2058c:	00bfffc4 	movi	r2,-1
   20590:	00001606 	br	205ec <sbrk+0xf8>
  }
#endif

  prev_heap_end = heap_end; 
   20594:	d0a01517 	ldw	r2,-32684(gp)
   20598:	e0bff915 	stw	r2,-28(fp)
  heap_end += incr; 
   2059c:	d0e01517 	ldw	r3,-32684(gp)
   205a0:	e0bfff17 	ldw	r2,-4(fp)
   205a4:	1885883a 	add	r2,r3,r2
   205a8:	d0a01515 	stw	r2,-32684(gp)
   205ac:	e0bff817 	ldw	r2,-32(fp)
   205b0:	e0bffd15 	stw	r2,-12(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   205b4:	0005303a 	rdctl	r2,status
   205b8:	e0bffe15 	stw	r2,-8(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   205bc:	e0fffe17 	ldw	r3,-8(fp)
   205c0:	00bfff84 	movi	r2,-2
   205c4:	1884703a 	and	r2,r3,r2
   205c8:	e0bffe15 	stw	r2,-8(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   205cc:	e0bffd17 	ldw	r2,-12(fp)
   205d0:	1080004c 	andi	r2,r2,1
   205d4:	e0fffe17 	ldw	r3,-8(fp)
   205d8:	1884b03a 	or	r2,r3,r2
   205dc:	e0bffe15 	stw	r2,-8(fp)
  
  NIOS2_WRITE_STATUS (status);
   205e0:	e0bffe17 	ldw	r2,-8(fp)
   205e4:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
   205e8:	e0bff917 	ldw	r2,-28(fp)
} 
   205ec:	e037883a 	mov	sp,fp
   205f0:	df000017 	ldw	fp,0(sp)
   205f4:	dec00104 	addi	sp,sp,4
   205f8:	f800283a 	ret

000205fc <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
   205fc:	defff904 	addi	sp,sp,-28
   20600:	df000615 	stw	fp,24(sp)
   20604:	df000604 	addi	fp,sp,24
   20608:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   2060c:	0005303a 	rdctl	r2,status
   20610:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   20614:	e0fffb17 	ldw	r3,-20(fp)
   20618:	00bfff84 	movi	r2,-2
   2061c:	1884703a 	and	r2,r3,r2
   20620:	1001703a 	wrctl	status,r2
  
  return context;
   20624:	e0bffb17 	ldw	r2,-20(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
   20628:	e0bffa15 	stw	r2,-24(fp)
  alt_llist_remove (&alarm->llist);
   2062c:	e0bfff17 	ldw	r2,-4(fp)
   20630:	e0bffc15 	stw	r2,-16(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
   20634:	e0bffc17 	ldw	r2,-16(fp)
   20638:	10800017 	ldw	r2,0(r2)
   2063c:	e0fffc17 	ldw	r3,-16(fp)
   20640:	18c00117 	ldw	r3,4(r3)
   20644:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
   20648:	e0bffc17 	ldw	r2,-16(fp)
   2064c:	10800117 	ldw	r2,4(r2)
   20650:	e0fffc17 	ldw	r3,-16(fp)
   20654:	18c00017 	ldw	r3,0(r3)
   20658:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
   2065c:	e0bffc17 	ldw	r2,-16(fp)
   20660:	e0fffc17 	ldw	r3,-16(fp)
   20664:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
   20668:	e0bffc17 	ldw	r2,-16(fp)
   2066c:	e0fffc17 	ldw	r3,-16(fp)
   20670:	10c00015 	stw	r3,0(r2)
   20674:	e0bffa17 	ldw	r2,-24(fp)
   20678:	e0bffd15 	stw	r2,-12(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   2067c:	0005303a 	rdctl	r2,status
   20680:	e0bffe15 	stw	r2,-8(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   20684:	e0fffe17 	ldw	r3,-8(fp)
   20688:	00bfff84 	movi	r2,-2
   2068c:	1884703a 	and	r2,r3,r2
   20690:	e0bffe15 	stw	r2,-8(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   20694:	e0bffd17 	ldw	r2,-12(fp)
   20698:	1080004c 	andi	r2,r2,1
   2069c:	e0fffe17 	ldw	r3,-8(fp)
   206a0:	1884b03a 	or	r2,r3,r2
   206a4:	e0bffe15 	stw	r2,-8(fp)
  
  NIOS2_WRITE_STATUS (status);
   206a8:	e0bffe17 	ldw	r2,-8(fp)
   206ac:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
   206b0:	e037883a 	mov	sp,fp
   206b4:	df000017 	ldw	fp,0(sp)
   206b8:	dec00104 	addi	sp,sp,4
   206bc:	f800283a 	ret

000206c0 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
   206c0:	defffb04 	addi	sp,sp,-20
   206c4:	dfc00415 	stw	ra,16(sp)
   206c8:	df000315 	stw	fp,12(sp)
   206cc:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
   206d0:	d0a01617 	ldw	r2,-32680(gp)
   206d4:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
   206d8:	d0a8f617 	ldw	r2,-23592(gp)
   206dc:	10800044 	addi	r2,r2,1
   206e0:	d0a8f615 	stw	r2,-23592(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
   206e4:	00002e06 	br	207a0 <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
   206e8:	e0bffd17 	ldw	r2,-12(fp)
   206ec:	10800017 	ldw	r2,0(r2)
   206f0:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
   206f4:	e0bffd17 	ldw	r2,-12(fp)
   206f8:	10800403 	ldbu	r2,16(r2)
   206fc:	10803fcc 	andi	r2,r2,255
   20700:	10000426 	beq	r2,zero,20714 <alt_tick+0x54>
   20704:	d0a8f617 	ldw	r2,-23592(gp)
   20708:	1000021e 	bne	r2,zero,20714 <alt_tick+0x54>
    {
      alarm->rollover = 0;
   2070c:	e0bffd17 	ldw	r2,-12(fp)
   20710:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
   20714:	e0bffd17 	ldw	r2,-12(fp)
   20718:	10800217 	ldw	r2,8(r2)
   2071c:	d0e8f617 	ldw	r3,-23592(gp)
   20720:	18801d36 	bltu	r3,r2,20798 <alt_tick+0xd8>
   20724:	e0bffd17 	ldw	r2,-12(fp)
   20728:	10800403 	ldbu	r2,16(r2)
   2072c:	10803fcc 	andi	r2,r2,255
   20730:	1000191e 	bne	r2,zero,20798 <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
   20734:	e0bffd17 	ldw	r2,-12(fp)
   20738:	10c00317 	ldw	r3,12(r2)
   2073c:	e0bffd17 	ldw	r2,-12(fp)
   20740:	10800517 	ldw	r2,20(r2)
   20744:	1009883a 	mov	r4,r2
   20748:	183ee83a 	callr	r3
   2074c:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
   20750:	e0bfff17 	ldw	r2,-4(fp)
   20754:	1000031e 	bne	r2,zero,20764 <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
   20758:	e13ffd17 	ldw	r4,-12(fp)
   2075c:	00205fc0 	call	205fc <alt_alarm_stop>
   20760:	00000d06 	br	20798 <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
   20764:	e0bffd17 	ldw	r2,-12(fp)
   20768:	10c00217 	ldw	r3,8(r2)
   2076c:	e0bfff17 	ldw	r2,-4(fp)
   20770:	1887883a 	add	r3,r3,r2
   20774:	e0bffd17 	ldw	r2,-12(fp)
   20778:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
   2077c:	e0bffd17 	ldw	r2,-12(fp)
   20780:	10c00217 	ldw	r3,8(r2)
   20784:	d0a8f617 	ldw	r2,-23592(gp)
   20788:	1880032e 	bgeu	r3,r2,20798 <alt_tick+0xd8>
        {
          alarm->rollover = 1;
   2078c:	e0bffd17 	ldw	r2,-12(fp)
   20790:	00c00044 	movi	r3,1
   20794:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
   20798:	e0bffe17 	ldw	r2,-8(fp)
   2079c:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
   207a0:	e0fffd17 	ldw	r3,-12(fp)
   207a4:	d0a01604 	addi	r2,gp,-32680
   207a8:	18bfcf1e 	bne	r3,r2,206e8 <alt_tick+0x28>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
   207ac:	0001883a 	nop
}
   207b0:	e037883a 	mov	sp,fp
   207b4:	dfc00117 	ldw	ra,4(sp)
   207b8:	df000017 	ldw	fp,0(sp)
   207bc:	dec00204 	addi	sp,sp,8
   207c0:	f800283a 	ret

000207c4 <alt_uncached_malloc>:
/*
 * Allocate a block of uncached memory.
 */

volatile void* alt_uncached_malloc (size_t size)
{
   207c4:	defffc04 	addi	sp,sp,-16
   207c8:	dfc00315 	stw	ra,12(sp)
   207cc:	df000215 	stw	fp,8(sp)
   207d0:	df000204 	addi	fp,sp,8
   207d4:	e13fff15 	stw	r4,-4(fp)
  void* ptr;

  ptr = malloc (size);
   207d8:	e13fff17 	ldw	r4,-4(fp)
   207dc:	002c1400 	call	2c140 <malloc>
   207e0:	e0bffe15 	stw	r2,-8(fp)

  alt_dcache_flush (ptr, size);
   207e4:	e13ffe17 	ldw	r4,-8(fp)
   207e8:	e17fff17 	ldw	r5,-4(fp)
   207ec:	002af000 	call	2af00 <alt_dcache_flush>

  return ptr ? (volatile void*) (((alt_u32) ptr) | BYPASS_DCACHE_MASK) : NULL;
   207f0:	e0bffe17 	ldw	r2,-8(fp)
   207f4:	10000326 	beq	r2,zero,20804 <alt_uncached_malloc+0x40>
   207f8:	e0bffe17 	ldw	r2,-8(fp)
   207fc:	10a00034 	orhi	r2,r2,32768
   20800:	00000106 	br	20808 <alt_uncached_malloc+0x44>
   20804:	0005883a 	mov	r2,zero
}
   20808:	e037883a 	mov	sp,fp
   2080c:	dfc00117 	ldw	ra,4(sp)
   20810:	df000017 	ldw	fp,0(sp)
   20814:	dec00204 	addi	sp,sp,8
   20818:	f800283a 	ret

0002081c <usleep>:
   2081c:	defffd04 	addi	sp,sp,-12
   20820:	dfc00215 	stw	ra,8(sp)
   20824:	df000115 	stw	fp,4(sp)
   20828:	df000104 	addi	fp,sp,4
   2082c:	e13fff15 	stw	r4,-4(fp)
   20830:	e13fff17 	ldw	r4,-4(fp)
   20834:	002add80 	call	2add8 <alt_busy_sleep>
   20838:	e037883a 	mov	sp,fp
   2083c:	dfc00117 	ldw	ra,4(sp)
   20840:	df000017 	ldw	fp,0(sp)
   20844:	dec00204 	addi	sp,sp,8
   20848:	f800283a 	ret

0002084c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   2084c:	defffe04 	addi	sp,sp,-8
   20850:	dfc00115 	stw	ra,4(sp)
   20854:	df000015 	stw	fp,0(sp)
   20858:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   2085c:	008000f4 	movhi	r2,3
   20860:	108d3404 	addi	r2,r2,13520
   20864:	10800017 	ldw	r2,0(r2)
   20868:	10000526 	beq	r2,zero,20880 <alt_get_errno+0x34>
   2086c:	008000f4 	movhi	r2,3
   20870:	108d3404 	addi	r2,r2,13520
   20874:	10800017 	ldw	r2,0(r2)
   20878:	103ee83a 	callr	r2
   2087c:	00000206 	br	20888 <alt_get_errno+0x3c>
   20880:	008000f4 	movhi	r2,3
   20884:	10961104 	addi	r2,r2,22596
}
   20888:	e037883a 	mov	sp,fp
   2088c:	dfc00117 	ldw	ra,4(sp)
   20890:	df000017 	ldw	fp,0(sp)
   20894:	dec00204 	addi	sp,sp,8
   20898:	f800283a 	ret

0002089c <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
   2089c:	defff904 	addi	sp,sp,-28
   208a0:	dfc00615 	stw	ra,24(sp)
   208a4:	df000515 	stw	fp,20(sp)
   208a8:	df000504 	addi	fp,sp,20
   208ac:	e13ffd15 	stw	r4,-12(fp)
   208b0:	e17ffe15 	stw	r5,-8(fp)
   208b4:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
   208b8:	e0bffd17 	ldw	r2,-12(fp)
   208bc:	10000616 	blt	r2,zero,208d8 <write+0x3c>
   208c0:	e0bffd17 	ldw	r2,-12(fp)
   208c4:	10c00324 	muli	r3,r2,12
   208c8:	008000f4 	movhi	r2,3
   208cc:	1086c804 	addi	r2,r2,6944
   208d0:	1885883a 	add	r2,r3,r2
   208d4:	00000106 	br	208dc <write+0x40>
   208d8:	0005883a 	mov	r2,zero
   208dc:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
   208e0:	e0bffb17 	ldw	r2,-20(fp)
   208e4:	10001f26 	beq	r2,zero,20964 <write+0xc8>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
   208e8:	e0bffb17 	ldw	r2,-20(fp)
   208ec:	10800217 	ldw	r2,8(r2)
   208f0:	108000cc 	andi	r2,r2,3
   208f4:	10001726 	beq	r2,zero,20954 <write+0xb8>
   208f8:	e0bffb17 	ldw	r2,-20(fp)
   208fc:	10800017 	ldw	r2,0(r2)
   20900:	10800617 	ldw	r2,24(r2)
   20904:	10001326 	beq	r2,zero,20954 <write+0xb8>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
   20908:	e0bffb17 	ldw	r2,-20(fp)
   2090c:	10800017 	ldw	r2,0(r2)
   20910:	10c00617 	ldw	r3,24(r2)
   20914:	e0bfff17 	ldw	r2,-4(fp)
   20918:	e13ffb17 	ldw	r4,-20(fp)
   2091c:	e17ffe17 	ldw	r5,-8(fp)
   20920:	100d883a 	mov	r6,r2
   20924:	183ee83a 	callr	r3
   20928:	e0bffc15 	stw	r2,-16(fp)
   2092c:	e0bffc17 	ldw	r2,-16(fp)
   20930:	1000060e 	bge	r2,zero,2094c <write+0xb0>
      {
        ALT_ERRNO = -rval;
   20934:	002084c0 	call	2084c <alt_get_errno>
   20938:	e0fffc17 	ldw	r3,-16(fp)
   2093c:	00c7c83a 	sub	r3,zero,r3
   20940:	10c00015 	stw	r3,0(r2)
        return -1;
   20944:	00bfffc4 	movi	r2,-1
   20948:	00000a06 	br	20974 <write+0xd8>
      }
      return rval;
   2094c:	e0bffc17 	ldw	r2,-16(fp)
   20950:	00000806 	br	20974 <write+0xd8>
    }
    else
    {
      ALT_ERRNO = EACCES;
   20954:	002084c0 	call	2084c <alt_get_errno>
   20958:	00c00344 	movi	r3,13
   2095c:	10c00015 	stw	r3,0(r2)
   20960:	00000306 	br	20970 <write+0xd4>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
   20964:	002084c0 	call	2084c <alt_get_errno>
   20968:	00c01444 	movi	r3,81
   2096c:	10c00015 	stw	r3,0(r2)
  }
  return -1;
   20970:	00bfffc4 	movi	r2,-1
}
   20974:	e037883a 	mov	sp,fp
   20978:	dfc00117 	ldw	ra,4(sp)
   2097c:	df000017 	ldw	fp,0(sp)
   20980:	dec00204 	addi	sp,sp,8
   20984:	f800283a 	ret

00020988 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
   20988:	defffd04 	addi	sp,sp,-12
   2098c:	dfc00215 	stw	ra,8(sp)
   20990:	df000115 	stw	fp,4(sp)
   20994:	df000104 	addi	fp,sp,4
   20998:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
   2099c:	e13fff17 	ldw	r4,-4(fp)
   209a0:	014000f4 	movhi	r5,3
   209a4:	294d3104 	addi	r5,r5,13508
   209a8:	002af900 	call	2af90 <alt_dev_llist_insert>
}
   209ac:	e037883a 	mov	sp,fp
   209b0:	dfc00117 	ldw	ra,4(sp)
   209b4:	df000017 	ldw	fp,0(sp)
   209b8:	dec00204 	addi	sp,sp,8
   209bc:	f800283a 	ret

000209c0 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
   209c0:	defffd04 	addi	sp,sp,-12
   209c4:	dfc00215 	stw	ra,8(sp)
   209c8:	df000115 	stw	fp,4(sp)
   209cc:	df000104 	addi	fp,sp,4
   209d0:	e13fff15 	stw	r4,-4(fp)
    ALTERA_VIC_IRQ_INIT ( VIC_0, vic_0);
   209d4:	010000f4 	movhi	r4,3
   209d8:	21072804 	addi	r4,r4,7328
   209dc:	002ab440 	call	2ab44 <alt_vic_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts ()
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
   209e0:	00802034 	movhi	r2,128
   209e4:	10800044 	addi	r2,r2,1
   209e8:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
   209ec:	e037883a 	mov	sp,fp
   209f0:	dfc00117 	ldw	ra,4(sp)
   209f4:	df000017 	ldw	fp,0(sp)
   209f8:	dec00204 	addi	sp,sp,8
   209fc:	f800283a 	ret

00020a00 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
   20a00:	defffe04 	addi	sp,sp,-8
   20a04:	dfc00115 	stw	ra,4(sp)
   20a08:	df000015 	stw	fp,0(sp)
   20a0c:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( SYS_CLK_TIMER, sys_clk_timer);
   20a10:	01020034 	movhi	r4,2048
   20a14:	21005804 	addi	r4,r4,352
   20a18:	000b883a 	mov	r5,zero
   20a1c:	000d883a 	mov	r6,zero
   20a20:	01c0fa04 	movi	r7,1000
   20a24:	0024f480 	call	24f48 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_TIMER_INIT ( TIMER_5, timer_5);
    ALTERA_AVALON_TIMER_INIT ( TIMER_6, timer_6);
    ALTERA_AVALON_TIMER_INIT ( TIMER_7, timer_7);
    ALTERA_AVALON_TIMER_INIT ( TIMER_8, timer_8);
    ALTERA_AVALON_TIMER_INIT ( TIMER_9, timer_9);
    ALTERA_AVALON_CFI_FLASH_INIT ( CFI_FLASH, cfi_flash);
   20a28:	010000f4 	movhi	r4,3
   20a2c:	21074f04 	addi	r4,r4,7484
   20a30:	0020b480 	call	20b48 <alt_flash_cfi_init>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
   20a34:	010000f4 	movhi	r4,3
   20a38:	21078f04 	addi	r4,r4,7740
   20a3c:	000b883a 	mov	r5,zero
   20a40:	01800044 	movi	r6,1
   20a44:	00229380 	call	22938 <altera_avalon_jtag_uart_init>
   20a48:	010000f4 	movhi	r4,3
   20a4c:	21078504 	addi	r4,r4,7700
   20a50:	00209880 	call	20988 <alt_dev_reg>
    ALTERA_AVALON_LCD_16207_INIT ( LCD, lcd);
   20a54:	010000f4 	movhi	r4,3
   20a58:	210ba704 	addi	r4,r4,11932
   20a5c:	0023fe40 	call	23fe4 <altera_avalon_lcd_16207_init>
   20a60:	010000f4 	movhi	r4,3
   20a64:	210b9d04 	addi	r4,r4,11892
   20a68:	00209880 	call	20988 <alt_dev_reg>
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_RX, sgdma_rx);
   20a6c:	010000f4 	movhi	r4,3
   20a70:	210be504 	addi	r4,r4,12180
   20a74:	000b883a 	mov	r5,zero
   20a78:	01800304 	movi	r6,12
   20a7c:	0024e040 	call	24e04 <alt_avalon_sgdma_init>
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_TX, sgdma_tx);
   20a80:	010000f4 	movhi	r4,3
   20a84:	210bf104 	addi	r4,r4,12228
   20a88:	000b883a 	mov	r5,zero
   20a8c:	01800344 	movi	r6,13
   20a90:	0024e040 	call	24e04 <alt_avalon_sgdma_init>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID, sysid);
   20a94:	0001883a 	nop
    ALTERA_AVALON_UART_INIT ( RS232, rs232);
   20a98:	010000f4 	movhi	r4,3
   20a9c:	210c0704 	addi	r4,r4,12316
   20aa0:	000b883a 	mov	r5,zero
   20aa4:	018001c4 	movi	r6,7
   20aa8:	002a0880 	call	2a088 <altera_avalon_uart_init>
   20aac:	010000f4 	movhi	r4,3
   20ab0:	210bfd04 	addi	r4,r4,12276
   20ab4:	00209880 	call	20988 <alt_dev_reg>
    ALTERA_AVALON_UART_INIT ( UART_0, uart_0);
   20ab8:	010000f4 	movhi	r4,3
   20abc:	210c3804 	addi	r4,r4,12512
   20ac0:	000b883a 	mov	r5,zero
   20ac4:	018000c4 	movi	r6,3
   20ac8:	002a0880 	call	2a088 <altera_avalon_uart_init>
   20acc:	010000f4 	movhi	r4,3
   20ad0:	210c2e04 	addi	r4,r4,12472
   20ad4:	00209880 	call	20988 <alt_dev_reg>
    ALTERA_AVALON_UART_INIT ( UART_1, uart_1);
   20ad8:	010000f4 	movhi	r4,3
   20adc:	210c6904 	addi	r4,r4,12708
   20ae0:	000b883a 	mov	r5,zero
   20ae4:	01800104 	movi	r6,4
   20ae8:	002a0880 	call	2a088 <altera_avalon_uart_init>
   20aec:	010000f4 	movhi	r4,3
   20af0:	210c5f04 	addi	r4,r4,12668
   20af4:	00209880 	call	20988 <alt_dev_reg>
    ALTERA_ETH_TSE_INIT ( TSE_MAC, tse_mac);
   20af8:	0001883a 	nop
}
   20afc:	e037883a 	mov	sp,fp
   20b00:	dfc00117 	ldw	ra,4(sp)
   20b04:	df000017 	ldw	fp,0(sp)
   20b08:	dec00204 	addi	sp,sp,8
   20b0c:	f800283a 	ret

00020b10 <alt_flash_device_register>:
   20b10:	defffd04 	addi	sp,sp,-12
   20b14:	dfc00215 	stw	ra,8(sp)
   20b18:	df000115 	stw	fp,4(sp)
   20b1c:	df000104 	addi	fp,sp,4
   20b20:	e13fff15 	stw	r4,-4(fp)
   20b24:	e13fff17 	ldw	r4,-4(fp)
   20b28:	014000f4 	movhi	r5,3
   20b2c:	294d3c04 	addi	r5,r5,13552
   20b30:	002af900 	call	2af90 <alt_dev_llist_insert>
   20b34:	e037883a 	mov	sp,fp
   20b38:	dfc00117 	ldw	ra,4(sp)
   20b3c:	df000017 	ldw	fp,0(sp)
   20b40:	dec00204 	addi	sp,sp,8
   20b44:	f800283a 	ret

00020b48 <alt_flash_cfi_init>:
   20b48:	defffc04 	addi	sp,sp,-16
   20b4c:	dfc00315 	stw	ra,12(sp)
   20b50:	df000215 	stw	fp,8(sp)
   20b54:	df000204 	addi	fp,sp,8
   20b58:	e13fff15 	stw	r4,-4(fp)
   20b5c:	e03ffe15 	stw	zero,-8(fp)
   20b60:	e13fff17 	ldw	r4,-4(fp)
   20b64:	0021f900 	call	21f90 <alt_read_cfi_width>
   20b68:	e0bffe15 	stw	r2,-8(fp)
   20b6c:	e0bffe17 	ldw	r2,-8(fp)
   20b70:	1000031e 	bne	r2,zero,20b80 <alt_flash_cfi_init+0x38>
   20b74:	e13fff17 	ldw	r4,-4(fp)
   20b78:	00216e80 	call	216e8 <alt_set_flash_width_func>
   20b7c:	e0bffe15 	stw	r2,-8(fp)
   20b80:	e0bffe17 	ldw	r2,-8(fp)
   20b84:	1000031e 	bne	r2,zero,20b94 <alt_flash_cfi_init+0x4c>
   20b88:	e13fff17 	ldw	r4,-4(fp)
   20b8c:	00219c80 	call	219c8 <alt_read_cfi_table>
   20b90:	e0bffe15 	stw	r2,-8(fp)
   20b94:	e0bffe17 	ldw	r2,-8(fp)
   20b98:	1000031e 	bne	r2,zero,20ba8 <alt_flash_cfi_init+0x60>
   20b9c:	e13fff17 	ldw	r4,-4(fp)
   20ba0:	00218ac0 	call	218ac <alt_set_flash_algorithm_func>
   20ba4:	e0bffe15 	stw	r2,-8(fp)
   20ba8:	e0bffe17 	ldw	r2,-8(fp)
   20bac:	1000041e 	bne	r2,zero,20bc0 <alt_flash_cfi_init+0x78>
   20bb0:	e0bfff17 	ldw	r2,-4(fp)
   20bb4:	1009883a 	mov	r4,r2
   20bb8:	0020b100 	call	20b10 <alt_flash_device_register>
   20bbc:	e0bffe15 	stw	r2,-8(fp)
   20bc0:	e0bffe17 	ldw	r2,-8(fp)
   20bc4:	e037883a 	mov	sp,fp
   20bc8:	dfc00117 	ldw	ra,4(sp)
   20bcc:	df000017 	ldw	fp,0(sp)
   20bd0:	dec00204 	addi	sp,sp,8
   20bd4:	f800283a 	ret

00020bd8 <alt_flash_cfi_write>:
   20bd8:	defff104 	addi	sp,sp,-60
   20bdc:	dfc00e15 	stw	ra,56(sp)
   20be0:	df000d15 	stw	fp,52(sp)
   20be4:	df000d04 	addi	fp,sp,52
   20be8:	e13ffc15 	stw	r4,-16(fp)
   20bec:	e17ffd15 	stw	r5,-12(fp)
   20bf0:	e1bffe15 	stw	r6,-8(fp)
   20bf4:	e1ffff15 	stw	r7,-4(fp)
   20bf8:	e03ff415 	stw	zero,-48(fp)
   20bfc:	e0bfff17 	ldw	r2,-4(fp)
   20c00:	e0bff815 	stw	r2,-32(fp)
   20c04:	e0bffd17 	ldw	r2,-12(fp)
   20c08:	e0bff915 	stw	r2,-28(fp)
   20c0c:	e0bffc17 	ldw	r2,-16(fp)
   20c10:	e0bffa15 	stw	r2,-24(fp)
   20c14:	e03ff515 	stw	zero,-44(fp)
   20c18:	00008806 	br	20e3c <alt_flash_cfi_write+0x264>
   20c1c:	e0fffa17 	ldw	r3,-24(fp)
   20c20:	e0bff517 	ldw	r2,-44(fp)
   20c24:	1004913a 	slli	r2,r2,4
   20c28:	1885883a 	add	r2,r3,r2
   20c2c:	10800d04 	addi	r2,r2,52
   20c30:	10800017 	ldw	r2,0(r2)
   20c34:	e0fffd17 	ldw	r3,-12(fp)
   20c38:	18807d16 	blt	r3,r2,20e30 <alt_flash_cfi_write+0x258>
   20c3c:	e0fffa17 	ldw	r3,-24(fp)
   20c40:	e0bff517 	ldw	r2,-44(fp)
   20c44:	1004913a 	slli	r2,r2,4
   20c48:	1885883a 	add	r2,r3,r2
   20c4c:	10800d04 	addi	r2,r2,52
   20c50:	10c00017 	ldw	r3,0(r2)
   20c54:	e13ffa17 	ldw	r4,-24(fp)
   20c58:	e0bff517 	ldw	r2,-44(fp)
   20c5c:	1004913a 	slli	r2,r2,4
   20c60:	2085883a 	add	r2,r4,r2
   20c64:	10800e04 	addi	r2,r2,56
   20c68:	10800017 	ldw	r2,0(r2)
   20c6c:	1885883a 	add	r2,r3,r2
   20c70:	e0fffd17 	ldw	r3,-12(fp)
   20c74:	18806e0e 	bge	r3,r2,20e30 <alt_flash_cfi_write+0x258>
   20c78:	e0fffa17 	ldw	r3,-24(fp)
   20c7c:	e0bff517 	ldw	r2,-44(fp)
   20c80:	1004913a 	slli	r2,r2,4
   20c84:	1885883a 	add	r2,r3,r2
   20c88:	10800d04 	addi	r2,r2,52
   20c8c:	10800017 	ldw	r2,0(r2)
   20c90:	e0bff715 	stw	r2,-36(fp)
   20c94:	e03ff615 	stw	zero,-40(fp)
   20c98:	00005d06 	br	20e10 <alt_flash_cfi_write+0x238>
   20c9c:	e0fffd17 	ldw	r3,-12(fp)
   20ca0:	e0bff717 	ldw	r2,-36(fp)
   20ca4:	18804e16 	blt	r3,r2,20de0 <alt_flash_cfi_write+0x208>
   20ca8:	e0fffa17 	ldw	r3,-24(fp)
   20cac:	e0bff517 	ldw	r2,-44(fp)
   20cb0:	10800104 	addi	r2,r2,4
   20cb4:	1004913a 	slli	r2,r2,4
   20cb8:	1885883a 	add	r2,r3,r2
   20cbc:	10c00017 	ldw	r3,0(r2)
   20cc0:	e0bff717 	ldw	r2,-36(fp)
   20cc4:	1885883a 	add	r2,r3,r2
   20cc8:	e0fffd17 	ldw	r3,-12(fp)
   20ccc:	1880440e 	bge	r3,r2,20de0 <alt_flash_cfi_write+0x208>
   20cd0:	e0fffa17 	ldw	r3,-24(fp)
   20cd4:	e0bff517 	ldw	r2,-44(fp)
   20cd8:	10800104 	addi	r2,r2,4
   20cdc:	1004913a 	slli	r2,r2,4
   20ce0:	1885883a 	add	r2,r3,r2
   20ce4:	10c00017 	ldw	r3,0(r2)
   20ce8:	e0bff717 	ldw	r2,-36(fp)
   20cec:	1887883a 	add	r3,r3,r2
   20cf0:	e0bffd17 	ldw	r2,-12(fp)
   20cf4:	1885c83a 	sub	r2,r3,r2
   20cf8:	e0bffb15 	stw	r2,-20(fp)
   20cfc:	e0fffb17 	ldw	r3,-20(fp)
   20d00:	e0bfff17 	ldw	r2,-4(fp)
   20d04:	1880010e 	bge	r3,r2,20d0c <alt_flash_cfi_write+0x134>
   20d08:	1805883a 	mov	r2,r3
   20d0c:	e0bffb15 	stw	r2,-20(fp)
   20d10:	e0bffa17 	ldw	r2,-24(fp)
   20d14:	10c00a17 	ldw	r3,40(r2)
   20d18:	e0bffd17 	ldw	r2,-12(fp)
   20d1c:	1887883a 	add	r3,r3,r2
   20d20:	e0bffb17 	ldw	r2,-20(fp)
   20d24:	e13ffe17 	ldw	r4,-8(fp)
   20d28:	180b883a 	mov	r5,r3
   20d2c:	100d883a 	mov	r6,r2
   20d30:	002c1680 	call	2c168 <memcmp>
   20d34:	10001426 	beq	r2,zero,20d88 <alt_flash_cfi_write+0x1b0>
   20d38:	e0bffa17 	ldw	r2,-24(fp)
   20d3c:	10c00817 	ldw	r3,32(r2)
   20d40:	e0bffa17 	ldw	r2,-24(fp)
   20d44:	1009883a 	mov	r4,r2
   20d48:	e17ff717 	ldw	r5,-36(fp)
   20d4c:	183ee83a 	callr	r3
   20d50:	e0bff415 	stw	r2,-48(fp)
   20d54:	e0bff417 	ldw	r2,-48(fp)
   20d58:	10000b1e 	bne	r2,zero,20d88 <alt_flash_cfi_write+0x1b0>
   20d5c:	e0bffa17 	ldw	r2,-24(fp)
   20d60:	10c00917 	ldw	r3,36(r2)
   20d64:	e0bffa17 	ldw	r2,-24(fp)
   20d68:	e13ffb17 	ldw	r4,-20(fp)
   20d6c:	d9000015 	stw	r4,0(sp)
   20d70:	1009883a 	mov	r4,r2
   20d74:	e17ff717 	ldw	r5,-36(fp)
   20d78:	e1bffd17 	ldw	r6,-12(fp)
   20d7c:	e1fffe17 	ldw	r7,-8(fp)
   20d80:	183ee83a 	callr	r3
   20d84:	e0bff415 	stw	r2,-48(fp)
   20d88:	e0ffff17 	ldw	r3,-4(fp)
   20d8c:	e0bffb17 	ldw	r2,-20(fp)
   20d90:	18802e26 	beq	r3,r2,20e4c <alt_flash_cfi_write+0x274>
   20d94:	e0bff417 	ldw	r2,-48(fp)
   20d98:	10002c1e 	bne	r2,zero,20e4c <alt_flash_cfi_write+0x274>
   20d9c:	e0ffff17 	ldw	r3,-4(fp)
   20da0:	e0bffb17 	ldw	r2,-20(fp)
   20da4:	1885c83a 	sub	r2,r3,r2
   20da8:	e0bfff15 	stw	r2,-4(fp)
   20dac:	e0fffa17 	ldw	r3,-24(fp)
   20db0:	e0bff517 	ldw	r2,-44(fp)
   20db4:	10800104 	addi	r2,r2,4
   20db8:	1004913a 	slli	r2,r2,4
   20dbc:	1885883a 	add	r2,r3,r2
   20dc0:	10c00017 	ldw	r3,0(r2)
   20dc4:	e0bff717 	ldw	r2,-36(fp)
   20dc8:	1885883a 	add	r2,r3,r2
   20dcc:	e0bffd15 	stw	r2,-12(fp)
   20dd0:	e0bffb17 	ldw	r2,-20(fp)
   20dd4:	e0fffe17 	ldw	r3,-8(fp)
   20dd8:	1885883a 	add	r2,r3,r2
   20ddc:	e0bffe15 	stw	r2,-8(fp)
   20de0:	e0fffa17 	ldw	r3,-24(fp)
   20de4:	e0bff517 	ldw	r2,-44(fp)
   20de8:	10800104 	addi	r2,r2,4
   20dec:	1004913a 	slli	r2,r2,4
   20df0:	1885883a 	add	r2,r3,r2
   20df4:	10800017 	ldw	r2,0(r2)
   20df8:	e0fff717 	ldw	r3,-36(fp)
   20dfc:	1885883a 	add	r2,r3,r2
   20e00:	e0bff715 	stw	r2,-36(fp)
   20e04:	e0bff617 	ldw	r2,-40(fp)
   20e08:	10800044 	addi	r2,r2,1
   20e0c:	e0bff615 	stw	r2,-40(fp)
   20e10:	e0fffa17 	ldw	r3,-24(fp)
   20e14:	e0bff517 	ldw	r2,-44(fp)
   20e18:	1004913a 	slli	r2,r2,4
   20e1c:	1885883a 	add	r2,r3,r2
   20e20:	10800f04 	addi	r2,r2,60
   20e24:	10800017 	ldw	r2,0(r2)
   20e28:	e0fff617 	ldw	r3,-40(fp)
   20e2c:	18bf9b16 	blt	r3,r2,20c9c <alt_flash_cfi_write+0xc4>
   20e30:	e0bff517 	ldw	r2,-44(fp)
   20e34:	10800044 	addi	r2,r2,1
   20e38:	e0bff515 	stw	r2,-44(fp)
   20e3c:	e0bffa17 	ldw	r2,-24(fp)
   20e40:	10800c17 	ldw	r2,48(r2)
   20e44:	e0fff517 	ldw	r3,-44(fp)
   20e48:	18bf7416 	blt	r3,r2,20c1c <alt_flash_cfi_write+0x44>
   20e4c:	e0bffa17 	ldw	r2,-24(fp)
   20e50:	10c00a17 	ldw	r3,40(r2)
   20e54:	e0bff917 	ldw	r2,-28(fp)
   20e58:	1887883a 	add	r3,r3,r2
   20e5c:	e0bff817 	ldw	r2,-32(fp)
   20e60:	1809883a 	mov	r4,r3
   20e64:	100b883a 	mov	r5,r2
   20e68:	002af000 	call	2af00 <alt_dcache_flush>
   20e6c:	e0bff417 	ldw	r2,-48(fp)
   20e70:	e037883a 	mov	sp,fp
   20e74:	dfc00117 	ldw	ra,4(sp)
   20e78:	df000017 	ldw	fp,0(sp)
   20e7c:	dec00204 	addi	sp,sp,8
   20e80:	f800283a 	ret

00020e84 <alt_flash_cfi_get_info>:
   20e84:	defffa04 	addi	sp,sp,-24
   20e88:	df000515 	stw	fp,20(sp)
   20e8c:	df000504 	addi	fp,sp,20
   20e90:	e13ffd15 	stw	r4,-12(fp)
   20e94:	e17ffe15 	stw	r5,-8(fp)
   20e98:	e1bfff15 	stw	r6,-4(fp)
   20e9c:	e03ffb15 	stw	zero,-20(fp)
   20ea0:	e0bffd17 	ldw	r2,-12(fp)
   20ea4:	e0bffc15 	stw	r2,-16(fp)
   20ea8:	e0bffc17 	ldw	r2,-16(fp)
   20eac:	10c00c17 	ldw	r3,48(r2)
   20eb0:	e0bfff17 	ldw	r2,-4(fp)
   20eb4:	10c00015 	stw	r3,0(r2)
   20eb8:	e0bffc17 	ldw	r2,-16(fp)
   20ebc:	10800c17 	ldw	r2,48(r2)
   20ec0:	1000031e 	bne	r2,zero,20ed0 <alt_flash_cfi_get_info+0x4c>
   20ec4:	00bffec4 	movi	r2,-5
   20ec8:	e0bffb15 	stw	r2,-20(fp)
   20ecc:	00000b06 	br	20efc <alt_flash_cfi_get_info+0x78>
   20ed0:	e0bffc17 	ldw	r2,-16(fp)
   20ed4:	10800c17 	ldw	r2,48(r2)
   20ed8:	10800250 	cmplti	r2,r2,9
   20edc:	1000031e 	bne	r2,zero,20eec <alt_flash_cfi_get_info+0x68>
   20ee0:	00bffd04 	movi	r2,-12
   20ee4:	e0bffb15 	stw	r2,-20(fp)
   20ee8:	00000406 	br	20efc <alt_flash_cfi_get_info+0x78>
   20eec:	e0bffc17 	ldw	r2,-16(fp)
   20ef0:	10c00d04 	addi	r3,r2,52
   20ef4:	e0bffe17 	ldw	r2,-8(fp)
   20ef8:	10c00015 	stw	r3,0(r2)
   20efc:	e0bffb17 	ldw	r2,-20(fp)
   20f00:	e037883a 	mov	sp,fp
   20f04:	df000017 	ldw	fp,0(sp)
   20f08:	dec00104 	addi	sp,sp,4
   20f0c:	f800283a 	ret

00020f10 <alt_flash_cfi_read>:
   20f10:	defff904 	addi	sp,sp,-28
   20f14:	dfc00615 	stw	ra,24(sp)
   20f18:	df000515 	stw	fp,20(sp)
   20f1c:	df000504 	addi	fp,sp,20
   20f20:	e13ffc15 	stw	r4,-16(fp)
   20f24:	e17ffd15 	stw	r5,-12(fp)
   20f28:	e1bffe15 	stw	r6,-8(fp)
   20f2c:	e1ffff15 	stw	r7,-4(fp)
   20f30:	e0bffc17 	ldw	r2,-16(fp)
   20f34:	e0bffb15 	stw	r2,-20(fp)
   20f38:	e0bffb17 	ldw	r2,-20(fp)
   20f3c:	10c00a17 	ldw	r3,40(r2)
   20f40:	e0bffd17 	ldw	r2,-12(fp)
   20f44:	1887883a 	add	r3,r3,r2
   20f48:	e0bfff17 	ldw	r2,-4(fp)
   20f4c:	e13ffe17 	ldw	r4,-8(fp)
   20f50:	180b883a 	mov	r5,r3
   20f54:	100d883a 	mov	r6,r2
   20f58:	00164c00 	call	164c0 <memcpy>
   20f5c:	0005883a 	mov	r2,zero
   20f60:	e037883a 	mov	sp,fp
   20f64:	dfc00117 	ldw	ra,4(sp)
   20f68:	df000017 	ldw	fp,0(sp)
   20f6c:	dec00204 	addi	sp,sp,8
   20f70:	f800283a 	ret

00020f74 <alt_write_value_to_flash>:
   20f74:	defffa04 	addi	sp,sp,-24
   20f78:	df000515 	stw	fp,20(sp)
   20f7c:	df000504 	addi	fp,sp,20
   20f80:	e13ffd15 	stw	r4,-12(fp)
   20f84:	e17ffe15 	stw	r5,-8(fp)
   20f88:	e1bfff15 	stw	r6,-4(fp)
   20f8c:	e0bffd17 	ldw	r2,-12(fp)
   20f90:	10802e17 	ldw	r2,184(r2)
   20f94:	10800058 	cmpnei	r2,r2,1
   20f98:	1000091e 	bne	r2,zero,20fc0 <alt_write_value_to_flash+0x4c>
   20f9c:	e0bffd17 	ldw	r2,-12(fp)
   20fa0:	10c00a17 	ldw	r3,40(r2)
   20fa4:	e0bffe17 	ldw	r2,-8(fp)
   20fa8:	1885883a 	add	r2,r3,r2
   20fac:	e0ffff17 	ldw	r3,-4(fp)
   20fb0:	18c00003 	ldbu	r3,0(r3)
   20fb4:	18c03fcc 	andi	r3,r3,255
   20fb8:	10c00025 	stbio	r3,0(r2)
   20fbc:	00003e06 	br	210b8 <alt_write_value_to_flash+0x144>
   20fc0:	e0bffd17 	ldw	r2,-12(fp)
   20fc4:	10802e17 	ldw	r2,184(r2)
   20fc8:	10800098 	cmpnei	r2,r2,2
   20fcc:	1000141e 	bne	r2,zero,21020 <alt_write_value_to_flash+0xac>
   20fd0:	e0bfff17 	ldw	r2,-4(fp)
   20fd4:	10800003 	ldbu	r2,0(r2)
   20fd8:	10803fcc 	andi	r2,r2,255
   20fdc:	e0bffb0d 	sth	r2,-20(fp)
   20fe0:	e0bfff17 	ldw	r2,-4(fp)
   20fe4:	10800044 	addi	r2,r2,1
   20fe8:	10800003 	ldbu	r2,0(r2)
   20fec:	10803fcc 	andi	r2,r2,255
   20ff0:	1004923a 	slli	r2,r2,8
   20ff4:	1007883a 	mov	r3,r2
   20ff8:	e0bffb0b 	ldhu	r2,-20(fp)
   20ffc:	1884b03a 	or	r2,r3,r2
   21000:	e0bffb0d 	sth	r2,-20(fp)
   21004:	e0bffd17 	ldw	r2,-12(fp)
   21008:	10c00a17 	ldw	r3,40(r2)
   2100c:	e0bffe17 	ldw	r2,-8(fp)
   21010:	1885883a 	add	r2,r3,r2
   21014:	e0fffb0b 	ldhu	r3,-20(fp)
   21018:	10c0002d 	sthio	r3,0(r2)
   2101c:	00002606 	br	210b8 <alt_write_value_to_flash+0x144>
   21020:	e0bffd17 	ldw	r2,-12(fp)
   21024:	10802e17 	ldw	r2,184(r2)
   21028:	10800118 	cmpnei	r2,r2,4
   2102c:	1000221e 	bne	r2,zero,210b8 <alt_write_value_to_flash+0x144>
   21030:	e0bfff17 	ldw	r2,-4(fp)
   21034:	10800003 	ldbu	r2,0(r2)
   21038:	10803fcc 	andi	r2,r2,255
   2103c:	e0bffc15 	stw	r2,-16(fp)
   21040:	e0bfff17 	ldw	r2,-4(fp)
   21044:	10800044 	addi	r2,r2,1
   21048:	10800003 	ldbu	r2,0(r2)
   2104c:	10803fcc 	andi	r2,r2,255
   21050:	1004923a 	slli	r2,r2,8
   21054:	e0fffc17 	ldw	r3,-16(fp)
   21058:	1884b03a 	or	r2,r3,r2
   2105c:	e0bffc15 	stw	r2,-16(fp)
   21060:	e0bfff17 	ldw	r2,-4(fp)
   21064:	10800084 	addi	r2,r2,2
   21068:	10800003 	ldbu	r2,0(r2)
   2106c:	10803fcc 	andi	r2,r2,255
   21070:	1004943a 	slli	r2,r2,16
   21074:	e0fffc17 	ldw	r3,-16(fp)
   21078:	1884b03a 	or	r2,r3,r2
   2107c:	e0bffc15 	stw	r2,-16(fp)
   21080:	e0bfff17 	ldw	r2,-4(fp)
   21084:	108000c4 	addi	r2,r2,3
   21088:	10800003 	ldbu	r2,0(r2)
   2108c:	10803fcc 	andi	r2,r2,255
   21090:	1004963a 	slli	r2,r2,24
   21094:	e0fffc17 	ldw	r3,-16(fp)
   21098:	1884b03a 	or	r2,r3,r2
   2109c:	e0bffc15 	stw	r2,-16(fp)
   210a0:	e0bffd17 	ldw	r2,-12(fp)
   210a4:	10c00a17 	ldw	r3,40(r2)
   210a8:	e0bffe17 	ldw	r2,-8(fp)
   210ac:	1885883a 	add	r2,r3,r2
   210b0:	e0fffc17 	ldw	r3,-16(fp)
   210b4:	10c00035 	stwio	r3,0(r2)
   210b8:	0001883a 	nop
   210bc:	e037883a 	mov	sp,fp
   210c0:	df000017 	ldw	fp,0(sp)
   210c4:	dec00104 	addi	sp,sp,4
   210c8:	f800283a 	ret

000210cc <alt_flash_program_block>:
   210cc:	defff304 	addi	sp,sp,-52
   210d0:	dfc00c15 	stw	ra,48(sp)
   210d4:	df000b15 	stw	fp,44(sp)
   210d8:	df000b04 	addi	fp,sp,44
   210dc:	e13ffc15 	stw	r4,-16(fp)
   210e0:	e17ffd15 	stw	r5,-12(fp)
   210e4:	e1bffe15 	stw	r6,-8(fp)
   210e8:	e1ffff15 	stw	r7,-4(fp)
   210ec:	e03ff515 	stw	zero,-44(fp)
   210f0:	e0bffc17 	ldw	r2,-16(fp)
   210f4:	10c00a17 	ldw	r3,40(r2)
   210f8:	e0bffd17 	ldw	r2,-12(fp)
   210fc:	1885883a 	add	r2,r3,r2
   21100:	e0fffc17 	ldw	r3,-16(fp)
   21104:	18c02e17 	ldw	r3,184(r3)
   21108:	10c9283a 	div	r4,r2,r3
   2110c:	20c7383a 	mul	r3,r4,r3
   21110:	10c5c83a 	sub	r2,r2,r3
   21114:	e0bff815 	stw	r2,-32(fp)
   21118:	e0bff817 	ldw	r2,-32(fp)
   2111c:	10003b26 	beq	r2,zero,2120c <alt_flash_program_block+0x140>
   21120:	e0bffc17 	ldw	r2,-16(fp)
   21124:	10c02e17 	ldw	r3,184(r2)
   21128:	e0bff817 	ldw	r2,-32(fp)
   2112c:	1885c83a 	sub	r2,r3,r2
   21130:	e0bff915 	stw	r2,-28(fp)
   21134:	e03ff615 	stw	zero,-40(fp)
   21138:	00001206 	br	21184 <alt_flash_program_block+0xb8>
   2113c:	e0bffc17 	ldw	r2,-16(fp)
   21140:	10c00a17 	ldw	r3,40(r2)
   21144:	e13ffd17 	ldw	r4,-12(fp)
   21148:	e0bff817 	ldw	r2,-32(fp)
   2114c:	2089c83a 	sub	r4,r4,r2
   21150:	e0bff617 	ldw	r2,-40(fp)
   21154:	2085883a 	add	r2,r4,r2
   21158:	1885883a 	add	r2,r3,r2
   2115c:	10800023 	ldbuio	r2,0(r2)
   21160:	10803fcc 	andi	r2,r2,255
   21164:	1007883a 	mov	r3,r2
   21168:	e13ffb04 	addi	r4,fp,-20
   2116c:	e0bff617 	ldw	r2,-40(fp)
   21170:	2085883a 	add	r2,r4,r2
   21174:	10c00005 	stb	r3,0(r2)
   21178:	e0bff617 	ldw	r2,-40(fp)
   2117c:	10800044 	addi	r2,r2,1
   21180:	e0bff615 	stw	r2,-40(fp)
   21184:	e0fff617 	ldw	r3,-40(fp)
   21188:	e0bff817 	ldw	r2,-32(fp)
   2118c:	18bfeb16 	blt	r3,r2,2113c <alt_flash_program_block+0x70>
   21190:	e03ff615 	stw	zero,-40(fp)
   21194:	00000d06 	br	211cc <alt_flash_program_block+0x100>
   21198:	e0fff817 	ldw	r3,-32(fp)
   2119c:	e0bff617 	ldw	r2,-40(fp)
   211a0:	1885883a 	add	r2,r3,r2
   211a4:	e0fff617 	ldw	r3,-40(fp)
   211a8:	e13ffe17 	ldw	r4,-8(fp)
   211ac:	20c7883a 	add	r3,r4,r3
   211b0:	18c00003 	ldbu	r3,0(r3)
   211b4:	e13ffb04 	addi	r4,fp,-20
   211b8:	2085883a 	add	r2,r4,r2
   211bc:	10c00005 	stb	r3,0(r2)
   211c0:	e0bff617 	ldw	r2,-40(fp)
   211c4:	10800044 	addi	r2,r2,1
   211c8:	e0bff615 	stw	r2,-40(fp)
   211cc:	e0fff617 	ldw	r3,-40(fp)
   211d0:	e0bff917 	ldw	r2,-28(fp)
   211d4:	18bff016 	blt	r3,r2,21198 <alt_flash_program_block+0xcc>
   211d8:	e0fffd17 	ldw	r3,-12(fp)
   211dc:	e0bff817 	ldw	r2,-32(fp)
   211e0:	1887c83a 	sub	r3,r3,r2
   211e4:	e0bffb04 	addi	r2,fp,-20
   211e8:	e1c00217 	ldw	r7,8(fp)
   211ec:	e13ffc17 	ldw	r4,-16(fp)
   211f0:	180b883a 	mov	r5,r3
   211f4:	100d883a 	mov	r6,r2
   211f8:	383ee83a 	callr	r7
   211fc:	e0bff515 	stw	r2,-44(fp)
   21200:	e0bff917 	ldw	r2,-28(fp)
   21204:	e0bff615 	stw	r2,-40(fp)
   21208:	00000106 	br	21210 <alt_flash_program_block+0x144>
   2120c:	e03ff615 	stw	zero,-40(fp)
   21210:	e0fffd17 	ldw	r3,-12(fp)
   21214:	e0bfff17 	ldw	r2,-4(fp)
   21218:	1885883a 	add	r2,r3,r2
   2121c:	e0fffc17 	ldw	r3,-16(fp)
   21220:	18c02e17 	ldw	r3,184(r3)
   21224:	10c9283a 	div	r4,r2,r3
   21228:	20c7383a 	mul	r3,r4,r3
   2122c:	10c5c83a 	sub	r2,r2,r3
   21230:	e0bffa15 	stw	r2,-24(fp)
   21234:	00001106 	br	2127c <alt_flash_program_block+0x1b0>
   21238:	e0fffd17 	ldw	r3,-12(fp)
   2123c:	e0bff617 	ldw	r2,-40(fp)
   21240:	1887883a 	add	r3,r3,r2
   21244:	e0bff617 	ldw	r2,-40(fp)
   21248:	e13ffe17 	ldw	r4,-8(fp)
   2124c:	2085883a 	add	r2,r4,r2
   21250:	e1c00217 	ldw	r7,8(fp)
   21254:	e13ffc17 	ldw	r4,-16(fp)
   21258:	180b883a 	mov	r5,r3
   2125c:	100d883a 	mov	r6,r2
   21260:	383ee83a 	callr	r7
   21264:	e0bff515 	stw	r2,-44(fp)
   21268:	e0bffc17 	ldw	r2,-16(fp)
   2126c:	10802e17 	ldw	r2,184(r2)
   21270:	e0fff617 	ldw	r3,-40(fp)
   21274:	1885883a 	add	r2,r3,r2
   21278:	e0bff615 	stw	r2,-40(fp)
   2127c:	e0bff517 	ldw	r2,-44(fp)
   21280:	1000051e 	bne	r2,zero,21298 <alt_flash_program_block+0x1cc>
   21284:	e0ffff17 	ldw	r3,-4(fp)
   21288:	e0bffa17 	ldw	r2,-24(fp)
   2128c:	1885c83a 	sub	r2,r3,r2
   21290:	e0fff617 	ldw	r3,-40(fp)
   21294:	18bfe816 	blt	r3,r2,21238 <alt_flash_program_block+0x16c>
   21298:	e0bffa17 	ldw	r2,-24(fp)
   2129c:	10003b26 	beq	r2,zero,2138c <alt_flash_program_block+0x2c0>
   212a0:	e0bff517 	ldw	r2,-44(fp)
   212a4:	1000391e 	bne	r2,zero,2138c <alt_flash_program_block+0x2c0>
   212a8:	e0bffc17 	ldw	r2,-16(fp)
   212ac:	10c02e17 	ldw	r3,184(r2)
   212b0:	e0bffa17 	ldw	r2,-24(fp)
   212b4:	1885c83a 	sub	r2,r3,r2
   212b8:	e0bff815 	stw	r2,-32(fp)
   212bc:	e03ff715 	stw	zero,-36(fp)
   212c0:	00000d06 	br	212f8 <alt_flash_program_block+0x22c>
   212c4:	e0fff617 	ldw	r3,-40(fp)
   212c8:	e0bff717 	ldw	r2,-36(fp)
   212cc:	1885883a 	add	r2,r3,r2
   212d0:	e0fffe17 	ldw	r3,-8(fp)
   212d4:	1885883a 	add	r2,r3,r2
   212d8:	10c00003 	ldbu	r3,0(r2)
   212dc:	e13ffb04 	addi	r4,fp,-20
   212e0:	e0bff717 	ldw	r2,-36(fp)
   212e4:	2085883a 	add	r2,r4,r2
   212e8:	10c00005 	stb	r3,0(r2)
   212ec:	e0bff717 	ldw	r2,-36(fp)
   212f0:	10800044 	addi	r2,r2,1
   212f4:	e0bff715 	stw	r2,-36(fp)
   212f8:	e0fff717 	ldw	r3,-36(fp)
   212fc:	e0bffa17 	ldw	r2,-24(fp)
   21300:	18bff016 	blt	r3,r2,212c4 <alt_flash_program_block+0x1f8>
   21304:	e03ff715 	stw	zero,-36(fp)
   21308:	00001306 	br	21358 <alt_flash_program_block+0x28c>
   2130c:	e0fffa17 	ldw	r3,-24(fp)
   21310:	e0bff717 	ldw	r2,-36(fp)
   21314:	1885883a 	add	r2,r3,r2
   21318:	e0fffc17 	ldw	r3,-16(fp)
   2131c:	19000a17 	ldw	r4,40(r3)
   21320:	e17ffd17 	ldw	r5,-12(fp)
   21324:	e0ffff17 	ldw	r3,-4(fp)
   21328:	28cb883a 	add	r5,r5,r3
   2132c:	e0fff717 	ldw	r3,-36(fp)
   21330:	28c7883a 	add	r3,r5,r3
   21334:	20c7883a 	add	r3,r4,r3
   21338:	18c00023 	ldbuio	r3,0(r3)
   2133c:	18c03fcc 	andi	r3,r3,255
   21340:	e13ffb04 	addi	r4,fp,-20
   21344:	2085883a 	add	r2,r4,r2
   21348:	10c00005 	stb	r3,0(r2)
   2134c:	e0bff717 	ldw	r2,-36(fp)
   21350:	10800044 	addi	r2,r2,1
   21354:	e0bff715 	stw	r2,-36(fp)
   21358:	e0fff717 	ldw	r3,-36(fp)
   2135c:	e0bff817 	ldw	r2,-32(fp)
   21360:	18bfea16 	blt	r3,r2,2130c <alt_flash_program_block+0x240>
   21364:	e0fffd17 	ldw	r3,-12(fp)
   21368:	e0bff617 	ldw	r2,-40(fp)
   2136c:	1887883a 	add	r3,r3,r2
   21370:	e0bffb04 	addi	r2,fp,-20
   21374:	e1c00217 	ldw	r7,8(fp)
   21378:	e13ffc17 	ldw	r4,-16(fp)
   2137c:	180b883a 	mov	r5,r3
   21380:	100d883a 	mov	r6,r2
   21384:	383ee83a 	callr	r7
   21388:	e0bff515 	stw	r2,-44(fp)
   2138c:	e0bff517 	ldw	r2,-44(fp)
   21390:	e037883a 	mov	sp,fp
   21394:	dfc00117 	ldw	ra,4(sp)
   21398:	df000017 	ldw	fp,0(sp)
   2139c:	dec00204 	addi	sp,sp,8
   213a0:	f800283a 	ret

000213a4 <alt_read_query_entry_8bit>:
   213a4:	defffd04 	addi	sp,sp,-12
   213a8:	df000215 	stw	fp,8(sp)
   213ac:	df000204 	addi	fp,sp,8
   213b0:	e13ffe15 	stw	r4,-8(fp)
   213b4:	e17fff15 	stw	r5,-4(fp)
   213b8:	e0bffe17 	ldw	r2,-8(fp)
   213bc:	10c00a17 	ldw	r3,40(r2)
   213c0:	e0bfff17 	ldw	r2,-4(fp)
   213c4:	1885883a 	add	r2,r3,r2
   213c8:	10800023 	ldbuio	r2,0(r2)
   213cc:	10803fcc 	andi	r2,r2,255
   213d0:	e037883a 	mov	sp,fp
   213d4:	df000017 	ldw	fp,0(sp)
   213d8:	dec00104 	addi	sp,sp,4
   213dc:	f800283a 	ret

000213e0 <alt_read_query_entry_16bit>:
   213e0:	defffd04 	addi	sp,sp,-12
   213e4:	df000215 	stw	fp,8(sp)
   213e8:	df000204 	addi	fp,sp,8
   213ec:	e13ffe15 	stw	r4,-8(fp)
   213f0:	e17fff15 	stw	r5,-4(fp)
   213f4:	e0bffe17 	ldw	r2,-8(fp)
   213f8:	10c00a17 	ldw	r3,40(r2)
   213fc:	e0bfff17 	ldw	r2,-4(fp)
   21400:	1085883a 	add	r2,r2,r2
   21404:	1885883a 	add	r2,r3,r2
   21408:	1080002b 	ldhuio	r2,0(r2)
   2140c:	10bfffcc 	andi	r2,r2,65535
   21410:	e037883a 	mov	sp,fp
   21414:	df000017 	ldw	fp,0(sp)
   21418:	dec00104 	addi	sp,sp,4
   2141c:	f800283a 	ret

00021420 <alt_read_query_entry_32bit>:
   21420:	defffd04 	addi	sp,sp,-12
   21424:	df000215 	stw	fp,8(sp)
   21428:	df000204 	addi	fp,sp,8
   2142c:	e13ffe15 	stw	r4,-8(fp)
   21430:	e17fff15 	stw	r5,-4(fp)
   21434:	e0bffe17 	ldw	r2,-8(fp)
   21438:	10c00a17 	ldw	r3,40(r2)
   2143c:	e0bfff17 	ldw	r2,-4(fp)
   21440:	1085883a 	add	r2,r2,r2
   21444:	1085883a 	add	r2,r2,r2
   21448:	1885883a 	add	r2,r3,r2
   2144c:	10800037 	ldwio	r2,0(r2)
   21450:	e037883a 	mov	sp,fp
   21454:	df000017 	ldw	fp,0(sp)
   21458:	dec00104 	addi	sp,sp,4
   2145c:	f800283a 	ret

00021460 <alt_write_flash_command_8bit_device_8bit_mode>:
   21460:	defffc04 	addi	sp,sp,-16
   21464:	df000315 	stw	fp,12(sp)
   21468:	df000304 	addi	fp,sp,12
   2146c:	e13ffd15 	stw	r4,-12(fp)
   21470:	e17ffe15 	stw	r5,-8(fp)
   21474:	3005883a 	mov	r2,r6
   21478:	e0bfff05 	stb	r2,-4(fp)
   2147c:	e0bffe17 	ldw	r2,-8(fp)
   21480:	e0fffd17 	ldw	r3,-12(fp)
   21484:	1885883a 	add	r2,r3,r2
   21488:	e0ffff03 	ldbu	r3,-4(fp)
   2148c:	10c00025 	stbio	r3,0(r2)
   21490:	0001883a 	nop
   21494:	e037883a 	mov	sp,fp
   21498:	df000017 	ldw	fp,0(sp)
   2149c:	dec00104 	addi	sp,sp,4
   214a0:	f800283a 	ret

000214a4 <alt_write_flash_command_16bit_device_8bit_mode>:
   214a4:	defffc04 	addi	sp,sp,-16
   214a8:	df000315 	stw	fp,12(sp)
   214ac:	df000304 	addi	fp,sp,12
   214b0:	e13ffd15 	stw	r4,-12(fp)
   214b4:	e17ffe15 	stw	r5,-8(fp)
   214b8:	3005883a 	mov	r2,r6
   214bc:	e0bfff05 	stb	r2,-4(fp)
   214c0:	e0bffe17 	ldw	r2,-8(fp)
   214c4:	1080004c 	andi	r2,r2,1
   214c8:	10000726 	beq	r2,zero,214e8 <alt_write_flash_command_16bit_device_8bit_mode+0x44>
   214cc:	e0bffe17 	ldw	r2,-8(fp)
   214d0:	1085883a 	add	r2,r2,r2
   214d4:	e0fffd17 	ldw	r3,-12(fp)
   214d8:	1885883a 	add	r2,r3,r2
   214dc:	e0ffff03 	ldbu	r3,-4(fp)
   214e0:	10c00025 	stbio	r3,0(r2)
   214e4:	00000706 	br	21504 <alt_write_flash_command_16bit_device_8bit_mode+0x60>
   214e8:	e0bffe17 	ldw	r2,-8(fp)
   214ec:	1085883a 	add	r2,r2,r2
   214f0:	10800044 	addi	r2,r2,1
   214f4:	e0fffd17 	ldw	r3,-12(fp)
   214f8:	1885883a 	add	r2,r3,r2
   214fc:	e0ffff03 	ldbu	r3,-4(fp)
   21500:	10c00025 	stbio	r3,0(r2)
   21504:	0001883a 	nop
   21508:	e037883a 	mov	sp,fp
   2150c:	df000017 	ldw	fp,0(sp)
   21510:	dec00104 	addi	sp,sp,4
   21514:	f800283a 	ret

00021518 <alt_write_flash_command_32bit_device_8bit_mode>:
   21518:	defffc04 	addi	sp,sp,-16
   2151c:	df000315 	stw	fp,12(sp)
   21520:	df000304 	addi	fp,sp,12
   21524:	e13ffd15 	stw	r4,-12(fp)
   21528:	e17ffe15 	stw	r5,-8(fp)
   2152c:	3005883a 	mov	r2,r6
   21530:	e0bfff05 	stb	r2,-4(fp)
   21534:	e0bffe17 	ldw	r2,-8(fp)
   21538:	1085883a 	add	r2,r2,r2
   2153c:	1085883a 	add	r2,r2,r2
   21540:	e0fffd17 	ldw	r3,-12(fp)
   21544:	1885883a 	add	r2,r3,r2
   21548:	e0ffff03 	ldbu	r3,-4(fp)
   2154c:	10c00025 	stbio	r3,0(r2)
   21550:	0001883a 	nop
   21554:	e037883a 	mov	sp,fp
   21558:	df000017 	ldw	fp,0(sp)
   2155c:	dec00104 	addi	sp,sp,4
   21560:	f800283a 	ret

00021564 <alt_write_flash_command_16bit_device_16bit_mode>:
   21564:	defffc04 	addi	sp,sp,-16
   21568:	df000315 	stw	fp,12(sp)
   2156c:	df000304 	addi	fp,sp,12
   21570:	e13ffd15 	stw	r4,-12(fp)
   21574:	e17ffe15 	stw	r5,-8(fp)
   21578:	3005883a 	mov	r2,r6
   2157c:	e0bfff05 	stb	r2,-4(fp)
   21580:	e0bffe17 	ldw	r2,-8(fp)
   21584:	1085883a 	add	r2,r2,r2
   21588:	e0fffd17 	ldw	r3,-12(fp)
   2158c:	1885883a 	add	r2,r3,r2
   21590:	e0ffff03 	ldbu	r3,-4(fp)
   21594:	10c0002d 	sthio	r3,0(r2)
   21598:	0001883a 	nop
   2159c:	e037883a 	mov	sp,fp
   215a0:	df000017 	ldw	fp,0(sp)
   215a4:	dec00104 	addi	sp,sp,4
   215a8:	f800283a 	ret

000215ac <alt_write_flash_command_32bit_device_16bit_mode>:
   215ac:	defffc04 	addi	sp,sp,-16
   215b0:	df000315 	stw	fp,12(sp)
   215b4:	df000304 	addi	fp,sp,12
   215b8:	e13ffd15 	stw	r4,-12(fp)
   215bc:	e17ffe15 	stw	r5,-8(fp)
   215c0:	3005883a 	mov	r2,r6
   215c4:	e0bfff05 	stb	r2,-4(fp)
   215c8:	e0bffe17 	ldw	r2,-8(fp)
   215cc:	1085883a 	add	r2,r2,r2
   215d0:	1085883a 	add	r2,r2,r2
   215d4:	e0fffd17 	ldw	r3,-12(fp)
   215d8:	1885883a 	add	r2,r3,r2
   215dc:	e0ffff03 	ldbu	r3,-4(fp)
   215e0:	10c0002d 	sthio	r3,0(r2)
   215e4:	0001883a 	nop
   215e8:	e037883a 	mov	sp,fp
   215ec:	df000017 	ldw	fp,0(sp)
   215f0:	dec00104 	addi	sp,sp,4
   215f4:	f800283a 	ret

000215f8 <alt_write_flash_command_32bit_device_32bit_mode>:
   215f8:	defffc04 	addi	sp,sp,-16
   215fc:	df000315 	stw	fp,12(sp)
   21600:	df000304 	addi	fp,sp,12
   21604:	e13ffd15 	stw	r4,-12(fp)
   21608:	e17ffe15 	stw	r5,-8(fp)
   2160c:	3005883a 	mov	r2,r6
   21610:	e0bfff05 	stb	r2,-4(fp)
   21614:	e0bffe17 	ldw	r2,-8(fp)
   21618:	1085883a 	add	r2,r2,r2
   2161c:	1085883a 	add	r2,r2,r2
   21620:	e0fffd17 	ldw	r3,-12(fp)
   21624:	1885883a 	add	r2,r3,r2
   21628:	e0ffff03 	ldbu	r3,-4(fp)
   2162c:	10c00035 	stwio	r3,0(r2)
   21630:	0001883a 	nop
   21634:	e037883a 	mov	sp,fp
   21638:	df000017 	ldw	fp,0(sp)
   2163c:	dec00104 	addi	sp,sp,4
   21640:	f800283a 	ret

00021644 <alt_write_native_8bit>:
   21644:	defffd04 	addi	sp,sp,-12
   21648:	df000215 	stw	fp,8(sp)
   2164c:	df000204 	addi	fp,sp,8
   21650:	e13ffe15 	stw	r4,-8(fp)
   21654:	e17fff15 	stw	r5,-4(fp)
   21658:	e0bfff17 	ldw	r2,-4(fp)
   2165c:	10c03fcc 	andi	r3,r2,255
   21660:	e0bffe17 	ldw	r2,-8(fp)
   21664:	10c00025 	stbio	r3,0(r2)
   21668:	0001883a 	nop
   2166c:	e037883a 	mov	sp,fp
   21670:	df000017 	ldw	fp,0(sp)
   21674:	dec00104 	addi	sp,sp,4
   21678:	f800283a 	ret

0002167c <alt_write_native_16bit>:
   2167c:	defffd04 	addi	sp,sp,-12
   21680:	df000215 	stw	fp,8(sp)
   21684:	df000204 	addi	fp,sp,8
   21688:	e13ffe15 	stw	r4,-8(fp)
   2168c:	e17fff15 	stw	r5,-4(fp)
   21690:	e0bfff17 	ldw	r2,-4(fp)
   21694:	10ffffcc 	andi	r3,r2,65535
   21698:	e0bffe17 	ldw	r2,-8(fp)
   2169c:	10c0002d 	sthio	r3,0(r2)
   216a0:	0001883a 	nop
   216a4:	e037883a 	mov	sp,fp
   216a8:	df000017 	ldw	fp,0(sp)
   216ac:	dec00104 	addi	sp,sp,4
   216b0:	f800283a 	ret

000216b4 <alt_write_native_32bit>:
   216b4:	defffd04 	addi	sp,sp,-12
   216b8:	df000215 	stw	fp,8(sp)
   216bc:	df000204 	addi	fp,sp,8
   216c0:	e13ffe15 	stw	r4,-8(fp)
   216c4:	e17fff15 	stw	r5,-4(fp)
   216c8:	e0ffff17 	ldw	r3,-4(fp)
   216cc:	e0bffe17 	ldw	r2,-8(fp)
   216d0:	10c00035 	stwio	r3,0(r2)
   216d4:	0001883a 	nop
   216d8:	e037883a 	mov	sp,fp
   216dc:	df000017 	ldw	fp,0(sp)
   216e0:	dec00104 	addi	sp,sp,4
   216e4:	f800283a 	ret

000216e8 <alt_set_flash_width_func>:
   216e8:	defffd04 	addi	sp,sp,-12
   216ec:	df000215 	stw	fp,8(sp)
   216f0:	df000204 	addi	fp,sp,8
   216f4:	e13fff15 	stw	r4,-4(fp)
   216f8:	e03ffe15 	stw	zero,-8(fp)
   216fc:	e0bfff17 	ldw	r2,-4(fp)
   21700:	10802e17 	ldw	r2,184(r2)
   21704:	10c000a0 	cmpeqi	r3,r2,2
   21708:	1800231e 	bne	r3,zero,21798 <alt_set_flash_width_func+0xb0>
   2170c:	10c00120 	cmpeqi	r3,r2,4
   21710:	1800371e 	bne	r3,zero,217f0 <alt_set_flash_width_func+0x108>
   21714:	10800060 	cmpeqi	r2,r2,1
   21718:	10003e26 	beq	r2,zero,21814 <alt_set_flash_width_func+0x12c>
   2171c:	e0bfff17 	ldw	r2,-4(fp)
   21720:	00c000b4 	movhi	r3,2
   21724:	18c59104 	addi	r3,r3,5700
   21728:	10c03515 	stw	r3,212(r2)
   2172c:	e0bfff17 	ldw	r2,-4(fp)
   21730:	10802f17 	ldw	r2,188(r2)
   21734:	10800058 	cmpnei	r2,r2,1
   21738:	1000051e 	bne	r2,zero,21750 <alt_set_flash_width_func+0x68>
   2173c:	e0bfff17 	ldw	r2,-4(fp)
   21740:	00c000b4 	movhi	r3,2
   21744:	18c51804 	addi	r3,r3,5216
   21748:	10c03315 	stw	r3,204(r2)
   2174c:	00003406 	br	21820 <alt_set_flash_width_func+0x138>
   21750:	e0bfff17 	ldw	r2,-4(fp)
   21754:	10802f17 	ldw	r2,188(r2)
   21758:	10800098 	cmpnei	r2,r2,2
   2175c:	1000051e 	bne	r2,zero,21774 <alt_set_flash_width_func+0x8c>
   21760:	e0bfff17 	ldw	r2,-4(fp)
   21764:	00c000b4 	movhi	r3,2
   21768:	18c52904 	addi	r3,r3,5284
   2176c:	10c03315 	stw	r3,204(r2)
   21770:	00002b06 	br	21820 <alt_set_flash_width_func+0x138>
   21774:	e0bfff17 	ldw	r2,-4(fp)
   21778:	10802f17 	ldw	r2,188(r2)
   2177c:	10800118 	cmpnei	r2,r2,4
   21780:	1000271e 	bne	r2,zero,21820 <alt_set_flash_width_func+0x138>
   21784:	e0bfff17 	ldw	r2,-4(fp)
   21788:	00c000b4 	movhi	r3,2
   2178c:	18c54604 	addi	r3,r3,5400
   21790:	10c03315 	stw	r3,204(r2)
   21794:	00002206 	br	21820 <alt_set_flash_width_func+0x138>
   21798:	e0bfff17 	ldw	r2,-4(fp)
   2179c:	00c000b4 	movhi	r3,2
   217a0:	18c59f04 	addi	r3,r3,5756
   217a4:	10c03515 	stw	r3,212(r2)
   217a8:	e0bfff17 	ldw	r2,-4(fp)
   217ac:	10802f17 	ldw	r2,188(r2)
   217b0:	10800098 	cmpnei	r2,r2,2
   217b4:	1000051e 	bne	r2,zero,217cc <alt_set_flash_width_func+0xe4>
   217b8:	e0bfff17 	ldw	r2,-4(fp)
   217bc:	00c000b4 	movhi	r3,2
   217c0:	18c55904 	addi	r3,r3,5476
   217c4:	10c03315 	stw	r3,204(r2)
   217c8:	00001706 	br	21828 <alt_set_flash_width_func+0x140>
   217cc:	e0bfff17 	ldw	r2,-4(fp)
   217d0:	10802f17 	ldw	r2,188(r2)
   217d4:	10800118 	cmpnei	r2,r2,4
   217d8:	1000131e 	bne	r2,zero,21828 <alt_set_flash_width_func+0x140>
   217dc:	e0bfff17 	ldw	r2,-4(fp)
   217e0:	00c000b4 	movhi	r3,2
   217e4:	18c56b04 	addi	r3,r3,5548
   217e8:	10c03315 	stw	r3,204(r2)
   217ec:	00000e06 	br	21828 <alt_set_flash_width_func+0x140>
   217f0:	e0bfff17 	ldw	r2,-4(fp)
   217f4:	00c000b4 	movhi	r3,2
   217f8:	18c5ad04 	addi	r3,r3,5812
   217fc:	10c03515 	stw	r3,212(r2)
   21800:	e0bfff17 	ldw	r2,-4(fp)
   21804:	00c000b4 	movhi	r3,2
   21808:	18c57e04 	addi	r3,r3,5624
   2180c:	10c03315 	stw	r3,204(r2)
   21810:	00000606 	br	2182c <alt_set_flash_width_func+0x144>
   21814:	00bffcc4 	movi	r2,-13
   21818:	e0bffe15 	stw	r2,-8(fp)
   2181c:	00000306 	br	2182c <alt_set_flash_width_func+0x144>
   21820:	0001883a 	nop
   21824:	00000106 	br	2182c <alt_set_flash_width_func+0x144>
   21828:	0001883a 	nop
   2182c:	e0bffe17 	ldw	r2,-8(fp)
   21830:	1000191e 	bne	r2,zero,21898 <alt_set_flash_width_func+0x1b0>
   21834:	e0bfff17 	ldw	r2,-4(fp)
   21838:	10802f17 	ldw	r2,188(r2)
   2183c:	10c000a0 	cmpeqi	r3,r2,2
   21840:	1800091e 	bne	r3,zero,21868 <alt_set_flash_width_func+0x180>
   21844:	10c00120 	cmpeqi	r3,r2,4
   21848:	18000c1e 	bne	r3,zero,2187c <alt_set_flash_width_func+0x194>
   2184c:	10800060 	cmpeqi	r2,r2,1
   21850:	10000f26 	beq	r2,zero,21890 <alt_set_flash_width_func+0x1a8>
   21854:	e0bfff17 	ldw	r2,-4(fp)
   21858:	00c000b4 	movhi	r3,2
   2185c:	18c4e904 	addi	r3,r3,5028
   21860:	10c03415 	stw	r3,208(r2)
   21864:	00000c06 	br	21898 <alt_set_flash_width_func+0x1b0>
   21868:	e0bfff17 	ldw	r2,-4(fp)
   2186c:	00c000b4 	movhi	r3,2
   21870:	18c4f804 	addi	r3,r3,5088
   21874:	10c03415 	stw	r3,208(r2)
   21878:	00000706 	br	21898 <alt_set_flash_width_func+0x1b0>
   2187c:	e0bfff17 	ldw	r2,-4(fp)
   21880:	00c000b4 	movhi	r3,2
   21884:	18c50804 	addi	r3,r3,5152
   21888:	10c03415 	stw	r3,208(r2)
   2188c:	00000206 	br	21898 <alt_set_flash_width_func+0x1b0>
   21890:	00bffcc4 	movi	r2,-13
   21894:	e0bffe15 	stw	r2,-8(fp)
   21898:	e0bffe17 	ldw	r2,-8(fp)
   2189c:	e037883a 	mov	sp,fp
   218a0:	df000017 	ldw	fp,0(sp)
   218a4:	dec00104 	addi	sp,sp,4
   218a8:	f800283a 	ret

000218ac <alt_set_flash_algorithm_func>:
   218ac:	defffd04 	addi	sp,sp,-12
   218b0:	df000215 	stw	fp,8(sp)
   218b4:	df000204 	addi	fp,sp,8
   218b8:	e13fff15 	stw	r4,-4(fp)
   218bc:	e03ffe15 	stw	zero,-8(fp)
   218c0:	e0bfff17 	ldw	r2,-4(fp)
   218c4:	10802d17 	ldw	r2,180(r2)
   218c8:	10c000a0 	cmpeqi	r3,r2,2
   218cc:	1800051e 	bne	r3,zero,218e4 <alt_set_flash_algorithm_func+0x38>
   218d0:	10c000e0 	cmpeqi	r3,r2,3
   218d4:	18000c1e 	bne	r3,zero,21908 <alt_set_flash_algorithm_func+0x5c>
   218d8:	10800060 	cmpeqi	r2,r2,1
   218dc:	10000a1e 	bne	r2,zero,21908 <alt_set_flash_algorithm_func+0x5c>
   218e0:	00001206 	br	2192c <alt_set_flash_algorithm_func+0x80>
   218e4:	e0bfff17 	ldw	r2,-4(fp)
   218e8:	00c000f4 	movhi	r3,3
   218ec:	18ed9c04 	addi	r3,r3,-18832
   218f0:	10c00815 	stw	r3,32(r2)
   218f4:	e0bfff17 	ldw	r2,-4(fp)
   218f8:	00c000f4 	movhi	r3,3
   218fc:	18ed8204 	addi	r3,r3,-18936
   21900:	10c00915 	stw	r3,36(r2)
   21904:	00000b06 	br	21934 <alt_set_flash_algorithm_func+0x88>
   21908:	e0bfff17 	ldw	r2,-4(fp)
   2190c:	00c000f4 	movhi	r3,3
   21910:	18eeba04 	addi	r3,r3,-17688
   21914:	10c00815 	stw	r3,32(r2)
   21918:	e0bfff17 	ldw	r2,-4(fp)
   2191c:	00c000f4 	movhi	r3,3
   21920:	18ee9a04 	addi	r3,r3,-17816
   21924:	10c00915 	stw	r3,36(r2)
   21928:	00000206 	br	21934 <alt_set_flash_algorithm_func+0x88>
   2192c:	00bffec4 	movi	r2,-5
   21930:	e0bffe15 	stw	r2,-8(fp)
   21934:	e0bffe17 	ldw	r2,-8(fp)
   21938:	e037883a 	mov	sp,fp
   2193c:	df000017 	ldw	fp,0(sp)
   21940:	dec00104 	addi	sp,sp,4
   21944:	f800283a 	ret

00021948 <alt_read_16bit_query_entry>:
   21948:	defffb04 	addi	sp,sp,-20
   2194c:	dfc00415 	stw	ra,16(sp)
   21950:	df000315 	stw	fp,12(sp)
   21954:	df000304 	addi	fp,sp,12
   21958:	e13ffe15 	stw	r4,-8(fp)
   2195c:	e17fff15 	stw	r5,-4(fp)
   21960:	e0bffe17 	ldw	r2,-8(fp)
   21964:	10803417 	ldw	r2,208(r2)
   21968:	e13ffe17 	ldw	r4,-8(fp)
   2196c:	e17fff17 	ldw	r5,-4(fp)
   21970:	103ee83a 	callr	r2
   21974:	10803fcc 	andi	r2,r2,255
   21978:	e0bffd0d 	sth	r2,-12(fp)
   2197c:	e0bffe17 	ldw	r2,-8(fp)
   21980:	10c03417 	ldw	r3,208(r2)
   21984:	e0bfff17 	ldw	r2,-4(fp)
   21988:	10800044 	addi	r2,r2,1
   2198c:	e13ffe17 	ldw	r4,-8(fp)
   21990:	100b883a 	mov	r5,r2
   21994:	183ee83a 	callr	r3
   21998:	10803fcc 	andi	r2,r2,255
   2199c:	1004923a 	slli	r2,r2,8
   219a0:	1007883a 	mov	r3,r2
   219a4:	e0bffd0b 	ldhu	r2,-12(fp)
   219a8:	1884b03a 	or	r2,r3,r2
   219ac:	e0bffd0d 	sth	r2,-12(fp)
   219b0:	e0bffd0b 	ldhu	r2,-12(fp)
   219b4:	e037883a 	mov	sp,fp
   219b8:	dfc00117 	ldw	ra,4(sp)
   219bc:	df000017 	ldw	fp,0(sp)
   219c0:	dec00204 	addi	sp,sp,8
   219c4:	f800283a 	ret

000219c8 <alt_read_cfi_table>:
   219c8:	defff304 	addi	sp,sp,-52
   219cc:	dfc00c15 	stw	ra,48(sp)
   219d0:	df000b15 	stw	fp,44(sp)
   219d4:	df000b04 	addi	fp,sp,44
   219d8:	e13fff15 	stw	r4,-4(fp)
   219dc:	e03ff715 	stw	zero,-36(fp)
   219e0:	e03ff815 	stw	zero,-32(fp)
   219e4:	e03ff915 	stw	zero,-28(fp)
   219e8:	e13fff17 	ldw	r4,-4(fp)
   219ec:	00227000 	call	22700 <alt_check_primary_table>
   219f0:	e0bff715 	stw	r2,-36(fp)
   219f4:	e0bff717 	ldw	r2,-36(fp)
   219f8:	10015f1e 	bne	r2,zero,21f78 <alt_read_cfi_table+0x5b0>
   219fc:	e0bfff17 	ldw	r2,-4(fp)
   21a00:	10803417 	ldw	r2,208(r2)
   21a04:	e13fff17 	ldw	r4,-4(fp)
   21a08:	014004c4 	movi	r5,19
   21a0c:	103ee83a 	callr	r2
   21a10:	10c03fcc 	andi	r3,r2,255
   21a14:	e0bfff17 	ldw	r2,-4(fp)
   21a18:	10c02d15 	stw	r3,180(r2)
   21a1c:	e0bfff17 	ldw	r2,-4(fp)
   21a20:	10803417 	ldw	r2,208(r2)
   21a24:	e13fff17 	ldw	r4,-4(fp)
   21a28:	014007c4 	movi	r5,31
   21a2c:	103ee83a 	callr	r2
   21a30:	10803fcc 	andi	r2,r2,255
   21a34:	e0bffa15 	stw	r2,-24(fp)
   21a38:	e0bfff17 	ldw	r2,-4(fp)
   21a3c:	10803417 	ldw	r2,208(r2)
   21a40:	e13fff17 	ldw	r4,-4(fp)
   21a44:	014008c4 	movi	r5,35
   21a48:	103ee83a 	callr	r2
   21a4c:	10803fcc 	andi	r2,r2,255
   21a50:	e0bffb15 	stw	r2,-20(fp)
   21a54:	e0bffa17 	ldw	r2,-24(fp)
   21a58:	10000226 	beq	r2,zero,21a64 <alt_read_cfi_table+0x9c>
   21a5c:	e0bffb17 	ldw	r2,-20(fp)
   21a60:	1000041e 	bne	r2,zero,21a74 <alt_read_cfi_table+0xac>
   21a64:	e0bfff17 	ldw	r2,-4(fp)
   21a68:	00c0fa04 	movi	r3,1000
   21a6c:	10c03015 	stw	r3,192(r2)
   21a70:	00000706 	br	21a90 <alt_read_cfi_table+0xc8>
   21a74:	00c00044 	movi	r3,1
   21a78:	e0bffa17 	ldw	r2,-24(fp)
   21a7c:	1886983a 	sll	r3,r3,r2
   21a80:	e0bffb17 	ldw	r2,-20(fp)
   21a84:	1886983a 	sll	r3,r3,r2
   21a88:	e0bfff17 	ldw	r2,-4(fp)
   21a8c:	10c03015 	stw	r3,192(r2)
   21a90:	e0bfff17 	ldw	r2,-4(fp)
   21a94:	10803417 	ldw	r2,208(r2)
   21a98:	e13fff17 	ldw	r4,-4(fp)
   21a9c:	01400844 	movi	r5,33
   21aa0:	103ee83a 	callr	r2
   21aa4:	10803fcc 	andi	r2,r2,255
   21aa8:	e0bffa15 	stw	r2,-24(fp)
   21aac:	e0bfff17 	ldw	r2,-4(fp)
   21ab0:	10803417 	ldw	r2,208(r2)
   21ab4:	e13fff17 	ldw	r4,-4(fp)
   21ab8:	01400944 	movi	r5,37
   21abc:	103ee83a 	callr	r2
   21ac0:	10803fcc 	andi	r2,r2,255
   21ac4:	e0bffb15 	stw	r2,-20(fp)
   21ac8:	e0bffa17 	ldw	r2,-24(fp)
   21acc:	10000226 	beq	r2,zero,21ad8 <alt_read_cfi_table+0x110>
   21ad0:	e0bffb17 	ldw	r2,-20(fp)
   21ad4:	1000051e 	bne	r2,zero,21aec <alt_read_cfi_table+0x124>
   21ad8:	e0bfff17 	ldw	r2,-4(fp)
   21adc:	00c04c74 	movhi	r3,305
   21ae0:	18cb4004 	addi	r3,r3,11520
   21ae4:	10c03115 	stw	r3,196(r2)
   21ae8:	00000806 	br	21b0c <alt_read_cfi_table+0x144>
   21aec:	00c00044 	movi	r3,1
   21af0:	e0bffa17 	ldw	r2,-24(fp)
   21af4:	1886983a 	sll	r3,r3,r2
   21af8:	e0bffb17 	ldw	r2,-20(fp)
   21afc:	1884983a 	sll	r2,r3,r2
   21b00:	10c0fa24 	muli	r3,r2,1000
   21b04:	e0bfff17 	ldw	r2,-4(fp)
   21b08:	10c03115 	stw	r3,196(r2)
   21b0c:	e0bfff17 	ldw	r2,-4(fp)
   21b10:	10803417 	ldw	r2,208(r2)
   21b14:	e13fff17 	ldw	r4,-4(fp)
   21b18:	014009c4 	movi	r5,39
   21b1c:	103ee83a 	callr	r2
   21b20:	10803fcc 	andi	r2,r2,255
   21b24:	00c00044 	movi	r3,1
   21b28:	1884983a 	sll	r2,r3,r2
   21b2c:	e0bffc15 	stw	r2,-16(fp)
   21b30:	e0bfff17 	ldw	r2,-4(fp)
   21b34:	10803417 	ldw	r2,208(r2)
   21b38:	e13fff17 	ldw	r4,-4(fp)
   21b3c:	01400b04 	movi	r5,44
   21b40:	103ee83a 	callr	r2
   21b44:	10c03fcc 	andi	r3,r2,255
   21b48:	e0bfff17 	ldw	r2,-4(fp)
   21b4c:	10c00c15 	stw	r3,48(r2)
   21b50:	e0bfff17 	ldw	r2,-4(fp)
   21b54:	10800c17 	ldw	r2,48(r2)
   21b58:	10800250 	cmplti	r2,r2,9
   21b5c:	1000031e 	bne	r2,zero,21b6c <alt_read_cfi_table+0x1a4>
   21b60:	00bffd04 	movi	r2,-12
   21b64:	e0bff715 	stw	r2,-36(fp)
   21b68:	00006006 	br	21cec <alt_read_cfi_table+0x324>
   21b6c:	e03ff515 	stw	zero,-44(fp)
   21b70:	00005506 	br	21cc8 <alt_read_cfi_table+0x300>
   21b74:	e0bff517 	ldw	r2,-44(fp)
   21b78:	1085883a 	add	r2,r2,r2
   21b7c:	1085883a 	add	r2,r2,r2
   21b80:	10800b44 	addi	r2,r2,45
   21b84:	e13fff17 	ldw	r4,-4(fp)
   21b88:	100b883a 	mov	r5,r2
   21b8c:	00219480 	call	21948 <alt_read_16bit_query_entry>
   21b90:	10ffffcc 	andi	r3,r2,65535
   21b94:	e13fff17 	ldw	r4,-4(fp)
   21b98:	e0bff517 	ldw	r2,-44(fp)
   21b9c:	1004913a 	slli	r2,r2,4
   21ba0:	2085883a 	add	r2,r4,r2
   21ba4:	10800f04 	addi	r2,r2,60
   21ba8:	10c00015 	stw	r3,0(r2)
   21bac:	e0ffff17 	ldw	r3,-4(fp)
   21bb0:	e0bff517 	ldw	r2,-44(fp)
   21bb4:	1004913a 	slli	r2,r2,4
   21bb8:	1885883a 	add	r2,r3,r2
   21bbc:	10800f04 	addi	r2,r2,60
   21bc0:	10800017 	ldw	r2,0(r2)
   21bc4:	10c00044 	addi	r3,r2,1
   21bc8:	e13fff17 	ldw	r4,-4(fp)
   21bcc:	e0bff517 	ldw	r2,-44(fp)
   21bd0:	1004913a 	slli	r2,r2,4
   21bd4:	2085883a 	add	r2,r4,r2
   21bd8:	10800f04 	addi	r2,r2,60
   21bdc:	10c00015 	stw	r3,0(r2)
   21be0:	e0bff517 	ldw	r2,-44(fp)
   21be4:	1085883a 	add	r2,r2,r2
   21be8:	1085883a 	add	r2,r2,r2
   21bec:	10800bc4 	addi	r2,r2,47
   21bf0:	e13fff17 	ldw	r4,-4(fp)
   21bf4:	100b883a 	mov	r5,r2
   21bf8:	00219480 	call	21948 <alt_read_16bit_query_entry>
   21bfc:	10ffffcc 	andi	r3,r2,65535
   21c00:	e13fff17 	ldw	r4,-4(fp)
   21c04:	e0bff517 	ldw	r2,-44(fp)
   21c08:	10800104 	addi	r2,r2,4
   21c0c:	1004913a 	slli	r2,r2,4
   21c10:	2085883a 	add	r2,r4,r2
   21c14:	10c00015 	stw	r3,0(r2)
   21c18:	e0ffff17 	ldw	r3,-4(fp)
   21c1c:	e0bff517 	ldw	r2,-44(fp)
   21c20:	10800104 	addi	r2,r2,4
   21c24:	1004913a 	slli	r2,r2,4
   21c28:	1885883a 	add	r2,r3,r2
   21c2c:	10800017 	ldw	r2,0(r2)
   21c30:	1006923a 	slli	r3,r2,8
   21c34:	e13fff17 	ldw	r4,-4(fp)
   21c38:	e0bff517 	ldw	r2,-44(fp)
   21c3c:	10800104 	addi	r2,r2,4
   21c40:	1004913a 	slli	r2,r2,4
   21c44:	2085883a 	add	r2,r4,r2
   21c48:	10c00015 	stw	r3,0(r2)
   21c4c:	e0ffff17 	ldw	r3,-4(fp)
   21c50:	e0bff517 	ldw	r2,-44(fp)
   21c54:	1004913a 	slli	r2,r2,4
   21c58:	1885883a 	add	r2,r3,r2
   21c5c:	10800f04 	addi	r2,r2,60
   21c60:	10c00017 	ldw	r3,0(r2)
   21c64:	e13fff17 	ldw	r4,-4(fp)
   21c68:	e0bff517 	ldw	r2,-44(fp)
   21c6c:	10800104 	addi	r2,r2,4
   21c70:	1004913a 	slli	r2,r2,4
   21c74:	2085883a 	add	r2,r4,r2
   21c78:	10800017 	ldw	r2,0(r2)
   21c7c:	1887383a 	mul	r3,r3,r2
   21c80:	e13fff17 	ldw	r4,-4(fp)
   21c84:	e0bff517 	ldw	r2,-44(fp)
   21c88:	1004913a 	slli	r2,r2,4
   21c8c:	2085883a 	add	r2,r4,r2
   21c90:	10800e04 	addi	r2,r2,56
   21c94:	10c00015 	stw	r3,0(r2)
   21c98:	e0ffff17 	ldw	r3,-4(fp)
   21c9c:	e0bff517 	ldw	r2,-44(fp)
   21ca0:	1004913a 	slli	r2,r2,4
   21ca4:	1885883a 	add	r2,r3,r2
   21ca8:	10800e04 	addi	r2,r2,56
   21cac:	10800017 	ldw	r2,0(r2)
   21cb0:	e0fff817 	ldw	r3,-32(fp)
   21cb4:	1885883a 	add	r2,r3,r2
   21cb8:	e0bff815 	stw	r2,-32(fp)
   21cbc:	e0bff517 	ldw	r2,-44(fp)
   21cc0:	10800044 	addi	r2,r2,1
   21cc4:	e0bff515 	stw	r2,-44(fp)
   21cc8:	e0bfff17 	ldw	r2,-4(fp)
   21ccc:	10800c17 	ldw	r2,48(r2)
   21cd0:	e0fff517 	ldw	r3,-44(fp)
   21cd4:	18bfa716 	blt	r3,r2,21b74 <alt_read_cfi_table+0x1ac>
   21cd8:	e0fff817 	ldw	r3,-32(fp)
   21cdc:	e0bffc17 	ldw	r2,-16(fp)
   21ce0:	18800226 	beq	r3,r2,21cec <alt_read_cfi_table+0x324>
   21ce4:	00bffb44 	movi	r2,-19
   21ce8:	e0bff715 	stw	r2,-36(fp)
   21cec:	e0bfff17 	ldw	r2,-4(fp)
   21cf0:	10c03417 	ldw	r3,208(r2)
   21cf4:	e0bfff17 	ldw	r2,-4(fp)
   21cf8:	10803217 	ldw	r2,200(r2)
   21cfc:	108003c4 	addi	r2,r2,15
   21d00:	e13fff17 	ldw	r4,-4(fp)
   21d04:	100b883a 	mov	r5,r2
   21d08:	183ee83a 	callr	r3
   21d0c:	e0bffd05 	stb	r2,-12(fp)
   21d10:	e0bfff17 	ldw	r2,-4(fp)
   21d14:	10802d17 	ldw	r2,180(r2)
   21d18:	10800098 	cmpnei	r2,r2,2
   21d1c:	1000601e 	bne	r2,zero,21ea0 <alt_read_cfi_table+0x4d8>
   21d20:	e0bffd03 	ldbu	r2,-12(fp)
   21d24:	108000d8 	cmpnei	r2,r2,3
   21d28:	10005d1e 	bne	r2,zero,21ea0 <alt_read_cfi_table+0x4d8>
   21d2c:	e0bfff17 	ldw	r2,-4(fp)
   21d30:	10800c17 	ldw	r2,48(r2)
   21d34:	10bfffc4 	addi	r2,r2,-1
   21d38:	e0bff515 	stw	r2,-44(fp)
   21d3c:	e03ff615 	stw	zero,-40(fp)
   21d40:	00005406 	br	21e94 <alt_read_cfi_table+0x4cc>
   21d44:	e0ffff17 	ldw	r3,-4(fp)
   21d48:	e0bff517 	ldw	r2,-44(fp)
   21d4c:	1004913a 	slli	r2,r2,4
   21d50:	1885883a 	add	r2,r3,r2
   21d54:	10800e04 	addi	r2,r2,56
   21d58:	10800017 	ldw	r2,0(r2)
   21d5c:	e0bffe15 	stw	r2,-8(fp)
   21d60:	e0ffff17 	ldw	r3,-4(fp)
   21d64:	e0bff617 	ldw	r2,-40(fp)
   21d68:	1004913a 	slli	r2,r2,4
   21d6c:	1885883a 	add	r2,r3,r2
   21d70:	10800e04 	addi	r2,r2,56
   21d74:	10c00017 	ldw	r3,0(r2)
   21d78:	e13fff17 	ldw	r4,-4(fp)
   21d7c:	e0bff517 	ldw	r2,-44(fp)
   21d80:	1004913a 	slli	r2,r2,4
   21d84:	2085883a 	add	r2,r4,r2
   21d88:	10800e04 	addi	r2,r2,56
   21d8c:	10c00015 	stw	r3,0(r2)
   21d90:	e0ffff17 	ldw	r3,-4(fp)
   21d94:	e0bff617 	ldw	r2,-40(fp)
   21d98:	1004913a 	slli	r2,r2,4
   21d9c:	1885883a 	add	r2,r3,r2
   21da0:	10800e04 	addi	r2,r2,56
   21da4:	e0fffe17 	ldw	r3,-8(fp)
   21da8:	10c00015 	stw	r3,0(r2)
   21dac:	e0ffff17 	ldw	r3,-4(fp)
   21db0:	e0bff517 	ldw	r2,-44(fp)
   21db4:	10800104 	addi	r2,r2,4
   21db8:	1004913a 	slli	r2,r2,4
   21dbc:	1885883a 	add	r2,r3,r2
   21dc0:	10800017 	ldw	r2,0(r2)
   21dc4:	e0bffe15 	stw	r2,-8(fp)
   21dc8:	e0ffff17 	ldw	r3,-4(fp)
   21dcc:	e0bff617 	ldw	r2,-40(fp)
   21dd0:	10800104 	addi	r2,r2,4
   21dd4:	1004913a 	slli	r2,r2,4
   21dd8:	1885883a 	add	r2,r3,r2
   21ddc:	10c00017 	ldw	r3,0(r2)
   21de0:	e13fff17 	ldw	r4,-4(fp)
   21de4:	e0bff517 	ldw	r2,-44(fp)
   21de8:	10800104 	addi	r2,r2,4
   21dec:	1004913a 	slli	r2,r2,4
   21df0:	2085883a 	add	r2,r4,r2
   21df4:	10c00015 	stw	r3,0(r2)
   21df8:	e0ffff17 	ldw	r3,-4(fp)
   21dfc:	e0bff617 	ldw	r2,-40(fp)
   21e00:	10800104 	addi	r2,r2,4
   21e04:	1004913a 	slli	r2,r2,4
   21e08:	1885883a 	add	r2,r3,r2
   21e0c:	e0fffe17 	ldw	r3,-8(fp)
   21e10:	10c00015 	stw	r3,0(r2)
   21e14:	e0ffff17 	ldw	r3,-4(fp)
   21e18:	e0bff517 	ldw	r2,-44(fp)
   21e1c:	1004913a 	slli	r2,r2,4
   21e20:	1885883a 	add	r2,r3,r2
   21e24:	10800f04 	addi	r2,r2,60
   21e28:	10800017 	ldw	r2,0(r2)
   21e2c:	e0bffe15 	stw	r2,-8(fp)
   21e30:	e0ffff17 	ldw	r3,-4(fp)
   21e34:	e0bff617 	ldw	r2,-40(fp)
   21e38:	1004913a 	slli	r2,r2,4
   21e3c:	1885883a 	add	r2,r3,r2
   21e40:	10800f04 	addi	r2,r2,60
   21e44:	10c00017 	ldw	r3,0(r2)
   21e48:	e13fff17 	ldw	r4,-4(fp)
   21e4c:	e0bff517 	ldw	r2,-44(fp)
   21e50:	1004913a 	slli	r2,r2,4
   21e54:	2085883a 	add	r2,r4,r2
   21e58:	10800f04 	addi	r2,r2,60
   21e5c:	10c00015 	stw	r3,0(r2)
   21e60:	e0ffff17 	ldw	r3,-4(fp)
   21e64:	e0bff617 	ldw	r2,-40(fp)
   21e68:	1004913a 	slli	r2,r2,4
   21e6c:	1885883a 	add	r2,r3,r2
   21e70:	10800f04 	addi	r2,r2,60
   21e74:	e0fffe17 	ldw	r3,-8(fp)
   21e78:	10c00015 	stw	r3,0(r2)
   21e7c:	e0bff517 	ldw	r2,-44(fp)
   21e80:	10bfffc4 	addi	r2,r2,-1
   21e84:	e0bff515 	stw	r2,-44(fp)
   21e88:	e0bff617 	ldw	r2,-40(fp)
   21e8c:	10800044 	addi	r2,r2,1
   21e90:	e0bff615 	stw	r2,-40(fp)
   21e94:	e0bff617 	ldw	r2,-40(fp)
   21e98:	e0fff517 	ldw	r3,-44(fp)
   21e9c:	18bfa90e 	bge	r3,r2,21d44 <alt_read_cfi_table+0x37c>
   21ea0:	e03ff515 	stw	zero,-44(fp)
   21ea4:	00001306 	br	21ef4 <alt_read_cfi_table+0x52c>
   21ea8:	e0ffff17 	ldw	r3,-4(fp)
   21eac:	e0bff517 	ldw	r2,-44(fp)
   21eb0:	1004913a 	slli	r2,r2,4
   21eb4:	1885883a 	add	r2,r3,r2
   21eb8:	10800d04 	addi	r2,r2,52
   21ebc:	e0fff917 	ldw	r3,-28(fp)
   21ec0:	10c00015 	stw	r3,0(r2)
   21ec4:	e0ffff17 	ldw	r3,-4(fp)
   21ec8:	e0bff517 	ldw	r2,-44(fp)
   21ecc:	1004913a 	slli	r2,r2,4
   21ed0:	1885883a 	add	r2,r3,r2
   21ed4:	10800e04 	addi	r2,r2,56
   21ed8:	10800017 	ldw	r2,0(r2)
   21edc:	e0fff917 	ldw	r3,-28(fp)
   21ee0:	1885883a 	add	r2,r3,r2
   21ee4:	e0bff915 	stw	r2,-28(fp)
   21ee8:	e0bff517 	ldw	r2,-44(fp)
   21eec:	10800044 	addi	r2,r2,1
   21ef0:	e0bff515 	stw	r2,-44(fp)
   21ef4:	e0bfff17 	ldw	r2,-4(fp)
   21ef8:	10800c17 	ldw	r2,48(r2)
   21efc:	e0fff517 	ldw	r3,-44(fp)
   21f00:	18bfe916 	blt	r3,r2,21ea8 <alt_read_cfi_table+0x4e0>
   21f04:	e0bfff17 	ldw	r2,-4(fp)
   21f08:	10802d17 	ldw	r2,180(r2)
   21f0c:	10c000a0 	cmpeqi	r3,r2,2
   21f10:	1800051e 	bne	r3,zero,21f28 <alt_read_cfi_table+0x560>
   21f14:	10c000e0 	cmpeqi	r3,r2,3
   21f18:	18000c1e 	bne	r3,zero,21f4c <alt_read_cfi_table+0x584>
   21f1c:	10800060 	cmpeqi	r2,r2,1
   21f20:	10000a1e 	bne	r2,zero,21f4c <alt_read_cfi_table+0x584>
   21f24:	00001206 	br	21f70 <alt_read_cfi_table+0x5a8>
   21f28:	e0bfff17 	ldw	r2,-4(fp)
   21f2c:	10c03317 	ldw	r3,204(r2)
   21f30:	e0bfff17 	ldw	r2,-4(fp)
   21f34:	10800a17 	ldw	r2,40(r2)
   21f38:	1009883a 	mov	r4,r2
   21f3c:	01401544 	movi	r5,85
   21f40:	01803c04 	movi	r6,240
   21f44:	183ee83a 	callr	r3
   21f48:	00000b06 	br	21f78 <alt_read_cfi_table+0x5b0>
   21f4c:	e0bfff17 	ldw	r2,-4(fp)
   21f50:	10c03317 	ldw	r3,204(r2)
   21f54:	e0bfff17 	ldw	r2,-4(fp)
   21f58:	10800a17 	ldw	r2,40(r2)
   21f5c:	1009883a 	mov	r4,r2
   21f60:	01401544 	movi	r5,85
   21f64:	01803fc4 	movi	r6,255
   21f68:	183ee83a 	callr	r3
   21f6c:	00000206 	br	21f78 <alt_read_cfi_table+0x5b0>
   21f70:	00bffec4 	movi	r2,-5
   21f74:	e0bff715 	stw	r2,-36(fp)
   21f78:	e0bff717 	ldw	r2,-36(fp)
   21f7c:	e037883a 	mov	sp,fp
   21f80:	dfc00117 	ldw	ra,4(sp)
   21f84:	df000017 	ldw	fp,0(sp)
   21f88:	dec00204 	addi	sp,sp,8
   21f8c:	f800283a 	ret

00021f90 <alt_read_cfi_width>:
   21f90:	defff704 	addi	sp,sp,-36
   21f94:	dfc00815 	stw	ra,32(sp)
   21f98:	df000715 	stw	fp,28(sp)
   21f9c:	df000704 	addi	fp,sp,28
   21fa0:	e13fff15 	stw	r4,-4(fp)
   21fa4:	e03ffa15 	stw	zero,-24(fp)
   21fa8:	e0bfff17 	ldw	r2,-4(fp)
   21fac:	10800a17 	ldw	r2,40(r2)
   21fb0:	1009883a 	mov	r4,r2
   21fb4:	01401544 	movi	r5,85
   21fb8:	01802604 	movi	r6,152
   21fbc:	00214600 	call	21460 <alt_write_flash_command_8bit_device_8bit_mode>
   21fc0:	e03ff915 	stw	zero,-28(fp)
   21fc4:	00000f06 	br	22004 <alt_read_cfi_width+0x74>
   21fc8:	e0bfff17 	ldw	r2,-4(fp)
   21fcc:	10c00a17 	ldw	r3,40(r2)
   21fd0:	e0bff917 	ldw	r2,-28(fp)
   21fd4:	10800404 	addi	r2,r2,16
   21fd8:	1885883a 	add	r2,r3,r2
   21fdc:	10800023 	ldbuio	r2,0(r2)
   21fe0:	10803fcc 	andi	r2,r2,255
   21fe4:	1007883a 	mov	r3,r2
   21fe8:	e13ffb84 	addi	r4,fp,-18
   21fec:	e0bff917 	ldw	r2,-28(fp)
   21ff0:	2085883a 	add	r2,r4,r2
   21ff4:	10c00005 	stb	r3,0(r2)
   21ff8:	e0bff917 	ldw	r2,-28(fp)
   21ffc:	10800044 	addi	r2,r2,1
   22000:	e0bff915 	stw	r2,-28(fp)
   22004:	e0bff917 	ldw	r2,-28(fp)
   22008:	108000d0 	cmplti	r2,r2,3
   2200c:	103fee1e 	bne	r2,zero,21fc8 <alt_read_cfi_width+0x38>
   22010:	e0bffb83 	ldbu	r2,-18(fp)
   22014:	10803fcc 	andi	r2,r2,255
   22018:	10801458 	cmpnei	r2,r2,81
   2201c:	10001d1e 	bne	r2,zero,22094 <alt_read_cfi_width+0x104>
   22020:	e0bffbc3 	ldbu	r2,-17(fp)
   22024:	10803fcc 	andi	r2,r2,255
   22028:	10801498 	cmpnei	r2,r2,82
   2202c:	1000191e 	bne	r2,zero,22094 <alt_read_cfi_width+0x104>
   22030:	e0bffc03 	ldbu	r2,-16(fp)
   22034:	10803fcc 	andi	r2,r2,255
   22038:	10801658 	cmpnei	r2,r2,89
   2203c:	1000151e 	bne	r2,zero,22094 <alt_read_cfi_width+0x104>
   22040:	e0bfff17 	ldw	r2,-4(fp)
   22044:	00c00044 	movi	r3,1
   22048:	10c02e15 	stw	r3,184(r2)
   2204c:	e0bfff17 	ldw	r2,-4(fp)
   22050:	00c00044 	movi	r3,1
   22054:	10c02f15 	stw	r3,188(r2)
   22058:	e0bfff17 	ldw	r2,-4(fp)
   2205c:	10800a17 	ldw	r2,40(r2)
   22060:	10800a04 	addi	r2,r2,40
   22064:	1080002b 	ldhuio	r2,0(r2)
   22068:	10bfffcc 	andi	r2,r2,65535
   2206c:	e0bffb0d 	sth	r2,-20(fp)
   22070:	e0bffb0b 	ldhu	r2,-20(fp)
   22074:	10800044 	addi	r2,r2,1
   22078:	e0bffb0d 	sth	r2,-20(fp)
   2207c:	e0bffb0b 	ldhu	r2,-20(fp)
   22080:	1080004c 	andi	r2,r2,1
   22084:	1001981e 	bne	r2,zero,226e8 <alt_read_cfi_width+0x758>
   22088:	00bffb44 	movi	r2,-19
   2208c:	e0bffa15 	stw	r2,-24(fp)
   22090:	00019506 	br	226e8 <alt_read_cfi_width+0x758>
   22094:	e0bfff17 	ldw	r2,-4(fp)
   22098:	10800a17 	ldw	r2,40(r2)
   2209c:	1009883a 	mov	r4,r2
   220a0:	01401544 	movi	r5,85
   220a4:	01802604 	movi	r6,152
   220a8:	00214a40 	call	214a4 <alt_write_flash_command_16bit_device_8bit_mode>
   220ac:	e03ff915 	stw	zero,-28(fp)
   220b0:	00000f06 	br	220f0 <alt_read_cfi_width+0x160>
   220b4:	e0bfff17 	ldw	r2,-4(fp)
   220b8:	10c00a17 	ldw	r3,40(r2)
   220bc:	e0bff917 	ldw	r2,-28(fp)
   220c0:	10800804 	addi	r2,r2,32
   220c4:	1885883a 	add	r2,r3,r2
   220c8:	10800023 	ldbuio	r2,0(r2)
   220cc:	10803fcc 	andi	r2,r2,255
   220d0:	1007883a 	mov	r3,r2
   220d4:	e13ffb84 	addi	r4,fp,-18
   220d8:	e0bff917 	ldw	r2,-28(fp)
   220dc:	2085883a 	add	r2,r4,r2
   220e0:	10c00005 	stb	r3,0(r2)
   220e4:	e0bff917 	ldw	r2,-28(fp)
   220e8:	10800044 	addi	r2,r2,1
   220ec:	e0bff915 	stw	r2,-28(fp)
   220f0:	e0bff917 	ldw	r2,-28(fp)
   220f4:	10800190 	cmplti	r2,r2,6
   220f8:	103fee1e 	bne	r2,zero,220b4 <alt_read_cfi_width+0x124>
   220fc:	e0bffb83 	ldbu	r2,-18(fp)
   22100:	10803fcc 	andi	r2,r2,255
   22104:	10801458 	cmpnei	r2,r2,81
   22108:	1000291e 	bne	r2,zero,221b0 <alt_read_cfi_width+0x220>
   2210c:	e0bffbc3 	ldbu	r2,-17(fp)
   22110:	10803fcc 	andi	r2,r2,255
   22114:	10801458 	cmpnei	r2,r2,81
   22118:	1000251e 	bne	r2,zero,221b0 <alt_read_cfi_width+0x220>
   2211c:	e0bffc03 	ldbu	r2,-16(fp)
   22120:	10803fcc 	andi	r2,r2,255
   22124:	10801498 	cmpnei	r2,r2,82
   22128:	1000211e 	bne	r2,zero,221b0 <alt_read_cfi_width+0x220>
   2212c:	e0bffc43 	ldbu	r2,-15(fp)
   22130:	10803fcc 	andi	r2,r2,255
   22134:	10801498 	cmpnei	r2,r2,82
   22138:	10001d1e 	bne	r2,zero,221b0 <alt_read_cfi_width+0x220>
   2213c:	e0bffc83 	ldbu	r2,-14(fp)
   22140:	10803fcc 	andi	r2,r2,255
   22144:	10801658 	cmpnei	r2,r2,89
   22148:	1000191e 	bne	r2,zero,221b0 <alt_read_cfi_width+0x220>
   2214c:	e0bffcc3 	ldbu	r2,-13(fp)
   22150:	10803fcc 	andi	r2,r2,255
   22154:	10801658 	cmpnei	r2,r2,89
   22158:	1000151e 	bne	r2,zero,221b0 <alt_read_cfi_width+0x220>
   2215c:	e0bfff17 	ldw	r2,-4(fp)
   22160:	00c00044 	movi	r3,1
   22164:	10c02e15 	stw	r3,184(r2)
   22168:	e0bfff17 	ldw	r2,-4(fp)
   2216c:	00c00084 	movi	r3,2
   22170:	10c02f15 	stw	r3,188(r2)
   22174:	e0bfff17 	ldw	r2,-4(fp)
   22178:	10800a17 	ldw	r2,40(r2)
   2217c:	10801404 	addi	r2,r2,80
   22180:	1080002b 	ldhuio	r2,0(r2)
   22184:	10bfffcc 	andi	r2,r2,65535
   22188:	e0bffb0d 	sth	r2,-20(fp)
   2218c:	e0bffb0b 	ldhu	r2,-20(fp)
   22190:	10800044 	addi	r2,r2,1
   22194:	e0bffb0d 	sth	r2,-20(fp)
   22198:	e0bffb0b 	ldhu	r2,-20(fp)
   2219c:	1080004c 	andi	r2,r2,1
   221a0:	1001511e 	bne	r2,zero,226e8 <alt_read_cfi_width+0x758>
   221a4:	00bffb44 	movi	r2,-19
   221a8:	e0bffa15 	stw	r2,-24(fp)
   221ac:	00014e06 	br	226e8 <alt_read_cfi_width+0x758>
   221b0:	e0bfff17 	ldw	r2,-4(fp)
   221b4:	10800a17 	ldw	r2,40(r2)
   221b8:	1009883a 	mov	r4,r2
   221bc:	01401544 	movi	r5,85
   221c0:	01802604 	movi	r6,152
   221c4:	00215640 	call	21564 <alt_write_flash_command_16bit_device_16bit_mode>
   221c8:	e03ff915 	stw	zero,-28(fp)
   221cc:	00000f06 	br	2220c <alt_read_cfi_width+0x27c>
   221d0:	e0bfff17 	ldw	r2,-4(fp)
   221d4:	10c00a17 	ldw	r3,40(r2)
   221d8:	e0bff917 	ldw	r2,-28(fp)
   221dc:	10800804 	addi	r2,r2,32
   221e0:	1885883a 	add	r2,r3,r2
   221e4:	10800023 	ldbuio	r2,0(r2)
   221e8:	10803fcc 	andi	r2,r2,255
   221ec:	1007883a 	mov	r3,r2
   221f0:	e13ffb84 	addi	r4,fp,-18
   221f4:	e0bff917 	ldw	r2,-28(fp)
   221f8:	2085883a 	add	r2,r4,r2
   221fc:	10c00005 	stb	r3,0(r2)
   22200:	e0bff917 	ldw	r2,-28(fp)
   22204:	10800044 	addi	r2,r2,1
   22208:	e0bff915 	stw	r2,-28(fp)
   2220c:	e0bff917 	ldw	r2,-28(fp)
   22210:	10800190 	cmplti	r2,r2,6
   22214:	103fee1e 	bne	r2,zero,221d0 <alt_read_cfi_width+0x240>
   22218:	e0bffb83 	ldbu	r2,-18(fp)
   2221c:	10803fcc 	andi	r2,r2,255
   22220:	10801458 	cmpnei	r2,r2,81
   22224:	1000261e 	bne	r2,zero,222c0 <alt_read_cfi_width+0x330>
   22228:	e0bffbc3 	ldbu	r2,-17(fp)
   2222c:	10803fcc 	andi	r2,r2,255
   22230:	1000231e 	bne	r2,zero,222c0 <alt_read_cfi_width+0x330>
   22234:	e0bffc03 	ldbu	r2,-16(fp)
   22238:	10803fcc 	andi	r2,r2,255
   2223c:	10801498 	cmpnei	r2,r2,82
   22240:	10001f1e 	bne	r2,zero,222c0 <alt_read_cfi_width+0x330>
   22244:	e0bffc43 	ldbu	r2,-15(fp)
   22248:	10803fcc 	andi	r2,r2,255
   2224c:	10001c1e 	bne	r2,zero,222c0 <alt_read_cfi_width+0x330>
   22250:	e0bffc83 	ldbu	r2,-14(fp)
   22254:	10803fcc 	andi	r2,r2,255
   22258:	10801658 	cmpnei	r2,r2,89
   2225c:	1000181e 	bne	r2,zero,222c0 <alt_read_cfi_width+0x330>
   22260:	e0bffcc3 	ldbu	r2,-13(fp)
   22264:	10803fcc 	andi	r2,r2,255
   22268:	1000151e 	bne	r2,zero,222c0 <alt_read_cfi_width+0x330>
   2226c:	e0bfff17 	ldw	r2,-4(fp)
   22270:	00c00084 	movi	r3,2
   22274:	10c02e15 	stw	r3,184(r2)
   22278:	e0bfff17 	ldw	r2,-4(fp)
   2227c:	00c00084 	movi	r3,2
   22280:	10c02f15 	stw	r3,188(r2)
   22284:	e0bfff17 	ldw	r2,-4(fp)
   22288:	10800a17 	ldw	r2,40(r2)
   2228c:	10801404 	addi	r2,r2,80
   22290:	1080002b 	ldhuio	r2,0(r2)
   22294:	10bfffcc 	andi	r2,r2,65535
   22298:	e0bffb0d 	sth	r2,-20(fp)
   2229c:	e0bffb0b 	ldhu	r2,-20(fp)
   222a0:	10800044 	addi	r2,r2,1
   222a4:	e0bffb0d 	sth	r2,-20(fp)
   222a8:	e0bffb0b 	ldhu	r2,-20(fp)
   222ac:	1080008c 	andi	r2,r2,2
   222b0:	10010d1e 	bne	r2,zero,226e8 <alt_read_cfi_width+0x758>
   222b4:	00bffb44 	movi	r2,-19
   222b8:	e0bffa15 	stw	r2,-24(fp)
   222bc:	00010a06 	br	226e8 <alt_read_cfi_width+0x758>
   222c0:	e0bfff17 	ldw	r2,-4(fp)
   222c4:	10800a17 	ldw	r2,40(r2)
   222c8:	1009883a 	mov	r4,r2
   222cc:	01401544 	movi	r5,85
   222d0:	01802604 	movi	r6,152
   222d4:	00215f80 	call	215f8 <alt_write_flash_command_32bit_device_32bit_mode>
   222d8:	e03ff915 	stw	zero,-28(fp)
   222dc:	00000f06 	br	2231c <alt_read_cfi_width+0x38c>
   222e0:	e0bfff17 	ldw	r2,-4(fp)
   222e4:	10c00a17 	ldw	r3,40(r2)
   222e8:	e0bff917 	ldw	r2,-28(fp)
   222ec:	10801004 	addi	r2,r2,64
   222f0:	1885883a 	add	r2,r3,r2
   222f4:	10800023 	ldbuio	r2,0(r2)
   222f8:	10803fcc 	andi	r2,r2,255
   222fc:	1007883a 	mov	r3,r2
   22300:	e13ffb84 	addi	r4,fp,-18
   22304:	e0bff917 	ldw	r2,-28(fp)
   22308:	2085883a 	add	r2,r4,r2
   2230c:	10c00005 	stb	r3,0(r2)
   22310:	e0bff917 	ldw	r2,-28(fp)
   22314:	10800044 	addi	r2,r2,1
   22318:	e0bff915 	stw	r2,-28(fp)
   2231c:	e0bff917 	ldw	r2,-28(fp)
   22320:	10800310 	cmplti	r2,r2,12
   22324:	103fee1e 	bne	r2,zero,222e0 <alt_read_cfi_width+0x350>
   22328:	e0bffb83 	ldbu	r2,-18(fp)
   2232c:	10803fcc 	andi	r2,r2,255
   22330:	10801458 	cmpnei	r2,r2,81
   22334:	1000371e 	bne	r2,zero,22414 <alt_read_cfi_width+0x484>
   22338:	e0bffbc3 	ldbu	r2,-17(fp)
   2233c:	10803fcc 	andi	r2,r2,255
   22340:	1000341e 	bne	r2,zero,22414 <alt_read_cfi_width+0x484>
   22344:	e0bffc03 	ldbu	r2,-16(fp)
   22348:	10803fcc 	andi	r2,r2,255
   2234c:	1000311e 	bne	r2,zero,22414 <alt_read_cfi_width+0x484>
   22350:	e0bffc43 	ldbu	r2,-15(fp)
   22354:	10803fcc 	andi	r2,r2,255
   22358:	10002e1e 	bne	r2,zero,22414 <alt_read_cfi_width+0x484>
   2235c:	e0bffc83 	ldbu	r2,-14(fp)
   22360:	10803fcc 	andi	r2,r2,255
   22364:	10801498 	cmpnei	r2,r2,82
   22368:	10002a1e 	bne	r2,zero,22414 <alt_read_cfi_width+0x484>
   2236c:	e0bffcc3 	ldbu	r2,-13(fp)
   22370:	10803fcc 	andi	r2,r2,255
   22374:	1000271e 	bne	r2,zero,22414 <alt_read_cfi_width+0x484>
   22378:	e0bffd03 	ldbu	r2,-12(fp)
   2237c:	10803fcc 	andi	r2,r2,255
   22380:	1000241e 	bne	r2,zero,22414 <alt_read_cfi_width+0x484>
   22384:	e0bffd43 	ldbu	r2,-11(fp)
   22388:	10803fcc 	andi	r2,r2,255
   2238c:	1000211e 	bne	r2,zero,22414 <alt_read_cfi_width+0x484>
   22390:	e0bffd83 	ldbu	r2,-10(fp)
   22394:	10803fcc 	andi	r2,r2,255
   22398:	10801658 	cmpnei	r2,r2,89
   2239c:	10001d1e 	bne	r2,zero,22414 <alt_read_cfi_width+0x484>
   223a0:	e0bffdc3 	ldbu	r2,-9(fp)
   223a4:	10803fcc 	andi	r2,r2,255
   223a8:	10001a1e 	bne	r2,zero,22414 <alt_read_cfi_width+0x484>
   223ac:	e0bffe03 	ldbu	r2,-8(fp)
   223b0:	10803fcc 	andi	r2,r2,255
   223b4:	1000171e 	bne	r2,zero,22414 <alt_read_cfi_width+0x484>
   223b8:	e0bffe43 	ldbu	r2,-7(fp)
   223bc:	10803fcc 	andi	r2,r2,255
   223c0:	1000141e 	bne	r2,zero,22414 <alt_read_cfi_width+0x484>
   223c4:	e0bfff17 	ldw	r2,-4(fp)
   223c8:	00c00104 	movi	r3,4
   223cc:	10c02e15 	stw	r3,184(r2)
   223d0:	e0bfff17 	ldw	r2,-4(fp)
   223d4:	00c00104 	movi	r3,4
   223d8:	10c02f15 	stw	r3,188(r2)
   223dc:	e0bfff17 	ldw	r2,-4(fp)
   223e0:	10800a17 	ldw	r2,40(r2)
   223e4:	10802804 	addi	r2,r2,160
   223e8:	10800037 	ldwio	r2,0(r2)
   223ec:	e0bffb0d 	sth	r2,-20(fp)
   223f0:	e0bffb0b 	ldhu	r2,-20(fp)
   223f4:	10800044 	addi	r2,r2,1
   223f8:	e0bffb0d 	sth	r2,-20(fp)
   223fc:	e0bffb0b 	ldhu	r2,-20(fp)
   22400:	1080010c 	andi	r2,r2,4
   22404:	1000b81e 	bne	r2,zero,226e8 <alt_read_cfi_width+0x758>
   22408:	00bffb44 	movi	r2,-19
   2240c:	e0bffa15 	stw	r2,-24(fp)
   22410:	0000b506 	br	226e8 <alt_read_cfi_width+0x758>
   22414:	e0bfff17 	ldw	r2,-4(fp)
   22418:	10800a17 	ldw	r2,40(r2)
   2241c:	1009883a 	mov	r4,r2
   22420:	01401544 	movi	r5,85
   22424:	01802604 	movi	r6,152
   22428:	00215ac0 	call	215ac <alt_write_flash_command_32bit_device_16bit_mode>
   2242c:	e03ff915 	stw	zero,-28(fp)
   22430:	00000f06 	br	22470 <alt_read_cfi_width+0x4e0>
   22434:	e0bfff17 	ldw	r2,-4(fp)
   22438:	10c00a17 	ldw	r3,40(r2)
   2243c:	e0bff917 	ldw	r2,-28(fp)
   22440:	10801004 	addi	r2,r2,64
   22444:	1885883a 	add	r2,r3,r2
   22448:	10800023 	ldbuio	r2,0(r2)
   2244c:	10803fcc 	andi	r2,r2,255
   22450:	1007883a 	mov	r3,r2
   22454:	e13ffb84 	addi	r4,fp,-18
   22458:	e0bff917 	ldw	r2,-28(fp)
   2245c:	2085883a 	add	r2,r4,r2
   22460:	10c00005 	stb	r3,0(r2)
   22464:	e0bff917 	ldw	r2,-28(fp)
   22468:	10800044 	addi	r2,r2,1
   2246c:	e0bff915 	stw	r2,-28(fp)
   22470:	e0bff917 	ldw	r2,-28(fp)
   22474:	10800310 	cmplti	r2,r2,12
   22478:	103fee1e 	bne	r2,zero,22434 <alt_read_cfi_width+0x4a4>
   2247c:	e0bffb83 	ldbu	r2,-18(fp)
   22480:	10803fcc 	andi	r2,r2,255
   22484:	10801458 	cmpnei	r2,r2,81
   22488:	10003a1e 	bne	r2,zero,22574 <alt_read_cfi_width+0x5e4>
   2248c:	e0bffbc3 	ldbu	r2,-17(fp)
   22490:	10803fcc 	andi	r2,r2,255
   22494:	1000371e 	bne	r2,zero,22574 <alt_read_cfi_width+0x5e4>
   22498:	e0bffc03 	ldbu	r2,-16(fp)
   2249c:	10803fcc 	andi	r2,r2,255
   224a0:	10801458 	cmpnei	r2,r2,81
   224a4:	1000331e 	bne	r2,zero,22574 <alt_read_cfi_width+0x5e4>
   224a8:	e0bffc43 	ldbu	r2,-15(fp)
   224ac:	10803fcc 	andi	r2,r2,255
   224b0:	1000301e 	bne	r2,zero,22574 <alt_read_cfi_width+0x5e4>
   224b4:	e0bffc83 	ldbu	r2,-14(fp)
   224b8:	10803fcc 	andi	r2,r2,255
   224bc:	10801498 	cmpnei	r2,r2,82
   224c0:	10002c1e 	bne	r2,zero,22574 <alt_read_cfi_width+0x5e4>
   224c4:	e0bffcc3 	ldbu	r2,-13(fp)
   224c8:	10803fcc 	andi	r2,r2,255
   224cc:	1000291e 	bne	r2,zero,22574 <alt_read_cfi_width+0x5e4>
   224d0:	e0bffd03 	ldbu	r2,-12(fp)
   224d4:	10803fcc 	andi	r2,r2,255
   224d8:	10801498 	cmpnei	r2,r2,82
   224dc:	1000251e 	bne	r2,zero,22574 <alt_read_cfi_width+0x5e4>
   224e0:	e0bffd43 	ldbu	r2,-11(fp)
   224e4:	10803fcc 	andi	r2,r2,255
   224e8:	1000221e 	bne	r2,zero,22574 <alt_read_cfi_width+0x5e4>
   224ec:	e0bffd83 	ldbu	r2,-10(fp)
   224f0:	10803fcc 	andi	r2,r2,255
   224f4:	10801658 	cmpnei	r2,r2,89
   224f8:	10001e1e 	bne	r2,zero,22574 <alt_read_cfi_width+0x5e4>
   224fc:	e0bffdc3 	ldbu	r2,-9(fp)
   22500:	10803fcc 	andi	r2,r2,255
   22504:	10001b1e 	bne	r2,zero,22574 <alt_read_cfi_width+0x5e4>
   22508:	e0bffe03 	ldbu	r2,-8(fp)
   2250c:	10803fcc 	andi	r2,r2,255
   22510:	10801658 	cmpnei	r2,r2,89
   22514:	1000171e 	bne	r2,zero,22574 <alt_read_cfi_width+0x5e4>
   22518:	e0bffe43 	ldbu	r2,-7(fp)
   2251c:	10803fcc 	andi	r2,r2,255
   22520:	1000141e 	bne	r2,zero,22574 <alt_read_cfi_width+0x5e4>
   22524:	e0bfff17 	ldw	r2,-4(fp)
   22528:	00c00084 	movi	r3,2
   2252c:	10c02e15 	stw	r3,184(r2)
   22530:	e0bfff17 	ldw	r2,-4(fp)
   22534:	00c00104 	movi	r3,4
   22538:	10c02f15 	stw	r3,188(r2)
   2253c:	e0bfff17 	ldw	r2,-4(fp)
   22540:	10800a17 	ldw	r2,40(r2)
   22544:	10802804 	addi	r2,r2,160
   22548:	10800037 	ldwio	r2,0(r2)
   2254c:	e0bffb0d 	sth	r2,-20(fp)
   22550:	e0bffb0b 	ldhu	r2,-20(fp)
   22554:	10800044 	addi	r2,r2,1
   22558:	e0bffb0d 	sth	r2,-20(fp)
   2255c:	e0bffb0b 	ldhu	r2,-20(fp)
   22560:	1080010c 	andi	r2,r2,4
   22564:	1000601e 	bne	r2,zero,226e8 <alt_read_cfi_width+0x758>
   22568:	00bffb44 	movi	r2,-19
   2256c:	e0bffa15 	stw	r2,-24(fp)
   22570:	00005d06 	br	226e8 <alt_read_cfi_width+0x758>
   22574:	e0bfff17 	ldw	r2,-4(fp)
   22578:	10800a17 	ldw	r2,40(r2)
   2257c:	1009883a 	mov	r4,r2
   22580:	01401544 	movi	r5,85
   22584:	01802604 	movi	r6,152
   22588:	00215180 	call	21518 <alt_write_flash_command_32bit_device_8bit_mode>
   2258c:	e03ff915 	stw	zero,-28(fp)
   22590:	00000f06 	br	225d0 <alt_read_cfi_width+0x640>
   22594:	e0bfff17 	ldw	r2,-4(fp)
   22598:	10c00a17 	ldw	r3,40(r2)
   2259c:	e0bff917 	ldw	r2,-28(fp)
   225a0:	10801004 	addi	r2,r2,64
   225a4:	1885883a 	add	r2,r3,r2
   225a8:	10800023 	ldbuio	r2,0(r2)
   225ac:	10803fcc 	andi	r2,r2,255
   225b0:	1007883a 	mov	r3,r2
   225b4:	e13ffb84 	addi	r4,fp,-18
   225b8:	e0bff917 	ldw	r2,-28(fp)
   225bc:	2085883a 	add	r2,r4,r2
   225c0:	10c00005 	stb	r3,0(r2)
   225c4:	e0bff917 	ldw	r2,-28(fp)
   225c8:	10800044 	addi	r2,r2,1
   225cc:	e0bff915 	stw	r2,-28(fp)
   225d0:	e0bff917 	ldw	r2,-28(fp)
   225d4:	10800310 	cmplti	r2,r2,12
   225d8:	103fee1e 	bne	r2,zero,22594 <alt_read_cfi_width+0x604>
   225dc:	e0bffb83 	ldbu	r2,-18(fp)
   225e0:	10803fcc 	andi	r2,r2,255
   225e4:	10801458 	cmpnei	r2,r2,81
   225e8:	10003f1e 	bne	r2,zero,226e8 <alt_read_cfi_width+0x758>
   225ec:	e0bffbc3 	ldbu	r2,-17(fp)
   225f0:	10803fcc 	andi	r2,r2,255
   225f4:	10801458 	cmpnei	r2,r2,81
   225f8:	10003b1e 	bne	r2,zero,226e8 <alt_read_cfi_width+0x758>
   225fc:	e0bffc03 	ldbu	r2,-16(fp)
   22600:	10803fcc 	andi	r2,r2,255
   22604:	10801458 	cmpnei	r2,r2,81
   22608:	1000371e 	bne	r2,zero,226e8 <alt_read_cfi_width+0x758>
   2260c:	e0bffc43 	ldbu	r2,-15(fp)
   22610:	10803fcc 	andi	r2,r2,255
   22614:	10801458 	cmpnei	r2,r2,81
   22618:	1000331e 	bne	r2,zero,226e8 <alt_read_cfi_width+0x758>
   2261c:	e0bffc83 	ldbu	r2,-14(fp)
   22620:	10803fcc 	andi	r2,r2,255
   22624:	10801498 	cmpnei	r2,r2,82
   22628:	10002f1e 	bne	r2,zero,226e8 <alt_read_cfi_width+0x758>
   2262c:	e0bffcc3 	ldbu	r2,-13(fp)
   22630:	10803fcc 	andi	r2,r2,255
   22634:	10801498 	cmpnei	r2,r2,82
   22638:	10002b1e 	bne	r2,zero,226e8 <alt_read_cfi_width+0x758>
   2263c:	e0bffd03 	ldbu	r2,-12(fp)
   22640:	10803fcc 	andi	r2,r2,255
   22644:	10801498 	cmpnei	r2,r2,82
   22648:	1000271e 	bne	r2,zero,226e8 <alt_read_cfi_width+0x758>
   2264c:	e0bffd43 	ldbu	r2,-11(fp)
   22650:	10803fcc 	andi	r2,r2,255
   22654:	10801498 	cmpnei	r2,r2,82
   22658:	1000231e 	bne	r2,zero,226e8 <alt_read_cfi_width+0x758>
   2265c:	e0bffd83 	ldbu	r2,-10(fp)
   22660:	10803fcc 	andi	r2,r2,255
   22664:	10801658 	cmpnei	r2,r2,89
   22668:	10001f1e 	bne	r2,zero,226e8 <alt_read_cfi_width+0x758>
   2266c:	e0bffdc3 	ldbu	r2,-9(fp)
   22670:	10803fcc 	andi	r2,r2,255
   22674:	10801658 	cmpnei	r2,r2,89
   22678:	10001b1e 	bne	r2,zero,226e8 <alt_read_cfi_width+0x758>
   2267c:	e0bffe03 	ldbu	r2,-8(fp)
   22680:	10803fcc 	andi	r2,r2,255
   22684:	10801658 	cmpnei	r2,r2,89
   22688:	1000171e 	bne	r2,zero,226e8 <alt_read_cfi_width+0x758>
   2268c:	e0bffe43 	ldbu	r2,-7(fp)
   22690:	10803fcc 	andi	r2,r2,255
   22694:	10801658 	cmpnei	r2,r2,89
   22698:	1000131e 	bne	r2,zero,226e8 <alt_read_cfi_width+0x758>
   2269c:	e0bfff17 	ldw	r2,-4(fp)
   226a0:	00c00044 	movi	r3,1
   226a4:	10c02e15 	stw	r3,184(r2)
   226a8:	e0bfff17 	ldw	r2,-4(fp)
   226ac:	00c00104 	movi	r3,4
   226b0:	10c02f15 	stw	r3,188(r2)
   226b4:	e0bfff17 	ldw	r2,-4(fp)
   226b8:	10800a17 	ldw	r2,40(r2)
   226bc:	10802804 	addi	r2,r2,160
   226c0:	10800037 	ldwio	r2,0(r2)
   226c4:	e0bffb0d 	sth	r2,-20(fp)
   226c8:	e0bffb0b 	ldhu	r2,-20(fp)
   226cc:	10800044 	addi	r2,r2,1
   226d0:	e0bffb0d 	sth	r2,-20(fp)
   226d4:	e0bffb0b 	ldhu	r2,-20(fp)
   226d8:	1080010c 	andi	r2,r2,4
   226dc:	1000021e 	bne	r2,zero,226e8 <alt_read_cfi_width+0x758>
   226e0:	00bffb44 	movi	r2,-19
   226e4:	e0bffa15 	stw	r2,-24(fp)
   226e8:	e0bffa17 	ldw	r2,-24(fp)
   226ec:	e037883a 	mov	sp,fp
   226f0:	dfc00117 	ldw	ra,4(sp)
   226f4:	df000017 	ldw	fp,0(sp)
   226f8:	dec00204 	addi	sp,sp,8
   226fc:	f800283a 	ret

00022700 <alt_check_primary_table>:
   22700:	defffa04 	addi	sp,sp,-24
   22704:	dfc00515 	stw	ra,20(sp)
   22708:	df000415 	stw	fp,16(sp)
   2270c:	df000404 	addi	fp,sp,16
   22710:	e13fff15 	stw	r4,-4(fp)
   22714:	e03ffd15 	stw	zero,-12(fp)
   22718:	e13fff17 	ldw	r4,-4(fp)
   2271c:	01400544 	movi	r5,21
   22720:	00219480 	call	21948 <alt_read_16bit_query_entry>
   22724:	10ffffcc 	andi	r3,r2,65535
   22728:	e0bfff17 	ldw	r2,-4(fp)
   2272c:	10c03215 	stw	r3,200(r2)
   22730:	e03ffc15 	stw	zero,-16(fp)
   22734:	00001006 	br	22778 <alt_check_primary_table+0x78>
   22738:	e0bfff17 	ldw	r2,-4(fp)
   2273c:	10c03417 	ldw	r3,208(r2)
   22740:	e0bfff17 	ldw	r2,-4(fp)
   22744:	11003217 	ldw	r4,200(r2)
   22748:	e0bffc17 	ldw	r2,-16(fp)
   2274c:	2085883a 	add	r2,r4,r2
   22750:	e13fff17 	ldw	r4,-4(fp)
   22754:	100b883a 	mov	r5,r2
   22758:	183ee83a 	callr	r3
   2275c:	e13ffe04 	addi	r4,fp,-8
   22760:	e0fffc17 	ldw	r3,-16(fp)
   22764:	20c7883a 	add	r3,r4,r3
   22768:	18800005 	stb	r2,0(r3)
   2276c:	e0bffc17 	ldw	r2,-16(fp)
   22770:	10800044 	addi	r2,r2,1
   22774:	e0bffc15 	stw	r2,-16(fp)
   22778:	e0bffc17 	ldw	r2,-16(fp)
   2277c:	108000d0 	cmplti	r2,r2,3
   22780:	103fed1e 	bne	r2,zero,22738 <alt_check_primary_table+0x38>
   22784:	e0bffe03 	ldbu	r2,-8(fp)
   22788:	10803fcc 	andi	r2,r2,255
   2278c:	10801418 	cmpnei	r2,r2,80
   22790:	1000081e 	bne	r2,zero,227b4 <alt_check_primary_table+0xb4>
   22794:	e0bffe43 	ldbu	r2,-7(fp)
   22798:	10803fcc 	andi	r2,r2,255
   2279c:	10801498 	cmpnei	r2,r2,82
   227a0:	1000041e 	bne	r2,zero,227b4 <alt_check_primary_table+0xb4>
   227a4:	e0bffe83 	ldbu	r2,-6(fp)
   227a8:	10803fcc 	andi	r2,r2,255
   227ac:	10801260 	cmpeqi	r2,r2,73
   227b0:	1000021e 	bne	r2,zero,227bc <alt_check_primary_table+0xbc>
   227b4:	00bffb44 	movi	r2,-19
   227b8:	e0bffd15 	stw	r2,-12(fp)
   227bc:	e0bffd17 	ldw	r2,-12(fp)
   227c0:	e037883a 	mov	sp,fp
   227c4:	dfc00117 	ldw	ra,4(sp)
   227c8:	df000017 	ldw	fp,0(sp)
   227cc:	dec00204 	addi	sp,sp,8
   227d0:	f800283a 	ret

000227d4 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
   227d4:	defffa04 	addi	sp,sp,-24
   227d8:	dfc00515 	stw	ra,20(sp)
   227dc:	df000415 	stw	fp,16(sp)
   227e0:	df000404 	addi	fp,sp,16
   227e4:	e13ffd15 	stw	r4,-12(fp)
   227e8:	e17ffe15 	stw	r5,-8(fp)
   227ec:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
   227f0:	e0bffd17 	ldw	r2,-12(fp)
   227f4:	10800017 	ldw	r2,0(r2)
   227f8:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
   227fc:	e0bffc17 	ldw	r2,-16(fp)
   22800:	10c00a04 	addi	r3,r2,40
      fd->fd_flags);
   22804:	e0bffd17 	ldw	r2,-12(fp)
int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
   22808:	10800217 	ldw	r2,8(r2)
   2280c:	1809883a 	mov	r4,r3
   22810:	e17ffe17 	ldw	r5,-8(fp)
   22814:	e1bfff17 	ldw	r6,-4(fp)
   22818:	100f883a 	mov	r7,r2
   2281c:	0022dfc0 	call	22dfc <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
   22820:	e037883a 	mov	sp,fp
   22824:	dfc00117 	ldw	ra,4(sp)
   22828:	df000017 	ldw	fp,0(sp)
   2282c:	dec00204 	addi	sp,sp,8
   22830:	f800283a 	ret

00022834 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
   22834:	defffa04 	addi	sp,sp,-24
   22838:	dfc00515 	stw	ra,20(sp)
   2283c:	df000415 	stw	fp,16(sp)
   22840:	df000404 	addi	fp,sp,16
   22844:	e13ffd15 	stw	r4,-12(fp)
   22848:	e17ffe15 	stw	r5,-8(fp)
   2284c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
   22850:	e0bffd17 	ldw	r2,-12(fp)
   22854:	10800017 	ldw	r2,0(r2)
   22858:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
   2285c:	e0bffc17 	ldw	r2,-16(fp)
   22860:	10c00a04 	addi	r3,r2,40
      fd->fd_flags);
   22864:	e0bffd17 	ldw	r2,-12(fp)
int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
   22868:	10800217 	ldw	r2,8(r2)
   2286c:	1809883a 	mov	r4,r3
   22870:	e17ffe17 	ldw	r5,-8(fp)
   22874:	e1bfff17 	ldw	r6,-4(fp)
   22878:	100f883a 	mov	r7,r2
   2287c:	00230400 	call	23040 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
   22880:	e037883a 	mov	sp,fp
   22884:	dfc00117 	ldw	ra,4(sp)
   22888:	df000017 	ldw	fp,0(sp)
   2288c:	dec00204 	addi	sp,sp,8
   22890:	f800283a 	ret

00022894 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
   22894:	defffc04 	addi	sp,sp,-16
   22898:	dfc00315 	stw	ra,12(sp)
   2289c:	df000215 	stw	fp,8(sp)
   228a0:	df000204 	addi	fp,sp,8
   228a4:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
   228a8:	e0bfff17 	ldw	r2,-4(fp)
   228ac:	10800017 	ldw	r2,0(r2)
   228b0:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
   228b4:	e0bffe17 	ldw	r2,-8(fp)
   228b8:	10c00a04 	addi	r3,r2,40
   228bc:	e0bfff17 	ldw	r2,-4(fp)
   228c0:	10800217 	ldw	r2,8(r2)
   228c4:	1809883a 	mov	r4,r3
   228c8:	100b883a 	mov	r5,r2
   228cc:	0022ca00 	call	22ca0 <altera_avalon_jtag_uart_close>
}
   228d0:	e037883a 	mov	sp,fp
   228d4:	dfc00117 	ldw	ra,4(sp)
   228d8:	df000017 	ldw	fp,0(sp)
   228dc:	dec00204 	addi	sp,sp,8
   228e0:	f800283a 	ret

000228e4 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
   228e4:	defffa04 	addi	sp,sp,-24
   228e8:	dfc00515 	stw	ra,20(sp)
   228ec:	df000415 	stw	fp,16(sp)
   228f0:	df000404 	addi	fp,sp,16
   228f4:	e13ffd15 	stw	r4,-12(fp)
   228f8:	e17ffe15 	stw	r5,-8(fp)
   228fc:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
   22900:	e0bffd17 	ldw	r2,-12(fp)
   22904:	10800017 	ldw	r2,0(r2)
   22908:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
   2290c:	e0bffc17 	ldw	r2,-16(fp)
   22910:	10800a04 	addi	r2,r2,40
   22914:	1009883a 	mov	r4,r2
   22918:	e17ffe17 	ldw	r5,-8(fp)
   2291c:	e1bfff17 	ldw	r6,-4(fp)
   22920:	0022d080 	call	22d08 <altera_avalon_jtag_uart_ioctl>
}
   22924:	e037883a 	mov	sp,fp
   22928:	dfc00117 	ldw	ra,4(sp)
   2292c:	df000017 	ldw	fp,0(sp)
   22930:	dec00204 	addi	sp,sp,8
   22934:	f800283a 	ret

00022938 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
   22938:	defffa04 	addi	sp,sp,-24
   2293c:	dfc00515 	stw	ra,20(sp)
   22940:	df000415 	stw	fp,16(sp)
   22944:	df000404 	addi	fp,sp,16
   22948:	e13ffd15 	stw	r4,-12(fp)
   2294c:	e17ffe15 	stw	r5,-8(fp)
   22950:	e1bfff15 	stw	r6,-4(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
   22954:	e0bffd17 	ldw	r2,-12(fp)
   22958:	00c00044 	movi	r3,1
   2295c:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
   22960:	e0bffd17 	ldw	r2,-12(fp)
   22964:	10800017 	ldw	r2,0(r2)
   22968:	10800104 	addi	r2,r2,4
   2296c:	e0fffd17 	ldw	r3,-12(fp)
   22970:	18c00817 	ldw	r3,32(r3)
   22974:	10c00035 	stwio	r3,0(r2)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
   22978:	e0fffe17 	ldw	r3,-8(fp)
   2297c:	e0bfff17 	ldw	r2,-4(fp)
   22980:	d8000015 	stw	zero,0(sp)
   22984:	1809883a 	mov	r4,r3
   22988:	100b883a 	mov	r5,r2
   2298c:	018000b4 	movhi	r6,2
   22990:	318a7e04 	addi	r6,r6,10744
   22994:	e1fffd17 	ldw	r7,-12(fp)
   22998:	002ac800 	call	2ac80 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
   2299c:	e0bffd17 	ldw	r2,-12(fp)
   229a0:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
   229a4:	e0bffd17 	ldw	r2,-12(fp)
   229a8:	10c00204 	addi	r3,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
   229ac:	008000f4 	movhi	r2,3
   229b0:	10961504 	addi	r2,r2,22612
   229b4:	10800017 	ldw	r2,0(r2)
   229b8:	1809883a 	mov	r4,r3
   229bc:	100b883a 	mov	r5,r2
   229c0:	018000b4 	movhi	r6,2
   229c4:	318aff04 	addi	r6,r6,11260
   229c8:	e1fffd17 	ldw	r7,-12(fp)
   229cc:	001fbb40 	call	1fbb4 <alt_alarm_start>
   229d0:	1000040e 	bge	r2,zero,229e4 <altera_avalon_jtag_uart_init+0xac>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
   229d4:	e0bffd17 	ldw	r2,-12(fp)
   229d8:	00e00034 	movhi	r3,32768
   229dc:	18ffffc4 	addi	r3,r3,-1
   229e0:	10c00115 	stw	r3,4(r2)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
   229e4:	e037883a 	mov	sp,fp
   229e8:	dfc00117 	ldw	ra,4(sp)
   229ec:	df000017 	ldw	fp,0(sp)
   229f0:	dec00204 	addi	sp,sp,8
   229f4:	f800283a 	ret

000229f8 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
   229f8:	defff804 	addi	sp,sp,-32
   229fc:	df000715 	stw	fp,28(sp)
   22a00:	df000704 	addi	fp,sp,28
   22a04:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
   22a08:	e0bfff17 	ldw	r2,-4(fp)
   22a0c:	e0bffb15 	stw	r2,-20(fp)
  unsigned int base = sp->base;
   22a10:	e0bffb17 	ldw	r2,-20(fp)
   22a14:	10800017 	ldw	r2,0(r2)
   22a18:	e0bffc15 	stw	r2,-16(fp)
   22a1c:	00000106 	br	22a24 <altera_avalon_jtag_uart_irq+0x2c>
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
   22a20:	0001883a 	nop
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
   22a24:	e0bffc17 	ldw	r2,-16(fp)
   22a28:	10800104 	addi	r2,r2,4
   22a2c:	10800037 	ldwio	r2,0(r2)
   22a30:	e0bffd15 	stw	r2,-12(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
   22a34:	e0bffd17 	ldw	r2,-12(fp)
   22a38:	1080c00c 	andi	r2,r2,768
   22a3c:	10006a26 	beq	r2,zero,22be8 <altera_avalon_jtag_uart_irq+0x1f0>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
   22a40:	e0bffd17 	ldw	r2,-12(fp)
   22a44:	1080400c 	andi	r2,r2,256
   22a48:	10003326 	beq	r2,zero,22b18 <altera_avalon_jtag_uart_irq+0x120>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
   22a4c:	00800074 	movhi	r2,1
   22a50:	e0bff915 	stw	r2,-28(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   22a54:	e0bffb17 	ldw	r2,-20(fp)
   22a58:	10800a17 	ldw	r2,40(r2)
   22a5c:	10800044 	addi	r2,r2,1
   22a60:	1081ffcc 	andi	r2,r2,2047
   22a64:	e0bffe15 	stw	r2,-8(fp)
        if (next == sp->rx_out)
   22a68:	e0bffb17 	ldw	r2,-20(fp)
   22a6c:	10c00b17 	ldw	r3,44(r2)
   22a70:	e0bffe17 	ldw	r2,-8(fp)
   22a74:	18801426 	beq	r3,r2,22ac8 <altera_avalon_jtag_uart_irq+0xd0>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
   22a78:	e0bffc17 	ldw	r2,-16(fp)
   22a7c:	10800037 	ldwio	r2,0(r2)
   22a80:	e0bff915 	stw	r2,-28(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
   22a84:	e0bff917 	ldw	r2,-28(fp)
   22a88:	10a0000c 	andi	r2,r2,32768
   22a8c:	10001026 	beq	r2,zero,22ad0 <altera_avalon_jtag_uart_irq+0xd8>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
   22a90:	e0bffb17 	ldw	r2,-20(fp)
   22a94:	10800a17 	ldw	r2,40(r2)
   22a98:	e0fff917 	ldw	r3,-28(fp)
   22a9c:	e13ffb17 	ldw	r4,-20(fp)
   22aa0:	2085883a 	add	r2,r4,r2
   22aa4:	10800e04 	addi	r2,r2,56
   22aa8:	10c00005 	stb	r3,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   22aac:	e0bffb17 	ldw	r2,-20(fp)
   22ab0:	10800a17 	ldw	r2,40(r2)
   22ab4:	10800044 	addi	r2,r2,1
   22ab8:	10c1ffcc 	andi	r3,r2,2047
   22abc:	e0bffb17 	ldw	r2,-20(fp)
   22ac0:	10c00a15 	stw	r3,40(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }
   22ac4:	003fe306 	br	22a54 <altera_avalon_jtag_uart_irq+0x5c>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
   22ac8:	0001883a 	nop
   22acc:	00000106 	br	22ad4 <altera_avalon_jtag_uart_irq+0xdc>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
   22ad0:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
   22ad4:	e0bff917 	ldw	r2,-28(fp)
   22ad8:	10bfffec 	andhi	r2,r2,65535
   22adc:	10000e26 	beq	r2,zero,22b18 <altera_avalon_jtag_uart_irq+0x120>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
   22ae0:	e0bffb17 	ldw	r2,-20(fp)
   22ae4:	10c00817 	ldw	r3,32(r2)
   22ae8:	00bfff84 	movi	r2,-2
   22aec:	1886703a 	and	r3,r3,r2
   22af0:	e0bffb17 	ldw	r2,-20(fp)
   22af4:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
   22af8:	e0bffc17 	ldw	r2,-16(fp)
   22afc:	10800104 	addi	r2,r2,4
   22b00:	e0fffb17 	ldw	r3,-20(fp)
   22b04:	18c00817 	ldw	r3,32(r3)
   22b08:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
   22b0c:	e0bffc17 	ldw	r2,-16(fp)
   22b10:	10800104 	addi	r2,r2,4
   22b14:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
   22b18:	e0bffd17 	ldw	r2,-12(fp)
   22b1c:	1080800c 	andi	r2,r2,512
   22b20:	103fbf26 	beq	r2,zero,22a20 <altera_avalon_jtag_uart_irq+0x28>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
   22b24:	e0bffd17 	ldw	r2,-12(fp)
   22b28:	1004d43a 	srli	r2,r2,16
   22b2c:	e0bffa15 	stw	r2,-24(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
   22b30:	00001406 	br	22b84 <altera_avalon_jtag_uart_irq+0x18c>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
   22b34:	e0bffc17 	ldw	r2,-16(fp)
   22b38:	e0fffb17 	ldw	r3,-20(fp)
   22b3c:	18c00d17 	ldw	r3,52(r3)
   22b40:	e13ffb17 	ldw	r4,-20(fp)
   22b44:	20c7883a 	add	r3,r4,r3
   22b48:	18c20e04 	addi	r3,r3,2104
   22b4c:	18c00003 	ldbu	r3,0(r3)
   22b50:	18c03fcc 	andi	r3,r3,255
   22b54:	18c0201c 	xori	r3,r3,128
   22b58:	18ffe004 	addi	r3,r3,-128
   22b5c:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   22b60:	e0bffb17 	ldw	r2,-20(fp)
   22b64:	10800d17 	ldw	r2,52(r2)
   22b68:	10800044 	addi	r2,r2,1
   22b6c:	10c1ffcc 	andi	r3,r2,2047
   22b70:	e0bffb17 	ldw	r2,-20(fp)
   22b74:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
   22b78:	e0bffa17 	ldw	r2,-24(fp)
   22b7c:	10bfffc4 	addi	r2,r2,-1
   22b80:	e0bffa15 	stw	r2,-24(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
   22b84:	e0bffa17 	ldw	r2,-24(fp)
   22b88:	10000526 	beq	r2,zero,22ba0 <altera_avalon_jtag_uart_irq+0x1a8>
   22b8c:	e0bffb17 	ldw	r2,-20(fp)
   22b90:	10c00d17 	ldw	r3,52(r2)
   22b94:	e0bffb17 	ldw	r2,-20(fp)
   22b98:	10800c17 	ldw	r2,48(r2)
   22b9c:	18bfe51e 	bne	r3,r2,22b34 <altera_avalon_jtag_uart_irq+0x13c>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
   22ba0:	e0bffa17 	ldw	r2,-24(fp)
   22ba4:	103f9e26 	beq	r2,zero,22a20 <altera_avalon_jtag_uart_irq+0x28>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
   22ba8:	e0bffb17 	ldw	r2,-20(fp)
   22bac:	10c00817 	ldw	r3,32(r2)
   22bb0:	00bfff44 	movi	r2,-3
   22bb4:	1886703a 	and	r3,r3,r2
   22bb8:	e0bffb17 	ldw	r2,-20(fp)
   22bbc:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
   22bc0:	e0bffb17 	ldw	r2,-20(fp)
   22bc4:	10800017 	ldw	r2,0(r2)
   22bc8:	10800104 	addi	r2,r2,4
   22bcc:	e0fffb17 	ldw	r3,-20(fp)
   22bd0:	18c00817 	ldw	r3,32(r3)
   22bd4:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
   22bd8:	e0bffc17 	ldw	r2,-16(fp)
   22bdc:	10800104 	addi	r2,r2,4
   22be0:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
   22be4:	003f8e06 	br	22a20 <altera_avalon_jtag_uart_irq+0x28>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
   22be8:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
   22bec:	e037883a 	mov	sp,fp
   22bf0:	df000017 	ldw	fp,0(sp)
   22bf4:	dec00104 	addi	sp,sp,4
   22bf8:	f800283a 	ret

00022bfc <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
   22bfc:	defffc04 	addi	sp,sp,-16
   22c00:	df000315 	stw	fp,12(sp)
   22c04:	df000304 	addi	fp,sp,12
   22c08:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
   22c0c:	e0bfff17 	ldw	r2,-4(fp)
   22c10:	e0bffd15 	stw	r2,-12(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
   22c14:	e0bffd17 	ldw	r2,-12(fp)
   22c18:	10800017 	ldw	r2,0(r2)
   22c1c:	10800104 	addi	r2,r2,4
   22c20:	10800037 	ldwio	r2,0(r2)
   22c24:	e0bffe15 	stw	r2,-8(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
   22c28:	e0bffe17 	ldw	r2,-8(fp)
   22c2c:	1081000c 	andi	r2,r2,1024
   22c30:	10000a26 	beq	r2,zero,22c5c <altera_avalon_jtag_uart_timeout+0x60>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
   22c34:	e0bffd17 	ldw	r2,-12(fp)
   22c38:	10800017 	ldw	r2,0(r2)
   22c3c:	10800104 	addi	r2,r2,4
   22c40:	e0fffd17 	ldw	r3,-12(fp)
   22c44:	18c00817 	ldw	r3,32(r3)
   22c48:	18c10014 	ori	r3,r3,1024
   22c4c:	10c00035 	stwio	r3,0(r2)
    sp->host_inactive = 0;
   22c50:	e0bffd17 	ldw	r2,-12(fp)
   22c54:	10000915 	stw	zero,36(r2)
   22c58:	00000a06 	br	22c84 <altera_avalon_jtag_uart_timeout+0x88>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
   22c5c:	e0bffd17 	ldw	r2,-12(fp)
   22c60:	10800917 	ldw	r2,36(r2)
   22c64:	00e00034 	movhi	r3,32768
   22c68:	18ffff04 	addi	r3,r3,-4
   22c6c:	18800536 	bltu	r3,r2,22c84 <altera_avalon_jtag_uart_timeout+0x88>
    sp->host_inactive++;
   22c70:	e0bffd17 	ldw	r2,-12(fp)
   22c74:	10800917 	ldw	r2,36(r2)
   22c78:	10c00044 	addi	r3,r2,1
   22c7c:	e0bffd17 	ldw	r2,-12(fp)
   22c80:	10c00915 	stw	r3,36(r2)
   22c84:	008000f4 	movhi	r2,3
   22c88:	10961504 	addi	r2,r2,22612
   22c8c:	10800017 	ldw	r2,0(r2)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
   22c90:	e037883a 	mov	sp,fp
   22c94:	df000017 	ldw	fp,0(sp)
   22c98:	dec00104 	addi	sp,sp,4
   22c9c:	f800283a 	ret

00022ca0 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
   22ca0:	defffd04 	addi	sp,sp,-12
   22ca4:	df000215 	stw	fp,8(sp)
   22ca8:	df000204 	addi	fp,sp,8
   22cac:	e13ffe15 	stw	r4,-8(fp)
   22cb0:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
   22cb4:	00000506 	br	22ccc <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
   22cb8:	e0bfff17 	ldw	r2,-4(fp)
   22cbc:	1090000c 	andi	r2,r2,16384
   22cc0:	10000226 	beq	r2,zero,22ccc <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
   22cc4:	00bffd44 	movi	r2,-11
   22cc8:	00000b06 	br	22cf8 <altera_avalon_jtag_uart_close+0x58>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
   22ccc:	e0bffe17 	ldw	r2,-8(fp)
   22cd0:	10c00d17 	ldw	r3,52(r2)
   22cd4:	e0bffe17 	ldw	r2,-8(fp)
   22cd8:	10800c17 	ldw	r2,48(r2)
   22cdc:	18800526 	beq	r3,r2,22cf4 <altera_avalon_jtag_uart_close+0x54>
   22ce0:	e0bffe17 	ldw	r2,-8(fp)
   22ce4:	10c00917 	ldw	r3,36(r2)
   22ce8:	e0bffe17 	ldw	r2,-8(fp)
   22cec:	10800117 	ldw	r2,4(r2)
   22cf0:	18bff136 	bltu	r3,r2,22cb8 <altera_avalon_jtag_uart_close+0x18>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
   22cf4:	0005883a 	mov	r2,zero
}
   22cf8:	e037883a 	mov	sp,fp
   22cfc:	df000017 	ldw	fp,0(sp)
   22d00:	dec00104 	addi	sp,sp,4
   22d04:	f800283a 	ret

00022d08 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
   22d08:	defffa04 	addi	sp,sp,-24
   22d0c:	df000515 	stw	fp,20(sp)
   22d10:	df000504 	addi	fp,sp,20
   22d14:	e13ffd15 	stw	r4,-12(fp)
   22d18:	e17ffe15 	stw	r5,-8(fp)
   22d1c:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
   22d20:	00bff9c4 	movi	r2,-25
   22d24:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
   22d28:	e0bffe17 	ldw	r2,-8(fp)
   22d2c:	10da8060 	cmpeqi	r3,r2,27137
   22d30:	1800031e 	bne	r3,zero,22d40 <altera_avalon_jtag_uart_ioctl+0x38>
   22d34:	109a80a0 	cmpeqi	r2,r2,27138
   22d38:	1000181e 	bne	r2,zero,22d9c <altera_avalon_jtag_uart_ioctl+0x94>
   22d3c:	00002606 	br	22dd8 <altera_avalon_jtag_uart_ioctl+0xd0>
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
   22d40:	e0bffd17 	ldw	r2,-12(fp)
   22d44:	10c00117 	ldw	r3,4(r2)
   22d48:	00a00034 	movhi	r2,32768
   22d4c:	10bfffc4 	addi	r2,r2,-1
   22d50:	18802226 	beq	r3,r2,22ddc <altera_avalon_jtag_uart_ioctl+0xd4>
    {
      int timeout = *((int *)arg);
   22d54:	e0bfff17 	ldw	r2,-4(fp)
   22d58:	10800017 	ldw	r2,0(r2)
   22d5c:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
   22d60:	e0bffc17 	ldw	r2,-16(fp)
   22d64:	10800090 	cmplti	r2,r2,2
   22d68:	1000061e 	bne	r2,zero,22d84 <altera_avalon_jtag_uart_ioctl+0x7c>
   22d6c:	e0fffc17 	ldw	r3,-16(fp)
   22d70:	00a00034 	movhi	r2,32768
   22d74:	10bfffc4 	addi	r2,r2,-1
   22d78:	18800226 	beq	r3,r2,22d84 <altera_avalon_jtag_uart_ioctl+0x7c>
   22d7c:	e0bffc17 	ldw	r2,-16(fp)
   22d80:	00000206 	br	22d8c <altera_avalon_jtag_uart_ioctl+0x84>
   22d84:	00a00034 	movhi	r2,32768
   22d88:	10bfff84 	addi	r2,r2,-2
   22d8c:	e0fffd17 	ldw	r3,-12(fp)
   22d90:	18800115 	stw	r2,4(r3)
      rc = 0;
   22d94:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
   22d98:	00001006 	br	22ddc <altera_avalon_jtag_uart_ioctl+0xd4>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
   22d9c:	e0bffd17 	ldw	r2,-12(fp)
   22da0:	10c00117 	ldw	r3,4(r2)
   22da4:	00a00034 	movhi	r2,32768
   22da8:	10bfffc4 	addi	r2,r2,-1
   22dac:	18800d26 	beq	r3,r2,22de4 <altera_avalon_jtag_uart_ioctl+0xdc>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
   22db0:	e0bffd17 	ldw	r2,-12(fp)
   22db4:	10c00917 	ldw	r3,36(r2)
   22db8:	e0bffd17 	ldw	r2,-12(fp)
   22dbc:	10800117 	ldw	r2,4(r2)
   22dc0:	1885803a 	cmpltu	r2,r3,r2
   22dc4:	10c03fcc 	andi	r3,r2,255
   22dc8:	e0bfff17 	ldw	r2,-4(fp)
   22dcc:	10c00015 	stw	r3,0(r2)
      rc = 0;
   22dd0:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
   22dd4:	00000306 	br	22de4 <altera_avalon_jtag_uart_ioctl+0xdc>

  default:
    break;
   22dd8:	00000306 	br	22de8 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
   22ddc:	0001883a 	nop
   22de0:	00000106 	br	22de8 <altera_avalon_jtag_uart_ioctl+0xe0>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
   22de4:	0001883a 	nop

  default:
    break;
  }

  return rc;
   22de8:	e0bffb17 	ldw	r2,-20(fp)
}
   22dec:	e037883a 	mov	sp,fp
   22df0:	df000017 	ldw	fp,0(sp)
   22df4:	dec00104 	addi	sp,sp,4
   22df8:	f800283a 	ret

00022dfc <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
   22dfc:	defff204 	addi	sp,sp,-56
   22e00:	dfc00d15 	stw	ra,52(sp)
   22e04:	df000c15 	stw	fp,48(sp)
   22e08:	df000c04 	addi	fp,sp,48
   22e0c:	e13ffc15 	stw	r4,-16(fp)
   22e10:	e17ffd15 	stw	r5,-12(fp)
   22e14:	e1bffe15 	stw	r6,-8(fp)
   22e18:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
   22e1c:	e0bffd17 	ldw	r2,-12(fp)
   22e20:	e0bff415 	stw	r2,-48(fp)
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
   22e24:	00004706 	br	22f44 <altera_avalon_jtag_uart_read+0x148>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
   22e28:	e0bffc17 	ldw	r2,-16(fp)
   22e2c:	10800a17 	ldw	r2,40(r2)
   22e30:	e0bff615 	stw	r2,-40(fp)
      out = sp->rx_out;
   22e34:	e0bffc17 	ldw	r2,-16(fp)
   22e38:	10800b17 	ldw	r2,44(r2)
   22e3c:	e0bff715 	stw	r2,-36(fp)

      if (in >= out)
   22e40:	e0fff617 	ldw	r3,-40(fp)
   22e44:	e0bff717 	ldw	r2,-36(fp)
   22e48:	18800536 	bltu	r3,r2,22e60 <altera_avalon_jtag_uart_read+0x64>
        n = in - out;
   22e4c:	e0fff617 	ldw	r3,-40(fp)
   22e50:	e0bff717 	ldw	r2,-36(fp)
   22e54:	1885c83a 	sub	r2,r3,r2
   22e58:	e0bff515 	stw	r2,-44(fp)
   22e5c:	00000406 	br	22e70 <altera_avalon_jtag_uart_read+0x74>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
   22e60:	00c20004 	movi	r3,2048
   22e64:	e0bff717 	ldw	r2,-36(fp)
   22e68:	1885c83a 	sub	r2,r3,r2
   22e6c:	e0bff515 	stw	r2,-44(fp)

      if (n == 0)
   22e70:	e0bff517 	ldw	r2,-44(fp)
   22e74:	10001e26 	beq	r2,zero,22ef0 <altera_avalon_jtag_uart_read+0xf4>
        break; /* No more data available */

      if (n > space)
   22e78:	e0fffe17 	ldw	r3,-8(fp)
   22e7c:	e0bff517 	ldw	r2,-44(fp)
   22e80:	1880022e 	bgeu	r3,r2,22e8c <altera_avalon_jtag_uart_read+0x90>
        n = space;
   22e84:	e0bffe17 	ldw	r2,-8(fp)
   22e88:	e0bff515 	stw	r2,-44(fp)

      memcpy(ptr, sp->rx_buf + out, n);
   22e8c:	e0bff717 	ldw	r2,-36(fp)
   22e90:	10800e04 	addi	r2,r2,56
   22e94:	e0fffc17 	ldw	r3,-16(fp)
   22e98:	1885883a 	add	r2,r3,r2
   22e9c:	e13ff417 	ldw	r4,-48(fp)
   22ea0:	100b883a 	mov	r5,r2
   22ea4:	e1bff517 	ldw	r6,-44(fp)
   22ea8:	00164c00 	call	164c0 <memcpy>
      ptr   += n;
   22eac:	e0fff417 	ldw	r3,-48(fp)
   22eb0:	e0bff517 	ldw	r2,-44(fp)
   22eb4:	1885883a 	add	r2,r3,r2
   22eb8:	e0bff415 	stw	r2,-48(fp)
      space -= n;
   22ebc:	e0fffe17 	ldw	r3,-8(fp)
   22ec0:	e0bff517 	ldw	r2,-44(fp)
   22ec4:	1885c83a 	sub	r2,r3,r2
   22ec8:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   22ecc:	e0fff717 	ldw	r3,-36(fp)
   22ed0:	e0bff517 	ldw	r2,-44(fp)
   22ed4:	1885883a 	add	r2,r3,r2
   22ed8:	10c1ffcc 	andi	r3,r2,2047
   22edc:	e0bffc17 	ldw	r2,-16(fp)
   22ee0:	10c00b15 	stw	r3,44(r2)
    }
    while (space > 0);
   22ee4:	e0bffe17 	ldw	r2,-8(fp)
   22ee8:	00bfcf16 	blt	zero,r2,22e28 <altera_avalon_jtag_uart_read+0x2c>
   22eec:	00000106 	br	22ef4 <altera_avalon_jtag_uart_read+0xf8>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
   22ef0:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
   22ef4:	e0fff417 	ldw	r3,-48(fp)
   22ef8:	e0bffd17 	ldw	r2,-12(fp)
   22efc:	1880141e 	bne	r3,r2,22f50 <altera_avalon_jtag_uart_read+0x154>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
   22f00:	e0bfff17 	ldw	r2,-4(fp)
   22f04:	1090000c 	andi	r2,r2,16384
   22f08:	1000131e 	bne	r2,zero,22f58 <altera_avalon_jtag_uart_read+0x15c>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
   22f0c:	0001883a 	nop
   22f10:	e0bffc17 	ldw	r2,-16(fp)
   22f14:	10c00a17 	ldw	r3,40(r2)
   22f18:	e0bff617 	ldw	r2,-40(fp)
   22f1c:	1880051e 	bne	r3,r2,22f34 <altera_avalon_jtag_uart_read+0x138>
   22f20:	e0bffc17 	ldw	r2,-16(fp)
   22f24:	10c00917 	ldw	r3,36(r2)
   22f28:	e0bffc17 	ldw	r2,-16(fp)
   22f2c:	10800117 	ldw	r2,4(r2)
   22f30:	18bff736 	bltu	r3,r2,22f10 <altera_avalon_jtag_uart_read+0x114>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
   22f34:	e0bffc17 	ldw	r2,-16(fp)
   22f38:	10c00a17 	ldw	r3,40(r2)
   22f3c:	e0bff617 	ldw	r2,-40(fp)
   22f40:	18800726 	beq	r3,r2,22f60 <altera_avalon_jtag_uart_read+0x164>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
   22f44:	e0bffe17 	ldw	r2,-8(fp)
   22f48:	00bfb716 	blt	zero,r2,22e28 <altera_avalon_jtag_uart_read+0x2c>
   22f4c:	00000506 	br	22f64 <altera_avalon_jtag_uart_read+0x168>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
   22f50:	0001883a 	nop
   22f54:	00000306 	br	22f64 <altera_avalon_jtag_uart_read+0x168>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
   22f58:	0001883a 	nop
   22f5c:	00000106 	br	22f64 <altera_avalon_jtag_uart_read+0x168>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
   22f60:	0001883a 	nop
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);

  if (ptr != buffer)
   22f64:	e0fff417 	ldw	r3,-48(fp)
   22f68:	e0bffd17 	ldw	r2,-12(fp)
   22f6c:	18802226 	beq	r3,r2,22ff8 <altera_avalon_jtag_uart_read+0x1fc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   22f70:	0005303a 	rdctl	r2,status
   22f74:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   22f78:	e0fff917 	ldw	r3,-28(fp)
   22f7c:	00bfff84 	movi	r2,-2
   22f80:	1884703a 	and	r2,r3,r2
   22f84:	1001703a 	wrctl	status,r2
  
  return context;
   22f88:	e0bff917 	ldw	r2,-28(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
   22f8c:	e0bff815 	stw	r2,-32(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
   22f90:	e0bffc17 	ldw	r2,-16(fp)
   22f94:	10800817 	ldw	r2,32(r2)
   22f98:	10c00054 	ori	r3,r2,1
   22f9c:	e0bffc17 	ldw	r2,-16(fp)
   22fa0:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
   22fa4:	e0bffc17 	ldw	r2,-16(fp)
   22fa8:	10800017 	ldw	r2,0(r2)
   22fac:	10800104 	addi	r2,r2,4
   22fb0:	e0fffc17 	ldw	r3,-16(fp)
   22fb4:	18c00817 	ldw	r3,32(r3)
   22fb8:	10c00035 	stwio	r3,0(r2)
   22fbc:	e0bff817 	ldw	r2,-32(fp)
   22fc0:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   22fc4:	0005303a 	rdctl	r2,status
   22fc8:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   22fcc:	e0fffb17 	ldw	r3,-20(fp)
   22fd0:	00bfff84 	movi	r2,-2
   22fd4:	1884703a 	and	r2,r3,r2
   22fd8:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   22fdc:	e0bffa17 	ldw	r2,-24(fp)
   22fe0:	1080004c 	andi	r2,r2,1
   22fe4:	e0fffb17 	ldw	r3,-20(fp)
   22fe8:	1884b03a 	or	r2,r3,r2
   22fec:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
   22ff0:	e0bffb17 	ldw	r2,-20(fp)
   22ff4:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
   22ff8:	e0fff417 	ldw	r3,-48(fp)
   22ffc:	e0bffd17 	ldw	r2,-12(fp)
   23000:	18800426 	beq	r3,r2,23014 <altera_avalon_jtag_uart_read+0x218>
    return ptr - buffer;
   23004:	e0fff417 	ldw	r3,-48(fp)
   23008:	e0bffd17 	ldw	r2,-12(fp)
   2300c:	1885c83a 	sub	r2,r3,r2
   23010:	00000606 	br	2302c <altera_avalon_jtag_uart_read+0x230>
  else if (flags & O_NONBLOCK)
   23014:	e0bfff17 	ldw	r2,-4(fp)
   23018:	1090000c 	andi	r2,r2,16384
   2301c:	10000226 	beq	r2,zero,23028 <altera_avalon_jtag_uart_read+0x22c>
    return -EWOULDBLOCK;
   23020:	00bffd44 	movi	r2,-11
   23024:	00000106 	br	2302c <altera_avalon_jtag_uart_read+0x230>
  else
    return -EIO;
   23028:	00bffec4 	movi	r2,-5
}
   2302c:	e037883a 	mov	sp,fp
   23030:	dfc00117 	ldw	ra,4(sp)
   23034:	df000017 	ldw	fp,0(sp)
   23038:	dec00204 	addi	sp,sp,8
   2303c:	f800283a 	ret

00023040 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
   23040:	defff204 	addi	sp,sp,-56
   23044:	dfc00d15 	stw	ra,52(sp)
   23048:	df000c15 	stw	fp,48(sp)
   2304c:	df000c04 	addi	fp,sp,48
   23050:	e13ffc15 	stw	r4,-16(fp)
   23054:	e17ffd15 	stw	r5,-12(fp)
   23058:	e1bffe15 	stw	r6,-8(fp)
   2305c:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
   23060:	e03ff415 	stw	zero,-48(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
   23064:	e0bffd17 	ldw	r2,-12(fp)
   23068:	e0bff615 	stw	r2,-40(fp)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
   2306c:	00003706 	br	2314c <altera_avalon_jtag_uart_write+0x10c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
   23070:	e0bffc17 	ldw	r2,-16(fp)
   23074:	10800c17 	ldw	r2,48(r2)
   23078:	e0bff715 	stw	r2,-36(fp)
      out = sp->tx_out;
   2307c:	e0bffc17 	ldw	r2,-16(fp)
   23080:	10800d17 	ldw	r2,52(r2)
   23084:	e0bff415 	stw	r2,-48(fp)

      if (in < out)
   23088:	e0fff717 	ldw	r3,-36(fp)
   2308c:	e0bff417 	ldw	r2,-48(fp)
   23090:	1880062e 	bgeu	r3,r2,230ac <altera_avalon_jtag_uart_write+0x6c>
        n = out - 1 - in;
   23094:	e0fff417 	ldw	r3,-48(fp)
   23098:	e0bff717 	ldw	r2,-36(fp)
   2309c:	1885c83a 	sub	r2,r3,r2
   230a0:	10bfffc4 	addi	r2,r2,-1
   230a4:	e0bff515 	stw	r2,-44(fp)
   230a8:	00000b06 	br	230d8 <altera_avalon_jtag_uart_write+0x98>
      else if (out > 0)
   230ac:	e0bff417 	ldw	r2,-48(fp)
   230b0:	10000526 	beq	r2,zero,230c8 <altera_avalon_jtag_uart_write+0x88>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
   230b4:	00c20004 	movi	r3,2048
   230b8:	e0bff717 	ldw	r2,-36(fp)
   230bc:	1885c83a 	sub	r2,r3,r2
   230c0:	e0bff515 	stw	r2,-44(fp)
   230c4:	00000406 	br	230d8 <altera_avalon_jtag_uart_write+0x98>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
   230c8:	00c1ffc4 	movi	r3,2047
   230cc:	e0bff717 	ldw	r2,-36(fp)
   230d0:	1885c83a 	sub	r2,r3,r2
   230d4:	e0bff515 	stw	r2,-44(fp)

      if (n == 0)
   230d8:	e0bff517 	ldw	r2,-44(fp)
   230dc:	10001e26 	beq	r2,zero,23158 <altera_avalon_jtag_uart_write+0x118>
        break;

      if (n > count)
   230e0:	e0fffe17 	ldw	r3,-8(fp)
   230e4:	e0bff517 	ldw	r2,-44(fp)
   230e8:	1880022e 	bgeu	r3,r2,230f4 <altera_avalon_jtag_uart_write+0xb4>
        n = count;
   230ec:	e0bffe17 	ldw	r2,-8(fp)
   230f0:	e0bff515 	stw	r2,-44(fp)

      memcpy(sp->tx_buf + in, ptr, n);
   230f4:	e0bff717 	ldw	r2,-36(fp)
   230f8:	10820e04 	addi	r2,r2,2104
   230fc:	e0fffc17 	ldw	r3,-16(fp)
   23100:	1885883a 	add	r2,r3,r2
   23104:	1009883a 	mov	r4,r2
   23108:	e17ffd17 	ldw	r5,-12(fp)
   2310c:	e1bff517 	ldw	r6,-44(fp)
   23110:	00164c00 	call	164c0 <memcpy>
      ptr   += n;
   23114:	e0fffd17 	ldw	r3,-12(fp)
   23118:	e0bff517 	ldw	r2,-44(fp)
   2311c:	1885883a 	add	r2,r3,r2
   23120:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
   23124:	e0fffe17 	ldw	r3,-8(fp)
   23128:	e0bff517 	ldw	r2,-44(fp)
   2312c:	1885c83a 	sub	r2,r3,r2
   23130:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   23134:	e0fff717 	ldw	r3,-36(fp)
   23138:	e0bff517 	ldw	r2,-44(fp)
   2313c:	1885883a 	add	r2,r3,r2
   23140:	10c1ffcc 	andi	r3,r2,2047
   23144:	e0bffc17 	ldw	r2,-16(fp)
   23148:	10c00c15 	stw	r3,48(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
   2314c:	e0bffe17 	ldw	r2,-8(fp)
   23150:	00bfc716 	blt	zero,r2,23070 <altera_avalon_jtag_uart_write+0x30>
   23154:	00000106 	br	2315c <altera_avalon_jtag_uart_write+0x11c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
   23158:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   2315c:	0005303a 	rdctl	r2,status
   23160:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   23164:	e0fff917 	ldw	r3,-28(fp)
   23168:	00bfff84 	movi	r2,-2
   2316c:	1884703a 	and	r2,r3,r2
   23170:	1001703a 	wrctl	status,r2
  
  return context;
   23174:	e0bff917 	ldw	r2,-28(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
   23178:	e0bff815 	stw	r2,-32(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
   2317c:	e0bffc17 	ldw	r2,-16(fp)
   23180:	10800817 	ldw	r2,32(r2)
   23184:	10c00094 	ori	r3,r2,2
   23188:	e0bffc17 	ldw	r2,-16(fp)
   2318c:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
   23190:	e0bffc17 	ldw	r2,-16(fp)
   23194:	10800017 	ldw	r2,0(r2)
   23198:	10800104 	addi	r2,r2,4
   2319c:	e0fffc17 	ldw	r3,-16(fp)
   231a0:	18c00817 	ldw	r3,32(r3)
   231a4:	10c00035 	stwio	r3,0(r2)
   231a8:	e0bff817 	ldw	r2,-32(fp)
   231ac:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   231b0:	0005303a 	rdctl	r2,status
   231b4:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   231b8:	e0fffb17 	ldw	r3,-20(fp)
   231bc:	00bfff84 	movi	r2,-2
   231c0:	1884703a 	and	r2,r3,r2
   231c4:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   231c8:	e0bffa17 	ldw	r2,-24(fp)
   231cc:	1080004c 	andi	r2,r2,1
   231d0:	e0fffb17 	ldw	r3,-20(fp)
   231d4:	1884b03a 	or	r2,r3,r2
   231d8:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
   231dc:	e0bffb17 	ldw	r2,-20(fp)
   231e0:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
   231e4:	e0bffe17 	ldw	r2,-8(fp)
   231e8:	0080110e 	bge	zero,r2,23230 <altera_avalon_jtag_uart_write+0x1f0>
    {
      if (flags & O_NONBLOCK)
   231ec:	e0bfff17 	ldw	r2,-4(fp)
   231f0:	1090000c 	andi	r2,r2,16384
   231f4:	1000111e 	bne	r2,zero,2323c <altera_avalon_jtag_uart_write+0x1fc>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
   231f8:	0001883a 	nop
   231fc:	e0bffc17 	ldw	r2,-16(fp)
   23200:	10c00d17 	ldw	r3,52(r2)
   23204:	e0bff417 	ldw	r2,-48(fp)
   23208:	1880051e 	bne	r3,r2,23220 <altera_avalon_jtag_uart_write+0x1e0>
   2320c:	e0bffc17 	ldw	r2,-16(fp)
   23210:	10c00917 	ldw	r3,36(r2)
   23214:	e0bffc17 	ldw	r2,-16(fp)
   23218:	10800117 	ldw	r2,4(r2)
   2321c:	18bff736 	bltu	r3,r2,231fc <altera_avalon_jtag_uart_write+0x1bc>
        ;
#endif /* __ucosii__ */

      if (out == sp->tx_out)
   23220:	e0bffc17 	ldw	r2,-16(fp)
   23224:	10c00d17 	ldw	r3,52(r2)
   23228:	e0bff417 	ldw	r2,-48(fp)
   2322c:	18800526 	beq	r3,r2,23244 <altera_avalon_jtag_uart_write+0x204>
         break;
    }
  }
  while (count > 0);
   23230:	e0bffe17 	ldw	r2,-8(fp)
   23234:	00bfc516 	blt	zero,r2,2314c <altera_avalon_jtag_uart_write+0x10c>
   23238:	00000306 	br	23248 <altera_avalon_jtag_uart_write+0x208>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
   2323c:	0001883a 	nop
   23240:	00000106 	br	23248 <altera_avalon_jtag_uart_write+0x208>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if (out == sp->tx_out)
         break;
   23244:	0001883a 	nop
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
   23248:	e0fffd17 	ldw	r3,-12(fp)
   2324c:	e0bff617 	ldw	r2,-40(fp)
   23250:	18800426 	beq	r3,r2,23264 <altera_avalon_jtag_uart_write+0x224>
    return ptr - start;
   23254:	e0fffd17 	ldw	r3,-12(fp)
   23258:	e0bff617 	ldw	r2,-40(fp)
   2325c:	1885c83a 	sub	r2,r3,r2
   23260:	00000606 	br	2327c <altera_avalon_jtag_uart_write+0x23c>
  else if (flags & O_NONBLOCK)
   23264:	e0bfff17 	ldw	r2,-4(fp)
   23268:	1090000c 	andi	r2,r2,16384
   2326c:	10000226 	beq	r2,zero,23278 <altera_avalon_jtag_uart_write+0x238>
    return -EWOULDBLOCK;
   23270:	00bffd44 	movi	r2,-11
   23274:	00000106 	br	2327c <altera_avalon_jtag_uart_write+0x23c>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
   23278:	00bffec4 	movi	r2,-5
}
   2327c:	e037883a 	mov	sp,fp
   23280:	dfc00117 	ldw	ra,4(sp)
   23284:	df000017 	ldw	fp,0(sp)
   23288:	dec00204 	addi	sp,sp,8
   2328c:	f800283a 	ret

00023290 <lcd_write_command>:

/* --------------------------------------------------------------------- */

static void lcd_write_command(altera_avalon_lcd_16207_state* sp, 
  unsigned char command)
{
   23290:	defffa04 	addi	sp,sp,-24
   23294:	dfc00515 	stw	ra,20(sp)
   23298:	df000415 	stw	fp,16(sp)
   2329c:	df000404 	addi	fp,sp,16
   232a0:	e13ffe15 	stw	r4,-8(fp)
   232a4:	2805883a 	mov	r2,r5
   232a8:	e0bfff05 	stb	r2,-4(fp)
  unsigned int base = sp->base;
   232ac:	e0bffe17 	ldw	r2,-8(fp)
   232b0:	10800017 	ldw	r2,0(r2)
   232b4:	e0bffd15 	stw	r2,-12(fp)
  /* We impose a timeout on the driver in case the LCD panel isn't connected.
   * The first time we call this function the timeout is approx 25ms 
   * (assuming 5 cycles per loop and a 200MHz clock).  Obviously systems
   * with slower clocks, or debug builds, or slower memory will take longer.
   */
  int i = 1000000;
   232b8:	008003f4 	movhi	r2,15
   232bc:	10909004 	addi	r2,r2,16960
   232c0:	e0bffc15 	stw	r2,-16(fp)

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
   232c4:	e0bffe17 	ldw	r2,-8(fp)
   232c8:	10800803 	ldbu	r2,32(r2)
   232cc:	10803fcc 	andi	r2,r2,255
   232d0:	1080201c 	xori	r2,r2,128
   232d4:	10bfe004 	addi	r2,r2,-128
   232d8:	10000a26 	beq	r2,zero,23304 <lcd_write_command+0x74>
    return;
   232dc:	00001406 	br	23330 <lcd_write_command+0xa0>

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
    if (--i == 0)
   232e0:	e0bffc17 	ldw	r2,-16(fp)
   232e4:	10bfffc4 	addi	r2,r2,-1
   232e8:	e0bffc15 	stw	r2,-16(fp)
   232ec:	e0bffc17 	ldw	r2,-16(fp)
   232f0:	1000051e 	bne	r2,zero,23308 <lcd_write_command+0x78>
    {
      sp->broken = 1;
   232f4:	e0bffe17 	ldw	r2,-8(fp)
   232f8:	00c00044 	movi	r3,1
   232fc:	10c00805 	stb	r3,32(r2)
      return;
   23300:	00000b06 	br	23330 <lcd_write_command+0xa0>
  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
   23304:	0001883a 	nop
   23308:	e0bffd17 	ldw	r2,-12(fp)
   2330c:	10800104 	addi	r2,r2,4
   23310:	10800037 	ldwio	r2,0(r2)
   23314:	1080200c 	andi	r2,r2,128
   23318:	103ff11e 	bne	r2,zero,232e0 <lcd_write_command+0x50>
    }

  /* Despite what it says in the datasheet, the LCD isn't ready to accept
   * a write immediately after it returns BUSY=0.  Wait for 100us more.
   */
  usleep(100);
   2331c:	01001904 	movi	r4,100
   23320:	002081c0 	call	2081c <usleep>

  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, command);
   23324:	e0bffd17 	ldw	r2,-12(fp)
   23328:	e0ffff03 	ldbu	r3,-4(fp)
   2332c:	10c00035 	stwio	r3,0(r2)
}
   23330:	e037883a 	mov	sp,fp
   23334:	dfc00117 	ldw	ra,4(sp)
   23338:	df000017 	ldw	fp,0(sp)
   2333c:	dec00204 	addi	sp,sp,8
   23340:	f800283a 	ret

00023344 <lcd_write_data>:

/* --------------------------------------------------------------------- */

static void lcd_write_data(altera_avalon_lcd_16207_state* sp, 
  unsigned char data)
{
   23344:	defffa04 	addi	sp,sp,-24
   23348:	dfc00515 	stw	ra,20(sp)
   2334c:	df000415 	stw	fp,16(sp)
   23350:	df000404 	addi	fp,sp,16
   23354:	e13ffe15 	stw	r4,-8(fp)
   23358:	2805883a 	mov	r2,r5
   2335c:	e0bfff05 	stb	r2,-4(fp)
  unsigned int base = sp->base;
   23360:	e0bffe17 	ldw	r2,-8(fp)
   23364:	10800017 	ldw	r2,0(r2)
   23368:	e0bffd15 	stw	r2,-12(fp)
  /* We impose a timeout on the driver in case the LCD panel isn't connected.
   * The first time we call this function the timeout is approx 25ms 
   * (assuming 5 cycles per loop and a 200MHz clock).  Obviously systems
   * with slower clocks, or debug builds, or slower memory will take longer.
   */
  int i = 1000000;
   2336c:	008003f4 	movhi	r2,15
   23370:	10909004 	addi	r2,r2,16960
   23374:	e0bffc15 	stw	r2,-16(fp)

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
   23378:	e0bffe17 	ldw	r2,-8(fp)
   2337c:	10800803 	ldbu	r2,32(r2)
   23380:	10803fcc 	andi	r2,r2,255
   23384:	1080201c 	xori	r2,r2,128
   23388:	10bfe004 	addi	r2,r2,-128
   2338c:	10000a26 	beq	r2,zero,233b8 <lcd_write_data+0x74>
    return;
   23390:	00001b06 	br	23400 <lcd_write_data+0xbc>

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
    if (--i == 0)
   23394:	e0bffc17 	ldw	r2,-16(fp)
   23398:	10bfffc4 	addi	r2,r2,-1
   2339c:	e0bffc15 	stw	r2,-16(fp)
   233a0:	e0bffc17 	ldw	r2,-16(fp)
   233a4:	1000051e 	bne	r2,zero,233bc <lcd_write_data+0x78>
    {
      sp->broken = 1;
   233a8:	e0bffe17 	ldw	r2,-8(fp)
   233ac:	00c00044 	movi	r3,1
   233b0:	10c00805 	stb	r3,32(r2)
      return;
   233b4:	00001206 	br	23400 <lcd_write_data+0xbc>
  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
   233b8:	0001883a 	nop
   233bc:	e0bffd17 	ldw	r2,-12(fp)
   233c0:	10800104 	addi	r2,r2,4
   233c4:	10800037 	ldwio	r2,0(r2)
   233c8:	1080200c 	andi	r2,r2,128
   233cc:	103ff11e 	bne	r2,zero,23394 <lcd_write_data+0x50>
    }

  /* Despite what it says in the datasheet, the LCD isn't ready to accept
   * a write immediately after it returns BUSY=0.  Wait for 100us more.
   */
  usleep(100);
   233d0:	01001904 	movi	r4,100
   233d4:	002081c0 	call	2081c <usleep>

  IOWR_ALTERA_AVALON_LCD_16207_DATA(base, data);
   233d8:	e0bffd17 	ldw	r2,-12(fp)
   233dc:	10800204 	addi	r2,r2,8
   233e0:	e0ffff03 	ldbu	r3,-4(fp)
   233e4:	10c00035 	stwio	r3,0(r2)

  sp->address++;
   233e8:	e0bffe17 	ldw	r2,-8(fp)
   233ec:	108008c3 	ldbu	r2,35(r2)
   233f0:	10800044 	addi	r2,r2,1
   233f4:	1007883a 	mov	r3,r2
   233f8:	e0bffe17 	ldw	r2,-8(fp)
   233fc:	10c008c5 	stb	r3,35(r2)
}
   23400:	e037883a 	mov	sp,fp
   23404:	dfc00117 	ldw	ra,4(sp)
   23408:	df000017 	ldw	fp,0(sp)
   2340c:	dec00204 	addi	sp,sp,8
   23410:	f800283a 	ret

00023414 <lcd_clear_screen>:

/* --------------------------------------------------------------------- */

static void lcd_clear_screen(altera_avalon_lcd_16207_state* sp)
{
   23414:	defffc04 	addi	sp,sp,-16
   23418:	dfc00315 	stw	ra,12(sp)
   2341c:	df000215 	stw	fp,8(sp)
   23420:	df000204 	addi	fp,sp,8
   23424:	e13fff15 	stw	r4,-4(fp)
  int y;

  lcd_write_command(sp, LCD_CMD_CLEAR);
   23428:	e13fff17 	ldw	r4,-4(fp)
   2342c:	01400044 	movi	r5,1
   23430:	00232900 	call	23290 <lcd_write_command>

  sp->x = 0;
   23434:	e0bfff17 	ldw	r2,-4(fp)
   23438:	10000845 	stb	zero,33(r2)
  sp->y = 0;
   2343c:	e0bfff17 	ldw	r2,-4(fp)
   23440:	10000885 	stb	zero,34(r2)
  sp->address = 0;
   23444:	e0bfff17 	ldw	r2,-4(fp)
   23448:	100008c5 	stb	zero,35(r2)

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   2344c:	e03ffe15 	stw	zero,-8(fp)
   23450:	00001b06 	br	234c0 <lcd_clear_screen+0xac>
  {
    memset(sp->line[y].data, ' ', sizeof(sp->line[0].data));
   23454:	e0bffe17 	ldw	r2,-8(fp)
   23458:	108018e4 	muli	r2,r2,99
   2345c:	10801004 	addi	r2,r2,64
   23460:	e0ffff17 	ldw	r3,-4(fp)
   23464:	1885883a 	add	r2,r3,r2
   23468:	1009883a 	mov	r4,r2
   2346c:	01400804 	movi	r5,32
   23470:	01801444 	movi	r6,81
   23474:	00165b80 	call	165b8 <memset>
    memset(sp->line[y].visible, ' ', sizeof(sp->line[0].visible));
   23478:	e0bffe17 	ldw	r2,-8(fp)
   2347c:	108018e4 	muli	r2,r2,99
   23480:	10800c04 	addi	r2,r2,48
   23484:	e0ffff17 	ldw	r3,-4(fp)
   23488:	1885883a 	add	r2,r3,r2
   2348c:	1009883a 	mov	r4,r2
   23490:	01400804 	movi	r5,32
   23494:	01800404 	movi	r6,16
   23498:	00165b80 	call	165b8 <memset>
    sp->line[y].width = 0;
   2349c:	e0ffff17 	ldw	r3,-4(fp)
   234a0:	e0bffe17 	ldw	r2,-8(fp)
   234a4:	108018e4 	muli	r2,r2,99
   234a8:	1885883a 	add	r2,r3,r2
   234ac:	10802404 	addi	r2,r2,144
   234b0:	10000045 	stb	zero,1(r2)

  sp->x = 0;
  sp->y = 0;
  sp->address = 0;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   234b4:	e0bffe17 	ldw	r2,-8(fp)
   234b8:	10800044 	addi	r2,r2,1
   234bc:	e0bffe15 	stw	r2,-8(fp)
   234c0:	e0bffe17 	ldw	r2,-8(fp)
   234c4:	10800090 	cmplti	r2,r2,2
   234c8:	103fe21e 	bne	r2,zero,23454 <lcd_clear_screen+0x40>
  {
    memset(sp->line[y].data, ' ', sizeof(sp->line[0].data));
    memset(sp->line[y].visible, ' ', sizeof(sp->line[0].visible));
    sp->line[y].width = 0;
  }
}
   234cc:	e037883a 	mov	sp,fp
   234d0:	dfc00117 	ldw	ra,4(sp)
   234d4:	df000017 	ldw	fp,0(sp)
   234d8:	dec00204 	addi	sp,sp,8
   234dc:	f800283a 	ret

000234e0 <lcd_repaint_screen>:

/* --------------------------------------------------------------------- */

static void lcd_repaint_screen(altera_avalon_lcd_16207_state* sp)
{
   234e0:	defff704 	addi	sp,sp,-36
   234e4:	dfc00815 	stw	ra,32(sp)
   234e8:	df000715 	stw	fp,28(sp)
   234ec:	df000704 	addi	fp,sp,28
   234f0:	e13fff15 	stw	r4,-4(fp)
  /* scrollpos controls how much the lines have scrolled round.  The speed
   * each line scrolls at is controlled by its speed variable - while
   * scrolline lines will wrap at the position set by width
   */

  int scrollpos = sp->scrollpos;
   234f4:	e0bfff17 	ldw	r2,-4(fp)
   234f8:	10800943 	ldbu	r2,37(r2)
   234fc:	10803fcc 	andi	r2,r2,255
   23500:	e0bffc15 	stw	r2,-16(fp)

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   23504:	e03ff915 	stw	zero,-28(fp)
   23508:	00006806 	br	236ac <lcd_repaint_screen+0x1cc>
  {
    int width  = sp->line[y].width;
   2350c:	e0ffff17 	ldw	r3,-4(fp)
   23510:	e0bff917 	ldw	r2,-28(fp)
   23514:	108018e4 	muli	r2,r2,99
   23518:	1885883a 	add	r2,r3,r2
   2351c:	10802404 	addi	r2,r2,144
   23520:	10800043 	ldbu	r2,1(r2)
   23524:	10803fcc 	andi	r2,r2,255
   23528:	1080201c 	xori	r2,r2,128
   2352c:	10bfe004 	addi	r2,r2,-128
   23530:	e0bffd15 	stw	r2,-12(fp)
    int offset = (scrollpos * sp->line[y].speed) >> 8;
   23534:	e0ffff17 	ldw	r3,-4(fp)
   23538:	e0bff917 	ldw	r2,-28(fp)
   2353c:	108018e4 	muli	r2,r2,99
   23540:	1885883a 	add	r2,r3,r2
   23544:	10802404 	addi	r2,r2,144
   23548:	10800083 	ldbu	r2,2(r2)
   2354c:	10c03fcc 	andi	r3,r2,255
   23550:	e0bffc17 	ldw	r2,-16(fp)
   23554:	1885383a 	mul	r2,r3,r2
   23558:	1005d23a 	srai	r2,r2,8
   2355c:	e0bffb15 	stw	r2,-20(fp)
    if (offset >= width)
   23560:	e0fffb17 	ldw	r3,-20(fp)
   23564:	e0bffd17 	ldw	r2,-12(fp)
   23568:	18800116 	blt	r3,r2,23570 <lcd_repaint_screen+0x90>
      offset = 0;
   2356c:	e03ffb15 	stw	zero,-20(fp)

    for (x = 0 ; x < ALT_LCD_WIDTH ; x++)
   23570:	e03ffa15 	stw	zero,-24(fp)
   23574:	00004706 	br	23694 <lcd_repaint_screen+0x1b4>
    {
      char c = sp->line[y].data[(x + offset) % width];
   23578:	e0fffa17 	ldw	r3,-24(fp)
   2357c:	e0bffb17 	ldw	r2,-20(fp)
   23580:	1885883a 	add	r2,r3,r2
   23584:	e0fffd17 	ldw	r3,-12(fp)
   23588:	10c9283a 	div	r4,r2,r3
   2358c:	e0fffd17 	ldw	r3,-12(fp)
   23590:	20c7383a 	mul	r3,r4,r3
   23594:	10c5c83a 	sub	r2,r2,r3
   23598:	e13fff17 	ldw	r4,-4(fp)
   2359c:	e0fff917 	ldw	r3,-28(fp)
   235a0:	18c018e4 	muli	r3,r3,99
   235a4:	20c7883a 	add	r3,r4,r3
   235a8:	1885883a 	add	r2,r3,r2
   235ac:	10801004 	addi	r2,r2,64
   235b0:	10800003 	ldbu	r2,0(r2)
   235b4:	e0bffe05 	stb	r2,-8(fp)

      /* Writing data takes 40us, so don't do it unless required */
      if (sp->line[y].visible[x] != c)
   235b8:	e0ffff17 	ldw	r3,-4(fp)
   235bc:	e0bff917 	ldw	r2,-28(fp)
   235c0:	108018e4 	muli	r2,r2,99
   235c4:	1887883a 	add	r3,r3,r2
   235c8:	e0bffa17 	ldw	r2,-24(fp)
   235cc:	1885883a 	add	r2,r3,r2
   235d0:	10800c04 	addi	r2,r2,48
   235d4:	10800003 	ldbu	r2,0(r2)
   235d8:	10c03fcc 	andi	r3,r2,255
   235dc:	18c0201c 	xori	r3,r3,128
   235e0:	18ffe004 	addi	r3,r3,-128
   235e4:	e0bffe07 	ldb	r2,-8(fp)
   235e8:	18802726 	beq	r3,r2,23688 <lcd_repaint_screen+0x1a8>
      {
        unsigned char address = x + colstart[y];
   235ec:	e0fff917 	ldw	r3,-28(fp)
   235f0:	d0a01804 	addi	r2,gp,-32672
   235f4:	1885883a 	add	r2,r3,r2
   235f8:	10800003 	ldbu	r2,0(r2)
   235fc:	1007883a 	mov	r3,r2
   23600:	e0bffa17 	ldw	r2,-24(fp)
   23604:	1885883a 	add	r2,r3,r2
   23608:	e0bffe45 	stb	r2,-7(fp)

        if (address != sp->address)
   2360c:	e0fffe43 	ldbu	r3,-7(fp)
   23610:	e0bfff17 	ldw	r2,-4(fp)
   23614:	108008c3 	ldbu	r2,35(r2)
   23618:	10803fcc 	andi	r2,r2,255
   2361c:	1080201c 	xori	r2,r2,128
   23620:	10bfe004 	addi	r2,r2,-128
   23624:	18800a26 	beq	r3,r2,23650 <lcd_repaint_screen+0x170>
        {
          lcd_write_command(sp, LCD_CMD_WRITE_DATA | address);
   23628:	e0fffe43 	ldbu	r3,-7(fp)
   2362c:	00bfe004 	movi	r2,-128
   23630:	1884b03a 	or	r2,r3,r2
   23634:	10803fcc 	andi	r2,r2,255
   23638:	e13fff17 	ldw	r4,-4(fp)
   2363c:	100b883a 	mov	r5,r2
   23640:	00232900 	call	23290 <lcd_write_command>
          sp->address = address;
   23644:	e0fffe43 	ldbu	r3,-7(fp)
   23648:	e0bfff17 	ldw	r2,-4(fp)
   2364c:	10c008c5 	stb	r3,35(r2)
        }

        lcd_write_data(sp, c);
   23650:	e0bffe03 	ldbu	r2,-8(fp)
   23654:	10803fcc 	andi	r2,r2,255
   23658:	e13fff17 	ldw	r4,-4(fp)
   2365c:	100b883a 	mov	r5,r2
   23660:	00233440 	call	23344 <lcd_write_data>
        sp->line[y].visible[x] = c;
   23664:	e0ffff17 	ldw	r3,-4(fp)
   23668:	e0bff917 	ldw	r2,-28(fp)
   2366c:	108018e4 	muli	r2,r2,99
   23670:	1887883a 	add	r3,r3,r2
   23674:	e0bffa17 	ldw	r2,-24(fp)
   23678:	1885883a 	add	r2,r3,r2
   2367c:	10800c04 	addi	r2,r2,48
   23680:	e0fffe03 	ldbu	r3,-8(fp)
   23684:	10c00005 	stb	r3,0(r2)
    int width  = sp->line[y].width;
    int offset = (scrollpos * sp->line[y].speed) >> 8;
    if (offset >= width)
      offset = 0;

    for (x = 0 ; x < ALT_LCD_WIDTH ; x++)
   23688:	e0bffa17 	ldw	r2,-24(fp)
   2368c:	10800044 	addi	r2,r2,1
   23690:	e0bffa15 	stw	r2,-24(fp)
   23694:	e0bffa17 	ldw	r2,-24(fp)
   23698:	10800410 	cmplti	r2,r2,16
   2369c:	103fb61e 	bne	r2,zero,23578 <lcd_repaint_screen+0x98>
   * scrolline lines will wrap at the position set by width
   */

  int scrollpos = sp->scrollpos;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   236a0:	e0bff917 	ldw	r2,-28(fp)
   236a4:	10800044 	addi	r2,r2,1
   236a8:	e0bff915 	stw	r2,-28(fp)
   236ac:	e0bff917 	ldw	r2,-28(fp)
   236b0:	10800090 	cmplti	r2,r2,2
   236b4:	103f951e 	bne	r2,zero,2350c <lcd_repaint_screen+0x2c>
        lcd_write_data(sp, c);
        sp->line[y].visible[x] = c;
      }
    }
  }
}
   236b8:	e037883a 	mov	sp,fp
   236bc:	dfc00117 	ldw	ra,4(sp)
   236c0:	df000017 	ldw	fp,0(sp)
   236c4:	dec00204 	addi	sp,sp,8
   236c8:	f800283a 	ret

000236cc <lcd_scroll_up>:

/* --------------------------------------------------------------------- */

static void lcd_scroll_up(altera_avalon_lcd_16207_state* sp)
{
   236cc:	defffc04 	addi	sp,sp,-16
   236d0:	dfc00315 	stw	ra,12(sp)
   236d4:	df000215 	stw	fp,8(sp)
   236d8:	df000204 	addi	fp,sp,8
   236dc:	e13fff15 	stw	r4,-4(fp)
  int y;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   236e0:	e03ffe15 	stw	zero,-8(fp)
   236e4:	00001e06 	br	23760 <lcd_scroll_up+0x94>
  {
    if (y < ALT_LCD_HEIGHT-1)
   236e8:	e0bffe17 	ldw	r2,-8(fp)
   236ec:	00801016 	blt	zero,r2,23730 <lcd_scroll_up+0x64>
      memcpy(sp->line[y].data, sp->line[y+1].data, ALT_LCD_VIRTUAL_WIDTH);
   236f0:	e0bffe17 	ldw	r2,-8(fp)
   236f4:	108018e4 	muli	r2,r2,99
   236f8:	10801004 	addi	r2,r2,64
   236fc:	e0ffff17 	ldw	r3,-4(fp)
   23700:	1887883a 	add	r3,r3,r2
   23704:	e0bffe17 	ldw	r2,-8(fp)
   23708:	10800044 	addi	r2,r2,1
   2370c:	108018e4 	muli	r2,r2,99
   23710:	10801004 	addi	r2,r2,64
   23714:	e13fff17 	ldw	r4,-4(fp)
   23718:	2085883a 	add	r2,r4,r2
   2371c:	1809883a 	mov	r4,r3
   23720:	100b883a 	mov	r5,r2
   23724:	01801404 	movi	r6,80
   23728:	00164c00 	call	164c0 <memcpy>
   2372c:	00000906 	br	23754 <lcd_scroll_up+0x88>
    else
      memset(sp->line[y].data, ' ', ALT_LCD_VIRTUAL_WIDTH);
   23730:	e0bffe17 	ldw	r2,-8(fp)
   23734:	108018e4 	muli	r2,r2,99
   23738:	10801004 	addi	r2,r2,64
   2373c:	e0ffff17 	ldw	r3,-4(fp)
   23740:	1885883a 	add	r2,r3,r2
   23744:	1009883a 	mov	r4,r2
   23748:	01400804 	movi	r5,32
   2374c:	01801404 	movi	r6,80
   23750:	00165b80 	call	165b8 <memset>

static void lcd_scroll_up(altera_avalon_lcd_16207_state* sp)
{
  int y;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   23754:	e0bffe17 	ldw	r2,-8(fp)
   23758:	10800044 	addi	r2,r2,1
   2375c:	e0bffe15 	stw	r2,-8(fp)
   23760:	e0bffe17 	ldw	r2,-8(fp)
   23764:	10800090 	cmplti	r2,r2,2
   23768:	103fdf1e 	bne	r2,zero,236e8 <lcd_scroll_up+0x1c>
      memcpy(sp->line[y].data, sp->line[y+1].data, ALT_LCD_VIRTUAL_WIDTH);
    else
      memset(sp->line[y].data, ' ', ALT_LCD_VIRTUAL_WIDTH);
  }

  sp->y--;
   2376c:	e0bfff17 	ldw	r2,-4(fp)
   23770:	10800883 	ldbu	r2,34(r2)
   23774:	10bfffc4 	addi	r2,r2,-1
   23778:	1007883a 	mov	r3,r2
   2377c:	e0bfff17 	ldw	r2,-4(fp)
   23780:	10c00885 	stb	r3,34(r2)
}
   23784:	e037883a 	mov	sp,fp
   23788:	dfc00117 	ldw	ra,4(sp)
   2378c:	df000017 	ldw	fp,0(sp)
   23790:	dec00204 	addi	sp,sp,8
   23794:	f800283a 	ret

00023798 <lcd_handle_escape>:

/* --------------------------------------------------------------------- */

static void lcd_handle_escape(altera_avalon_lcd_16207_state* sp, char c)
{
   23798:	defff904 	addi	sp,sp,-28
   2379c:	dfc00615 	stw	ra,24(sp)
   237a0:	df000515 	stw	fp,20(sp)
   237a4:	df000504 	addi	fp,sp,20
   237a8:	e13ffe15 	stw	r4,-8(fp)
   237ac:	2805883a 	mov	r2,r5
   237b0:	e0bfff05 	stb	r2,-4(fp)
  int parm1 = 0, parm2 = 0;
   237b4:	e03ffb15 	stw	zero,-20(fp)
   237b8:	e03ffc15 	stw	zero,-16(fp)

  if (sp->escape[0] == '[')
   237bc:	e0bffe17 	ldw	r2,-8(fp)
   237c0:	10800a03 	ldbu	r2,40(r2)
   237c4:	10803fcc 	andi	r2,r2,255
   237c8:	1080201c 	xori	r2,r2,128
   237cc:	10bfe004 	addi	r2,r2,-128
   237d0:	108016d8 	cmpnei	r2,r2,91
   237d4:	1000441e 	bne	r2,zero,238e8 <lcd_handle_escape+0x150>
  {
    char * ptr = sp->escape+1;
   237d8:	e0bffe17 	ldw	r2,-8(fp)
   237dc:	10800a44 	addi	r2,r2,41
   237e0:	e0bffd15 	stw	r2,-12(fp)
    while (isdigit(*ptr))
   237e4:	00000d06 	br	2381c <lcd_handle_escape+0x84>
      parm1 = (parm1 * 10) + (*ptr++ - '0');
   237e8:	e0bffb17 	ldw	r2,-20(fp)
   237ec:	10c002a4 	muli	r3,r2,10
   237f0:	e0bffd17 	ldw	r2,-12(fp)
   237f4:	10800003 	ldbu	r2,0(r2)
   237f8:	10803fcc 	andi	r2,r2,255
   237fc:	1080201c 	xori	r2,r2,128
   23800:	10bfe004 	addi	r2,r2,-128
   23804:	10bff404 	addi	r2,r2,-48
   23808:	1885883a 	add	r2,r3,r2
   2380c:	e0bffb15 	stw	r2,-20(fp)
   23810:	e0bffd17 	ldw	r2,-12(fp)
   23814:	10800044 	addi	r2,r2,1
   23818:	e0bffd15 	stw	r2,-12(fp)
  int parm1 = 0, parm2 = 0;

  if (sp->escape[0] == '[')
  {
    char * ptr = sp->escape+1;
    while (isdigit(*ptr))
   2381c:	008000f4 	movhi	r2,3
   23820:	108d3e04 	addi	r2,r2,13560
   23824:	10c00017 	ldw	r3,0(r2)
   23828:	e0bffd17 	ldw	r2,-12(fp)
   2382c:	10800003 	ldbu	r2,0(r2)
   23830:	10803fcc 	andi	r2,r2,255
   23834:	1080201c 	xori	r2,r2,128
   23838:	10bfe004 	addi	r2,r2,-128
   2383c:	1885883a 	add	r2,r3,r2
   23840:	10800003 	ldbu	r2,0(r2)
   23844:	10803fcc 	andi	r2,r2,255
   23848:	1080010c 	andi	r2,r2,4
   2384c:	103fe61e 	bne	r2,zero,237e8 <lcd_handle_escape+0x50>
      parm1 = (parm1 * 10) + (*ptr++ - '0');

    if (*ptr == ';')
   23850:	e0bffd17 	ldw	r2,-12(fp)
   23854:	10800003 	ldbu	r2,0(r2)
   23858:	10803fcc 	andi	r2,r2,255
   2385c:	1080201c 	xori	r2,r2,128
   23860:	10bfe004 	addi	r2,r2,-128
   23864:	10800ed8 	cmpnei	r2,r2,59
   23868:	1000211e 	bne	r2,zero,238f0 <lcd_handle_escape+0x158>
    {
      ptr++;
   2386c:	e0bffd17 	ldw	r2,-12(fp)
   23870:	10800044 	addi	r2,r2,1
   23874:	e0bffd15 	stw	r2,-12(fp)
      while (isdigit(*ptr))
   23878:	00000d06 	br	238b0 <lcd_handle_escape+0x118>
        parm2 = (parm2 * 10) + (*ptr++ - '0');
   2387c:	e0bffc17 	ldw	r2,-16(fp)
   23880:	10c002a4 	muli	r3,r2,10
   23884:	e0bffd17 	ldw	r2,-12(fp)
   23888:	10800003 	ldbu	r2,0(r2)
   2388c:	10803fcc 	andi	r2,r2,255
   23890:	1080201c 	xori	r2,r2,128
   23894:	10bfe004 	addi	r2,r2,-128
   23898:	10bff404 	addi	r2,r2,-48
   2389c:	1885883a 	add	r2,r3,r2
   238a0:	e0bffc15 	stw	r2,-16(fp)
   238a4:	e0bffd17 	ldw	r2,-12(fp)
   238a8:	10800044 	addi	r2,r2,1
   238ac:	e0bffd15 	stw	r2,-12(fp)
      parm1 = (parm1 * 10) + (*ptr++ - '0');

    if (*ptr == ';')
    {
      ptr++;
      while (isdigit(*ptr))
   238b0:	008000f4 	movhi	r2,3
   238b4:	108d3e04 	addi	r2,r2,13560
   238b8:	10c00017 	ldw	r3,0(r2)
   238bc:	e0bffd17 	ldw	r2,-12(fp)
   238c0:	10800003 	ldbu	r2,0(r2)
   238c4:	10803fcc 	andi	r2,r2,255
   238c8:	1080201c 	xori	r2,r2,128
   238cc:	10bfe004 	addi	r2,r2,-128
   238d0:	1885883a 	add	r2,r3,r2
   238d4:	10800003 	ldbu	r2,0(r2)
   238d8:	10803fcc 	andi	r2,r2,255
   238dc:	1080010c 	andi	r2,r2,4
   238e0:	103fe61e 	bne	r2,zero,2387c <lcd_handle_escape+0xe4>
   238e4:	00000206 	br	238f0 <lcd_handle_escape+0x158>
        parm2 = (parm2 * 10) + (*ptr++ - '0');
    }
  }
  else
    parm1 = -1;
   238e8:	00bfffc4 	movi	r2,-1
   238ec:	e0bffb15 	stw	r2,-20(fp)

  switch (c)
   238f0:	e0bfff07 	ldb	r2,-4(fp)
   238f4:	10c012a0 	cmpeqi	r3,r2,74
   238f8:	18002a1e 	bne	r3,zero,239a4 <lcd_handle_escape+0x20c>
   238fc:	10c012c8 	cmpgei	r3,r2,75
   23900:	1800031e 	bne	r3,zero,23910 <lcd_handle_escape+0x178>
   23904:	10801220 	cmpeqi	r2,r2,72
   23908:	1000051e 	bne	r2,zero,23920 <lcd_handle_escape+0x188>
   2390c:	00004c06 	br	23a40 <lcd_handle_escape+0x2a8>
   23910:	10c012e0 	cmpeqi	r3,r2,75
   23914:	1800291e 	bne	r3,zero,239bc <lcd_handle_escape+0x224>
   23918:	108019a0 	cmpeqi	r2,r2,102
   2391c:	10004826 	beq	r2,zero,23a40 <lcd_handle_escape+0x2a8>
  {
  case 'H': /* ESC '[' <y> ';' <x> 'H'  : Move cursor to location */
  case 'f': /* Same as above */
    if (parm2 > 0)
   23920:	e0bffc17 	ldw	r2,-16(fp)
   23924:	0080050e 	bge	zero,r2,2393c <lcd_handle_escape+0x1a4>
      sp->x = parm2 - 1;
   23928:	e0bffc17 	ldw	r2,-16(fp)
   2392c:	10bfffc4 	addi	r2,r2,-1
   23930:	1007883a 	mov	r3,r2
   23934:	e0bffe17 	ldw	r2,-8(fp)
   23938:	10c00845 	stb	r3,33(r2)
    if (parm1 > 0)
   2393c:	e0bffb17 	ldw	r2,-20(fp)
   23940:	00803a0e 	bge	zero,r2,23a2c <lcd_handle_escape+0x294>
    {
      sp->y = parm1 - 1;
   23944:	e0bffb17 	ldw	r2,-20(fp)
   23948:	10bfffc4 	addi	r2,r2,-1
   2394c:	1007883a 	mov	r3,r2
   23950:	e0bffe17 	ldw	r2,-8(fp)
   23954:	10c00885 	stb	r3,34(r2)
      if (sp->y > ALT_LCD_HEIGHT * 2)
   23958:	e0bffe17 	ldw	r2,-8(fp)
   2395c:	10800883 	ldbu	r2,34(r2)
   23960:	10803fcc 	andi	r2,r2,255
   23964:	10800170 	cmpltui	r2,r2,5
   23968:	1000071e 	bne	r2,zero,23988 <lcd_handle_escape+0x1f0>
        sp->y = ALT_LCD_HEIGHT * 2;
   2396c:	e0bffe17 	ldw	r2,-8(fp)
   23970:	00c00104 	movi	r3,4
   23974:	10c00885 	stb	r3,34(r2)
      while (sp->y > ALT_LCD_HEIGHT)
   23978:	00000306 	br	23988 <lcd_handle_escape+0x1f0>
        lcd_scroll_up(sp);
   2397c:	e13ffe17 	ldw	r4,-8(fp)
   23980:	00236cc0 	call	236cc <lcd_scroll_up>
   23984:	00000106 	br	2398c <lcd_handle_escape+0x1f4>
    if (parm1 > 0)
    {
      sp->y = parm1 - 1;
      if (sp->y > ALT_LCD_HEIGHT * 2)
        sp->y = ALT_LCD_HEIGHT * 2;
      while (sp->y > ALT_LCD_HEIGHT)
   23988:	0001883a 	nop
   2398c:	e0bffe17 	ldw	r2,-8(fp)
   23990:	10800883 	ldbu	r2,34(r2)
   23994:	10803fcc 	andi	r2,r2,255
   23998:	108000e8 	cmpgeui	r2,r2,3
   2399c:	103ff71e 	bne	r2,zero,2397c <lcd_handle_escape+0x1e4>
        lcd_scroll_up(sp);
    }
    break;
   239a0:	00002206 	br	23a2c <lcd_handle_escape+0x294>
    /*   ESC J      is clear to beginning of line    [unimplemented]
     *   ESC [ 0 J  is clear to bottom of screen     [unimplemented]
     *   ESC [ 1 J  is clear to beginning of screen  [unimplemented]
     *   ESC [ 2 J  is clear screen
     */
    if (parm1 == 2)
   239a4:	e0bffb17 	ldw	r2,-20(fp)
   239a8:	10800098 	cmpnei	r2,r2,2
   239ac:	1000211e 	bne	r2,zero,23a34 <lcd_handle_escape+0x29c>
      lcd_clear_screen(sp);
   239b0:	e13ffe17 	ldw	r4,-8(fp)
   239b4:	00234140 	call	23414 <lcd_clear_screen>
    break;
   239b8:	00001e06 	br	23a34 <lcd_handle_escape+0x29c>
    /*   ESC K      is clear to end of line
     *   ESC [ 0 K  is clear to end of line
     *   ESC [ 1 K  is clear to beginning of line    [unimplemented]
     *   ESC [ 2 K  is clear line                    [unimplemented]
     */
    if (parm1 < 1)
   239bc:	e0bffb17 	ldw	r2,-20(fp)
   239c0:	00801e16 	blt	zero,r2,23a3c <lcd_handle_escape+0x2a4>
    {
      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
   239c4:	e0bffe17 	ldw	r2,-8(fp)
   239c8:	10800843 	ldbu	r2,33(r2)
   239cc:	10803fcc 	andi	r2,r2,255
   239d0:	10801428 	cmpgeui	r2,r2,80
   239d4:	1000191e 	bne	r2,zero,23a3c <lcd_handle_escape+0x2a4>
        memset(sp->line[sp->y].data + sp->x, ' ', ALT_LCD_VIRTUAL_WIDTH - sp->x);
   239d8:	e0bffe17 	ldw	r2,-8(fp)
   239dc:	10800883 	ldbu	r2,34(r2)
   239e0:	10803fcc 	andi	r2,r2,255
   239e4:	108018e4 	muli	r2,r2,99
   239e8:	10801004 	addi	r2,r2,64
   239ec:	e0fffe17 	ldw	r3,-8(fp)
   239f0:	1887883a 	add	r3,r3,r2
   239f4:	e0bffe17 	ldw	r2,-8(fp)
   239f8:	10800843 	ldbu	r2,33(r2)
   239fc:	10803fcc 	andi	r2,r2,255
   23a00:	1887883a 	add	r3,r3,r2
   23a04:	e0bffe17 	ldw	r2,-8(fp)
   23a08:	10800843 	ldbu	r2,33(r2)
   23a0c:	10803fcc 	andi	r2,r2,255
   23a10:	01001404 	movi	r4,80
   23a14:	2085c83a 	sub	r2,r4,r2
   23a18:	1809883a 	mov	r4,r3
   23a1c:	01400804 	movi	r5,32
   23a20:	100d883a 	mov	r6,r2
   23a24:	00165b80 	call	165b8 <memset>
    }
    break;
   23a28:	00000406 	br	23a3c <lcd_handle_escape+0x2a4>
      if (sp->y > ALT_LCD_HEIGHT * 2)
        sp->y = ALT_LCD_HEIGHT * 2;
      while (sp->y > ALT_LCD_HEIGHT)
        lcd_scroll_up(sp);
    }
    break;
   23a2c:	0001883a 	nop
   23a30:	00000306 	br	23a40 <lcd_handle_escape+0x2a8>
     *   ESC [ 1 J  is clear to beginning of screen  [unimplemented]
     *   ESC [ 2 J  is clear screen
     */
    if (parm1 == 2)
      lcd_clear_screen(sp);
    break;
   23a34:	0001883a 	nop
   23a38:	00000106 	br	23a40 <lcd_handle_escape+0x2a8>
    if (parm1 < 1)
    {
      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
        memset(sp->line[sp->y].data + sp->x, ' ', ALT_LCD_VIRTUAL_WIDTH - sp->x);
    }
    break;
   23a3c:	0001883a 	nop
  }
}
   23a40:	e037883a 	mov	sp,fp
   23a44:	dfc00117 	ldw	ra,4(sp)
   23a48:	df000017 	ldw	fp,0(sp)
   23a4c:	dec00204 	addi	sp,sp,8
   23a50:	f800283a 	ret

00023a54 <altera_avalon_lcd_16207_write>:

/* --------------------------------------------------------------------- */

int altera_avalon_lcd_16207_write(altera_avalon_lcd_16207_state* sp, 
  const char* ptr, int len, int flags)
{
   23a54:	defff304 	addi	sp,sp,-52
   23a58:	dfc00c15 	stw	ra,48(sp)
   23a5c:	df000b15 	stw	fp,44(sp)
   23a60:	df000b04 	addi	fp,sp,44
   23a64:	e13ffc15 	stw	r4,-16(fp)
   23a68:	e17ffd15 	stw	r5,-12(fp)
   23a6c:	e1bffe15 	stw	r6,-8(fp)
   23a70:	e1ffff15 	stw	r7,-4(fp)
  const char* end = ptr + len;
   23a74:	e0bffe17 	ldw	r2,-8(fp)
   23a78:	e0fffd17 	ldw	r3,-12(fp)
   23a7c:	1885883a 	add	r2,r3,r2
   23a80:	e0bff815 	stw	r2,-32(fp)

  ALT_SEM_PEND (sp->write_lock, 0);

  /* Tell the routine which is called off the timer interrupt that the
   * foreground routines are active so it must not repaint the display. */
  sp->active = 1;
   23a84:	e0bffc17 	ldw	r2,-16(fp)
   23a88:	00c00044 	movi	r3,1
   23a8c:	10c009c5 	stb	r3,39(r2)

  for ( ; ptr < end ; ptr++)
   23a90:	00009d06 	br	23d08 <altera_avalon_lcd_16207_write+0x2b4>
  {
    char c = *ptr;
   23a94:	e0bffd17 	ldw	r2,-12(fp)
   23a98:	10800003 	ldbu	r2,0(r2)
   23a9c:	e0bff905 	stb	r2,-28(fp)

    if (sp->esccount >= 0)
   23aa0:	e0bffc17 	ldw	r2,-16(fp)
   23aa4:	10800903 	ldbu	r2,36(r2)
   23aa8:	10803fcc 	andi	r2,r2,255
   23aac:	1080201c 	xori	r2,r2,128
   23ab0:	10bfe004 	addi	r2,r2,-128
   23ab4:	10003816 	blt	r2,zero,23b98 <altera_avalon_lcd_16207_write+0x144>
    {
      unsigned int esccount = sp->esccount;
   23ab8:	e0bffc17 	ldw	r2,-16(fp)
   23abc:	10800903 	ldbu	r2,36(r2)
   23ac0:	10803fcc 	andi	r2,r2,255
   23ac4:	1080201c 	xori	r2,r2,128
   23ac8:	10bfe004 	addi	r2,r2,-128
   23acc:	e0bffa15 	stw	r2,-24(fp)

      /* Single character escape sequences can end with any character
       * Multi character escape sequences start with '[' and contain
       * digits and semicolons before terminating
       */
      if ((esccount == 0 && c != '[') ||
   23ad0:	e0bffa17 	ldw	r2,-24(fp)
   23ad4:	1000031e 	bne	r2,zero,23ae4 <altera_avalon_lcd_16207_write+0x90>
   23ad8:	e0bff907 	ldb	r2,-28(fp)
   23adc:	108016d8 	cmpnei	r2,r2,91
   23ae0:	10000e1e 	bne	r2,zero,23b1c <altera_avalon_lcd_16207_write+0xc8>
   23ae4:	e0bffa17 	ldw	r2,-24(fp)
   23ae8:	10001926 	beq	r2,zero,23b50 <altera_avalon_lcd_16207_write+0xfc>
          (esccount > 0 && !isdigit(c) && c != ';'))
   23aec:	008000f4 	movhi	r2,3
   23af0:	108d3e04 	addi	r2,r2,13560
   23af4:	10c00017 	ldw	r3,0(r2)
   23af8:	e0bff907 	ldb	r2,-28(fp)
   23afc:	1885883a 	add	r2,r3,r2
   23b00:	10800003 	ldbu	r2,0(r2)
   23b04:	10803fcc 	andi	r2,r2,255
   23b08:	1080010c 	andi	r2,r2,4
   23b0c:	1000101e 	bne	r2,zero,23b50 <altera_avalon_lcd_16207_write+0xfc>
   23b10:	e0bff907 	ldb	r2,-28(fp)
   23b14:	10800ee0 	cmpeqi	r2,r2,59
   23b18:	10000d1e 	bne	r2,zero,23b50 <altera_avalon_lcd_16207_write+0xfc>
      {
        sp->escape[esccount] = 0;
   23b1c:	e0fffc17 	ldw	r3,-16(fp)
   23b20:	e0bffa17 	ldw	r2,-24(fp)
   23b24:	1885883a 	add	r2,r3,r2
   23b28:	10800a04 	addi	r2,r2,40
   23b2c:	10000005 	stb	zero,0(r2)

        lcd_handle_escape(sp, c);
   23b30:	e0bff907 	ldb	r2,-28(fp)
   23b34:	e13ffc17 	ldw	r4,-16(fp)
   23b38:	100b883a 	mov	r5,r2
   23b3c:	00237980 	call	23798 <lcd_handle_escape>

        sp->esccount = -1;
   23b40:	e0bffc17 	ldw	r2,-16(fp)
   23b44:	00ffffc4 	movi	r3,-1
   23b48:	10c00905 	stb	r3,36(r2)
   23b4c:	00006b06 	br	23cfc <altera_avalon_lcd_16207_write+0x2a8>
      }
      else if (sp->esccount < sizeof(sp->escape)-1)
   23b50:	e0bffc17 	ldw	r2,-16(fp)
   23b54:	10800903 	ldbu	r2,36(r2)
   23b58:	10803fcc 	andi	r2,r2,255
   23b5c:	108001e8 	cmpgeui	r2,r2,7
   23b60:	1000651e 	bne	r2,zero,23cf8 <altera_avalon_lcd_16207_write+0x2a4>
      {
        sp->escape[esccount] = c;
   23b64:	e0fffc17 	ldw	r3,-16(fp)
   23b68:	e0bffa17 	ldw	r2,-24(fp)
   23b6c:	1885883a 	add	r2,r3,r2
   23b70:	10800a04 	addi	r2,r2,40
   23b74:	e0fff903 	ldbu	r3,-28(fp)
   23b78:	10c00005 	stb	r3,0(r2)
        sp->esccount++;
   23b7c:	e0bffc17 	ldw	r2,-16(fp)
   23b80:	10800903 	ldbu	r2,36(r2)
   23b84:	10800044 	addi	r2,r2,1
   23b88:	1007883a 	mov	r3,r2
   23b8c:	e0bffc17 	ldw	r2,-16(fp)
   23b90:	10c00905 	stb	r3,36(r2)
   23b94:	00005806 	br	23cf8 <altera_avalon_lcd_16207_write+0x2a4>
      }
    }
    else if (c == 27) /* ESC */
   23b98:	e0bff907 	ldb	r2,-28(fp)
   23b9c:	108006d8 	cmpnei	r2,r2,27
   23ba0:	1000031e 	bne	r2,zero,23bb0 <altera_avalon_lcd_16207_write+0x15c>
    {
      sp->esccount = 0;
   23ba4:	e0bffc17 	ldw	r2,-16(fp)
   23ba8:	10000905 	stb	zero,36(r2)
   23bac:	00005306 	br	23cfc <altera_avalon_lcd_16207_write+0x2a8>
    }
    else if (c == '\r')
   23bb0:	e0bff907 	ldb	r2,-28(fp)
   23bb4:	10800358 	cmpnei	r2,r2,13
   23bb8:	1000031e 	bne	r2,zero,23bc8 <altera_avalon_lcd_16207_write+0x174>
    {
      sp->x = 0;
   23bbc:	e0bffc17 	ldw	r2,-16(fp)
   23bc0:	10000845 	stb	zero,33(r2)
   23bc4:	00004d06 	br	23cfc <altera_avalon_lcd_16207_write+0x2a8>
    }
    else if (c == '\n')
   23bc8:	e0bff907 	ldb	r2,-28(fp)
   23bcc:	10800298 	cmpnei	r2,r2,10
   23bd0:	1000101e 	bne	r2,zero,23c14 <altera_avalon_lcd_16207_write+0x1c0>
    {
      sp->x = 0;
   23bd4:	e0bffc17 	ldw	r2,-16(fp)
   23bd8:	10000845 	stb	zero,33(r2)
      sp->y++;
   23bdc:	e0bffc17 	ldw	r2,-16(fp)
   23be0:	10800883 	ldbu	r2,34(r2)
   23be4:	10800044 	addi	r2,r2,1
   23be8:	1007883a 	mov	r3,r2
   23bec:	e0bffc17 	ldw	r2,-16(fp)
   23bf0:	10c00885 	stb	r3,34(r2)

      /* Let the cursor sit at X=0, Y=HEIGHT without scrolling so the user
       * can print two lines of data without losing one.
       */
      if (sp->y > ALT_LCD_HEIGHT)
   23bf4:	e0bffc17 	ldw	r2,-16(fp)
   23bf8:	10800883 	ldbu	r2,34(r2)
   23bfc:	10803fcc 	andi	r2,r2,255
   23c00:	108000f0 	cmpltui	r2,r2,3
   23c04:	10003d1e 	bne	r2,zero,23cfc <altera_avalon_lcd_16207_write+0x2a8>
        lcd_scroll_up(sp);
   23c08:	e13ffc17 	ldw	r4,-16(fp)
   23c0c:	00236cc0 	call	236cc <lcd_scroll_up>
   23c10:	00003a06 	br	23cfc <altera_avalon_lcd_16207_write+0x2a8>
    }
    else if (c == '\b')
   23c14:	e0bff907 	ldb	r2,-28(fp)
   23c18:	10800218 	cmpnei	r2,r2,8
   23c1c:	10000b1e 	bne	r2,zero,23c4c <altera_avalon_lcd_16207_write+0x1f8>
    {
      if (sp->x > 0)
   23c20:	e0bffc17 	ldw	r2,-16(fp)
   23c24:	10800843 	ldbu	r2,33(r2)
   23c28:	10803fcc 	andi	r2,r2,255
   23c2c:	10003326 	beq	r2,zero,23cfc <altera_avalon_lcd_16207_write+0x2a8>
        sp->x--;
   23c30:	e0bffc17 	ldw	r2,-16(fp)
   23c34:	10800843 	ldbu	r2,33(r2)
   23c38:	10bfffc4 	addi	r2,r2,-1
   23c3c:	1007883a 	mov	r3,r2
   23c40:	e0bffc17 	ldw	r2,-16(fp)
   23c44:	10c00845 	stb	r3,33(r2)
   23c48:	00002c06 	br	23cfc <altera_avalon_lcd_16207_write+0x2a8>
    }
    else if (isprint(c))
   23c4c:	008000f4 	movhi	r2,3
   23c50:	108d3e04 	addi	r2,r2,13560
   23c54:	10c00017 	ldw	r3,0(r2)
   23c58:	e0bff907 	ldb	r2,-28(fp)
   23c5c:	1885883a 	add	r2,r3,r2
   23c60:	10800003 	ldbu	r2,0(r2)
   23c64:	10803fcc 	andi	r2,r2,255
   23c68:	1080201c 	xori	r2,r2,128
   23c6c:	10bfe004 	addi	r2,r2,-128
   23c70:	108025cc 	andi	r2,r2,151
   23c74:	10002126 	beq	r2,zero,23cfc <altera_avalon_lcd_16207_write+0x2a8>
    {
      /* If we didn't scroll on the last linefeed then we might need to do
       * it now. */
      if (sp->y >= ALT_LCD_HEIGHT)
   23c78:	e0bffc17 	ldw	r2,-16(fp)
   23c7c:	10800883 	ldbu	r2,34(r2)
   23c80:	10803fcc 	andi	r2,r2,255
   23c84:	108000b0 	cmpltui	r2,r2,2
   23c88:	1000021e 	bne	r2,zero,23c94 <altera_avalon_lcd_16207_write+0x240>
        lcd_scroll_up(sp);
   23c8c:	e13ffc17 	ldw	r4,-16(fp)
   23c90:	00236cc0 	call	236cc <lcd_scroll_up>

      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
   23c94:	e0bffc17 	ldw	r2,-16(fp)
   23c98:	10800843 	ldbu	r2,33(r2)
   23c9c:	10803fcc 	andi	r2,r2,255
   23ca0:	10801428 	cmpgeui	r2,r2,80
   23ca4:	10000d1e 	bne	r2,zero,23cdc <altera_avalon_lcd_16207_write+0x288>
        sp->line[sp->y].data[sp->x] = c;
   23ca8:	e0bffc17 	ldw	r2,-16(fp)
   23cac:	10800883 	ldbu	r2,34(r2)
   23cb0:	10c03fcc 	andi	r3,r2,255
   23cb4:	e0bffc17 	ldw	r2,-16(fp)
   23cb8:	10800843 	ldbu	r2,33(r2)
   23cbc:	10803fcc 	andi	r2,r2,255
   23cc0:	e13ffc17 	ldw	r4,-16(fp)
   23cc4:	18c018e4 	muli	r3,r3,99
   23cc8:	20c7883a 	add	r3,r4,r3
   23ccc:	1885883a 	add	r2,r3,r2
   23cd0:	10801004 	addi	r2,r2,64
   23cd4:	e0fff903 	ldbu	r3,-28(fp)
   23cd8:	10c00005 	stb	r3,0(r2)

      sp->x++;
   23cdc:	e0bffc17 	ldw	r2,-16(fp)
   23ce0:	10800843 	ldbu	r2,33(r2)
   23ce4:	10800044 	addi	r2,r2,1
   23ce8:	1007883a 	mov	r3,r2
   23cec:	e0bffc17 	ldw	r2,-16(fp)
   23cf0:	10c00845 	stb	r3,33(r2)
   23cf4:	00000106 	br	23cfc <altera_avalon_lcd_16207_write+0x2a8>
        sp->esccount = -1;
      }
      else if (sp->esccount < sizeof(sp->escape)-1)
      {
        sp->escape[esccount] = c;
        sp->esccount++;
   23cf8:	0001883a 	nop

  /* Tell the routine which is called off the timer interrupt that the
   * foreground routines are active so it must not repaint the display. */
  sp->active = 1;

  for ( ; ptr < end ; ptr++)
   23cfc:	e0bffd17 	ldw	r2,-12(fp)
   23d00:	10800044 	addi	r2,r2,1
   23d04:	e0bffd15 	stw	r2,-12(fp)
   23d08:	e0fffd17 	ldw	r3,-12(fp)
   23d0c:	e0bff817 	ldw	r2,-32(fp)
   23d10:	18bf6036 	bltu	r3,r2,23a94 <altera_avalon_lcd_16207_write+0x40>
      sp->x++;
    }
  }

  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
   23d14:	00800404 	movi	r2,16
   23d18:	e0bff615 	stw	r2,-40(fp)
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   23d1c:	e03ff515 	stw	zero,-44(fp)
   23d20:	00003706 	br	23e00 <altera_avalon_lcd_16207_write+0x3ac>
  {
    int width;
    for (width = ALT_LCD_VIRTUAL_WIDTH ; width > 0 ; width--)
   23d24:	00801404 	movi	r2,80
   23d28:	e0bff715 	stw	r2,-36(fp)
   23d2c:	00001106 	br	23d74 <altera_avalon_lcd_16207_write+0x320>
      if (sp->line[y].data[width-1] != ' ')
   23d30:	e0bff717 	ldw	r2,-36(fp)
   23d34:	10bfffc4 	addi	r2,r2,-1
   23d38:	e13ffc17 	ldw	r4,-16(fp)
   23d3c:	e0fff517 	ldw	r3,-44(fp)
   23d40:	18c018e4 	muli	r3,r3,99
   23d44:	20c7883a 	add	r3,r4,r3
   23d48:	1885883a 	add	r2,r3,r2
   23d4c:	10801004 	addi	r2,r2,64
   23d50:	10800003 	ldbu	r2,0(r2)
   23d54:	10803fcc 	andi	r2,r2,255
   23d58:	1080201c 	xori	r2,r2,128
   23d5c:	10bfe004 	addi	r2,r2,-128
   23d60:	10800820 	cmpeqi	r2,r2,32
   23d64:	10000626 	beq	r2,zero,23d80 <altera_avalon_lcd_16207_write+0x32c>
  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
  {
    int width;
    for (width = ALT_LCD_VIRTUAL_WIDTH ; width > 0 ; width--)
   23d68:	e0bff717 	ldw	r2,-36(fp)
   23d6c:	10bfffc4 	addi	r2,r2,-1
   23d70:	e0bff715 	stw	r2,-36(fp)
   23d74:	e0bff717 	ldw	r2,-36(fp)
   23d78:	00bfed16 	blt	zero,r2,23d30 <altera_avalon_lcd_16207_write+0x2dc>
   23d7c:	00000106 	br	23d84 <altera_avalon_lcd_16207_write+0x330>
      if (sp->line[y].data[width-1] != ' ')
        break;
   23d80:	0001883a 	nop

    /* The minimum width is the size of the LCD panel.  If the real width
     * is long enough to require scrolling then add an extra space so the
     * end of the message doesn't run into the beginning of it.
     */
    if (width <= ALT_LCD_WIDTH)
   23d84:	e0bff717 	ldw	r2,-36(fp)
   23d88:	10800448 	cmpgei	r2,r2,17
   23d8c:	1000031e 	bne	r2,zero,23d9c <altera_avalon_lcd_16207_write+0x348>
      width = ALT_LCD_WIDTH;
   23d90:	00800404 	movi	r2,16
   23d94:	e0bff715 	stw	r2,-36(fp)
   23d98:	00000306 	br	23da8 <altera_avalon_lcd_16207_write+0x354>
    else
      width++;
   23d9c:	e0bff717 	ldw	r2,-36(fp)
   23da0:	10800044 	addi	r2,r2,1
   23da4:	e0bff715 	stw	r2,-36(fp)

    sp->line[y].width = width;
   23da8:	e0bff717 	ldw	r2,-36(fp)
   23dac:	1007883a 	mov	r3,r2
   23db0:	e13ffc17 	ldw	r4,-16(fp)
   23db4:	e0bff517 	ldw	r2,-44(fp)
   23db8:	108018e4 	muli	r2,r2,99
   23dbc:	2085883a 	add	r2,r4,r2
   23dc0:	10802404 	addi	r2,r2,144
   23dc4:	10c00045 	stb	r3,1(r2)
    if (widthmax < width)
   23dc8:	e0fff617 	ldw	r3,-40(fp)
   23dcc:	e0bff717 	ldw	r2,-36(fp)
   23dd0:	1880020e 	bge	r3,r2,23ddc <altera_avalon_lcd_16207_write+0x388>
      widthmax = width;
   23dd4:	e0bff717 	ldw	r2,-36(fp)
   23dd8:	e0bff615 	stw	r2,-40(fp)
    sp->line[y].speed = 0; /* By default lines don't scroll */
   23ddc:	e0fffc17 	ldw	r3,-16(fp)
   23de0:	e0bff517 	ldw	r2,-44(fp)
   23de4:	108018e4 	muli	r2,r2,99
   23de8:	1885883a 	add	r2,r3,r2
   23dec:	10802404 	addi	r2,r2,144
   23df0:	10000085 	stb	zero,2(r2)
    }
  }

  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   23df4:	e0bff517 	ldw	r2,-44(fp)
   23df8:	10800044 	addi	r2,r2,1
   23dfc:	e0bff515 	stw	r2,-44(fp)
   23e00:	e0bff517 	ldw	r2,-44(fp)
   23e04:	10800090 	cmplti	r2,r2,2
   23e08:	103fc61e 	bne	r2,zero,23d24 <altera_avalon_lcd_16207_write+0x2d0>
    if (widthmax < width)
      widthmax = width;
    sp->line[y].speed = 0; /* By default lines don't scroll */
  }

  if (widthmax <= ALT_LCD_WIDTH)
   23e0c:	e0bff617 	ldw	r2,-40(fp)
   23e10:	10800448 	cmpgei	r2,r2,17
   23e14:	1000031e 	bne	r2,zero,23e24 <altera_avalon_lcd_16207_write+0x3d0>
    sp->scrollmax = 0;
   23e18:	e0bffc17 	ldw	r2,-16(fp)
   23e1c:	10000985 	stb	zero,38(r2)
   23e20:	00002d06 	br	23ed8 <altera_avalon_lcd_16207_write+0x484>
  else
  {
    widthmax *= 2;
   23e24:	e0bff617 	ldw	r2,-40(fp)
   23e28:	1085883a 	add	r2,r2,r2
   23e2c:	e0bff615 	stw	r2,-40(fp)
    sp->scrollmax = widthmax;
   23e30:	e0bff617 	ldw	r2,-40(fp)
   23e34:	1007883a 	mov	r3,r2
   23e38:	e0bffc17 	ldw	r2,-16(fp)
   23e3c:	10c00985 	stb	r3,38(r2)

    /* Now calculate how fast each of the other lines should go */
    for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   23e40:	e03ff515 	stw	zero,-44(fp)
   23e44:	00002106 	br	23ecc <altera_avalon_lcd_16207_write+0x478>
      if (sp->line[y].width > ALT_LCD_WIDTH)
   23e48:	e0fffc17 	ldw	r3,-16(fp)
   23e4c:	e0bff517 	ldw	r2,-44(fp)
   23e50:	108018e4 	muli	r2,r2,99
   23e54:	1885883a 	add	r2,r3,r2
   23e58:	10802404 	addi	r2,r2,144
   23e5c:	10800043 	ldbu	r2,1(r2)
   23e60:	10803fcc 	andi	r2,r2,255
   23e64:	1080201c 	xori	r2,r2,128
   23e68:	10bfe004 	addi	r2,r2,-128
   23e6c:	10800450 	cmplti	r2,r2,17
   23e70:	1000131e 	bne	r2,zero,23ec0 <altera_avalon_lcd_16207_write+0x46c>
         */
#if 1
        /* This option makes all the lines scroll round at different speeds
         * which are chosen so that all the scrolls finish at the same time.
         */
        sp->line[y].speed = 256 * sp->line[y].width / widthmax;
   23e74:	e0fffc17 	ldw	r3,-16(fp)
   23e78:	e0bff517 	ldw	r2,-44(fp)
   23e7c:	108018e4 	muli	r2,r2,99
   23e80:	1885883a 	add	r2,r3,r2
   23e84:	10802404 	addi	r2,r2,144
   23e88:	10800043 	ldbu	r2,1(r2)
   23e8c:	10803fcc 	andi	r2,r2,255
   23e90:	1080201c 	xori	r2,r2,128
   23e94:	10bfe004 	addi	r2,r2,-128
   23e98:	1006923a 	slli	r3,r2,8
   23e9c:	e0bff617 	ldw	r2,-40(fp)
   23ea0:	1885283a 	div	r2,r3,r2
   23ea4:	1007883a 	mov	r3,r2
   23ea8:	e13ffc17 	ldw	r4,-16(fp)
   23eac:	e0bff517 	ldw	r2,-44(fp)
   23eb0:	108018e4 	muli	r2,r2,99
   23eb4:	2085883a 	add	r2,r4,r2
   23eb8:	10802404 	addi	r2,r2,144
   23ebc:	10c00085 	stb	r3,2(r2)
  {
    widthmax *= 2;
    sp->scrollmax = widthmax;

    /* Now calculate how fast each of the other lines should go */
    for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   23ec0:	e0bff517 	ldw	r2,-44(fp)
   23ec4:	10800044 	addi	r2,r2,1
   23ec8:	e0bff515 	stw	r2,-44(fp)
   23ecc:	e0bff517 	ldw	r2,-44(fp)
   23ed0:	10800090 	cmplti	r2,r2,2
   23ed4:	103fdc1e 	bne	r2,zero,23e48 <altera_avalon_lcd_16207_write+0x3f4>
   * (because active was set when the timer interrupt occurred).  If there
   * has been a missed repaint then paint again.  And again.  etc.
   */
  for ( ; ; )
  {
    int old_scrollpos = sp->scrollpos;
   23ed8:	e0bffc17 	ldw	r2,-16(fp)
   23edc:	10800943 	ldbu	r2,37(r2)
   23ee0:	10803fcc 	andi	r2,r2,255
   23ee4:	e0bffb15 	stw	r2,-20(fp)

    lcd_repaint_screen(sp);
   23ee8:	e13ffc17 	ldw	r4,-16(fp)
   23eec:	00234e00 	call	234e0 <lcd_repaint_screen>

    /* Let the timer routines repaint the display again */
    sp->active = 0;
   23ef0:	e0bffc17 	ldw	r2,-16(fp)
   23ef4:	100009c5 	stb	zero,39(r2)

    /* Have the timer routines tried to scroll while we were painting?
     * If not then we can exit */
    if (sp->scrollpos == old_scrollpos)
   23ef8:	e0bffc17 	ldw	r2,-16(fp)
   23efc:	10800943 	ldbu	r2,37(r2)
   23f00:	10c03fcc 	andi	r3,r2,255
   23f04:	e0bffb17 	ldw	r2,-20(fp)
   23f08:	18800426 	beq	r3,r2,23f1c <altera_avalon_lcd_16207_write+0x4c8>
      break;

    /* We need to repaint again since the display scrolled while we were
     * painting last time */
    sp->active = 1;
   23f0c:	e0bffc17 	ldw	r2,-16(fp)
   23f10:	00c00044 	movi	r3,1
   23f14:	10c009c5 	stb	r3,39(r2)
  }
   23f18:	003fef06 	br	23ed8 <altera_avalon_lcd_16207_write+0x484>
    sp->active = 0;

    /* Have the timer routines tried to scroll while we were painting?
     * If not then we can exit */
    if (sp->scrollpos == old_scrollpos)
      break;
   23f1c:	0001883a 	nop
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->write_lock);

  return len;
   23f20:	e0bffe17 	ldw	r2,-8(fp)
}
   23f24:	e037883a 	mov	sp,fp
   23f28:	dfc00117 	ldw	ra,4(sp)
   23f2c:	df000017 	ldw	fp,0(sp)
   23f30:	dec00204 	addi	sp,sp,8
   23f34:	f800283a 	ret

00023f38 <alt_lcd_16207_timeout>:
/*
 * Timeout routine is called every second
 */

static alt_u32 alt_lcd_16207_timeout(void* context) 
{
   23f38:	defffc04 	addi	sp,sp,-16
   23f3c:	dfc00315 	stw	ra,12(sp)
   23f40:	df000215 	stw	fp,8(sp)
   23f44:	df000204 	addi	fp,sp,8
   23f48:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_lcd_16207_state* sp = (altera_avalon_lcd_16207_state*)context;
   23f4c:	e0bfff17 	ldw	r2,-4(fp)
   23f50:	e0bffe15 	stw	r2,-8(fp)

  /* Update the scrolling position */
  if (sp->scrollpos + 1 >= sp->scrollmax)
   23f54:	e0bffe17 	ldw	r2,-8(fp)
   23f58:	10800943 	ldbu	r2,37(r2)
   23f5c:	10803fcc 	andi	r2,r2,255
   23f60:	10c00044 	addi	r3,r2,1
   23f64:	e0bffe17 	ldw	r2,-8(fp)
   23f68:	10800983 	ldbu	r2,38(r2)
   23f6c:	10803fcc 	andi	r2,r2,255
   23f70:	18800316 	blt	r3,r2,23f80 <alt_lcd_16207_timeout+0x48>
    sp->scrollpos = 0;
   23f74:	e0bffe17 	ldw	r2,-8(fp)
   23f78:	10000945 	stb	zero,37(r2)
   23f7c:	00000606 	br	23f98 <alt_lcd_16207_timeout+0x60>
  else
    sp->scrollpos = sp->scrollpos + 1;
   23f80:	e0bffe17 	ldw	r2,-8(fp)
   23f84:	10800943 	ldbu	r2,37(r2)
   23f88:	10800044 	addi	r2,r2,1
   23f8c:	1007883a 	mov	r3,r2
   23f90:	e0bffe17 	ldw	r2,-8(fp)
   23f94:	10c00945 	stb	r3,37(r2)

  /* Repaint the panel unless the foreground will do it again soon */
  if (sp->scrollmax > 0 && !sp->active)
   23f98:	e0bffe17 	ldw	r2,-8(fp)
   23f9c:	10800983 	ldbu	r2,38(r2)
   23fa0:	10803fcc 	andi	r2,r2,255
   23fa4:	10000826 	beq	r2,zero,23fc8 <alt_lcd_16207_timeout+0x90>
   23fa8:	e0bffe17 	ldw	r2,-8(fp)
   23fac:	108009c3 	ldbu	r2,39(r2)
   23fb0:	10803fcc 	andi	r2,r2,255
   23fb4:	1080201c 	xori	r2,r2,128
   23fb8:	10bfe004 	addi	r2,r2,-128
   23fbc:	1000021e 	bne	r2,zero,23fc8 <alt_lcd_16207_timeout+0x90>
    lcd_repaint_screen(sp);
   23fc0:	e13ffe17 	ldw	r4,-8(fp)
   23fc4:	00234e00 	call	234e0 <lcd_repaint_screen>

  return sp->period;
   23fc8:	e0bffe17 	ldw	r2,-8(fp)
   23fcc:	10800717 	ldw	r2,28(r2)
}
   23fd0:	e037883a 	mov	sp,fp
   23fd4:	dfc00117 	ldw	ra,4(sp)
   23fd8:	df000017 	ldw	fp,0(sp)
   23fdc:	dec00204 	addi	sp,sp,8
   23fe0:	f800283a 	ret

00023fe4 <altera_avalon_lcd_16207_init>:

/*
 * Called at boot time to initialise the LCD driver
 */
void altera_avalon_lcd_16207_init(altera_avalon_lcd_16207_state* sp)
{
   23fe4:	defffc04 	addi	sp,sp,-16
   23fe8:	dfc00315 	stw	ra,12(sp)
   23fec:	df000215 	stw	fp,8(sp)
   23ff0:	df000204 	addi	fp,sp,8
   23ff4:	e13fff15 	stw	r4,-4(fp)
  unsigned int base = sp->base;
   23ff8:	e0bfff17 	ldw	r2,-4(fp)
   23ffc:	10800017 	ldw	r2,0(r2)
   24000:	e0bffe15 	stw	r2,-8(fp)

  /* Mark the device as functional */
  sp->broken = 0;
   24004:	e0bfff17 	ldw	r2,-4(fp)
   24008:	10000805 	stb	zero,32(r2)
   * the BUSY bit in the status register doesn't work until the display
   * has been reset three times.
   */

  /* Wait for 15 ms then reset */
  usleep(15000);
   2400c:	010ea604 	movi	r4,15000
   24010:	002081c0 	call	2081c <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
   24014:	e0bffe17 	ldw	r2,-8(fp)
   24018:	00c00c04 	movi	r3,48
   2401c:	10c00035 	stwio	r3,0(r2)

  /* Wait for another 4.1ms and reset again */
  usleep(4100);  
   24020:	01040104 	movi	r4,4100
   24024:	002081c0 	call	2081c <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
   24028:	e0bffe17 	ldw	r2,-8(fp)
   2402c:	00c00c04 	movi	r3,48
   24030:	10c00035 	stwio	r3,0(r2)

  /* Wait a further 1 ms and reset a third time */
  usleep(1000);
   24034:	0100fa04 	movi	r4,1000
   24038:	002081c0 	call	2081c <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
   2403c:	e0bffe17 	ldw	r2,-8(fp)
   24040:	00c00c04 	movi	r3,48
   24044:	10c00035 	stwio	r3,0(r2)

  /* Setup interface parameters: 8 bit bus, 2 rows, 5x7 font */
  lcd_write_command(sp, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT | LCD_CMD_TWO_LINE);
   24048:	e13fff17 	ldw	r4,-4(fp)
   2404c:	01400e04 	movi	r5,56
   24050:	00232900 	call	23290 <lcd_write_command>
  
  /* Turn display off */
  lcd_write_command(sp, LCD_CMD_ONOFF);
   24054:	e13fff17 	ldw	r4,-4(fp)
   24058:	01400204 	movi	r5,8
   2405c:	00232900 	call	23290 <lcd_write_command>

  /* Clear display */
  lcd_clear_screen(sp);
   24060:	e13fff17 	ldw	r4,-4(fp)
   24064:	00234140 	call	23414 <lcd_clear_screen>
  
  /* Set mode: increment after writing, don't shift display */
  lcd_write_command(sp, LCD_CMD_MODES | LCD_CMD_MODE_INC);
   24068:	e13fff17 	ldw	r4,-4(fp)
   2406c:	01400184 	movi	r5,6
   24070:	00232900 	call	23290 <lcd_write_command>

  /* Turn display on */
  lcd_write_command(sp, LCD_CMD_ONOFF | LCD_CMD_ENABLE_DISP);
   24074:	e13fff17 	ldw	r4,-4(fp)
   24078:	01400304 	movi	r5,12
   2407c:	00232900 	call	23290 <lcd_write_command>

  sp->esccount = -1;
   24080:	e0bfff17 	ldw	r2,-4(fp)
   24084:	00ffffc4 	movi	r3,-1
   24088:	10c00905 	stb	r3,36(r2)
  memset(sp->escape, 0, sizeof(sp->escape));
   2408c:	e0bfff17 	ldw	r2,-4(fp)
   24090:	10800a04 	addi	r2,r2,40
   24094:	1009883a 	mov	r4,r2
   24098:	000b883a 	mov	r5,zero
   2409c:	01800204 	movi	r6,8
   240a0:	00165b80 	call	165b8 <memset>

  sp->scrollpos = 0;
   240a4:	e0bfff17 	ldw	r2,-4(fp)
   240a8:	10000945 	stb	zero,37(r2)
  sp->scrollmax = 0;
   240ac:	e0bfff17 	ldw	r2,-4(fp)
   240b0:	10000985 	stb	zero,38(r2)
  sp->active = 0;
   240b4:	e0bfff17 	ldw	r2,-4(fp)
   240b8:	100009c5 	stb	zero,39(r2)
   240bc:	008000f4 	movhi	r2,3
   240c0:	10961504 	addi	r2,r2,22612
   240c4:	10800017 	ldw	r2,0(r2)

  sp->period = alt_ticks_per_second() / 10; /* Call every 100ms */
   240c8:	1007883a 	mov	r3,r2
   240cc:	00800284 	movi	r2,10
   240d0:	1885203a 	divu	r2,r3,r2
   240d4:	1007883a 	mov	r3,r2
   240d8:	e0bfff17 	ldw	r2,-4(fp)
   240dc:	10c00715 	stw	r3,28(r2)

  alt_alarm_start(&sp->alarm, sp->period, &alt_lcd_16207_timeout, sp);
   240e0:	e0bfff17 	ldw	r2,-4(fp)
   240e4:	10c00104 	addi	r3,r2,4
   240e8:	e0bfff17 	ldw	r2,-4(fp)
   240ec:	10800717 	ldw	r2,28(r2)
   240f0:	1809883a 	mov	r4,r3
   240f4:	100b883a 	mov	r5,r2
   240f8:	018000b4 	movhi	r6,2
   240fc:	318fce04 	addi	r6,r6,16184
   24100:	e1ffff17 	ldw	r7,-4(fp)
   24104:	001fbb40 	call	1fbb4 <alt_alarm_start>
}
   24108:	e037883a 	mov	sp,fp
   2410c:	dfc00117 	ldw	ra,4(sp)
   24110:	df000017 	ldw	fp,0(sp)
   24114:	dec00204 	addi	sp,sp,8
   24118:	f800283a 	ret

0002411c <altera_avalon_lcd_16207_write_fd>:
extern int altera_avalon_lcd_16207_write(altera_avalon_lcd_16207_state* sp,
  const char* ptr, int count, int flags);

int 
altera_avalon_lcd_16207_write_fd(alt_fd* fd, const char* buffer, int space)
{
   2411c:	defffa04 	addi	sp,sp,-24
   24120:	dfc00515 	stw	ra,20(sp)
   24124:	df000415 	stw	fp,16(sp)
   24128:	df000404 	addi	fp,sp,16
   2412c:	e13ffd15 	stw	r4,-12(fp)
   24130:	e17ffe15 	stw	r5,-8(fp)
   24134:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_lcd_16207_dev* dev = (altera_avalon_lcd_16207_dev*) fd->dev; 
   24138:	e0bffd17 	ldw	r2,-12(fp)
   2413c:	10800017 	ldw	r2,0(r2)
   24140:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_lcd_16207_write(&dev->state, buffer, space,
   24144:	e0bffc17 	ldw	r2,-16(fp)
   24148:	10c00a04 	addi	r3,r2,40
      fd->fd_flags);
   2414c:	e0bffd17 	ldw	r2,-12(fp)
int 
altera_avalon_lcd_16207_write_fd(alt_fd* fd, const char* buffer, int space)
{
    altera_avalon_lcd_16207_dev* dev = (altera_avalon_lcd_16207_dev*) fd->dev; 

    return altera_avalon_lcd_16207_write(&dev->state, buffer, space,
   24150:	10800217 	ldw	r2,8(r2)
   24154:	1809883a 	mov	r4,r3
   24158:	e17ffe17 	ldw	r5,-8(fp)
   2415c:	e1bfff17 	ldw	r6,-4(fp)
   24160:	100f883a 	mov	r7,r2
   24164:	0023a540 	call	23a54 <altera_avalon_lcd_16207_write>
      fd->fd_flags);
}
   24168:	e037883a 	mov	sp,fp
   2416c:	dfc00117 	ldw	ra,4(sp)
   24170:	df000017 	ldw	fp,0(sp)
   24174:	dec00204 	addi	sp,sp,8
   24178:	f800283a 	ret

0002417c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   2417c:	defffe04 	addi	sp,sp,-8
   24180:	dfc00115 	stw	ra,4(sp)
   24184:	df000015 	stw	fp,0(sp)
   24188:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   2418c:	008000f4 	movhi	r2,3
   24190:	108d3404 	addi	r2,r2,13520
   24194:	10800017 	ldw	r2,0(r2)
   24198:	10000526 	beq	r2,zero,241b0 <alt_get_errno+0x34>
   2419c:	008000f4 	movhi	r2,3
   241a0:	108d3404 	addi	r2,r2,13520
   241a4:	10800017 	ldw	r2,0(r2)
   241a8:	103ee83a 	callr	r2
   241ac:	00000206 	br	241b8 <alt_get_errno+0x3c>
   241b0:	008000f4 	movhi	r2,3
   241b4:	10961104 	addi	r2,r2,22596
}
   241b8:	e037883a 	mov	sp,fp
   241bc:	dfc00117 	ldw	ra,4(sp)
   241c0:	df000017 	ldw	fp,0(sp)
   241c4:	dec00204 	addi	sp,sp,8
   241c8:	f800283a 	ret

000241cc <alt_avalon_sgdma_do_async_transfer>:
 * - 0 for success, or various errors defined in <errno.h>
 */
int alt_avalon_sgdma_do_async_transfer(
  alt_sgdma_dev *dev,
  alt_sgdma_descriptor *desc)
{
   241cc:	defffc04 	addi	sp,sp,-16
   241d0:	df000315 	stw	fp,12(sp)
   241d4:	df000304 	addi	fp,sp,12
   241d8:	e13ffe15 	stw	r4,-8(fp)
   241dc:	e17fff15 	stw	r5,-4(fp)
  alt_u32 control;

  /* Return with error immediately if controller is busy */
  if( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
   241e0:	e0bffe17 	ldw	r2,-8(fp)
   241e4:	10800317 	ldw	r2,12(r2)
   241e8:	10800037 	ldwio	r2,0(r2)
   241ec:	1080040c 	andi	r2,r2,16
   241f0:	10000226 	beq	r2,zero,241fc <alt_avalon_sgdma_do_async_transfer+0x30>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    return -EBUSY;
   241f4:	00bffc04 	movi	r2,-16
   241f8:	00003906 	br	242e0 <alt_avalon_sgdma_do_async_transfer+0x114>
  }

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
   241fc:	e0bffe17 	ldw	r2,-8(fp)
   24200:	10800317 	ldw	r2,12(r2)
   24204:	10800404 	addi	r2,r2,16
   24208:	e0fffe17 	ldw	r3,-8(fp)
   2420c:	18c00317 	ldw	r3,12(r3)
   24210:	18c00404 	addi	r3,r3,16
   24214:	19000037 	ldwio	r4,0(r3)
   24218:	00fff7c4 	movi	r3,-33
   2421c:	20c6703a 	and	r3,r4,r3
   24220:	10c00035 	stwio	r3,0(r2)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
   24224:	e0bffe17 	ldw	r2,-8(fp)
   24228:	10800317 	ldw	r2,12(r2)
   2422c:	00c03fc4 	movi	r3,255
   24230:	10c00035 	stwio	r3,0(r2)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
   24234:	e0bffe17 	ldw	r2,-8(fp)
   24238:	10800317 	ldw	r2,12(r2)
   2423c:	10800804 	addi	r2,r2,32
   24240:	e0ffff17 	ldw	r3,-4(fp)
   24244:	10c00035 	stwio	r3,0(r2)
   *  - Stop on an error with any particular descriptor
   *  - Include any control register bits registered with along with
   *    the callback routine (effectively, interrupts are controlled
   *    via the control bits set during callback-register time).
   */
  if(dev->callback) {
   24248:	e0bffe17 	ldw	r2,-8(fp)
   2424c:	10800917 	ldw	r2,36(r2)
   24250:	10001126 	beq	r2,zero,24298 <alt_avalon_sgdma_do_async_transfer+0xcc>
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
   24254:	e0bffe17 	ldw	r2,-8(fp)
   24258:	10800317 	ldw	r2,12(r2)
   2425c:	10800404 	addi	r2,r2,16
   24260:	10800037 	ldwio	r2,0(r2)
   24264:	e0bffd15 	stw	r2,-12(fp)

    control |= (dev->chain_control                          |
   24268:	e0bffe17 	ldw	r2,-8(fp)
   2426c:	10c00b17 	ldw	r3,44(r2)
   24270:	e0bffd17 	ldw	r2,-12(fp)
   24274:	1884b03a 	or	r2,r3,r2
   24278:	10801814 	ori	r2,r2,96
   2427c:	e0bffd15 	stw	r2,-12(fp)
                ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK  );

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
   24280:	e0bffe17 	ldw	r2,-8(fp)
   24284:	10800317 	ldw	r2,12(r2)
   24288:	10800404 	addi	r2,r2,16
   2428c:	e0fffd17 	ldw	r3,-12(fp)
   24290:	10c00035 	stwio	r3,0(r2)
   24294:	00001106 	br	242dc <alt_avalon_sgdma_do_async_transfer+0x110>
   *   - Run
   *   - Stop on an error with any particular descriptor
   *   - Disable interrupt generation
   */
  else {
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
   24298:	e0bffe17 	ldw	r2,-8(fp)
   2429c:	10800317 	ldw	r2,12(r2)
   242a0:	10800404 	addi	r2,r2,16
   242a4:	10800037 	ldwio	r2,0(r2)
   242a8:	e0bffd15 	stw	r2,-12(fp)

    control |= (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
   242ac:	e0bffd17 	ldw	r2,-12(fp)
   242b0:	10801814 	ori	r2,r2,96
   242b4:	e0bffd15 	stw	r2,-12(fp)
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK );
    control &= ~ALTERA_AVALON_SGDMA_CONTROL_IE_GLOBAL_MSK;
   242b8:	e0fffd17 	ldw	r3,-12(fp)
   242bc:	00bffbc4 	movi	r2,-17
   242c0:	1884703a 	and	r2,r3,r2
   242c4:	e0bffd15 	stw	r2,-12(fp)

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
   242c8:	e0bffe17 	ldw	r2,-8(fp)
   242cc:	10800317 	ldw	r2,12(r2)
   242d0:	10800404 	addi	r2,r2,16
   242d4:	e0fffd17 	ldw	r3,-12(fp)
   242d8:	10c00035 	stwio	r3,0(r2)

  /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
  return 0;
   242dc:	0005883a 	mov	r2,zero
}
   242e0:	e037883a 	mov	sp,fp
   242e4:	df000017 	ldw	fp,0(sp)
   242e8:	dec00104 	addi	sp,sp,4
   242ec:	f800283a 	ret

000242f0 <alt_avalon_sgdma_do_sync_transfer>:
 * - status: Content of SGDMA status register.
 */
alt_u8 alt_avalon_sgdma_do_sync_transfer(
  alt_sgdma_dev *dev,
  alt_sgdma_descriptor *desc)
{
   242f0:	defffc04 	addi	sp,sp,-16
   242f4:	df000315 	stw	fp,12(sp)
   242f8:	df000304 	addi	fp,sp,12
   242fc:	e13ffe15 	stw	r4,-8(fp)
   24300:	e17fff15 	stw	r5,-4(fp)
  alt_u8 status;

  /* Wait for any pending transfers to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
   24304:	0001883a 	nop
   24308:	e0bffe17 	ldw	r2,-8(fp)
   2430c:	10800317 	ldw	r2,12(r2)
   24310:	10800037 	ldwio	r2,0(r2)
   24314:	1080040c 	andi	r2,r2,16
   24318:	103ffb1e 	bne	r2,zero,24308 <alt_avalon_sgdma_do_sync_transfer+0x18>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );


  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
   2431c:	e0bffe17 	ldw	r2,-8(fp)
   24320:	10800317 	ldw	r2,12(r2)
   24324:	10800404 	addi	r2,r2,16
   24328:	e0fffe17 	ldw	r3,-8(fp)
   2432c:	18c00317 	ldw	r3,12(r3)
   24330:	18c00404 	addi	r3,r3,16
   24334:	19000037 	ldwio	r4,0(r3)
   24338:	00fff7c4 	movi	r3,-33
   2433c:	20c6703a 	and	r3,r4,r3
   24340:	10c00035 	stwio	r3,0(r2)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
   24344:	e0bffe17 	ldw	r2,-8(fp)
   24348:	10800317 	ldw	r2,12(r2)
   2434c:	00c03fc4 	movi	r3,255
   24350:	10c00035 	stwio	r3,0(r2)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
   24354:	e0bffe17 	ldw	r2,-8(fp)
   24358:	10800317 	ldw	r2,12(r2)
   2435c:	10800804 	addi	r2,r2,32
   24360:	e0ffff17 	ldw	r3,-4(fp)
   24364:	10c00035 	stwio	r3,0(r2)
   * Set up SGDMA controller to:
   * - Disable interrupt generation
   * - Run once a valid descriptor is written to controller
   * - Stop on an error with any particular descriptor
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
   24368:	e0bffe17 	ldw	r2,-8(fp)
   2436c:	10800317 	ldw	r2,12(r2)
   24370:	10800404 	addi	r2,r2,16
   24374:	e0fffe17 	ldw	r3,-8(fp)
   24378:	18c00317 	ldw	r3,12(r3)
   2437c:	18c00404 	addi	r3,r3,16
   24380:	18c00037 	ldwio	r3,0(r3)
   24384:	18c01814 	ori	r3,r3,96
   24388:	10c00035 	stwio	r3,0(r2)
    (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK |
     ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK | 
     IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base)) );

  /* Wait for the descriptor (chain) to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
   2438c:	0001883a 	nop
   24390:	e0bffe17 	ldw	r2,-8(fp)
   24394:	10800317 	ldw	r2,12(r2)
   24398:	10800037 	ldwio	r2,0(r2)
   2439c:	1080040c 	andi	r2,r2,16
   243a0:	103ffb1e 	bne	r2,zero,24390 <alt_avalon_sgdma_do_sync_transfer+0xa0>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
   243a4:	e0bffe17 	ldw	r2,-8(fp)
   243a8:	10800317 	ldw	r2,12(r2)
   243ac:	10800404 	addi	r2,r2,16
   243b0:	e0fffe17 	ldw	r3,-8(fp)
   243b4:	18c00317 	ldw	r3,12(r3)
   243b8:	18c00404 	addi	r3,r3,16
   243bc:	19000037 	ldwio	r4,0(r3)
   243c0:	00fff7c4 	movi	r3,-33
   243c4:	20c6703a 	and	r3,r4,r3
   243c8:	10c00035 	stwio	r3,0(r2)
    (IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) &
     ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK) );

  /* Get & clear status register contents */
  status = IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base);
   243cc:	e0bffe17 	ldw	r2,-8(fp)
   243d0:	10800317 	ldw	r2,12(r2)
   243d4:	10800037 	ldwio	r2,0(r2)
   243d8:	e0bffd05 	stb	r2,-12(fp)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
   243dc:	e0bffe17 	ldw	r2,-8(fp)
   243e0:	10800317 	ldw	r2,12(r2)
   243e4:	00c03fc4 	movi	r3,255
   243e8:	10c00035 	stwio	r3,0(r2)

  return status;
   243ec:	e0bffd03 	ldbu	r2,-12(fp)
}
   243f0:	e037883a 	mov	sp,fp
   243f4:	df000017 	ldw	fp,0(sp)
   243f8:	dec00104 	addi	sp,sp,4
   243fc:	f800283a 	ret

00024400 <alt_avalon_sgdma_construct_mem_to_mem_desc>:
  alt_u32              *read_addr,
  alt_u32              *write_addr,
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed)
{
   24400:	defff404 	addi	sp,sp,-48
   24404:	dfc00b15 	stw	ra,44(sp)
   24408:	df000a15 	stw	fp,40(sp)
   2440c:	df000a04 	addi	fp,sp,40
   24410:	e13ffb15 	stw	r4,-20(fp)
   24414:	e17ffc15 	stw	r5,-16(fp)
   24418:	e1bffd15 	stw	r6,-12(fp)
   2441c:	e1fffe15 	stw	r7,-8(fp)
   24420:	e0800217 	ldw	r2,8(fp)
   24424:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_mem_to_mem_desc_burst(desc, next, read_addr, 
   24428:	e0bfff0b 	ldhu	r2,-4(fp)
   2442c:	d8800015 	stw	r2,0(sp)
   24430:	e0800317 	ldw	r2,12(fp)
   24434:	d8800115 	stw	r2,4(sp)
   24438:	e0800417 	ldw	r2,16(fp)
   2443c:	d8800215 	stw	r2,8(sp)
   24440:	d8000315 	stw	zero,12(sp)
   24444:	d8000415 	stw	zero,16(sp)
   24448:	e13ffb17 	ldw	r4,-20(fp)
   2444c:	e17ffc17 	ldw	r5,-16(fp)
   24450:	e1bffd17 	ldw	r6,-12(fp)
   24454:	e1fffe17 	ldw	r7,-8(fp)
   24458:	00244700 	call	24470 <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>
    write_addr, length, read_fixed, write_fixed, 0, 0);
}
   2445c:	e037883a 	mov	sp,fp
   24460:	dfc00117 	ldw	ra,4(sp)
   24464:	df000017 	ldw	fp,0(sp)
   24468:	dec00204 	addi	sp,sp,8
   2446c:	f800283a 	ret

00024470 <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>:
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed,
  int                   read_burst,
  int                   write_burst)
{
   24470:	defff204 	addi	sp,sp,-56
   24474:	dfc00d15 	stw	ra,52(sp)
   24478:	df000c15 	stw	fp,48(sp)
   2447c:	df000c04 	addi	fp,sp,48
   24480:	e13ffb15 	stw	r4,-20(fp)
   24484:	e17ffc15 	stw	r5,-16(fp)
   24488:	e1bffd15 	stw	r6,-12(fp)
   2448c:	e1fffe15 	stw	r7,-8(fp)
   24490:	e0800217 	ldw	r2,8(fp)
   24494:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
   24498:	e0bfff0b 	ldhu	r2,-4(fp)
   2449c:	d8800015 	stw	r2,0(sp)
   244a0:	d8000115 	stw	zero,4(sp)
   244a4:	e0800317 	ldw	r2,12(fp)
   244a8:	d8800215 	stw	r2,8(sp)
   244ac:	e0800417 	ldw	r2,16(fp)
   244b0:	d8800315 	stw	r2,12(sp)
   244b4:	e0800517 	ldw	r2,20(fp)
   244b8:	d8800415 	stw	r2,16(sp)
   244bc:	e0800617 	ldw	r2,24(fp)
   244c0:	d8800515 	stw	r2,20(sp)
   244c4:	d8000615 	stw	zero,24(sp)
   244c8:	e13ffb17 	ldw	r4,-20(fp)
   244cc:	e17ffc17 	ldw	r5,-16(fp)
   244d0:	e1bffd17 	ldw	r6,-12(fp)
   244d4:	e1fffe17 	ldw	r7,-8(fp)
   244d8:	00249dc0 	call	249dc <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    write_fixed,
    read_burst,
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in mem-to-mem mode
}
   244dc:	e037883a 	mov	sp,fp
   244e0:	dfc00117 	ldw	ra,4(sp)
   244e4:	df000017 	ldw	fp,0(sp)
   244e8:	dec00204 	addi	sp,sp,8
   244ec:	f800283a 	ret

000244f0 <alt_avalon_sgdma_construct_stream_to_mem_desc>:
  alt_sgdma_descriptor *desc,
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed)
{
   244f0:	defff804 	addi	sp,sp,-32
   244f4:	dfc00715 	stw	ra,28(sp)
   244f8:	df000615 	stw	fp,24(sp)
   244fc:	df000604 	addi	fp,sp,24
   24500:	e13ffc15 	stw	r4,-16(fp)
   24504:	e17ffd15 	stw	r5,-12(fp)
   24508:	e1bffe15 	stw	r6,-8(fp)
   2450c:	3805883a 	mov	r2,r7
   24510:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_stream_to_mem_desc_burst(desc, next, write_addr, 
   24514:	e0bfff0b 	ldhu	r2,-4(fp)
   24518:	e0c00217 	ldw	r3,8(fp)
   2451c:	d8c00015 	stw	r3,0(sp)
   24520:	d8000115 	stw	zero,4(sp)
   24524:	e13ffc17 	ldw	r4,-16(fp)
   24528:	e17ffd17 	ldw	r5,-12(fp)
   2452c:	e1bffe17 	ldw	r6,-8(fp)
   24530:	100f883a 	mov	r7,r2
   24534:	002454c0 	call	2454c <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>
    length_or_eop, write_fixed, 0);
}
   24538:	e037883a 	mov	sp,fp
   2453c:	dfc00117 	ldw	ra,4(sp)
   24540:	df000017 	ldw	fp,0(sp)
   24544:	dec00204 	addi	sp,sp,8
   24548:	f800283a 	ret

0002454c <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>:
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed,
  int                   write_burst)
{
   2454c:	defff304 	addi	sp,sp,-52
   24550:	dfc00c15 	stw	ra,48(sp)
   24554:	df000b15 	stw	fp,44(sp)
   24558:	df000b04 	addi	fp,sp,44
   2455c:	e13ffc15 	stw	r4,-16(fp)
   24560:	e17ffd15 	stw	r5,-12(fp)
   24564:	e1bffe15 	stw	r6,-8(fp)
   24568:	3805883a 	mov	r2,r7
   2456c:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
   24570:	e0bfff0b 	ldhu	r2,-4(fp)
   24574:	d8800015 	stw	r2,0(sp)
   24578:	d8000115 	stw	zero,4(sp)
   2457c:	d8000215 	stw	zero,8(sp)
   24580:	e0800217 	ldw	r2,8(fp)
   24584:	d8800315 	stw	r2,12(sp)
   24588:	d8000415 	stw	zero,16(sp)
   2458c:	e0800317 	ldw	r2,12(fp)
   24590:	d8800515 	stw	r2,20(sp)
   24594:	d8000615 	stw	zero,24(sp)
   24598:	e13ffc17 	ldw	r4,-16(fp)
   2459c:	e17ffd17 	ldw	r5,-12(fp)
   245a0:	000d883a 	mov	r6,zero
   245a4:	e1fffe17 	ldw	r7,-8(fp)
   245a8:	00249dc0 	call	249dc <alt_avalon_sgdma_construct_descriptor_burst>
    0x0,            // Read fixed: N/A in stream-to-mem mode
    write_fixed,
    0,              // Read_burst : N/A in stream-to-mem mode
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in stream-to-mem mode
}
   245ac:	e037883a 	mov	sp,fp
   245b0:	dfc00117 	ldw	ra,4(sp)
   245b4:	df000017 	ldw	fp,0(sp)
   245b8:	dec00204 	addi	sp,sp,8
   245bc:	f800283a 	ret

000245c0 <alt_avalon_sgdma_construct_mem_to_stream_desc>:
  alt_u16               length,
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  alt_u8                atlantic_channel)
{
   245c0:	defff404 	addi	sp,sp,-48
   245c4:	dfc00b15 	stw	ra,44(sp)
   245c8:	df000a15 	stw	fp,40(sp)
   245cc:	df000a04 	addi	fp,sp,40
   245d0:	e13ffb15 	stw	r4,-20(fp)
   245d4:	e17ffc15 	stw	r5,-16(fp)
   245d8:	e1bffd15 	stw	r6,-12(fp)
   245dc:	3805883a 	mov	r2,r7
   245e0:	e0c00517 	ldw	r3,20(fp)
   245e4:	e0bffe0d 	sth	r2,-8(fp)
   245e8:	e0ffff05 	stb	r3,-4(fp)
  alt_avalon_sgdma_construct_mem_to_stream_desc_burst(desc, next, read_addr, 
   245ec:	e0bffe0b 	ldhu	r2,-8(fp)
   245f0:	e0ffff03 	ldbu	r3,-4(fp)
   245f4:	e1000217 	ldw	r4,8(fp)
   245f8:	d9000015 	stw	r4,0(sp)
   245fc:	e1000317 	ldw	r4,12(fp)
   24600:	d9000115 	stw	r4,4(sp)
   24604:	e1000417 	ldw	r4,16(fp)
   24608:	d9000215 	stw	r4,8(sp)
   2460c:	d8000315 	stw	zero,12(sp)
   24610:	d8c00415 	stw	r3,16(sp)
   24614:	e13ffb17 	ldw	r4,-20(fp)
   24618:	e17ffc17 	ldw	r5,-16(fp)
   2461c:	e1bffd17 	ldw	r6,-12(fp)
   24620:	100f883a 	mov	r7,r2
   24624:	002463c0 	call	2463c <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>
    length, read_fixed, generate_sop, generate_eop, 0, atlantic_channel);

}
   24628:	e037883a 	mov	sp,fp
   2462c:	dfc00117 	ldw	ra,4(sp)
   24630:	df000017 	ldw	fp,0(sp)
   24634:	dec00204 	addi	sp,sp,8
   24638:	f800283a 	ret

0002463c <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>:
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  int                   read_burst,
  alt_u8                atlantic_channel)
{
   2463c:	defff204 	addi	sp,sp,-56
   24640:	dfc00d15 	stw	ra,52(sp)
   24644:	df000c15 	stw	fp,48(sp)
   24648:	df000c04 	addi	fp,sp,48
   2464c:	e13ffb15 	stw	r4,-20(fp)
   24650:	e17ffc15 	stw	r5,-16(fp)
   24654:	e1bffd15 	stw	r6,-12(fp)
   24658:	3805883a 	mov	r2,r7
   2465c:	e0c00617 	ldw	r3,24(fp)
   24660:	e0bffe0d 	sth	r2,-8(fp)
   24664:	e0ffff05 	stb	r3,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
   24668:	e0fffe0b 	ldhu	r3,-8(fp)
   2466c:	e0bfff03 	ldbu	r2,-4(fp)
   24670:	d8c00015 	stw	r3,0(sp)
   24674:	e0c00417 	ldw	r3,16(fp)
   24678:	d8c00115 	stw	r3,4(sp)
   2467c:	e0c00217 	ldw	r3,8(fp)
   24680:	d8c00215 	stw	r3,8(sp)
   24684:	e0c00317 	ldw	r3,12(fp)
   24688:	d8c00315 	stw	r3,12(sp)
   2468c:	e0c00517 	ldw	r3,20(fp)
   24690:	d8c00415 	stw	r3,16(sp)
   24694:	d8000515 	stw	zero,20(sp)
   24698:	d8800615 	stw	r2,24(sp)
   2469c:	e13ffb17 	ldw	r4,-20(fp)
   246a0:	e17ffc17 	ldw	r5,-16(fp)
   246a4:	e1bffd17 	ldw	r6,-12(fp)
   246a8:	000f883a 	mov	r7,zero
   246ac:	00249dc0 	call	249dc <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    generate_sop,
    read_burst,
    0,                 // Write_burst : N/A in mem-to-stream mode
    atlantic_channel);
}
   246b0:	e037883a 	mov	sp,fp
   246b4:	dfc00117 	ldw	ra,4(sp)
   246b8:	df000017 	ldw	fp,0(sp)
   246bc:	dec00204 	addi	sp,sp,8
   246c0:	f800283a 	ret

000246c4 <alt_avalon_sgdma_register_callback>:
void alt_avalon_sgdma_register_callback(
  alt_sgdma_dev *dev,
  alt_avalon_sgdma_callback callback,
  alt_u32 chain_control,
  void *context)
{
   246c4:	defffb04 	addi	sp,sp,-20
   246c8:	df000415 	stw	fp,16(sp)
   246cc:	df000404 	addi	fp,sp,16
   246d0:	e13ffc15 	stw	r4,-16(fp)
   246d4:	e17ffd15 	stw	r5,-12(fp)
   246d8:	e1bffe15 	stw	r6,-8(fp)
   246dc:	e1ffff15 	stw	r7,-4(fp)
  dev->callback         = callback;
   246e0:	e0bffc17 	ldw	r2,-16(fp)
   246e4:	e0fffd17 	ldw	r3,-12(fp)
   246e8:	10c00915 	stw	r3,36(r2)
  dev->callback_context = context;
   246ec:	e0bffc17 	ldw	r2,-16(fp)
   246f0:	e0ffff17 	ldw	r3,-4(fp)
   246f4:	10c00a15 	stw	r3,40(r2)
  dev->chain_control    = chain_control;
   246f8:	e0bffc17 	ldw	r2,-16(fp)
   246fc:	e0fffe17 	ldw	r3,-8(fp)
   24700:	10c00b15 	stw	r3,44(r2)
}
   24704:	e037883a 	mov	sp,fp
   24708:	df000017 	ldw	fp,0(sp)
   2470c:	dec00104 	addi	sp,sp,4
   24710:	f800283a 	ret

00024714 <alt_avalon_sgdma_start>:
 *
 * Arguments:
 * - *dev: Pointer to SGDMA device (instance) struct.
 */
void alt_avalon_sgdma_start(alt_sgdma_dev *dev)
{
   24714:	defffd04 	addi	sp,sp,-12
   24718:	df000215 	stw	fp,8(sp)
   2471c:	df000204 	addi	fp,sp,8
   24720:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
   24724:	e0bfff17 	ldw	r2,-4(fp)
   24728:	10800317 	ldw	r2,12(r2)
   2472c:	10800404 	addi	r2,r2,16
   24730:	10800037 	ldwio	r2,0(r2)
   24734:	e0bffe15 	stw	r2,-8(fp)
  control |= ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
   24738:	e0bffe17 	ldw	r2,-8(fp)
   2473c:	10800814 	ori	r2,r2,32
   24740:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
   24744:	e0bfff17 	ldw	r2,-4(fp)
   24748:	10800317 	ldw	r2,12(r2)
   2474c:	10800404 	addi	r2,r2,16
   24750:	e0fffe17 	ldw	r3,-8(fp)
   24754:	10c00035 	stwio	r3,0(r2)
}
   24758:	e037883a 	mov	sp,fp
   2475c:	df000017 	ldw	fp,0(sp)
   24760:	dec00104 	addi	sp,sp,4
   24764:	f800283a 	ret

00024768 <alt_avalon_sgdma_stop>:
 *
 * Arguments:
 * - *dev: Pointer to SGDMA device (instance) struct
 */
void alt_avalon_sgdma_stop(alt_sgdma_dev *dev)
{
   24768:	defffd04 	addi	sp,sp,-12
   2476c:	df000215 	stw	fp,8(sp)
   24770:	df000204 	addi	fp,sp,8
   24774:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
   24778:	e0bfff17 	ldw	r2,-4(fp)
   2477c:	10800317 	ldw	r2,12(r2)
   24780:	10800404 	addi	r2,r2,16
   24784:	10800037 	ldwio	r2,0(r2)
   24788:	e0bffe15 	stw	r2,-8(fp)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
   2478c:	e0fffe17 	ldw	r3,-8(fp)
   24790:	00bff7c4 	movi	r2,-33
   24794:	1884703a 	and	r2,r3,r2
   24798:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
   2479c:	e0bfff17 	ldw	r2,-4(fp)
   247a0:	10800317 	ldw	r2,12(r2)
   247a4:	10800404 	addi	r2,r2,16
   247a8:	e0fffe17 	ldw	r3,-8(fp)
   247ac:	10c00035 	stwio	r3,0(r2)
}
   247b0:	e037883a 	mov	sp,fp
   247b4:	df000017 	ldw	fp,0(sp)
   247b8:	dec00104 	addi	sp,sp,4
   247bc:	f800283a 	ret

000247c0 <alt_avalon_sgdma_check_descriptor_status>:
 * - 0 if the descriptor is error-free, not "owned by hardware", or
 *   a previously requested transfer has appeared to have completed
 *   normally. Or, various error conditions defined in <errno.h>
 */
int alt_avalon_sgdma_check_descriptor_status(alt_sgdma_descriptor *desc)
{
   247c0:	defffe04 	addi	sp,sp,-8
   247c4:	df000115 	stw	fp,4(sp)
   247c8:	df000104 	addi	fp,sp,4
   247cc:	e13fff15 	stw	r4,-4(fp)
  /* Errors take precedence */
  if( IORD_8DIRECT(&desc->status, 0) &
   247d0:	e0bfff17 	ldw	r2,-4(fp)
   247d4:	10800784 	addi	r2,r2,30
   247d8:	10800023 	ldbuio	r2,0(r2)
   247dc:	10803fcc 	andi	r2,r2,255
   247e0:	10801fcc 	andi	r2,r2,127
   247e4:	10000226 	beq	r2,zero,247f0 <alt_avalon_sgdma_check_descriptor_status+0x30>
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_OVERFLOW_MSK |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) {
    return -EIO;
   247e8:	00bffec4 	movi	r2,-5
   247ec:	00000906 	br	24814 <alt_avalon_sgdma_check_descriptor_status+0x54>
  }

  if( IORD_8DIRECT(&desc->control, 0) &
   247f0:	e0bfff17 	ldw	r2,-4(fp)
   247f4:	108007c4 	addi	r2,r2,31
   247f8:	10800023 	ldbuio	r2,0(r2)
   247fc:	10803fcc 	andi	r2,r2,255
   24800:	1080200c 	andi	r2,r2,128
   24804:	10000226 	beq	r2,zero,24810 <alt_avalon_sgdma_check_descriptor_status+0x50>
      ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK) {
    return -EINPROGRESS;
   24808:	00bfe244 	movi	r2,-119
   2480c:	00000106 	br	24814 <alt_avalon_sgdma_check_descriptor_status+0x54>
  }

    return 0;
   24810:	0005883a 	mov	r2,zero
}
   24814:	e037883a 	mov	sp,fp
   24818:	df000017 	ldw	fp,0(sp)
   2481c:	dec00104 	addi	sp,sp,4
   24820:	f800283a 	ret

00024824 <alt_avalon_sgdma_open>:
 * Returns:
 * - Pointer to SGDMA device instance struct, or null if the device
 *   could not be opened.
 */
alt_sgdma_dev* alt_avalon_sgdma_open (const char* name)
{
   24824:	defffc04 	addi	sp,sp,-16
   24828:	dfc00315 	stw	ra,12(sp)
   2482c:	df000215 	stw	fp,8(sp)
   24830:	df000204 	addi	fp,sp,8
   24834:	e13fff15 	stw	r4,-4(fp)
  alt_sgdma_dev* dev;

  dev = (alt_sgdma_dev*) alt_find_dev (name, &alt_sgdma_list);
   24838:	e13fff17 	ldw	r4,-4(fp)
   2483c:	d1601904 	addi	r5,gp,-32668
   24840:	002b0e80 	call	2b0e8 <alt_find_dev>
   24844:	e0bffe15 	stw	r2,-8(fp)

  if (NULL == dev) {
   24848:	e0bffe17 	ldw	r2,-8(fp)
   2484c:	1000031e 	bne	r2,zero,2485c <alt_avalon_sgdma_open+0x38>
    ALT_ERRNO = ENODEV;
   24850:	002417c0 	call	2417c <alt_get_errno>
   24854:	00c004c4 	movi	r3,19
   24858:	10c00015 	stw	r3,0(r2)
  }

  return dev;
   2485c:	e0bffe17 	ldw	r2,-8(fp)
}
   24860:	e037883a 	mov	sp,fp
   24864:	dfc00117 	ldw	ra,4(sp)
   24868:	df000017 	ldw	fp,0(sp)
   2486c:	dec00204 	addi	sp,sp,8
   24870:	f800283a 	ret

00024874 <alt_avalon_sgdma_construct_descriptor>:
  alt_u16               length_or_eop,
  int                   generate_eop,
  int                   read_fixed,
  int                   write_fixed_or_sop,
  alt_u8                atlantic_channel)
{
   24874:	defff104 	addi	sp,sp,-60
   24878:	dfc00e15 	stw	ra,56(sp)
   2487c:	df000d15 	stw	fp,52(sp)
   24880:	df000d04 	addi	fp,sp,52
   24884:	e13ffa15 	stw	r4,-24(fp)
   24888:	e17ffb15 	stw	r5,-20(fp)
   2488c:	e1bffc15 	stw	r6,-16(fp)
   24890:	e1fffd15 	stw	r7,-12(fp)
   24894:	e0c00217 	ldw	r3,8(fp)
   24898:	e0800617 	ldw	r2,24(fp)
   2489c:	e0fffe0d 	sth	r3,-8(fp)
   248a0:	e0bfff05 	stb	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(desc, next, read_addr, 
   248a4:	e0fffe0b 	ldhu	r3,-8(fp)
   248a8:	e0bfff03 	ldbu	r2,-4(fp)
   248ac:	d8c00015 	stw	r3,0(sp)
   248b0:	e0c00317 	ldw	r3,12(fp)
   248b4:	d8c00115 	stw	r3,4(sp)
   248b8:	e0c00417 	ldw	r3,16(fp)
   248bc:	d8c00215 	stw	r3,8(sp)
   248c0:	e0c00517 	ldw	r3,20(fp)
   248c4:	d8c00315 	stw	r3,12(sp)
   248c8:	d8000415 	stw	zero,16(sp)
   248cc:	d8000515 	stw	zero,20(sp)
   248d0:	d8800615 	stw	r2,24(sp)
   248d4:	e13ffa17 	ldw	r4,-24(fp)
   248d8:	e17ffb17 	ldw	r5,-20(fp)
   248dc:	e1bffc17 	ldw	r6,-16(fp)
   248e0:	e1fffd17 	ldw	r7,-12(fp)
   248e4:	00249dc0 	call	249dc <alt_avalon_sgdma_construct_descriptor_burst>
    write_addr, length_or_eop, generate_eop, read_fixed, write_fixed_or_sop, 
    0, 0, atlantic_channel);
}
   248e8:	e037883a 	mov	sp,fp
   248ec:	dfc00117 	ldw	ra,4(sp)
   248f0:	df000017 	ldw	fp,0(sp)
   248f4:	dec00204 	addi	sp,sp,8
   248f8:	f800283a 	ret

000248fc <alt_avalon_sgdma_enable_desc_poll>:
 *
 * Returns:
 * - None
 */
void alt_avalon_sgdma_enable_desc_poll(alt_sgdma_dev *dev, alt_u32 frequency)
{
   248fc:	defffc04 	addi	sp,sp,-16
   24900:	df000315 	stw	fp,12(sp)
   24904:	df000304 	addi	fp,sp,12
   24908:	e13ffe15 	stw	r4,-8(fp)
   2490c:	e17fff15 	stw	r5,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
   24910:	e0bffe17 	ldw	r2,-8(fp)
   24914:	10800317 	ldw	r2,12(r2)
   24918:	10800404 	addi	r2,r2,16
   2491c:	10800037 	ldwio	r2,0(r2)
   24920:	e0bffd15 	stw	r2,-12(fp)
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
   24924:	e0fffd17 	ldw	r3,-12(fp)
   24928:	00a00434 	movhi	r2,32784
   2492c:	10bfffc4 	addi	r2,r2,-1
   24930:	1884703a 	and	r2,r3,r2
   24934:	e0bffd15 	stw	r2,-12(fp)
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
   24938:	e0bfff17 	ldw	r2,-4(fp)
   2493c:	1004953a 	slli	r2,r2,20
   24940:	10dffc2c 	andhi	r3,r2,32752

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
   24944:	e0bffd17 	ldw	r2,-12(fp)
   24948:	1884b03a 	or	r2,r3,r2
   2494c:	10800134 	orhi	r2,r2,4
   24950:	e0bffd15 	stw	r2,-12(fp)
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
            ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
   24954:	e0bffe17 	ldw	r2,-8(fp)
   24958:	10800317 	ldw	r2,12(r2)
   2495c:	10800404 	addi	r2,r2,16
   24960:	e0fffd17 	ldw	r3,-12(fp)
   24964:	10c00035 	stwio	r3,0(r2)
  
  return;
   24968:	0001883a 	nop
}
   2496c:	e037883a 	mov	sp,fp
   24970:	df000017 	ldw	fp,0(sp)
   24974:	dec00104 	addi	sp,sp,4
   24978:	f800283a 	ret

0002497c <alt_avalon_sgdma_disable_desc_poll>:
 *
 * Returns:
 * - None
 */
void alt_avalon_sgdma_disable_desc_poll(alt_sgdma_dev *dev)
{
   2497c:	defffd04 	addi	sp,sp,-12
   24980:	df000215 	stw	fp,8(sp)
   24984:	df000204 	addi	fp,sp,8
   24988:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
   2498c:	e0bfff17 	ldw	r2,-4(fp)
   24990:	10800317 	ldw	r2,12(r2)
   24994:	10800404 	addi	r2,r2,16
   24998:	10800037 	ldwio	r2,0(r2)
   2499c:	e0bffe15 	stw	r2,-8(fp)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK;
   249a0:	e0fffe17 	ldw	r3,-8(fp)
   249a4:	00bfff34 	movhi	r2,65532
   249a8:	10bfffc4 	addi	r2,r2,-1
   249ac:	1884703a 	and	r2,r3,r2
   249b0:	e0bffe15 	stw	r2,-8(fp)

  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
   249b4:	e0bfff17 	ldw	r2,-4(fp)
   249b8:	10800317 	ldw	r2,12(r2)
   249bc:	10800404 	addi	r2,r2,16
   249c0:	e0fffe17 	ldw	r3,-8(fp)
   249c4:	10c00035 	stwio	r3,0(r2)
  
  return;
   249c8:	0001883a 	nop
}
   249cc:	e037883a 	mov	sp,fp
   249d0:	df000017 	ldw	fp,0(sp)
   249d4:	dec00104 	addi	sp,sp,4
   249d8:	f800283a 	ret

000249dc <alt_avalon_sgdma_construct_descriptor_burst>:
  int                   read_fixed,
  int                   write_fixed_or_sop,
  int                   read_burst,
  int                   write_burst,
  alt_u8                atlantic_channel)
{
   249dc:	defff804 	addi	sp,sp,-32
   249e0:	dfc00715 	stw	ra,28(sp)
   249e4:	df000615 	stw	fp,24(sp)
   249e8:	df000604 	addi	fp,sp,24
   249ec:	e13ffa15 	stw	r4,-24(fp)
   249f0:	e17ffb15 	stw	r5,-20(fp)
   249f4:	e1bffc15 	stw	r6,-16(fp)
   249f8:	e1fffd15 	stw	r7,-12(fp)
   249fc:	e0c00217 	ldw	r3,8(fp)
   24a00:	e0800817 	ldw	r2,32(fp)
   24a04:	e0fffe0d 	sth	r3,-8(fp)
   24a08:	e0bfff05 	stb	r2,-4(fp)
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
   24a0c:	e0bffb17 	ldw	r2,-20(fp)
   24a10:	108007c4 	addi	r2,r2,31
   24a14:	e0fffb17 	ldw	r3,-20(fp)
   24a18:	18c007c3 	ldbu	r3,31(r3)
   24a1c:	19003fcc 	andi	r4,r3,255
   24a20:	00ffdfc4 	movi	r3,-129
   24a24:	20c6703a 	and	r3,r4,r3
   24a28:	10c00025 	stbio	r3,0(r2)
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
   24a2c:	e0bffa17 	ldw	r2,-24(fp)
   24a30:	e0fffc17 	ldw	r3,-16(fp)
   24a34:	18c03fcc 	andi	r3,r3,255
   24a38:	11000003 	ldbu	r4,0(r2)
   24a3c:	2008703a 	and	r4,r4,zero
   24a40:	20c6b03a 	or	r3,r4,r3
   24a44:	10c00005 	stb	r3,0(r2)
   24a48:	e0fffc17 	ldw	r3,-16(fp)
   24a4c:	1806d23a 	srli	r3,r3,8
   24a50:	18c03fcc 	andi	r3,r3,255
   24a54:	11000043 	ldbu	r4,1(r2)
   24a58:	2008703a 	and	r4,r4,zero
   24a5c:	20c6b03a 	or	r3,r4,r3
   24a60:	10c00045 	stb	r3,1(r2)
   24a64:	e0fffc17 	ldw	r3,-16(fp)
   24a68:	1806d43a 	srli	r3,r3,16
   24a6c:	18c03fcc 	andi	r3,r3,255
   24a70:	11000083 	ldbu	r4,2(r2)
   24a74:	2008703a 	and	r4,r4,zero
   24a78:	20c6b03a 	or	r3,r4,r3
   24a7c:	10c00085 	stb	r3,2(r2)
   24a80:	e0fffc17 	ldw	r3,-16(fp)
   24a84:	1806d63a 	srli	r3,r3,24
   24a88:	110000c3 	ldbu	r4,3(r2)
   24a8c:	2008703a 	and	r4,r4,zero
   24a90:	20c6b03a 	or	r3,r4,r3
   24a94:	10c000c5 	stb	r3,3(r2)
  desc->write_addr               = write_addr;
   24a98:	e0bffa17 	ldw	r2,-24(fp)
   24a9c:	e0fffd17 	ldw	r3,-12(fp)
   24aa0:	18c03fcc 	andi	r3,r3,255
   24aa4:	11000203 	ldbu	r4,8(r2)
   24aa8:	2008703a 	and	r4,r4,zero
   24aac:	20c6b03a 	or	r3,r4,r3
   24ab0:	10c00205 	stb	r3,8(r2)
   24ab4:	e0fffd17 	ldw	r3,-12(fp)
   24ab8:	1806d23a 	srli	r3,r3,8
   24abc:	18c03fcc 	andi	r3,r3,255
   24ac0:	11000243 	ldbu	r4,9(r2)
   24ac4:	2008703a 	and	r4,r4,zero
   24ac8:	20c6b03a 	or	r3,r4,r3
   24acc:	10c00245 	stb	r3,9(r2)
   24ad0:	e0fffd17 	ldw	r3,-12(fp)
   24ad4:	1806d43a 	srli	r3,r3,16
   24ad8:	18c03fcc 	andi	r3,r3,255
   24adc:	11000283 	ldbu	r4,10(r2)
   24ae0:	2008703a 	and	r4,r4,zero
   24ae4:	20c6b03a 	or	r3,r4,r3
   24ae8:	10c00285 	stb	r3,10(r2)
   24aec:	e0fffd17 	ldw	r3,-12(fp)
   24af0:	1806d63a 	srli	r3,r3,24
   24af4:	110002c3 	ldbu	r4,11(r2)
   24af8:	2008703a 	and	r4,r4,zero
   24afc:	20c6b03a 	or	r3,r4,r3
   24b00:	10c002c5 	stb	r3,11(r2)
  desc->next                     = (alt_u32 *) next;
   24b04:	e0bffa17 	ldw	r2,-24(fp)
   24b08:	e0fffb17 	ldw	r3,-20(fp)
   24b0c:	18c03fcc 	andi	r3,r3,255
   24b10:	11000403 	ldbu	r4,16(r2)
   24b14:	2008703a 	and	r4,r4,zero
   24b18:	20c6b03a 	or	r3,r4,r3
   24b1c:	10c00405 	stb	r3,16(r2)
   24b20:	e0fffb17 	ldw	r3,-20(fp)
   24b24:	1806d23a 	srli	r3,r3,8
   24b28:	18c03fcc 	andi	r3,r3,255
   24b2c:	11000443 	ldbu	r4,17(r2)
   24b30:	2008703a 	and	r4,r4,zero
   24b34:	20c6b03a 	or	r3,r4,r3
   24b38:	10c00445 	stb	r3,17(r2)
   24b3c:	e0fffb17 	ldw	r3,-20(fp)
   24b40:	1806d43a 	srli	r3,r3,16
   24b44:	18c03fcc 	andi	r3,r3,255
   24b48:	11000483 	ldbu	r4,18(r2)
   24b4c:	2008703a 	and	r4,r4,zero
   24b50:	20c6b03a 	or	r3,r4,r3
   24b54:	10c00485 	stb	r3,18(r2)
   24b58:	e0fffb17 	ldw	r3,-20(fp)
   24b5c:	1806d63a 	srli	r3,r3,24
   24b60:	110004c3 	ldbu	r4,19(r2)
   24b64:	2008703a 	and	r4,r4,zero
   24b68:	20c6b03a 	or	r3,r4,r3
   24b6c:	10c004c5 	stb	r3,19(r2)
  desc->read_addr_pad            = 0x0;
   24b70:	e0bffa17 	ldw	r2,-24(fp)
   24b74:	10c00103 	ldbu	r3,4(r2)
   24b78:	1806703a 	and	r3,r3,zero
   24b7c:	10c00105 	stb	r3,4(r2)
   24b80:	10c00143 	ldbu	r3,5(r2)
   24b84:	1806703a 	and	r3,r3,zero
   24b88:	10c00145 	stb	r3,5(r2)
   24b8c:	10c00183 	ldbu	r3,6(r2)
   24b90:	1806703a 	and	r3,r3,zero
   24b94:	10c00185 	stb	r3,6(r2)
   24b98:	10c001c3 	ldbu	r3,7(r2)
   24b9c:	1806703a 	and	r3,r3,zero
   24ba0:	10c001c5 	stb	r3,7(r2)
  desc->write_addr_pad           = 0x0;
   24ba4:	e0bffa17 	ldw	r2,-24(fp)
   24ba8:	10c00303 	ldbu	r3,12(r2)
   24bac:	1806703a 	and	r3,r3,zero
   24bb0:	10c00305 	stb	r3,12(r2)
   24bb4:	10c00343 	ldbu	r3,13(r2)
   24bb8:	1806703a 	and	r3,r3,zero
   24bbc:	10c00345 	stb	r3,13(r2)
   24bc0:	10c00383 	ldbu	r3,14(r2)
   24bc4:	1806703a 	and	r3,r3,zero
   24bc8:	10c00385 	stb	r3,14(r2)
   24bcc:	10c003c3 	ldbu	r3,15(r2)
   24bd0:	1806703a 	and	r3,r3,zero
   24bd4:	10c003c5 	stb	r3,15(r2)
  desc->next_pad                 = 0x0;
   24bd8:	e0bffa17 	ldw	r2,-24(fp)
   24bdc:	10c00503 	ldbu	r3,20(r2)
   24be0:	1806703a 	and	r3,r3,zero
   24be4:	10c00505 	stb	r3,20(r2)
   24be8:	10c00543 	ldbu	r3,21(r2)
   24bec:	1806703a 	and	r3,r3,zero
   24bf0:	10c00545 	stb	r3,21(r2)
   24bf4:	10c00583 	ldbu	r3,22(r2)
   24bf8:	1806703a 	and	r3,r3,zero
   24bfc:	10c00585 	stb	r3,22(r2)
   24c00:	10c005c3 	ldbu	r3,23(r2)
   24c04:	1806703a 	and	r3,r3,zero
   24c08:	10c005c5 	stb	r3,23(r2)
  desc->bytes_to_transfer        = length_or_eop;
   24c0c:	e0bffa17 	ldw	r2,-24(fp)
   24c10:	e0fffe0b 	ldhu	r3,-8(fp)
   24c14:	18c03fcc 	andi	r3,r3,255
   24c18:	11000603 	ldbu	r4,24(r2)
   24c1c:	2008703a 	and	r4,r4,zero
   24c20:	20c6b03a 	or	r3,r4,r3
   24c24:	10c00605 	stb	r3,24(r2)
   24c28:	e0fffe0b 	ldhu	r3,-8(fp)
   24c2c:	1806d23a 	srli	r3,r3,8
   24c30:	18ffffcc 	andi	r3,r3,65535
   24c34:	11000643 	ldbu	r4,25(r2)
   24c38:	2008703a 	and	r4,r4,zero
   24c3c:	20c6b03a 	or	r3,r4,r3
   24c40:	10c00645 	stb	r3,25(r2)
  desc->actual_bytes_transferred = 0;
   24c44:	e0bffa17 	ldw	r2,-24(fp)
   24c48:	10c00703 	ldbu	r3,28(r2)
   24c4c:	1806703a 	and	r3,r3,zero
   24c50:	10c00705 	stb	r3,28(r2)
   24c54:	10c00743 	ldbu	r3,29(r2)
   24c58:	1806703a 	and	r3,r3,zero
   24c5c:	10c00745 	stb	r3,29(r2)
  desc->status                   = 0x0;
   24c60:	e0bffa17 	ldw	r2,-24(fp)
   24c64:	10000785 	stb	zero,30(r2)

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
   24c68:	e0800617 	ldw	r2,24(fp)
   24c6c:	1007883a 	mov	r3,r2
   24c70:	e0bffa17 	ldw	r2,-24(fp)
   24c74:	10c00685 	stb	r3,26(r2)
  desc->write_burst              = write_burst;
   24c78:	e0800717 	ldw	r2,28(fp)
   24c7c:	1007883a 	mov	r3,r2
   24c80:	e0bffa17 	ldw	r2,-24(fp)
   24c84:	10c006c5 	stb	r3,27(r2)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
   24c88:	e0800317 	ldw	r2,12(fp)
   24c8c:	10000226 	beq	r2,zero,24c98 <alt_avalon_sgdma_construct_descriptor_burst+0x2bc>
   24c90:	00ffe044 	movi	r3,-127
   24c94:	00000106 	br	24c9c <alt_avalon_sgdma_construct_descriptor_burst+0x2c0>
   24c98:	00ffe004 	movi	r3,-128
   24c9c:	e0800417 	ldw	r2,16(fp)
   24ca0:	10000226 	beq	r2,zero,24cac <alt_avalon_sgdma_construct_descriptor_burst+0x2d0>
   24ca4:	00800084 	movi	r2,2
   24ca8:	00000106 	br	24cb0 <alt_avalon_sgdma_construct_descriptor_burst+0x2d4>
   24cac:	0005883a 	mov	r2,zero
   24cb0:	1884b03a 	or	r2,r3,r2
   24cb4:	1007883a 	mov	r3,r2
   24cb8:	e0800517 	ldw	r2,20(fp)
   24cbc:	10000226 	beq	r2,zero,24cc8 <alt_avalon_sgdma_construct_descriptor_burst+0x2ec>
   24cc0:	00800104 	movi	r2,4
   24cc4:	00000106 	br	24ccc <alt_avalon_sgdma_construct_descriptor_burst+0x2f0>
   24cc8:	0005883a 	mov	r2,zero
   24ccc:	1884b03a 	or	r2,r3,r2
   24cd0:	1007883a 	mov	r3,r2
   24cd4:	e0bfff03 	ldbu	r2,-4(fp)
   24cd8:	10000426 	beq	r2,zero,24cec <alt_avalon_sgdma_construct_descriptor_burst+0x310>
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_GENERATE_EOP_MSK : 0x0)        |
    (read_fixed ?
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_READ_FIXED_ADDRESS_MSK : 0x0)  |
    (write_fixed_or_sop ?
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_WRITE_FIXED_ADDRESS_MSK : 0x0) |
    (atlantic_channel ? ( (atlantic_channel & 0x0F) << 3) : 0)
   24cdc:	e0bfff03 	ldbu	r2,-4(fp)
   24ce0:	108003cc 	andi	r2,r2,15
   24ce4:	100490fa 	slli	r2,r2,3
   24ce8:	00000106 	br	24cf0 <alt_avalon_sgdma_construct_descriptor_burst+0x314>
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
   24cec:	0005883a 	mov	r2,zero
   24cf0:	1884b03a 	or	r2,r3,r2
   24cf4:	1007883a 	mov	r3,r2
   24cf8:	e0bffa17 	ldw	r2,-24(fp)
   24cfc:	10c007c5 	stb	r3,31(r2)
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to
   */
  alt_remap_uncached(desc, sizeof(alt_sgdma_descriptor));
   24d00:	e13ffa17 	ldw	r4,-24(fp)
   24d04:	01400804 	movi	r5,32
   24d08:	00204b40 	call	204b4 <alt_remap_uncached>
}
   24d0c:	e037883a 	mov	sp,fp
   24d10:	dfc00117 	ldw	ra,4(sp)
   24d14:	df000017 	ldw	fp,0(sp)
   24d18:	dec00204 	addi	sp,sp,8
   24d1c:	f800283a 	ret

00024d20 <alt_avalon_sgdma_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_sgdma_irq(void *context)
#else
static void alt_avalon_sgdma_irq(void *context, alt_u32 id)
#endif
{
   24d20:	defff804 	addi	sp,sp,-32
   24d24:	dfc00715 	stw	ra,28(sp)
   24d28:	df000615 	stw	fp,24(sp)
   24d2c:	df000604 	addi	fp,sp,24
   24d30:	e13fff15 	stw	r4,-4(fp)
  alt_sgdma_dev *dev = (alt_sgdma_dev *) context;
   24d34:	e0bfff17 	ldw	r2,-4(fp)
   24d38:	e0bffa15 	stw	r2,-24(fp)
   * Note: This is explicitly done before calling user interrupt-handling
   * code rather than after; if user ISR code initiates another SGDMA
   * transfer which completes quickly, reading the control register after
   * the callback routine may result in a lost interrupt.
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
   24d3c:	e0bffa17 	ldw	r2,-24(fp)
   24d40:	10800317 	ldw	r2,12(r2)
   24d44:	10800404 	addi	r2,r2,16
   24d48:	e0fffa17 	ldw	r3,-24(fp)
   24d4c:	18c00317 	ldw	r3,12(r3)
   24d50:	18c00404 	addi	r3,r3,16
   24d54:	18c00037 	ldwio	r3,0(r3)
   24d58:	18e00034 	orhi	r3,r3,32768
   24d5c:	10c00035 	stwio	r3,0(r2)
    IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) | 0x80000000);
  
  /* Dummy read to ensure IRQ is negated before the ISR returns */
  IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
   24d60:	e0bffa17 	ldw	r2,-24(fp)
   24d64:	10800317 	ldw	r2,12(r2)
   24d68:	10800404 	addi	r2,r2,16
   24d6c:	10800037 	ldwio	r2,0(r2)
   * Other interrupts are explicitly disabled if callbacks
   * are registered because there is no guarantee that they are 
   * preemption-safe. This allows the driver to support 
   * interrupt preemption.
   */
  if(dev->callback) {
   24d70:	e0bffa17 	ldw	r2,-24(fp)
   24d74:	10800917 	ldw	r2,36(r2)
   24d78:	10001d26 	beq	r2,zero,24df0 <alt_avalon_sgdma_irq+0xd0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   24d7c:	0005303a 	rdctl	r2,status
   24d80:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   24d84:	e0fffc17 	ldw	r3,-16(fp)
   24d88:	00bfff84 	movi	r2,-2
   24d8c:	1884703a 	and	r2,r3,r2
   24d90:	1001703a 	wrctl	status,r2
  
  return context;
   24d94:	e0bffc17 	ldw	r2,-16(fp)
    cpu_sr = alt_irq_disable_all();
   24d98:	e0bffb15 	stw	r2,-20(fp)
    (dev->callback)(dev->callback_context);
   24d9c:	e0bffa17 	ldw	r2,-24(fp)
   24da0:	10c00917 	ldw	r3,36(r2)
   24da4:	e0bffa17 	ldw	r2,-24(fp)
   24da8:	10800a17 	ldw	r2,40(r2)
   24dac:	1009883a 	mov	r4,r2
   24db0:	183ee83a 	callr	r3
   24db4:	e0bffb17 	ldw	r2,-20(fp)
   24db8:	e0bffd15 	stw	r2,-12(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   24dbc:	0005303a 	rdctl	r2,status
   24dc0:	e0bffe15 	stw	r2,-8(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   24dc4:	e0fffe17 	ldw	r3,-8(fp)
   24dc8:	00bfff84 	movi	r2,-2
   24dcc:	1884703a 	and	r2,r3,r2
   24dd0:	e0bffe15 	stw	r2,-8(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   24dd4:	e0bffd17 	ldw	r2,-12(fp)
   24dd8:	1080004c 	andi	r2,r2,1
   24ddc:	e0fffe17 	ldw	r3,-8(fp)
   24de0:	1884b03a 	or	r2,r3,r2
   24de4:	e0bffe15 	stw	r2,-8(fp)
  
  NIOS2_WRITE_STATUS (status);
   24de8:	e0bffe17 	ldw	r2,-8(fp)
   24dec:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(cpu_sr);
  }
}
   24df0:	e037883a 	mov	sp,fp
   24df4:	dfc00117 	ldw	ra,4(sp)
   24df8:	df000017 	ldw	fp,0(sp)
   24dfc:	dec00204 	addi	sp,sp,8
   24e00:	f800283a 	ret

00024e04 <alt_avalon_sgdma_init>:
 * This routine disables interrupts, future descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_avalon_sgdma_init (alt_sgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
   24e04:	defffa04 	addi	sp,sp,-24
   24e08:	dfc00515 	stw	ra,20(sp)
   24e0c:	df000415 	stw	fp,16(sp)
   24e10:	df000404 	addi	fp,sp,16
   24e14:	e13ffd15 	stw	r4,-12(fp)
   24e18:	e17ffe15 	stw	r5,-8(fp)
   24e1c:	e1bfff15 	stw	r6,-4(fp)

  /* 
   * Halt any current transactions (reset the device)
   * SW reset is written twice per SGDMA documentation 
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
   24e20:	e0bffd17 	ldw	r2,-12(fp)
   24e24:	10800317 	ldw	r2,12(r2)
   24e28:	10800404 	addi	r2,r2,16
   24e2c:	00c00074 	movhi	r3,1
   24e30:	10c00035 	stwio	r3,0(r2)
    ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
   24e34:	e0bffd17 	ldw	r2,-12(fp)
   24e38:	10800317 	ldw	r2,12(r2)
   24e3c:	10800404 	addi	r2,r2,16
   24e40:	00c00074 	movhi	r3,1
   24e44:	10c00035 	stwio	r3,0(r2)

  /*
   * Disable interrupts, halt future descriptor processing,
   * and clear status register content
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 0x0);
   24e48:	e0bffd17 	ldw	r2,-12(fp)
   24e4c:	10800317 	ldw	r2,12(r2)
   24e50:	10800404 	addi	r2,r2,16
   24e54:	0007883a 	mov	r3,zero
   24e58:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
   24e5c:	e0bffd17 	ldw	r2,-12(fp)
   24e60:	10800317 	ldw	r2,12(r2)
   24e64:	00c03fc4 	movi	r3,255
   24e68:	10c00035 	stwio	r3,0(r2)

  /* Register this instance of the SGDMA controller with HAL */
  alt_dev_llist_insert((alt_dev_llist*) dev, &alt_sgdma_list);
   24e6c:	e13ffd17 	ldw	r4,-12(fp)
   24e70:	d1601904 	addi	r5,gp,-32668
   24e74:	002af900 	call	2af90 <alt_dev_llist_insert>

  /* Install IRQ handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(ic_id, irq, alt_avalon_sgdma_irq, dev, 0x0);
   24e78:	d8000015 	stw	zero,0(sp)
   24e7c:	e13ffe17 	ldw	r4,-8(fp)
   24e80:	e17fff17 	ldw	r5,-4(fp)
   24e84:	018000b4 	movhi	r6,2
   24e88:	31934804 	addi	r6,r6,19744
   24e8c:	e1fffd17 	ldw	r7,-12(fp)
   24e90:	002ac800 	call	2ac80 <alt_ic_isr_register>
#else
  alt_irq_register(irq, dev, alt_avalon_sgdma_irq);
#endif  
}
   24e94:	e037883a 	mov	sp,fp
   24e98:	dfc00117 	ldw	ra,4(sp)
   24e9c:	df000017 	ldw	fp,0(sp)
   24ea0:	dec00204 	addi	sp,sp,8
   24ea4:	f800283a 	ret

00024ea8 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
   24ea8:	defff904 	addi	sp,sp,-28
   24eac:	dfc00615 	stw	ra,24(sp)
   24eb0:	df000515 	stw	fp,20(sp)
   24eb4:	df000504 	addi	fp,sp,20
   24eb8:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
   24ebc:	0007883a 	mov	r3,zero
   24ec0:	e0bfff17 	ldw	r2,-4(fp)
   24ec4:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
   24ec8:	e0bfff17 	ldw	r2,-4(fp)
   24ecc:	10800104 	addi	r2,r2,4
   24ed0:	10800037 	ldwio	r2,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   24ed4:	0005303a 	rdctl	r2,status
   24ed8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   24edc:	e0fffc17 	ldw	r3,-16(fp)
   24ee0:	00bfff84 	movi	r2,-2
   24ee4:	1884703a 	and	r2,r3,r2
   24ee8:	1001703a 	wrctl	status,r2
  
  return context;
   24eec:	e0bffc17 	ldw	r2,-16(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
   24ef0:	e0bffb15 	stw	r2,-20(fp)
  alt_tick ();
   24ef4:	00206c00 	call	206c0 <alt_tick>
   24ef8:	e0bffb17 	ldw	r2,-20(fp)
   24efc:	e0bffd15 	stw	r2,-12(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   24f00:	0005303a 	rdctl	r2,status
   24f04:	e0bffe15 	stw	r2,-8(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   24f08:	e0fffe17 	ldw	r3,-8(fp)
   24f0c:	00bfff84 	movi	r2,-2
   24f10:	1884703a 	and	r2,r3,r2
   24f14:	e0bffe15 	stw	r2,-8(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   24f18:	e0bffd17 	ldw	r2,-12(fp)
   24f1c:	1080004c 	andi	r2,r2,1
   24f20:	e0fffe17 	ldw	r3,-8(fp)
   24f24:	1884b03a 	or	r2,r3,r2
   24f28:	e0bffe15 	stw	r2,-8(fp)
  
  NIOS2_WRITE_STATUS (status);
   24f2c:	e0bffe17 	ldw	r2,-8(fp)
   24f30:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
   24f34:	e037883a 	mov	sp,fp
   24f38:	dfc00117 	ldw	ra,4(sp)
   24f3c:	df000017 	ldw	fp,0(sp)
   24f40:	dec00204 	addi	sp,sp,8
   24f44:	f800283a 	ret

00024f48 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
   24f48:	defff804 	addi	sp,sp,-32
   24f4c:	dfc00715 	stw	ra,28(sp)
   24f50:	df000615 	stw	fp,24(sp)
   24f54:	df000604 	addi	fp,sp,24
   24f58:	e13ffc15 	stw	r4,-16(fp)
   24f5c:	e17ffd15 	stw	r5,-12(fp)
   24f60:	e1bffe15 	stw	r6,-8(fp)
   24f64:	e1ffff15 	stw	r7,-4(fp)
   24f68:	e0bfff17 	ldw	r2,-4(fp)
   24f6c:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
   24f70:	008000f4 	movhi	r2,3
   24f74:	10961504 	addi	r2,r2,22612
   24f78:	10800017 	ldw	r2,0(r2)
   24f7c:	1000041e 	bne	r2,zero,24f90 <alt_avalon_timer_sc_init+0x48>
  {
    _alt_tick_rate = nticks;
   24f80:	008000f4 	movhi	r2,3
   24f84:	10961504 	addi	r2,r2,22612
   24f88:	e0fffb17 	ldw	r3,-20(fp)
   24f8c:	10c00015 	stw	r3,0(r2)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
   24f90:	e0bffc17 	ldw	r2,-16(fp)
   24f94:	10800104 	addi	r2,r2,4
   24f98:	00c001c4 	movi	r3,7
   24f9c:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
   24fa0:	d8000015 	stw	zero,0(sp)
   24fa4:	e13ffd17 	ldw	r4,-12(fp)
   24fa8:	e17ffe17 	ldw	r5,-8(fp)
   24fac:	018000b4 	movhi	r6,2
   24fb0:	3193aa04 	addi	r6,r6,20136
   24fb4:	e1fffc17 	ldw	r7,-16(fp)
   24fb8:	002ac800 	call	2ac80 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
   24fbc:	e037883a 	mov	sp,fp
   24fc0:	dfc00117 	ldw	ra,4(sp)
   24fc4:	df000017 	ldw	fp,0(sp)
   24fc8:	dec00204 	addi	sp,sp,8
   24fcc:	f800283a 	ret

00024fd0 <no_printf>:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

void no_printf (char *fmt, ...) {}
   24fd0:	defffb04 	addi	sp,sp,-20
   24fd4:	df000115 	stw	fp,4(sp)
   24fd8:	df000104 	addi	fp,sp,4
   24fdc:	e1400115 	stw	r5,4(fp)
   24fe0:	e1800215 	stw	r6,8(fp)
   24fe4:	e1c00315 	stw	r7,12(fp)
   24fe8:	e13fff15 	stw	r4,-4(fp)
   24fec:	e037883a 	mov	sp,fp
   24ff0:	df000017 	ldw	fp,0(sp)
   24ff4:	dec00404 	addi	sp,sp,16
   24ff8:	f800283a 	ret

00024ffc <tse_mac_initTransInfo2>:

alt_32 tse_mac_initTransInfo2( tse_mac_trans_info *mi,
                                        alt_u32 mac_base,
                                        alt_32 tx_sgdma,
                                        alt_32 rx_sgdma,
                                        alt_32 cfgflags) {
   24ffc:	defffb04 	addi	sp,sp,-20
   25000:	df000415 	stw	fp,16(sp)
   25004:	df000404 	addi	fp,sp,16
   25008:	e13ffc15 	stw	r4,-16(fp)
   2500c:	e17ffd15 	stw	r5,-12(fp)
   25010:	e1bffe15 	stw	r6,-8(fp)
   25014:	e1ffff15 	stw	r7,-4(fp)
                                              
        mi->base     = (np_tse_mac*)mac_base;
   25018:	e0fffd17 	ldw	r3,-12(fp)
   2501c:	e0bffc17 	ldw	r2,-16(fp)
   25020:	10c00015 	stw	r3,0(r2)
        mi->tx_sgdma = (alt_sgdma_dev *)tx_sgdma;
   25024:	e0fffe17 	ldw	r3,-8(fp)
   25028:	e0bffc17 	ldw	r2,-16(fp)
   2502c:	10c00115 	stw	r3,4(r2)
        mi->rx_sgdma = (alt_sgdma_dev *)rx_sgdma;
   25030:	e0ffff17 	ldw	r3,-4(fp)
   25034:	e0bffc17 	ldw	r2,-16(fp)
   25038:	10c00215 	stw	r3,8(r2)
        mi->cfgflags = cfgflags;     
   2503c:	e0c00117 	ldw	r3,4(fp)
   25040:	e0bffc17 	ldw	r2,-16(fp)
   25044:	10c00415 	stw	r3,16(r2)
        return SUCCESS;
   25048:	0005883a 	mov	r2,zero
}
   2504c:	e037883a 	mov	sp,fp
   25050:	df000017 	ldw	fp,0(sp)
   25054:	dec00104 	addi	sp,sp,4
   25058:	f800283a 	ret

0002505c <tse_mac_sTxWrite>:
  * @param txDesc           Pointer to the transmit SGDMA descriptor
  * @return actual bytes transferred if ok, else error (-1)
  */
alt_32 tse_mac_sTxWrite( tse_mac_trans_info *mi, 
                       alt_sgdma_descriptor *txDesc)   
{ 
   2505c:	defffa04 	addi	sp,sp,-24
   25060:	dfc00515 	stw	ra,20(sp)
   25064:	df000415 	stw	fp,16(sp)
   25068:	df000404 	addi	fp,sp,16
   2506c:	e13ffe15 	stw	r4,-8(fp)
   25070:	e17fff15 	stw	r5,-4(fp)

  alt_32 timeout;
  alt_u8 result = 0;
   25074:	e03ffd05 	stb	zero,-12(fp)
  alt_u16 actualBytesTransferred;
    
  // Make sure DMA controller is not busy from a former command
  // and TX is able to accept data
  timeout = 0;
   25078:	e03ffc15 	stw	zero,-16(fp)
  //tse_dprintf("\nWaiting while tx SGDMA is busy......... ");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->tx_sgdma->base) & 
   2507c:	00000e06 	br	250b8 <tse_mac_sTxWrite+0x5c>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
           if(timeout++ == ALTERA_TSE_SGDMA_BUSY_TIME_OUT_CNT) {
   25080:	e0fffc17 	ldw	r3,-16(fp)
   25084:	008003f4 	movhi	r2,15
   25088:	10909004 	addi	r2,r2,16960
   2508c:	1885003a 	cmpeq	r2,r3,r2
   25090:	e0fffc17 	ldw	r3,-16(fp)
   25094:	18c00044 	addi	r3,r3,1
   25098:	e0fffc15 	stw	r3,-16(fp)
   2509c:	10803fcc 	andi	r2,r2,255
   250a0:	10000526 	beq	r2,zero,250b8 <tse_mac_sTxWrite+0x5c>
            tse_dprintf(4, "WARNING : TX SGDMA Timeout\n");
   250a4:	010000f4 	movhi	r4,3
   250a8:	213ce904 	addi	r4,r4,-3164
   250ac:	0024fd00 	call	24fd0 <no_printf>
            return ENP_RESOURCE;  // avoid being stuck here
   250b0:	00bffa84 	movi	r2,-22
   250b4:	00001c06 	br	25128 <tse_mac_sTxWrite+0xcc>
    
  // Make sure DMA controller is not busy from a former command
  // and TX is able to accept data
  timeout = 0;
  //tse_dprintf("\nWaiting while tx SGDMA is busy......... ");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->tx_sgdma->base) & 
   250b8:	e0bffe17 	ldw	r2,-8(fp)
   250bc:	10800117 	ldw	r2,4(r2)
   250c0:	10800317 	ldw	r2,12(r2)
   250c4:	10800037 	ldwio	r2,0(r2)
   250c8:	1080040c 	andi	r2,r2,16
   250cc:	103fec1e 	bne	r2,zero,25080 <tse_mac_sTxWrite+0x24>
           }
  }

  // Set up the SGDMA
  // Clear the status and control bits of the SGDMA descriptor
  IOWR_ALTERA_AVALON_SGDMA_CONTROL (mi->tx_sgdma->base, 0);
   250d0:	e0bffe17 	ldw	r2,-8(fp)
   250d4:	10800117 	ldw	r2,4(r2)
   250d8:	10800317 	ldw	r2,12(r2)
   250dc:	10800404 	addi	r2,r2,16
   250e0:	0007883a 	mov	r3,zero
   250e4:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS (mi->tx_sgdma->base, 0xFF);
   250e8:	e0bffe17 	ldw	r2,-8(fp)
   250ec:	10800117 	ldw	r2,4(r2)
   250f0:	10800317 	ldw	r2,12(r2)
   250f4:	00c03fc4 	movi	r3,255
   250f8:	10c00035 	stwio	r3,0(r2)
  
  // Start SGDMA (blocking call)
  result = alt_avalon_sgdma_do_sync_transfer(
                mi->tx_sgdma, 
   250fc:	e0bffe17 	ldw	r2,-8(fp)
  // Clear the status and control bits of the SGDMA descriptor
  IOWR_ALTERA_AVALON_SGDMA_CONTROL (mi->tx_sgdma->base, 0);
  IOWR_ALTERA_AVALON_SGDMA_STATUS (mi->tx_sgdma->base, 0xFF);
  
  // Start SGDMA (blocking call)
  result = alt_avalon_sgdma_do_sync_transfer(
   25100:	10800117 	ldw	r2,4(r2)
   25104:	1009883a 	mov	r4,r2
   25108:	e17fff17 	ldw	r5,-4(fp)
   2510c:	00242f00 	call	242f0 <alt_avalon_sgdma_do_sync_transfer>
   25110:	e0bffd05 	stb	r2,-12(fp)
                mi->tx_sgdma, 
                (alt_sgdma_descriptor *) &txDesc[0]);
  
  /* perform cache save read to obtain actual bytes transferred for current sgdma descriptor */
  actualBytesTransferred = IORD_ALTERA_TSE_SGDMA_DESC_ACTUAL_BYTES_TRANSFERRED(&txDesc[0]);
   25114:	e0bfff17 	ldw	r2,-4(fp)
   25118:	10800704 	addi	r2,r2,28
   2511c:	10800037 	ldwio	r2,0(r2)
   25120:	e0bffd8d 	sth	r2,-10(fp)

  return actualBytesTransferred;
   25124:	e0bffd8b 	ldhu	r2,-10(fp)
}
   25128:	e037883a 	mov	sp,fp
   2512c:	dfc00117 	ldw	ra,4(sp)
   25130:	df000017 	ldw	fp,0(sp)
   25134:	dec00204 	addi	sp,sp,8
   25138:	f800283a 	ret

0002513c <tse_mac_aRxRead>:
  *        the actual bytes transferred for current descriptor
  */
alt_32 tse_mac_aRxRead( 
  tse_mac_trans_info *mi,       
  alt_sgdma_descriptor *rxDesc)  
{
   2513c:	defffa04 	addi	sp,sp,-24
   25140:	dfc00515 	stw	ra,20(sp)
   25144:	df000415 	stw	fp,16(sp)
   25148:	df000404 	addi	fp,sp,16
   2514c:	e13ffe15 	stw	r4,-8(fp)
   25150:	e17fff15 	stw	r5,-4(fp)
  alt_32 timeout;
  
  alt_u8 result = 0;
   25154:	e03ffd05 	stb	zero,-12(fp)
         
  // Make sure SGDMA controller is not busy from a former command
  timeout = 0;
   25158:	e03ffc15 	stw	zero,-16(fp)
//  tse_dprintf("\nWaiting while rx SGDMA is busy.........");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->rx_sgdma->base) & 
   2515c:	00000e06 	br	25198 <tse_mac_aRxRead+0x5c>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    if(timeout++ == ALTERA_TSE_SGDMA_BUSY_TIME_OUT_CNT) {
   25160:	e0fffc17 	ldw	r3,-16(fp)
   25164:	008003f4 	movhi	r2,15
   25168:	10909004 	addi	r2,r2,16960
   2516c:	1885003a 	cmpeq	r2,r3,r2
   25170:	e0fffc17 	ldw	r3,-16(fp)
   25174:	18c00044 	addi	r3,r3,1
   25178:	e0fffc15 	stw	r3,-16(fp)
   2517c:	10803fcc 	andi	r2,r2,255
   25180:	10000526 	beq	r2,zero,25198 <tse_mac_aRxRead+0x5c>
        tse_dprintf(4, "WARNING : RX SGDMA Timeout\n");
   25184:	010000f4 	movhi	r4,3
   25188:	213cf004 	addi	r4,r4,-3136
   2518c:	0024fd00 	call	24fd0 <no_printf>
        return ENP_RESOURCE;  // avoid being stuck here
   25190:	00bffa84 	movi	r2,-22
   25194:	00000d06 	br	251cc <tse_mac_aRxRead+0x90>
  alt_u8 result = 0;
         
  // Make sure SGDMA controller is not busy from a former command
  timeout = 0;
//  tse_dprintf("\nWaiting while rx SGDMA is busy.........");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->rx_sgdma->base) & 
   25198:	e0bffe17 	ldw	r2,-8(fp)
   2519c:	10800217 	ldw	r2,8(r2)
   251a0:	10800317 	ldw	r2,12(r2)
   251a4:	10800037 	ldwio	r2,0(r2)
   251a8:	1080040c 	andi	r2,r2,16
   251ac:	103fec1e 	bne	r2,zero,25160 <tse_mac_aRxRead+0x24>
  }

 
  // SGDMA operation invoked for RX (non-blocking call)
  result = alt_avalon_sgdma_do_async_transfer(
                mi->rx_sgdma, 
   251b0:	e0bffe17 	ldw	r2,-8(fp)
    }
  }

 
  // SGDMA operation invoked for RX (non-blocking call)
  result = alt_avalon_sgdma_do_async_transfer(
   251b4:	10800217 	ldw	r2,8(r2)
   251b8:	1009883a 	mov	r4,r2
   251bc:	e17fff17 	ldw	r5,-4(fp)
   251c0:	00241cc0 	call	241cc <alt_avalon_sgdma_do_async_transfer>
   251c4:	e0bffd05 	stb	r2,-12(fp)
                mi->rx_sgdma, 
                (alt_sgdma_descriptor *) &rxDesc[0]);

 
  return SUCCESS;
   251c8:	0005883a 	mov	r2,zero
}
   251cc:	e037883a 	mov	sp,fp
   251d0:	dfc00117 	ldw	ra,4(sp)
   251d4:	df000017 	ldw	fp,0(sp)
   251d8:	dec00204 	addi	sp,sp,8
   251dc:	f800283a 	ret

000251e0 <tse_mac_SwReset>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
*/
alt_32 tse_mac_SwReset(np_tse_mac *pmac) 
{
   251e0:	defffc04 	addi	sp,sp,-16
   251e4:	df000315 	stw	fp,12(sp)
   251e8:	df000304 	addi	fp,sp,12
   251ec:	e13fff15 	stw	r4,-4(fp)
	alt_32 timeout;
	alt_32 cc;
        
    cc = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
   251f0:	e0bfff17 	ldw	r2,-4(fp)
   251f4:	10800204 	addi	r2,r2,8
   251f8:	10800037 	ldwio	r2,0(r2)
   251fc:	e0bffe15 	stw	r2,-8(fp)
    
    // set reset and Gig-Speed bits to make sure we have an incoming clock on
    // tx side. If there is a 10/100 PHY, we will still have a valid clock on
    // tx_clk no matter what setting we have here, but on a Gig phy the
    // MII clock may be missing.
    IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,(ALTERA_TSEMAC_CMD_SW_RESET_MSK | ALTERA_TSEMAC_CMD_ETH_SPEED_MSK));
   25200:	e0bfff17 	ldw	r2,-4(fp)
   25204:	10800204 	addi	r2,r2,8
   25208:	00c80204 	movi	r3,8200
   2520c:	10c00035 	stwio	r3,0(r2)

    
    // wait for completion with fallback in case there is no PHY or it is
    // not connected and hence might not provide any clocks at all.
    timeout=0;
   25210:	e03ffd15 	stw	zero,-12(fp)
    while( (IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac) & ALTERA_TSEMAC_CMD_SW_RESET_MSK) != 0 && timeout < ALTERA_TSE_SW_RESET_TIME_OUT_CNT) timeout++;
   25214:	00000306 	br	25224 <tse_mac_SwReset+0x44>
   25218:	e0bffd17 	ldw	r2,-12(fp)
   2521c:	10800044 	addi	r2,r2,1
   25220:	e0bffd15 	stw	r2,-12(fp)
   25224:	e0bfff17 	ldw	r2,-4(fp)
   25228:	10800204 	addi	r2,r2,8
   2522c:	10800037 	ldwio	r2,0(r2)
   25230:	1088000c 	andi	r2,r2,8192
   25234:	10000326 	beq	r2,zero,25244 <tse_mac_SwReset+0x64>
   25238:	e0bffd17 	ldw	r2,-12(fp)
   2523c:	1089c410 	cmplti	r2,r2,10000
   25240:	103ff51e 	bne	r2,zero,25218 <tse_mac_SwReset+0x38>
   
    IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,cc); // Restore
   25244:	e0bfff17 	ldw	r2,-4(fp)
   25248:	10800204 	addi	r2,r2,8
   2524c:	e0fffe17 	ldw	r3,-8(fp)
   25250:	10c00035 	stwio	r3,0(r2)
    return SUCCESS;
   25254:	0005883a 	mov	r2,zero
}
   25258:	e037883a 	mov	sp,fp
   2525c:	df000017 	ldw	fp,0(sp)
   25260:	dec00104 	addi	sp,sp,4
   25264:	f800283a 	ret

00025268 <tse_mac_setMIImode>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
*/
alt_32 tse_mac_setMIImode(np_tse_mac *pmac)
{
   25268:	defffd04 	addi	sp,sp,-12
   2526c:	df000215 	stw	fp,8(sp)
   25270:	df000204 	addi	fp,sp,8
   25274:	e13fff15 	stw	r4,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
   25278:	e0bfff17 	ldw	r2,-4(fp)
   2527c:	10800204 	addi	r2,r2,8
   25280:	10800037 	ldwio	r2,0(r2)
   25284:	e0bffe15 	stw	r2,-8(fp)
  helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK; 
   25288:	e0fffe17 	ldw	r3,-8(fp)
   2528c:	00bffdc4 	movi	r2,-9
   25290:	1884703a 	and	r2,r3,r2
   25294:	e0bffe15 	stw	r2,-8(fp)
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,helpvar);
   25298:	e0bfff17 	ldw	r2,-4(fp)
   2529c:	10800204 	addi	r2,r2,8
   252a0:	e0fffe17 	ldw	r3,-8(fp)
   252a4:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
   252a8:	0005883a 	mov	r2,zero
}
   252ac:	e037883a 	mov	sp,fp
   252b0:	df000017 	ldw	fp,0(sp)
   252b4:	dec00104 	addi	sp,sp,4
   252b8:	f800283a 	ret

000252bc <tse_mac_setGMIImode>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
 */
alt_32 tse_mac_setGMIImode(np_tse_mac *pmac)
{
   252bc:	defffd04 	addi	sp,sp,-12
   252c0:	df000215 	stw	fp,8(sp)
   252c4:	df000204 	addi	fp,sp,8
   252c8:	e13fff15 	stw	r4,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
   252cc:	e0bfff17 	ldw	r2,-4(fp)
   252d0:	10800204 	addi	r2,r2,8
   252d4:	10800037 	ldwio	r2,0(r2)
   252d8:	e0bffe15 	stw	r2,-8(fp)
  helpvar |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
   252dc:	e0bffe17 	ldw	r2,-8(fp)
   252e0:	10800214 	ori	r2,r2,8
   252e4:	e0bffe15 	stw	r2,-8(fp)

  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,helpvar);
   252e8:	e0bfff17 	ldw	r2,-4(fp)
   252ec:	10800204 	addi	r2,r2,8
   252f0:	e0fffe17 	ldw	r3,-8(fp)
   252f4:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
   252f8:	0005883a 	mov	r2,zero
}
   252fc:	e037883a 	mov	sp,fp
   25300:	df000017 	ldw	fp,0(sp)
   25304:	dec00104 	addi	sp,sp,4
   25308:	f800283a 	ret

0002530c <alt_tse_phy_add_profile>:
 * @param  phy  pointer to alt_tse_phy_profile structure describing PHY registers
 * @return      index of PHY added in PHY profile on success, else return ALTERA_TSE_MALLOC_FAILED if memory allocation failed
 * PHY which are currently supported by default :  Marvell 88E1111, Marvell Quad PHY 88E1145, National DP83865, and National DP83848C
 */
alt_32 alt_tse_phy_add_profile(alt_tse_phy_profile *phy)
{
   2530c:	defffb04 	addi	sp,sp,-20
   25310:	dfc00415 	stw	ra,16(sp)
   25314:	df000315 	stw	fp,12(sp)
   25318:	dc000215 	stw	r16,8(sp)
   2531c:	df000204 	addi	fp,sp,8
   25320:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
    
    /* search PHY profile for same ID */
    for(i = 0; i < phy_profile_count; i++)
   25324:	e03ffe15 	stw	zero,-8(fp)
   25328:	00002906 	br	253d0 <alt_tse_phy_add_profile+0xc4>
    {
        if(pphy_profiles[i]->oui == phy->oui && pphy_profiles[i]->model_number == phy->model_number)
   2532c:	00c00134 	movhi	r3,4
   25330:	18cdf004 	addi	r3,r3,14272
   25334:	e0bffe17 	ldw	r2,-8(fp)
   25338:	1085883a 	add	r2,r2,r2
   2533c:	1085883a 	add	r2,r2,r2
   25340:	1885883a 	add	r2,r3,r2
   25344:	10800017 	ldw	r2,0(r2)
   25348:	10c01417 	ldw	r3,80(r2)
   2534c:	e0bfff17 	ldw	r2,-4(fp)
   25350:	10801417 	ldw	r2,80(r2)
   25354:	18801b1e 	bne	r3,r2,253c4 <alt_tse_phy_add_profile+0xb8>
   25358:	00c00134 	movhi	r3,4
   2535c:	18cdf004 	addi	r3,r3,14272
   25360:	e0bffe17 	ldw	r2,-8(fp)
   25364:	1085883a 	add	r2,r2,r2
   25368:	1085883a 	add	r2,r2,r2
   2536c:	1885883a 	add	r2,r3,r2
   25370:	10800017 	ldw	r2,0(r2)
   25374:	10c01503 	ldbu	r3,84(r2)
   25378:	e0bfff17 	ldw	r2,-4(fp)
   2537c:	10801503 	ldbu	r2,84(r2)
   25380:	18c03fcc 	andi	r3,r3,255
   25384:	10803fcc 	andi	r2,r2,255
   25388:	18800e1e 	bne	r3,r2,253c4 <alt_tse_phy_add_profile+0xb8>
        {
            tse_dprintf(4, "WARNING : PHY OUI 0x%06x, PHY Model Number 0x%02x already exist in PHY profile\n", (int) phy->oui, phy->model_number);
   2538c:	e0bfff17 	ldw	r2,-4(fp)
   25390:	10801417 	ldw	r2,80(r2)
   25394:	1007883a 	mov	r3,r2
   25398:	e0bfff17 	ldw	r2,-4(fp)
   2539c:	10801503 	ldbu	r2,84(r2)
   253a0:	10803fcc 	andi	r2,r2,255
   253a4:	010000f4 	movhi	r4,3
   253a8:	213cf704 	addi	r4,r4,-3108
   253ac:	180b883a 	mov	r5,r3
   253b0:	100d883a 	mov	r6,r2
   253b4:	0024fd00 	call	24fd0 <no_printf>
            tse_dprintf(4, "In case of same PHY OUI and PHY Model Number in profile, first added PHY setting will be used\n");
   253b8:	010000f4 	movhi	r4,3
   253bc:	213d0b04 	addi	r4,r4,-3028
   253c0:	0024fd00 	call	24fd0 <no_printf>
alt_32 alt_tse_phy_add_profile(alt_tse_phy_profile *phy)
{
	alt_32 i;
    
    /* search PHY profile for same ID */
    for(i = 0; i < phy_profile_count; i++)
   253c4:	e0bffe17 	ldw	r2,-8(fp)
   253c8:	10800044 	addi	r2,r2,1
   253cc:	e0bffe15 	stw	r2,-8(fp)
   253d0:	d0a8f703 	ldbu	r2,-23588(gp)
   253d4:	10803fcc 	andi	r2,r2,255
   253d8:	e0fffe17 	ldw	r3,-8(fp)
   253dc:	18bfd316 	blt	r3,r2,2532c <alt_tse_phy_add_profile+0x20>
            tse_dprintf(4, "In case of same PHY OUI and PHY Model Number in profile, first added PHY setting will be used\n");
        }
    }

    /* Allocate memory space to store the profile */    
    pphy_profiles[phy_profile_count] = (alt_tse_phy_profile *) malloc(sizeof(alt_tse_phy_profile));
   253e0:	d0a8f703 	ldbu	r2,-23588(gp)
   253e4:	14003fcc 	andi	r16,r2,255
   253e8:	01001904 	movi	r4,100
   253ec:	002c1400 	call	2c140 <malloc>
   253f0:	1007883a 	mov	r3,r2
   253f4:	01000134 	movhi	r4,4
   253f8:	210df004 	addi	r4,r4,14272
   253fc:	8405883a 	add	r2,r16,r16
   25400:	1085883a 	add	r2,r2,r2
   25404:	2085883a 	add	r2,r4,r2
   25408:	10c00015 	stw	r3,0(r2)
    if(!pphy_profiles[phy_profile_count]) {
   2540c:	d0a8f703 	ldbu	r2,-23588(gp)
   25410:	10803fcc 	andi	r2,r2,255
   25414:	00c00134 	movhi	r3,4
   25418:	18cdf004 	addi	r3,r3,14272
   2541c:	1085883a 	add	r2,r2,r2
   25420:	1085883a 	add	r2,r2,r2
   25424:	1885883a 	add	r2,r3,r2
   25428:	10800017 	ldw	r2,0(r2)
   2542c:	1000081e 	bne	r2,zero,25450 <alt_tse_phy_add_profile+0x144>
        tse_dprintf(1, "ERROR   : Unable to allocate memory for pphy_profile[%d]\n", phy_profile_count);
   25430:	d0a8f703 	ldbu	r2,-23588(gp)
   25434:	10803fcc 	andi	r2,r2,255
   25438:	010000f4 	movhi	r4,3
   2543c:	213d2304 	addi	r4,r4,-2932
   25440:	100b883a 	mov	r5,r2
   25444:	0024fd00 	call	24fd0 <no_printf>
        return ALTERA_TSE_MALLOC_FAILED;
   25448:	00bfffc4 	movi	r2,-1
   2544c:	00002206 	br	254d8 <alt_tse_phy_add_profile+0x1cc>
    }

    /* Store PHY information */
    *pphy_profiles[phy_profile_count] = *phy;
   25450:	d0a8f703 	ldbu	r2,-23588(gp)
   25454:	10803fcc 	andi	r2,r2,255
   25458:	00c00134 	movhi	r3,4
   2545c:	18cdf004 	addi	r3,r3,14272
   25460:	1085883a 	add	r2,r2,r2
   25464:	1085883a 	add	r2,r2,r2
   25468:	1885883a 	add	r2,r3,r2
   2546c:	10c00017 	ldw	r3,0(r2)
   25470:	e0bfff17 	ldw	r2,-4(fp)
   25474:	1809883a 	mov	r4,r3
   25478:	1007883a 	mov	r3,r2
   2547c:	00801904 	movi	r2,100
   25480:	180b883a 	mov	r5,r3
   25484:	100d883a 	mov	r6,r2
   25488:	00164c00 	call	164c0 <memcpy>
    strcpy(pphy_profiles[phy_profile_count]->name, phy->name);
   2548c:	d0a8f703 	ldbu	r2,-23588(gp)
   25490:	10803fcc 	andi	r2,r2,255
   25494:	00c00134 	movhi	r3,4
   25498:	18cdf004 	addi	r3,r3,14272
   2549c:	1085883a 	add	r2,r2,r2
   254a0:	1085883a 	add	r2,r2,r2
   254a4:	1885883a 	add	r2,r3,r2
   254a8:	10800017 	ldw	r2,0(r2)
   254ac:	1007883a 	mov	r3,r2
   254b0:	e0bfff17 	ldw	r2,-4(fp)
   254b4:	1809883a 	mov	r4,r3
   254b8:	100b883a 	mov	r5,r2
   254bc:	002c1e40 	call	2c1e4 <strcpy>
    
    phy_profile_count++;
   254c0:	d0a8f703 	ldbu	r2,-23588(gp)
   254c4:	10800044 	addi	r2,r2,1
   254c8:	d0a8f705 	stb	r2,-23588(gp)
    
    return phy_profile_count - 1;
   254cc:	d0a8f703 	ldbu	r2,-23588(gp)
   254d0:	10803fcc 	andi	r2,r2,255
   254d4:	10bfffc4 	addi	r2,r2,-1
}
   254d8:	e037883a 	mov	sp,fp
   254dc:	dfc00217 	ldw	ra,8(sp)
   254e0:	df000117 	ldw	fp,4(sp)
   254e4:	dc000017 	ldw	r16,0(sp)
   254e8:	dec00304 	addi	sp,sp,12
   254ec:	f800283a 	ret

000254f0 <alt_tse_system_add_sys>:
alt_32 alt_tse_system_add_sys(
	alt_tse_system_mac					*psys_mac,
	alt_tse_system_sgdma				*psys_sgdma,
	alt_tse_system_desc_mem				*psys_mem,
	alt_tse_system_shared_fifo			*psys_shared_fifo,
	alt_tse_system_phy 					*psys_phy ) {
   254f0:	defff204 	addi	sp,sp,-56
   254f4:	dfc00d15 	stw	ra,52(sp)
   254f8:	df000c15 	stw	fp,48(sp)
   254fc:	dc000b15 	stw	r16,44(sp)
   25500:	df000b04 	addi	fp,sp,44
   25504:	e13ffc15 	stw	r4,-16(fp)
   25508:	e17ffd15 	stw	r5,-12(fp)
   2550c:	e1bffe15 	stw	r6,-8(fp)
   25510:	e1ffff15 	stw	r7,-4(fp)

	int i;
	int loop_end;
	
	alt_tse_system_mac					*pmac	= psys_mac;
   25514:	e0bffc17 	ldw	r2,-16(fp)
   25518:	e0bffb15 	stw	r2,-20(fp)
	alt_tse_system_sgdma				*psgdma	= psys_sgdma;
   2551c:	e0bffd17 	ldw	r2,-12(fp)
   25520:	e0bff715 	stw	r2,-36(fp)
	alt_tse_system_desc_mem				*pmem	= psys_mem;
   25524:	e0bffe17 	ldw	r2,-8(fp)
   25528:	e0bff815 	stw	r2,-32(fp)
	alt_tse_system_shared_fifo			*pfifo	= psys_shared_fifo;
   2552c:	e0bfff17 	ldw	r2,-4(fp)
   25530:	e0bff915 	stw	r2,-28(fp)
	alt_tse_system_phy 					*pphy	= psys_phy;
   25534:	e0800317 	ldw	r2,12(fp)
   25538:	e0bffa15 	stw	r2,-24(fp)
	
	static alt_8 tse_system_count = 0;
	
	/* Determine number of loop */
	/* Run at least one for non-multi-channel MAC */
	if(pmac->tse_num_of_channel == 0) {
   2553c:	e0bffb17 	ldw	r2,-20(fp)
   25540:	10800303 	ldbu	r2,12(r2)
   25544:	10803fcc 	andi	r2,r2,255
   25548:	1000031e 	bne	r2,zero,25558 <alt_tse_system_add_sys+0x68>
		loop_end = 1;
   2554c:	00800044 	movi	r2,1
   25550:	e0bff615 	stw	r2,-40(fp)
   25554:	00000e06 	br	25590 <alt_tse_system_add_sys+0xa0>
	}
	else if(pmac->tse_num_of_channel > 0) {
   25558:	e0bffb17 	ldw	r2,-20(fp)
   2555c:	10800303 	ldbu	r2,12(r2)
   25560:	10803fcc 	andi	r2,r2,255
   25564:	10000526 	beq	r2,zero,2557c <alt_tse_system_add_sys+0x8c>
		loop_end = pmac->tse_num_of_channel; 
   25568:	e0bffb17 	ldw	r2,-20(fp)
   2556c:	10800303 	ldbu	r2,12(r2)
   25570:	10803fcc 	andi	r2,r2,255
   25574:	e0bff615 	stw	r2,-40(fp)
   25578:	00000506 	br	25590 <alt_tse_system_add_sys+0xa0>
	}
	else {
		tse_dprintf(2, "ERROR   : Invalid number of channel specified!\n");
   2557c:	010000f4 	movhi	r4,3
   25580:	213d3204 	addi	r4,r4,-2872
   25584:	0024fd00 	call	24fd0 <no_printf>
		return ALTERA_TSE_SYSTEM_DEF_ERROR;
   25588:	00bfffc4 	movi	r2,-1
   2558c:	00025106 	br	25ed4 <alt_tse_system_add_sys+0x9e4>
	}

	for(i = 0; i < loop_end; i++) {
   25590:	e03ff515 	stw	zero,-44(fp)
   25594:	00024b06 	br	25ec4 <alt_tse_system_add_sys+0x9d4>
		
		/* Make sure the boundary of array is not exceeded */
		if(tse_system_count >= MAXNETS) {
   25598:	d0a8f7c3 	ldbu	r2,-23585(gp)
   2559c:	10803fcc 	andi	r2,r2,255
   255a0:	1080201c 	xori	r2,r2,128
   255a4:	10bfe004 	addi	r2,r2,-128
   255a8:	10800210 	cmplti	r2,r2,8
   255ac:	10000c1e 	bne	r2,zero,255e0 <alt_tse_system_add_sys+0xf0>
			tse_dprintf(2, "ERROR   : Number of TSE System added exceed the size of array!\n");
   255b0:	010000f4 	movhi	r4,3
   255b4:	213d3e04 	addi	r4,r4,-2824
   255b8:	0024fd00 	call	24fd0 <no_printf>
			tse_dprintf(2, "ERROR   : Size of array = %d, Number of TSE System = %d\n", MAXNETS, tse_system_count);
   255bc:	d0a8f7c3 	ldbu	r2,-23585(gp)
   255c0:	10803fcc 	andi	r2,r2,255
   255c4:	1080201c 	xori	r2,r2,128
   255c8:	10bfe004 	addi	r2,r2,-128
   255cc:	010000f4 	movhi	r4,3
   255d0:	213d4e04 	addi	r4,r4,-2760
   255d4:	01400204 	movi	r5,8
   255d8:	100d883a 	mov	r6,r2
   255dc:	0024fd00 	call	24fd0 <no_printf>
		}

		/* Add MAC info to alt_tse_system_info structure */
		if(pmac == 0) {
   255e0:	e0bffb17 	ldw	r2,-20(fp)
   255e4:	1000081e 	bne	r2,zero,25608 <alt_tse_system_add_sys+0x118>
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
   255e8:	010000f4 	movhi	r4,3
   255ec:	213d5d04 	addi	r4,r4,-2700
   255f0:	0024fd00 	call	24fd0 <no_printf>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_system_add_sys()\n");
   255f4:	010000f4 	movhi	r4,3
   255f8:	213d6704 	addi	r4,r4,-2660
   255fc:	0024fd00 	call	24fd0 <no_printf>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
   25600:	00bfffc4 	movi	r2,-1
   25604:	00023306 	br	25ed4 <alt_tse_system_add_sys+0x9e4>
		}		
		
		tse_mac_device[tse_system_count].tse_mac_base 					= pmac->tse_mac_base + (i * 0x400);
   25608:	d0a8f7c3 	ldbu	r2,-23585(gp)
   2560c:	10803fcc 	andi	r2,r2,255
   25610:	1080201c 	xori	r2,r2,128
   25614:	10bfe004 	addi	r2,r2,-128
   25618:	e0fffb17 	ldw	r3,-20(fp)
   2561c:	19000017 	ldw	r4,0(r3)
   25620:	e0fff517 	ldw	r3,-44(fp)
   25624:	180692ba 	slli	r3,r3,10
   25628:	20c7883a 	add	r3,r4,r3
   2562c:	010000f4 	movhi	r4,3
   25630:	210c9004 	addi	r4,r4,12864
   25634:	10801224 	muli	r2,r2,72
   25638:	2085883a 	add	r2,r4,r2
   2563c:	10c00015 	stw	r3,0(r2)
		tse_mac_device[tse_system_count].tse_tx_depth 					= pmac->tse_tx_depth;
   25640:	d0a8f7c3 	ldbu	r2,-23585(gp)
   25644:	10803fcc 	andi	r2,r2,255
   25648:	1080201c 	xori	r2,r2,128
   2564c:	10bfe004 	addi	r2,r2,-128
   25650:	e0fffb17 	ldw	r3,-20(fp)
   25654:	18c0010b 	ldhu	r3,4(r3)
   25658:	010000f4 	movhi	r4,3
   2565c:	210c9004 	addi	r4,r4,12864
   25660:	10801224 	muli	r2,r2,72
   25664:	2085883a 	add	r2,r4,r2
   25668:	10800104 	addi	r2,r2,4
   2566c:	10c0000d 	sth	r3,0(r2)
		tse_mac_device[tse_system_count].tse_rx_depth 					= pmac->tse_rx_depth;
   25670:	d0a8f7c3 	ldbu	r2,-23585(gp)
   25674:	10803fcc 	andi	r2,r2,255
   25678:	1080201c 	xori	r2,r2,128
   2567c:	10bfe004 	addi	r2,r2,-128
   25680:	e0fffb17 	ldw	r3,-20(fp)
   25684:	18c0018b 	ldhu	r3,6(r3)
   25688:	010000f4 	movhi	r4,3
   2568c:	210c9004 	addi	r4,r4,12864
   25690:	10801224 	muli	r2,r2,72
   25694:	2085883a 	add	r2,r4,r2
   25698:	10800104 	addi	r2,r2,4
   2569c:	10c0008d 	sth	r3,2(r2)
		tse_mac_device[tse_system_count].tse_use_mdio 					= pmac->tse_use_mdio;
   256a0:	d0a8f7c3 	ldbu	r2,-23585(gp)
   256a4:	10803fcc 	andi	r2,r2,255
   256a8:	1080201c 	xori	r2,r2,128
   256ac:	10bfe004 	addi	r2,r2,-128
   256b0:	e0fffb17 	ldw	r3,-20(fp)
   256b4:	18c00203 	ldbu	r3,8(r3)
   256b8:	010000f4 	movhi	r4,3
   256bc:	210c9004 	addi	r4,r4,12864
   256c0:	10801224 	muli	r2,r2,72
   256c4:	2085883a 	add	r2,r4,r2
   256c8:	10800204 	addi	r2,r2,8
   256cc:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_en_maclite 				= pmac->tse_en_maclite;
   256d0:	d0a8f7c3 	ldbu	r2,-23585(gp)
   256d4:	10803fcc 	andi	r2,r2,255
   256d8:	1080201c 	xori	r2,r2,128
   256dc:	10bfe004 	addi	r2,r2,-128
   256e0:	e0fffb17 	ldw	r3,-20(fp)
   256e4:	18c00243 	ldbu	r3,9(r3)
   256e8:	010000f4 	movhi	r4,3
   256ec:	210c9004 	addi	r4,r4,12864
   256f0:	10801224 	muli	r2,r2,72
   256f4:	2085883a 	add	r2,r4,r2
   256f8:	10800204 	addi	r2,r2,8
   256fc:	10c00045 	stb	r3,1(r2)
		tse_mac_device[tse_system_count].tse_maclite_gige 				= pmac->tse_maclite_gige;
   25700:	d0a8f7c3 	ldbu	r2,-23585(gp)
   25704:	10803fcc 	andi	r2,r2,255
   25708:	1080201c 	xori	r2,r2,128
   2570c:	10bfe004 	addi	r2,r2,-128
   25710:	e0fffb17 	ldw	r3,-20(fp)
   25714:	18c00283 	ldbu	r3,10(r3)
   25718:	010000f4 	movhi	r4,3
   2571c:	210c9004 	addi	r4,r4,12864
   25720:	10801224 	muli	r2,r2,72
   25724:	2085883a 	add	r2,r4,r2
   25728:	10800204 	addi	r2,r2,8
   2572c:	10c00085 	stb	r3,2(r2)
		tse_mac_device[tse_system_count].tse_multichannel_mac 			= pmac->tse_multichannel_mac;
   25730:	d0a8f7c3 	ldbu	r2,-23585(gp)
   25734:	10803fcc 	andi	r2,r2,255
   25738:	1080201c 	xori	r2,r2,128
   2573c:	10bfe004 	addi	r2,r2,-128
   25740:	e0fffb17 	ldw	r3,-20(fp)
   25744:	18c002c3 	ldbu	r3,11(r3)
   25748:	010000f4 	movhi	r4,3
   2574c:	210c9004 	addi	r4,r4,12864
   25750:	10801224 	muli	r2,r2,72
   25754:	2085883a 	add	r2,r4,r2
   25758:	10800204 	addi	r2,r2,8
   2575c:	10c000c5 	stb	r3,3(r2)
		tse_mac_device[tse_system_count].tse_num_of_channel 			= pmac->tse_num_of_channel;
   25760:	d0a8f7c3 	ldbu	r2,-23585(gp)
   25764:	10803fcc 	andi	r2,r2,255
   25768:	1080201c 	xori	r2,r2,128
   2576c:	10bfe004 	addi	r2,r2,-128
   25770:	e0fffb17 	ldw	r3,-20(fp)
   25774:	18c00303 	ldbu	r3,12(r3)
   25778:	010000f4 	movhi	r4,3
   2577c:	210c9004 	addi	r4,r4,12864
   25780:	10801224 	muli	r2,r2,72
   25784:	2085883a 	add	r2,r4,r2
   25788:	10800304 	addi	r2,r2,12
   2578c:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_mdio_shared 				= pmac->tse_mdio_shared;
   25790:	d0a8f7c3 	ldbu	r2,-23585(gp)
   25794:	10803fcc 	andi	r2,r2,255
   25798:	1080201c 	xori	r2,r2,128
   2579c:	10bfe004 	addi	r2,r2,-128
   257a0:	e0fffb17 	ldw	r3,-20(fp)
   257a4:	18c00343 	ldbu	r3,13(r3)
   257a8:	010000f4 	movhi	r4,3
   257ac:	210c9004 	addi	r4,r4,12864
   257b0:	10801224 	muli	r2,r2,72
   257b4:	2085883a 	add	r2,r4,r2
   257b8:	10800304 	addi	r2,r2,12
   257bc:	10c00045 	stb	r3,1(r2)
		tse_mac_device[tse_system_count].tse_number_of_mac_mdio_shared	= pmac->tse_number_of_mac_mdio_shared;
   257c0:	d0a8f7c3 	ldbu	r2,-23585(gp)
   257c4:	10803fcc 	andi	r2,r2,255
   257c8:	1080201c 	xori	r2,r2,128
   257cc:	10bfe004 	addi	r2,r2,-128
   257d0:	e0fffb17 	ldw	r3,-20(fp)
   257d4:	18c00383 	ldbu	r3,14(r3)
   257d8:	010000f4 	movhi	r4,3
   257dc:	210c9004 	addi	r4,r4,12864
   257e0:	10801224 	muli	r2,r2,72
   257e4:	2085883a 	add	r2,r4,r2
   257e8:	10800304 	addi	r2,r2,12
   257ec:	10c00085 	stb	r3,2(r2)
		tse_mac_device[tse_system_count].tse_pcs_ena 					= pmac->tse_pcs_ena;
   257f0:	d0a8f7c3 	ldbu	r2,-23585(gp)
   257f4:	10803fcc 	andi	r2,r2,255
   257f8:	1080201c 	xori	r2,r2,128
   257fc:	10bfe004 	addi	r2,r2,-128
   25800:	e0fffb17 	ldw	r3,-20(fp)
   25804:	18c003c3 	ldbu	r3,15(r3)
   25808:	010000f4 	movhi	r4,3
   2580c:	210c9004 	addi	r4,r4,12864
   25810:	10801224 	muli	r2,r2,72
   25814:	2085883a 	add	r2,r4,r2
   25818:	10800304 	addi	r2,r2,12
   2581c:	10c000c5 	stb	r3,3(r2)
		tse_mac_device[tse_system_count].tse_pcs_sgmii 					= pmac->tse_pcs_sgmii;
   25820:	d0a8f7c3 	ldbu	r2,-23585(gp)
   25824:	10803fcc 	andi	r2,r2,255
   25828:	1080201c 	xori	r2,r2,128
   2582c:	10bfe004 	addi	r2,r2,-128
   25830:	e0fffb17 	ldw	r3,-20(fp)
   25834:	18c00403 	ldbu	r3,16(r3)
   25838:	010000f4 	movhi	r4,3
   2583c:	210c9004 	addi	r4,r4,12864
   25840:	10801224 	muli	r2,r2,72
   25844:	2085883a 	add	r2,r4,r2
   25848:	10800404 	addi	r2,r2,16
   2584c:	10c00005 	stb	r3,0(r2)
		
		/* Add SGDMA info to alt_tse_system_info structure */
		if(psgdma == 0) {
   25850:	e0bff717 	ldw	r2,-36(fp)
   25854:	10000d1e 	bne	r2,zero,2588c <alt_tse_system_add_sys+0x39c>
			tse_dprintf(2, "ERROR   : SGDMA system structure == NULL\n");
   25858:	010000f4 	movhi	r4,3
   2585c:	213d7904 	addi	r4,r4,-2588
   25860:	0024fd00 	call	24fd0 <no_printf>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_system_add_sys() for tse_mac_device[%d]\n", tse_system_count);
   25864:	d0a8f7c3 	ldbu	r2,-23585(gp)
   25868:	10803fcc 	andi	r2,r2,255
   2586c:	1080201c 	xori	r2,r2,128
   25870:	10bfe004 	addi	r2,r2,-128
   25874:	010000f4 	movhi	r4,3
   25878:	213d8404 	addi	r4,r4,-2544
   2587c:	100b883a 	mov	r5,r2
   25880:	0024fd00 	call	24fd0 <no_printf>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
   25884:	00bfffc4 	movi	r2,-1
   25888:	00019206 	br	25ed4 <alt_tse_system_add_sys+0x9e4>
		}
		
		tse_mac_device[tse_system_count].tse_sgdma_tx = (char *) malloc(strlen(psgdma->tse_sgdma_tx) + 1);
   2588c:	d0a8f7c3 	ldbu	r2,-23585(gp)
   25890:	14003fcc 	andi	r16,r2,255
   25894:	8400201c 	xori	r16,r16,128
   25898:	843fe004 	addi	r16,r16,-128
   2589c:	e0bff717 	ldw	r2,-36(fp)
   258a0:	10800017 	ldw	r2,0(r2)
   258a4:	1009883a 	mov	r4,r2
   258a8:	0016a080 	call	16a08 <strlen>
   258ac:	10800044 	addi	r2,r2,1
   258b0:	1009883a 	mov	r4,r2
   258b4:	002c1400 	call	2c140 <malloc>
   258b8:	1007883a 	mov	r3,r2
   258bc:	010000f4 	movhi	r4,3
   258c0:	210c9004 	addi	r4,r4,12864
   258c4:	80801224 	muli	r2,r16,72
   258c8:	2085883a 	add	r2,r4,r2
   258cc:	10800504 	addi	r2,r2,20
   258d0:	10c00015 	stw	r3,0(r2)
	    if(!tse_mac_device[tse_system_count].tse_sgdma_tx) {
   258d4:	d0a8f7c3 	ldbu	r2,-23585(gp)
   258d8:	10803fcc 	andi	r2,r2,255
   258dc:	1080201c 	xori	r2,r2,128
   258e0:	10bfe004 	addi	r2,r2,-128
   258e4:	00c000f4 	movhi	r3,3
   258e8:	18cc9004 	addi	r3,r3,12864
   258ec:	10801224 	muli	r2,r2,72
   258f0:	1885883a 	add	r2,r3,r2
   258f4:	10800504 	addi	r2,r2,20
   258f8:	10800017 	ldw	r2,0(r2)
   258fc:	10000a1e 	bne	r2,zero,25928 <alt_tse_system_add_sys+0x438>
	        tse_dprintf(1, "ERROR   : Unable to allocate memory for tse_mac_device[%d].tse_sgdma_tx\n", tse_system_count);
   25900:	d0a8f7c3 	ldbu	r2,-23585(gp)
   25904:	10803fcc 	andi	r2,r2,255
   25908:	1080201c 	xori	r2,r2,128
   2590c:	10bfe004 	addi	r2,r2,-128
   25910:	010000f4 	movhi	r4,3
   25914:	213d9c04 	addi	r4,r4,-2448
   25918:	100b883a 	mov	r5,r2
   2591c:	0024fd00 	call	24fd0 <no_printf>
	        return ALTERA_TSE_MALLOC_FAILED;
   25920:	00bfffc4 	movi	r2,-1
   25924:	00016b06 	br	25ed4 <alt_tse_system_add_sys+0x9e4>
	    }   
		strcpy(tse_mac_device[tse_system_count].tse_sgdma_tx, psgdma->tse_sgdma_tx);
   25928:	d0a8f7c3 	ldbu	r2,-23585(gp)
   2592c:	10803fcc 	andi	r2,r2,255
   25930:	1080201c 	xori	r2,r2,128
   25934:	10bfe004 	addi	r2,r2,-128
   25938:	00c000f4 	movhi	r3,3
   2593c:	18cc9004 	addi	r3,r3,12864
   25940:	10801224 	muli	r2,r2,72
   25944:	1885883a 	add	r2,r3,r2
   25948:	10800504 	addi	r2,r2,20
   2594c:	10c00017 	ldw	r3,0(r2)
   25950:	e0bff717 	ldw	r2,-36(fp)
   25954:	10800017 	ldw	r2,0(r2)
   25958:	1809883a 	mov	r4,r3
   2595c:	100b883a 	mov	r5,r2
   25960:	002c1e40 	call	2c1e4 <strcpy>
		
		tse_mac_device[tse_system_count].tse_sgdma_rx = (char *) malloc(strlen(psgdma->tse_sgdma_rx) + 1);
   25964:	d0a8f7c3 	ldbu	r2,-23585(gp)
   25968:	14003fcc 	andi	r16,r2,255
   2596c:	8400201c 	xori	r16,r16,128
   25970:	843fe004 	addi	r16,r16,-128
   25974:	e0bff717 	ldw	r2,-36(fp)
   25978:	10800117 	ldw	r2,4(r2)
   2597c:	1009883a 	mov	r4,r2
   25980:	0016a080 	call	16a08 <strlen>
   25984:	10800044 	addi	r2,r2,1
   25988:	1009883a 	mov	r4,r2
   2598c:	002c1400 	call	2c140 <malloc>
   25990:	1007883a 	mov	r3,r2
   25994:	010000f4 	movhi	r4,3
   25998:	210c9004 	addi	r4,r4,12864
   2599c:	80801224 	muli	r2,r16,72
   259a0:	2085883a 	add	r2,r4,r2
   259a4:	10800604 	addi	r2,r2,24
   259a8:	10c00015 	stw	r3,0(r2)
	    if(!tse_mac_device[tse_system_count].tse_sgdma_rx) {
   259ac:	d0a8f7c3 	ldbu	r2,-23585(gp)
   259b0:	10803fcc 	andi	r2,r2,255
   259b4:	1080201c 	xori	r2,r2,128
   259b8:	10bfe004 	addi	r2,r2,-128
   259bc:	00c000f4 	movhi	r3,3
   259c0:	18cc9004 	addi	r3,r3,12864
   259c4:	10801224 	muli	r2,r2,72
   259c8:	1885883a 	add	r2,r3,r2
   259cc:	10800604 	addi	r2,r2,24
   259d0:	10800017 	ldw	r2,0(r2)
   259d4:	10000a1e 	bne	r2,zero,25a00 <alt_tse_system_add_sys+0x510>
	        tse_dprintf(1, "ERROR   : Unable to allocate memory for tse_mac_device[%d].tse_sgdma_rx\n", tse_system_count);
   259d8:	d0a8f7c3 	ldbu	r2,-23585(gp)
   259dc:	10803fcc 	andi	r2,r2,255
   259e0:	1080201c 	xori	r2,r2,128
   259e4:	10bfe004 	addi	r2,r2,-128
   259e8:	010000f4 	movhi	r4,3
   259ec:	213daf04 	addi	r4,r4,-2372
   259f0:	100b883a 	mov	r5,r2
   259f4:	0024fd00 	call	24fd0 <no_printf>
	        return ALTERA_TSE_MALLOC_FAILED;
   259f8:	00bfffc4 	movi	r2,-1
   259fc:	00013506 	br	25ed4 <alt_tse_system_add_sys+0x9e4>
	    }
	    strcpy(tse_mac_device[tse_system_count].tse_sgdma_rx, psgdma->tse_sgdma_rx);
   25a00:	d0a8f7c3 	ldbu	r2,-23585(gp)
   25a04:	10803fcc 	andi	r2,r2,255
   25a08:	1080201c 	xori	r2,r2,128
   25a0c:	10bfe004 	addi	r2,r2,-128
   25a10:	00c000f4 	movhi	r3,3
   25a14:	18cc9004 	addi	r3,r3,12864
   25a18:	10801224 	muli	r2,r2,72
   25a1c:	1885883a 	add	r2,r3,r2
   25a20:	10800604 	addi	r2,r2,24
   25a24:	10c00017 	ldw	r3,0(r2)
   25a28:	e0bff717 	ldw	r2,-36(fp)
   25a2c:	10800117 	ldw	r2,4(r2)
   25a30:	1809883a 	mov	r4,r3
   25a34:	100b883a 	mov	r5,r2
   25a38:	002c1e40 	call	2c1e4 <strcpy>
	    
		tse_mac_device[tse_system_count].tse_sgdma_rx_irq = psgdma->tse_sgdma_rx_irq;
   25a3c:	d0a8f7c3 	ldbu	r2,-23585(gp)
   25a40:	10803fcc 	andi	r2,r2,255
   25a44:	1080201c 	xori	r2,r2,128
   25a48:	10bfe004 	addi	r2,r2,-128
   25a4c:	e0fff717 	ldw	r3,-36(fp)
   25a50:	18c0020b 	ldhu	r3,8(r3)
   25a54:	010000f4 	movhi	r4,3
   25a58:	210c9004 	addi	r4,r4,12864
   25a5c:	10801224 	muli	r2,r2,72
   25a60:	2085883a 	add	r2,r4,r2
   25a64:	10800704 	addi	r2,r2,28
   25a68:	10c0000d 	sth	r3,0(r2)
		
		/* Add descriptor memory info to alt_tse_system_info structure */
		if(pmem == 0) {
   25a6c:	e0bff817 	ldw	r2,-32(fp)
   25a70:	1000151e 	bne	r2,zero,25ac8 <alt_tse_system_add_sys+0x5d8>
			tse_mac_device[tse_system_count].ext_desc_mem	= TSE_INT_DESC_MEM;
   25a74:	d0a8f7c3 	ldbu	r2,-23585(gp)
   25a78:	10803fcc 	andi	r2,r2,255
   25a7c:	1080201c 	xori	r2,r2,128
   25a80:	10bfe004 	addi	r2,r2,-128
   25a84:	00c000f4 	movhi	r3,3
   25a88:	18cc9004 	addi	r3,r3,12864
   25a8c:	10801224 	muli	r2,r2,72
   25a90:	1885883a 	add	r2,r3,r2
   25a94:	10800704 	addi	r2,r2,28
   25a98:	10000085 	stb	zero,2(r2)
			tse_mac_device[tse_system_count].desc_mem_base	= TSE_INT_DESC_MEM;
   25a9c:	d0a8f7c3 	ldbu	r2,-23585(gp)
   25aa0:	10803fcc 	andi	r2,r2,255
   25aa4:	1080201c 	xori	r2,r2,128
   25aa8:	10bfe004 	addi	r2,r2,-128
   25aac:	00c000f4 	movhi	r3,3
   25ab0:	18cc9004 	addi	r3,r3,12864
   25ab4:	10801224 	muli	r2,r2,72
   25ab8:	1885883a 	add	r2,r3,r2
   25abc:	10800804 	addi	r2,r2,32
   25ac0:	10000015 	stw	zero,0(r2)
   25ac4:	00001806 	br	25b28 <alt_tse_system_add_sys+0x638>
		}
		else {
			tse_mac_device[tse_system_count].ext_desc_mem	= pmem->ext_desc_mem;
   25ac8:	d0a8f7c3 	ldbu	r2,-23585(gp)
   25acc:	10803fcc 	andi	r2,r2,255
   25ad0:	1080201c 	xori	r2,r2,128
   25ad4:	10bfe004 	addi	r2,r2,-128
   25ad8:	e0fff817 	ldw	r3,-32(fp)
   25adc:	18c00003 	ldbu	r3,0(r3)
   25ae0:	010000f4 	movhi	r4,3
   25ae4:	210c9004 	addi	r4,r4,12864
   25ae8:	10801224 	muli	r2,r2,72
   25aec:	2085883a 	add	r2,r4,r2
   25af0:	10800704 	addi	r2,r2,28
   25af4:	10c00085 	stb	r3,2(r2)
			tse_mac_device[tse_system_count].desc_mem_base	= pmem->desc_mem_base;
   25af8:	d0a8f7c3 	ldbu	r2,-23585(gp)
   25afc:	10803fcc 	andi	r2,r2,255
   25b00:	1080201c 	xori	r2,r2,128
   25b04:	10bfe004 	addi	r2,r2,-128
   25b08:	e0fff817 	ldw	r3,-32(fp)
   25b0c:	18c00117 	ldw	r3,4(r3)
   25b10:	010000f4 	movhi	r4,3
   25b14:	210c9004 	addi	r4,r4,12864
   25b18:	10801224 	muli	r2,r2,72
   25b1c:	2085883a 	add	r2,r4,r2
   25b20:	10800804 	addi	r2,r2,32
   25b24:	10c00015 	stw	r3,0(r2)
		}
		
		/* Add shared fifo info to alt_tse_system_info structure */
		if(pfifo == 0) {
   25b28:	e0bff917 	ldw	r2,-28(fp)
   25b2c:	1000471e 	bne	r2,zero,25c4c <alt_tse_system_add_sys+0x75c>
			tse_mac_device[tse_system_count].use_shared_fifo                = TSE_NO_SHARED_FIFO;
   25b30:	d0a8f7c3 	ldbu	r2,-23585(gp)
   25b34:	10803fcc 	andi	r2,r2,255
   25b38:	1080201c 	xori	r2,r2,128
   25b3c:	10bfe004 	addi	r2,r2,-128
   25b40:	00c000f4 	movhi	r3,3
   25b44:	18cc9004 	addi	r3,r3,12864
   25b48:	10801224 	muli	r2,r2,72
   25b4c:	1885883a 	add	r2,r3,r2
   25b50:	10800904 	addi	r2,r2,36
   25b54:	10000005 	stb	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_ctrl_base	= TSE_NO_SHARED_FIFO;
   25b58:	d0a8f7c3 	ldbu	r2,-23585(gp)
   25b5c:	10803fcc 	andi	r2,r2,255
   25b60:	1080201c 	xori	r2,r2,128
   25b64:	10bfe004 	addi	r2,r2,-128
   25b68:	00c000f4 	movhi	r3,3
   25b6c:	18cc9004 	addi	r3,r3,12864
   25b70:	10801224 	muli	r2,r2,72
   25b74:	1885883a 	add	r2,r3,r2
   25b78:	10800a04 	addi	r2,r2,40
   25b7c:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_stat_base	= TSE_NO_SHARED_FIFO;
   25b80:	d0a8f7c3 	ldbu	r2,-23585(gp)
   25b84:	10803fcc 	andi	r2,r2,255
   25b88:	1080201c 	xori	r2,r2,128
   25b8c:	10bfe004 	addi	r2,r2,-128
   25b90:	00c000f4 	movhi	r3,3
   25b94:	18cc9004 	addi	r3,r3,12864
   25b98:	10801224 	muli	r2,r2,72
   25b9c:	1885883a 	add	r2,r3,r2
   25ba0:	10800b04 	addi	r2,r2,44
   25ba4:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_depth       = TSE_NO_SHARED_FIFO;
   25ba8:	d0a8f7c3 	ldbu	r2,-23585(gp)
   25bac:	10803fcc 	andi	r2,r2,255
   25bb0:	1080201c 	xori	r2,r2,128
   25bb4:	10bfe004 	addi	r2,r2,-128
   25bb8:	00c000f4 	movhi	r3,3
   25bbc:	18cc9004 	addi	r3,r3,12864
   25bc0:	10801224 	muli	r2,r2,72
   25bc4:	1885883a 	add	r2,r3,r2
   25bc8:	10800c04 	addi	r2,r2,48
   25bcc:	10000015 	stw	zero,0(r2)
			
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_ctrl_base	= TSE_NO_SHARED_FIFO;
   25bd0:	d0a8f7c3 	ldbu	r2,-23585(gp)
   25bd4:	10803fcc 	andi	r2,r2,255
   25bd8:	1080201c 	xori	r2,r2,128
   25bdc:	10bfe004 	addi	r2,r2,-128
   25be0:	00c000f4 	movhi	r3,3
   25be4:	18cc9004 	addi	r3,r3,12864
   25be8:	10801224 	muli	r2,r2,72
   25bec:	1885883a 	add	r2,r3,r2
   25bf0:	10800d04 	addi	r2,r2,52
   25bf4:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_stat_base	= TSE_NO_SHARED_FIFO;
   25bf8:	d0a8f7c3 	ldbu	r2,-23585(gp)
   25bfc:	10803fcc 	andi	r2,r2,255
   25c00:	1080201c 	xori	r2,r2,128
   25c04:	10bfe004 	addi	r2,r2,-128
   25c08:	00c000f4 	movhi	r3,3
   25c0c:	18cc9004 	addi	r3,r3,12864
   25c10:	10801224 	muli	r2,r2,72
   25c14:	1885883a 	add	r2,r3,r2
   25c18:	10800e04 	addi	r2,r2,56
   25c1c:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_depth       = TSE_NO_SHARED_FIFO;
   25c20:	d0a8f7c3 	ldbu	r2,-23585(gp)
   25c24:	10803fcc 	andi	r2,r2,255
   25c28:	1080201c 	xori	r2,r2,128
   25c2c:	10bfe004 	addi	r2,r2,-128
   25c30:	00c000f4 	movhi	r3,3
   25c34:	18cc9004 	addi	r3,r3,12864
   25c38:	10801224 	muli	r2,r2,72
   25c3c:	1885883a 	add	r2,r3,r2
   25c40:	10800f04 	addi	r2,r2,60
   25c44:	10000015 	stw	zero,0(r2)
   25c48:	00005406 	br	25d9c <alt_tse_system_add_sys+0x8ac>
		}
		else {
			tse_mac_device[tse_system_count].use_shared_fifo                = pfifo->use_shared_fifo;
   25c4c:	d0a8f7c3 	ldbu	r2,-23585(gp)
   25c50:	10803fcc 	andi	r2,r2,255
   25c54:	1080201c 	xori	r2,r2,128
   25c58:	10bfe004 	addi	r2,r2,-128
   25c5c:	e0fff917 	ldw	r3,-28(fp)
   25c60:	18c00003 	ldbu	r3,0(r3)
   25c64:	010000f4 	movhi	r4,3
   25c68:	210c9004 	addi	r4,r4,12864
   25c6c:	10801224 	muli	r2,r2,72
   25c70:	2085883a 	add	r2,r4,r2
   25c74:	10800904 	addi	r2,r2,36
   25c78:	10c00005 	stb	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_ctrl_base	= pfifo->tse_shared_fifo_tx_ctrl_base;
   25c7c:	d0a8f7c3 	ldbu	r2,-23585(gp)
   25c80:	10803fcc 	andi	r2,r2,255
   25c84:	1080201c 	xori	r2,r2,128
   25c88:	10bfe004 	addi	r2,r2,-128
   25c8c:	e0fff917 	ldw	r3,-28(fp)
   25c90:	18c00117 	ldw	r3,4(r3)
   25c94:	010000f4 	movhi	r4,3
   25c98:	210c9004 	addi	r4,r4,12864
   25c9c:	10801224 	muli	r2,r2,72
   25ca0:	2085883a 	add	r2,r4,r2
   25ca4:	10800a04 	addi	r2,r2,40
   25ca8:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_stat_base	= pfifo->tse_shared_fifo_tx_stat_base;
   25cac:	d0a8f7c3 	ldbu	r2,-23585(gp)
   25cb0:	10803fcc 	andi	r2,r2,255
   25cb4:	1080201c 	xori	r2,r2,128
   25cb8:	10bfe004 	addi	r2,r2,-128
   25cbc:	e0fff917 	ldw	r3,-28(fp)
   25cc0:	18c00217 	ldw	r3,8(r3)
   25cc4:	010000f4 	movhi	r4,3
   25cc8:	210c9004 	addi	r4,r4,12864
   25ccc:	10801224 	muli	r2,r2,72
   25cd0:	2085883a 	add	r2,r4,r2
   25cd4:	10800b04 	addi	r2,r2,44
   25cd8:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_depth       = pfifo->tse_shared_fifo_tx_depth;
   25cdc:	d0a8f7c3 	ldbu	r2,-23585(gp)
   25ce0:	10803fcc 	andi	r2,r2,255
   25ce4:	1080201c 	xori	r2,r2,128
   25ce8:	10bfe004 	addi	r2,r2,-128
   25cec:	e0fff917 	ldw	r3,-28(fp)
   25cf0:	18c00317 	ldw	r3,12(r3)
   25cf4:	010000f4 	movhi	r4,3
   25cf8:	210c9004 	addi	r4,r4,12864
   25cfc:	10801224 	muli	r2,r2,72
   25d00:	2085883a 	add	r2,r4,r2
   25d04:	10800c04 	addi	r2,r2,48
   25d08:	10c00015 	stw	r3,0(r2)
			
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_ctrl_base	= pfifo->tse_shared_fifo_rx_ctrl_base;
   25d0c:	d0a8f7c3 	ldbu	r2,-23585(gp)
   25d10:	10803fcc 	andi	r2,r2,255
   25d14:	1080201c 	xori	r2,r2,128
   25d18:	10bfe004 	addi	r2,r2,-128
   25d1c:	e0fff917 	ldw	r3,-28(fp)
   25d20:	18c00417 	ldw	r3,16(r3)
   25d24:	010000f4 	movhi	r4,3
   25d28:	210c9004 	addi	r4,r4,12864
   25d2c:	10801224 	muli	r2,r2,72
   25d30:	2085883a 	add	r2,r4,r2
   25d34:	10800d04 	addi	r2,r2,52
   25d38:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_stat_base	= pfifo->tse_shared_fifo_rx_stat_base;
   25d3c:	d0a8f7c3 	ldbu	r2,-23585(gp)
   25d40:	10803fcc 	andi	r2,r2,255
   25d44:	1080201c 	xori	r2,r2,128
   25d48:	10bfe004 	addi	r2,r2,-128
   25d4c:	e0fff917 	ldw	r3,-28(fp)
   25d50:	18c00517 	ldw	r3,20(r3)
   25d54:	010000f4 	movhi	r4,3
   25d58:	210c9004 	addi	r4,r4,12864
   25d5c:	10801224 	muli	r2,r2,72
   25d60:	2085883a 	add	r2,r4,r2
   25d64:	10800e04 	addi	r2,r2,56
   25d68:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_depth       = pfifo->tse_shared_fifo_rx_depth;
   25d6c:	d0a8f7c3 	ldbu	r2,-23585(gp)
   25d70:	10803fcc 	andi	r2,r2,255
   25d74:	1080201c 	xori	r2,r2,128
   25d78:	10bfe004 	addi	r2,r2,-128
   25d7c:	e0fff917 	ldw	r3,-28(fp)
   25d80:	18c00617 	ldw	r3,24(r3)
   25d84:	010000f4 	movhi	r4,3
   25d88:	210c9004 	addi	r4,r4,12864
   25d8c:	10801224 	muli	r2,r2,72
   25d90:	2085883a 	add	r2,r4,r2
   25d94:	10800f04 	addi	r2,r2,60
   25d98:	10c00015 	stw	r3,0(r2)
		}
		
		/* Add PHY info to alt_tse_system_info structure */
		if(pphy == 0) {
   25d9c:	e0bffa17 	ldw	r2,-24(fp)
   25da0:	1000161e 	bne	r2,zero,25dfc <alt_tse_system_add_sys+0x90c>
			tse_mac_device[tse_system_count].tse_phy_mdio_address	= TSE_PHY_AUTO_ADDRESS;
   25da4:	d0a8f7c3 	ldbu	r2,-23585(gp)
   25da8:	10803fcc 	andi	r2,r2,255
   25dac:	1080201c 	xori	r2,r2,128
   25db0:	10bfe004 	addi	r2,r2,-128
   25db4:	00c000f4 	movhi	r3,3
   25db8:	18cc9004 	addi	r3,r3,12864
   25dbc:	10801224 	muli	r2,r2,72
   25dc0:	1885883a 	add	r2,r3,r2
   25dc4:	10801004 	addi	r2,r2,64
   25dc8:	00ffffc4 	movi	r3,-1
   25dcc:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_phy_cfg 			= 0;
   25dd0:	d0a8f7c3 	ldbu	r2,-23585(gp)
   25dd4:	10803fcc 	andi	r2,r2,255
   25dd8:	1080201c 	xori	r2,r2,128
   25ddc:	10bfe004 	addi	r2,r2,-128
   25de0:	00c000f4 	movhi	r3,3
   25de4:	18cc9004 	addi	r3,r3,12864
   25de8:	10801224 	muli	r2,r2,72
   25dec:	1885883a 	add	r2,r3,r2
   25df0:	10801104 	addi	r2,r2,68
   25df4:	10000015 	stw	zero,0(r2)
   25df8:	00001806 	br	25e5c <alt_tse_system_add_sys+0x96c>
		}
		else {
			tse_mac_device[tse_system_count].tse_phy_mdio_address	= pphy->tse_phy_mdio_address;
   25dfc:	d0a8f7c3 	ldbu	r2,-23585(gp)
   25e00:	10803fcc 	andi	r2,r2,255
   25e04:	1080201c 	xori	r2,r2,128
   25e08:	10bfe004 	addi	r2,r2,-128
   25e0c:	e0fffa17 	ldw	r3,-24(fp)
   25e10:	18c00017 	ldw	r3,0(r3)
   25e14:	010000f4 	movhi	r4,3
   25e18:	210c9004 	addi	r4,r4,12864
   25e1c:	10801224 	muli	r2,r2,72
   25e20:	2085883a 	add	r2,r4,r2
   25e24:	10801004 	addi	r2,r2,64
   25e28:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_phy_cfg 			= pphy->tse_phy_cfg;
   25e2c:	d0a8f7c3 	ldbu	r2,-23585(gp)
   25e30:	10803fcc 	andi	r2,r2,255
   25e34:	1080201c 	xori	r2,r2,128
   25e38:	10bfe004 	addi	r2,r2,-128
   25e3c:	e0fffa17 	ldw	r3,-24(fp)
   25e40:	18c00117 	ldw	r3,4(r3)
   25e44:	010000f4 	movhi	r4,3
   25e48:	210c9004 	addi	r4,r4,12864
   25e4c:	10801224 	muli	r2,r2,72
   25e50:	2085883a 	add	r2,r4,r2
   25e54:	10801104 	addi	r2,r2,68
   25e58:	10c00015 	stw	r3,0(r2)
		}
		
		/* Point to next structure */
		psgdma++;
   25e5c:	e0bff717 	ldw	r2,-36(fp)
   25e60:	10800304 	addi	r2,r2,12
   25e64:	e0bff715 	stw	r2,-36(fp)
		if(pmem) pmem++;
   25e68:	e0bff817 	ldw	r2,-32(fp)
   25e6c:	10000326 	beq	r2,zero,25e7c <alt_tse_system_add_sys+0x98c>
   25e70:	e0bff817 	ldw	r2,-32(fp)
   25e74:	10800204 	addi	r2,r2,8
   25e78:	e0bff815 	stw	r2,-32(fp)
		if(pfifo) pfifo++;
   25e7c:	e0bff917 	ldw	r2,-28(fp)
   25e80:	10000326 	beq	r2,zero,25e90 <alt_tse_system_add_sys+0x9a0>
   25e84:	e0bff917 	ldw	r2,-28(fp)
   25e88:	10800704 	addi	r2,r2,28
   25e8c:	e0bff915 	stw	r2,-28(fp)
		if(pphy) pphy++;
   25e90:	e0bffa17 	ldw	r2,-24(fp)
   25e94:	10000326 	beq	r2,zero,25ea4 <alt_tse_system_add_sys+0x9b4>
   25e98:	e0bffa17 	ldw	r2,-24(fp)
   25e9c:	10800204 	addi	r2,r2,8
   25ea0:	e0bffa15 	stw	r2,-24(fp)
		
		tse_system_count++;
   25ea4:	d0a8f7c3 	ldbu	r2,-23585(gp)
   25ea8:	10800044 	addi	r2,r2,1
   25eac:	d0a8f7c5 	stb	r2,-23585(gp)
		max_mac_system = tse_system_count;
   25eb0:	d0a8f7c3 	ldbu	r2,-23585(gp)
   25eb4:	d0a01b05 	stb	r2,-32660(gp)
	else {
		tse_dprintf(2, "ERROR   : Invalid number of channel specified!\n");
		return ALTERA_TSE_SYSTEM_DEF_ERROR;
	}

	for(i = 0; i < loop_end; i++) {
   25eb8:	e0bff517 	ldw	r2,-44(fp)
   25ebc:	10800044 	addi	r2,r2,1
   25ec0:	e0bff515 	stw	r2,-44(fp)
   25ec4:	e0fff517 	ldw	r3,-44(fp)
   25ec8:	e0bff617 	ldw	r2,-40(fp)
   25ecc:	18bdb216 	blt	r3,r2,25598 <alt_tse_system_add_sys+0xa8>
		
		tse_system_count++;
		max_mac_system = tse_system_count;
	}
	
	return SUCCESS;
   25ed0:	0005883a 	mov	r2,zero
	
}
   25ed4:	e037883a 	mov	sp,fp
   25ed8:	dfc00217 	ldw	ra,8(sp)
   25edc:	df000117 	ldw	fp,4(sp)
   25ee0:	dc000017 	ldw	r16,0(sp)
   25ee4:	dec00304 	addi	sp,sp,12
   25ee8:	f800283a 	ret

00025eec <alt_tse_sys_enable_mdio_sharing>:
 * @param		number_of_mac  number of MAC sharing MDIO block
 * @return      SUCCESS on success
 * 				ALTERA_TSE_SYSTEM_DEF_ERROR if definition of system incorrect or pointer == NULL
 * Multi-channel MAC not supported
 */
alt_32 alt_tse_sys_enable_mdio_sharing(alt_tse_system_mac **psys_mac_list, alt_u8 number_of_mac) {
   25eec:	defff904 	addi	sp,sp,-28
   25ef0:	dfc00615 	stw	ra,24(sp)
   25ef4:	df000515 	stw	fp,20(sp)
   25ef8:	df000504 	addi	fp,sp,20
   25efc:	e13ffe15 	stw	r4,-8(fp)
   25f00:	2805883a 	mov	r2,r5
   25f04:	e0bfff05 	stb	r2,-4(fp)
	alt_32 i;
	alt_32 j;
	
	alt_tse_system_mac *psys_mac;
	
	for(i = 0; i < number_of_mac; i++) {
   25f08:	e03ffb15 	stw	zero,-20(fp)
   25f0c:	00004706 	br	2602c <alt_tse_sys_enable_mdio_sharing+0x140>
		psys_mac = psys_mac_list[i];
   25f10:	e0bffb17 	ldw	r2,-20(fp)
   25f14:	1085883a 	add	r2,r2,r2
   25f18:	1085883a 	add	r2,r2,r2
   25f1c:	e0fffe17 	ldw	r3,-8(fp)
   25f20:	1885883a 	add	r2,r3,r2
   25f24:	10800017 	ldw	r2,0(r2)
   25f28:	e0bffd15 	stw	r2,-12(fp)
		
		if(psys_mac == 0) {
   25f2c:	e0bffd17 	ldw	r2,-12(fp)
   25f30:	1000081e 	bne	r2,zero,25f54 <alt_tse_sys_enable_mdio_sharing+0x68>
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
   25f34:	010000f4 	movhi	r4,3
   25f38:	213d5d04 	addi	r4,r4,-2700
   25f3c:	0024fd00 	call	24fd0 <no_printf>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_sys_enable_mdio_sharing()\n");
   25f40:	010000f4 	movhi	r4,3
   25f44:	213dc204 	addi	r4,r4,-2296
   25f48:	0024fd00 	call	24fd0 <no_printf>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
   25f4c:	00bfffc4 	movi	r2,-1
   25f50:	00003a06 	br	2603c <alt_tse_sys_enable_mdio_sharing+0x150>
		}
		
		for(j = 0; j < max_mac_system; j++) {
   25f54:	e03ffc15 	stw	zero,-16(fp)
   25f58:	00002d06 	br	26010 <alt_tse_sys_enable_mdio_sharing+0x124>
			
			if(psys_mac->tse_mac_base == tse_mac_device[j].tse_mac_base) {
   25f5c:	e0bffd17 	ldw	r2,-12(fp)
   25f60:	10c00017 	ldw	r3,0(r2)
   25f64:	010000f4 	movhi	r4,3
   25f68:	210c9004 	addi	r4,r4,12864
   25f6c:	e0bffc17 	ldw	r2,-16(fp)
   25f70:	10801224 	muli	r2,r2,72
   25f74:	2085883a 	add	r2,r4,r2
   25f78:	10800017 	ldw	r2,0(r2)
   25f7c:	1880211e 	bne	r3,r2,26004 <alt_tse_sys_enable_mdio_sharing+0x118>
				if(tse_mac_device[j].tse_multichannel_mac) {
   25f80:	00c000f4 	movhi	r3,3
   25f84:	18cc9004 	addi	r3,r3,12864
   25f88:	e0bffc17 	ldw	r2,-16(fp)
   25f8c:	10801224 	muli	r2,r2,72
   25f90:	1885883a 	add	r2,r3,r2
   25f94:	10800204 	addi	r2,r2,8
   25f98:	108000c3 	ldbu	r2,3(r2)
   25f9c:	10803fcc 	andi	r2,r2,255
   25fa0:	10000826 	beq	r2,zero,25fc4 <alt_tse_sys_enable_mdio_sharing+0xd8>
					tse_dprintf(2, "ERROR   : MDIO sharing supported by default for Multi-channel MAC\n");
   25fa4:	010000f4 	movhi	r4,3
   25fa8:	213dd604 	addi	r4,r4,-2216
   25fac:	0024fd00 	call	24fd0 <no_printf>
					tse_dprintf(2, "ERROR   : Do not include Multi-channel MAC in the MAC List\n");
   25fb0:	010000f4 	movhi	r4,3
   25fb4:	213de704 	addi	r4,r4,-2148
   25fb8:	0024fd00 	call	24fd0 <no_printf>
					return ALTERA_TSE_SYSTEM_DEF_ERROR;
   25fbc:	00bfffc4 	movi	r2,-1
   25fc0:	00001e06 	br	2603c <alt_tse_sys_enable_mdio_sharing+0x150>
				}
				
				tse_mac_device[j].tse_mdio_shared = 1;
   25fc4:	00c000f4 	movhi	r3,3
   25fc8:	18cc9004 	addi	r3,r3,12864
   25fcc:	e0bffc17 	ldw	r2,-16(fp)
   25fd0:	10801224 	muli	r2,r2,72
   25fd4:	1885883a 	add	r2,r3,r2
   25fd8:	10800304 	addi	r2,r2,12
   25fdc:	00c00044 	movi	r3,1
   25fe0:	10c00045 	stb	r3,1(r2)
				tse_mac_device[j].tse_number_of_mac_mdio_shared = number_of_mac;
   25fe4:	00c000f4 	movhi	r3,3
   25fe8:	18cc9004 	addi	r3,r3,12864
   25fec:	e0bffc17 	ldw	r2,-16(fp)
   25ff0:	10801224 	muli	r2,r2,72
   25ff4:	1885883a 	add	r2,r3,r2
   25ff8:	10800304 	addi	r2,r2,12
   25ffc:	e0ffff03 	ldbu	r3,-4(fp)
   26000:	10c00085 	stb	r3,2(r2)
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_sys_enable_mdio_sharing()\n");
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
		}
		
		for(j = 0; j < max_mac_system; j++) {
   26004:	e0bffc17 	ldw	r2,-16(fp)
   26008:	10800044 	addi	r2,r2,1
   2600c:	e0bffc15 	stw	r2,-16(fp)
   26010:	d0a01b03 	ldbu	r2,-32660(gp)
   26014:	10803fcc 	andi	r2,r2,255
   26018:	e0fffc17 	ldw	r3,-16(fp)
   2601c:	18bfcf16 	blt	r3,r2,25f5c <alt_tse_sys_enable_mdio_sharing+0x70>
	alt_32 i;
	alt_32 j;
	
	alt_tse_system_mac *psys_mac;
	
	for(i = 0; i < number_of_mac; i++) {
   26020:	e0bffb17 	ldw	r2,-20(fp)
   26024:	10800044 	addi	r2,r2,1
   26028:	e0bffb15 	stw	r2,-20(fp)
   2602c:	e0bfff03 	ldbu	r2,-4(fp)
   26030:	e0fffb17 	ldw	r3,-20(fp)
   26034:	18bfb616 	blt	r3,r2,25f10 <alt_tse_sys_enable_mdio_sharing+0x24>
				tse_mac_device[j].tse_number_of_mac_mdio_shared = number_of_mac;
			}
		}	
	}
	
	return SUCCESS;
   26038:	0005883a 	mov	r2,zero
}
   2603c:	e037883a 	mov	sp,fp
   26040:	dfc00117 	ldw	ra,4(sp)
   26044:	df000017 	ldw	fp,0(sp)
   26048:	dec00204 	addi	sp,sp,8
   2604c:	f800283a 	ret

00026050 <alt_tse_mac_get_common_speed>:
/* @Function Description: Get the common speed supported by all PHYs connected to the MAC within the same group
 * @API Type:           Public
 * @param pmac          Pointer to the TSE MAC Control Interface Base address
 * @return              common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if no common speed found
 */
alt_32 alt_tse_mac_get_common_speed(np_tse_mac *pmac) {
   26050:	defffc04 	addi	sp,sp,-16
   26054:	dfc00315 	stw	ra,12(sp)
   26058:	df000215 	stw	fp,8(sp)
   2605c:	df000204 	addi	fp,sp,8
   26060:	e13fff15 	stw	r4,-4(fp)
    alt_tse_mac_group *pmac_group = alt_tse_get_mac_info(pmac)->pmac_group;
   26064:	e13fff17 	ldw	r4,-4(fp)
   26068:	00262380 	call	26238 <alt_tse_get_mac_info>
   2606c:	10800317 	ldw	r2,12(r2)
   26070:	e0bffe15 	stw	r2,-8(fp)
    return alt_tse_phy_get_common_speed(pmac_group);
   26074:	e13ffe17 	ldw	r4,-8(fp)
   26078:	00293d00 	call	293d0 <alt_tse_phy_get_common_speed>
}
   2607c:	e037883a 	mov	sp,fp
   26080:	dfc00117 	ldw	ra,4(sp)
   26084:	df000017 	ldw	fp,0(sp)
   26088:	dec00204 	addi	sp,sp,8
   2608c:	f800283a 	ret

00026090 <alt_tse_mac_set_common_speed>:
 * @API Type:               Public
 * @param pmac              Pointer to the TSE MAC Control Interface Base address
 *        common_speed      common speed supported by all PHYs
 * @return                  common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if invalid common speed specified
 */
alt_32 alt_tse_mac_set_common_speed(np_tse_mac *pmac, alt_32 common_speed) {
   26090:	defffb04 	addi	sp,sp,-20
   26094:	dfc00415 	stw	ra,16(sp)
   26098:	df000315 	stw	fp,12(sp)
   2609c:	df000304 	addi	fp,sp,12
   260a0:	e13ffe15 	stw	r4,-8(fp)
   260a4:	e17fff15 	stw	r5,-4(fp)
    alt_tse_mac_group *pmac_group = alt_tse_get_mac_info(pmac)->pmac_group;
   260a8:	e13ffe17 	ldw	r4,-8(fp)
   260ac:	00262380 	call	26238 <alt_tse_get_mac_info>
   260b0:	10800317 	ldw	r2,12(r2)
   260b4:	e0bffd15 	stw	r2,-12(fp)
    return alt_tse_phy_set_common_speed(pmac_group, common_speed);
   260b8:	e13ffd17 	ldw	r4,-12(fp)
   260bc:	e17fff17 	ldw	r5,-4(fp)
   260c0:	00296f80 	call	296f8 <alt_tse_phy_set_common_speed>
}
   260c4:	e037883a 	mov	sp,fp
   260c8:	dfc00117 	ldw	ra,4(sp)
   260cc:	df000017 	ldw	fp,0(sp)
   260d0:	dec00204 	addi	sp,sp,8
   260d4:	f800283a 	ret

000260d8 <alt_tse_get_system_index>:
/* @Function Description: Get the index of alt_tse_system_info structure in tse_mac_device[]
 * @API Type:        Internal
 * @param psys_info  Pointer to the alt_tse_system_info structure
 * @return           Index of alt_tse_system_info structure in tse_mac_device[]
 */
alt_32 alt_tse_get_system_index(alt_tse_system_info *psys_info) {
   260d8:	defffd04 	addi	sp,sp,-12
   260dc:	df000215 	stw	fp,8(sp)
   260e0:	df000204 	addi	fp,sp,8
   260e4:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
    
    for(i = 0; i < max_mac_system; i++) {
   260e8:	e03ffe15 	stw	zero,-8(fp)
   260ec:	00000c06 	br	26120 <alt_tse_get_system_index+0x48>
        if(psys_info == &tse_mac_device[i]) {
   260f0:	e0bffe17 	ldw	r2,-8(fp)
   260f4:	10c01224 	muli	r3,r2,72
   260f8:	008000f4 	movhi	r2,3
   260fc:	108c9004 	addi	r2,r2,12864
   26100:	1887883a 	add	r3,r3,r2
   26104:	e0bfff17 	ldw	r2,-4(fp)
   26108:	1880021e 	bne	r3,r2,26114 <alt_tse_get_system_index+0x3c>
            return i;
   2610c:	e0bffe17 	ldw	r2,-8(fp)
   26110:	00000806 	br	26134 <alt_tse_get_system_index+0x5c>
 * @return           Index of alt_tse_system_info structure in tse_mac_device[]
 */
alt_32 alt_tse_get_system_index(alt_tse_system_info *psys_info) {
	alt_32 i;
    
    for(i = 0; i < max_mac_system; i++) {
   26114:	e0bffe17 	ldw	r2,-8(fp)
   26118:	10800044 	addi	r2,r2,1
   2611c:	e0bffe15 	stw	r2,-8(fp)
   26120:	d0a01b03 	ldbu	r2,-32660(gp)
   26124:	10803fcc 	andi	r2,r2,255
   26128:	e0fffe17 	ldw	r3,-8(fp)
   2612c:	18bff016 	blt	r3,r2,260f0 <alt_tse_get_system_index+0x18>
        if(psys_info == &tse_mac_device[i]) {
            return i;
        }
    }
    return ALTERA_TSE_NO_INDEX_FOUND;
   26130:	00bfffc4 	movi	r2,-1
}
   26134:	e037883a 	mov	sp,fp
   26138:	df000017 	ldw	fp,0(sp)
   2613c:	dec00104 	addi	sp,sp,4
   26140:	f800283a 	ret

00026144 <alt_tse_get_mac_group_index>:
/* @Function Description: Get the index of alt_tse_mac_group structure in pmac_groups[]
 * @API Type:         Internal
 * @param pmac_group  Pointer to the alt_tse_mac_group structure
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
   26144:	defffd04 	addi	sp,sp,-12
   26148:	df000215 	stw	fp,8(sp)
   2614c:	df000204 	addi	fp,sp,8
   26150:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
   26154:	e03ffe15 	stw	zero,-8(fp)
   26158:	00000e06 	br	26194 <alt_tse_get_mac_group_index+0x50>
        if(pmac_group == pmac_groups[i]) {
   2615c:	00c00134 	movhi	r3,4
   26160:	18cde804 	addi	r3,r3,14240
   26164:	e0bffe17 	ldw	r2,-8(fp)
   26168:	1085883a 	add	r2,r2,r2
   2616c:	1085883a 	add	r2,r2,r2
   26170:	1885883a 	add	r2,r3,r2
   26174:	10c00017 	ldw	r3,0(r2)
   26178:	e0bfff17 	ldw	r2,-4(fp)
   2617c:	1880021e 	bne	r3,r2,26188 <alt_tse_get_mac_group_index+0x44>
            return i;
   26180:	e0bffe17 	ldw	r2,-8(fp)
   26184:	00000806 	br	261a8 <alt_tse_get_mac_group_index+0x64>
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
   26188:	e0bffe17 	ldw	r2,-8(fp)
   2618c:	10800044 	addi	r2,r2,1
   26190:	e0bffe15 	stw	r2,-8(fp)
   26194:	d0a8f743 	ldbu	r2,-23587(gp)
   26198:	10803fcc 	andi	r2,r2,255
   2619c:	e0fffe17 	ldw	r3,-8(fp)
   261a0:	18bfee16 	blt	r3,r2,2615c <alt_tse_get_mac_group_index+0x18>
        if(pmac_group == pmac_groups[i]) {
            return i;
        }
    }
    return ALTERA_TSE_NO_INDEX_FOUND;
   261a4:	00bfffc4 	movi	r2,-1
}
   261a8:	e037883a 	mov	sp,fp
   261ac:	df000017 	ldw	fp,0(sp)
   261b0:	dec00104 	addi	sp,sp,4
   261b4:	f800283a 	ret

000261b8 <alt_tse_get_mac_info_index>:
/* @Function Description: Get the index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 * @API Type:         Internal
 * @param pmac_group  Pointer to the alt_tse_mac_info structure
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
   261b8:	defffd04 	addi	sp,sp,-12
   261bc:	df000215 	stw	fp,8(sp)
   261c0:	df000204 	addi	fp,sp,8
   261c4:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   261c8:	e03ffe15 	stw	zero,-8(fp)
   261cc:	00000f06 	br	2620c <alt_tse_get_mac_info_index+0x54>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
   261d0:	e0bfff17 	ldw	r2,-4(fp)
   261d4:	10c00317 	ldw	r3,12(r2)
   261d8:	e0bffe17 	ldw	r2,-8(fp)
   261dc:	10800044 	addi	r2,r2,1
   261e0:	1085883a 	add	r2,r2,r2
   261e4:	1085883a 	add	r2,r2,r2
   261e8:	1885883a 	add	r2,r3,r2
   261ec:	10c00017 	ldw	r3,0(r2)
   261f0:	e0bfff17 	ldw	r2,-4(fp)
   261f4:	1880021e 	bne	r3,r2,26200 <alt_tse_get_mac_info_index+0x48>
            return i;
   261f8:	e0bffe17 	ldw	r2,-8(fp)
   261fc:	00000a06 	br	26228 <alt_tse_get_mac_info_index+0x70>
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   26200:	e0bffe17 	ldw	r2,-8(fp)
   26204:	10800044 	addi	r2,r2,1
   26208:	e0bffe15 	stw	r2,-8(fp)
   2620c:	e0bfff17 	ldw	r2,-4(fp)
   26210:	10800317 	ldw	r2,12(r2)
   26214:	10800003 	ldbu	r2,0(r2)
   26218:	10803fcc 	andi	r2,r2,255
   2621c:	e0fffe17 	ldw	r3,-8(fp)
   26220:	18bfeb16 	blt	r3,r2,261d0 <alt_tse_get_mac_info_index+0x18>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
            return i;
        }
    }
    
    return ALTERA_TSE_NO_INDEX_FOUND;
   26224:	00bfffc4 	movi	r2,-1
}
   26228:	e037883a 	mov	sp,fp
   2622c:	df000017 	ldw	fp,0(sp)
   26230:	dec00104 	addi	sp,sp,4
   26234:	f800283a 	ret

00026238 <alt_tse_get_mac_info>:
/* @Function Description: Get the pointer of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 * @API Type:         Internal
 * @param pmac        Pointer to the TSE MAC Control Interface Base address
 * @return            Pointer to alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_tse_mac_info *alt_tse_get_mac_info(np_tse_mac *pmac) {
   26238:	defffa04 	addi	sp,sp,-24
   2623c:	df000515 	stw	fp,20(sp)
   26240:	df000504 	addi	fp,sp,20
   26244:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
	alt_32 j;
    alt_tse_mac_group *pmac_group = 0;
   26248:	e03ffd15 	stw	zero,-12(fp)
    alt_tse_mac_info *pmac_info = 0;
   2624c:	e03ffe15 	stw	zero,-8(fp)
    
    for(i = 0; i < mac_group_count; i++) {
   26250:	e03ffb15 	stw	zero,-20(fp)
   26254:	00002506 	br	262ec <alt_tse_get_mac_info+0xb4>
        pmac_group = pmac_groups[i];
   26258:	00c00134 	movhi	r3,4
   2625c:	18cde804 	addi	r3,r3,14240
   26260:	e0bffb17 	ldw	r2,-20(fp)
   26264:	1085883a 	add	r2,r2,r2
   26268:	1085883a 	add	r2,r2,r2
   2626c:	1885883a 	add	r2,r3,r2
   26270:	10800017 	ldw	r2,0(r2)
   26274:	e0bffd15 	stw	r2,-12(fp)
        for(j = 0; j < pmac_group->channel; j++) {
   26278:	e03ffc15 	stw	zero,-16(fp)
   2627c:	00001306 	br	262cc <alt_tse_get_mac_info+0x94>
            pmac_info = pmac_group->pmac_info[j];
   26280:	e0fffd17 	ldw	r3,-12(fp)
   26284:	e0bffc17 	ldw	r2,-16(fp)
   26288:	10800044 	addi	r2,r2,1
   2628c:	1085883a 	add	r2,r2,r2
   26290:	1085883a 	add	r2,r2,r2
   26294:	1885883a 	add	r2,r3,r2
   26298:	10800017 	ldw	r2,0(r2)
   2629c:	e0bffe15 	stw	r2,-8(fp)
            if(((np_tse_mac *) pmac_info->psys_info->tse_mac_base) == pmac) {
   262a0:	e0bffe17 	ldw	r2,-8(fp)
   262a4:	10800217 	ldw	r2,8(r2)
   262a8:	10800017 	ldw	r2,0(r2)
   262ac:	1007883a 	mov	r3,r2
   262b0:	e0bfff17 	ldw	r2,-4(fp)
   262b4:	1880021e 	bne	r3,r2,262c0 <alt_tse_get_mac_info+0x88>
                return pmac_info;
   262b8:	e0bffe17 	ldw	r2,-8(fp)
   262bc:	00001006 	br	26300 <alt_tse_get_mac_info+0xc8>
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
        pmac_group = pmac_groups[i];
        for(j = 0; j < pmac_group->channel; j++) {
   262c0:	e0bffc17 	ldw	r2,-16(fp)
   262c4:	10800044 	addi	r2,r2,1
   262c8:	e0bffc15 	stw	r2,-16(fp)
   262cc:	e0bffd17 	ldw	r2,-12(fp)
   262d0:	10800003 	ldbu	r2,0(r2)
   262d4:	10803fcc 	andi	r2,r2,255
   262d8:	e0fffc17 	ldw	r3,-16(fp)
   262dc:	18bfe816 	blt	r3,r2,26280 <alt_tse_get_mac_info+0x48>
	alt_32 i;
	alt_32 j;
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
   262e0:	e0bffb17 	ldw	r2,-20(fp)
   262e4:	10800044 	addi	r2,r2,1
   262e8:	e0bffb15 	stw	r2,-20(fp)
   262ec:	d0a8f743 	ldbu	r2,-23587(gp)
   262f0:	10803fcc 	andi	r2,r2,255
   262f4:	e0fffb17 	ldw	r3,-20(fp)
   262f8:	18bfd716 	blt	r3,r2,26258 <alt_tse_get_mac_info+0x20>
                return pmac_info;
            }
        }        
    }
    
    return 0;
   262fc:	0005883a 	mov	r2,zero
}
   26300:	e037883a 	mov	sp,fp
   26304:	df000017 	ldw	fp,0(sp)
   26308:	dec00104 	addi	sp,sp,4
   2630c:	f800283a 	ret

00026310 <alt_tse_mac_set_speed>:
 * @param pmac  Pointer to the TSE MAC Control Interface Base address
 * @param speed 2 = 1000 Mbps, 1 = 100 Mbps, 0 = 10 Mbps
 * @return ENP_PARAM if invalid speed specified, else return SUCCESS
 */
alt_32 alt_tse_mac_set_speed(np_tse_mac *pmac, alt_u8 speed)
{
   26310:	defffc04 	addi	sp,sp,-16
   26314:	df000315 	stw	fp,12(sp)
   26318:	df000304 	addi	fp,sp,12
   2631c:	e13ffe15 	stw	r4,-8(fp)
   26320:	2805883a 	mov	r2,r5
   26324:	e0bfff05 	stb	r2,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
   26328:	e0bffe17 	ldw	r2,-8(fp)
   2632c:	10800204 	addi	r2,r2,8
   26330:	10800037 	ldwio	r2,0(r2)
   26334:	e0bffd15 	stw	r2,-12(fp)
  
  /* 1000 Mbps */
  if(speed == TSE_PHY_SPEED_1000) {
   26338:	e0bfff03 	ldbu	r2,-4(fp)
   2633c:	10800098 	cmpnei	r2,r2,2
   26340:	1000091e 	bne	r2,zero,26368 <alt_tse_mac_set_speed+0x58>
    helpvar |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
   26344:	e0bffd17 	ldw	r2,-12(fp)
   26348:	10800214 	ori	r2,r2,8
   2634c:	e0bffd15 	stw	r2,-12(fp)
	helpvar &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
   26350:	e0fffd17 	ldw	r3,-12(fp)
   26354:	00bf8034 	movhi	r2,65024
   26358:	10bfffc4 	addi	r2,r2,-1
   2635c:	1884703a 	and	r2,r3,r2
   26360:	e0bffd15 	stw	r2,-12(fp)
   26364:	00001906 	br	263cc <alt_tse_mac_set_speed+0xbc>
  }
  /* 100 Mbps */
  else if(speed == TSE_PHY_SPEED_100) {
   26368:	e0bfff03 	ldbu	r2,-4(fp)
   2636c:	10800058 	cmpnei	r2,r2,1
   26370:	10000a1e 	bne	r2,zero,2639c <alt_tse_mac_set_speed+0x8c>
    helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
   26374:	e0fffd17 	ldw	r3,-12(fp)
   26378:	00bffdc4 	movi	r2,-9
   2637c:	1884703a 	and	r2,r3,r2
   26380:	e0bffd15 	stw	r2,-12(fp)
	helpvar &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
   26384:	e0fffd17 	ldw	r3,-12(fp)
   26388:	00bf8034 	movhi	r2,65024
   2638c:	10bfffc4 	addi	r2,r2,-1
   26390:	1884703a 	and	r2,r3,r2
   26394:	e0bffd15 	stw	r2,-12(fp)
   26398:	00000c06 	br	263cc <alt_tse_mac_set_speed+0xbc>
  }
  /* 10 Mbps */
  else if(speed == TSE_PHY_SPEED_10) {
   2639c:	e0bfff03 	ldbu	r2,-4(fp)
   263a0:	1000081e 	bne	r2,zero,263c4 <alt_tse_mac_set_speed+0xb4>
    helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
   263a4:	e0fffd17 	ldw	r3,-12(fp)
   263a8:	00bffdc4 	movi	r2,-9
   263ac:	1884703a 	and	r2,r3,r2
   263b0:	e0bffd15 	stw	r2,-12(fp)
	helpvar |= ALTERA_TSEMAC_CMD_ENA_10_MSK;
   263b4:	e0bffd17 	ldw	r2,-12(fp)
   263b8:	10808034 	orhi	r2,r2,512
   263bc:	e0bffd15 	stw	r2,-12(fp)
   263c0:	00000206 	br	263cc <alt_tse_mac_set_speed+0xbc>
  }  
  else {
    return ENP_PARAM;
   263c4:	00bffd84 	movi	r2,-10
   263c8:	00000506 	br	263e0 <alt_tse_mac_set_speed+0xd0>
  }
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac, helpvar);
   263cc:	e0bffe17 	ldw	r2,-8(fp)
   263d0:	10800204 	addi	r2,r2,8
   263d4:	e0fffd17 	ldw	r3,-12(fp)
   263d8:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
   263dc:	0005883a 	mov	r2,zero
}
   263e0:	e037883a 	mov	sp,fp
   263e4:	df000017 	ldw	fp,0(sp)
   263e8:	dec00104 	addi	sp,sp,4
   263ec:	f800283a 	ret

000263f0 <alt_tse_mac_set_duplex>:
 * @param pmac  Pointer to the TSE MAC Control Interface Base address
 * @param duplex 1 = Full Duplex, 0 = Half Duplex
 * @return ENP_PARAM if invalid duplex specified, else return SUCCESS
 */
alt_32 alt_tse_mac_set_duplex(np_tse_mac *pmac, alt_u8 duplex)
{
   263f0:	defffc04 	addi	sp,sp,-16
   263f4:	df000315 	stw	fp,12(sp)
   263f8:	df000304 	addi	fp,sp,12
   263fc:	e13ffe15 	stw	r4,-8(fp)
   26400:	2805883a 	mov	r2,r5
   26404:	e0bfff05 	stb	r2,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
   26408:	e0bffe17 	ldw	r2,-8(fp)
   2640c:	10800204 	addi	r2,r2,8
   26410:	10800037 	ldwio	r2,0(r2)
   26414:	e0bffd15 	stw	r2,-12(fp)
  
  /* Half Duplex */
  if(duplex == TSE_PHY_DUPLEX_HALF) {
   26418:	e0bfff03 	ldbu	r2,-4(fp)
   2641c:	1000041e 	bne	r2,zero,26430 <alt_tse_mac_set_duplex+0x40>
    helpvar |= ALTERA_TSEMAC_CMD_HD_ENA_MSK;
   26420:	e0bffd17 	ldw	r2,-12(fp)
   26424:	10810014 	ori	r2,r2,1024
   26428:	e0bffd15 	stw	r2,-12(fp)
   2642c:	00000a06 	br	26458 <alt_tse_mac_set_duplex+0x68>
  } 
  /* Full Duplex */
  else if(duplex == TSE_PHY_DUPLEX_FULL) {
   26430:	e0bfff03 	ldbu	r2,-4(fp)
   26434:	10800058 	cmpnei	r2,r2,1
   26438:	1000051e 	bne	r2,zero,26450 <alt_tse_mac_set_duplex+0x60>
    helpvar &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
   2643c:	e0fffd17 	ldw	r3,-12(fp)
   26440:	00beffc4 	movi	r2,-1025
   26444:	1884703a 	and	r2,r3,r2
   26448:	e0bffd15 	stw	r2,-12(fp)
   2644c:	00000206 	br	26458 <alt_tse_mac_set_duplex+0x68>
  }
  else {
    return ENP_PARAM;
   26450:	00bffd84 	movi	r2,-10
   26454:	00000506 	br	2646c <alt_tse_mac_set_duplex+0x7c>
  }
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac, helpvar);
   26458:	e0bffe17 	ldw	r2,-8(fp)
   2645c:	10800204 	addi	r2,r2,8
   26460:	e0fffd17 	ldw	r3,-12(fp)
   26464:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
   26468:	0005883a 	mov	r2,zero

}
   2646c:	e037883a 	mov	sp,fp
   26470:	df000017 	ldw	fp,0(sp)
   26474:	dec00104 	addi	sp,sp,4
   26478:	f800283a 	ret

0002647c <getPHYSpeed>:
  	(((speed == TSE_PHY_SPEED_1000) ? 1 : 0) << 1) |   \
	(((speed == TSE_PHY_SPEED_100) ? 1 : 0) << 2) |     \
	(((speed == TSE_PHY_SPEED_10) ? 1 : 0) << 3) |      \
	((speed == TSE_PHY_SPEED_INVALID) ? ALT_TSE_E_INVALID_SPEED : 0))
  
alt_32 getPHYSpeed(np_tse_mac *pmac) {
   2647c:	defff404 	addi	sp,sp,-48
   26480:	dfc00b15 	stw	ra,44(sp)
   26484:	df000a15 	stw	fp,40(sp)
   26488:	df000a04 	addi	fp,sp,40
   2648c:	e13fff15 	stw	r4,-4(fp)

	alt_u8 speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
   26490:	00800044 	movi	r2,1
   26494:	e0bff705 	stb	r2,-36(fp)
	alt_u8 duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;     /* 1 = full ; 0 = half*/
   26498:	00800044 	movi	r2,1
   2649c:	e0bff745 	stb	r2,-35(fp)
	alt_32 result = ALT_TSE_SPEED_DUPLEX(speed, duplex);
   264a0:	e0bff743 	ldbu	r2,-35(fp)
   264a4:	10c0004c 	andi	r3,r2,1
   264a8:	e0bff703 	ldbu	r2,-36(fp)
   264ac:	10800098 	cmpnei	r2,r2,2
   264b0:	1000021e 	bne	r2,zero,264bc <getPHYSpeed+0x40>
   264b4:	00800084 	movi	r2,2
   264b8:	00000106 	br	264c0 <getPHYSpeed+0x44>
   264bc:	0005883a 	mov	r2,zero
   264c0:	1886b03a 	or	r3,r3,r2
   264c4:	e0bff703 	ldbu	r2,-36(fp)
   264c8:	10800058 	cmpnei	r2,r2,1
   264cc:	1000021e 	bne	r2,zero,264d8 <getPHYSpeed+0x5c>
   264d0:	00800104 	movi	r2,4
   264d4:	00000106 	br	264dc <getPHYSpeed+0x60>
   264d8:	0005883a 	mov	r2,zero
   264dc:	1886b03a 	or	r3,r3,r2
   264e0:	e0bff703 	ldbu	r2,-36(fp)
   264e4:	1000021e 	bne	r2,zero,264f0 <getPHYSpeed+0x74>
   264e8:	00800204 	movi	r2,8
   264ec:	00000106 	br	264f4 <getPHYSpeed+0x78>
   264f0:	0005883a 	mov	r2,zero
   264f4:	1886b03a 	or	r3,r3,r2
   264f8:	e0bff703 	ldbu	r2,-36(fp)
   264fc:	108000d8 	cmpnei	r2,r2,3
   26500:	1000021e 	bne	r2,zero,2650c <getPHYSpeed+0x90>
   26504:	00800074 	movhi	r2,1
   26508:	00000106 	br	26510 <getPHYSpeed+0x94>
   2650c:	0005883a 	mov	r2,zero
   26510:	1884b03a 	or	r2,r3,r2
   26514:	e0bff815 	stw	r2,-32(fp)
    
    alt_tse_phy_info *pphy = 0;
   26518:	e03ff915 	stw	zero,-28(fp)
    alt_tse_mac_info *pmac_info = 0;
   2651c:	e03ffa15 	stw	zero,-24(fp)
    alt_tse_mac_group *pmac_group = 0;
   26520:	e03ffb15 	stw	zero,-20(fp)
    alt_tse_system_info *psys = 0;
   26524:	e03ffc15 	stw	zero,-16(fp)
    
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
   26528:	e03ffd05 	stb	zero,-12(fp)
    alt_8 mac_group_index = 0;
   2652c:	e03ffd45 	stb	zero,-11(fp)
    
    /* initialized PHYs only once */
    static alt_u8 is_init = 0;
    if(is_init == 0) {
   26530:	d0a8f783 	ldbu	r2,-23586(gp)
   26534:	10803fcc 	andi	r2,r2,255
   26538:	1000031e 	bne	r2,zero,26548 <getPHYSpeed+0xcc>
        alt_tse_phy_init();
   2653c:	00284500 	call	28450 <alt_tse_phy_init>
        is_init = 1;
   26540:	00800044 	movi	r2,1
   26544:	d0a8f785 	stb	r2,-23586(gp)
    }
    
    /* Look for pmac_group and pmac_info structure based on pmac or iface */
    pmac_info = alt_tse_get_mac_info(pmac);
   26548:	e13fff17 	ldw	r4,-4(fp)
   2654c:	00262380 	call	26238 <alt_tse_get_mac_info>
   26550:	e0bffa15 	stw	r2,-24(fp)
    
    if(pmac_info == 0) {
   26554:	e0bffa17 	ldw	r2,-24(fp)
   26558:	1000491e 	bne	r2,zero,26680 <getPHYSpeed+0x204>
        speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
   2655c:	00800044 	movi	r2,1
   26560:	e0bff705 	stb	r2,-36(fp)
        duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
   26564:	00800044 	movi	r2,1
   26568:	e0bff745 	stb	r2,-35(fp)
        result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PMAC_FOUND;
   2656c:	e0bff743 	ldbu	r2,-35(fp)
   26570:	10c0004c 	andi	r3,r2,1
   26574:	e0bff703 	ldbu	r2,-36(fp)
   26578:	10800098 	cmpnei	r2,r2,2
   2657c:	1000021e 	bne	r2,zero,26588 <getPHYSpeed+0x10c>
   26580:	00800084 	movi	r2,2
   26584:	00000106 	br	2658c <getPHYSpeed+0x110>
   26588:	0005883a 	mov	r2,zero
   2658c:	1886b03a 	or	r3,r3,r2
   26590:	e0bff703 	ldbu	r2,-36(fp)
   26594:	10800058 	cmpnei	r2,r2,1
   26598:	1000021e 	bne	r2,zero,265a4 <getPHYSpeed+0x128>
   2659c:	00800104 	movi	r2,4
   265a0:	00000106 	br	265a8 <getPHYSpeed+0x12c>
   265a4:	0005883a 	mov	r2,zero
   265a8:	1886b03a 	or	r3,r3,r2
   265ac:	e0bff703 	ldbu	r2,-36(fp)
   265b0:	1000021e 	bne	r2,zero,265bc <getPHYSpeed+0x140>
   265b4:	00800204 	movi	r2,8
   265b8:	00000106 	br	265c0 <getPHYSpeed+0x144>
   265bc:	0005883a 	mov	r2,zero
   265c0:	1886b03a 	or	r3,r3,r2
   265c4:	e0bff703 	ldbu	r2,-36(fp)
   265c8:	108000d8 	cmpnei	r2,r2,3
   265cc:	1000021e 	bne	r2,zero,265d8 <getPHYSpeed+0x15c>
   265d0:	00800074 	movhi	r2,1
   265d4:	00000106 	br	265dc <getPHYSpeed+0x160>
   265d8:	0005883a 	mov	r2,zero
   265dc:	1884b03a 	or	r2,r3,r2
   265e0:	10802034 	orhi	r2,r2,128
   265e4:	e0bff815 	stw	r2,-32(fp)
        tse_dprintf(2, "ERROR   : [getPHYSpeed] pmac not found from list of pmac_info[]! Speed = %s Mbps, Duplex = %s\n", speed == TSE_PHY_SPEED_1000 ? "1000" :
   265e8:	e0bff703 	ldbu	r2,-36(fp)
   265ec:	108000a0 	cmpeqi	r2,r2,2
   265f0:	10000f1e 	bne	r2,zero,26630 <getPHYSpeed+0x1b4>
   265f4:	e0bff703 	ldbu	r2,-36(fp)
   265f8:	10800060 	cmpeqi	r2,r2,1
   265fc:	1000081e 	bne	r2,zero,26620 <getPHYSpeed+0x1a4>
   26600:	e0bff703 	ldbu	r2,-36(fp)
   26604:	1000031e 	bne	r2,zero,26614 <getPHYSpeed+0x198>
   26608:	008000f4 	movhi	r2,3
   2660c:	10bdf604 	addi	r2,r2,-2088
   26610:	00000206 	br	2661c <getPHYSpeed+0x1a0>
   26614:	008000f4 	movhi	r2,3
   26618:	10bdf704 	addi	r2,r2,-2084
   2661c:	00000206 	br	26628 <getPHYSpeed+0x1ac>
   26620:	008000f4 	movhi	r2,3
   26624:	10bdf904 	addi	r2,r2,-2076
   26628:	1007883a 	mov	r3,r2
   2662c:	00000206 	br	26638 <getPHYSpeed+0x1bc>
   26630:	00c000f4 	movhi	r3,3
   26634:	18fdfa04 	addi	r3,r3,-2072
   26638:	e0bff743 	ldbu	r2,-35(fp)
   2663c:	10800058 	cmpnei	r2,r2,1
   26640:	1000031e 	bne	r2,zero,26650 <getPHYSpeed+0x1d4>
   26644:	008000f4 	movhi	r2,3
   26648:	10bdfc04 	addi	r2,r2,-2064
   2664c:	00000206 	br	26658 <getPHYSpeed+0x1dc>
   26650:	008000f4 	movhi	r2,3
   26654:	10bdfe04 	addi	r2,r2,-2056
   26658:	010000f4 	movhi	r4,3
   2665c:	213e0004 	addi	r4,r4,-2048
   26660:	180b883a 	mov	r5,r3
   26664:	100d883a 	mov	r6,r2
   26668:	0024fd00 	call	24fd0 <no_printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
        tse_dprintf(2, "ERROR   : [getPHYSpeed] Please define tse_mac_device[] correctly\n");
   2666c:	010000f4 	movhi	r4,3
   26670:	213e1804 	addi	r4,r4,-1952
   26674:	0024fd00 	call	24fd0 <no_printf>
        return result;
   26678:	e0bff817 	ldw	r2,-32(fp)
   2667c:	00021706 	br	26edc <getPHYSpeed+0xa60>
    }
    
    pphy = pmac_info->pphy_info;
   26680:	e0bffa17 	ldw	r2,-24(fp)
   26684:	10800117 	ldw	r2,4(r2)
   26688:	e0bff915 	stw	r2,-28(fp)
    pmac_group = pmac_info->pmac_group;
   2668c:	e0bffa17 	ldw	r2,-24(fp)
   26690:	10800317 	ldw	r2,12(r2)
   26694:	e0bffb15 	stw	r2,-20(fp)
    psys = pmac_info->psys_info;
   26698:	e0bffa17 	ldw	r2,-24(fp)
   2669c:	10800217 	ldw	r2,8(r2)
   266a0:	e0bffc15 	stw	r2,-16(fp)
    
    mac_info_index = alt_tse_get_mac_info_index(pmac_info);
   266a4:	e13ffa17 	ldw	r4,-24(fp)
   266a8:	00261b80 	call	261b8 <alt_tse_get_mac_info_index>
   266ac:	e0bffd05 	stb	r2,-12(fp)
    mac_group_index = alt_tse_get_mac_group_index(pmac_group);
   266b0:	e13ffb17 	ldw	r4,-20(fp)
   266b4:	00261440 	call	26144 <alt_tse_get_mac_group_index>
   266b8:	e0bffd45 	stb	r2,-11(fp)
         
    /* MDIO is not used */
    if (pmac_group->pmac_info[0]->psys_info->tse_use_mdio == 0)
   266bc:	e0bffb17 	ldw	r2,-20(fp)
   266c0:	10800117 	ldw	r2,4(r2)
   266c4:	10800217 	ldw	r2,8(r2)
   266c8:	10800203 	ldbu	r2,8(r2)
   266cc:	10803fcc 	andi	r2,r2,255
   266d0:	10005a1e 	bne	r2,zero,2683c <getPHYSpeed+0x3c0>
    {
        speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
   266d4:	00800044 	movi	r2,1
   266d8:	e0bff705 	stb	r2,-36(fp)
        duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
   266dc:	00800044 	movi	r2,1
   266e0:	e0bff745 	stb	r2,-35(fp)
        result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_MDIO;
   266e4:	e0bff743 	ldbu	r2,-35(fp)
   266e8:	10c0004c 	andi	r3,r2,1
   266ec:	e0bff703 	ldbu	r2,-36(fp)
   266f0:	10800098 	cmpnei	r2,r2,2
   266f4:	1000021e 	bne	r2,zero,26700 <getPHYSpeed+0x284>
   266f8:	00800084 	movi	r2,2
   266fc:	00000106 	br	26704 <getPHYSpeed+0x288>
   26700:	0005883a 	mov	r2,zero
   26704:	1886b03a 	or	r3,r3,r2
   26708:	e0bff703 	ldbu	r2,-36(fp)
   2670c:	10800058 	cmpnei	r2,r2,1
   26710:	1000021e 	bne	r2,zero,2671c <getPHYSpeed+0x2a0>
   26714:	00800104 	movi	r2,4
   26718:	00000106 	br	26720 <getPHYSpeed+0x2a4>
   2671c:	0005883a 	mov	r2,zero
   26720:	1886b03a 	or	r3,r3,r2
   26724:	e0bff703 	ldbu	r2,-36(fp)
   26728:	1000021e 	bne	r2,zero,26734 <getPHYSpeed+0x2b8>
   2672c:	00800204 	movi	r2,8
   26730:	00000106 	br	26738 <getPHYSpeed+0x2bc>
   26734:	0005883a 	mov	r2,zero
   26738:	1886b03a 	or	r3,r3,r2
   2673c:	e0bff703 	ldbu	r2,-36(fp)
   26740:	108000d8 	cmpnei	r2,r2,3
   26744:	1000021e 	bne	r2,zero,26750 <getPHYSpeed+0x2d4>
   26748:	00800074 	movhi	r2,1
   2674c:	00000106 	br	26754 <getPHYSpeed+0x2d8>
   26750:	0005883a 	mov	r2,zero
   26754:	1884b03a 	or	r2,r3,r2
   26758:	10801034 	orhi	r2,r2,64
   2675c:	e0bff815 	stw	r2,-32(fp)
        usleep(ALTERA_NOMDIO_TIMEOUT_THRESHOLD);
   26760:	010003f4 	movhi	r4,15
   26764:	21109004 	addi	r4,r4,16960
   26768:	002081c0 	call	2081c <usleep>
        if(psys->tse_phy_cfg) {
   2676c:	e0bffc17 	ldw	r2,-16(fp)
   26770:	10801117 	ldw	r2,68(r2)
   26774:	10000d26 	beq	r2,zero,267ac <getPHYSpeed+0x330>
        	tse_dprintf(4, "WARNING : PHY[%d.%d] - MDIO not enabled! Running user configuration...\n", mac_group_index, mac_info_index);
   26778:	e0fffd47 	ldb	r3,-11(fp)
   2677c:	e0bffd07 	ldb	r2,-12(fp)
   26780:	010000f4 	movhi	r4,3
   26784:	213e2904 	addi	r4,r4,-1884
   26788:	180b883a 	mov	r5,r3
   2678c:	100d883a 	mov	r6,r2
   26790:	0024fd00 	call	24fd0 <no_printf>
        	result = psys->tse_phy_cfg(pmac);
   26794:	e0bffc17 	ldw	r2,-16(fp)
   26798:	10801117 	ldw	r2,68(r2)
   2679c:	e13fff17 	ldw	r4,-4(fp)
   267a0:	103ee83a 	callr	r2
   267a4:	e0bff815 	stw	r2,-32(fp)
   267a8:	00002206 	br	26834 <getPHYSpeed+0x3b8>
        }
        else {
        	tse_dprintf(4, "WARNING : MAC Group[%d] - MDIO not enabled! Speed = %s, Duplex = %s\n", mac_group_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
   267ac:	e17ffd47 	ldb	r5,-11(fp)
   267b0:	e0bff703 	ldbu	r2,-36(fp)
   267b4:	108000a0 	cmpeqi	r2,r2,2
   267b8:	10000f1e 	bne	r2,zero,267f8 <getPHYSpeed+0x37c>
   267bc:	e0bff703 	ldbu	r2,-36(fp)
   267c0:	10800060 	cmpeqi	r2,r2,1
   267c4:	1000081e 	bne	r2,zero,267e8 <getPHYSpeed+0x36c>
   267c8:	e0bff703 	ldbu	r2,-36(fp)
   267cc:	1000031e 	bne	r2,zero,267dc <getPHYSpeed+0x360>
   267d0:	008000f4 	movhi	r2,3
   267d4:	10bdf604 	addi	r2,r2,-2088
   267d8:	00000206 	br	267e4 <getPHYSpeed+0x368>
   267dc:	008000f4 	movhi	r2,3
   267e0:	10bdf704 	addi	r2,r2,-2084
   267e4:	00000206 	br	267f0 <getPHYSpeed+0x374>
   267e8:	008000f4 	movhi	r2,3
   267ec:	10bdf904 	addi	r2,r2,-2076
   267f0:	1007883a 	mov	r3,r2
   267f4:	00000206 	br	26800 <getPHYSpeed+0x384>
   267f8:	00c000f4 	movhi	r3,3
   267fc:	18fdfa04 	addi	r3,r3,-2072
   26800:	e0bff743 	ldbu	r2,-35(fp)
   26804:	10800058 	cmpnei	r2,r2,1
   26808:	1000031e 	bne	r2,zero,26818 <getPHYSpeed+0x39c>
   2680c:	008000f4 	movhi	r2,3
   26810:	10bdfc04 	addi	r2,r2,-2064
   26814:	00000206 	br	26820 <getPHYSpeed+0x3a4>
   26818:	008000f4 	movhi	r2,3
   2681c:	10bdfe04 	addi	r2,r2,-2056
   26820:	010000f4 	movhi	r4,3
   26824:	213e3b04 	addi	r4,r4,-1812
   26828:	180d883a 	mov	r6,r3
   2682c:	100f883a 	mov	r7,r2
   26830:	0024fd00 	call	24fd0 <no_printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
        }
        return result;
   26834:	e0bff817 	ldw	r2,-32(fp)
   26838:	0001a806 	br	26edc <getPHYSpeed+0xa60>

    /* Not running simulation */
    #ifndef ALT_SIM_OPTIMIZE
	
		/* These variables declaration are here to avoid "warning: unused variable" message when compile for simulation */
		np_tse_mac *pmac_group_base = (np_tse_mac *) pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   2683c:	e0bffb17 	ldw	r2,-20(fp)
   26840:	10800117 	ldw	r2,4(r2)
   26844:	10800217 	ldw	r2,8(r2)
   26848:	10800017 	ldw	r2,0(r2)
   2684c:	e0bffe15 	stw	r2,-8(fp)
    
        /* if no PHY connected to the MAC */
        if(pphy == 0) {
   26850:	e0bff917 	ldw	r2,-28(fp)
   26854:	1000471e 	bne	r2,zero,26974 <getPHYSpeed+0x4f8>
            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
   26858:	00800044 	movi	r2,1
   2685c:	e0bff705 	stb	r2,-36(fp)
            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
   26860:	00800044 	movi	r2,1
   26864:	e0bff745 	stb	r2,-35(fp)
            result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PHY;
   26868:	e0bff743 	ldbu	r2,-35(fp)
   2686c:	10c0004c 	andi	r3,r2,1
   26870:	e0bff703 	ldbu	r2,-36(fp)
   26874:	10800098 	cmpnei	r2,r2,2
   26878:	1000021e 	bne	r2,zero,26884 <getPHYSpeed+0x408>
   2687c:	00800084 	movi	r2,2
   26880:	00000106 	br	26888 <getPHYSpeed+0x40c>
   26884:	0005883a 	mov	r2,zero
   26888:	1886b03a 	or	r3,r3,r2
   2688c:	e0bff703 	ldbu	r2,-36(fp)
   26890:	10800058 	cmpnei	r2,r2,1
   26894:	1000021e 	bne	r2,zero,268a0 <getPHYSpeed+0x424>
   26898:	00800104 	movi	r2,4
   2689c:	00000106 	br	268a4 <getPHYSpeed+0x428>
   268a0:	0005883a 	mov	r2,zero
   268a4:	1886b03a 	or	r3,r3,r2
   268a8:	e0bff703 	ldbu	r2,-36(fp)
   268ac:	1000021e 	bne	r2,zero,268b8 <getPHYSpeed+0x43c>
   268b0:	00800204 	movi	r2,8
   268b4:	00000106 	br	268bc <getPHYSpeed+0x440>
   268b8:	0005883a 	mov	r2,zero
   268bc:	1886b03a 	or	r3,r3,r2
   268c0:	e0bff703 	ldbu	r2,-36(fp)
   268c4:	108000d8 	cmpnei	r2,r2,3
   268c8:	1000021e 	bne	r2,zero,268d4 <getPHYSpeed+0x458>
   268cc:	00800074 	movhi	r2,1
   268d0:	00000106 	br	268d8 <getPHYSpeed+0x45c>
   268d4:	0005883a 	mov	r2,zero
   268d8:	1884b03a 	or	r2,r3,r2
   268dc:	10800834 	orhi	r2,r2,32
   268e0:	e0bff815 	stw	r2,-32(fp)
            tse_dprintf(2, "ERROR   : PHY[%d.%d] - No PHY connected! Speed = %s, Duplex = %s\n", mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
   268e4:	e17ffd47 	ldb	r5,-11(fp)
   268e8:	e1bffd07 	ldb	r6,-12(fp)
   268ec:	e0bff703 	ldbu	r2,-36(fp)
   268f0:	108000a0 	cmpeqi	r2,r2,2
   268f4:	10000e1e 	bne	r2,zero,26930 <getPHYSpeed+0x4b4>
   268f8:	e0bff703 	ldbu	r2,-36(fp)
   268fc:	10800060 	cmpeqi	r2,r2,1
   26900:	1000081e 	bne	r2,zero,26924 <getPHYSpeed+0x4a8>
   26904:	e0bff703 	ldbu	r2,-36(fp)
   26908:	1000031e 	bne	r2,zero,26918 <getPHYSpeed+0x49c>
   2690c:	008000f4 	movhi	r2,3
   26910:	10bdf604 	addi	r2,r2,-2088
   26914:	00000206 	br	26920 <getPHYSpeed+0x4a4>
   26918:	008000f4 	movhi	r2,3
   2691c:	10bdf704 	addi	r2,r2,-2084
   26920:	00000206 	br	2692c <getPHYSpeed+0x4b0>
   26924:	008000f4 	movhi	r2,3
   26928:	10bdf904 	addi	r2,r2,-2076
   2692c:	00000206 	br	26938 <getPHYSpeed+0x4bc>
   26930:	008000f4 	movhi	r2,3
   26934:	10bdfa04 	addi	r2,r2,-2072
   26938:	e0fff743 	ldbu	r3,-35(fp)
   2693c:	18c00058 	cmpnei	r3,r3,1
   26940:	1800031e 	bne	r3,zero,26950 <getPHYSpeed+0x4d4>
   26944:	00c000f4 	movhi	r3,3
   26948:	18fdfc04 	addi	r3,r3,-2064
   2694c:	00000206 	br	26958 <getPHYSpeed+0x4dc>
   26950:	00c000f4 	movhi	r3,3
   26954:	18fdfe04 	addi	r3,r3,-2056
   26958:	d8c00015 	stw	r3,0(sp)
   2695c:	010000f4 	movhi	r4,3
   26960:	213e4d04 	addi	r4,r4,-1740
   26964:	100f883a 	mov	r7,r2
   26968:	0024fd00 	call	24fd0 <no_printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
            return result;
   2696c:	e0bff817 	ldw	r2,-32(fp)
   26970:	00015a06 	br	26edc <getPHYSpeed+0xa60>
        }

		/* Small MAC */
		if(pmac_info->mac_type == ALTERA_TSE_MACLITE_10_100) {
   26974:	e0bffa17 	ldw	r2,-24(fp)
   26978:	10800003 	ldbu	r2,0(r2)
   2697c:	10803fcc 	andi	r2,r2,255
   26980:	10800058 	cmpnei	r2,r2,1
   26984:	1000081e 	bne	r2,zero,269a8 <getPHYSpeed+0x52c>
			alt_tse_phy_set_adv_1000(pphy, 0);
   26988:	e13ff917 	ldw	r4,-28(fp)
   2698c:	000b883a 	mov	r5,zero
   26990:	0028e240 	call	28e24 <alt_tse_phy_set_adv_1000>
			alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
   26994:	e13ff917 	ldw	r4,-28(fp)
   26998:	01400134 	movhi	r5,4
   2699c:	29742404 	addi	r5,r5,-12144
   269a0:	00285680 	call	28568 <alt_tse_phy_restart_an>
   269a4:	00000f06 	br	269e4 <getPHYSpeed+0x568>
		}
		else if(pmac_info->mac_type == ALTERA_TSE_MACLITE_1000) {
   269a8:	e0bffa17 	ldw	r2,-24(fp)
   269ac:	10800003 	ldbu	r2,0(r2)
   269b0:	10803fcc 	andi	r2,r2,255
   269b4:	10800098 	cmpnei	r2,r2,2
   269b8:	10000a1e 	bne	r2,zero,269e4 <getPHYSpeed+0x568>
			alt_tse_phy_set_adv_100(pphy, 0);
   269bc:	e13ff917 	ldw	r4,-28(fp)
   269c0:	000b883a 	mov	r5,zero
   269c4:	0028fe00 	call	28fe0 <alt_tse_phy_set_adv_100>
			alt_tse_phy_set_adv_10(pphy, 0);
   269c8:	e13ff917 	ldw	r4,-28(fp)
   269cc:	000b883a 	mov	r5,zero
   269d0:	00292280 	call	29228 <alt_tse_phy_set_adv_10>
			alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
   269d4:	e13ff917 	ldw	r4,-28(fp)
   269d8:	01400134 	movhi	r5,4
   269dc:	29742404 	addi	r5,r5,-12144
   269e0:	00285680 	call	28568 <alt_tse_phy_restart_an>
		}
		
		/* check link connection for this PHY */
		if(alt_tse_phy_check_link(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD) == TSE_PHY_AN_NOT_COMPLETE) {
   269e4:	e13ff917 	ldw	r4,-28(fp)
   269e8:	01400134 	movhi	r5,4
   269ec:	29742404 	addi	r5,r5,-12144
   269f0:	002872c0 	call	2872c <alt_tse_phy_check_link>
   269f4:	10bfffd8 	cmpnei	r2,r2,-1
   269f8:	1000471e 	bne	r2,zero,26b18 <getPHYSpeed+0x69c>
			speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
   269fc:	00800044 	movi	r2,1
   26a00:	e0bff705 	stb	r2,-36(fp)
			duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
   26a04:	00800044 	movi	r2,1
   26a08:	e0bff745 	stb	r2,-35(fp)
			result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_AN_NOT_COMPLETE;
   26a0c:	e0bff743 	ldbu	r2,-35(fp)
   26a10:	10c0004c 	andi	r3,r2,1
   26a14:	e0bff703 	ldbu	r2,-36(fp)
   26a18:	10800098 	cmpnei	r2,r2,2
   26a1c:	1000021e 	bne	r2,zero,26a28 <getPHYSpeed+0x5ac>
   26a20:	00800084 	movi	r2,2
   26a24:	00000106 	br	26a2c <getPHYSpeed+0x5b0>
   26a28:	0005883a 	mov	r2,zero
   26a2c:	1886b03a 	or	r3,r3,r2
   26a30:	e0bff703 	ldbu	r2,-36(fp)
   26a34:	10800058 	cmpnei	r2,r2,1
   26a38:	1000021e 	bne	r2,zero,26a44 <getPHYSpeed+0x5c8>
   26a3c:	00800104 	movi	r2,4
   26a40:	00000106 	br	26a48 <getPHYSpeed+0x5cc>
   26a44:	0005883a 	mov	r2,zero
   26a48:	1886b03a 	or	r3,r3,r2
   26a4c:	e0bff703 	ldbu	r2,-36(fp)
   26a50:	1000021e 	bne	r2,zero,26a5c <getPHYSpeed+0x5e0>
   26a54:	00800204 	movi	r2,8
   26a58:	00000106 	br	26a60 <getPHYSpeed+0x5e4>
   26a5c:	0005883a 	mov	r2,zero
   26a60:	1886b03a 	or	r3,r3,r2
   26a64:	e0bff703 	ldbu	r2,-36(fp)
   26a68:	108000d8 	cmpnei	r2,r2,3
   26a6c:	1000021e 	bne	r2,zero,26a78 <getPHYSpeed+0x5fc>
   26a70:	00800074 	movhi	r2,1
   26a74:	00000106 	br	26a7c <getPHYSpeed+0x600>
   26a78:	0005883a 	mov	r2,zero
   26a7c:	1884b03a 	or	r2,r3,r2
   26a80:	10800234 	orhi	r2,r2,8
   26a84:	e0bff815 	stw	r2,-32(fp)
			tse_dprintf(3, "WARNING : PHY[%d.%d] - Auto-Negotiation not completed! Speed = %s, Duplex = %s\n", mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
   26a88:	e17ffd47 	ldb	r5,-11(fp)
   26a8c:	e1bffd07 	ldb	r6,-12(fp)
   26a90:	e0bff703 	ldbu	r2,-36(fp)
   26a94:	108000a0 	cmpeqi	r2,r2,2
   26a98:	10000e1e 	bne	r2,zero,26ad4 <getPHYSpeed+0x658>
   26a9c:	e0bff703 	ldbu	r2,-36(fp)
   26aa0:	10800060 	cmpeqi	r2,r2,1
   26aa4:	1000081e 	bne	r2,zero,26ac8 <getPHYSpeed+0x64c>
   26aa8:	e0bff703 	ldbu	r2,-36(fp)
   26aac:	1000031e 	bne	r2,zero,26abc <getPHYSpeed+0x640>
   26ab0:	008000f4 	movhi	r2,3
   26ab4:	10bdf604 	addi	r2,r2,-2088
   26ab8:	00000206 	br	26ac4 <getPHYSpeed+0x648>
   26abc:	008000f4 	movhi	r2,3
   26ac0:	10bdf704 	addi	r2,r2,-2084
   26ac4:	00000206 	br	26ad0 <getPHYSpeed+0x654>
   26ac8:	008000f4 	movhi	r2,3
   26acc:	10bdf904 	addi	r2,r2,-2076
   26ad0:	00000206 	br	26adc <getPHYSpeed+0x660>
   26ad4:	008000f4 	movhi	r2,3
   26ad8:	10bdfa04 	addi	r2,r2,-2072
   26adc:	e0fff743 	ldbu	r3,-35(fp)
   26ae0:	18c00058 	cmpnei	r3,r3,1
   26ae4:	1800031e 	bne	r3,zero,26af4 <getPHYSpeed+0x678>
   26ae8:	00c000f4 	movhi	r3,3
   26aec:	18fdfc04 	addi	r3,r3,-2064
   26af0:	00000206 	br	26afc <getPHYSpeed+0x680>
   26af4:	00c000f4 	movhi	r3,3
   26af8:	18fdfe04 	addi	r3,r3,-2056
   26afc:	d8c00015 	stw	r3,0(sp)
   26b00:	010000f4 	movhi	r4,3
   26b04:	213e5e04 	addi	r4,r4,-1672
   26b08:	100f883a 	mov	r7,r2
   26b0c:	0024fd00 	call	24fd0 <no_printf>
																			 speed == TSE_PHY_SPEED_100 ? "100" :
																			 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
																			 duplex == 1 ? "Full" : "Half");
			return result;
   26b10:	e0bff817 	ldw	r2,-32(fp)
   26b14:	0000f106 	br	26edc <getPHYSpeed+0xa60>
		}

        IOWR(&pmac_group_base->MDIO_ADDR1, 0, pphy->mdio_address);
   26b18:	e0bffe17 	ldw	r2,-8(fp)
   26b1c:	10801004 	addi	r2,r2,64
   26b20:	e0fff917 	ldw	r3,-28(fp)
   26b24:	18c00003 	ldbu	r3,0(r3)
   26b28:	18c03fcc 	andi	r3,r3,255
   26b2c:	10c00035 	stwio	r3,0(r2)
        /* To enable PHY loopback */
        #if ENABLE_PHY_LOOPBACK
            tse_dprintf(5, "INFO    : PHY[%d.%d] - Putting PHY in loopback\n", mac_group_index, mac_info_index);
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 1);   // enable PHY loopback
		#else
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 0);   // disable PHY loopback
   26b30:	d8000015 	stw	zero,0(sp)
   26b34:	e13ff917 	ldw	r4,-28(fp)
   26b38:	000b883a 	mov	r5,zero
   26b3c:	01800384 	movi	r6,14
   26b40:	01c00044 	movi	r7,1
   26b44:	0026f900 	call	26f90 <alt_tse_phy_wr_mdio_reg>
        #endif
       
        /* if PHY not found in profile */
        if(pphy->pphy_profile == 0) {
   26b48:	e0bff917 	ldw	r2,-28(fp)
   26b4c:	10800517 	ldw	r2,20(r2)
   26b50:	10002b1e 	bne	r2,zero,26c00 <getPHYSpeed+0x784>
            tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not found in PHY profile\n", mac_group_index, mac_info_index);
   26b54:	e0fffd47 	ldb	r3,-11(fp)
   26b58:	e0bffd07 	ldb	r2,-12(fp)
   26b5c:	010000f4 	movhi	r4,3
   26b60:	213e7204 	addi	r4,r4,-1592
   26b64:	180b883a 	mov	r5,r3
   26b68:	100d883a 	mov	r6,r2
   26b6c:	0024fd00 	call	24fd0 <no_printf>
            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
   26b70:	00800044 	movi	r2,1
   26b74:	e0bff705 	stb	r2,-36(fp)
            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
   26b78:	00800044 	movi	r2,1
   26b7c:	e0bff745 	stb	r2,-35(fp)
			result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PHY_PROFILE;
   26b80:	e0bff743 	ldbu	r2,-35(fp)
   26b84:	10c0004c 	andi	r3,r2,1
   26b88:	e0bff703 	ldbu	r2,-36(fp)
   26b8c:	10800098 	cmpnei	r2,r2,2
   26b90:	1000021e 	bne	r2,zero,26b9c <getPHYSpeed+0x720>
   26b94:	00800084 	movi	r2,2
   26b98:	00000106 	br	26ba0 <getPHYSpeed+0x724>
   26b9c:	0005883a 	mov	r2,zero
   26ba0:	1886b03a 	or	r3,r3,r2
   26ba4:	e0bff703 	ldbu	r2,-36(fp)
   26ba8:	10800058 	cmpnei	r2,r2,1
   26bac:	1000021e 	bne	r2,zero,26bb8 <getPHYSpeed+0x73c>
   26bb0:	00800104 	movi	r2,4
   26bb4:	00000106 	br	26bbc <getPHYSpeed+0x740>
   26bb8:	0005883a 	mov	r2,zero
   26bbc:	1886b03a 	or	r3,r3,r2
   26bc0:	e0bff703 	ldbu	r2,-36(fp)
   26bc4:	1000021e 	bne	r2,zero,26bd0 <getPHYSpeed+0x754>
   26bc8:	00800204 	movi	r2,8
   26bcc:	00000106 	br	26bd4 <getPHYSpeed+0x758>
   26bd0:	0005883a 	mov	r2,zero
   26bd4:	1886b03a 	or	r3,r3,r2
   26bd8:	e0bff703 	ldbu	r2,-36(fp)
   26bdc:	108000d8 	cmpnei	r2,r2,3
   26be0:	1000021e 	bne	r2,zero,26bec <getPHYSpeed+0x770>
   26be4:	00800074 	movhi	r2,1
   26be8:	00000106 	br	26bf0 <getPHYSpeed+0x774>
   26bec:	0005883a 	mov	r2,zero
   26bf0:	1884b03a 	or	r2,r3,r2
   26bf4:	10800134 	orhi	r2,r2,4
   26bf8:	e0bff815 	stw	r2,-32(fp)
   26bfc:	00009406 	br	26e50 <getPHYSpeed+0x9d4>
        }
        // retrieve duplex information from PHY
		else
		{
			if(pphy->pphy_profile->link_status_read)
   26c00:	e0bff917 	ldw	r2,-28(fp)
   26c04:	10800517 	ldw	r2,20(r2)
   26c08:	10801817 	ldw	r2,96(r2)
   26c0c:	10002626 	beq	r2,zero,26ca8 <getPHYSpeed+0x82c>
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
   26c10:	e0bff917 	ldw	r2,-28(fp)
   26c14:	10800517 	ldw	r2,20(r2)
   26c18:	10801817 	ldw	r2,96(r2)
   26c1c:	e13ffe17 	ldw	r4,-8(fp)
   26c20:	103ee83a 	callr	r2
   26c24:	e0bff815 	stw	r2,-32(fp)
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
   26c28:	e0bff817 	ldw	r2,-32(fp)
   26c2c:	1080008c 	andi	r2,r2,2
   26c30:	10000c1e 	bne	r2,zero,26c64 <getPHYSpeed+0x7e8>
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
   26c34:	e0bff817 	ldw	r2,-32(fp)
   26c38:	1080010c 	andi	r2,r2,4
		else
		{
			if(pphy->pphy_profile->link_status_read)
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
   26c3c:	1000071e 	bne	r2,zero,26c5c <getPHYSpeed+0x7e0>
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
						(result & 0x08) ? TSE_PHY_SPEED_10  : TSE_PHY_SPEED_INVALID;
   26c40:	e0bff817 	ldw	r2,-32(fp)
   26c44:	1080020c 	andi	r2,r2,8
		else
		{
			if(pphy->pphy_profile->link_status_read)
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
   26c48:	10000226 	beq	r2,zero,26c54 <getPHYSpeed+0x7d8>
   26c4c:	0005883a 	mov	r2,zero
   26c50:	00000106 	br	26c58 <getPHYSpeed+0x7dc>
   26c54:	008000c4 	movi	r2,3
   26c58:	00000106 	br	26c60 <getPHYSpeed+0x7e4>
   26c5c:	00800044 	movi	r2,1
   26c60:	00000106 	br	26c68 <getPHYSpeed+0x7ec>
   26c64:	00800084 	movi	r2,2
   26c68:	e0bff705 	stb	r2,-36(fp)
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
						(result & 0x08) ? TSE_PHY_SPEED_10  : TSE_PHY_SPEED_INVALID;
				duplex = (result & 0x01) ? TSE_PHY_DUPLEX_FULL : TSE_PHY_DUPLEX_HALF;
   26c6c:	e0bff817 	ldw	r2,-32(fp)
   26c70:	1080004c 	andi	r2,r2,1
   26c74:	1004c03a 	cmpne	r2,r2,zero
   26c78:	e0bff745 	stb	r2,-35(fp)
				
				if(result & ALT_TSE_E_INVALID_SPEED)
   26c7c:	e0bff817 	ldw	r2,-32(fp)
   26c80:	1080006c 	andhi	r2,r2,1
   26c84:	10007226 	beq	r2,zero,26e50 <getPHYSpeed+0x9d4>
				{
					tse_dprintf(3, "WARNING : PHY[%d.%d] - Invalid speed read from PHY\n", mac_group_index, mac_info_index);
   26c88:	e0fffd47 	ldb	r3,-11(fp)
   26c8c:	e0bffd07 	ldb	r2,-12(fp)
   26c90:	010000f4 	movhi	r4,3
   26c94:	213e8004 	addi	r4,r4,-1536
   26c98:	180b883a 	mov	r5,r3
   26c9c:	100d883a 	mov	r6,r2
   26ca0:	0024fd00 	call	24fd0 <no_printf>
   26ca4:	00006a06 	br	26e50 <getPHYSpeed+0x9d4>
				}
			}
			else if(pphy->pphy_profile->status_reg_location == 0)
   26ca8:	e0bff917 	ldw	r2,-28(fp)
   26cac:	10800517 	ldw	r2,20(r2)
   26cb0:	10801583 	ldbu	r2,86(r2)
   26cb4:	10803fcc 	andi	r2,r2,255
   26cb8:	10002b1e 	bne	r2,zero,26d68 <getPHYSpeed+0x8ec>
	        {
	            tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY Specific Status register information not provided in profile\n", mac_group_index, mac_info_index);
   26cbc:	e0fffd47 	ldb	r3,-11(fp)
   26cc0:	e0bffd07 	ldb	r2,-12(fp)
   26cc4:	010000f4 	movhi	r4,3
   26cc8:	213e8d04 	addi	r4,r4,-1484
   26ccc:	180b883a 	mov	r5,r3
   26cd0:	100d883a 	mov	r6,r2
   26cd4:	0024fd00 	call	24fd0 <no_printf>
	            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
   26cd8:	00800044 	movi	r2,1
   26cdc:	e0bff705 	stb	r2,-36(fp)
	            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
   26ce0:	00800044 	movi	r2,1
   26ce4:	e0bff745 	stb	r2,-35(fp)
				result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_PROFILE_INCORRECT_DEFINED;
   26ce8:	e0bff743 	ldbu	r2,-35(fp)
   26cec:	10c0004c 	andi	r3,r2,1
   26cf0:	e0bff703 	ldbu	r2,-36(fp)
   26cf4:	10800098 	cmpnei	r2,r2,2
   26cf8:	1000021e 	bne	r2,zero,26d04 <getPHYSpeed+0x888>
   26cfc:	00800084 	movi	r2,2
   26d00:	00000106 	br	26d08 <getPHYSpeed+0x88c>
   26d04:	0005883a 	mov	r2,zero
   26d08:	1886b03a 	or	r3,r3,r2
   26d0c:	e0bff703 	ldbu	r2,-36(fp)
   26d10:	10800058 	cmpnei	r2,r2,1
   26d14:	1000021e 	bne	r2,zero,26d20 <getPHYSpeed+0x8a4>
   26d18:	00800104 	movi	r2,4
   26d1c:	00000106 	br	26d24 <getPHYSpeed+0x8a8>
   26d20:	0005883a 	mov	r2,zero
   26d24:	1886b03a 	or	r3,r3,r2
   26d28:	e0bff703 	ldbu	r2,-36(fp)
   26d2c:	1000021e 	bne	r2,zero,26d38 <getPHYSpeed+0x8bc>
   26d30:	00800204 	movi	r2,8
   26d34:	00000106 	br	26d3c <getPHYSpeed+0x8c0>
   26d38:	0005883a 	mov	r2,zero
   26d3c:	1886b03a 	or	r3,r3,r2
   26d40:	e0bff703 	ldbu	r2,-36(fp)
   26d44:	108000d8 	cmpnei	r2,r2,3
   26d48:	1000021e 	bne	r2,zero,26d54 <getPHYSpeed+0x8d8>
   26d4c:	00800074 	movhi	r2,1
   26d50:	00000106 	br	26d58 <getPHYSpeed+0x8dc>
   26d54:	0005883a 	mov	r2,zero
   26d58:	1884b03a 	or	r2,r3,r2
   26d5c:	108000b4 	orhi	r2,r2,2
   26d60:	e0bff815 	stw	r2,-32(fp)
   26d64:	00003a06 	br	26e50 <getPHYSpeed+0x9d4>
	        }
	        else
	        {
	            /* extract connection speed and duplex information */
	        	speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 2);
   26d68:	e0bff917 	ldw	r2,-28(fp)
   26d6c:	10800517 	ldw	r2,20(r2)
   26d70:	10801583 	ldbu	r2,86(r2)
   26d74:	10c03fcc 	andi	r3,r2,255
   26d78:	e0bff917 	ldw	r2,-28(fp)
   26d7c:	10800517 	ldw	r2,20(r2)
   26d80:	108015c3 	ldbu	r2,87(r2)
   26d84:	10803fcc 	andi	r2,r2,255
   26d88:	e13ff917 	ldw	r4,-28(fp)
   26d8c:	180b883a 	mov	r5,r3
   26d90:	100d883a 	mov	r6,r2
   26d94:	01c00084 	movi	r7,2
   26d98:	00270bc0 	call	270bc <alt_tse_phy_rd_mdio_reg>
   26d9c:	e0bff705 	stb	r2,-36(fp)
	            duplex = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->duplex_bit_location, 1);
   26da0:	e0bff917 	ldw	r2,-28(fp)
   26da4:	10800517 	ldw	r2,20(r2)
   26da8:	10801583 	ldbu	r2,86(r2)
   26dac:	10c03fcc 	andi	r3,r2,255
   26db0:	e0bff917 	ldw	r2,-28(fp)
   26db4:	10800517 	ldw	r2,20(r2)
   26db8:	10801603 	ldbu	r2,88(r2)
   26dbc:	10803fcc 	andi	r2,r2,255
   26dc0:	e13ff917 	ldw	r4,-28(fp)
   26dc4:	180b883a 	mov	r5,r3
   26dc8:	100d883a 	mov	r6,r2
   26dcc:	01c00044 	movi	r7,1
   26dd0:	00270bc0 	call	270bc <alt_tse_phy_rd_mdio_reg>
   26dd4:	e0bff745 	stb	r2,-35(fp)
				
				result = ALT_TSE_SPEED_DUPLEX(speed, duplex);
   26dd8:	e0bff743 	ldbu	r2,-35(fp)
   26ddc:	10c0004c 	andi	r3,r2,1
   26de0:	e0bff703 	ldbu	r2,-36(fp)
   26de4:	10800098 	cmpnei	r2,r2,2
   26de8:	1000021e 	bne	r2,zero,26df4 <getPHYSpeed+0x978>
   26dec:	00800084 	movi	r2,2
   26df0:	00000106 	br	26df8 <getPHYSpeed+0x97c>
   26df4:	0005883a 	mov	r2,zero
   26df8:	1886b03a 	or	r3,r3,r2
   26dfc:	e0bff703 	ldbu	r2,-36(fp)
   26e00:	10800058 	cmpnei	r2,r2,1
   26e04:	1000021e 	bne	r2,zero,26e10 <getPHYSpeed+0x994>
   26e08:	00800104 	movi	r2,4
   26e0c:	00000106 	br	26e14 <getPHYSpeed+0x998>
   26e10:	0005883a 	mov	r2,zero
   26e14:	1886b03a 	or	r3,r3,r2
   26e18:	e0bff703 	ldbu	r2,-36(fp)
   26e1c:	1000021e 	bne	r2,zero,26e28 <getPHYSpeed+0x9ac>
   26e20:	00800204 	movi	r2,8
   26e24:	00000106 	br	26e2c <getPHYSpeed+0x9b0>
   26e28:	0005883a 	mov	r2,zero
   26e2c:	1886b03a 	or	r3,r3,r2
   26e30:	e0bff703 	ldbu	r2,-36(fp)
   26e34:	108000d8 	cmpnei	r2,r2,3
   26e38:	1000021e 	bne	r2,zero,26e44 <getPHYSpeed+0x9c8>
   26e3c:	00800074 	movhi	r2,1
   26e40:	00000106 	br	26e48 <getPHYSpeed+0x9cc>
   26e44:	0005883a 	mov	r2,zero
   26e48:	1884b03a 	or	r2,r3,r2
   26e4c:	e0bff815 	stw	r2,-32(fp)
        /* for simulation purpose, default to gigabit mode */
        speed = 1;
        duplex = 1;
    #endif

    tse_dprintf(5, "INFO    : PHY[%d.%d] - Speed = %s, Duplex = %s\n",  mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
   26e50:	e17ffd47 	ldb	r5,-11(fp)
   26e54:	e1bffd07 	ldb	r6,-12(fp)
   26e58:	e0bff703 	ldbu	r2,-36(fp)
   26e5c:	108000a0 	cmpeqi	r2,r2,2
   26e60:	10000e1e 	bne	r2,zero,26e9c <getPHYSpeed+0xa20>
   26e64:	e0bff703 	ldbu	r2,-36(fp)
   26e68:	10800060 	cmpeqi	r2,r2,1
   26e6c:	1000081e 	bne	r2,zero,26e90 <getPHYSpeed+0xa14>
   26e70:	e0bff703 	ldbu	r2,-36(fp)
   26e74:	1000031e 	bne	r2,zero,26e84 <getPHYSpeed+0xa08>
   26e78:	008000f4 	movhi	r2,3
   26e7c:	10bdf604 	addi	r2,r2,-2088
   26e80:	00000206 	br	26e8c <getPHYSpeed+0xa10>
   26e84:	008000f4 	movhi	r2,3
   26e88:	10bdf704 	addi	r2,r2,-2084
   26e8c:	00000206 	br	26e98 <getPHYSpeed+0xa1c>
   26e90:	008000f4 	movhi	r2,3
   26e94:	10bdf904 	addi	r2,r2,-2076
   26e98:	00000206 	br	26ea4 <getPHYSpeed+0xa28>
   26e9c:	008000f4 	movhi	r2,3
   26ea0:	10bdfa04 	addi	r2,r2,-2072
   26ea4:	e0fff743 	ldbu	r3,-35(fp)
   26ea8:	18c00058 	cmpnei	r3,r3,1
   26eac:	1800031e 	bne	r3,zero,26ebc <getPHYSpeed+0xa40>
   26eb0:	00c000f4 	movhi	r3,3
   26eb4:	18fdfc04 	addi	r3,r3,-2064
   26eb8:	00000206 	br	26ec4 <getPHYSpeed+0xa48>
   26ebc:	00c000f4 	movhi	r3,3
   26ec0:	18fdfe04 	addi	r3,r3,-2056
   26ec4:	d8c00015 	stw	r3,0(sp)
   26ec8:	010000f4 	movhi	r4,3
   26ecc:	213ea404 	addi	r4,r4,-1392
   26ed0:	100f883a 	mov	r7,r2
   26ed4:	0024fd00 	call	24fd0 <no_printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");

    return result;
   26ed8:	e0bff817 	ldw	r2,-32(fp)
}
   26edc:	e037883a 	mov	sp,fp
   26ee0:	dfc00117 	ldw	ra,4(sp)
   26ee4:	df000017 	ldw	fp,0(sp)
   26ee8:	dec00204 	addi	sp,sp,8
   26eec:	f800283a 	ret

00026ef0 <alt_tse_phy_rd_mdio_addr>:
/* @Function Description: Read MDIO address from the MDIO address1 register of first MAC within MAC group
 * @API Type:    Internal
 * @param pmac   Pointer to the alt_tse_phy_info structure
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_rd_mdio_addr(alt_tse_phy_info *pphy) {
   26ef0:	defffd04 	addi	sp,sp,-12
   26ef4:	df000215 	stw	fp,8(sp)
   26ef8:	df000204 	addi	fp,sp,8
   26efc:	e13fff15 	stw	r4,-4(fp)
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   26f00:	e0bfff17 	ldw	r2,-4(fp)
   26f04:	10800617 	ldw	r2,24(r2)
   26f08:	10800317 	ldw	r2,12(r2)
   26f0c:	10800117 	ldw	r2,4(r2)
   26f10:	10800217 	ldw	r2,8(r2)
   26f14:	10800017 	ldw	r2,0(r2)
   26f18:	e0bffe15 	stw	r2,-8(fp)
    return IORD(&pmac_group_base->MDIO_ADDR1, 0);
   26f1c:	e0bffe17 	ldw	r2,-8(fp)
   26f20:	10801004 	addi	r2,r2,64
   26f24:	10800037 	ldwio	r2,0(r2)
}
   26f28:	e037883a 	mov	sp,fp
   26f2c:	df000017 	ldw	fp,0(sp)
   26f30:	dec00104 	addi	sp,sp,4
   26f34:	f800283a 	ret

00026f38 <alt_tse_phy_wr_mdio_addr>:
 * @API Type:           Internal
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
   26f38:	defffc04 	addi	sp,sp,-16
   26f3c:	df000315 	stw	fp,12(sp)
   26f40:	df000304 	addi	fp,sp,12
   26f44:	e13ffe15 	stw	r4,-8(fp)
   26f48:	2805883a 	mov	r2,r5
   26f4c:	e0bfff05 	stb	r2,-4(fp)
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   26f50:	e0bffe17 	ldw	r2,-8(fp)
   26f54:	10800617 	ldw	r2,24(r2)
   26f58:	10800317 	ldw	r2,12(r2)
   26f5c:	10800117 	ldw	r2,4(r2)
   26f60:	10800217 	ldw	r2,8(r2)
   26f64:	10800017 	ldw	r2,0(r2)
   26f68:	e0bffd15 	stw	r2,-12(fp)
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdio_address);
   26f6c:	e0bffd17 	ldw	r2,-12(fp)
   26f70:	10801004 	addi	r2,r2,64
   26f74:	e0ffff03 	ldbu	r3,-4(fp)
   26f78:	10c00035 	stwio	r3,0(r2)
    
    return SUCCESS;
   26f7c:	0005883a 	mov	r2,zero
}
   26f80:	e037883a 	mov	sp,fp
   26f84:	df000017 	ldw	fp,0(sp)
   26f88:	dec00104 	addi	sp,sp,4
   26f8c:	f800283a 	ret

00026f90 <alt_tse_phy_wr_mdio_reg>:
  * @param  bit_length       number of bits to be written to the register.
  * @param  data             data to be written to the register at specific bit location of register.
  * @return SUCCESS 
  */
alt_32 alt_tse_phy_wr_mdio_reg(alt_tse_phy_info *pphy, alt_u8 reg_num, alt_u8 lsb_num, alt_u8 bit_length, alt_u16 data)
{
   26f90:	defff604 	addi	sp,sp,-40
   26f94:	df000915 	stw	fp,36(sp)
   26f98:	df000904 	addi	fp,sp,36
   26f9c:	e13ffb15 	stw	r4,-20(fp)
   26fa0:	2809883a 	mov	r4,r5
   26fa4:	3007883a 	mov	r3,r6
   26fa8:	3805883a 	mov	r2,r7
   26fac:	e1400117 	ldw	r5,4(fp)
   26fb0:	e13ffc05 	stb	r4,-16(fp)
   26fb4:	e0fffd05 	stb	r3,-12(fp)
   26fb8:	e0bffe05 	stb	r2,-8(fp)
   26fbc:	e17fff0d 	sth	r5,-4(fp)
    
    alt_u16 temp_data;
    alt_u16 bit_mask;
    alt_32 i;
    np_tse_mac *pmac = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   26fc0:	e0bffb17 	ldw	r2,-20(fp)
   26fc4:	10800617 	ldw	r2,24(r2)
   26fc8:	10800317 	ldw	r2,12(r2)
   26fcc:	10800117 	ldw	r2,4(r2)
   26fd0:	10800217 	ldw	r2,8(r2)
   26fd4:	10800017 	ldw	r2,0(r2)
   26fd8:	e0bff915 	stw	r2,-28(fp)
    
    bit_mask = 0x00;
   26fdc:	e03ff70d 	sth	zero,-36(fp)
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
   26fe0:	e03ff815 	stw	zero,-32(fp)
   26fe4:	00000906 	br	2700c <alt_tse_phy_wr_mdio_reg+0x7c>
    {
        bit_mask <<= 1;
   26fe8:	e0bff70b 	ldhu	r2,-36(fp)
   26fec:	1085883a 	add	r2,r2,r2
   26ff0:	e0bff70d 	sth	r2,-36(fp)
        bit_mask |= 0x01;        
   26ff4:	e0bff70b 	ldhu	r2,-36(fp)
   26ff8:	10800054 	ori	r2,r2,1
   26ffc:	e0bff70d 	sth	r2,-36(fp)
    
    bit_mask = 0x00;
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
   27000:	e0bff817 	ldw	r2,-32(fp)
   27004:	10800044 	addi	r2,r2,1
   27008:	e0bff815 	stw	r2,-32(fp)
   2700c:	e0bffe03 	ldbu	r2,-8(fp)
   27010:	e0fff817 	ldw	r3,-32(fp)
   27014:	18bff416 	blt	r3,r2,26fe8 <alt_tse_phy_wr_mdio_reg+0x58>
        bit_mask <<= 1;
        bit_mask |= 0x01;        
    }
    
    /* shifting mask to left by bit_num */
    bit_mask <<= lsb_num;
   27018:	e0fff70b 	ldhu	r3,-36(fp)
   2701c:	e0bffd03 	ldbu	r2,-12(fp)
   27020:	1884983a 	sll	r2,r3,r2
   27024:	e0bff70d 	sth	r2,-36(fp)

    /* read register data */
    temp_data = IORD(&pmac->mdio1, reg_num);
   27028:	e0bff917 	ldw	r2,-28(fp)
   2702c:	10c0a004 	addi	r3,r2,640
   27030:	e0bffc03 	ldbu	r2,-16(fp)
   27034:	1085883a 	add	r2,r2,r2
   27038:	1085883a 	add	r2,r2,r2
   2703c:	1885883a 	add	r2,r3,r2
   27040:	10800037 	ldwio	r2,0(r2)
   27044:	e0bffa0d 	sth	r2,-24(fp)
    
    /* clear bits to be written */
    temp_data &= ~bit_mask;
   27048:	e0bff70b 	ldhu	r2,-36(fp)
   2704c:	0084303a 	nor	r2,zero,r2
   27050:	1007883a 	mov	r3,r2
   27054:	e0bffa0b 	ldhu	r2,-24(fp)
   27058:	1884703a 	and	r2,r3,r2
   2705c:	e0bffa0d 	sth	r2,-24(fp)
    
    /* OR-ed together corresponding bits data */
    temp_data |= ((data << lsb_num) & bit_mask);    
   27060:	e0ffff0b 	ldhu	r3,-4(fp)
   27064:	e0bffd03 	ldbu	r2,-12(fp)
   27068:	1884983a 	sll	r2,r3,r2
   2706c:	1007883a 	mov	r3,r2
   27070:	e0bff70b 	ldhu	r2,-36(fp)
   27074:	1884703a 	and	r2,r3,r2
   27078:	1007883a 	mov	r3,r2
   2707c:	e0bffa0b 	ldhu	r2,-24(fp)
   27080:	1884b03a 	or	r2,r3,r2
   27084:	e0bffa0d 	sth	r2,-24(fp)
    
    /* write data to MDIO register */
    IOWR(&pmac->mdio1, reg_num, temp_data);
   27088:	e0bff917 	ldw	r2,-28(fp)
   2708c:	10c0a004 	addi	r3,r2,640
   27090:	e0bffc03 	ldbu	r2,-16(fp)
   27094:	1085883a 	add	r2,r2,r2
   27098:	1085883a 	add	r2,r2,r2
   2709c:	1885883a 	add	r2,r3,r2
   270a0:	e0fffa0b 	ldhu	r3,-24(fp)
   270a4:	10c00035 	stwio	r3,0(r2)
    
    return SUCCESS;
   270a8:	0005883a 	mov	r2,zero
    
}
   270ac:	e037883a 	mov	sp,fp
   270b0:	df000017 	ldw	fp,0(sp)
   270b4:	dec00104 	addi	sp,sp,4
   270b8:	f800283a 	ret

000270bc <alt_tse_phy_rd_mdio_reg>:
 * @param  bit_length       number of bits to be read from the register.
 * @return data read from MDIO register 
 */

alt_u32 alt_tse_phy_rd_mdio_reg(alt_tse_phy_info *pphy, alt_u8 reg_num, alt_u8 lsb_num, alt_u8 bit_length)
{
   270bc:	defff704 	addi	sp,sp,-36
   270c0:	df000815 	stw	fp,32(sp)
   270c4:	df000804 	addi	fp,sp,32
   270c8:	e13ffc15 	stw	r4,-16(fp)
   270cc:	2809883a 	mov	r4,r5
   270d0:	3007883a 	mov	r3,r6
   270d4:	3805883a 	mov	r2,r7
   270d8:	e13ffd05 	stb	r4,-12(fp)
   270dc:	e0fffe05 	stb	r3,-8(fp)
   270e0:	e0bfff05 	stb	r2,-4(fp)
    alt_u16 temp_data;
    alt_u32 bit_mask;
    alt_32 i;
    np_tse_mac *pmac = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   270e4:	e0bffc17 	ldw	r2,-16(fp)
   270e8:	10800617 	ldw	r2,24(r2)
   270ec:	10800317 	ldw	r2,12(r2)
   270f0:	10800117 	ldw	r2,4(r2)
   270f4:	10800217 	ldw	r2,8(r2)
   270f8:	10800017 	ldw	r2,0(r2)
   270fc:	e0bffa15 	stw	r2,-24(fp)
    
    bit_mask = 0x00;
   27100:	e03ff815 	stw	zero,-32(fp)
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
   27104:	e03ff915 	stw	zero,-28(fp)
   27108:	00000906 	br	27130 <alt_tse_phy_rd_mdio_reg+0x74>
    {
        bit_mask <<= 1;
   2710c:	e0bff817 	ldw	r2,-32(fp)
   27110:	1085883a 	add	r2,r2,r2
   27114:	e0bff815 	stw	r2,-32(fp)
        bit_mask |= 0x01;        
   27118:	e0bff817 	ldw	r2,-32(fp)
   2711c:	10800054 	ori	r2,r2,1
   27120:	e0bff815 	stw	r2,-32(fp)
    
    bit_mask = 0x00;
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
   27124:	e0bff917 	ldw	r2,-28(fp)
   27128:	10800044 	addi	r2,r2,1
   2712c:	e0bff915 	stw	r2,-28(fp)
   27130:	e0bfff03 	ldbu	r2,-4(fp)
   27134:	e0fff917 	ldw	r3,-28(fp)
   27138:	18bff416 	blt	r3,r2,2710c <alt_tse_phy_rd_mdio_reg+0x50>
        bit_mask <<= 1;
        bit_mask |= 0x01;        
    }
    
    /* read register data */
    temp_data = IORD(&pmac->mdio1, reg_num);
   2713c:	e0bffa17 	ldw	r2,-24(fp)
   27140:	10c0a004 	addi	r3,r2,640
   27144:	e0bffd03 	ldbu	r2,-12(fp)
   27148:	1085883a 	add	r2,r2,r2
   2714c:	1085883a 	add	r2,r2,r2
   27150:	1885883a 	add	r2,r3,r2
   27154:	10800037 	ldwio	r2,0(r2)
   27158:	e0bffb0d 	sth	r2,-20(fp)
    
    /* shifting read data */
    temp_data >>= lsb_num;
   2715c:	e0fffb0b 	ldhu	r3,-20(fp)
   27160:	e0bffe03 	ldbu	r2,-8(fp)
   27164:	1885d83a 	sra	r2,r3,r2
   27168:	e0bffb0d 	sth	r2,-20(fp)
    
    return (temp_data & bit_mask);
   2716c:	e0fffb0b 	ldhu	r3,-20(fp)
   27170:	e0bff817 	ldw	r2,-32(fp)
   27174:	1884703a 	and	r2,r3,r2
}
   27178:	e037883a 	mov	sp,fp
   2717c:	df000017 	ldw	fp,0(sp)
   27180:	dec00104 	addi	sp,sp,4
   27184:	f800283a 	ret

00027188 <alt_tse_phy_add_profile_default>:
 * @param pmac  N/A
 * @return      Number of PHY in profile
 * 
 * User might add their own PHY by calling alt_tse_phy_add_profile()
 */
alt_32 alt_tse_phy_add_profile_default() {
   27188:	deff9a04 	addi	sp,sp,-408
   2718c:	dfc06515 	stw	ra,404(sp)
   27190:	df006415 	stw	fp,400(sp)
   27194:	df006404 	addi	fp,sp,400
        
    /* ------------------------------ */
    /* Marvell PHY on PHYWORKX board  */
    /* ------------------------------ */
    
    alt_tse_phy_profile MV88E1111 = {"Marvell 88E1111",      /* Marvell 88E1111                                  */
   27198:	e0ff9c04 	addi	r3,fp,-400
   2719c:	00801904 	movi	r2,100
   271a0:	1809883a 	mov	r4,r3
   271a4:	000b883a 	mov	r5,zero
   271a8:	100d883a 	mov	r6,r2
   271ac:	00165b80 	call	165b8 <memset>
   271b0:	009d9cb4 	movhi	r2,30322
   271b4:	10985344 	addi	r2,r2,24909
   271b8:	e0bf9c15 	stw	r2,-400(fp)
   271bc:	00881b34 	movhi	r2,8300
   271c0:	109b1944 	addi	r2,r2,27749
   271c4:	e0bf9d15 	stw	r2,-396(fp)
   271c8:	008c5174 	movhi	r2,12613
   271cc:	108e0e04 	addi	r2,r2,14392
   271d0:	e0bf9e15 	stw	r2,-392(fp)
   271d4:	00800c74 	movhi	r2,49
   271d8:	108c4c44 	addi	r2,r2,12593
   271dc:	e0bf9f15 	stw	r2,-388(fp)
   271e0:	e0ffa004 	addi	r3,fp,-384
   271e4:	00801004 	movi	r2,64
   271e8:	1809883a 	mov	r4,r3
   271ec:	000b883a 	mov	r5,zero
   271f0:	100d883a 	mov	r6,r2
   271f4:	00165b80 	call	165b8 <memset>
   271f8:	009410c4 	movi	r2,20547
   271fc:	e0bfb015 	stw	r2,-320(fp)
   27200:	00800304 	movi	r2,12
   27204:	e0bfb105 	stb	r2,-316(fp)
   27208:	00800084 	movi	r2,2
   2720c:	e0bfb145 	stb	r2,-315(fp)
   27210:	00800444 	movi	r2,17
   27214:	e0bfb185 	stb	r2,-314(fp)
   27218:	00800384 	movi	r2,14
   2721c:	e0bfb1c5 	stb	r2,-313(fp)
   27220:	00800344 	movi	r2,13
   27224:	e0bfb205 	stb	r2,-312(fp)
   27228:	00800284 	movi	r2,10
   2722c:	e0bfb245 	stb	r2,-311(fp)
   27230:	008000f4 	movhi	r2,3
   27234:	10a6ec04 	addi	r2,r2,-25680
   27238:	e0bfb315 	stw	r2,-308(fp)
    
    /* ---------------------------------- */
    /* Marvell Quad PHY on PHYWORKX board */
    /* ---------------------------------- */
    
    alt_tse_phy_profile MV88E1145 = {"Marvell Quad PHY 88E1145",      /* Marvell 88E1145                                  */
   2723c:	e0ffb504 	addi	r3,fp,-300
   27240:	00801904 	movi	r2,100
   27244:	1809883a 	mov	r4,r3
   27248:	000b883a 	mov	r5,zero
   2724c:	100d883a 	mov	r6,r2
   27250:	00165b80 	call	165b8 <memset>
   27254:	009d9cb4 	movhi	r2,30322
   27258:	10985344 	addi	r2,r2,24909
   2725c:	e0bfb515 	stw	r2,-300(fp)
   27260:	00881b34 	movhi	r2,8300
   27264:	109b1944 	addi	r2,r2,27749
   27268:	e0bfb615 	stw	r2,-296(fp)
   2726c:	00991874 	movhi	r2,25697
   27270:	109d5444 	addi	r2,r2,30033
   27274:	e0bfb715 	stw	r2,-292(fp)
   27278:	00965234 	movhi	r2,22856
   2727c:	10940804 	addi	r2,r2,20512
   27280:	e0bfb815 	stw	r2,-288(fp)
   27284:	00914e34 	movhi	r2,17720
   27288:	108e0804 	addi	r2,r2,14368
   2728c:	e0bfb915 	stw	r2,-284(fp)
   27290:	008d4d34 	movhi	r2,13620
   27294:	108c4c44 	addi	r2,r2,12593
   27298:	e0bfba15 	stw	r2,-280(fp)
   2729c:	e03fbb15 	stw	zero,-276(fp)
   272a0:	e03fbc15 	stw	zero,-272(fp)
   272a4:	e03fbd15 	stw	zero,-268(fp)
   272a8:	e03fbe15 	stw	zero,-264(fp)
   272ac:	e03fbf15 	stw	zero,-260(fp)
   272b0:	e03fc015 	stw	zero,-256(fp)
   272b4:	e03fc115 	stw	zero,-252(fp)
   272b8:	e03fc215 	stw	zero,-248(fp)
   272bc:	e03fc315 	stw	zero,-244(fp)
   272c0:	e03fc415 	stw	zero,-240(fp)
   272c4:	e03fc515 	stw	zero,-236(fp)
   272c8:	e03fc615 	stw	zero,-232(fp)
   272cc:	e03fc715 	stw	zero,-228(fp)
   272d0:	e03fc815 	stw	zero,-224(fp)
   272d4:	009410c4 	movi	r2,20547
   272d8:	e0bfc915 	stw	r2,-220(fp)
   272dc:	00800344 	movi	r2,13
   272e0:	e0bfca05 	stb	r2,-216(fp)
   272e4:	00800084 	movi	r2,2
   272e8:	e0bfca45 	stb	r2,-215(fp)
   272ec:	00800444 	movi	r2,17
   272f0:	e0bfca85 	stb	r2,-214(fp)
   272f4:	00800384 	movi	r2,14
   272f8:	e0bfcac5 	stb	r2,-213(fp)
   272fc:	00800344 	movi	r2,13
   27300:	e0bfcb05 	stb	r2,-212(fp)
   27304:	00800284 	movi	r2,10
   27308:	e0bfcb45 	stb	r2,-211(fp)
   2730c:	008000f4 	movhi	r2,3
   27310:	10a6ec04 	addi	r2,r2,-25680
   27314:	e0bfcc15 	stw	r2,-208(fp)
                      
    /* ------------------------------ */
    /* National PHY on PHYWORKX board */
    /* ------------------------------ */  
    
    alt_tse_phy_profile DP83865 = {"National DP83865",     /* National DP83865                                 */
   27318:	e0ffce04 	addi	r3,fp,-200
   2731c:	00801904 	movi	r2,100
   27320:	1809883a 	mov	r4,r3
   27324:	000b883a 	mov	r5,zero
   27328:	100d883a 	mov	r6,r2
   2732c:	00165b80 	call	165b8 <memset>
   27330:	009a5d34 	movhi	r2,26996
   27334:	10985384 	addi	r2,r2,24910
   27338:	e0bfce15 	stw	r2,-200(fp)
   2733c:	009b1874 	movhi	r2,27745
   27340:	109b9bc4 	addi	r2,r2,28271
   27344:	e0bfcf15 	stw	r2,-196(fp)
   27348:	008e1434 	movhi	r2,14416
   2734c:	10910804 	addi	r2,r2,17440
   27350:	e0bfd015 	stw	r2,-192(fp)
   27354:	008d4db4 	movhi	r2,13622
   27358:	108e0cc4 	addi	r2,r2,14387
   2735c:	e0bfd115 	stw	r2,-188(fp)
   27360:	e03fd215 	stw	zero,-184(fp)
   27364:	e0ffd304 	addi	r3,fp,-180
   27368:	00800f04 	movi	r2,60
   2736c:	1809883a 	mov	r4,r3
   27370:	000b883a 	mov	r5,zero
   27374:	100d883a 	mov	r6,r2
   27378:	00165b80 	call	165b8 <memset>
   2737c:	00800234 	movhi	r2,8
   27380:	108005c4 	addi	r2,r2,23
   27384:	e0bfe215 	stw	r2,-120(fp)
   27388:	008001c4 	movi	r2,7
   2738c:	e0bfe305 	stb	r2,-116(fp)
   27390:	00800284 	movi	r2,10
   27394:	e0bfe345 	stb	r2,-115(fp)
   27398:	00800444 	movi	r2,17
   2739c:	e0bfe385 	stb	r2,-114(fp)
   273a0:	008000c4 	movi	r2,3
   273a4:	e0bfe3c5 	stb	r2,-113(fp)
   273a8:	00800044 	movi	r2,1
   273ac:	e0bfe405 	stb	r2,-112(fp)
   273b0:	00800084 	movi	r2,2
   273b4:	e0bfe445 	stb	r2,-111(fp)
                      
    /* -------------------------------------- */
    /* National 10/100 PHY on PHYWORKX board  */
    /* -------------------------------------- */ 
                      
    alt_tse_phy_profile DP83848C = {"National DP83848C",  /* National DP83848C                                          */
   273b8:	008000f4 	movhi	r2,3
   273bc:	10beb004 	addi	r2,r2,-1344
   273c0:	e13fe704 	addi	r4,fp,-100
   273c4:	1007883a 	mov	r3,r2
   273c8:	00801904 	movi	r2,100
   273cc:	180b883a 	mov	r5,r3
   273d0:	100d883a 	mov	r6,r2
   273d4:	00164c00 	call	164c0 <memcpy>
						   0,                              /* No function pointer configure National DP83848C            */
						   &DP83848C_link_status_read      /* Function pointer to read from PHY specific status register */           
                          };
                      
    /* add supported PHY to profile */                          
    alt_tse_phy_add_profile(&MV88E1111);
   273d8:	e13f9c04 	addi	r4,fp,-400
   273dc:	002530c0 	call	2530c <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&MV88E1145);
   273e0:	e0bfb504 	addi	r2,fp,-300
   273e4:	1009883a 	mov	r4,r2
   273e8:	002530c0 	call	2530c <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&DP83865);
   273ec:	e0bfce04 	addi	r2,fp,-200
   273f0:	1009883a 	mov	r4,r2
   273f4:	002530c0 	call	2530c <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&DP83848C);
   273f8:	e0bfe704 	addi	r2,fp,-100
   273fc:	1009883a 	mov	r4,r2
   27400:	002530c0 	call	2530c <alt_tse_phy_add_profile>
    
    
    return phy_profile_count;
   27404:	d0a8f703 	ldbu	r2,-23588(gp)
   27408:	10803fcc 	andi	r2,r2,255
}
   2740c:	e037883a 	mov	sp,fp
   27410:	dfc00117 	ldw	ra,4(sp)
   27414:	df000017 	ldw	fp,0(sp)
   27418:	dec00204 	addi	sp,sp,8
   2741c:	f800283a 	ret

00027420 <alt_tse_phy_print_profile>:
/* @Function Description: Display PHYs available in profile
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      Number of PHY in profile
 */
alt_32 alt_tse_phy_print_profile() {
   27420:	defffd04 	addi	sp,sp,-12
   27424:	dfc00215 	stw	ra,8(sp)
   27428:	df000115 	stw	fp,4(sp)
   2742c:	df000104 	addi	fp,sp,4
   
	alt_8 i;
    /* display PHY in profile */
    tse_dprintf(6, "List of PHY profiles supported (Total profiles = %d)...\n", phy_profile_count);
   27430:	d0a8f703 	ldbu	r2,-23588(gp)
   27434:	10803fcc 	andi	r2,r2,255
   27438:	010000f4 	movhi	r4,3
   2743c:	213ec904 	addi	r4,r4,-1244
   27440:	100b883a 	mov	r5,r2
   27444:	0024fd00 	call	24fd0 <no_printf>
    
    for(i = 0; i < phy_profile_count; i++)
   27448:	e03fff05 	stb	zero,-4(fp)
   2744c:	00006d06 	br	27604 <alt_tse_phy_print_profile+0x1e4>
    {
        tse_dprintf(6, "Profile No.%2d   :\n", i);
   27450:	e0bfff07 	ldb	r2,-4(fp)
   27454:	010000f4 	movhi	r4,3
   27458:	213ed804 	addi	r4,r4,-1184
   2745c:	100b883a 	mov	r5,r2
   27460:	0024fd00 	call	24fd0 <no_printf>
        tse_dprintf(6, "PHY Name        : %s\n", pphy_profiles[i]->name);
   27464:	e0bfff07 	ldb	r2,-4(fp)
   27468:	00c00134 	movhi	r3,4
   2746c:	18cdf004 	addi	r3,r3,14272
   27470:	1085883a 	add	r2,r2,r2
   27474:	1085883a 	add	r2,r2,r2
   27478:	1885883a 	add	r2,r3,r2
   2747c:	10800017 	ldw	r2,0(r2)
   27480:	010000f4 	movhi	r4,3
   27484:	213edd04 	addi	r4,r4,-1164
   27488:	100b883a 	mov	r5,r2
   2748c:	0024fd00 	call	24fd0 <no_printf>
   
        tse_dprintf(6, "PHY OUI         : 0x%06x\n", (int)pphy_profiles[i]->oui);
   27490:	e0bfff07 	ldb	r2,-4(fp)
   27494:	00c00134 	movhi	r3,4
   27498:	18cdf004 	addi	r3,r3,14272
   2749c:	1085883a 	add	r2,r2,r2
   274a0:	1085883a 	add	r2,r2,r2
   274a4:	1885883a 	add	r2,r3,r2
   274a8:	10800017 	ldw	r2,0(r2)
   274ac:	10801417 	ldw	r2,80(r2)
   274b0:	010000f4 	movhi	r4,3
   274b4:	213ee304 	addi	r4,r4,-1140
   274b8:	100b883a 	mov	r5,r2
   274bc:	0024fd00 	call	24fd0 <no_printf>
        tse_dprintf(6, "PHY Model Num.  : 0x%02x\n", pphy_profiles[i]->model_number);
   274c0:	e0bfff07 	ldb	r2,-4(fp)
   274c4:	00c00134 	movhi	r3,4
   274c8:	18cdf004 	addi	r3,r3,14272
   274cc:	1085883a 	add	r2,r2,r2
   274d0:	1085883a 	add	r2,r2,r2
   274d4:	1885883a 	add	r2,r3,r2
   274d8:	10800017 	ldw	r2,0(r2)
   274dc:	10801503 	ldbu	r2,84(r2)
   274e0:	10803fcc 	andi	r2,r2,255
   274e4:	010000f4 	movhi	r4,3
   274e8:	213eea04 	addi	r4,r4,-1112
   274ec:	100b883a 	mov	r5,r2
   274f0:	0024fd00 	call	24fd0 <no_printf>
        tse_dprintf(6, "PHY Rev. Num.   : 0x%02x\n", pphy_profiles[i]->revision_number);
   274f4:	e0bfff07 	ldb	r2,-4(fp)
   274f8:	00c00134 	movhi	r3,4
   274fc:	18cdf004 	addi	r3,r3,14272
   27500:	1085883a 	add	r2,r2,r2
   27504:	1085883a 	add	r2,r2,r2
   27508:	1885883a 	add	r2,r3,r2
   2750c:	10800017 	ldw	r2,0(r2)
   27510:	10801543 	ldbu	r2,85(r2)
   27514:	10803fcc 	andi	r2,r2,255
   27518:	010000f4 	movhi	r4,3
   2751c:	213ef104 	addi	r4,r4,-1084
   27520:	100b883a 	mov	r5,r2
   27524:	0024fd00 	call	24fd0 <no_printf>
        
        tse_dprintf(6, "Status Register : 0x%02x\n", pphy_profiles[i]->status_reg_location); 
   27528:	e0bfff07 	ldb	r2,-4(fp)
   2752c:	00c00134 	movhi	r3,4
   27530:	18cdf004 	addi	r3,r3,14272
   27534:	1085883a 	add	r2,r2,r2
   27538:	1085883a 	add	r2,r2,r2
   2753c:	1885883a 	add	r2,r3,r2
   27540:	10800017 	ldw	r2,0(r2)
   27544:	10801583 	ldbu	r2,86(r2)
   27548:	10803fcc 	andi	r2,r2,255
   2754c:	010000f4 	movhi	r4,3
   27550:	213ef804 	addi	r4,r4,-1056
   27554:	100b883a 	mov	r5,r2
   27558:	0024fd00 	call	24fd0 <no_printf>
        
        tse_dprintf(6, "Speed Bit       : %d\n", pphy_profiles[i]->speed_lsb_location);
   2755c:	e0bfff07 	ldb	r2,-4(fp)
   27560:	00c00134 	movhi	r3,4
   27564:	18cdf004 	addi	r3,r3,14272
   27568:	1085883a 	add	r2,r2,r2
   2756c:	1085883a 	add	r2,r2,r2
   27570:	1885883a 	add	r2,r3,r2
   27574:	10800017 	ldw	r2,0(r2)
   27578:	108015c3 	ldbu	r2,87(r2)
   2757c:	10803fcc 	andi	r2,r2,255
   27580:	010000f4 	movhi	r4,3
   27584:	213eff04 	addi	r4,r4,-1028
   27588:	100b883a 	mov	r5,r2
   2758c:	0024fd00 	call	24fd0 <no_printf>
        
        tse_dprintf(6, "Duplex Bit      : %d\n", pphy_profiles[i]->duplex_bit_location);
   27590:	e0bfff07 	ldb	r2,-4(fp)
   27594:	00c00134 	movhi	r3,4
   27598:	18cdf004 	addi	r3,r3,14272
   2759c:	1085883a 	add	r2,r2,r2
   275a0:	1085883a 	add	r2,r2,r2
   275a4:	1885883a 	add	r2,r3,r2
   275a8:	10800017 	ldw	r2,0(r2)
   275ac:	10801603 	ldbu	r2,88(r2)
   275b0:	10803fcc 	andi	r2,r2,255
   275b4:	010000f4 	movhi	r4,3
   275b8:	213f0504 	addi	r4,r4,-1004
   275bc:	100b883a 	mov	r5,r2
   275c0:	0024fd00 	call	24fd0 <no_printf>
        
        tse_dprintf(6, "Link Bit        : %d\n\n", pphy_profiles[i]->link_bit_location);
   275c4:	e0bfff07 	ldb	r2,-4(fp)
   275c8:	00c00134 	movhi	r3,4
   275cc:	18cdf004 	addi	r3,r3,14272
   275d0:	1085883a 	add	r2,r2,r2
   275d4:	1085883a 	add	r2,r2,r2
   275d8:	1885883a 	add	r2,r3,r2
   275dc:	10800017 	ldw	r2,0(r2)
   275e0:	10801643 	ldbu	r2,89(r2)
   275e4:	10803fcc 	andi	r2,r2,255
   275e8:	010000f4 	movhi	r4,3
   275ec:	213f0b04 	addi	r4,r4,-980
   275f0:	100b883a 	mov	r5,r2
   275f4:	0024fd00 	call	24fd0 <no_printf>
   
	alt_8 i;
    /* display PHY in profile */
    tse_dprintf(6, "List of PHY profiles supported (Total profiles = %d)...\n", phy_profile_count);
    
    for(i = 0; i < phy_profile_count; i++)
   275f8:	e0bfff03 	ldbu	r2,-4(fp)
   275fc:	10800044 	addi	r2,r2,1
   27600:	e0bfff05 	stb	r2,-4(fp)
   27604:	e0ffff07 	ldb	r3,-4(fp)
   27608:	d0a8f703 	ldbu	r2,-23588(gp)
   2760c:	10803fcc 	andi	r2,r2,255
   27610:	18bf8f16 	blt	r3,r2,27450 <alt_tse_phy_print_profile+0x30>
        
        tse_dprintf(6, "Link Bit        : %d\n\n", pphy_profiles[i]->link_bit_location);
 
    }
    
    return phy_profile_count;
   27614:	d0a8f703 	ldbu	r2,-23588(gp)
   27618:	10803fcc 	andi	r2,r2,255
}
   2761c:	e037883a 	mov	sp,fp
   27620:	dfc00117 	ldw	ra,4(sp)
   27624:	df000017 	ldw	fp,0(sp)
   27628:	dec00204 	addi	sp,sp,8
   2762c:	f800283a 	ret

00027630 <alt_tse_mac_group_init>:
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      return SUCCESS
 *              return ALTERA_TSE_SYSTEM_DEF_ERROR if alt_tse_system_info structure definition error
 */
alt_32 alt_tse_mac_group_init() {
   27630:	defffa04 	addi	sp,sp,-24
   27634:	dfc00515 	stw	ra,20(sp)
   27638:	df000415 	stw	fp,16(sp)
   2763c:	df000404 	addi	fp,sp,16
    
	alt_8 i;
	alt_8 j;
    
    alt_tse_mac_group *pmac_group = 0;
   27640:	e03ffd15 	stw	zero,-12(fp)
    alt_tse_mac_info *pmac_info = 0;
   27644:	e03ffe15 	stw	zero,-8(fp)
    alt_tse_system_info *psys = 0;
   27648:	e03fff15 	stw	zero,-4(fp)

    /* reset number of MAC group */
    mac_group_count = 0;
   2764c:	d028f745 	stb	zero,-23587(gp)
    
    /* loop through every alt_tse_system_info structure */
    for(i = 0; i < max_mac_system; i++) {
   27650:	e03ffc05 	stb	zero,-16(fp)
   27654:	00019306 	br	27ca4 <alt_tse_mac_group_init+0x674>
        psys = &tse_mac_device[i];
   27658:	e0bffc07 	ldb	r2,-16(fp)
   2765c:	10c01224 	muli	r3,r2,72
   27660:	008000f4 	movhi	r2,3
   27664:	108c9004 	addi	r2,r2,12864
   27668:	1885883a 	add	r2,r3,r2
   2766c:	e0bfff15 	stw	r2,-4(fp)

        if((psys->tse_sgdma_tx != 0) && (psys->tse_sgdma_rx != 0)) {    	
   27670:	e0bfff17 	ldw	r2,-4(fp)
   27674:	10800517 	ldw	r2,20(r2)
   27678:	10018726 	beq	r2,zero,27c98 <alt_tse_mac_group_init+0x668>
   2767c:	e0bfff17 	ldw	r2,-4(fp)
   27680:	10800617 	ldw	r2,24(r2)
   27684:	10018426 	beq	r2,zero,27c98 <alt_tse_mac_group_init+0x668>
            tse_dprintf(5, "INFO    : TSE MAC %d found at address 0x%08x\n", mac_group_count, (int) psys->tse_mac_base);
   27688:	d0a8f743 	ldbu	r2,-23587(gp)
   2768c:	10c03fcc 	andi	r3,r2,255
   27690:	e0bfff17 	ldw	r2,-4(fp)
   27694:	10800017 	ldw	r2,0(r2)
   27698:	010000f4 	movhi	r4,3
   2769c:	213f1104 	addi	r4,r4,-956
   276a0:	180b883a 	mov	r5,r3
   276a4:	100d883a 	mov	r6,r2
   276a8:	0024fd00 	call	24fd0 <no_printf>
            
            /* Allocate memory for the structure */
            pmac_group = (alt_tse_mac_group *) malloc(sizeof(alt_tse_mac_group));
   276ac:	01000904 	movi	r4,36
   276b0:	002c1400 	call	2c140 <malloc>
   276b4:	e0bffd15 	stw	r2,-12(fp)
            if(!pmac_group) {
   276b8:	e0bffd17 	ldw	r2,-12(fp)
   276bc:	1000081e 	bne	r2,zero,276e0 <alt_tse_mac_group_init+0xb0>
                tse_dprintf(1, "ERROR   : Unable to allocate memory for MAC Group[%d]\n", mac_group_count);
   276c0:	d0a8f743 	ldbu	r2,-23587(gp)
   276c4:	10803fcc 	andi	r2,r2,255
   276c8:	010000f4 	movhi	r4,3
   276cc:	213f1d04 	addi	r4,r4,-908
   276d0:	100b883a 	mov	r5,r2
   276d4:	0024fd00 	call	24fd0 <no_printf>
                return ALTERA_TSE_MALLOC_FAILED;
   276d8:	00bfffc4 	movi	r2,-1
   276dc:	00017606 	br	27cb8 <alt_tse_mac_group_init+0x688>
            }
           
            /* Non-multi-channel MAC considered as 1 channel */
            if(psys->tse_multichannel_mac) {
   276e0:	e0bfff17 	ldw	r2,-4(fp)
   276e4:	108002c3 	ldbu	r2,11(r2)
   276e8:	10803fcc 	andi	r2,r2,255
   276ec:	10001226 	beq	r2,zero,27738 <alt_tse_mac_group_init+0x108>
                pmac_group->channel = psys->tse_num_of_channel;
   276f0:	e0bfff17 	ldw	r2,-4(fp)
   276f4:	10c00303 	ldbu	r3,12(r2)
   276f8:	e0bffd17 	ldw	r2,-12(fp)
   276fc:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = Yes\n");
   27700:	010000f4 	movhi	r4,3
   27704:	213f2b04 	addi	r4,r4,-852
   27708:	0024fd00 	call	24fd0 <no_printf>
                tse_dprintf(6, "INFO    : Number of channel        = %d\n", pmac_group->channel);
   2770c:	e0bffd17 	ldw	r2,-12(fp)
   27710:	10800003 	ldbu	r2,0(r2)
   27714:	10803fcc 	andi	r2,r2,255
   27718:	010000f4 	movhi	r4,3
   2771c:	213f3604 	addi	r4,r4,-808
   27720:	100b883a 	mov	r5,r2
   27724:	0024fd00 	call	24fd0 <no_printf>
            	tse_dprintf(6, "INFO    : MDIO Shared              = Yes\n");
   27728:	010000f4 	movhi	r4,3
   2772c:	213f4104 	addi	r4,r4,-764
   27730:	0024fd00 	call	24fd0 <no_printf>
   27734:	00001f06 	br	277b4 <alt_tse_mac_group_init+0x184>
            }
            else if(psys->tse_mdio_shared) {
   27738:	e0bfff17 	ldw	r2,-4(fp)
   2773c:	10800343 	ldbu	r2,13(r2)
   27740:	10803fcc 	andi	r2,r2,255
   27744:	10001226 	beq	r2,zero,27790 <alt_tse_mac_group_init+0x160>
                pmac_group->channel = psys->tse_number_of_mac_mdio_shared;
   27748:	e0bfff17 	ldw	r2,-4(fp)
   2774c:	10c00383 	ldbu	r3,14(r2)
   27750:	e0bffd17 	ldw	r2,-12(fp)
   27754:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
   27758:	010000f4 	movhi	r4,3
   2775c:	213f4c04 	addi	r4,r4,-720
   27760:	0024fd00 	call	24fd0 <no_printf>
                tse_dprintf(6, "INFO    : MDIO Shared              = Yes\n");
   27764:	010000f4 	movhi	r4,3
   27768:	213f4104 	addi	r4,r4,-764
   2776c:	0024fd00 	call	24fd0 <no_printf>
                tse_dprintf(6, "INFO    : Number of MAC Share MDIO = %d\n", pmac_group->channel);
   27770:	e0bffd17 	ldw	r2,-12(fp)
   27774:	10800003 	ldbu	r2,0(r2)
   27778:	10803fcc 	andi	r2,r2,255
   2777c:	010000f4 	movhi	r4,3
   27780:	213f5704 	addi	r4,r4,-676
   27784:	100b883a 	mov	r5,r2
   27788:	0024fd00 	call	24fd0 <no_printf>
   2778c:	00000906 	br	277b4 <alt_tse_mac_group_init+0x184>
            }
            else {
                pmac_group->channel = 1;
   27790:	e0bffd17 	ldw	r2,-12(fp)
   27794:	00c00044 	movi	r3,1
   27798:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
   2779c:	010000f4 	movhi	r4,3
   277a0:	213f4c04 	addi	r4,r4,-720
   277a4:	0024fd00 	call	24fd0 <no_printf>
                tse_dprintf(6, "INFO    : MDIO Shared              = No\n");
   277a8:	010000f4 	movhi	r4,3
   277ac:	213f6204 	addi	r4,r4,-632
   277b0:	0024fd00 	call	24fd0 <no_printf>
            }
            
            for(j = 0; j < pmac_group->channel; j++) {
   277b4:	e03ffc45 	stb	zero,-15(fp)
   277b8:	00012006 	br	27c3c <alt_tse_mac_group_init+0x60c>
                /* Allocate memory for the structure */
                pmac_info = (alt_tse_mac_info *) malloc(sizeof(alt_tse_mac_info));
   277bc:	01000404 	movi	r4,16
   277c0:	002c1400 	call	2c140 <malloc>
   277c4:	e0bffe15 	stw	r2,-8(fp)
                if(!pmac_info) {
   277c8:	e0bffe17 	ldw	r2,-8(fp)
   277cc:	10000a1e 	bne	r2,zero,277f8 <alt_tse_mac_group_init+0x1c8>
                    tse_dprintf(1, "ERROR   : Unable to allocate memory for MAC Group[%d]->pmac_info[%d]\n", mac_group_count, j);
   277d0:	d0a8f743 	ldbu	r2,-23587(gp)
   277d4:	10c03fcc 	andi	r3,r2,255
   277d8:	e0bffc47 	ldb	r2,-15(fp)
   277dc:	010000f4 	movhi	r4,3
   277e0:	213f6d04 	addi	r4,r4,-588
   277e4:	180b883a 	mov	r5,r3
   277e8:	100d883a 	mov	r6,r2
   277ec:	0024fd00 	call	24fd0 <no_printf>
                    return ALTERA_TSE_MALLOC_FAILED;
   277f0:	00bfffc4 	movi	r2,-1
   277f4:	00013006 	br	27cb8 <alt_tse_mac_group_init+0x688>
                }
                
                pmac_info->pmac_group = pmac_group;
   277f8:	e0bffe17 	ldw	r2,-8(fp)
   277fc:	e0fffd17 	ldw	r3,-12(fp)
   27800:	10c00315 	stw	r3,12(r2)
                
                pmac_info->pphy_info = 0;
   27804:	e0bffe17 	ldw	r2,-8(fp)
   27808:	10000115 	stw	zero,4(r2)
                
                pmac_info->psys_info = &tse_mac_device[i + j];
   2780c:	e0fffc07 	ldb	r3,-16(fp)
   27810:	e0bffc47 	ldb	r2,-15(fp)
   27814:	1885883a 	add	r2,r3,r2
   27818:	10c01224 	muli	r3,r2,72
   2781c:	008000f4 	movhi	r2,3
   27820:	108c9004 	addi	r2,r2,12864
   27824:	1887883a 	add	r3,r3,r2
   27828:	e0bffe17 	ldw	r2,-8(fp)
   2782c:	10c00215 	stw	r3,8(r2)
                
                /* check to make sure the alt_tse_system_info defined correctly or has been defined */
                if((pmac_info->psys_info->tse_sgdma_tx == 0) || (pmac_info->psys_info->tse_sgdma_rx == 0)){                	
   27830:	e0bffe17 	ldw	r2,-8(fp)
   27834:	10800217 	ldw	r2,8(r2)
   27838:	10800517 	ldw	r2,20(r2)
   2783c:	10000426 	beq	r2,zero,27850 <alt_tse_mac_group_init+0x220>
   27840:	e0bffe17 	ldw	r2,-8(fp)
   27844:	10800217 	ldw	r2,8(r2)
   27848:	10800617 	ldw	r2,24(r2)
   2784c:	1000091e 	bne	r2,zero,27874 <alt_tse_mac_group_init+0x244>
                    tse_dprintf(2, "ERROR   : tse_mac_device[%d] does not defined correctly!\n", i + j);
   27850:	e0fffc07 	ldb	r3,-16(fp)
   27854:	e0bffc47 	ldb	r2,-15(fp)
   27858:	1885883a 	add	r2,r3,r2
   2785c:	010000f4 	movhi	r4,3
   27860:	213f7f04 	addi	r4,r4,-516
   27864:	100b883a 	mov	r5,r2
   27868:	0024fd00 	call	24fd0 <no_printf>
                    return ALTERA_TSE_SYSTEM_DEF_ERROR;
   2786c:	00bfffc4 	movi	r2,-1
   27870:	00011106 	br	27cb8 <alt_tse_mac_group_init+0x688>
                }
                
                /* MAC type detection */
                if(pmac_info->psys_info->tse_en_maclite) {
   27874:	e0bffe17 	ldw	r2,-8(fp)
   27878:	10800217 	ldw	r2,8(r2)
   2787c:	10800243 	ldbu	r2,9(r2)
   27880:	10803fcc 	andi	r2,r2,255
   27884:	10000d26 	beq	r2,zero,278bc <alt_tse_mac_group_init+0x28c>
                    if(pmac_info->psys_info->tse_maclite_gige) {
   27888:	e0bffe17 	ldw	r2,-8(fp)
   2788c:	10800217 	ldw	r2,8(r2)
   27890:	10800283 	ldbu	r2,10(r2)
   27894:	10803fcc 	andi	r2,r2,255
   27898:	10000426 	beq	r2,zero,278ac <alt_tse_mac_group_init+0x27c>
                        pmac_info->mac_type = ALTERA_TSE_MACLITE_1000;
   2789c:	e0bffe17 	ldw	r2,-8(fp)
   278a0:	00c00084 	movi	r3,2
   278a4:	10c00005 	stb	r3,0(r2)
   278a8:	00000606 	br	278c4 <alt_tse_mac_group_init+0x294>
                    }
                    else {
                        pmac_info->mac_type = ALTERA_TSE_MACLITE_10_100;
   278ac:	e0bffe17 	ldw	r2,-8(fp)
   278b0:	00c00044 	movi	r3,1
   278b4:	10c00005 	stb	r3,0(r2)
   278b8:	00000206 	br	278c4 <alt_tse_mac_group_init+0x294>
                    }
                }
                else {
                    pmac_info->mac_type = ALTERA_TSE_FULL_MAC;                    
   278bc:	e0bffe17 	ldw	r2,-8(fp)
   278c0:	10000005 	stb	zero,0(r2)
                }
                
                if((pmac_info->psys_info->tse_mdio_shared) && (!pmac_info->psys_info->tse_multichannel_mac)){
   278c4:	e0bffe17 	ldw	r2,-8(fp)
   278c8:	10800217 	ldw	r2,8(r2)
   278cc:	10800343 	ldbu	r2,13(r2)
   278d0:	10803fcc 	andi	r2,r2,255
   278d4:	10006526 	beq	r2,zero,27a6c <alt_tse_mac_group_init+0x43c>
   278d8:	e0bffe17 	ldw	r2,-8(fp)
   278dc:	10800217 	ldw	r2,8(r2)
   278e0:	108002c3 	ldbu	r2,11(r2)
   278e4:	10803fcc 	andi	r2,r2,255
   278e8:	1000601e 	bne	r2,zero,27a6c <alt_tse_mac_group_init+0x43c>
                	tse_dprintf(6, "INFO    : MAC %2d Address           = 0x%08x\n", j, (int) pmac_info->psys_info->tse_mac_base);
   278ec:	e0fffc47 	ldb	r3,-15(fp)
   278f0:	e0bffe17 	ldw	r2,-8(fp)
   278f4:	10800217 	ldw	r2,8(r2)
   278f8:	10800017 	ldw	r2,0(r2)
   278fc:	010000f4 	movhi	r4,3
   27900:	213f8e04 	addi	r4,r4,-456
   27904:	180b883a 	mov	r5,r3
   27908:	100d883a 	mov	r6,r2
   2790c:	0024fd00 	call	24fd0 <no_printf>
                    tse_dprintf(6, "INFO    : MAC %2d Device            = tse_mac_device[%d]\n", j, i + j);
   27910:	e0fffc47 	ldb	r3,-15(fp)
   27914:	e13ffc07 	ldb	r4,-16(fp)
   27918:	e0bffc47 	ldb	r2,-15(fp)
   2791c:	2085883a 	add	r2,r4,r2
   27920:	010000f4 	movhi	r4,3
   27924:	213f9a04 	addi	r4,r4,-408
   27928:	180b883a 	mov	r5,r3
   2792c:	100d883a 	mov	r6,r2
   27930:	0024fd00 	call	24fd0 <no_printf>
                    
                	switch(pmac_info->mac_type) {
   27934:	e0bffe17 	ldw	r2,-8(fp)
   27938:	10800003 	ldbu	r2,0(r2)
   2793c:	10803fcc 	andi	r2,r2,255
   27940:	10c00060 	cmpeqi	r3,r2,1
   27944:	18000c1e 	bne	r3,zero,27978 <alt_tse_mac_group_init+0x348>
   27948:	10c000a0 	cmpeqi	r3,r2,2
   2794c:	1800021e 	bne	r3,zero,27958 <alt_tse_mac_group_init+0x328>
   27950:	10001126 	beq	r2,zero,27998 <alt_tse_mac_group_init+0x368>
   27954:	00001806 	br	279b8 <alt_tse_mac_group_init+0x388>
                        case ALTERA_TSE_MACLITE_1000:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "1000 Mbps Small MAC");
   27958:	e0bffc47 	ldb	r2,-15(fp)
   2795c:	010000f4 	movhi	r4,3
   27960:	213fa904 	addi	r4,r4,-348
   27964:	100b883a 	mov	r5,r2
   27968:	018000f4 	movhi	r6,3
   2796c:	31bfb404 	addi	r6,r6,-304
   27970:	0024fd00 	call	24fd0 <no_printf>
                            break;
   27974:	00001706 	br	279d4 <alt_tse_mac_group_init+0x3a4>
                        case ALTERA_TSE_MACLITE_10_100:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "10/100 Mbps Small MAC");
   27978:	e0bffc47 	ldb	r2,-15(fp)
   2797c:	010000f4 	movhi	r4,3
   27980:	213fa904 	addi	r4,r4,-348
   27984:	100b883a 	mov	r5,r2
   27988:	018000f4 	movhi	r6,3
   2798c:	31bfb904 	addi	r6,r6,-284
   27990:	0024fd00 	call	24fd0 <no_printf>
                            break;
   27994:	00000f06 	br	279d4 <alt_tse_mac_group_init+0x3a4>
                        case ALTERA_TSE_FULL_MAC:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "10/100/1000 Ethernet MAC");
   27998:	e0bffc47 	ldb	r2,-15(fp)
   2799c:	010000f4 	movhi	r4,3
   279a0:	213fa904 	addi	r4,r4,-348
   279a4:	100b883a 	mov	r5,r2
   279a8:	018000f4 	movhi	r6,3
   279ac:	31bfbf04 	addi	r6,r6,-260
   279b0:	0024fd00 	call	24fd0 <no_printf>
                            break;
   279b4:	00000706 	br	279d4 <alt_tse_mac_group_init+0x3a4>
                        default :
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "Unknown");
   279b8:	e0bffc47 	ldb	r2,-15(fp)
   279bc:	010000f4 	movhi	r4,3
   279c0:	213fa904 	addi	r4,r4,-348
   279c4:	100b883a 	mov	r5,r2
   279c8:	018000f4 	movhi	r6,3
   279cc:	31bdf704 	addi	r6,r6,-2084
   279d0:	0024fd00 	call	24fd0 <no_printf>
                    }
                    
                    if(pmac_info->psys_info->tse_pcs_ena) {
   279d4:	e0bffe17 	ldw	r2,-8(fp)
   279d8:	10800217 	ldw	r2,8(r2)
   279dc:	108003c3 	ldbu	r2,15(r2)
   279e0:	10803fcc 	andi	r2,r2,255
   279e4:	10008a26 	beq	r2,zero,27c10 <alt_tse_mac_group_init+0x5e0>
                        tse_dprintf(6, "INFO    : PCS %2d Enable            = %s\n", j, pmac_info->psys_info->tse_pcs_ena ? "Yes" : "No");
   279e8:	e0fffc47 	ldb	r3,-15(fp)
   279ec:	e0bffe17 	ldw	r2,-8(fp)
   279f0:	10800217 	ldw	r2,8(r2)
   279f4:	108003c3 	ldbu	r2,15(r2)
   279f8:	10803fcc 	andi	r2,r2,255
   279fc:	10000326 	beq	r2,zero,27a0c <alt_tse_mac_group_init+0x3dc>
   27a00:	008000f4 	movhi	r2,3
   27a04:	10bfc604 	addi	r2,r2,-232
   27a08:	00000206 	br	27a14 <alt_tse_mac_group_init+0x3e4>
   27a0c:	008000f4 	movhi	r2,3
   27a10:	10bfc704 	addi	r2,r2,-228
   27a14:	010000f4 	movhi	r4,3
   27a18:	213fc804 	addi	r4,r4,-224
   27a1c:	180b883a 	mov	r5,r3
   27a20:	100d883a 	mov	r6,r2
   27a24:	0024fd00 	call	24fd0 <no_printf>
                        tse_dprintf(6, "INFO    : PCS %2d SGMII Enable      = %s\n", j, pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");                        
   27a28:	e0fffc47 	ldb	r3,-15(fp)
   27a2c:	e0bffe17 	ldw	r2,-8(fp)
   27a30:	10800217 	ldw	r2,8(r2)
   27a34:	10800403 	ldbu	r2,16(r2)
   27a38:	10803fcc 	andi	r2,r2,255
   27a3c:	10000326 	beq	r2,zero,27a4c <alt_tse_mac_group_init+0x41c>
   27a40:	008000f4 	movhi	r2,3
   27a44:	10bfc604 	addi	r2,r2,-232
   27a48:	00000206 	br	27a54 <alt_tse_mac_group_init+0x424>
   27a4c:	008000f4 	movhi	r2,3
   27a50:	10bfc704 	addi	r2,r2,-228
   27a54:	010000f4 	movhi	r4,3
   27a58:	213fd304 	addi	r4,r4,-180
   27a5c:	180b883a 	mov	r5,r3
   27a60:	100d883a 	mov	r6,r2
   27a64:	0024fd00 	call	24fd0 <no_printf>
                            break;
                        default :
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "Unknown");
                    }
                    
                    if(pmac_info->psys_info->tse_pcs_ena) {
   27a68:	00006906 	br	27c10 <alt_tse_mac_group_init+0x5e0>
                        tse_dprintf(6, "INFO    : PCS %2d SGMII Enable      = %s\n", j, pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");                        
                    }
                }
                else {
                	/* display only once for all MAC, except shared MDIO MACs */
	                if(j == 0) {
   27a6c:	e0bffc47 	ldb	r2,-15(fp)
   27a70:	1000411e 	bne	r2,zero,27b78 <alt_tse_mac_group_init+0x548>
	                    switch(pmac_info->mac_type) {
   27a74:	e0bffe17 	ldw	r2,-8(fp)
   27a78:	10800003 	ldbu	r2,0(r2)
   27a7c:	10803fcc 	andi	r2,r2,255
   27a80:	10c00060 	cmpeqi	r3,r2,1
   27a84:	18000a1e 	bne	r3,zero,27ab0 <alt_tse_mac_group_init+0x480>
   27a88:	10c000a0 	cmpeqi	r3,r2,2
   27a8c:	1800021e 	bne	r3,zero,27a98 <alt_tse_mac_group_init+0x468>
   27a90:	10000d26 	beq	r2,zero,27ac8 <alt_tse_mac_group_init+0x498>
   27a94:	00001206 	br	27ae0 <alt_tse_mac_group_init+0x4b0>
	                        case ALTERA_TSE_MACLITE_1000:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "1000 Mbps Small MAC");
   27a98:	010000f4 	movhi	r4,3
   27a9c:	213fde04 	addi	r4,r4,-136
   27aa0:	014000f4 	movhi	r5,3
   27aa4:	297fb404 	addi	r5,r5,-304
   27aa8:	0024fd00 	call	24fd0 <no_printf>
	                            break;
   27aac:	00001106 	br	27af4 <alt_tse_mac_group_init+0x4c4>
	                        case ALTERA_TSE_MACLITE_10_100:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "10/100 Mbps Small MAC");
   27ab0:	010000f4 	movhi	r4,3
   27ab4:	213fde04 	addi	r4,r4,-136
   27ab8:	014000f4 	movhi	r5,3
   27abc:	297fb904 	addi	r5,r5,-284
   27ac0:	0024fd00 	call	24fd0 <no_printf>
	                            break;
   27ac4:	00000b06 	br	27af4 <alt_tse_mac_group_init+0x4c4>
	                        case ALTERA_TSE_FULL_MAC:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "10/100/1000 Ethernet MAC");
   27ac8:	010000f4 	movhi	r4,3
   27acc:	213fde04 	addi	r4,r4,-136
   27ad0:	014000f4 	movhi	r5,3
   27ad4:	297fbf04 	addi	r5,r5,-260
   27ad8:	0024fd00 	call	24fd0 <no_printf>
	                            break;
   27adc:	00000506 	br	27af4 <alt_tse_mac_group_init+0x4c4>
	                        default :
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "Unknown");
   27ae0:	010000f4 	movhi	r4,3
   27ae4:	213fde04 	addi	r4,r4,-136
   27ae8:	014000f4 	movhi	r5,3
   27aec:	297df704 	addi	r5,r5,-2084
   27af0:	0024fd00 	call	24fd0 <no_printf>
	                    }
	                    
	                    if(pmac_info->psys_info->tse_pcs_ena) {
   27af4:	e0bffe17 	ldw	r2,-8(fp)
   27af8:	10800217 	ldw	r2,8(r2)
   27afc:	108003c3 	ldbu	r2,15(r2)
   27b00:	10803fcc 	andi	r2,r2,255
   27b04:	10001c26 	beq	r2,zero,27b78 <alt_tse_mac_group_init+0x548>
	                        tse_dprintf(6, "INFO    : PCS Enable               = %s\n", pmac_info->psys_info->tse_pcs_ena ? "Yes" : "No");
   27b08:	e0bffe17 	ldw	r2,-8(fp)
   27b0c:	10800217 	ldw	r2,8(r2)
   27b10:	108003c3 	ldbu	r2,15(r2)
   27b14:	10803fcc 	andi	r2,r2,255
   27b18:	10000326 	beq	r2,zero,27b28 <alt_tse_mac_group_init+0x4f8>
   27b1c:	008000f4 	movhi	r2,3
   27b20:	10bfc604 	addi	r2,r2,-232
   27b24:	00000206 	br	27b30 <alt_tse_mac_group_init+0x500>
   27b28:	008000f4 	movhi	r2,3
   27b2c:	10bfc704 	addi	r2,r2,-228
   27b30:	010000f4 	movhi	r4,3
   27b34:	213fe904 	addi	r4,r4,-92
   27b38:	100b883a 	mov	r5,r2
   27b3c:	0024fd00 	call	24fd0 <no_printf>
	                        tse_dprintf(6, "INFO    : PCS SGMII Enable         = %s\n", pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");	                        
   27b40:	e0bffe17 	ldw	r2,-8(fp)
   27b44:	10800217 	ldw	r2,8(r2)
   27b48:	10800403 	ldbu	r2,16(r2)
   27b4c:	10803fcc 	andi	r2,r2,255
   27b50:	10000326 	beq	r2,zero,27b60 <alt_tse_mac_group_init+0x530>
   27b54:	008000f4 	movhi	r2,3
   27b58:	10bfc604 	addi	r2,r2,-232
   27b5c:	00000206 	br	27b68 <alt_tse_mac_group_init+0x538>
   27b60:	008000f4 	movhi	r2,3
   27b64:	10bfc704 	addi	r2,r2,-228
   27b68:	010000f4 	movhi	r4,3
   27b6c:	213ff404 	addi	r4,r4,-48
   27b70:	100b883a 	mov	r5,r2
   27b74:	0024fd00 	call	24fd0 <no_printf>
	                    }
	                }
	                
                	if(pmac_info->psys_info->tse_multichannel_mac) {
   27b78:	e0bffe17 	ldw	r2,-8(fp)
   27b7c:	10800217 	ldw	r2,8(r2)
   27b80:	108002c3 	ldbu	r2,11(r2)
   27b84:	10803fcc 	andi	r2,r2,255
   27b88:	10001326 	beq	r2,zero,27bd8 <alt_tse_mac_group_init+0x5a8>
                		tse_dprintf(6, "INFO    : Channel %2d Address       = 0x%08x\n", j, (int) pmac_info->psys_info->tse_mac_base);
   27b8c:	e0fffc47 	ldb	r3,-15(fp)
   27b90:	e0bffe17 	ldw	r2,-8(fp)
   27b94:	10800217 	ldw	r2,8(r2)
   27b98:	10800017 	ldw	r2,0(r2)
   27b9c:	010000f4 	movhi	r4,3
   27ba0:	213fff04 	addi	r4,r4,-4
   27ba4:	180b883a 	mov	r5,r3
   27ba8:	100d883a 	mov	r6,r2
   27bac:	0024fd00 	call	24fd0 <no_printf>
	                    tse_dprintf(6, "INFO    : Channel %2d Device        = tse_mac_device[%d]\n", j, i + j);
   27bb0:	e0fffc47 	ldb	r3,-15(fp)
   27bb4:	e13ffc07 	ldb	r4,-16(fp)
   27bb8:	e0bffc47 	ldb	r2,-15(fp)
   27bbc:	2085883a 	add	r2,r4,r2
   27bc0:	010000f4 	movhi	r4,3
   27bc4:	21000b04 	addi	r4,r4,44
   27bc8:	180b883a 	mov	r5,r3
   27bcc:	100d883a 	mov	r6,r2
   27bd0:	0024fd00 	call	24fd0 <no_printf>
   27bd4:	00000e06 	br	27c10 <alt_tse_mac_group_init+0x5e0>
	            	}                
	                else {
	                    tse_dprintf(6, "INFO    : MAC Address              = 0x%08x\n", (int) pmac_info->psys_info->tse_mac_base);
   27bd8:	e0bffe17 	ldw	r2,-8(fp)
   27bdc:	10800217 	ldw	r2,8(r2)
   27be0:	10800017 	ldw	r2,0(r2)
   27be4:	010000f4 	movhi	r4,3
   27be8:	21001a04 	addi	r4,r4,104
   27bec:	100b883a 	mov	r5,r2
   27bf0:	0024fd00 	call	24fd0 <no_printf>
	                    tse_dprintf(6, "INFO    : MAC Device               = tse_mac_device[%d]\n", i + j);
   27bf4:	e0fffc07 	ldb	r3,-16(fp)
   27bf8:	e0bffc47 	ldb	r2,-15(fp)
   27bfc:	1885883a 	add	r2,r3,r2
   27c00:	010000f4 	movhi	r4,3
   27c04:	21002604 	addi	r4,r4,152
   27c08:	100b883a 	mov	r5,r2
   27c0c:	0024fd00 	call	24fd0 <no_printf>
	                }
                }
                
                /* store the pointer in MAC group variable for the detected channel */
                pmac_group->pmac_info[j] = pmac_info;
   27c10:	e0bffc47 	ldb	r2,-15(fp)
   27c14:	e0fffd17 	ldw	r3,-12(fp)
   27c18:	10800044 	addi	r2,r2,1
   27c1c:	1085883a 	add	r2,r2,r2
   27c20:	1085883a 	add	r2,r2,r2
   27c24:	1885883a 	add	r2,r3,r2
   27c28:	e0fffe17 	ldw	r3,-8(fp)
   27c2c:	10c00015 	stw	r3,0(r2)
                pmac_group->channel = 1;
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
                tse_dprintf(6, "INFO    : MDIO Shared              = No\n");
            }
            
            for(j = 0; j < pmac_group->channel; j++) {
   27c30:	e0bffc43 	ldbu	r2,-15(fp)
   27c34:	10800044 	addi	r2,r2,1
   27c38:	e0bffc45 	stb	r2,-15(fp)
   27c3c:	e0fffc47 	ldb	r3,-15(fp)
   27c40:	e0bffd17 	ldw	r2,-12(fp)
   27c44:	10800003 	ldbu	r2,0(r2)
   27c48:	10803fcc 	andi	r2,r2,255
   27c4c:	18bedb16 	blt	r3,r2,277bc <alt_tse_mac_group_init+0x18c>
                /* store the pointer in MAC group variable for the detected channel */
                pmac_group->pmac_info[j] = pmac_info;
            }
            
            /* store the pointer in global variable */
            pmac_groups[mac_group_count] = pmac_group;
   27c50:	d0a8f743 	ldbu	r2,-23587(gp)
   27c54:	10803fcc 	andi	r2,r2,255
   27c58:	00c00134 	movhi	r3,4
   27c5c:	18cde804 	addi	r3,r3,14240
   27c60:	1085883a 	add	r2,r2,r2
   27c64:	1085883a 	add	r2,r2,r2
   27c68:	1885883a 	add	r2,r3,r2
   27c6c:	e0fffd17 	ldw	r3,-12(fp)
   27c70:	10c00015 	stw	r3,0(r2)
            
            mac_group_count++;
   27c74:	d0a8f743 	ldbu	r2,-23587(gp)
   27c78:	10800044 	addi	r2,r2,1
   27c7c:	d0a8f745 	stb	r2,-23587(gp)

            /* skip for subsequent Multi-channel MAC */
            i += (pmac_group->channel - 1);
   27c80:	e0bffd17 	ldw	r2,-12(fp)
   27c84:	10c00003 	ldbu	r3,0(r2)
   27c88:	e0bffc03 	ldbu	r2,-16(fp)
   27c8c:	1885883a 	add	r2,r3,r2
   27c90:	10bfffc4 	addi	r2,r2,-1
   27c94:	e0bffc05 	stb	r2,-16(fp)

    /* reset number of MAC group */
    mac_group_count = 0;
    
    /* loop through every alt_tse_system_info structure */
    for(i = 0; i < max_mac_system; i++) {
   27c98:	e0bffc03 	ldbu	r2,-16(fp)
   27c9c:	10800044 	addi	r2,r2,1
   27ca0:	e0bffc05 	stb	r2,-16(fp)
   27ca4:	e0fffc07 	ldb	r3,-16(fp)
   27ca8:	d0a01b03 	ldbu	r2,-32660(gp)
   27cac:	10803fcc 	andi	r2,r2,255
   27cb0:	18be6916 	blt	r3,r2,27658 <alt_tse_mac_group_init+0x28>
            /* skip for subsequent Multi-channel MAC */
            i += (pmac_group->channel - 1);
                        
        }
    }
    return SUCCESS;
   27cb4:	0005883a 	mov	r2,zero
}
   27cb8:	e037883a 	mov	sp,fp
   27cbc:	dfc00117 	ldw	ra,4(sp)
   27cc0:	df000017 	ldw	fp,0(sp)
   27cc4:	dec00204 	addi	sp,sp,8
   27cc8:	f800283a 	ret

00027ccc <alt_tse_mac_get_phy>:
/* @Function Description: Store information of all the PHYs connected to MAC to phy_list
 * @API Type:         Internal
 * @param pmac_group  Pointer to the TSE MAC grouping structure
 * @return            Number of PHY not in profile, return ALTERA_TSE_MALLOC_FAILED if memory allocation failed
 */
alt_32 alt_tse_mac_get_phy(alt_tse_mac_group *pmac_group) {
   27ccc:	deffed04 	addi	sp,sp,-76
   27cd0:	dfc01215 	stw	ra,72(sp)
   27cd4:	df001115 	stw	fp,68(sp)
   27cd8:	df001104 	addi	fp,sp,68
   27cdc:	e13fff15 	stw	r4,-4(fp)
    
	alt_32 phyid; 
	alt_32 phyid2 = 0;
   27ce0:	e03ff515 	stw	zero,-44(fp)
    alt_u8 revision_number;

    alt_32 i;

    alt_u8 is_phy_in_profile;
    alt_32 return_value = 0;
   27ce4:	e03ff315 	stw	zero,-52(fp)
    
    alt_8 phy_info_count = 0;
   27ce8:	e03ff405 	stb	zero,-48(fp)
    
    alt_tse_phy_info *pphy = 0;
   27cec:	e03ff615 	stw	zero,-40(fp)
    alt_tse_mac_info *pmac_info = 0;
   27cf0:	e03ff715 	stw	zero,-36(fp)
    alt_tse_system_info *psys = 0;
   27cf4:	e03ff815 	stw	zero,-32(fp)
    
    np_tse_mac *pmac_group_base = (np_tse_mac *) pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   27cf8:	e0bfff17 	ldw	r2,-4(fp)
   27cfc:	10800117 	ldw	r2,4(r2)
   27d00:	10800217 	ldw	r2,8(r2)
   27d04:	10800017 	ldw	r2,0(r2)
   27d08:	e0bff915 	stw	r2,-28(fp)
            
    /* Record previous MDIO address, to be restored at the end of function */
    alt_32 mdioadd_prev = IORD(&pmac_group_base->MDIO_ADDR1, 0);
   27d0c:	e0bff917 	ldw	r2,-28(fp)
   27d10:	10801004 	addi	r2,r2,64
   27d14:	10800037 	ldwio	r2,0(r2)
   27d18:	e0bffa15 	stw	r2,-24(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
   27d1c:	e13fff17 	ldw	r4,-4(fp)
   27d20:	00261440 	call	26144 <alt_tse_get_mac_group_index>
   27d24:	e0bffb05 	stb	r2,-20(fp)
    
    /* loop all valid PHY address to look for connected PHY */
    for (phyadd = 0x00; phyadd < 0x20; phyadd++)
   27d28:	e03ff005 	stb	zero,-64(fp)
   27d2c:	0000ca06 	br	28058 <alt_tse_mac_get_phy+0x38c>
    {        
        IOWR(&pmac_group_base->MDIO_ADDR1, 0, phyadd);
   27d30:	e0bff917 	ldw	r2,-28(fp)
   27d34:	10801004 	addi	r2,r2,64
   27d38:	e0fff003 	ldbu	r3,-64(fp)
   27d3c:	10c00035 	stwio	r3,0(r2)
        phyid = IORD(&pmac_group_base->mdio1.PHY_ID1,0);     // read PHY ID
   27d40:	e0bff917 	ldw	r2,-28(fp)
   27d44:	1080a204 	addi	r2,r2,648
   27d48:	10800037 	ldwio	r2,0(r2)
   27d4c:	e0bffc15 	stw	r2,-16(fp)
        phyid2 = IORD(&pmac_group_base->mdio1.PHY_ID2,0);     // read PHY ID
   27d50:	e0bff917 	ldw	r2,-28(fp)
   27d54:	1080a304 	addi	r2,r2,652
   27d58:	10800037 	ldwio	r2,0(r2)
   27d5c:	e0bff515 	stw	r2,-44(fp)
        
        /* PHY found */
        if (phyid != phyid2)
   27d60:	e0fffc17 	ldw	r3,-16(fp)
   27d64:	e0bff517 	ldw	r2,-44(fp)
   27d68:	1880b826 	beq	r3,r2,2804c <alt_tse_mac_get_phy+0x380>
        {
            pphy = (alt_tse_phy_info *) malloc(sizeof(alt_tse_phy_info));
   27d6c:	01000704 	movi	r4,28
   27d70:	002c1400 	call	2c140 <malloc>
   27d74:	e0bff615 	stw	r2,-40(fp)
            if(!pphy) {
   27d78:	e0bff617 	ldw	r2,-40(fp)
   27d7c:	1000091e 	bne	r2,zero,27da4 <alt_tse_mac_get_phy+0xd8>
                tse_dprintf(1, "ERROR   : Unable to allocate memory for phy_info[%d.%d]\n", mac_group_index, phy_info_count);
   27d80:	e0fffb07 	ldb	r3,-20(fp)
   27d84:	e0bff407 	ldb	r2,-48(fp)
   27d88:	010000f4 	movhi	r4,3
   27d8c:	21003504 	addi	r4,r4,212
   27d90:	180b883a 	mov	r5,r3
   27d94:	100d883a 	mov	r6,r2
   27d98:	0024fd00 	call	24fd0 <no_printf>
                return ALTERA_TSE_MALLOC_FAILED;
   27d9c:	00bfffc4 	movi	r2,-1
   27da0:	0000cc06 	br	280d4 <alt_tse_mac_get_phy+0x408>
            }
            
            /* store PHY address */
            pphy->mdio_address = phyadd;
   27da4:	e0bff617 	ldw	r2,-40(fp)
   27da8:	e0fff003 	ldbu	r3,-64(fp)
   27dac:	10c00005 	stb	r3,0(r2)

            /* get oui, model number, and revision number from PHYID and PHYID2 */
            oui = (phyid << 6) | ((phyid2 >> 10) & 0x3f);
   27db0:	e0bffc17 	ldw	r2,-16(fp)
   27db4:	100691ba 	slli	r3,r2,6
   27db8:	e0bff517 	ldw	r2,-44(fp)
   27dbc:	1005d2ba 	srai	r2,r2,10
   27dc0:	10800fcc 	andi	r2,r2,63
   27dc4:	1884b03a 	or	r2,r3,r2
   27dc8:	e0bffd15 	stw	r2,-12(fp)
            model_number = (phyid2 >> 4) & 0x3f;
   27dcc:	e0bff517 	ldw	r2,-44(fp)
   27dd0:	1005d13a 	srai	r2,r2,4
   27dd4:	10800fcc 	andi	r2,r2,63
   27dd8:	e0bffe05 	stb	r2,-8(fp)
            revision_number = phyid2 & 0x0f;
   27ddc:	e0bff517 	ldw	r2,-44(fp)
   27de0:	108003cc 	andi	r2,r2,15
   27de4:	e0bffe45 	stb	r2,-7(fp)
			
            /* map the PHY with PHY in profile */
            is_phy_in_profile = 0;
   27de8:	e03ff205 	stb	zero,-56(fp)
            for(i = 0; i < phy_profile_count; i++) {
   27dec:	e03ff115 	stw	zero,-60(fp)
   27df0:	00003306 	br	27ec0 <alt_tse_mac_get_phy+0x1f4>
                
                /* if PHY match with PHY in profile */
                if((pphy_profiles[i]->oui == oui) && (pphy_profiles[i]->model_number == model_number))
   27df4:	00c00134 	movhi	r3,4
   27df8:	18cdf004 	addi	r3,r3,14272
   27dfc:	e0bff117 	ldw	r2,-60(fp)
   27e00:	1085883a 	add	r2,r2,r2
   27e04:	1085883a 	add	r2,r2,r2
   27e08:	1885883a 	add	r2,r3,r2
   27e0c:	10800017 	ldw	r2,0(r2)
   27e10:	10c01417 	ldw	r3,80(r2)
   27e14:	e0bffd17 	ldw	r2,-12(fp)
   27e18:	1880261e 	bne	r3,r2,27eb4 <alt_tse_mac_get_phy+0x1e8>
   27e1c:	00c00134 	movhi	r3,4
   27e20:	18cdf004 	addi	r3,r3,14272
   27e24:	e0bff117 	ldw	r2,-60(fp)
   27e28:	1085883a 	add	r2,r2,r2
   27e2c:	1085883a 	add	r2,r2,r2
   27e30:	1885883a 	add	r2,r3,r2
   27e34:	10800017 	ldw	r2,0(r2)
   27e38:	10801503 	ldbu	r2,84(r2)
   27e3c:	10c03fcc 	andi	r3,r2,255
   27e40:	e0bffe03 	ldbu	r2,-8(fp)
   27e44:	18801b1e 	bne	r3,r2,27eb4 <alt_tse_mac_get_phy+0x1e8>
                {
                    pphy->pphy_profile = pphy_profiles[i];
   27e48:	00c00134 	movhi	r3,4
   27e4c:	18cdf004 	addi	r3,r3,14272
   27e50:	e0bff117 	ldw	r2,-60(fp)
   27e54:	1085883a 	add	r2,r2,r2
   27e58:	1085883a 	add	r2,r2,r2
   27e5c:	1885883a 	add	r2,r3,r2
   27e60:	10c00017 	ldw	r3,0(r2)
   27e64:	e0bff617 	ldw	r2,-40(fp)
   27e68:	10c00515 	stw	r3,20(r2)
                    
                    /* PHY found, add it to phy_list */
                    tse_dprintf(5, "INFO    : PHY %s found at PHY address 0x%02x of MAC Group[%d]\n", pphy_profiles[i]->name, phyadd, mac_group_index);
   27e6c:	00c00134 	movhi	r3,4
   27e70:	18cdf004 	addi	r3,r3,14272
   27e74:	e0bff117 	ldw	r2,-60(fp)
   27e78:	1085883a 	add	r2,r2,r2
   27e7c:	1085883a 	add	r2,r2,r2
   27e80:	1885883a 	add	r2,r3,r2
   27e84:	10800017 	ldw	r2,0(r2)
   27e88:	100b883a 	mov	r5,r2
   27e8c:	e0fff003 	ldbu	r3,-64(fp)
   27e90:	e0bffb07 	ldb	r2,-20(fp)
   27e94:	010000f4 	movhi	r4,3
   27e98:	21004404 	addi	r4,r4,272
   27e9c:	180d883a 	mov	r6,r3
   27ea0:	100f883a 	mov	r7,r2
   27ea4:	0024fd00 	call	24fd0 <no_printf>
                    is_phy_in_profile = 1;
   27ea8:	00800044 	movi	r2,1
   27eac:	e0bff205 	stb	r2,-56(fp)
                    break;
   27eb0:	00000706 	br	27ed0 <alt_tse_mac_get_phy+0x204>
            model_number = (phyid2 >> 4) & 0x3f;
            revision_number = phyid2 & 0x0f;
			
            /* map the PHY with PHY in profile */
            is_phy_in_profile = 0;
            for(i = 0; i < phy_profile_count; i++) {
   27eb4:	e0bff117 	ldw	r2,-60(fp)
   27eb8:	10800044 	addi	r2,r2,1
   27ebc:	e0bff115 	stw	r2,-60(fp)
   27ec0:	d0a8f703 	ldbu	r2,-23588(gp)
   27ec4:	10803fcc 	andi	r2,r2,255
   27ec8:	e0fff117 	ldw	r3,-60(fp)
   27ecc:	18bfc916 	blt	r3,r2,27df4 <alt_tse_mac_get_phy+0x128>
                    is_phy_in_profile = 1;
                    break;
                }
            }
            /* PHY not found in PHY profile */
            if(is_phy_in_profile == 0) {
   27ed0:	e0bff203 	ldbu	r2,-56(fp)
   27ed4:	10000f1e 	bne	r2,zero,27f14 <alt_tse_mac_get_phy+0x248>
                pphy->pphy_profile = 0;
   27ed8:	e0bff617 	ldw	r2,-40(fp)
   27edc:	10000515 	stw	zero,20(r2)
                tse_dprintf(3, "WARNING : Unknown PHY found at PHY address 0x%02x of MAC Group[%d]\n", phyadd, mac_group_index);
   27ee0:	e0fff003 	ldbu	r3,-64(fp)
   27ee4:	e0bffb07 	ldb	r2,-20(fp)
   27ee8:	010000f4 	movhi	r4,3
   27eec:	21005404 	addi	r4,r4,336
   27ef0:	180b883a 	mov	r5,r3
   27ef4:	100d883a 	mov	r6,r2
   27ef8:	0024fd00 	call	24fd0 <no_printf>
                tse_dprintf(3, "WARNING : Please add PHY information to PHY profile\n");
   27efc:	010000f4 	movhi	r4,3
   27f00:	21006504 	addi	r4,r4,404
   27f04:	0024fd00 	call	24fd0 <no_printf>
                return_value++;
   27f08:	e0bff317 	ldw	r2,-52(fp)
   27f0c:	10800044 	addi	r2,r2,1
   27f10:	e0bff315 	stw	r2,-52(fp)
            }
            
            tse_dprintf(6, "INFO    : PHY OUI             =  0x%06x\n", (int) oui);
   27f14:	e0bffd17 	ldw	r2,-12(fp)
   27f18:	010000f4 	movhi	r4,3
   27f1c:	21007304 	addi	r4,r4,460
   27f20:	100b883a 	mov	r5,r2
   27f24:	0024fd00 	call	24fd0 <no_printf>
            tse_dprintf(6, "INFO    : PHY Model Number    =  0x%02x\n", model_number);
   27f28:	e0bffe03 	ldbu	r2,-8(fp)
   27f2c:	010000f4 	movhi	r4,3
   27f30:	21007e04 	addi	r4,r4,504
   27f34:	100b883a 	mov	r5,r2
   27f38:	0024fd00 	call	24fd0 <no_printf>
            tse_dprintf(6, "INFO    : PHY Revision Number =  0x%01x\n", revision_number);
   27f3c:	e0bffe43 	ldbu	r2,-7(fp)
   27f40:	010000f4 	movhi	r4,3
   27f44:	21008904 	addi	r4,r4,548
   27f48:	100b883a 	mov	r5,r2
   27f4c:	0024fd00 	call	24fd0 <no_printf>
            
            /* map the detected PHY to connected MAC */
            if(alt_tse_mac_associate_phy(pmac_group, pphy) == TSE_PHY_MAP_SUCCESS) {
   27f50:	e13fff17 	ldw	r4,-4(fp)
   27f54:	e17ff617 	ldw	r5,-40(fp)
   27f58:	00280e80 	call	280e8 <alt_tse_mac_associate_phy>
   27f5c:	1000351e 	bne	r2,zero,28034 <alt_tse_mac_get_phy+0x368>
            	
            	pmac_info = pphy->pmac_info;
   27f60:	e0bff617 	ldw	r2,-40(fp)
   27f64:	10800617 	ldw	r2,24(r2)
   27f68:	e0bff715 	stw	r2,-36(fp)
            	psys = pmac_info->psys_info;
   27f6c:	e0bff717 	ldw	r2,-36(fp)
   27f70:	10800217 	ldw	r2,8(r2)
   27f74:	e0bff815 	stw	r2,-32(fp)
            	
            	/* Disable PHY loopback to allow Auto-Negotiation completed */
    	        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 0);   // disable PHY loopback
   27f78:	d8000015 	stw	zero,0(sp)
   27f7c:	e13ff617 	ldw	r4,-40(fp)
   27f80:	000b883a 	mov	r5,zero
   27f84:	01800384 	movi	r6,14
   27f88:	01c00044 	movi	r7,1
   27f8c:	0026f900 	call	26f90 <alt_tse_phy_wr_mdio_reg>
				
				/* Reset auto-negotiation advertisement */
				alt_tse_phy_set_adv_1000(pphy, 1);
   27f90:	e13ff617 	ldw	r4,-40(fp)
   27f94:	01400044 	movi	r5,1
   27f98:	0028e240 	call	28e24 <alt_tse_phy_set_adv_1000>
				alt_tse_phy_set_adv_100(pphy, 1);
   27f9c:	e13ff617 	ldw	r4,-40(fp)
   27fa0:	01400044 	movi	r5,1
   27fa4:	0028fe00 	call	28fe0 <alt_tse_phy_set_adv_100>
				alt_tse_phy_set_adv_10(pphy, 1);
   27fa8:	e13ff617 	ldw	r4,-40(fp)
   27fac:	01400044 	movi	r5,1
   27fb0:	00292280 	call	29228 <alt_tse_phy_set_adv_10>
            	            	
	            /* check link connection for this PHY */
	            alt_tse_phy_restart_an(pphy, ALTERA_CHECKLINK_TIMEOUT_THRESHOLD);
   27fb4:	e13ff617 	ldw	r4,-40(fp)
   27fb8:	014003f4 	movhi	r5,15
   27fbc:	29509004 	addi	r5,r5,16960
   27fc0:	00285680 	call	28568 <alt_tse_phy_restart_an>
	            
	            /* Perform additional setting if there is any */
	            /* Profile specific */
	            if(pphy->pphy_profile) {
   27fc4:	e0bff617 	ldw	r2,-40(fp)
   27fc8:	10800517 	ldw	r2,20(r2)
   27fcc:	10000f26 	beq	r2,zero,2800c <alt_tse_mac_get_phy+0x340>
		            if(pphy->pphy_profile->phy_cfg) {
   27fd0:	e0bff617 	ldw	r2,-40(fp)
   27fd4:	10800517 	ldw	r2,20(r2)
   27fd8:	10801717 	ldw	r2,92(r2)
   27fdc:	10000b26 	beq	r2,zero,2800c <alt_tse_mac_get_phy+0x340>
		                tse_dprintf(6, "INFO    : Applying additional PHY configuration of %s\n", pphy->pphy_profile->name);
   27fe0:	e0bff617 	ldw	r2,-40(fp)
   27fe4:	10800517 	ldw	r2,20(r2)
   27fe8:	010000f4 	movhi	r4,3
   27fec:	21009404 	addi	r4,r4,592
   27ff0:	100b883a 	mov	r5,r2
   27ff4:	0024fd00 	call	24fd0 <no_printf>
		                pphy->pphy_profile->phy_cfg(pmac_group_base);
   27ff8:	e0bff617 	ldw	r2,-40(fp)
   27ffc:	10800517 	ldw	r2,20(r2)
   28000:	10801717 	ldw	r2,92(r2)
   28004:	e13ff917 	ldw	r4,-28(fp)
   28008:	103ee83a 	callr	r2
		            }
	            }
	            
	            /* Initialize PHY, call user's function pointer in alt_tse_system_info structure */
	            /* Individual PHY specific */
            	if(psys->tse_phy_cfg) {
   2800c:	e0bff817 	ldw	r2,-32(fp)
   28010:	10801117 	ldw	r2,68(r2)
   28014:	10000726 	beq	r2,zero,28034 <alt_tse_mac_get_phy+0x368>
            		tse_dprintf(6, "INFO    : Applying additional user PHY configuration\n");
   28018:	010000f4 	movhi	r4,3
   2801c:	2100a204 	addi	r4,r4,648
   28020:	0024fd00 	call	24fd0 <no_printf>
            		psys->tse_phy_cfg(pmac_group_base);
   28024:	e0bff817 	ldw	r2,-32(fp)
   28028:	10801117 	ldw	r2,68(r2)
   2802c:	e13ff917 	ldw	r4,-28(fp)
   28030:	103ee83a 	callr	r2
            	}
            }
            
            tse_dprintf(6, "\n");
   28034:	010000f4 	movhi	r4,3
   28038:	2100b004 	addi	r4,r4,704
   2803c:	0024fd00 	call	24fd0 <no_printf>
	            
            phy_info_count++;
   28040:	e0bff403 	ldbu	r2,-48(fp)
   28044:	10800044 	addi	r2,r2,1
   28048:	e0bff405 	stb	r2,-48(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    
    /* loop all valid PHY address to look for connected PHY */
    for (phyadd = 0x00; phyadd < 0x20; phyadd++)
   2804c:	e0bff003 	ldbu	r2,-64(fp)
   28050:	10800044 	addi	r2,r2,1
   28054:	e0bff005 	stb	r2,-64(fp)
   28058:	e0bff003 	ldbu	r2,-64(fp)
   2805c:	10800830 	cmpltui	r2,r2,32
   28060:	103f331e 	bne	r2,zero,27d30 <alt_tse_mac_get_phy+0x64>
            phy_info_count++;
        }
    }
    
    /* check to verify the number of connected PHY match the number of channel */
    if(pmac_group->channel != phy_info_count) {
   28064:	e0bfff17 	ldw	r2,-4(fp)
   28068:	10800003 	ldbu	r2,0(r2)
   2806c:	10c03fcc 	andi	r3,r2,255
   28070:	e0bff407 	ldb	r2,-48(fp)
   28074:	18801226 	beq	r3,r2,280c0 <alt_tse_mac_get_phy+0x3f4>
        if(phy_info_count == 0) {
   28078:	e0bff407 	ldb	r2,-48(fp)
   2807c:	1000061e 	bne	r2,zero,28098 <alt_tse_mac_get_phy+0x3cc>
            tse_dprintf(2, "ERROR   : MAC Group[%d] - No PHY connected!\n", mac_group_index);
   28080:	e0bffb07 	ldb	r2,-20(fp)
   28084:	010000f4 	movhi	r4,3
   28088:	2100b104 	addi	r4,r4,708
   2808c:	100b883a 	mov	r5,r2
   28090:	0024fd00 	call	24fd0 <no_printf>
   28094:	00000a06 	br	280c0 <alt_tse_mac_get_phy+0x3f4>
        }
        else {
            tse_dprintf(3, "WARNING : MAC Group[%d] - Number of PHY connected is not equal to the number of channel, Number of PHY : %d, Channel : %d\n", mac_group_index, phy_info_count, pmac_group->channel);
   28098:	e17ffb07 	ldb	r5,-20(fp)
   2809c:	e0fff407 	ldb	r3,-48(fp)
   280a0:	e0bfff17 	ldw	r2,-4(fp)
   280a4:	10800003 	ldbu	r2,0(r2)
   280a8:	10803fcc 	andi	r2,r2,255
   280ac:	010000f4 	movhi	r4,3
   280b0:	2100bd04 	addi	r4,r4,756
   280b4:	180d883a 	mov	r6,r3
   280b8:	100f883a 	mov	r7,r2
   280bc:	0024fd00 	call	24fd0 <no_printf>
        }
    }
    
    /* Restore previous MDIO address */
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
   280c0:	e0bff917 	ldw	r2,-28(fp)
   280c4:	10801004 	addi	r2,r2,64
   280c8:	e0fffa17 	ldw	r3,-24(fp)
   280cc:	10c00035 	stwio	r3,0(r2)
    
    return return_value;
   280d0:	e0bff317 	ldw	r2,-52(fp)
}
   280d4:	e037883a 	mov	sp,fp
   280d8:	dfc00117 	ldw	ra,4(sp)
   280dc:	df000017 	ldw	fp,0(sp)
   280e0:	dec00204 	addi	sp,sp,8
   280e4:	f800283a 	ret

000280e8 <alt_tse_mac_associate_phy>:
 * @param pmac_group  Pointer to the TSE MAC grouping structure
 * @param pphy        Pointer to the TSE PHY info structure which hold information of PHY
 * @return            return TSE_PHY_MAP_ERROR if mapping error
 *                    return TSE_PHY_MAP_SUCCESS otherwise
 */
alt_32 alt_tse_mac_associate_phy(alt_tse_mac_group *pmac_group, alt_tse_phy_info *pphy) {
   280e8:	defff604 	addi	sp,sp,-40
   280ec:	dfc00915 	stw	ra,36(sp)
   280f0:	df000815 	stw	fp,32(sp)
   280f4:	df000804 	addi	fp,sp,32
   280f8:	e13ffe15 	stw	r4,-8(fp)
   280fc:	e17fff15 	stw	r5,-4(fp)
    
	alt_32 i;
	alt_32 return_value = TSE_PHY_MAP_SUCCESS;
   28100:	e03ff915 	stw	zero,-28(fp)
    
	alt_u8 is_mapped;

    alt_tse_system_info *psys = 0;
   28104:	e03ffb15 	stw	zero,-20(fp)
    alt_tse_mac_info *pmac_info = 0;
   28108:	e03ffc15 	stw	zero,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
   2810c:	e03ffd05 	stb	zero,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
   28110:	e13ffe17 	ldw	r4,-8(fp)
   28114:	00261440 	call	26144 <alt_tse_get_mac_group_index>
   28118:	e0bffd45 	stb	r2,-11(fp)
    alt_8 sys_info_index = 0;
   2811c:	e03ffd85 	stb	zero,-10(fp)
    
    is_mapped = 0;
   28120:	e03ffa05 	stb	zero,-24(fp)
    
    for(i = 0; i < pmac_group->channel; i++) {
   28124:	e03ff815 	stw	zero,-32(fp)
   28128:	00002b06 	br	281d8 <alt_tse_mac_associate_phy+0xf0>
        pmac_info = pmac_group->pmac_info[i];
   2812c:	e0fffe17 	ldw	r3,-8(fp)
   28130:	e0bff817 	ldw	r2,-32(fp)
   28134:	10800044 	addi	r2,r2,1
   28138:	1085883a 	add	r2,r2,r2
   2813c:	1085883a 	add	r2,r2,r2
   28140:	1885883a 	add	r2,r3,r2
   28144:	10800017 	ldw	r2,0(r2)
   28148:	e0bffc15 	stw	r2,-16(fp)
        psys = pmac_info->psys_info;
   2814c:	e0bffc17 	ldw	r2,-16(fp)
   28150:	10800217 	ldw	r2,8(r2)
   28154:	e0bffb15 	stw	r2,-20(fp)
       
        /* map according to the PHY address in alt_tse_system_info.h */
        if(psys->tse_phy_mdio_address == pphy->mdio_address) {
   28158:	e0bffb17 	ldw	r2,-20(fp)
   2815c:	10c01017 	ldw	r3,64(r2)
   28160:	e0bfff17 	ldw	r2,-4(fp)
   28164:	10800003 	ldbu	r2,0(r2)
   28168:	10803fcc 	andi	r2,r2,255
   2816c:	1880171e 	bne	r3,r2,281cc <alt_tse_mac_associate_phy+0xe4>
        	mac_info_index = alt_tse_get_mac_info_index(pmac_info);
   28170:	e13ffc17 	ldw	r4,-16(fp)
   28174:	00261b80 	call	261b8 <alt_tse_get_mac_info_index>
   28178:	e0bffd05 	stb	r2,-12(fp)
	        sys_info_index = alt_tse_get_system_index(psys);
   2817c:	e13ffb17 	ldw	r4,-20(fp)
   28180:	00260d80 	call	260d8 <alt_tse_get_system_index>
   28184:	e0bffd85 	stb	r2,-10(fp)
	        
            pmac_info->pphy_info = pphy;
   28188:	e0bffc17 	ldw	r2,-16(fp)
   2818c:	e0ffff17 	ldw	r3,-4(fp)
   28190:	10c00115 	stw	r3,4(r2)
            pphy->pmac_info = pmac_info;
   28194:	e0bfff17 	ldw	r2,-4(fp)
   28198:	e0fffc17 	ldw	r3,-16(fp)
   2819c:	10c00615 	stw	r3,24(r2)
            tse_dprintf(5, "INFO    : PHY[%d.%d] - Explicitly mapped to tse_mac_device[%d]\n", mac_group_index, mac_info_index, sys_info_index);
   281a0:	e17ffd47 	ldb	r5,-11(fp)
   281a4:	e0fffd07 	ldb	r3,-12(fp)
   281a8:	e0bffd87 	ldb	r2,-10(fp)
   281ac:	010000f4 	movhi	r4,3
   281b0:	2100dc04 	addi	r4,r4,880
   281b4:	180d883a 	mov	r6,r3
   281b8:	100f883a 	mov	r7,r2
   281bc:	0024fd00 	call	24fd0 <no_printf>
            is_mapped = 1;
   281c0:	00800044 	movi	r2,1
   281c4:	e0bffa05 	stb	r2,-24(fp)
            break;
   281c8:	00000806 	br	281ec <alt_tse_mac_associate_phy+0x104>
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    alt_8 sys_info_index = 0;
    
    is_mapped = 0;
    
    for(i = 0; i < pmac_group->channel; i++) {
   281cc:	e0bff817 	ldw	r2,-32(fp)
   281d0:	10800044 	addi	r2,r2,1
   281d4:	e0bff815 	stw	r2,-32(fp)
   281d8:	e0bffe17 	ldw	r2,-8(fp)
   281dc:	10800003 	ldbu	r2,0(r2)
   281e0:	10803fcc 	andi	r2,r2,255
   281e4:	e0fff817 	ldw	r3,-32(fp)
   281e8:	18bfd016 	blt	r3,r2,2812c <alt_tse_mac_associate_phy+0x44>
            break;
        }
    }
    
    /* if not yet map, it will automatically mapped to the first TSE device encountered with tse_phy_mdio_address = TSE_PHY_AUTO_ADDRESS */
    if(is_mapped == 0) {
   281ec:	e0bffa03 	ldbu	r2,-24(fp)
   281f0:	10003c1e 	bne	r2,zero,282e4 <alt_tse_mac_associate_phy+0x1fc>
        for(i = 0; i < pmac_group->channel; i++) {
   281f4:	e03ff815 	stw	zero,-32(fp)
   281f8:	00003506 	br	282d0 <alt_tse_mac_associate_phy+0x1e8>
            pmac_info = pmac_group->pmac_info[i];
   281fc:	e0fffe17 	ldw	r3,-8(fp)
   28200:	e0bff817 	ldw	r2,-32(fp)
   28204:	10800044 	addi	r2,r2,1
   28208:	1085883a 	add	r2,r2,r2
   2820c:	1085883a 	add	r2,r2,r2
   28210:	1885883a 	add	r2,r3,r2
   28214:	10800017 	ldw	r2,0(r2)
   28218:	e0bffc15 	stw	r2,-16(fp)
            psys = pmac_info->psys_info;
   2821c:	e0bffc17 	ldw	r2,-16(fp)
   28220:	10800217 	ldw	r2,8(r2)
   28224:	e0bffb15 	stw	r2,-20(fp)
            
            /* alt_tse_system_info structure definition error */
            if((psys->tse_sgdma_tx == 0) || (psys->tse_sgdma_rx == 0)){
   28228:	e0bffb17 	ldw	r2,-20(fp)
   2822c:	10800517 	ldw	r2,20(r2)
   28230:	10002326 	beq	r2,zero,282c0 <alt_tse_mac_associate_phy+0x1d8>
   28234:	e0bffb17 	ldw	r2,-20(fp)
   28238:	10800617 	ldw	r2,24(r2)
   2823c:	10002026 	beq	r2,zero,282c0 <alt_tse_mac_associate_phy+0x1d8>
            	continue;
            }
            
            if(psys->tse_phy_mdio_address == TSE_PHY_AUTO_ADDRESS) {
   28240:	e0bffb17 	ldw	r2,-20(fp)
   28244:	10801017 	ldw	r2,64(r2)
   28248:	10bfffd8 	cmpnei	r2,r2,-1
   2824c:	10001d1e 	bne	r2,zero,282c4 <alt_tse_mac_associate_phy+0x1dc>
                mac_info_index = alt_tse_get_mac_info_index(pmac_info);
   28250:	e13ffc17 	ldw	r4,-16(fp)
   28254:	00261b80 	call	261b8 <alt_tse_get_mac_info_index>
   28258:	e0bffd05 	stb	r2,-12(fp)
                sys_info_index = alt_tse_get_system_index(psys);
   2825c:	e13ffb17 	ldw	r4,-20(fp)
   28260:	00260d80 	call	260d8 <alt_tse_get_system_index>
   28264:	e0bffd85 	stb	r2,-10(fp)
                
                pmac_info->pphy_info = pphy;
   28268:	e0bffc17 	ldw	r2,-16(fp)
   2826c:	e0ffff17 	ldw	r3,-4(fp)
   28270:	10c00115 	stw	r3,4(r2)
                pphy->pmac_info = pmac_info;
   28274:	e0bfff17 	ldw	r2,-4(fp)
   28278:	e0fffc17 	ldw	r3,-16(fp)
   2827c:	10c00615 	stw	r3,24(r2)
                psys->tse_phy_mdio_address = pphy->mdio_address;
   28280:	e0bfff17 	ldw	r2,-4(fp)
   28284:	10800003 	ldbu	r2,0(r2)
   28288:	10c03fcc 	andi	r3,r2,255
   2828c:	e0bffb17 	ldw	r2,-20(fp)
   28290:	10c01015 	stw	r3,64(r2)
                tse_dprintf(5, "INFO    : PHY[%d.%d] - Automatically mapped to tse_mac_device[%d]\n", mac_group_index, mac_info_index, sys_info_index);
   28294:	e17ffd47 	ldb	r5,-11(fp)
   28298:	e0fffd07 	ldb	r3,-12(fp)
   2829c:	e0bffd87 	ldb	r2,-10(fp)
   282a0:	010000f4 	movhi	r4,3
   282a4:	2100ec04 	addi	r4,r4,944
   282a8:	180d883a 	mov	r6,r3
   282ac:	100f883a 	mov	r7,r2
   282b0:	0024fd00 	call	24fd0 <no_printf>
                is_mapped = 1;
   282b4:	00800044 	movi	r2,1
   282b8:	e0bffa05 	stb	r2,-24(fp)
                break;
   282bc:	00000906 	br	282e4 <alt_tse_mac_associate_phy+0x1fc>
            pmac_info = pmac_group->pmac_info[i];
            psys = pmac_info->psys_info;
            
            /* alt_tse_system_info structure definition error */
            if((psys->tse_sgdma_tx == 0) || (psys->tse_sgdma_rx == 0)){
            	continue;
   282c0:	0001883a 	nop
        }
    }
    
    /* if not yet map, it will automatically mapped to the first TSE device encountered with tse_phy_mdio_address = TSE_PHY_AUTO_ADDRESS */
    if(is_mapped == 0) {
        for(i = 0; i < pmac_group->channel; i++) {
   282c4:	e0bff817 	ldw	r2,-32(fp)
   282c8:	10800044 	addi	r2,r2,1
   282cc:	e0bff815 	stw	r2,-32(fp)
   282d0:	e0bffe17 	ldw	r2,-8(fp)
   282d4:	10800003 	ldbu	r2,0(r2)
   282d8:	10803fcc 	andi	r2,r2,255
   282dc:	e0fff817 	ldw	r3,-32(fp)
   282e0:	18bfc616 	blt	r3,r2,281fc <alt_tse_mac_associate_phy+0x114>
            }
        }
    }
    
    /* Still cannot find any matched MAC-PHY */
    if(is_mapped == 0) {
   282e4:	e0bffa03 	ldbu	r2,-24(fp)
   282e8:	1000091e 	bne	r2,zero,28310 <alt_tse_mac_associate_phy+0x228>
    	pphy->pmac_info = 0;
   282ec:	e0bfff17 	ldw	r2,-4(fp)
   282f0:	10000615 	stw	zero,24(r2)
        tse_dprintf(2, "WARNING : PHY[%d.X] - Mapping of PHY to MAC failed! Make sure the PHY address is defined correctly in tse_mac_device[] structure, and number of PHYs connected is equivalent to number of channel\n", mac_group_index);
   282f4:	e0bffd47 	ldb	r2,-11(fp)
   282f8:	010000f4 	movhi	r4,3
   282fc:	2100fd04 	addi	r4,r4,1012
   28300:	100b883a 	mov	r5,r2
   28304:	0024fd00 	call	24fd0 <no_printf>
        return_value = TSE_PHY_MAP_ERROR;
   28308:	00bfffc4 	movi	r2,-1
   2830c:	e0bff915 	stw	r2,-28(fp)
    }
    
    return return_value;
   28310:	e0bff917 	ldw	r2,-28(fp)
}
   28314:	e037883a 	mov	sp,fp
   28318:	dfc00117 	ldw	ra,4(sp)
   2831c:	df000017 	ldw	fp,0(sp)
   28320:	dec00204 	addi	sp,sp,8
   28324:	f800283a 	ret

00028328 <alt_tse_phy_cfg_pcs>:
/* @Function Description: Configure operating mode of Altera PCS if available
 * @API Type:           Internal
 * @param pmac_info     pointer to MAC info variable
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_cfg_pcs(alt_tse_mac_info *pmac_info) {
   28328:	defff804 	addi	sp,sp,-32
   2832c:	dfc00715 	stw	ra,28(sp)
   28330:	df000615 	stw	fp,24(sp)
   28334:	df000604 	addi	fp,sp,24
   28338:	e13fff15 	stw	r4,-4(fp)
    
    alt_tse_system_info *psys = pmac_info->psys_info;
   2833c:	e0bfff17 	ldw	r2,-4(fp)
   28340:	10800217 	ldw	r2,8(r2)
   28344:	e0bffa15 	stw	r2,-24(fp)
    np_tse_mac *pmac = (np_tse_mac *) psys->tse_mac_base;
   28348:	e0bffa17 	ldw	r2,-24(fp)
   2834c:	10800017 	ldw	r2,0(r2)
   28350:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
   28354:	e0bfff17 	ldw	r2,-4(fp)
   28358:	10800317 	ldw	r2,12(r2)
   2835c:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
   28360:	e13fff17 	ldw	r4,-4(fp)
   28364:	00261b80 	call	261b8 <alt_tse_get_mac_info_index>
   28368:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
   2836c:	e13ffc17 	ldw	r4,-16(fp)
   28370:	00261440 	call	26144 <alt_tse_get_mac_group_index>
   28374:	e0bffd45 	stb	r2,-11(fp)

    if(psys->tse_pcs_ena) {
   28378:	e0bffa17 	ldw	r2,-24(fp)
   2837c:	108003c3 	ldbu	r2,15(r2)
   28380:	10803fcc 	andi	r2,r2,255
   28384:	10002c26 	beq	r2,zero,28438 <alt_tse_phy_cfg_pcs+0x110>
        tse_dprintf(5, "INFO    : PCS[%d.%d] - Configuring PCS operating mode\n", mac_group_index, mac_info_index);
   28388:	e0fffd47 	ldb	r3,-11(fp)
   2838c:	e0bffd07 	ldb	r2,-12(fp)
   28390:	010000f4 	movhi	r4,3
   28394:	21012e04 	addi	r4,r4,1208
   28398:	180b883a 	mov	r5,r3
   2839c:	100d883a 	mov	r6,r2
   283a0:	0024fd00 	call	24fd0 <no_printf>
        
        alt_32 data = IORD(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE); 
   283a4:	e0bffb17 	ldw	r2,-20(fp)
   283a8:	10808004 	addi	r2,r2,512
   283ac:	10801404 	addi	r2,r2,80
   283b0:	10800037 	ldwio	r2,0(r2)
   283b4:	e0bffe15 	stw	r2,-8(fp)
        
        if(psys->tse_pcs_sgmii) {
   283b8:	e0bffa17 	ldw	r2,-24(fp)
   283bc:	10800403 	ldbu	r2,16(r2)
   283c0:	10803fcc 	andi	r2,r2,255
   283c4:	10000e26 	beq	r2,zero,28400 <alt_tse_phy_cfg_pcs+0xd8>
            tse_dprintf(5, "INFO    : PCS[%d.%d] - PCS SGMII mode enabled\n", mac_group_index, mac_info_index);
   283c8:	e0fffd47 	ldb	r3,-11(fp)
   283cc:	e0bffd07 	ldb	r2,-12(fp)
   283d0:	010000f4 	movhi	r4,3
   283d4:	21013c04 	addi	r4,r4,1264
   283d8:	180b883a 	mov	r5,r3
   283dc:	100d883a 	mov	r6,r2
   283e0:	0024fd00 	call	24fd0 <no_printf>
            IOWR(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE, data | 0x03);
   283e4:	e0bffb17 	ldw	r2,-20(fp)
   283e8:	10808004 	addi	r2,r2,512
   283ec:	10801404 	addi	r2,r2,80
   283f0:	e0fffe17 	ldw	r3,-8(fp)
   283f4:	18c000d4 	ori	r3,r3,3
   283f8:	10c00035 	stwio	r3,0(r2)
   283fc:	00000e06 	br	28438 <alt_tse_phy_cfg_pcs+0x110>
            }
        else {
            tse_dprintf(5, "INFO    : PCS[%d.%d] - PCS SGMII mode disabled\n", mac_group_index, mac_info_index);
   28400:	e0fffd47 	ldb	r3,-11(fp)
   28404:	e0bffd07 	ldb	r2,-12(fp)
   28408:	010000f4 	movhi	r4,3
   2840c:	21014804 	addi	r4,r4,1312
   28410:	180b883a 	mov	r5,r3
   28414:	100d883a 	mov	r6,r2
   28418:	0024fd00 	call	24fd0 <no_printf>
            IOWR(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE, data & ~0x03);
   2841c:	e0bffb17 	ldw	r2,-20(fp)
   28420:	10808004 	addi	r2,r2,512
   28424:	10801404 	addi	r2,r2,80
   28428:	e13ffe17 	ldw	r4,-8(fp)
   2842c:	00ffff04 	movi	r3,-4
   28430:	20c6703a 	and	r3,r4,r3
   28434:	10c00035 	stwio	r3,0(r2)
        }
    }
    
    return SUCCESS;
   28438:	0005883a 	mov	r2,zero
}
   2843c:	e037883a 	mov	sp,fp
   28440:	dfc00117 	ldw	ra,4(sp)
   28444:	df000017 	ldw	fp,0(sp)
   28448:	dec00204 	addi	sp,sp,8
   2844c:	f800283a 	ret

00028450 <alt_tse_phy_init>:
/* @Function Description: Detect and initialize all the PHYs connected
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      SUCCESS
 */
alt_32 alt_tse_phy_init() {
   28450:	defffb04 	addi	sp,sp,-20
   28454:	dfc00415 	stw	ra,16(sp)
   28458:	df000315 	stw	fp,12(sp)
   2845c:	df000304 	addi	fp,sp,12
	alt_8 i = 0;
   28460:	e03ffd05 	stb	zero,-12(fp)
	alt_8 j = 0;
   28464:	e03ffd45 	stb	zero,-11(fp)
    
    alt_tse_mac_group *pmac_group = 0;
   28468:	e03ffe15 	stw	zero,-8(fp)
    alt_tse_mac_info *pmac_info = 0;
   2846c:	e03fff15 	stw	zero,-4(fp)
    
    /* add supported PHYs */
    alt_tse_phy_add_profile_default();
   28470:	00271880 	call	27188 <alt_tse_phy_add_profile_default>
    
    /* display PHY in profile */
    alt_tse_phy_print_profile();
   28474:	00274200 	call	27420 <alt_tse_phy_print_profile>
    
    alt_tse_mac_group_init();
   28478:	00276300 	call	27630 <alt_tse_mac_group_init>
        
    /* initialize for each TSE MAC */
    /* run once only for multi-channel MAC */
    for(i = 0; i < mac_group_count; i++) {
   2847c:	e03ffd05 	stb	zero,-12(fp)
   28480:	00002f06 	br	28540 <alt_tse_phy_init+0xf0>
        pmac_group = pmac_groups[i];
   28484:	e0bffd07 	ldb	r2,-12(fp)
   28488:	00c00134 	movhi	r3,4
   2848c:	18cde804 	addi	r3,r3,14240
   28490:	1085883a 	add	r2,r2,r2
   28494:	1085883a 	add	r2,r2,r2
   28498:	1885883a 	add	r2,r3,r2
   2849c:	10800017 	ldw	r2,0(r2)
   284a0:	e0bffe15 	stw	r2,-8(fp)
        
        if(pmac_group->pmac_info[0]->psys_info->tse_use_mdio) {
   284a4:	e0bffe17 	ldw	r2,-8(fp)
   284a8:	10800117 	ldw	r2,4(r2)
   284ac:	10800217 	ldw	r2,8(r2)
   284b0:	10800203 	ldbu	r2,8(r2)
   284b4:	10803fcc 	andi	r2,r2,255
   284b8:	10000326 	beq	r2,zero,284c8 <alt_tse_phy_init+0x78>
            
        	/* get connected PHYs */
            alt_tse_mac_get_phy(pmac_group);
   284bc:	e13ffe17 	ldw	r4,-8(fp)
   284c0:	0027ccc0 	call	27ccc <alt_tse_mac_get_phy>
   284c4:	00000706 	br	284e4 <alt_tse_phy_init+0x94>
        }
        else {
            tse_dprintf(3, "WARNING : MAC Groups[%d]->pmac_info[%d] MDIO is not used, unable to run PHY detection\n", i, j);
   284c8:	e0fffd07 	ldb	r3,-12(fp)
   284cc:	e0bffd47 	ldb	r2,-11(fp)
   284d0:	010000f4 	movhi	r4,3
   284d4:	21015404 	addi	r4,r4,1360
   284d8:	180b883a 	mov	r5,r3
   284dc:	100d883a 	mov	r6,r2
   284e0:	0024fd00 	call	24fd0 <no_printf>
        }
        
        /* Configure PCS mode if MAC+PCS system is used */
        for(j = 0; j < pmac_group->channel; j++) {
   284e4:	e03ffd45 	stb	zero,-11(fp)
   284e8:	00000d06 	br	28520 <alt_tse_phy_init+0xd0>
            pmac_info = pmac_group->pmac_info[j];
   284ec:	e0bffd47 	ldb	r2,-11(fp)
   284f0:	e0fffe17 	ldw	r3,-8(fp)
   284f4:	10800044 	addi	r2,r2,1
   284f8:	1085883a 	add	r2,r2,r2
   284fc:	1085883a 	add	r2,r2,r2
   28500:	1885883a 	add	r2,r3,r2
   28504:	10800017 	ldw	r2,0(r2)
   28508:	e0bfff15 	stw	r2,-4(fp)
            
            alt_tse_phy_cfg_pcs(pmac_info);
   2850c:	e13fff17 	ldw	r4,-4(fp)
   28510:	00283280 	call	28328 <alt_tse_phy_cfg_pcs>
        else {
            tse_dprintf(3, "WARNING : MAC Groups[%d]->pmac_info[%d] MDIO is not used, unable to run PHY detection\n", i, j);
        }
        
        /* Configure PCS mode if MAC+PCS system is used */
        for(j = 0; j < pmac_group->channel; j++) {
   28514:	e0bffd43 	ldbu	r2,-11(fp)
   28518:	10800044 	addi	r2,r2,1
   2851c:	e0bffd45 	stb	r2,-11(fp)
   28520:	e0fffd47 	ldb	r3,-11(fp)
   28524:	e0bffe17 	ldw	r2,-8(fp)
   28528:	10800003 	ldbu	r2,0(r2)
   2852c:	10803fcc 	andi	r2,r2,255
   28530:	18bfee16 	blt	r3,r2,284ec <alt_tse_phy_init+0x9c>
    
    alt_tse_mac_group_init();
        
    /* initialize for each TSE MAC */
    /* run once only for multi-channel MAC */
    for(i = 0; i < mac_group_count; i++) {
   28534:	e0bffd03 	ldbu	r2,-12(fp)
   28538:	10800044 	addi	r2,r2,1
   2853c:	e0bffd05 	stb	r2,-12(fp)
   28540:	e0fffd07 	ldb	r3,-12(fp)
   28544:	d0a8f743 	ldbu	r2,-23587(gp)
   28548:	10803fcc 	andi	r2,r2,255
   2854c:	18bfcd16 	blt	r3,r2,28484 <alt_tse_phy_init+0x34>
            
            alt_tse_phy_cfg_pcs(pmac_info);
        }
    }
                
    return SUCCESS;
   28550:	0005883a 	mov	r2,zero
}
   28554:	e037883a 	mov	sp,fp
   28558:	dfc00117 	ldw	ra,4(sp)
   2855c:	df000017 	ldw	fp,0(sp)
   28560:	dec00204 	addi	sp,sp,8
   28564:	f800283a 	ret

00028568 <alt_tse_phy_restart_an>:
 *        timeout_threshold     timeout value of Auto-Negotiation
 * @return                      return TSE_PHY_AN_COMPLETE if success
 *                              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 *                              return TSE_PHY_AN_NOT_CAPABLE if the PHY not capable for AN
 */
alt_32 alt_tse_phy_restart_an(alt_tse_phy_info *pphy, alt_u32 timeout_threshold) {
   28568:	defff704 	addi	sp,sp,-36
   2856c:	dfc00815 	stw	ra,32(sp)
   28570:	df000715 	stw	fp,28(sp)
   28574:	df000704 	addi	fp,sp,28
   28578:	e13ffe15 	stw	r4,-8(fp)
   2857c:	e17fff15 	stw	r5,-4(fp)
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
   28580:	e0bffe17 	ldw	r2,-8(fp)
   28584:	10800617 	ldw	r2,24(r2)
   28588:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
   2858c:	e0bffb17 	ldw	r2,-20(fp)
   28590:	10800317 	ldw	r2,12(r2)
   28594:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
   28598:	e13ffb17 	ldw	r4,-20(fp)
   2859c:	00261b80 	call	261b8 <alt_tse_get_mac_info_index>
   285a0:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
   285a4:	e13ffc17 	ldw	r4,-16(fp)
   285a8:	00261440 	call	26144 <alt_tse_get_mac_group_index>
   285ac:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
   285b0:	e13ffe17 	ldw	r4,-8(fp)
   285b4:	0026ef00 	call	26ef0 <alt_tse_phy_rd_mdio_addr>
   285b8:	e0bffd85 	stb	r2,-10(fp)
    
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
   285bc:	e0bffe17 	ldw	r2,-8(fp)
   285c0:	10800003 	ldbu	r2,0(r2)
   285c4:	10803fcc 	andi	r2,r2,255
   285c8:	e13ffe17 	ldw	r4,-8(fp)
   285cc:	100b883a 	mov	r5,r2
   285d0:	0026f380 	call	26f38 <alt_tse_phy_wr_mdio_addr>
    
    if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
   285d4:	e13ffe17 	ldw	r4,-8(fp)
   285d8:	01400044 	movi	r5,1
   285dc:	018000c4 	movi	r6,3
   285e0:	01c00044 	movi	r7,1
   285e4:	00270bc0 	call	270bc <alt_tse_phy_rd_mdio_reg>
   285e8:	10000d1e 	bne	r2,zero,28620 <alt_tse_phy_restart_an+0xb8>
        tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not capable for Auto-Negotiation\n", mac_group_index, mac_info_index);
   285ec:	e0fffd47 	ldb	r3,-11(fp)
   285f0:	e0bffd07 	ldb	r2,-12(fp)
   285f4:	010000f4 	movhi	r4,3
   285f8:	21016a04 	addi	r4,r4,1448
   285fc:	180b883a 	mov	r5,r3
   28600:	100d883a 	mov	r6,r2
   28604:	0024fd00 	call	24fd0 <no_printf>
        
		/* Restore previous MDIO address */
		alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
   28608:	e0bffd83 	ldbu	r2,-10(fp)
   2860c:	e13ffe17 	ldw	r4,-8(fp)
   28610:	100b883a 	mov	r5,r2
   28614:	0026f380 	call	26f38 <alt_tse_phy_wr_mdio_addr>
		
		return TSE_PHY_AN_NOT_CAPABLE;
   28618:	00bfff84 	movi	r2,-2
   2861c:	00003e06 	br	28718 <alt_tse_phy_restart_an+0x1b0>
    }
    
    /* enable Auto-Negotiation */    
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_AN_ENA, 1, 1);
   28620:	00800044 	movi	r2,1
   28624:	d8800015 	stw	r2,0(sp)
   28628:	e13ffe17 	ldw	r4,-8(fp)
   2862c:	000b883a 	mov	r5,zero
   28630:	01800304 	movi	r6,12
   28634:	01c00044 	movi	r7,1
   28638:	0026f900 	call	26f90 <alt_tse_phy_wr_mdio_reg>
    
    /* send PHY reset command */
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_RESTART_AN, 1, 1);
   2863c:	00800044 	movi	r2,1
   28640:	d8800015 	stw	r2,0(sp)
   28644:	e13ffe17 	ldw	r4,-8(fp)
   28648:	000b883a 	mov	r5,zero
   2864c:	01800244 	movi	r6,9
   28650:	01c00044 	movi	r7,1
   28654:	0026f900 	call	26f90 <alt_tse_phy_wr_mdio_reg>
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Restart Auto-Negotiation, checking PHY link...\n", mac_group_index, mac_info_index);
   28658:	e0fffd47 	ldb	r3,-11(fp)
   2865c:	e0bffd07 	ldb	r2,-12(fp)
   28660:	010000f4 	movhi	r4,3
   28664:	21017a04 	addi	r4,r4,1512
   28668:	180b883a 	mov	r5,r3
   2866c:	100d883a 	mov	r6,r2
   28670:	0024fd00 	call	24fd0 <no_printf>
    
    alt_32 timeout = 0;
   28674:	e03ffa15 	stw	zero,-24(fp)
    while(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0 ){ 
   28678:	00001506 	br	286d0 <alt_tse_phy_restart_an+0x168>
        if(timeout++ > timeout_threshold) {
   2867c:	e0bffa17 	ldw	r2,-24(fp)
   28680:	e0ffff17 	ldw	r3,-4(fp)
   28684:	1885803a 	cmpltu	r2,r3,r2
   28688:	e0fffa17 	ldw	r3,-24(fp)
   2868c:	18c00044 	addi	r3,r3,1
   28690:	e0fffa15 	stw	r3,-24(fp)
   28694:	10803fcc 	andi	r2,r2,255
   28698:	10000d26 	beq	r2,zero,286d0 <alt_tse_phy_restart_an+0x168>
           tse_dprintf(4, "WARNING : PHY[%d.%d] - Auto-Negotiation FAILED\n", mac_group_index, mac_info_index);
   2869c:	e0fffd47 	ldb	r3,-11(fp)
   286a0:	e0bffd07 	ldb	r2,-12(fp)
   286a4:	010000f4 	movhi	r4,3
   286a8:	21018c04 	addi	r4,r4,1584
   286ac:	180b883a 	mov	r5,r3
   286b0:	100d883a 	mov	r6,r2
   286b4:	0024fd00 	call	24fd0 <no_printf>
		   
		   /* Restore previous MDIO address */
           alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
   286b8:	e0bffd83 	ldbu	r2,-10(fp)
   286bc:	e13ffe17 	ldw	r4,-8(fp)
   286c0:	100b883a 	mov	r5,r2
   286c4:	0026f380 	call	26f38 <alt_tse_phy_wr_mdio_addr>
           
		   return TSE_PHY_AN_NOT_COMPLETE;
   286c8:	00bfffc4 	movi	r2,-1
   286cc:	00001206 	br	28718 <alt_tse_phy_restart_an+0x1b0>
    /* send PHY reset command */
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_RESTART_AN, 1, 1);
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Restart Auto-Negotiation, checking PHY link...\n", mac_group_index, mac_info_index);
    
    alt_32 timeout = 0;
    while(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0 ){ 
   286d0:	e13ffe17 	ldw	r4,-8(fp)
   286d4:	01400044 	movi	r5,1
   286d8:	01800144 	movi	r6,5
   286dc:	01c00044 	movi	r7,1
   286e0:	00270bc0 	call	270bc <alt_tse_phy_rd_mdio_reg>
   286e4:	103fe526 	beq	r2,zero,2867c <alt_tse_phy_restart_an+0x114>
           alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
           
		   return TSE_PHY_AN_NOT_COMPLETE;
        }
    }
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Auto-Negotiation PASSED\n", mac_group_index, mac_info_index);
   286e8:	e0fffd47 	ldb	r3,-11(fp)
   286ec:	e0bffd07 	ldb	r2,-12(fp)
   286f0:	010000f4 	movhi	r4,3
   286f4:	21019804 	addi	r4,r4,1632
   286f8:	180b883a 	mov	r5,r3
   286fc:	100d883a 	mov	r6,r2
   28700:	0024fd00 	call	24fd0 <no_printf>
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
   28704:	e0bffd83 	ldbu	r2,-10(fp)
   28708:	e13ffe17 	ldw	r4,-8(fp)
   2870c:	100b883a 	mov	r5,r2
   28710:	0026f380 	call	26f38 <alt_tse_phy_wr_mdio_addr>
    
    return TSE_PHY_AN_COMPLETE;
   28714:	0005883a 	mov	r2,zero
}
   28718:	e037883a 	mov	sp,fp
   2871c:	dfc00117 	ldw	ra,4(sp)
   28720:	df000017 	ldw	fp,0(sp)
   28724:	dec00204 	addi	sp,sp,8
   28728:	f800283a 	ret

0002872c <alt_tse_phy_check_link>:
 * @param pphy                  Pointer to the alt_tse_phy_info structure
 *        timeout_threshold     timeout value of Auto-Negotiation
 * @return                      return TSE_PHY_AN_COMPLETE if success
 *                              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 */
alt_32 alt_tse_phy_check_link(alt_tse_phy_info *pphy, alt_u32 timeout_threshold) {
   2872c:	defff904 	addi	sp,sp,-28
   28730:	dfc00615 	stw	ra,24(sp)
   28734:	df000515 	stw	fp,20(sp)
   28738:	df000504 	addi	fp,sp,20
   2873c:	e13ffe15 	stw	r4,-8(fp)
   28740:	e17fff15 	stw	r5,-4(fp)

    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
   28744:	e0bffe17 	ldw	r2,-8(fp)
   28748:	10800617 	ldw	r2,24(r2)
   2874c:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
   28750:	e0bffb17 	ldw	r2,-20(fp)
   28754:	10800317 	ldw	r2,12(r2)
   28758:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
   2875c:	e13ffb17 	ldw	r4,-20(fp)
   28760:	00261b80 	call	261b8 <alt_tse_get_mac_info_index>
   28764:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group); 
   28768:	e13ffc17 	ldw	r4,-16(fp)
   2876c:	00261440 	call	26144 <alt_tse_get_mac_group_index>
   28770:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
   28774:	e13ffe17 	ldw	r4,-8(fp)
   28778:	0026ef00 	call	26ef0 <alt_tse_phy_rd_mdio_addr>
   2877c:	e0bffd85 	stb	r2,-10(fp)
    
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
   28780:	e0bffe17 	ldw	r2,-8(fp)
   28784:	10800003 	ldbu	r2,0(r2)
   28788:	10803fcc 	andi	r2,r2,255
   2878c:	e13ffe17 	ldw	r4,-8(fp)
   28790:	100b883a 	mov	r5,r2
   28794:	0026f380 	call	26f38 <alt_tse_phy_wr_mdio_addr>
    /* Issue a PHY reset here and wait for the link
     * autonegotiation complete again... this takes several SECONDS(!)
     * so be very careful not to do it frequently
     * perform this when PHY is configured in loopback or has no link yet.
     */
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Checking link...\n", mac_group_index, mac_info_index);
   28798:	e0fffd47 	ldb	r3,-11(fp)
   2879c:	e0bffd07 	ldb	r2,-12(fp)
   287a0:	010000f4 	movhi	r4,3
   287a4:	2101a404 	addi	r4,r4,1680
   287a8:	180b883a 	mov	r5,r3
   287ac:	100d883a 	mov	r6,r2
   287b0:	0024fd00 	call	24fd0 <no_printf>
    if( ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1)) != 0) ||
   287b4:	e13ffe17 	ldw	r4,-8(fp)
   287b8:	000b883a 	mov	r5,zero
   287bc:	01800384 	movi	r6,14
   287c0:	01c00044 	movi	r7,1
   287c4:	00270bc0 	call	270bc <alt_tse_phy_rd_mdio_reg>
   287c8:	1000061e 	bne	r2,zero,287e4 <alt_tse_phy_check_link+0xb8>
        ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1)) == 0) ) {                 
   287cc:	e13ffe17 	ldw	r4,-8(fp)
   287d0:	01400044 	movi	r5,1
   287d4:	01800144 	movi	r6,5
   287d8:	01c00044 	movi	r7,1
   287dc:	00270bc0 	call	270bc <alt_tse_phy_rd_mdio_reg>
     * autonegotiation complete again... this takes several SECONDS(!)
     * so be very careful not to do it frequently
     * perform this when PHY is configured in loopback or has no link yet.
     */
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Checking link...\n", mac_group_index, mac_info_index);
    if( ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1)) != 0) ||
   287e0:	1000191e 	bne	r2,zero,28848 <alt_tse_phy_check_link+0x11c>
        ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1)) == 0) ) {                 
        
        tse_dprintf(5, "INFO    : PHY[%d.%d] - Link not yet established, restart auto-negotiation...\n", mac_group_index, mac_info_index);
   287e4:	e0fffd47 	ldb	r3,-11(fp)
   287e8:	e0bffd07 	ldb	r2,-12(fp)
   287ec:	010000f4 	movhi	r4,3
   287f0:	2101af04 	addi	r4,r4,1724
   287f4:	180b883a 	mov	r5,r3
   287f8:	100d883a 	mov	r6,r2
   287fc:	0024fd00 	call	24fd0 <no_printf>
        /* restart Auto-Negotiation */
        /* if Auto-Negotiation still cannot complete, then go to next PHY */
        if(alt_tse_phy_restart_an(pphy, timeout_threshold) == TSE_PHY_AN_NOT_COMPLETE) {
   28800:	e13ffe17 	ldw	r4,-8(fp)
   28804:	e17fff17 	ldw	r5,-4(fp)
   28808:	00285680 	call	28568 <alt_tse_phy_restart_an>
   2880c:	10bfffd8 	cmpnei	r2,r2,-1
   28810:	10000d1e 	bne	r2,zero,28848 <alt_tse_phy_check_link+0x11c>
            tse_dprintf(3, "WARNING : PHY[%d.%d] - Link could not established\n", mac_group_index, mac_info_index);
   28814:	e0fffd47 	ldb	r3,-11(fp)
   28818:	e0bffd07 	ldb	r2,-12(fp)
   2881c:	010000f4 	movhi	r4,3
   28820:	2101c304 	addi	r4,r4,1804
   28824:	180b883a 	mov	r5,r3
   28828:	100d883a 	mov	r6,r2
   2882c:	0024fd00 	call	24fd0 <no_printf>
			
			/* Restore previous MDIO address */
			alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
   28830:	e0bffd83 	ldbu	r2,-10(fp)
   28834:	e13ffe17 	ldw	r4,-8(fp)
   28838:	100b883a 	mov	r5,r2
   2883c:	0026f380 	call	26f38 <alt_tse_phy_wr_mdio_addr>
	
            return TSE_PHY_AN_NOT_COMPLETE;
   28840:	00bfffc4 	movi	r2,-1
   28844:	00000c06 	br	28878 <alt_tse_phy_check_link+0x14c>
        }            
    }
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Link established\n", mac_group_index, mac_info_index);
   28848:	e0fffd47 	ldb	r3,-11(fp)
   2884c:	e0bffd07 	ldb	r2,-12(fp)
   28850:	010000f4 	movhi	r4,3
   28854:	2101d004 	addi	r4,r4,1856
   28858:	180b883a 	mov	r5,r3
   2885c:	100d883a 	mov	r6,r2
   28860:	0024fd00 	call	24fd0 <no_printf>
            
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
   28864:	e0bffd83 	ldbu	r2,-10(fp)
   28868:	e13ffe17 	ldw	r4,-8(fp)
   2886c:	100b883a 	mov	r5,r2
   28870:	0026f380 	call	26f38 <alt_tse_phy_wr_mdio_addr>
    
    return TSE_PHY_AN_COMPLETE; 
   28874:	0005883a 	mov	r2,zero
}
   28878:	e037883a 	mov	sp,fp
   2887c:	dfc00117 	ldw	ra,4(sp)
   28880:	df000017 	ldw	fp,0(sp)
   28884:	dec00204 	addi	sp,sp,8
   28888:	f800283a 	ret

0002888c <alt_tse_phy_get_cap>:
 * @param pmac  Pointer to the alt_tse_phy_info structure
 * @return      return TSE_PHY_AN_COMPLETE if success
 *              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 *              return TSE_PHY_AN_NOT_CAPABLE if the PHY not capable for AN
 */
alt_32 alt_tse_phy_get_cap(alt_tse_phy_info *pphy) {
   2888c:	defff904 	addi	sp,sp,-28
   28890:	dfc00615 	stw	ra,24(sp)
   28894:	df000515 	stw	fp,20(sp)
   28898:	df000504 	addi	fp,sp,20
   2889c:	e13fff15 	stw	r4,-4(fp)
	alt_32 return_value = TSE_PHY_AN_COMPLETE;
   288a0:	e03ffb15 	stw	zero,-20(fp)
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
   288a4:	e0bfff17 	ldw	r2,-4(fp)
   288a8:	10800617 	ldw	r2,24(r2)
   288ac:	e0bffc15 	stw	r2,-16(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
   288b0:	e0bffc17 	ldw	r2,-16(fp)
   288b4:	10800317 	ldw	r2,12(r2)
   288b8:	e0bffd15 	stw	r2,-12(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
   288bc:	e13ffc17 	ldw	r4,-16(fp)
   288c0:	00261b80 	call	261b8 <alt_tse_get_mac_info_index>
   288c4:	e0bffe05 	stb	r2,-8(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);    
   288c8:	e13ffd17 	ldw	r4,-12(fp)
   288cc:	00261440 	call	26144 <alt_tse_get_mac_group_index>
   288d0:	e0bffe45 	stb	r2,-7(fp)
        
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
   288d4:	e13fff17 	ldw	r4,-4(fp)
   288d8:	0026ef00 	call	26ef0 <alt_tse_phy_rd_mdio_addr>
   288dc:	e0bffe85 	stb	r2,-6(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
   288e0:	e0bfff17 	ldw	r2,-4(fp)
   288e4:	10800003 	ldbu	r2,0(r2)
   288e8:	10803fcc 	andi	r2,r2,255
   288ec:	e13fff17 	ldw	r4,-4(fp)
   288f0:	100b883a 	mov	r5,r2
   288f4:	0026f380 	call	26f38 <alt_tse_phy_wr_mdio_addr>
            
    if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
   288f8:	e13fff17 	ldw	r4,-4(fp)
   288fc:	01400044 	movi	r5,1
   28900:	018000c4 	movi	r6,3
   28904:	01c00044 	movi	r7,1
   28908:	00270bc0 	call	270bc <alt_tse_phy_rd_mdio_reg>
   2890c:	10000d1e 	bne	r2,zero,28944 <alt_tse_phy_get_cap+0xb8>
        tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not capable for Auto-Negotiation\n", mac_group_index, mac_info_index);
   28910:	e0fffe47 	ldb	r3,-7(fp)
   28914:	e0bffe07 	ldb	r2,-8(fp)
   28918:	010000f4 	movhi	r4,3
   2891c:	21016a04 	addi	r4,r4,1448
   28920:	180b883a 	mov	r5,r3
   28924:	100d883a 	mov	r6,r2
   28928:	0024fd00 	call	24fd0 <no_printf>
        
        /* Restore previous MDIO address */
        alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
   2892c:	e0bffe83 	ldbu	r2,-6(fp)
   28930:	e13fff17 	ldw	r4,-4(fp)
   28934:	100b883a 	mov	r5,r2
   28938:	0026f380 	call	26f38 <alt_tse_phy_wr_mdio_addr>
        
        return TSE_PHY_AN_NOT_CAPABLE;
   2893c:	00bfff84 	movi	r2,-2
   28940:	00013306 	br	28e10 <alt_tse_phy_get_cap+0x584>
    }
    
    /* check whether link has been established */
    alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
   28944:	e13fff17 	ldw	r4,-4(fp)
   28948:	01400134 	movhi	r5,4
   2894c:	29742404 	addi	r5,r5,-12144
   28950:	00285680 	call	28568 <alt_tse_phy_restart_an>
    
    if(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0) {
   28954:	e13fff17 	ldw	r4,-4(fp)
   28958:	01400044 	movi	r5,1
   2895c:	01800144 	movi	r6,5
   28960:	01c00044 	movi	r7,1
   28964:	00270bc0 	call	270bc <alt_tse_phy_rd_mdio_reg>
   28968:	1000021e 	bne	r2,zero,28974 <alt_tse_phy_get_cap+0xe8>
        return_value = TSE_PHY_AN_NOT_COMPLETE;
   2896c:	00bfffc4 	movi	r2,-1
   28970:	e0bffb15 	stw	r2,-20(fp)
    }
    
    /* get PHY capabilities */
    pphy->link_capability.cap_1000_base_x_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_FULL, 1);
   28974:	e13fff17 	ldw	r4,-4(fp)
   28978:	014003c4 	movi	r5,15
   2897c:	018003c4 	movi	r6,15
   28980:	01c00044 	movi	r7,1
   28984:	00270bc0 	call	270bc <alt_tse_phy_rd_mdio_reg>
   28988:	1007883a 	mov	r3,r2
   2898c:	e0bfff17 	ldw	r2,-4(fp)
   28990:	10c00045 	stb	r3,1(r2)
    pphy->link_capability.cap_1000_base_x_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_HALF, 1);
   28994:	e13fff17 	ldw	r4,-4(fp)
   28998:	014003c4 	movi	r5,15
   2899c:	01800384 	movi	r6,14
   289a0:	01c00044 	movi	r7,1
   289a4:	00270bc0 	call	270bc <alt_tse_phy_rd_mdio_reg>
   289a8:	1007883a 	mov	r3,r2
   289ac:	e0bfff17 	ldw	r2,-4(fp)
   289b0:	10c00085 	stb	r3,2(r2)
    pphy->link_capability.cap_1000_base_t_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_FULL, 1);
   289b4:	e13fff17 	ldw	r4,-4(fp)
   289b8:	014003c4 	movi	r5,15
   289bc:	01800344 	movi	r6,13
   289c0:	01c00044 	movi	r7,1
   289c4:	00270bc0 	call	270bc <alt_tse_phy_rd_mdio_reg>
   289c8:	1007883a 	mov	r3,r2
   289cc:	e0bfff17 	ldw	r2,-4(fp)
   289d0:	10c000c5 	stb	r3,3(r2)
    pphy->link_capability.cap_1000_base_t_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_HALF, 1);
   289d4:	e13fff17 	ldw	r4,-4(fp)
   289d8:	014003c4 	movi	r5,15
   289dc:	01800304 	movi	r6,12
   289e0:	01c00044 	movi	r7,1
   289e4:	00270bc0 	call	270bc <alt_tse_phy_rd_mdio_reg>
   289e8:	1007883a 	mov	r3,r2
   289ec:	e0bfff17 	ldw	r2,-4(fp)
   289f0:	10c00105 	stb	r3,4(r2)
    
    pphy->link_capability.cap_100_base_t4      = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T4, 1);
   289f4:	e13fff17 	ldw	r4,-4(fp)
   289f8:	01400044 	movi	r5,1
   289fc:	018003c4 	movi	r6,15
   28a00:	01c00044 	movi	r7,1
   28a04:	00270bc0 	call	270bc <alt_tse_phy_rd_mdio_reg>
   28a08:	1007883a 	mov	r3,r2
   28a0c:	e0bfff17 	ldw	r2,-4(fp)
   28a10:	10c00145 	stb	r3,5(r2)
    pphy->link_capability.cap_100_base_x_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_FULL, 1);
   28a14:	e13fff17 	ldw	r4,-4(fp)
   28a18:	01400044 	movi	r5,1
   28a1c:	01800384 	movi	r6,14
   28a20:	01c00044 	movi	r7,1
   28a24:	00270bc0 	call	270bc <alt_tse_phy_rd_mdio_reg>
   28a28:	1007883a 	mov	r3,r2
   28a2c:	e0bfff17 	ldw	r2,-4(fp)
   28a30:	10c00185 	stb	r3,6(r2)
    pphy->link_capability.cap_100_base_x_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_HALF, 1);
   28a34:	e13fff17 	ldw	r4,-4(fp)
   28a38:	01400044 	movi	r5,1
   28a3c:	01800344 	movi	r6,13
   28a40:	01c00044 	movi	r7,1
   28a44:	00270bc0 	call	270bc <alt_tse_phy_rd_mdio_reg>
   28a48:	1007883a 	mov	r3,r2
   28a4c:	e0bfff17 	ldw	r2,-4(fp)
   28a50:	10c001c5 	stb	r3,7(r2)
    pphy->link_capability.cap_100_base_t2_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_FULL, 1);
   28a54:	e13fff17 	ldw	r4,-4(fp)
   28a58:	01400044 	movi	r5,1
   28a5c:	01800284 	movi	r6,10
   28a60:	01c00044 	movi	r7,1
   28a64:	00270bc0 	call	270bc <alt_tse_phy_rd_mdio_reg>
   28a68:	1007883a 	mov	r3,r2
   28a6c:	e0bfff17 	ldw	r2,-4(fp)
   28a70:	10c00205 	stb	r3,8(r2)
    pphy->link_capability.cap_100_base_t2_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_HALF, 1);
   28a74:	e13fff17 	ldw	r4,-4(fp)
   28a78:	01400044 	movi	r5,1
   28a7c:	01800244 	movi	r6,9
   28a80:	01c00044 	movi	r7,1
   28a84:	00270bc0 	call	270bc <alt_tse_phy_rd_mdio_reg>
   28a88:	1007883a 	mov	r3,r2
   28a8c:	e0bfff17 	ldw	r2,-4(fp)
   28a90:	10c00245 	stb	r3,9(r2)
    pphy->link_capability.cap_10_base_t_full   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_FULL, 1);
   28a94:	e13fff17 	ldw	r4,-4(fp)
   28a98:	01400044 	movi	r5,1
   28a9c:	01800304 	movi	r6,12
   28aa0:	01c00044 	movi	r7,1
   28aa4:	00270bc0 	call	270bc <alt_tse_phy_rd_mdio_reg>
   28aa8:	1007883a 	mov	r3,r2
   28aac:	e0bfff17 	ldw	r2,-4(fp)
   28ab0:	10c00285 	stb	r3,10(r2)
    pphy->link_capability.cap_10_base_t_half   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_HALF, 1);
   28ab4:	e13fff17 	ldw	r4,-4(fp)
   28ab8:	01400044 	movi	r5,1
   28abc:	018002c4 	movi	r6,11
   28ac0:	01c00044 	movi	r7,1
   28ac4:	00270bc0 	call	270bc <alt_tse_phy_rd_mdio_reg>
   28ac8:	1007883a 	mov	r3,r2
   28acc:	e0bfff17 	ldw	r2,-4(fp)
   28ad0:	10c002c5 	stb	r3,11(r2)
    
    /* get link partner capability */
    pphy->link_capability.lp_1000_base_t_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_FULL_ADV, 1);
   28ad4:	e13fff17 	ldw	r4,-4(fp)
   28ad8:	01400284 	movi	r5,10
   28adc:	018002c4 	movi	r6,11
   28ae0:	01c00044 	movi	r7,1
   28ae4:	00270bc0 	call	270bc <alt_tse_phy_rd_mdio_reg>
   28ae8:	1007883a 	mov	r3,r2
   28aec:	e0bfff17 	ldw	r2,-4(fp)
   28af0:	10c00305 	stb	r3,12(r2)
    pphy->link_capability.lp_1000_base_t_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_HALF_ADV, 1);
   28af4:	e13fff17 	ldw	r4,-4(fp)
   28af8:	01400284 	movi	r5,10
   28afc:	01800284 	movi	r6,10
   28b00:	01c00044 	movi	r7,1
   28b04:	00270bc0 	call	270bc <alt_tse_phy_rd_mdio_reg>
   28b08:	1007883a 	mov	r3,r2
   28b0c:	e0bfff17 	ldw	r2,-4(fp)
   28b10:	10c00345 	stb	r3,13(r2)
    
    pphy->link_capability.lp_100_base_t4       = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1);
   28b14:	e13fff17 	ldw	r4,-4(fp)
   28b18:	01400144 	movi	r5,5
   28b1c:	01800244 	movi	r6,9
   28b20:	01c00044 	movi	r7,1
   28b24:	00270bc0 	call	270bc <alt_tse_phy_rd_mdio_reg>
   28b28:	1007883a 	mov	r3,r2
   28b2c:	e0bfff17 	ldw	r2,-4(fp)
   28b30:	10c00385 	stb	r3,14(r2)
    pphy->link_capability.lp_100_base_tx_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1);
   28b34:	e13fff17 	ldw	r4,-4(fp)
   28b38:	01400144 	movi	r5,5
   28b3c:	01800204 	movi	r6,8
   28b40:	01c00044 	movi	r7,1
   28b44:	00270bc0 	call	270bc <alt_tse_phy_rd_mdio_reg>
   28b48:	1007883a 	mov	r3,r2
   28b4c:	e0bfff17 	ldw	r2,-4(fp)
   28b50:	10c003c5 	stb	r3,15(r2)
    pphy->link_capability.lp_100_base_tx_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1);
   28b54:	e13fff17 	ldw	r4,-4(fp)
   28b58:	01400144 	movi	r5,5
   28b5c:	018001c4 	movi	r6,7
   28b60:	01c00044 	movi	r7,1
   28b64:	00270bc0 	call	270bc <alt_tse_phy_rd_mdio_reg>
   28b68:	1007883a 	mov	r3,r2
   28b6c:	e0bfff17 	ldw	r2,-4(fp)
   28b70:	10c00405 	stb	r3,16(r2)
    pphy->link_capability.lp_10_base_tx_full   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1);
   28b74:	e13fff17 	ldw	r4,-4(fp)
   28b78:	01400144 	movi	r5,5
   28b7c:	01800184 	movi	r6,6
   28b80:	01c00044 	movi	r7,1
   28b84:	00270bc0 	call	270bc <alt_tse_phy_rd_mdio_reg>
   28b88:	1007883a 	mov	r3,r2
   28b8c:	e0bfff17 	ldw	r2,-4(fp)
   28b90:	10c00445 	stb	r3,17(r2)
    pphy->link_capability.lp_10_base_tx_half   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1);
   28b94:	e13fff17 	ldw	r4,-4(fp)
   28b98:	01400144 	movi	r5,5
   28b9c:	01800144 	movi	r6,5
   28ba0:	01c00044 	movi	r7,1
   28ba4:	00270bc0 	call	270bc <alt_tse_phy_rd_mdio_reg>
   28ba8:	1007883a 	mov	r3,r2
   28bac:	e0bfff17 	ldw	r2,-4(fp)
   28bb0:	10c00485 	stb	r3,18(r2)
    
    tse_dprintf(6, "INFO    : PHY[%d.%d] - Capability of PHY :\n", mac_group_index, mac_info_index);
   28bb4:	e0fffe47 	ldb	r3,-7(fp)
   28bb8:	e0bffe07 	ldb	r2,-8(fp)
   28bbc:	010000f4 	movhi	r4,3
   28bc0:	2101db04 	addi	r4,r4,1900
   28bc4:	180b883a 	mov	r5,r3
   28bc8:	100d883a 	mov	r6,r2
   28bcc:	0024fd00 	call	24fd0 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-X Full Duplex = %d\n", pphy->link_capability.cap_1000_base_x_full);
   28bd0:	e0bfff17 	ldw	r2,-4(fp)
   28bd4:	10800043 	ldbu	r2,1(r2)
   28bd8:	10803fcc 	andi	r2,r2,255
   28bdc:	010000f4 	movhi	r4,3
   28be0:	2101e604 	addi	r4,r4,1944
   28be4:	100b883a 	mov	r5,r2
   28be8:	0024fd00 	call	24fd0 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-X Half Duplex = %d\n", pphy->link_capability.cap_1000_base_x_half);
   28bec:	e0bfff17 	ldw	r2,-4(fp)
   28bf0:	10800083 	ldbu	r2,2(r2)
   28bf4:	10803fcc 	andi	r2,r2,255
   28bf8:	010000f4 	movhi	r4,3
   28bfc:	2101f004 	addi	r4,r4,1984
   28c00:	100b883a 	mov	r5,r2
   28c04:	0024fd00 	call	24fd0 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Full Duplex = %d\n", pphy->link_capability.cap_1000_base_t_full);
   28c08:	e0bfff17 	ldw	r2,-4(fp)
   28c0c:	108000c3 	ldbu	r2,3(r2)
   28c10:	10803fcc 	andi	r2,r2,255
   28c14:	010000f4 	movhi	r4,3
   28c18:	2101fa04 	addi	r4,r4,2024
   28c1c:	100b883a 	mov	r5,r2
   28c20:	0024fd00 	call	24fd0 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Half Duplex = %d\n", pphy->link_capability.cap_1000_base_t_half);
   28c24:	e0bfff17 	ldw	r2,-4(fp)
   28c28:	10800103 	ldbu	r2,4(r2)
   28c2c:	10803fcc 	andi	r2,r2,255
   28c30:	010000f4 	movhi	r4,3
   28c34:	21020404 	addi	r4,r4,2064
   28c38:	100b883a 	mov	r5,r2
   28c3c:	0024fd00 	call	24fd0 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T4             = %d\n", pphy->link_capability.cap_100_base_t4);
   28c40:	e0bfff17 	ldw	r2,-4(fp)
   28c44:	10800143 	ldbu	r2,5(r2)
   28c48:	10803fcc 	andi	r2,r2,255
   28c4c:	010000f4 	movhi	r4,3
   28c50:	21020e04 	addi	r4,r4,2104
   28c54:	100b883a 	mov	r5,r2
   28c58:	0024fd00 	call	24fd0 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-X Full Duplex  = %d\n", pphy->link_capability.cap_100_base_x_full);
   28c5c:	e0bfff17 	ldw	r2,-4(fp)
   28c60:	10800183 	ldbu	r2,6(r2)
   28c64:	10803fcc 	andi	r2,r2,255
   28c68:	010000f4 	movhi	r4,3
   28c6c:	21021804 	addi	r4,r4,2144
   28c70:	100b883a 	mov	r5,r2
   28c74:	0024fd00 	call	24fd0 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-X Half Duplex  = %d\n", pphy->link_capability.cap_100_base_x_half);
   28c78:	e0bfff17 	ldw	r2,-4(fp)
   28c7c:	108001c3 	ldbu	r2,7(r2)
   28c80:	10803fcc 	andi	r2,r2,255
   28c84:	010000f4 	movhi	r4,3
   28c88:	21022204 	addi	r4,r4,2184
   28c8c:	100b883a 	mov	r5,r2
   28c90:	0024fd00 	call	24fd0 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T2 Full Duplex = %d\n", pphy->link_capability.cap_100_base_t2_full);
   28c94:	e0bfff17 	ldw	r2,-4(fp)
   28c98:	10800203 	ldbu	r2,8(r2)
   28c9c:	10803fcc 	andi	r2,r2,255
   28ca0:	010000f4 	movhi	r4,3
   28ca4:	21022c04 	addi	r4,r4,2224
   28ca8:	100b883a 	mov	r5,r2
   28cac:	0024fd00 	call	24fd0 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T2 Half Duplex = %d\n", pphy->link_capability.cap_100_base_t2_half);
   28cb0:	e0bfff17 	ldw	r2,-4(fp)
   28cb4:	10800243 	ldbu	r2,9(r2)
   28cb8:	10803fcc 	andi	r2,r2,255
   28cbc:	010000f4 	movhi	r4,3
   28cc0:	21023604 	addi	r4,r4,2264
   28cc4:	100b883a 	mov	r5,r2
   28cc8:	0024fd00 	call	24fd0 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-T Full Duplex   = %d\n", pphy->link_capability.cap_10_base_t_full);
   28ccc:	e0bfff17 	ldw	r2,-4(fp)
   28cd0:	10800283 	ldbu	r2,10(r2)
   28cd4:	10803fcc 	andi	r2,r2,255
   28cd8:	010000f4 	movhi	r4,3
   28cdc:	21024004 	addi	r4,r4,2304
   28ce0:	100b883a 	mov	r5,r2
   28ce4:	0024fd00 	call	24fd0 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-T Half Duplex   = %d\n", pphy->link_capability.cap_10_base_t_half);
   28ce8:	e0bfff17 	ldw	r2,-4(fp)
   28cec:	108002c3 	ldbu	r2,11(r2)
   28cf0:	10803fcc 	andi	r2,r2,255
   28cf4:	010000f4 	movhi	r4,3
   28cf8:	21024a04 	addi	r4,r4,2344
   28cfc:	100b883a 	mov	r5,r2
   28d00:	0024fd00 	call	24fd0 <no_printf>
    tse_dprintf(6, "\n");
   28d04:	010000f4 	movhi	r4,3
   28d08:	2100b004 	addi	r4,r4,704
   28d0c:	0024fd00 	call	24fd0 <no_printf>
    
    tse_dprintf(6, "INFO    : PHY[%d.%d] - Link Partner Capability :\n", mac_group_index, mac_info_index);
   28d10:	e0fffe47 	ldb	r3,-7(fp)
   28d14:	e0bffe07 	ldb	r2,-8(fp)
   28d18:	010000f4 	movhi	r4,3
   28d1c:	21025404 	addi	r4,r4,2384
   28d20:	180b883a 	mov	r5,r3
   28d24:	100d883a 	mov	r6,r2
   28d28:	0024fd00 	call	24fd0 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Full Duplex = %d\n", pphy->link_capability.lp_1000_base_t_full);
   28d2c:	e0bfff17 	ldw	r2,-4(fp)
   28d30:	10800303 	ldbu	r2,12(r2)
   28d34:	10803fcc 	andi	r2,r2,255
   28d38:	010000f4 	movhi	r4,3
   28d3c:	2101fa04 	addi	r4,r4,2024
   28d40:	100b883a 	mov	r5,r2
   28d44:	0024fd00 	call	24fd0 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Half Duplex = %d\n", pphy->link_capability.lp_1000_base_t_half);
   28d48:	e0bfff17 	ldw	r2,-4(fp)
   28d4c:	10800343 	ldbu	r2,13(r2)
   28d50:	10803fcc 	andi	r2,r2,255
   28d54:	010000f4 	movhi	r4,3
   28d58:	21020404 	addi	r4,r4,2064
   28d5c:	100b883a 	mov	r5,r2
   28d60:	0024fd00 	call	24fd0 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T4             = %d\n", pphy->link_capability.lp_100_base_t4);
   28d64:	e0bfff17 	ldw	r2,-4(fp)
   28d68:	10800383 	ldbu	r2,14(r2)
   28d6c:	10803fcc 	andi	r2,r2,255
   28d70:	010000f4 	movhi	r4,3
   28d74:	21020e04 	addi	r4,r4,2104
   28d78:	100b883a 	mov	r5,r2
   28d7c:	0024fd00 	call	24fd0 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-TX Full Duplex = %d\n", pphy->link_capability.lp_100_base_tx_full);
   28d80:	e0bfff17 	ldw	r2,-4(fp)
   28d84:	108003c3 	ldbu	r2,15(r2)
   28d88:	10803fcc 	andi	r2,r2,255
   28d8c:	010000f4 	movhi	r4,3
   28d90:	21026104 	addi	r4,r4,2436
   28d94:	100b883a 	mov	r5,r2
   28d98:	0024fd00 	call	24fd0 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-TX Half Duplex = %d\n", pphy->link_capability.lp_100_base_tx_half);
   28d9c:	e0bfff17 	ldw	r2,-4(fp)
   28da0:	10800403 	ldbu	r2,16(r2)
   28da4:	10803fcc 	andi	r2,r2,255
   28da8:	010000f4 	movhi	r4,3
   28dac:	21026b04 	addi	r4,r4,2476
   28db0:	100b883a 	mov	r5,r2
   28db4:	0024fd00 	call	24fd0 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-TX Full Duplex  = %d\n", pphy->link_capability.lp_10_base_tx_full);
   28db8:	e0bfff17 	ldw	r2,-4(fp)
   28dbc:	10800443 	ldbu	r2,17(r2)
   28dc0:	10803fcc 	andi	r2,r2,255
   28dc4:	010000f4 	movhi	r4,3
   28dc8:	21027504 	addi	r4,r4,2516
   28dcc:	100b883a 	mov	r5,r2
   28dd0:	0024fd00 	call	24fd0 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-TX Half Duplex  = %d\n", pphy->link_capability.lp_10_base_tx_half);
   28dd4:	e0bfff17 	ldw	r2,-4(fp)
   28dd8:	10800483 	ldbu	r2,18(r2)
   28ddc:	10803fcc 	andi	r2,r2,255
   28de0:	010000f4 	movhi	r4,3
   28de4:	21027f04 	addi	r4,r4,2556
   28de8:	100b883a 	mov	r5,r2
   28dec:	0024fd00 	call	24fd0 <no_printf>
    tse_dprintf(6, "\n");
   28df0:	010000f4 	movhi	r4,3
   28df4:	2100b004 	addi	r4,r4,704
   28df8:	0024fd00 	call	24fd0 <no_printf>
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
   28dfc:	e0bffe83 	ldbu	r2,-6(fp)
   28e00:	e13fff17 	ldw	r4,-4(fp)
   28e04:	100b883a 	mov	r5,r2
   28e08:	0026f380 	call	26f38 <alt_tse_phy_wr_mdio_addr>
    
    return return_value;
   28e0c:	e0bffb17 	ldw	r2,-20(fp)
    
}
   28e10:	e037883a 	mov	sp,fp
   28e14:	dfc00117 	ldw	ra,4(sp)
   28e18:	df000017 	ldw	fp,0(sp)
   28e1c:	dec00204 	addi	sp,sp,8
   28e20:	f800283a 	ret

00028e24 <alt_tse_phy_set_adv_1000>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_1000(alt_tse_phy_info *pphy, alt_u8 enable) {
   28e24:	defff804 	addi	sp,sp,-32
   28e28:	dfc00715 	stw	ra,28(sp)
   28e2c:	df000615 	stw	fp,24(sp)
   28e30:	df000604 	addi	fp,sp,24
   28e34:	e13ffe15 	stw	r4,-8(fp)
   28e38:	2805883a 	mov	r2,r5
   28e3c:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
   28e40:	e0bffe17 	ldw	r2,-8(fp)
   28e44:	10800617 	ldw	r2,24(r2)
   28e48:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
   28e4c:	e0bffb17 	ldw	r2,-20(fp)
   28e50:	10800317 	ldw	r2,12(r2)
   28e54:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
   28e58:	e13ffb17 	ldw	r4,-20(fp)
   28e5c:	00261b80 	call	261b8 <alt_tse_get_mac_info_index>
   28e60:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
   28e64:	e13ffc17 	ldw	r4,-16(fp)
   28e68:	00261440 	call	26144 <alt_tse_get_mac_group_index>
   28e6c:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
   28e70:	e13ffe17 	ldw	r4,-8(fp)
   28e74:	0026ef00 	call	26ef0 <alt_tse_phy_rd_mdio_addr>
   28e78:	e0bffd85 	stb	r2,-10(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
   28e7c:	e0bffe17 	ldw	r2,-8(fp)
   28e80:	10800003 	ldbu	r2,0(r2)
   28e84:	10803fcc 	andi	r2,r2,255
   28e88:	e13ffe17 	ldw	r4,-8(fp)
   28e8c:	100b883a 	mov	r5,r2
   28e90:	0026f380 	call	26f38 <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
   28e94:	e0bfff03 	ldbu	r2,-4(fp)
   28e98:	10002b26 	beq	r2,zero,28f48 <alt_tse_phy_set_adv_1000+0x124>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_FULL, 1); 
   28e9c:	e13ffe17 	ldw	r4,-8(fp)
   28ea0:	014003c4 	movi	r5,15
   28ea4:	01800344 	movi	r6,13
   28ea8:	01c00044 	movi	r7,1
   28eac:	00270bc0 	call	270bc <alt_tse_phy_rd_mdio_reg>
   28eb0:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_FULL_ADV, 1, cap);
   28eb4:	e0bffdc3 	ldbu	r2,-9(fp)
   28eb8:	d8800015 	stw	r2,0(sp)
   28ebc:	e13ffe17 	ldw	r4,-8(fp)
   28ec0:	01400244 	movi	r5,9
   28ec4:	01800244 	movi	r6,9
   28ec8:	01c00044 	movi	r7,1
   28ecc:	0026f900 	call	26f90 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
   28ed0:	e17ffd47 	ldb	r5,-11(fp)
   28ed4:	e0fffd07 	ldb	r3,-12(fp)
   28ed8:	e0bffdc3 	ldbu	r2,-9(fp)
   28edc:	010000f4 	movhi	r4,3
   28ee0:	21028904 	addi	r4,r4,2596
   28ee4:	180d883a 	mov	r6,r3
   28ee8:	100f883a 	mov	r7,r2
   28eec:	0024fd00 	call	24fd0 <no_printf>
        
        /* 1000 Mbps Half duplex not supported by TSE MAC */
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_HALF, 1);
   28ef0:	e13ffe17 	ldw	r4,-8(fp)
   28ef4:	014003c4 	movi	r5,15
   28ef8:	01800304 	movi	r6,12
   28efc:	01c00044 	movi	r7,1
   28f00:	00270bc0 	call	270bc <alt_tse_phy_rd_mdio_reg>
   28f04:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_HALF_ADV, 1, cap);
   28f08:	e0bffdc3 	ldbu	r2,-9(fp)
   28f0c:	d8800015 	stw	r2,0(sp)
   28f10:	e13ffe17 	ldw	r4,-8(fp)
   28f14:	01400244 	movi	r5,9
   28f18:	01800204 	movi	r6,8
   28f1c:	01c00044 	movi	r7,1
   28f20:	0026f900 	call	26f90 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
   28f24:	e17ffd47 	ldb	r5,-11(fp)
   28f28:	e0fffd07 	ldb	r3,-12(fp)
   28f2c:	e0bffdc3 	ldbu	r2,-9(fp)
   28f30:	010000f4 	movhi	r4,3
   28f34:	21029c04 	addi	r4,r4,2672
   28f38:	180d883a 	mov	r6,r3
   28f3c:	100f883a 	mov	r7,r2
   28f40:	0024fd00 	call	24fd0 <no_printf>
   28f44:	00001c06 	br	28fb8 <alt_tse_phy_set_adv_1000+0x194>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_FULL_ADV, 1, 0);
   28f48:	d8000015 	stw	zero,0(sp)
   28f4c:	e13ffe17 	ldw	r4,-8(fp)
   28f50:	01400244 	movi	r5,9
   28f54:	01800244 	movi	r6,9
   28f58:	01c00044 	movi	r7,1
   28f5c:	0026f900 	call	26f90 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
   28f60:	e0fffd47 	ldb	r3,-11(fp)
   28f64:	e0bffd07 	ldb	r2,-12(fp)
   28f68:	010000f4 	movhi	r4,3
   28f6c:	21028904 	addi	r4,r4,2596
   28f70:	180b883a 	mov	r5,r3
   28f74:	100d883a 	mov	r6,r2
   28f78:	000f883a 	mov	r7,zero
   28f7c:	0024fd00 	call	24fd0 <no_printf>
        
        /* 1000 Mbps Half duplex not supported by TSE MAC */
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_HALF_ADV, 1, 0);
   28f80:	d8000015 	stw	zero,0(sp)
   28f84:	e13ffe17 	ldw	r4,-8(fp)
   28f88:	01400244 	movi	r5,9
   28f8c:	01800204 	movi	r6,8
   28f90:	01c00044 	movi	r7,1
   28f94:	0026f900 	call	26f90 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement 1000 Base-T half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
   28f98:	e0fffd47 	ldb	r3,-11(fp)
   28f9c:	e0bffd07 	ldb	r2,-12(fp)
   28fa0:	010000f4 	movhi	r4,3
   28fa4:	2102af04 	addi	r4,r4,2748
   28fa8:	180b883a 	mov	r5,r3
   28fac:	100d883a 	mov	r6,r2
   28fb0:	000f883a 	mov	r7,zero
   28fb4:	0024fd00 	call	24fd0 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);    
   28fb8:	e0bffd83 	ldbu	r2,-10(fp)
   28fbc:	e13ffe17 	ldw	r4,-8(fp)
   28fc0:	100b883a 	mov	r5,r2
   28fc4:	0026f380 	call	26f38 <alt_tse_phy_wr_mdio_addr>

    return SUCCESS;
   28fc8:	0005883a 	mov	r2,zero
}
   28fcc:	e037883a 	mov	sp,fp
   28fd0:	dfc00117 	ldw	ra,4(sp)
   28fd4:	df000017 	ldw	fp,0(sp)
   28fd8:	dec00204 	addi	sp,sp,8
   28fdc:	f800283a 	ret

00028fe0 <alt_tse_phy_set_adv_100>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_100(alt_tse_phy_info *pphy, alt_u8 enable) {
   28fe0:	defff804 	addi	sp,sp,-32
   28fe4:	dfc00715 	stw	ra,28(sp)
   28fe8:	df000615 	stw	fp,24(sp)
   28fec:	df000604 	addi	fp,sp,24
   28ff0:	e13ffe15 	stw	r4,-8(fp)
   28ff4:	2805883a 	mov	r2,r5
   28ff8:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
   28ffc:	e0bffe17 	ldw	r2,-8(fp)
   29000:	10800617 	ldw	r2,24(r2)
   29004:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
   29008:	e0bffb17 	ldw	r2,-20(fp)
   2900c:	10800317 	ldw	r2,12(r2)
   29010:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
   29014:	e13ffb17 	ldw	r4,-20(fp)
   29018:	00261b80 	call	261b8 <alt_tse_get_mac_info_index>
   2901c:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
   29020:	e13ffc17 	ldw	r4,-16(fp)
   29024:	00261440 	call	26144 <alt_tse_get_mac_group_index>
   29028:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
   2902c:	e13ffe17 	ldw	r4,-8(fp)
   29030:	0026ef00 	call	26ef0 <alt_tse_phy_rd_mdio_addr>
   29034:	e0bffd85 	stb	r2,-10(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
   29038:	e0bffe17 	ldw	r2,-8(fp)
   2903c:	10800003 	ldbu	r2,0(r2)
   29040:	10803fcc 	andi	r2,r2,255
   29044:	e13ffe17 	ldw	r4,-8(fp)
   29048:	100b883a 	mov	r5,r2
   2904c:	0026f380 	call	26f38 <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
   29050:	e0bfff03 	ldbu	r2,-4(fp)
   29054:	10004026 	beq	r2,zero,29158 <alt_tse_phy_set_adv_100+0x178>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T4, 1);
   29058:	e13ffe17 	ldw	r4,-8(fp)
   2905c:	01400044 	movi	r5,1
   29060:	018003c4 	movi	r6,15
   29064:	01c00044 	movi	r7,1
   29068:	00270bc0 	call	270bc <alt_tse_phy_rd_mdio_reg>
   2906c:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1, cap);
   29070:	e0bffdc3 	ldbu	r2,-9(fp)
   29074:	d8800015 	stw	r2,0(sp)
   29078:	e13ffe17 	ldw	r4,-8(fp)
   2907c:	01400104 	movi	r5,4
   29080:	01800244 	movi	r6,9
   29084:	01c00044 	movi	r7,1
   29088:	0026f900 	call	26f90 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-T4 set to %d\n", mac_group_index, mac_info_index, cap);
   2908c:	e17ffd47 	ldb	r5,-11(fp)
   29090:	e0fffd07 	ldb	r3,-12(fp)
   29094:	e0bffdc3 	ldbu	r2,-9(fp)
   29098:	010000f4 	movhi	r4,3
   2909c:	2102c104 	addi	r4,r4,2820
   290a0:	180d883a 	mov	r6,r3
   290a4:	100f883a 	mov	r7,r2
   290a8:	0024fd00 	call	24fd0 <no_printf>
        
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_FULL, 1);
   290ac:	e13ffe17 	ldw	r4,-8(fp)
   290b0:	01400044 	movi	r5,1
   290b4:	01800384 	movi	r6,14
   290b8:	01c00044 	movi	r7,1
   290bc:	00270bc0 	call	270bc <alt_tse_phy_rd_mdio_reg>
   290c0:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1, cap);
   290c4:	e0bffdc3 	ldbu	r2,-9(fp)
   290c8:	d8800015 	stw	r2,0(sp)
   290cc:	e13ffe17 	ldw	r4,-8(fp)
   290d0:	01400104 	movi	r5,4
   290d4:	01800204 	movi	r6,8
   290d8:	01c00044 	movi	r7,1
   290dc:	0026f900 	call	26f90 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
   290e0:	e17ffd47 	ldb	r5,-11(fp)
   290e4:	e0fffd07 	ldb	r3,-12(fp)
   290e8:	e0bffdc3 	ldbu	r2,-9(fp)
   290ec:	010000f4 	movhi	r4,3
   290f0:	2102d104 	addi	r4,r4,2884
   290f4:	180d883a 	mov	r6,r3
   290f8:	100f883a 	mov	r7,r2
   290fc:	0024fd00 	call	24fd0 <no_printf>
        
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_HALF, 1);
   29100:	e13ffe17 	ldw	r4,-8(fp)
   29104:	01400044 	movi	r5,1
   29108:	01800344 	movi	r6,13
   2910c:	01c00044 	movi	r7,1
   29110:	00270bc0 	call	270bc <alt_tse_phy_rd_mdio_reg>
   29114:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1, cap);
   29118:	e0bffdc3 	ldbu	r2,-9(fp)
   2911c:	d8800015 	stw	r2,0(sp)
   29120:	e13ffe17 	ldw	r4,-8(fp)
   29124:	01400104 	movi	r5,4
   29128:	018001c4 	movi	r6,7
   2912c:	01c00044 	movi	r7,1
   29130:	0026f900 	call	26f90 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
   29134:	e17ffd47 	ldb	r5,-11(fp)
   29138:	e0fffd07 	ldb	r3,-12(fp)
   2913c:	e0bffdc3 	ldbu	r2,-9(fp)
   29140:	010000f4 	movhi	r4,3
   29144:	2102e404 	addi	r4,r4,2960
   29148:	180d883a 	mov	r6,r3
   2914c:	100f883a 	mov	r7,r2
   29150:	0024fd00 	call	24fd0 <no_printf>
   29154:	00002a06 	br	29200 <alt_tse_phy_set_adv_100+0x220>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1, 0);
   29158:	d8000015 	stw	zero,0(sp)
   2915c:	e13ffe17 	ldw	r4,-8(fp)
   29160:	01400104 	movi	r5,4
   29164:	01800244 	movi	r6,9
   29168:	01c00044 	movi	r7,1
   2916c:	0026f900 	call	26f90 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-T4 set to %d\n", mac_group_index, mac_info_index, 0);
   29170:	e0fffd47 	ldb	r3,-11(fp)
   29174:	e0bffd07 	ldb	r2,-12(fp)
   29178:	010000f4 	movhi	r4,3
   2917c:	2102c104 	addi	r4,r4,2820
   29180:	180b883a 	mov	r5,r3
   29184:	100d883a 	mov	r6,r2
   29188:	000f883a 	mov	r7,zero
   2918c:	0024fd00 	call	24fd0 <no_printf>
        
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1, 0);
   29190:	d8000015 	stw	zero,0(sp)
   29194:	e13ffe17 	ldw	r4,-8(fp)
   29198:	01400104 	movi	r5,4
   2919c:	01800204 	movi	r6,8
   291a0:	01c00044 	movi	r7,1
   291a4:	0026f900 	call	26f90 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
   291a8:	e0fffd47 	ldb	r3,-11(fp)
   291ac:	e0bffd07 	ldb	r2,-12(fp)
   291b0:	010000f4 	movhi	r4,3
   291b4:	2102d104 	addi	r4,r4,2884
   291b8:	180b883a 	mov	r5,r3
   291bc:	100d883a 	mov	r6,r2
   291c0:	000f883a 	mov	r7,zero
   291c4:	0024fd00 	call	24fd0 <no_printf>
        
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1, 0);
   291c8:	d8000015 	stw	zero,0(sp)
   291cc:	e13ffe17 	ldw	r4,-8(fp)
   291d0:	01400104 	movi	r5,4
   291d4:	018001c4 	movi	r6,7
   291d8:	01c00044 	movi	r7,1
   291dc:	0026f900 	call	26f90 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
   291e0:	e0fffd47 	ldb	r3,-11(fp)
   291e4:	e0bffd07 	ldb	r2,-12(fp)
   291e8:	010000f4 	movhi	r4,3
   291ec:	2102e404 	addi	r4,r4,2960
   291f0:	180b883a 	mov	r5,r3
   291f4:	100d883a 	mov	r6,r2
   291f8:	000f883a 	mov	r7,zero
   291fc:	0024fd00 	call	24fd0 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);  
   29200:	e0bffd83 	ldbu	r2,-10(fp)
   29204:	e13ffe17 	ldw	r4,-8(fp)
   29208:	100b883a 	mov	r5,r2
   2920c:	0026f380 	call	26f38 <alt_tse_phy_wr_mdio_addr>
    
    return SUCCESS;
   29210:	0005883a 	mov	r2,zero
}
   29214:	e037883a 	mov	sp,fp
   29218:	dfc00117 	ldw	ra,4(sp)
   2921c:	df000017 	ldw	fp,0(sp)
   29220:	dec00204 	addi	sp,sp,8
   29224:	f800283a 	ret

00029228 <alt_tse_phy_set_adv_10>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_10(alt_tse_phy_info *pphy, alt_u8 enable) {
   29228:	defff504 	addi	sp,sp,-44
   2922c:	dfc00a15 	stw	ra,40(sp)
   29230:	df000915 	stw	fp,36(sp)
   29234:	df000904 	addi	fp,sp,36
   29238:	e13ffe15 	stw	r4,-8(fp)
   2923c:	2805883a 	mov	r2,r5
   29240:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
   29244:	e0bffe17 	ldw	r2,-8(fp)
   29248:	10800617 	ldw	r2,24(r2)
   2924c:	e0bff815 	stw	r2,-32(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
   29250:	e0bff817 	ldw	r2,-32(fp)
   29254:	10800317 	ldw	r2,12(r2)
   29258:	e0bff915 	stw	r2,-28(fp)
    
    /* get index of the pointers in pointer array list */
    int mac_info_index = alt_tse_get_mac_info_index(pmac_info);
   2925c:	e13ff817 	ldw	r4,-32(fp)
   29260:	00261b80 	call	261b8 <alt_tse_get_mac_info_index>
   29264:	e0bffa15 	stw	r2,-24(fp)
    int mac_group_index = alt_tse_get_mac_group_index(pmac_group);
   29268:	e13ff917 	ldw	r4,-28(fp)
   2926c:	00261440 	call	26144 <alt_tse_get_mac_group_index>
   29270:	e0bffb15 	stw	r2,-20(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    int mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
   29274:	e13ffe17 	ldw	r4,-8(fp)
   29278:	0026ef00 	call	26ef0 <alt_tse_phy_rd_mdio_addr>
   2927c:	e0bffc15 	stw	r2,-16(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
   29280:	e0bffe17 	ldw	r2,-8(fp)
   29284:	10800003 	ldbu	r2,0(r2)
   29288:	10803fcc 	andi	r2,r2,255
   2928c:	e13ffe17 	ldw	r4,-8(fp)
   29290:	100b883a 	mov	r5,r2
   29294:	0026f380 	call	26f38 <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
   29298:	e0bfff03 	ldbu	r2,-4(fp)
   2929c:	10002926 	beq	r2,zero,29344 <alt_tse_phy_set_adv_10+0x11c>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_FULL, 1);
   292a0:	e13ffe17 	ldw	r4,-8(fp)
   292a4:	01400044 	movi	r5,1
   292a8:	01800304 	movi	r6,12
   292ac:	01c00044 	movi	r7,1
   292b0:	00270bc0 	call	270bc <alt_tse_phy_rd_mdio_reg>
   292b4:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1, cap);
   292b8:	e0bffd03 	ldbu	r2,-12(fp)
   292bc:	d8800015 	stw	r2,0(sp)
   292c0:	e13ffe17 	ldw	r4,-8(fp)
   292c4:	01400104 	movi	r5,4
   292c8:	01800184 	movi	r6,6
   292cc:	01c00044 	movi	r7,1
   292d0:	0026f900 	call	26f90 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
   292d4:	e0bffd03 	ldbu	r2,-12(fp)
   292d8:	010000f4 	movhi	r4,3
   292dc:	2102f704 	addi	r4,r4,3036
   292e0:	e17ffb17 	ldw	r5,-20(fp)
   292e4:	e1bffa17 	ldw	r6,-24(fp)
   292e8:	100f883a 	mov	r7,r2
   292ec:	0024fd00 	call	24fd0 <no_printf>
    
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_HALF, 1);
   292f0:	e13ffe17 	ldw	r4,-8(fp)
   292f4:	01400044 	movi	r5,1
   292f8:	018002c4 	movi	r6,11
   292fc:	01c00044 	movi	r7,1
   29300:	00270bc0 	call	270bc <alt_tse_phy_rd_mdio_reg>
   29304:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1, cap);
   29308:	e0bffd03 	ldbu	r2,-12(fp)
   2930c:	d8800015 	stw	r2,0(sp)
   29310:	e13ffe17 	ldw	r4,-8(fp)
   29314:	01400104 	movi	r5,4
   29318:	01800144 	movi	r6,5
   2931c:	01c00044 	movi	r7,1
   29320:	0026f900 	call	26f90 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
   29324:	e0bffd03 	ldbu	r2,-12(fp)
   29328:	010000f4 	movhi	r4,3
   2932c:	21030a04 	addi	r4,r4,3112
   29330:	e17ffb17 	ldw	r5,-20(fp)
   29334:	e1bffa17 	ldw	r6,-24(fp)
   29338:	100f883a 	mov	r7,r2
   2933c:	0024fd00 	call	24fd0 <no_printf>
   29340:	00001806 	br	293a4 <alt_tse_phy_set_adv_10+0x17c>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1, 0);
   29344:	d8000015 	stw	zero,0(sp)
   29348:	e13ffe17 	ldw	r4,-8(fp)
   2934c:	01400104 	movi	r5,4
   29350:	01800184 	movi	r6,6
   29354:	01c00044 	movi	r7,1
   29358:	0026f900 	call	26f90 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
   2935c:	010000f4 	movhi	r4,3
   29360:	2102f704 	addi	r4,r4,3036
   29364:	e17ffb17 	ldw	r5,-20(fp)
   29368:	e1bffa17 	ldw	r6,-24(fp)
   2936c:	000f883a 	mov	r7,zero
   29370:	0024fd00 	call	24fd0 <no_printf>
    
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1, 0);
   29374:	d8000015 	stw	zero,0(sp)
   29378:	e13ffe17 	ldw	r4,-8(fp)
   2937c:	01400104 	movi	r5,4
   29380:	01800144 	movi	r6,5
   29384:	01c00044 	movi	r7,1
   29388:	0026f900 	call	26f90 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
   2938c:	010000f4 	movhi	r4,3
   29390:	21030a04 	addi	r4,r4,3112
   29394:	e17ffb17 	ldw	r5,-20(fp)
   29398:	e1bffa17 	ldw	r6,-24(fp)
   2939c:	000f883a 	mov	r7,zero
   293a0:	0024fd00 	call	24fd0 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
   293a4:	e0bffc17 	ldw	r2,-16(fp)
   293a8:	10803fcc 	andi	r2,r2,255
   293ac:	e13ffe17 	ldw	r4,-8(fp)
   293b0:	100b883a 	mov	r5,r2
   293b4:	0026f380 	call	26f38 <alt_tse_phy_wr_mdio_addr>
    
    return SUCCESS;
   293b8:	0005883a 	mov	r2,zero
}
   293bc:	e037883a 	mov	sp,fp
   293c0:	dfc00117 	ldw	ra,4(sp)
   293c4:	df000017 	ldw	fp,0(sp)
   293c8:	dec00204 	addi	sp,sp,8
   293cc:	f800283a 	ret

000293d0 <alt_tse_phy_get_common_speed>:
/* @Function Description: Get the common speed supported by all PHYs connected to the MAC within the same group
 * @API Type:           Internal
 * @param pmac_group    Pointer to the TSE MAC Group structure which group all the MACs that should use the same speed
 * @return              common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if no common speed found
 */
alt_32 alt_tse_phy_get_common_speed(alt_tse_mac_group *pmac_group) {
   293d0:	defff604 	addi	sp,sp,-40
   293d4:	dfc00915 	stw	ra,36(sp)
   293d8:	df000815 	stw	fp,32(sp)
   293dc:	df000804 	addi	fp,sp,32
   293e0:	e13fff15 	stw	r4,-4(fp)
    
	alt_32 i;
	alt_u8 common_1000 = 1;
   293e4:	00800044 	movi	r2,1
   293e8:	e0bff905 	stb	r2,-28(fp)
	alt_u8 common_100 = 1;
   293ec:	00800044 	movi	r2,1
   293f0:	e0bff945 	stb	r2,-27(fp)
	alt_u8 common_10 = 1;
   293f4:	00800044 	movi	r2,1
   293f8:	e0bff985 	stb	r2,-26(fp)
    
	alt_32 common_speed;
    
	alt_u8 none_an_complete = 1;
   293fc:	00800044 	movi	r2,1
   29400:	e0bffb05 	stb	r2,-20(fp)
    
    alt_tse_mac_info *pmac_info = 0;
   29404:	e03ffc15 	stw	zero,-16(fp)
    alt_tse_phy_info *pphy = 0;
   29408:	e03ffd15 	stw	zero,-12(fp)
    
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
   2940c:	e13fff17 	ldw	r4,-4(fp)
   29410:	00261440 	call	26144 <alt_tse_get_mac_group_index>
   29414:	e0bffe05 	stb	r2,-8(fp)
    
    /* reset Auto-Negotiation advertisement */
    for(i = 0; i < pmac_group->channel; i++) {
   29418:	e03ff815 	stw	zero,-32(fp)
   2941c:	00001c06 	br	29490 <alt_tse_phy_get_common_speed+0xc0>
        pmac_info = pmac_group->pmac_info[i];
   29420:	e0ffff17 	ldw	r3,-4(fp)
   29424:	e0bff817 	ldw	r2,-32(fp)
   29428:	10800044 	addi	r2,r2,1
   2942c:	1085883a 	add	r2,r2,r2
   29430:	1085883a 	add	r2,r2,r2
   29434:	1885883a 	add	r2,r3,r2
   29438:	10800017 	ldw	r2,0(r2)
   2943c:	e0bffc15 	stw	r2,-16(fp)
        pphy = pmac_info->pphy_info;
   29440:	e0bffc17 	ldw	r2,-16(fp)
   29444:	10800117 	ldw	r2,4(r2)
   29448:	e0bffd15 	stw	r2,-12(fp)
        
        /* run only if PHY connected */
        if(pphy) {
   2944c:	e0bffd17 	ldw	r2,-12(fp)
   29450:	10000926 	beq	r2,zero,29478 <alt_tse_phy_get_common_speed+0xa8>
            alt_tse_phy_set_adv_1000(pphy, 1);
   29454:	e13ffd17 	ldw	r4,-12(fp)
   29458:	01400044 	movi	r5,1
   2945c:	0028e240 	call	28e24 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
   29460:	e13ffd17 	ldw	r4,-12(fp)
   29464:	01400044 	movi	r5,1
   29468:	0028fe00 	call	28fe0 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
   2946c:	e13ffd17 	ldw	r4,-12(fp)
   29470:	01400044 	movi	r5,1
   29474:	00292280 	call	29228 <alt_tse_phy_set_adv_10>
        }
        tse_dprintf(6, "\n");
   29478:	010000f4 	movhi	r4,3
   2947c:	2100b004 	addi	r4,r4,704
   29480:	0024fd00 	call	24fd0 <no_printf>
    alt_tse_phy_info *pphy = 0;
    
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    
    /* reset Auto-Negotiation advertisement */
    for(i = 0; i < pmac_group->channel; i++) {
   29484:	e0bff817 	ldw	r2,-32(fp)
   29488:	10800044 	addi	r2,r2,1
   2948c:	e0bff815 	stw	r2,-32(fp)
   29490:	e0bfff17 	ldw	r2,-4(fp)
   29494:	10800003 	ldbu	r2,0(r2)
   29498:	10803fcc 	andi	r2,r2,255
   2949c:	e0fff817 	ldw	r3,-32(fp)
   294a0:	18bfdf16 	blt	r3,r2,29420 <alt_tse_phy_get_common_speed+0x50>
        }
        tse_dprintf(6, "\n");
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
   294a4:	e03ff815 	stw	zero,-32(fp)
   294a8:	00005606 	br	29604 <alt_tse_phy_get_common_speed+0x234>

        pmac_info = pmac_group->pmac_info[i];
   294ac:	e0ffff17 	ldw	r3,-4(fp)
   294b0:	e0bff817 	ldw	r2,-32(fp)
   294b4:	10800044 	addi	r2,r2,1
   294b8:	1085883a 	add	r2,r2,r2
   294bc:	1085883a 	add	r2,r2,r2
   294c0:	1885883a 	add	r2,r3,r2
   294c4:	10800017 	ldw	r2,0(r2)
   294c8:	e0bffc15 	stw	r2,-16(fp)
        pphy = pmac_info->pphy_info;
   294cc:	e0bffc17 	ldw	r2,-16(fp)
   294d0:	10800117 	ldw	r2,4(r2)
   294d4:	e0bffd15 	stw	r2,-12(fp)
        
        /* if no PHY connected */
        if(!pphy) {
   294d8:	e0bffd17 	ldw	r2,-12(fp)
   294dc:	10004326 	beq	r2,zero,295ec <alt_tse_phy_get_common_speed+0x21c>
            continue;
        }
        
        /* get PHY capability */
        /* skip for PHY with Auto-Negotiation not completed */
        if(alt_tse_phy_get_cap(pphy) != TSE_PHY_AN_COMPLETE) {
   294e0:	e13ffd17 	ldw	r4,-12(fp)
   294e4:	002888c0 	call	2888c <alt_tse_phy_get_cap>
   294e8:	1000421e 	bne	r2,zero,295f4 <alt_tse_phy_get_common_speed+0x224>
            continue;
        }
        
        none_an_complete = 0;
   294ec:	e03ffb05 	stb	zero,-20(fp)
        
        /* Small MAC */
        if(pmac_info->mac_type == ALTERA_TSE_MACLITE_10_100) {
   294f0:	e0bffc17 	ldw	r2,-16(fp)
   294f4:	10800003 	ldbu	r2,0(r2)
   294f8:	10803fcc 	andi	r2,r2,255
   294fc:	10800058 	cmpnei	r2,r2,1
   29500:	1000021e 	bne	r2,zero,2950c <alt_tse_phy_get_common_speed+0x13c>
            common_1000 = 0;
   29504:	e03ff905 	stb	zero,-28(fp)
   29508:	00000706 	br	29528 <alt_tse_phy_get_common_speed+0x158>
        }
        else if(pmac_info->mac_type == ALTERA_TSE_MACLITE_1000) {
   2950c:	e0bffc17 	ldw	r2,-16(fp)
   29510:	10800003 	ldbu	r2,0(r2)
   29514:	10803fcc 	andi	r2,r2,255
   29518:	10800098 	cmpnei	r2,r2,2
   2951c:	1000021e 	bne	r2,zero,29528 <alt_tse_phy_get_common_speed+0x158>
            common_100 = 0;
   29520:	e03ff945 	stb	zero,-27(fp)
            common_10 = 0;            
   29524:	e03ff985 	stb	zero,-26(fp)
        }
        
        /* get common capabilities for all PHYs and link partners */
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
   29528:	e0bffd17 	ldw	r2,-12(fp)
   2952c:	10c000c3 	ldbu	r3,3(r2)
   29530:	e0bffd17 	ldw	r2,-12(fp)
   29534:	10800303 	ldbu	r2,12(r2)
   29538:	1884703a 	and	r2,r3,r2
   2953c:	1007883a 	mov	r3,r2
   29540:	e0bff903 	ldbu	r2,-28(fp)
   29544:	1884703a 	and	r2,r3,r2
   29548:	e0bff905 	stb	r2,-28(fp)
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
   2954c:	e0bffd17 	ldw	r2,-12(fp)
   29550:	10c00183 	ldbu	r3,6(r2)
   29554:	e0bffd17 	ldw	r2,-12(fp)
   29558:	108003c3 	ldbu	r2,15(r2)
   2955c:	1884703a 	and	r2,r3,r2
   29560:	1007883a 	mov	r3,r2
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
   29564:	e0bffd17 	ldw	r2,-12(fp)
   29568:	110001c3 	ldbu	r4,7(r2)
   2956c:	e0bffd17 	ldw	r2,-12(fp)
   29570:	10800403 	ldbu	r2,16(r2)
        }
        
        /* get common capabilities for all PHYs and link partners */
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
   29574:	2084703a 	and	r2,r4,r2
   29578:	1884b03a 	or	r2,r3,r2
   2957c:	1007883a 	mov	r3,r2
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
                        (pphy->link_capability.cap_100_base_t4 & pphy->link_capability.lp_100_base_t4));
   29580:	e0bffd17 	ldw	r2,-12(fp)
   29584:	11000143 	ldbu	r4,5(r2)
   29588:	e0bffd17 	ldw	r2,-12(fp)
   2958c:	10800383 	ldbu	r2,14(r2)
        }
        
        /* get common capabilities for all PHYs and link partners */
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
   29590:	2084703a 	and	r2,r4,r2
   29594:	1884b03a 	or	r2,r3,r2
   29598:	1007883a 	mov	r3,r2
   2959c:	e0bff943 	ldbu	r2,-27(fp)
   295a0:	1884703a 	and	r2,r3,r2
   295a4:	e0bff945 	stb	r2,-27(fp)
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
                        (pphy->link_capability.cap_100_base_t4 & pphy->link_capability.lp_100_base_t4));
        common_10 &= ((pphy->link_capability.cap_10_base_t_full & pphy->link_capability.lp_10_base_tx_full) |
   295a8:	e0bffd17 	ldw	r2,-12(fp)
   295ac:	10c00283 	ldbu	r3,10(r2)
   295b0:	e0bffd17 	ldw	r2,-12(fp)
   295b4:	10800443 	ldbu	r2,17(r2)
   295b8:	1884703a 	and	r2,r3,r2
   295bc:	1007883a 	mov	r3,r2
                        (pphy->link_capability.cap_10_base_t_half & pphy->link_capability.lp_10_base_tx_half));
   295c0:	e0bffd17 	ldw	r2,-12(fp)
   295c4:	110002c3 	ldbu	r4,11(r2)
   295c8:	e0bffd17 	ldw	r2,-12(fp)
   295cc:	10800483 	ldbu	r2,18(r2)
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
                        (pphy->link_capability.cap_100_base_t4 & pphy->link_capability.lp_100_base_t4));
        common_10 &= ((pphy->link_capability.cap_10_base_t_full & pphy->link_capability.lp_10_base_tx_full) |
   295d0:	2084703a 	and	r2,r4,r2
   295d4:	1884b03a 	or	r2,r3,r2
   295d8:	1007883a 	mov	r3,r2
   295dc:	e0bff983 	ldbu	r2,-26(fp)
   295e0:	1884703a 	and	r2,r3,r2
   295e4:	e0bff985 	stb	r2,-26(fp)
   295e8:	00000306 	br	295f8 <alt_tse_phy_get_common_speed+0x228>
        pmac_info = pmac_group->pmac_info[i];
        pphy = pmac_info->pphy_info;
        
        /* if no PHY connected */
        if(!pphy) {
            continue;
   295ec:	0001883a 	nop
   295f0:	00000106 	br	295f8 <alt_tse_phy_get_common_speed+0x228>
        }
        
        /* get PHY capability */
        /* skip for PHY with Auto-Negotiation not completed */
        if(alt_tse_phy_get_cap(pphy) != TSE_PHY_AN_COMPLETE) {
            continue;
   295f4:	0001883a 	nop
        }
        tse_dprintf(6, "\n");
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
   295f8:	e0bff817 	ldw	r2,-32(fp)
   295fc:	10800044 	addi	r2,r2,1
   29600:	e0bff815 	stw	r2,-32(fp)
   29604:	e0bfff17 	ldw	r2,-4(fp)
   29608:	10800003 	ldbu	r2,0(r2)
   2960c:	10803fcc 	andi	r2,r2,255
   29610:	e0fff817 	ldw	r3,-32(fp)
   29614:	18bfa516 	blt	r3,r2,294ac <alt_tse_phy_get_common_speed+0xdc>
                        (pphy->link_capability.cap_10_base_t_half & pphy->link_capability.lp_10_base_tx_half));

    }
    
    /* get common speed based on capabilities */
    if(none_an_complete == 1) {
   29618:	e0bffb03 	ldbu	r2,-20(fp)
   2961c:	10800058 	cmpnei	r2,r2,1
   29620:	1000081e 	bne	r2,zero,29644 <alt_tse_phy_get_common_speed+0x274>
        common_speed = TSE_PHY_SPEED_NO_COMMON;
   29624:	00bfffc4 	movi	r2,-1
   29628:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(2, "ERROR   : MAC Group[%d] - None of the PHYs Auto-Negotiation completed!\n", mac_group_index);
   2962c:	e0bffe07 	ldb	r2,-8(fp)
   29630:	010000f4 	movhi	r4,3
   29634:	21031d04 	addi	r4,r4,3188
   29638:	100b883a 	mov	r5,r2
   2963c:	0024fd00 	call	24fd0 <no_printf>
   29640:	00002706 	br	296e0 <alt_tse_phy_get_common_speed+0x310>
    }
    else if(common_1000) {
   29644:	e0bff903 	ldbu	r2,-28(fp)
   29648:	10000926 	beq	r2,zero,29670 <alt_tse_phy_get_common_speed+0x2a0>
        common_speed = TSE_PHY_SPEED_1000;
   2964c:	00800084 	movi	r2,2
   29650:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 1000);
   29654:	e0bffe07 	ldb	r2,-8(fp)
   29658:	010000f4 	movhi	r4,3
   2965c:	21032f04 	addi	r4,r4,3260
   29660:	100b883a 	mov	r5,r2
   29664:	0180fa04 	movi	r6,1000
   29668:	0024fd00 	call	24fd0 <no_printf>
   2966c:	00001c06 	br	296e0 <alt_tse_phy_get_common_speed+0x310>
    }
    else if(common_100) {
   29670:	e0bff943 	ldbu	r2,-27(fp)
   29674:	10000926 	beq	r2,zero,2969c <alt_tse_phy_get_common_speed+0x2cc>
        common_speed = TSE_PHY_SPEED_100;
   29678:	00800044 	movi	r2,1
   2967c:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 100);
   29680:	e0bffe07 	ldb	r2,-8(fp)
   29684:	010000f4 	movhi	r4,3
   29688:	21032f04 	addi	r4,r4,3260
   2968c:	100b883a 	mov	r5,r2
   29690:	01801904 	movi	r6,100
   29694:	0024fd00 	call	24fd0 <no_printf>
   29698:	00001106 	br	296e0 <alt_tse_phy_get_common_speed+0x310>
    }
    else if(common_10) {
   2969c:	e0bff983 	ldbu	r2,-26(fp)
   296a0:	10000826 	beq	r2,zero,296c4 <alt_tse_phy_get_common_speed+0x2f4>
        common_speed = TSE_PHY_SPEED_10;
   296a4:	e03ffa15 	stw	zero,-24(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 10);
   296a8:	e0bffe07 	ldb	r2,-8(fp)
   296ac:	010000f4 	movhi	r4,3
   296b0:	21032f04 	addi	r4,r4,3260
   296b4:	100b883a 	mov	r5,r2
   296b8:	01800284 	movi	r6,10
   296bc:	0024fd00 	call	24fd0 <no_printf>
   296c0:	00000706 	br	296e0 <alt_tse_phy_get_common_speed+0x310>
    }
    else {
        common_speed = TSE_PHY_SPEED_NO_COMMON;
   296c4:	00bfffc4 	movi	r2,-1
   296c8:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(2, "ERROR   : MAC Group[%d] - No common speed at all!\n", mac_group_index);    }
   296cc:	e0bffe07 	ldb	r2,-8(fp)
   296d0:	010000f4 	movhi	r4,3
   296d4:	21033c04 	addi	r4,r4,3312
   296d8:	100b883a 	mov	r5,r2
   296dc:	0024fd00 	call	24fd0 <no_printf>

    return common_speed;
   296e0:	e0bffa17 	ldw	r2,-24(fp)
}
   296e4:	e037883a 	mov	sp,fp
   296e8:	dfc00117 	ldw	ra,4(sp)
   296ec:	df000017 	ldw	fp,0(sp)
   296f0:	dec00204 	addi	sp,sp,8
   296f4:	f800283a 	ret

000296f8 <alt_tse_phy_set_common_speed>:
 * @API Type:               Internal
 * @param pmac_group        Pointer to the TSE MAC Group structure which group all the MACs that should use the same speed
 *        common_speed      common speed supported by all PHYs
 * @return      common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if invalid common speed specified
 */
alt_32 alt_tse_phy_set_common_speed(alt_tse_mac_group *pmac_group, alt_32 common_speed) {
   296f8:	defff004 	addi	sp,sp,-64
   296fc:	dfc00f15 	stw	ra,60(sp)
   29700:	df000e15 	stw	fp,56(sp)
   29704:	dc400d15 	stw	r17,52(sp)
   29708:	dc000c15 	stw	r16,48(sp)
   2970c:	df000c04 	addi	fp,sp,48
   29710:	e13ffe15 	stw	r4,-8(fp)
   29714:	e17fff15 	stw	r5,-4(fp)
	alt_u8 speed;
	alt_u8 duplex;
    
	alt_u8 gb_capable;
    
    alt_tse_phy_info *pphy = 0;
   29718:	e03ff715 	stw	zero,-36(fp)
    alt_tse_mac_info *pmac_info = 0;
   2971c:	e03ff815 	stw	zero,-32(fp)
    alt_tse_system_info *psys = 0;
   29720:	e03ff915 	stw	zero,-28(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
   29724:	e03ffa05 	stb	zero,-24(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
   29728:	e13ffe17 	ldw	r4,-8(fp)
   2972c:	00261440 	call	26144 <alt_tse_get_mac_group_index>
   29730:	e0bffa45 	stb	r2,-23(fp)
         
    /* Record previous MDIO address, to be restored at the end of function */
    np_tse_mac *pmac_group_base = (np_tse_mac *)pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   29734:	e0bffe17 	ldw	r2,-8(fp)
   29738:	10800117 	ldw	r2,4(r2)
   2973c:	10800217 	ldw	r2,8(r2)
   29740:	10800017 	ldw	r2,0(r2)
   29744:	e0bffb15 	stw	r2,-20(fp)
    alt_32 mdioadd_prev = IORD(&pmac_group_base->MDIO_ADDR1, 0);
   29748:	e0bffb17 	ldw	r2,-20(fp)
   2974c:	10801004 	addi	r2,r2,64
   29750:	10800037 	ldwio	r2,0(r2)
   29754:	e0bffc15 	stw	r2,-16(fp)
    
    if((common_speed < TSE_PHY_SPEED_10) || (common_speed > TSE_PHY_SPEED_1000)) {
   29758:	e0bfff17 	ldw	r2,-4(fp)
   2975c:	10000316 	blt	r2,zero,2976c <alt_tse_phy_set_common_speed+0x74>
   29760:	e0bfff17 	ldw	r2,-4(fp)
   29764:	108000d0 	cmplti	r2,r2,3
   29768:	10000c1e 	bne	r2,zero,2979c <alt_tse_phy_set_common_speed+0xa4>
        tse_dprintf(2, "ERROR   : MAC Group[%d] - Invalid common speed specified! common speed = %d\n", mac_group_index, (int)common_speed);
   2976c:	e0bffa47 	ldb	r2,-23(fp)
   29770:	010000f4 	movhi	r4,3
   29774:	21034904 	addi	r4,r4,3364
   29778:	100b883a 	mov	r5,r2
   2977c:	e1bfff17 	ldw	r6,-4(fp)
   29780:	0024fd00 	call	24fd0 <no_printf>
		/* Restore previous MDIO address */
		IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
   29784:	e0bffb17 	ldw	r2,-20(fp)
   29788:	10801004 	addi	r2,r2,64
   2978c:	e0fffc17 	ldw	r3,-16(fp)
   29790:	10c00035 	stwio	r3,0(r2)
        return TSE_PHY_SPEED_NO_COMMON;
   29794:	00bfffc4 	movi	r2,-1
   29798:	0000fe06 	br	29b94 <alt_tse_phy_set_common_speed+0x49c>
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
   2979c:	e03ff515 	stw	zero,-44(fp)
   297a0:	0000dc06 	br	29b14 <alt_tse_phy_set_common_speed+0x41c>
        pmac_info = pmac_group->pmac_info[i];
   297a4:	e0fffe17 	ldw	r3,-8(fp)
   297a8:	e0bff517 	ldw	r2,-44(fp)
   297ac:	10800044 	addi	r2,r2,1
   297b0:	1085883a 	add	r2,r2,r2
   297b4:	1085883a 	add	r2,r2,r2
   297b8:	1885883a 	add	r2,r3,r2
   297bc:	10800017 	ldw	r2,0(r2)
   297c0:	e0bff815 	stw	r2,-32(fp)
        mac_info_index = alt_tse_get_mac_info_index(pmac_info);
   297c4:	e13ff817 	ldw	r4,-32(fp)
   297c8:	00261b80 	call	261b8 <alt_tse_get_mac_info_index>
   297cc:	e0bffa05 	stb	r2,-24(fp)

        pphy = pmac_info->pphy_info;
   297d0:	e0bff817 	ldw	r2,-32(fp)
   297d4:	10800117 	ldw	r2,4(r2)
   297d8:	e0bff715 	stw	r2,-36(fp)
        
        /* if no PHY connected */
        if(!pphy) {
   297dc:	e0bff717 	ldw	r2,-36(fp)
   297e0:	1000c826 	beq	r2,zero,29b04 <alt_tse_phy_set_common_speed+0x40c>
            continue;
        }
        
        psys = pmac_info->psys_info; 
   297e4:	e0bff817 	ldw	r2,-32(fp)
   297e8:	10800217 	ldw	r2,8(r2)
   297ec:	e0bff915 	stw	r2,-28(fp)
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
   297f0:	e0bff717 	ldw	r2,-36(fp)
   297f4:	10800003 	ldbu	r2,0(r2)
   297f8:	10803fcc 	andi	r2,r2,255
   297fc:	e13ff717 	ldw	r4,-36(fp)
   29800:	100b883a 	mov	r5,r2
   29804:	0026f380 	call	26f38 <alt_tse_phy_wr_mdio_addr>

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
   29808:	e0bff717 	ldw	r2,-36(fp)
   2980c:	108000c3 	ldbu	r2,3(r2)
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
   29810:	10803fcc 	andi	r2,r2,255
   29814:	10000c1e 	bne	r2,zero,29848 <alt_tse_phy_set_common_speed+0x150>
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
   29818:	e0bff717 	ldw	r2,-36(fp)
   2981c:	10800103 	ldbu	r2,4(r2)
   29820:	10803fcc 	andi	r2,r2,255
   29824:	1000081e 	bne	r2,zero,29848 <alt_tse_phy_set_common_speed+0x150>
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
   29828:	e0bff717 	ldw	r2,-36(fp)
   2982c:	10800043 	ldbu	r2,1(r2)
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
   29830:	10803fcc 	andi	r2,r2,255
   29834:	1000041e 	bne	r2,zero,29848 <alt_tse_phy_set_common_speed+0x150>
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
   29838:	e0bff717 	ldw	r2,-36(fp)
   2983c:	10800083 	ldbu	r2,2(r2)
   29840:	10803fcc 	andi	r2,r2,255
   29844:	10000226 	beq	r2,zero,29850 <alt_tse_phy_set_common_speed+0x158>
   29848:	00800044 	movi	r2,1
   2984c:	00000106 	br	29854 <alt_tse_phy_set_common_speed+0x15c>
   29850:	0005883a 	mov	r2,zero
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
   29854:	e0bffd05 	stb	r2,-12(fp)
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
        
        /* if PHY does not supports 1000 Mbps, and common speed is 1000 Mbps */
        if((!gb_capable) && (common_speed == TSE_PHY_SPEED_1000)) {
   29858:	e0bffd03 	ldbu	r2,-12(fp)
   2985c:	1000101e 	bne	r2,zero,298a0 <alt_tse_phy_set_common_speed+0x1a8>
   29860:	e0bfff17 	ldw	r2,-4(fp)
   29864:	10800098 	cmpnei	r2,r2,2
   29868:	10000d1e 	bne	r2,zero,298a0 <alt_tse_phy_set_common_speed+0x1a8>
            tse_dprintf(2, "ERROR   : PHY[%d.%d] - PHY does not support 1000 Mbps, please specify valid common speed\n", mac_group_index, mac_info_index);
   2986c:	e0fffa47 	ldb	r3,-23(fp)
   29870:	e0bffa07 	ldb	r2,-24(fp)
   29874:	010000f4 	movhi	r4,3
   29878:	21035d04 	addi	r4,r4,3444
   2987c:	180b883a 	mov	r5,r3
   29880:	100d883a 	mov	r6,r2
   29884:	0024fd00 	call	24fd0 <no_printf>
			/* Restore previous MDIO address */
			IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
   29888:	e0bffb17 	ldw	r2,-20(fp)
   2988c:	10801004 	addi	r2,r2,64
   29890:	e0fffc17 	ldw	r3,-16(fp)
   29894:	10c00035 	stwio	r3,0(r2)
            return TSE_PHY_SPEED_NO_COMMON;
   29898:	00bfffc4 	movi	r2,-1
   2989c:	0000bd06 	br	29b94 <alt_tse_phy_set_common_speed+0x49c>
        }
        
        /* if PHY is not Auto-Negotiation capable */
        if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
   298a0:	e13ff717 	ldw	r4,-36(fp)
   298a4:	01400044 	movi	r5,1
   298a8:	018000c4 	movi	r6,3
   298ac:	01c00044 	movi	r7,1
   298b0:	00270bc0 	call	270bc <alt_tse_phy_rd_mdio_reg>
   298b4:	1000141e 	bne	r2,zero,29908 <alt_tse_phy_set_common_speed+0x210>
            
            /* if PHY supports 1000 Mbps, write msb of speed */
            if(gb_capable) {
   298b8:	e0bffd03 	ldbu	r2,-12(fp)
   298bc:	10000926 	beq	r2,zero,298e4 <alt_tse_phy_set_common_speed+0x1ec>
                alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_SPEED_MSB, 1, common_speed >> 1);
   298c0:	e0bfff17 	ldw	r2,-4(fp)
   298c4:	1005d07a 	srai	r2,r2,1
   298c8:	10bfffcc 	andi	r2,r2,65535
   298cc:	d8800015 	stw	r2,0(sp)
   298d0:	e13ff717 	ldw	r4,-36(fp)
   298d4:	000b883a 	mov	r5,zero
   298d8:	01800184 	movi	r6,6
   298dc:	01c00044 	movi	r7,1
   298e0:	0026f900 	call	26f90 <alt_tse_phy_wr_mdio_reg>
            }
            /* write lsb of speed */
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_SPEED_LSB, 1, common_speed);
   298e4:	e0bfff17 	ldw	r2,-4(fp)
   298e8:	10bfffcc 	andi	r2,r2,65535
   298ec:	d8800015 	stw	r2,0(sp)
   298f0:	e13ff717 	ldw	r4,-36(fp)
   298f4:	000b883a 	mov	r5,zero
   298f8:	01800344 	movi	r6,13
   298fc:	01c00044 	movi	r7,1
   29900:	0026f900 	call	26f90 <alt_tse_phy_wr_mdio_reg>
            
            /* continue to next PHY */
            continue;
   29904:	00008006 	br	29b08 <alt_tse_phy_set_common_speed+0x410>
        }
        
        /* set Auto-Negotiation advertisement based on common speed */
        if(common_speed == TSE_PHY_SPEED_1000) {
   29908:	e0bfff17 	ldw	r2,-4(fp)
   2990c:	10800098 	cmpnei	r2,r2,2
   29910:	10000a1e 	bne	r2,zero,2993c <alt_tse_phy_set_common_speed+0x244>
            alt_tse_phy_set_adv_1000(pphy, 1);
   29914:	e13ff717 	ldw	r4,-36(fp)
   29918:	01400044 	movi	r5,1
   2991c:	0028e240 	call	28e24 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
   29920:	e13ff717 	ldw	r4,-36(fp)
   29924:	01400044 	movi	r5,1
   29928:	0028fe00 	call	28fe0 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
   2992c:	e13ff717 	ldw	r4,-36(fp)
   29930:	01400044 	movi	r5,1
   29934:	00292280 	call	29228 <alt_tse_phy_set_adv_10>
   29938:	00002206 	br	299c4 <alt_tse_phy_set_common_speed+0x2cc>
        }
        else if(common_speed == TSE_PHY_SPEED_100) {
   2993c:	e0bfff17 	ldw	r2,-4(fp)
   29940:	10800058 	cmpnei	r2,r2,1
   29944:	10000a1e 	bne	r2,zero,29970 <alt_tse_phy_set_common_speed+0x278>
            alt_tse_phy_set_adv_1000(pphy, 0);
   29948:	e13ff717 	ldw	r4,-36(fp)
   2994c:	000b883a 	mov	r5,zero
   29950:	0028e240 	call	28e24 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
   29954:	e13ff717 	ldw	r4,-36(fp)
   29958:	01400044 	movi	r5,1
   2995c:	0028fe00 	call	28fe0 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
   29960:	e13ff717 	ldw	r4,-36(fp)
   29964:	01400044 	movi	r5,1
   29968:	00292280 	call	29228 <alt_tse_phy_set_adv_10>
   2996c:	00001506 	br	299c4 <alt_tse_phy_set_common_speed+0x2cc>
        }    
        else if(common_speed == TSE_PHY_SPEED_10) {
   29970:	e0bfff17 	ldw	r2,-4(fp)
   29974:	10000a1e 	bne	r2,zero,299a0 <alt_tse_phy_set_common_speed+0x2a8>
            alt_tse_phy_set_adv_1000(pphy, 0);
   29978:	e13ff717 	ldw	r4,-36(fp)
   2997c:	000b883a 	mov	r5,zero
   29980:	0028e240 	call	28e24 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 0);
   29984:	e13ff717 	ldw	r4,-36(fp)
   29988:	000b883a 	mov	r5,zero
   2998c:	0028fe00 	call	28fe0 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
   29990:	e13ff717 	ldw	r4,-36(fp)
   29994:	01400044 	movi	r5,1
   29998:	00292280 	call	29228 <alt_tse_phy_set_adv_10>
   2999c:	00000906 	br	299c4 <alt_tse_phy_set_common_speed+0x2cc>
        }
        else {
            alt_tse_phy_set_adv_1000(pphy, 0);
   299a0:	e13ff717 	ldw	r4,-36(fp)
   299a4:	000b883a 	mov	r5,zero
   299a8:	0028e240 	call	28e24 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 0);
   299ac:	e13ff717 	ldw	r4,-36(fp)
   299b0:	000b883a 	mov	r5,zero
   299b4:	0028fe00 	call	28fe0 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 0);
   299b8:	e13ff717 	ldw	r4,-36(fp)
   299bc:	000b883a 	mov	r5,zero
   299c0:	00292280 	call	29228 <alt_tse_phy_set_adv_10>
        }
        
        /* if PHY Auto-Negotiation is completed */
        if(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 1) {
   299c4:	e13ff717 	ldw	r4,-36(fp)
   299c8:	01400044 	movi	r5,1
   299cc:	01800144 	movi	r6,5
   299d0:	01c00044 	movi	r7,1
   299d4:	00270bc0 	call	270bc <alt_tse_phy_rd_mdio_reg>
   299d8:	10800058 	cmpnei	r2,r2,1
   299dc:	10003b1e 	bne	r2,zero,29acc <alt_tse_phy_set_common_speed+0x3d4>
            
            /* read both msb and lsb of speed bits if PHY support 1000 Mbps */
            if(gb_capable) {
   299e0:	e0bffd03 	ldbu	r2,-12(fp)
   299e4:	10000f26 	beq	r2,zero,29a24 <alt_tse_phy_set_common_speed+0x32c>
        
                /* get speed information after Auto-Negotiation */
                speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 2);
   299e8:	e0bff717 	ldw	r2,-36(fp)
   299ec:	10800517 	ldw	r2,20(r2)
   299f0:	10801583 	ldbu	r2,86(r2)
   299f4:	10c03fcc 	andi	r3,r2,255
   299f8:	e0bff717 	ldw	r2,-36(fp)
   299fc:	10800517 	ldw	r2,20(r2)
   29a00:	108015c3 	ldbu	r2,87(r2)
   29a04:	10803fcc 	andi	r2,r2,255
   29a08:	e13ff717 	ldw	r4,-36(fp)
   29a0c:	180b883a 	mov	r5,r3
   29a10:	100d883a 	mov	r6,r2
   29a14:	01c00084 	movi	r7,2
   29a18:	00270bc0 	call	270bc <alt_tse_phy_rd_mdio_reg>
   29a1c:	e0bff605 	stb	r2,-40(fp)
   29a20:	00000e06 	br	29a5c <alt_tse_phy_set_common_speed+0x364>
            }
            
            /* read lsb of speed only if PHY support only 10/100 Mbps */
            else {
                /* get speed and link information after Auto-Negotiation */
                speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 1);
   29a24:	e0bff717 	ldw	r2,-36(fp)
   29a28:	10800517 	ldw	r2,20(r2)
   29a2c:	10801583 	ldbu	r2,86(r2)
   29a30:	10c03fcc 	andi	r3,r2,255
   29a34:	e0bff717 	ldw	r2,-36(fp)
   29a38:	10800517 	ldw	r2,20(r2)
   29a3c:	108015c3 	ldbu	r2,87(r2)
   29a40:	10803fcc 	andi	r2,r2,255
   29a44:	e13ff717 	ldw	r4,-36(fp)
   29a48:	180b883a 	mov	r5,r3
   29a4c:	100d883a 	mov	r6,r2
   29a50:	01c00044 	movi	r7,1
   29a54:	00270bc0 	call	270bc <alt_tse_phy_rd_mdio_reg>
   29a58:	e0bff605 	stb	r2,-40(fp)
            }
            
            /* if current speed != common speed, then restart Auto-Negotiation */
            if(speed != common_speed) {
   29a5c:	e0fff603 	ldbu	r3,-40(fp)
   29a60:	e0bfff17 	ldw	r2,-4(fp)
   29a64:	18800426 	beq	r3,r2,29a78 <alt_tse_phy_set_common_speed+0x380>
                alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
   29a68:	e13ff717 	ldw	r4,-36(fp)
   29a6c:	01400134 	movhi	r5,4
   29a70:	29742404 	addi	r5,r5,-12144
   29a74:	00285680 	call	28568 <alt_tse_phy_restart_an>
            }
            
            /* get speed information after Auto-Negotiation */
            duplex = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->duplex_bit_location, 1);
   29a78:	e0bff717 	ldw	r2,-36(fp)
   29a7c:	10800517 	ldw	r2,20(r2)
   29a80:	10801583 	ldbu	r2,86(r2)
   29a84:	10c03fcc 	andi	r3,r2,255
   29a88:	e0bff717 	ldw	r2,-36(fp)
   29a8c:	10800517 	ldw	r2,20(r2)
   29a90:	10801603 	ldbu	r2,88(r2)
   29a94:	10803fcc 	andi	r2,r2,255
   29a98:	e13ff717 	ldw	r4,-36(fp)
   29a9c:	180b883a 	mov	r5,r3
   29aa0:	100d883a 	mov	r6,r2
   29aa4:	01c00044 	movi	r7,1
   29aa8:	00270bc0 	call	270bc <alt_tse_phy_rd_mdio_reg>
   29aac:	e0bffd45 	stb	r2,-11(fp)
            
            /* Set MAC duplex register */
            alt_tse_mac_set_duplex((np_tse_mac *)psys->tse_mac_base, duplex);
   29ab0:	e0bff917 	ldw	r2,-28(fp)
   29ab4:	10800017 	ldw	r2,0(r2)
   29ab8:	1007883a 	mov	r3,r2
   29abc:	e0bffd43 	ldbu	r2,-11(fp)
   29ac0:	1809883a 	mov	r4,r3
   29ac4:	100b883a 	mov	r5,r2
   29ac8:	00263f00 	call	263f0 <alt_tse_mac_set_duplex>
            
        }
        tse_dprintf(5, "INFO    : PHY[%d.%d] - PHY STATUS = 0x%04x\n\n", mac_group_index, mac_info_index, (int) alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, 0, 16));        
   29acc:	e47ffa47 	ldb	r17,-23(fp)
   29ad0:	e43ffa07 	ldb	r16,-24(fp)
   29ad4:	e13ff717 	ldw	r4,-36(fp)
   29ad8:	01400044 	movi	r5,1
   29adc:	000d883a 	mov	r6,zero
   29ae0:	01c00404 	movi	r7,16
   29ae4:	00270bc0 	call	270bc <alt_tse_phy_rd_mdio_reg>
   29ae8:	010000f4 	movhi	r4,3
   29aec:	21037404 	addi	r4,r4,3536
   29af0:	880b883a 	mov	r5,r17
   29af4:	800d883a 	mov	r6,r16
   29af8:	100f883a 	mov	r7,r2
   29afc:	0024fd00 	call	24fd0 <no_printf>
   29b00:	00000106 	br	29b08 <alt_tse_phy_set_common_speed+0x410>

        pphy = pmac_info->pphy_info;
        
        /* if no PHY connected */
        if(!pphy) {
            continue;
   29b04:	0001883a 	nop
		IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
        return TSE_PHY_SPEED_NO_COMMON;
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
   29b08:	e0bff517 	ldw	r2,-44(fp)
   29b0c:	10800044 	addi	r2,r2,1
   29b10:	e0bff515 	stw	r2,-44(fp)
   29b14:	e0bffe17 	ldw	r2,-8(fp)
   29b18:	10800003 	ldbu	r2,0(r2)
   29b1c:	10803fcc 	andi	r2,r2,255
   29b20:	e0fff517 	ldw	r3,-44(fp)
   29b24:	18bf1f16 	blt	r3,r2,297a4 <alt_tse_phy_set_common_speed+0xac>
            alt_tse_mac_set_duplex((np_tse_mac *)psys->tse_mac_base, duplex);
            
        }
        tse_dprintf(5, "INFO    : PHY[%d.%d] - PHY STATUS = 0x%04x\n\n", mac_group_index, mac_info_index, (int) alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, 0, 16));        
    }
    tse_dprintf(5, "INFO    : MAC Group[%d] - All PHYs set to common speed : %d Mbps\n", mac_group_index, (common_speed == TSE_PHY_SPEED_1000) ? 1000 : ((common_speed == TSE_PHY_SPEED_100) ? 100 : 10));
   29b28:	e0fffa47 	ldb	r3,-23(fp)
   29b2c:	e0bfff17 	ldw	r2,-4(fp)
   29b30:	108000a0 	cmpeqi	r2,r2,2
   29b34:	1000071e 	bne	r2,zero,29b54 <alt_tse_phy_set_common_speed+0x45c>
   29b38:	e0bfff17 	ldw	r2,-4(fp)
   29b3c:	10800058 	cmpnei	r2,r2,1
   29b40:	1000021e 	bne	r2,zero,29b4c <alt_tse_phy_set_common_speed+0x454>
   29b44:	00801904 	movi	r2,100
   29b48:	00000106 	br	29b50 <alt_tse_phy_set_common_speed+0x458>
   29b4c:	00800284 	movi	r2,10
   29b50:	00000106 	br	29b58 <alt_tse_phy_set_common_speed+0x460>
   29b54:	0080fa04 	movi	r2,1000
   29b58:	010000f4 	movhi	r4,3
   29b5c:	21038004 	addi	r4,r4,3584
   29b60:	180b883a 	mov	r5,r3
   29b64:	100d883a 	mov	r6,r2
   29b68:	0024fd00 	call	24fd0 <no_printf>

    /* Set MAC speed register */
    alt_tse_mac_set_speed(pmac_group_base, common_speed);
   29b6c:	e0bfff17 	ldw	r2,-4(fp)
   29b70:	10803fcc 	andi	r2,r2,255
   29b74:	e13ffb17 	ldw	r4,-20(fp)
   29b78:	100b883a 	mov	r5,r2
   29b7c:	00263100 	call	26310 <alt_tse_mac_set_speed>
    
    /* Restore previous MDIO address */
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
   29b80:	e0bffb17 	ldw	r2,-20(fp)
   29b84:	10801004 	addi	r2,r2,64
   29b88:	e0fffc17 	ldw	r3,-16(fp)
   29b8c:	10c00035 	stwio	r3,0(r2)
        
    return common_speed;
   29b90:	e0bfff17 	ldw	r2,-4(fp)
}
   29b94:	e037883a 	mov	sp,fp
   29b98:	dfc00317 	ldw	ra,12(sp)
   29b9c:	df000217 	ldw	fp,8(sp)
   29ba0:	dc400117 	ldw	r17,4(sp)
   29ba4:	dc000017 	ldw	r16,0(sp)
   29ba8:	dec00404 	addi	sp,sp,16
   29bac:	f800283a 	ret

00029bb0 <marvell_phy_cfg>:

/* @Function Description: Additional configuration for Marvell PHY
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address of MAC group
 */
alt_32 marvell_phy_cfg(np_tse_mac *pmac) {
   29bb0:	defffc04 	addi	sp,sp,-16
   29bb4:	dfc00315 	stw	ra,12(sp)
   29bb8:	df000215 	stw	fp,8(sp)
   29bbc:	df000204 	addi	fp,sp,8
   29bc0:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat;
    
    /* If there is no link yet, we enable auto crossover and reset the PHY */
    if((IORD(&pmac->mdio1.STATUS, 0) & PCS_ST_an_done) == 0) {
   29bc4:	e0bfff17 	ldw	r2,-4(fp)
   29bc8:	1080a104 	addi	r2,r2,644
   29bcc:	10800037 	ldwio	r2,0(r2)
   29bd0:	1080080c 	andi	r2,r2,32
   29bd4:	1000161e 	bne	r2,zero,29c30 <marvell_phy_cfg+0x80>
        tse_dprintf(5, "MARVELL : Enabling auto crossover\n");
   29bd8:	010000f4 	movhi	r4,3
   29bdc:	21039104 	addi	r4,r4,3652
   29be0:	0024fd00 	call	24fd0 <no_printf>
        IOWR(&pmac->mdio1.CONTROL, 16, 0x0078);
   29be4:	e0bfff17 	ldw	r2,-4(fp)
   29be8:	1080a004 	addi	r2,r2,640
   29bec:	10801004 	addi	r2,r2,64
   29bf0:	00c01e04 	movi	r3,120
   29bf4:	10c00035 	stwio	r3,0(r2)
        tse_dprintf(5, "MARVELL : PHY reset\n");
   29bf8:	010000f4 	movhi	r4,3
   29bfc:	21039a04 	addi	r4,r4,3688
   29c00:	0024fd00 	call	24fd0 <no_printf>
        dat = IORD(&pmac->mdio1.CONTROL, 0); 
   29c04:	e0bfff17 	ldw	r2,-4(fp)
   29c08:	1080a004 	addi	r2,r2,640
   29c0c:	10800037 	ldwio	r2,0(r2)
   29c10:	e0bffe0d 	sth	r2,-8(fp)
        IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);        
   29c14:	e0bfff17 	ldw	r2,-4(fp)
   29c18:	1080a004 	addi	r2,r2,640
   29c1c:	e13ffe0b 	ldhu	r4,-8(fp)
   29c20:	00e00004 	movi	r3,-32768
   29c24:	20c6b03a 	or	r3,r4,r3
   29c28:	18ffffcc 	andi	r3,r3,65535
   29c2c:	10c00035 	stwio	r3,0(r2)
    }
    
    return 0;
   29c30:	0005883a 	mov	r2,zero
}
   29c34:	e037883a 	mov	sp,fp
   29c38:	dfc00117 	ldw	ra,4(sp)
   29c3c:	df000017 	ldw	fp,0(sp)
   29c40:	dec00204 	addi	sp,sp,8
   29c44:	f800283a 	ret

00029c48 <marvell_cfg_gmii>:

/* @Function Description: Change operating mode of Marvell PHY to GMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_gmii(np_tse_mac *pmac) {
   29c48:	defffc04 	addi	sp,sp,-16
   29c4c:	dfc00315 	stw	ra,12(sp)
   29c50:	df000215 	stw	fp,8(sp)
   29c54:	df000204 	addi	fp,sp,8
   29c58:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
   29c5c:	e0bfff17 	ldw	r2,-4(fp)
   29c60:	1080bb04 	addi	r2,r2,748
   29c64:	10800037 	ldwio	r2,0(r2)
   29c68:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
   29c6c:	e0fffe0b 	ldhu	r3,-8(fp)
   29c70:	00bffc04 	movi	r2,-16
   29c74:	1884703a 	and	r2,r3,r2
   29c78:	e0bffe0d 	sth	r2,-8(fp)

    tse_dprintf(5, "MARVELL : Mode changed to GMII to copper mode\n");
   29c7c:	010000f4 	movhi	r4,3
   29c80:	2103a004 	addi	r4,r4,3712
   29c84:	0024fd00 	call	24fd0 <no_printf>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0xf);
   29c88:	e0bfff17 	ldw	r2,-4(fp)
   29c8c:	1080bb04 	addi	r2,r2,748
   29c90:	e0fffe0b 	ldhu	r3,-8(fp)
   29c94:	18c003d4 	ori	r3,r3,15
   29c98:	18ffffcc 	andi	r3,r3,65535
   29c9c:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Disable RGMII Timing Control\n");
   29ca0:	010000f4 	movhi	r4,3
   29ca4:	2103ac04 	addi	r4,r4,3760
   29ca8:	0024fd00 	call	24fd0 <no_printf>
    dat = IORD(&pmac->mdio1.reg14, 0); 
   29cac:	e0bfff17 	ldw	r2,-4(fp)
   29cb0:	1080b404 	addi	r2,r2,720
   29cb4:	10800037 	ldwio	r2,0(r2)
   29cb8:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
   29cbc:	e0fffe0b 	ldhu	r3,-8(fp)
   29cc0:	00bfdf44 	movi	r2,-131
   29cc4:	1884703a 	and	r2,r3,r2
   29cc8:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);
   29ccc:	e0bfff17 	ldw	r2,-4(fp)
   29cd0:	1080b404 	addi	r2,r2,720
   29cd4:	e0fffe0b 	ldhu	r3,-8(fp)
   29cd8:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : PHY reset\n");
   29cdc:	010000f4 	movhi	r4,3
   29ce0:	21039a04 	addi	r4,r4,3688
   29ce4:	0024fd00 	call	24fd0 <no_printf>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
   29ce8:	e0bfff17 	ldw	r2,-4(fp)
   29cec:	1080a004 	addi	r2,r2,640
   29cf0:	10800037 	ldwio	r2,0(r2)
   29cf4:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);
   29cf8:	e0bfff17 	ldw	r2,-4(fp)
   29cfc:	1080a004 	addi	r2,r2,640
   29d00:	e13ffe0b 	ldhu	r4,-8(fp)
   29d04:	00e00004 	movi	r3,-32768
   29d08:	20c6b03a 	or	r3,r4,r3
   29d0c:	18ffffcc 	andi	r3,r3,65535
   29d10:	10c00035 	stwio	r3,0(r2)
    
    return 1;
   29d14:	00800044 	movi	r2,1
}
   29d18:	e037883a 	mov	sp,fp
   29d1c:	dfc00117 	ldw	ra,4(sp)
   29d20:	df000017 	ldw	fp,0(sp)
   29d24:	dec00204 	addi	sp,sp,8
   29d28:	f800283a 	ret

00029d2c <marvell_cfg_sgmii>:

/* @Function Description: Change operating mode of Marvell PHY to SGMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_sgmii(np_tse_mac *pmac) {
   29d2c:	defffc04 	addi	sp,sp,-16
   29d30:	dfc00315 	stw	ra,12(sp)
   29d34:	df000215 	stw	fp,8(sp)
   29d38:	df000204 	addi	fp,sp,8
   29d3c:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
   29d40:	e0bfff17 	ldw	r2,-4(fp)
   29d44:	1080bb04 	addi	r2,r2,748
   29d48:	10800037 	ldwio	r2,0(r2)
   29d4c:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
   29d50:	e0fffe0b 	ldhu	r3,-8(fp)
   29d54:	00bffc04 	movi	r2,-16
   29d58:	1884703a 	and	r2,r3,r2
   29d5c:	e0bffe0d 	sth	r2,-8(fp)

    tse_dprintf(5, "MARVELL : Mode changed to SGMII without clock with SGMII Auto-Neg to copper mode\n");
   29d60:	010000f4 	movhi	r4,3
   29d64:	2103b604 	addi	r4,r4,3800
   29d68:	0024fd00 	call	24fd0 <no_printf>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0x4);
   29d6c:	e0bfff17 	ldw	r2,-4(fp)
   29d70:	1080bb04 	addi	r2,r2,748
   29d74:	e0fffe0b 	ldhu	r3,-8(fp)
   29d78:	18c00114 	ori	r3,r3,4
   29d7c:	18ffffcc 	andi	r3,r3,65535
   29d80:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Disable RGMII Timing Control\n");
   29d84:	010000f4 	movhi	r4,3
   29d88:	2103ac04 	addi	r4,r4,3760
   29d8c:	0024fd00 	call	24fd0 <no_printf>
    dat = IORD(&pmac->mdio1.reg14, 0); 
   29d90:	e0bfff17 	ldw	r2,-4(fp)
   29d94:	1080b404 	addi	r2,r2,720
   29d98:	10800037 	ldwio	r2,0(r2)
   29d9c:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
   29da0:	e0fffe0b 	ldhu	r3,-8(fp)
   29da4:	00bfdf44 	movi	r2,-131
   29da8:	1884703a 	and	r2,r3,r2
   29dac:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);
   29db0:	e0bfff17 	ldw	r2,-4(fp)
   29db4:	1080b404 	addi	r2,r2,720
   29db8:	e0fffe0b 	ldhu	r3,-8(fp)
   29dbc:	10c00035 	stwio	r3,0(r2)

    tse_dprintf(5, "MARVELL : PHY reset\n");
   29dc0:	010000f4 	movhi	r4,3
   29dc4:	21039a04 	addi	r4,r4,3688
   29dc8:	0024fd00 	call	24fd0 <no_printf>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
   29dcc:	e0bfff17 	ldw	r2,-4(fp)
   29dd0:	1080a004 	addi	r2,r2,640
   29dd4:	10800037 	ldwio	r2,0(r2)
   29dd8:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);
   29ddc:	e0bfff17 	ldw	r2,-4(fp)
   29de0:	1080a004 	addi	r2,r2,640
   29de4:	e13ffe0b 	ldhu	r4,-8(fp)
   29de8:	00e00004 	movi	r3,-32768
   29dec:	20c6b03a 	or	r3,r4,r3
   29df0:	18ffffcc 	andi	r3,r3,65535
   29df4:	10c00035 	stwio	r3,0(r2)
    
    return 1;
   29df8:	00800044 	movi	r2,1
}
   29dfc:	e037883a 	mov	sp,fp
   29e00:	dfc00117 	ldw	ra,4(sp)
   29e04:	df000017 	ldw	fp,0(sp)
   29e08:	dec00204 	addi	sp,sp,8
   29e0c:	f800283a 	ret

00029e10 <marvell_cfg_rgmii>:

/* @Function Description: Change operating mode of Marvell PHY to RGMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_rgmii(np_tse_mac *pmac) {
   29e10:	defffc04 	addi	sp,sp,-16
   29e14:	dfc00315 	stw	ra,12(sp)
   29e18:	df000215 	stw	fp,8(sp)
   29e1c:	df000204 	addi	fp,sp,8
   29e20:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
   29e24:	e0bfff17 	ldw	r2,-4(fp)
   29e28:	1080bb04 	addi	r2,r2,748
   29e2c:	10800037 	ldwio	r2,0(r2)
   29e30:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
   29e34:	e0fffe0b 	ldhu	r3,-8(fp)
   29e38:	00bffc04 	movi	r2,-16
   29e3c:	1884703a 	and	r2,r3,r2
   29e40:	e0bffe0d 	sth	r2,-8(fp)
    
    tse_dprintf(5, "MARVELL : Mode changed to RGMII/Modified MII to Copper mode\n");
   29e44:	010000f4 	movhi	r4,3
   29e48:	2103cb04 	addi	r4,r4,3884
   29e4c:	0024fd00 	call	24fd0 <no_printf>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0xb);
   29e50:	e0bfff17 	ldw	r2,-4(fp)
   29e54:	1080bb04 	addi	r2,r2,748
   29e58:	e0fffe0b 	ldhu	r3,-8(fp)
   29e5c:	18c002d4 	ori	r3,r3,11
   29e60:	18ffffcc 	andi	r3,r3,65535
   29e64:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Enable RGMII Timing Control\n");
   29e68:	010000f4 	movhi	r4,3
   29e6c:	2103db04 	addi	r4,r4,3948
   29e70:	0024fd00 	call	24fd0 <no_printf>
    dat = IORD(&pmac->mdio1.reg14, 0);
   29e74:	e0bfff17 	ldw	r2,-4(fp)
   29e78:	1080b404 	addi	r2,r2,720
   29e7c:	10800037 	ldwio	r2,0(r2)
   29e80:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
   29e84:	e0fffe0b 	ldhu	r3,-8(fp)
   29e88:	00bfdf44 	movi	r2,-131
   29e8c:	1884703a 	and	r2,r3,r2
   29e90:	e0bffe0d 	sth	r2,-8(fp)
    dat |= 0x82;
   29e94:	e0bffe0b 	ldhu	r2,-8(fp)
   29e98:	10802094 	ori	r2,r2,130
   29e9c:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);    
   29ea0:	e0bfff17 	ldw	r2,-4(fp)
   29ea4:	1080b404 	addi	r2,r2,720
   29ea8:	e0fffe0b 	ldhu	r3,-8(fp)
   29eac:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : PHY reset\n");
   29eb0:	010000f4 	movhi	r4,3
   29eb4:	21039a04 	addi	r4,r4,3688
   29eb8:	0024fd00 	call	24fd0 <no_printf>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
   29ebc:	e0bfff17 	ldw	r2,-4(fp)
   29ec0:	1080a004 	addi	r2,r2,640
   29ec4:	10800037 	ldwio	r2,0(r2)
   29ec8:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);
   29ecc:	e0bfff17 	ldw	r2,-4(fp)
   29ed0:	1080a004 	addi	r2,r2,640
   29ed4:	e13ffe0b 	ldhu	r4,-8(fp)
   29ed8:	00e00004 	movi	r3,-32768
   29edc:	20c6b03a 	or	r3,r4,r3
   29ee0:	18ffffcc 	andi	r3,r3,65535
   29ee4:	10c00035 	stwio	r3,0(r2)
    
    return 1;
   29ee8:	00800044 	movi	r2,1
    
}
   29eec:	e037883a 	mov	sp,fp
   29ef0:	dfc00117 	ldw	ra,4(sp)
   29ef4:	df000017 	ldw	fp,0(sp)
   29ef8:	dec00204 	addi	sp,sp,8
   29efc:	f800283a 	ret

00029f00 <DP83848C_link_status_read>:

/* @Function Description: Read link status from PHY specific status register of DP83848C
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_u32 DP83848C_link_status_read(np_tse_mac *pmac) {
   29f00:	defffc04 	addi	sp,sp,-16
   29f04:	df000315 	stw	fp,12(sp)
   29f08:	df000304 	addi	fp,sp,12
   29f0c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 link_status = 0;
   29f10:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 reg_status = IORD(&pmac->mdio1.reg10, 0);
   29f14:	e0bfff17 	ldw	r2,-4(fp)
   29f18:	1080b004 	addi	r2,r2,704
   29f1c:	10800037 	ldwio	r2,0(r2)
   29f20:	e0bffe15 	stw	r2,-8(fp)
	
	/* If speed == 10 Mbps */
	if(reg_status & 0x2) {
   29f24:	e0bffe17 	ldw	r2,-8(fp)
   29f28:	1080008c 	andi	r2,r2,2
   29f2c:	10000426 	beq	r2,zero,29f40 <DP83848C_link_status_read+0x40>
		link_status |= 0x8;
   29f30:	e0bffd17 	ldw	r2,-12(fp)
   29f34:	10800214 	ori	r2,r2,8
   29f38:	e0bffd15 	stw	r2,-12(fp)
   29f3c:	00000306 	br	29f4c <DP83848C_link_status_read+0x4c>
	}
	/* Else speed = 100 Mbps */
	else {
		link_status |= 0x4;
   29f40:	e0bffd17 	ldw	r2,-12(fp)
   29f44:	10800114 	ori	r2,r2,4
   29f48:	e0bffd15 	stw	r2,-12(fp)
	}
	
	/* If duplex == Full */
	if(reg_status & 0x4) {
   29f4c:	e0bffe17 	ldw	r2,-8(fp)
   29f50:	1080010c 	andi	r2,r2,4
   29f54:	10000326 	beq	r2,zero,29f64 <DP83848C_link_status_read+0x64>
		link_status |= 0x1;
   29f58:	e0bffd17 	ldw	r2,-12(fp)
   29f5c:	10800054 	ori	r2,r2,1
   29f60:	e0bffd15 	stw	r2,-12(fp)
	}
	
	return link_status;
   29f64:	e0bffd17 	ldw	r2,-12(fp)
}
   29f68:	e037883a 	mov	sp,fp
   29f6c:	df000017 	ldw	fp,0(sp)
   29f70:	dec00104 	addi	sp,sp,4
   29f74:	f800283a 	ret

00029f78 <altera_avalon_uart_read_fd>:
 *
 */

int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
   29f78:	defffa04 	addi	sp,sp,-24
   29f7c:	dfc00515 	stw	ra,20(sp)
   29f80:	df000415 	stw	fp,16(sp)
   29f84:	df000404 	addi	fp,sp,16
   29f88:	e13ffd15 	stw	r4,-12(fp)
   29f8c:	e17ffe15 	stw	r5,-8(fp)
   29f90:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
   29f94:	e0bffd17 	ldw	r2,-12(fp)
   29f98:	10800017 	ldw	r2,0(r2)
   29f9c:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_read(&dev->state, buffer, space,
   29fa0:	e0bffc17 	ldw	r2,-16(fp)
   29fa4:	10c00a04 	addi	r3,r2,40
      fd->fd_flags);
   29fa8:	e0bffd17 	ldw	r2,-12(fp)
int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 

    return altera_avalon_uart_read(&dev->state, buffer, space,
   29fac:	10800217 	ldw	r2,8(r2)
   29fb0:	1809883a 	mov	r4,r3
   29fb4:	e17ffe17 	ldw	r5,-8(fp)
   29fb8:	e1bfff17 	ldw	r6,-4(fp)
   29fbc:	100f883a 	mov	r7,r2
   29fc0:	002a4800 	call	2a480 <altera_avalon_uart_read>
      fd->fd_flags);
}
   29fc4:	e037883a 	mov	sp,fp
   29fc8:	dfc00117 	ldw	ra,4(sp)
   29fcc:	df000017 	ldw	fp,0(sp)
   29fd0:	dec00204 	addi	sp,sp,8
   29fd4:	f800283a 	ret

00029fd8 <altera_avalon_uart_write_fd>:

int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
   29fd8:	defffa04 	addi	sp,sp,-24
   29fdc:	dfc00515 	stw	ra,20(sp)
   29fe0:	df000415 	stw	fp,16(sp)
   29fe4:	df000404 	addi	fp,sp,16
   29fe8:	e13ffd15 	stw	r4,-12(fp)
   29fec:	e17ffe15 	stw	r5,-8(fp)
   29ff0:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
   29ff4:	e0bffd17 	ldw	r2,-12(fp)
   29ff8:	10800017 	ldw	r2,0(r2)
   29ffc:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_write(&dev->state, buffer, space,
   2a000:	e0bffc17 	ldw	r2,-16(fp)
   2a004:	10c00a04 	addi	r3,r2,40
      fd->fd_flags);
   2a008:	e0bffd17 	ldw	r2,-12(fp)
int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 

    return altera_avalon_uart_write(&dev->state, buffer, space,
   2a00c:	10800217 	ldw	r2,8(r2)
   2a010:	1809883a 	mov	r4,r3
   2a014:	e17ffe17 	ldw	r5,-8(fp)
   2a018:	e1bfff17 	ldw	r6,-4(fp)
   2a01c:	100f883a 	mov	r7,r2
   2a020:	002a72c0 	call	2a72c <altera_avalon_uart_write>
      fd->fd_flags);
}
   2a024:	e037883a 	mov	sp,fp
   2a028:	dfc00117 	ldw	ra,4(sp)
   2a02c:	df000017 	ldw	fp,0(sp)
   2a030:	dec00204 	addi	sp,sp,8
   2a034:	f800283a 	ret

0002a038 <altera_avalon_uart_close_fd>:

#endif /* ALTERA_AVALON_UART_USE_IOCTL */

int 
altera_avalon_uart_close_fd(alt_fd* fd)
{
   2a038:	defffc04 	addi	sp,sp,-16
   2a03c:	dfc00315 	stw	ra,12(sp)
   2a040:	df000215 	stw	fp,8(sp)
   2a044:	df000204 	addi	fp,sp,8
   2a048:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
   2a04c:	e0bfff17 	ldw	r2,-4(fp)
   2a050:	10800017 	ldw	r2,0(r2)
   2a054:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_uart_close(&dev->state, fd->fd_flags);
   2a058:	e0bffe17 	ldw	r2,-8(fp)
   2a05c:	10c00a04 	addi	r3,r2,40
   2a060:	e0bfff17 	ldw	r2,-4(fp)
   2a064:	10800217 	ldw	r2,8(r2)
   2a068:	1809883a 	mov	r4,r3
   2a06c:	100b883a 	mov	r5,r2
   2a070:	002a3dc0 	call	2a3dc <altera_avalon_uart_close>
}
   2a074:	e037883a 	mov	sp,fp
   2a078:	dfc00117 	ldw	ra,4(sp)
   2a07c:	df000017 	ldw	fp,0(sp)
   2a080:	dec00204 	addi	sp,sp,8
   2a084:	f800283a 	ret

0002a088 <altera_avalon_uart_init>:
  alt_u32 status);

void 
altera_avalon_uart_init(altera_avalon_uart_state* sp, 
  alt_u32 irq_controller_id,  alt_u32 irq)
{
   2a088:	defff804 	addi	sp,sp,-32
   2a08c:	dfc00715 	stw	ra,28(sp)
   2a090:	df000615 	stw	fp,24(sp)
   2a094:	df000604 	addi	fp,sp,24
   2a098:	e13ffd15 	stw	r4,-12(fp)
   2a09c:	e17ffe15 	stw	r5,-8(fp)
   2a0a0:	e1bfff15 	stw	r6,-4(fp)
  void* base = sp->base;
   2a0a4:	e0bffd17 	ldw	r2,-12(fp)
   2a0a8:	10800017 	ldw	r2,0(r2)
   2a0ac:	e0bffb15 	stw	r2,-20(fp)
 * HAL.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_no_error (void)
{
  return 0;
   2a0b0:	0005883a 	mov	r2,zero
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
   2a0b4:	1000041e 	bne	r2,zero,2a0c8 <altera_avalon_uart_init+0x40>
   2a0b8:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
   2a0bc:	1000021e 	bne	r2,zero,2a0c8 <altera_avalon_uart_init+0x40>
   2a0c0:	0005883a 	mov	r2,zero
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
   2a0c4:	10000226 	beq	r2,zero,2a0d0 <altera_avalon_uart_init+0x48>
   2a0c8:	00800044 	movi	r2,1
   2a0cc:	00000106 	br	2a0d4 <altera_avalon_uart_init+0x4c>
   2a0d0:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
   2a0d4:	e0bffc15 	stw	r2,-16(fp)
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);

  if (!error)
   2a0d8:	e0bffc17 	ldw	r2,-16(fp)
   2a0dc:	10000f1e 	bne	r2,zero,2a11c <altera_avalon_uart_init+0x94>
  {
    /* enable interrupts at the device */
    sp->ctrl = ALTERA_AVALON_UART_CONTROL_RTS_MSK  |
   2a0e0:	e0bffd17 	ldw	r2,-12(fp)
   2a0e4:	00c32004 	movi	r3,3200
   2a0e8:	10c00115 	stw	r3,4(r2)
                ALTERA_AVALON_UART_CONTROL_RRDY_MSK |
                ALTERA_AVALON_UART_CONTROL_DCTS_MSK;

    IOWR_ALTERA_AVALON_UART_CONTROL(base, sp->ctrl); 
   2a0ec:	e0bffb17 	ldw	r2,-20(fp)
   2a0f0:	10800304 	addi	r2,r2,12
   2a0f4:	e0fffd17 	ldw	r3,-12(fp)
   2a0f8:	18c00117 	ldw	r3,4(r3)
   2a0fc:	10c00035 	stwio	r3,0(r2)
  
    /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
    alt_ic_isr_register(irq_controller_id, irq, altera_avalon_uart_irq, sp, 
   2a100:	d8000015 	stw	zero,0(sp)
   2a104:	e13ffe17 	ldw	r4,-8(fp)
   2a108:	e17fff17 	ldw	r5,-4(fp)
   2a10c:	018000f4 	movhi	r6,3
   2a110:	31a84c04 	addi	r6,r6,-24272
   2a114:	e1fffd17 	ldw	r7,-12(fp)
   2a118:	002ac800 	call	2ac80 <alt_ic_isr_register>
      0x0);
#else
    alt_irq_register (irq, sp, altera_avalon_uart_irq);
#endif  
  }
}
   2a11c:	e037883a 	mov	sp,fp
   2a120:	dfc00117 	ldw	ra,4(sp)
   2a124:	df000017 	ldw	fp,0(sp)
   2a128:	dec00204 	addi	sp,sp,8
   2a12c:	f800283a 	ret

0002a130 <altera_avalon_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_uart_irq(void* context)
#else
static void altera_avalon_uart_irq(void* context, alt_u32 id)
#endif
{
   2a130:	defffa04 	addi	sp,sp,-24
   2a134:	dfc00515 	stw	ra,20(sp)
   2a138:	df000415 	stw	fp,16(sp)
   2a13c:	df000404 	addi	fp,sp,16
   2a140:	e13fff15 	stw	r4,-4(fp)
  alt_u32 status;

  altera_avalon_uart_state* sp = (altera_avalon_uart_state*) context;
   2a144:	e0bfff17 	ldw	r2,-4(fp)
   2a148:	e0bffc15 	stw	r2,-16(fp)
  void* base               = sp->base;
   2a14c:	e0bffc17 	ldw	r2,-16(fp)
   2a150:	10800017 	ldw	r2,0(r2)
   2a154:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Read the status register in order to determine the cause of the
   * interrupt.
   */

  status = IORD_ALTERA_AVALON_UART_STATUS(base);
   2a158:	e0bffd17 	ldw	r2,-12(fp)
   2a15c:	10800204 	addi	r2,r2,8
   2a160:	10800037 	ldwio	r2,0(r2)
   2a164:	e0bffe15 	stw	r2,-8(fp)

  /* Clear any error flags set at the device */
  IOWR_ALTERA_AVALON_UART_STATUS(base, 0);
   2a168:	e0bffd17 	ldw	r2,-12(fp)
   2a16c:	10800204 	addi	r2,r2,8
   2a170:	0007883a 	mov	r3,zero
   2a174:	10c00035 	stwio	r3,0(r2)

  /* Dummy read to ensure IRQ is negated before ISR returns */
  IORD_ALTERA_AVALON_UART_STATUS(base);
   2a178:	e0bffd17 	ldw	r2,-12(fp)
   2a17c:	10800204 	addi	r2,r2,8
   2a180:	10800037 	ldwio	r2,0(r2)
  
  /* process a read irq */
  if (status & ALTERA_AVALON_UART_STATUS_RRDY_MSK)
   2a184:	e0bffe17 	ldw	r2,-8(fp)
   2a188:	1080200c 	andi	r2,r2,128
   2a18c:	10000326 	beq	r2,zero,2a19c <altera_avalon_uart_irq+0x6c>
  {
    altera_avalon_uart_rxirq(sp, status);
   2a190:	e13ffc17 	ldw	r4,-16(fp)
   2a194:	e17ffe17 	ldw	r5,-8(fp)
   2a198:	002a1c80 	call	2a1c8 <altera_avalon_uart_rxirq>
  }

  /* process a write irq */
  if (status & (ALTERA_AVALON_UART_STATUS_TRDY_MSK | 
   2a19c:	e0bffe17 	ldw	r2,-8(fp)
   2a1a0:	1081100c 	andi	r2,r2,1088
   2a1a4:	10000326 	beq	r2,zero,2a1b4 <altera_avalon_uart_irq+0x84>
                  ALTERA_AVALON_UART_STATUS_DCTS_MSK))
  {
    altera_avalon_uart_txirq(sp, status);
   2a1a8:	e13ffc17 	ldw	r4,-16(fp)
   2a1ac:	e17ffe17 	ldw	r5,-8(fp)
   2a1b0:	002a2a00 	call	2a2a0 <altera_avalon_uart_txirq>
  }
  

}
   2a1b4:	e037883a 	mov	sp,fp
   2a1b8:	dfc00117 	ldw	ra,4(sp)
   2a1bc:	df000017 	ldw	fp,0(sp)
   2a1c0:	dec00204 	addi	sp,sp,8
   2a1c4:	f800283a 	ret

0002a1c8 <altera_avalon_uart_rxirq>:
 * the receive circular buffer, and sets the apropriate flags to indicate 
 * that there is data ready to be processed.
 */
static void 
altera_avalon_uart_rxirq(altera_avalon_uart_state* sp, alt_u32 status)
{
   2a1c8:	defffc04 	addi	sp,sp,-16
   2a1cc:	df000315 	stw	fp,12(sp)
   2a1d0:	df000304 	addi	fp,sp,12
   2a1d4:	e13ffe15 	stw	r4,-8(fp)
   2a1d8:	e17fff15 	stw	r5,-4(fp)
  alt_u32 next;
  
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
   2a1dc:	e0bfff17 	ldw	r2,-4(fp)
   2a1e0:	108000cc 	andi	r2,r2,3
   2a1e4:	1000291e 	bne	r2,zero,2a28c <altera_avalon_uart_rxirq+0xc4>
   * In a multi-threaded environment, set the read event flag to indicate
   * that there is data ready. This is only done if the circular buffer was
   * previously empty.
   */

  if (sp->rx_end == sp->rx_start)
   2a1e8:	e0bffe17 	ldw	r2,-8(fp)
   2a1ec:	10800317 	ldw	r2,12(r2)
    ALT_FLAG_POST (sp->events, ALT_UART_READ_RDY, OS_FLAG_SET);
  }

  /* Determine which slot to use next in the circular buffer */

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
   2a1f0:	e0bffe17 	ldw	r2,-8(fp)
   2a1f4:	10800317 	ldw	r2,12(r2)
   2a1f8:	10800044 	addi	r2,r2,1
   2a1fc:	10800fcc 	andi	r2,r2,63
   2a200:	e0bffd15 	stw	r2,-12(fp)

  /* Transfer data from the device to the circular buffer */

  sp->rx_buf[sp->rx_end] = IORD_ALTERA_AVALON_UART_RXDATA(sp->base);
   2a204:	e0bffe17 	ldw	r2,-8(fp)
   2a208:	10800317 	ldw	r2,12(r2)
   2a20c:	e0fffe17 	ldw	r3,-8(fp)
   2a210:	18c00017 	ldw	r3,0(r3)
   2a214:	18c00037 	ldwio	r3,0(r3)
   2a218:	e13ffe17 	ldw	r4,-8(fp)
   2a21c:	2085883a 	add	r2,r4,r2
   2a220:	10800704 	addi	r2,r2,28
   2a224:	10c00005 	stb	r3,0(r2)

  sp->rx_end = next;
   2a228:	e0bffe17 	ldw	r2,-8(fp)
   2a22c:	e0fffd17 	ldw	r3,-12(fp)
   2a230:	10c00315 	stw	r3,12(r2)

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
   2a234:	e0bffe17 	ldw	r2,-8(fp)
   2a238:	10800317 	ldw	r2,12(r2)
   2a23c:	10800044 	addi	r2,r2,1
   2a240:	10800fcc 	andi	r2,r2,63
   2a244:	e0bffd15 	stw	r2,-12(fp)
  /*
   * If the cicular buffer was full, disable interrupts. Interrupts will be
   * re-enabled when data is removed from the buffer.
   */

  if (next == sp->rx_start)
   2a248:	e0bffe17 	ldw	r2,-8(fp)
   2a24c:	10c00217 	ldw	r3,8(r2)
   2a250:	e0bffd17 	ldw	r2,-12(fp)
   2a254:	18800e1e 	bne	r3,r2,2a290 <altera_avalon_uart_rxirq+0xc8>
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
   2a258:	e0bffe17 	ldw	r2,-8(fp)
   2a25c:	10c00117 	ldw	r3,4(r2)
   2a260:	00bfdfc4 	movi	r2,-129
   2a264:	1886703a 	and	r3,r3,r2
   2a268:	e0bffe17 	ldw	r2,-8(fp)
   2a26c:	10c00115 	stw	r3,4(r2)
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
   2a270:	e0bffe17 	ldw	r2,-8(fp)
   2a274:	10800017 	ldw	r2,0(r2)
   2a278:	10800304 	addi	r2,r2,12
   2a27c:	e0fffe17 	ldw	r3,-8(fp)
   2a280:	18c00117 	ldw	r3,4(r3)
   2a284:	10c00035 	stwio	r3,0(r2)
   2a288:	00000106 	br	2a290 <altera_avalon_uart_rxirq+0xc8>
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
                  ALTERA_AVALON_UART_STATUS_FE_MSK))
  {
    return;
   2a28c:	0001883a 	nop
  if (next == sp->rx_start)
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
  }   
}
   2a290:	e037883a 	mov	sp,fp
   2a294:	df000017 	ldw	fp,0(sp)
   2a298:	dec00104 	addi	sp,sp,4
   2a29c:	f800283a 	ret

0002a2a0 <altera_avalon_uart_txirq>:
 * buffer to the device, and sets the apropriate flags to indicate that 
 * there is data ready to be processed.
 */
static void 
altera_avalon_uart_txirq(altera_avalon_uart_state* sp, alt_u32 status)
{
   2a2a0:	defffd04 	addi	sp,sp,-12
   2a2a4:	df000215 	stw	fp,8(sp)
   2a2a8:	df000204 	addi	fp,sp,8
   2a2ac:	e13ffe15 	stw	r4,-8(fp)
   2a2b0:	e17fff15 	stw	r5,-4(fp)
  /* Transfer data if there is some ready to be transfered */

  if (sp->tx_start != sp->tx_end)
   2a2b4:	e0bffe17 	ldw	r2,-8(fp)
   2a2b8:	10c00417 	ldw	r3,16(r2)
   2a2bc:	e0bffe17 	ldw	r2,-8(fp)
   2a2c0:	10800517 	ldw	r2,20(r2)
   2a2c4:	18803026 	beq	r3,r2,2a388 <altera_avalon_uart_txirq+0xe8>
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
   2a2c8:	e0bffe17 	ldw	r2,-8(fp)
   2a2cc:	10800617 	ldw	r2,24(r2)
   2a2d0:	1080008c 	andi	r2,r2,2
   2a2d4:	10000326 	beq	r2,zero,2a2e4 <altera_avalon_uart_txirq+0x44>
      (status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
   2a2d8:	e0bfff17 	ldw	r2,-4(fp)
   2a2dc:	1082000c 	andi	r2,r2,2048
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
   2a2e0:	10001b26 	beq	r2,zero,2a350 <altera_avalon_uart_txirq+0xb0>
       * In a multi-threaded environment, set the write event flag to indicate
       * that there is space in the circular buffer. This is only done if the
       * buffer was previously empty.
       */

      if (sp->tx_start == ((sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK))
   2a2e4:	e0bffe17 	ldw	r2,-8(fp)
   2a2e8:	10800417 	ldw	r2,16(r2)
                       OS_FLAG_SET);
      }

      /* Write the data to the device */

      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, sp->tx_buf[sp->tx_start]);
   2a2ec:	e0bffe17 	ldw	r2,-8(fp)
   2a2f0:	10800017 	ldw	r2,0(r2)
   2a2f4:	10800104 	addi	r2,r2,4
   2a2f8:	e0fffe17 	ldw	r3,-8(fp)
   2a2fc:	18c00417 	ldw	r3,16(r3)
   2a300:	e13ffe17 	ldw	r4,-8(fp)
   2a304:	20c7883a 	add	r3,r4,r3
   2a308:	18c01704 	addi	r3,r3,92
   2a30c:	18c00003 	ldbu	r3,0(r3)
   2a310:	18c03fcc 	andi	r3,r3,255
   2a314:	10c00035 	stwio	r3,0(r2)

      sp->tx_start = (++sp->tx_start) & ALT_AVALON_UART_BUF_MSK;
   2a318:	e0bffe17 	ldw	r2,-8(fp)
   2a31c:	10800417 	ldw	r2,16(r2)
   2a320:	10800044 	addi	r2,r2,1
   2a324:	e0fffe17 	ldw	r3,-8(fp)
   2a328:	18800415 	stw	r2,16(r3)
   2a32c:	10c00fcc 	andi	r3,r2,63
   2a330:	e0bffe17 	ldw	r2,-8(fp)
   2a334:	10c00415 	stw	r3,16(r2)
      /*
       * In case the tranmit interrupt had previously been disabled by 
       * detecting a low value on CTS, it is reenabled here.
       */ 

      sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
   2a338:	e0bffe17 	ldw	r2,-8(fp)
   2a33c:	10800117 	ldw	r2,4(r2)
   2a340:	10c01014 	ori	r3,r2,64
   2a344:	e0bffe17 	ldw	r2,-8(fp)
   2a348:	10c00115 	stw	r3,4(r2)
   2a34c:	00000e06 	br	2a388 <altera_avalon_uart_txirq+0xe8>
       * the last write to the status register. To avoid this resulting in
       * deadlock, it's necessary to re-check the status register here
       * before throttling.
       */
 
      status = IORD_ALTERA_AVALON_UART_STATUS(sp->base); 
   2a350:	e0bffe17 	ldw	r2,-8(fp)
   2a354:	10800017 	ldw	r2,0(r2)
   2a358:	10800204 	addi	r2,r2,8
   2a35c:	10800037 	ldwio	r2,0(r2)
   2a360:	e0bfff15 	stw	r2,-4(fp)

      if (!(status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
   2a364:	e0bfff17 	ldw	r2,-4(fp)
   2a368:	1082000c 	andi	r2,r2,2048
   2a36c:	1000061e 	bne	r2,zero,2a388 <altera_avalon_uart_txirq+0xe8>
      {
        sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
   2a370:	e0bffe17 	ldw	r2,-8(fp)
   2a374:	10c00117 	ldw	r3,4(r2)
   2a378:	00bfefc4 	movi	r2,-65
   2a37c:	1886703a 	and	r3,r3,r2
   2a380:	e0bffe17 	ldw	r2,-8(fp)
   2a384:	10c00115 	stw	r3,4(r2)
  /*
   * If the circular buffer is empty, disable the interrupt. This will be
   * re-enabled when new data is placed in the buffer.
   */

  if (sp->tx_start == sp->tx_end)
   2a388:	e0bffe17 	ldw	r2,-8(fp)
   2a38c:	10c00417 	ldw	r3,16(r2)
   2a390:	e0bffe17 	ldw	r2,-8(fp)
   2a394:	10800517 	ldw	r2,20(r2)
   2a398:	1880061e 	bne	r3,r2,2a3b4 <altera_avalon_uart_txirq+0x114>
  {
    sp->ctrl &= ~(ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
   2a39c:	e0bffe17 	ldw	r2,-8(fp)
   2a3a0:	10c00117 	ldw	r3,4(r2)
   2a3a4:	00beefc4 	movi	r2,-1089
   2a3a8:	1886703a 	and	r3,r3,r2
   2a3ac:	e0bffe17 	ldw	r2,-8(fp)
   2a3b0:	10c00115 	stw	r3,4(r2)
                    ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
  }

  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
   2a3b4:	e0bffe17 	ldw	r2,-8(fp)
   2a3b8:	10800017 	ldw	r2,0(r2)
   2a3bc:	10800304 	addi	r2,r2,12
   2a3c0:	e0fffe17 	ldw	r3,-8(fp)
   2a3c4:	18c00117 	ldw	r3,4(r3)
   2a3c8:	10c00035 	stwio	r3,0(r2)
}
   2a3cc:	e037883a 	mov	sp,fp
   2a3d0:	df000017 	ldw	fp,0(sp)
   2a3d4:	dec00104 	addi	sp,sp,4
   2a3d8:	f800283a 	ret

0002a3dc <altera_avalon_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
   2a3dc:	defffd04 	addi	sp,sp,-12
   2a3e0:	df000215 	stw	fp,8(sp)
   2a3e4:	df000204 	addi	fp,sp,8
   2a3e8:	e13ffe15 	stw	r4,-8(fp)
   2a3ec:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
   2a3f0:	00000506 	br	2a408 <altera_avalon_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
   2a3f4:	e0bfff17 	ldw	r2,-4(fp)
   2a3f8:	1090000c 	andi	r2,r2,16384
   2a3fc:	10000226 	beq	r2,zero,2a408 <altera_avalon_uart_close+0x2c>
      return -EWOULDBLOCK; 
   2a400:	00bffd44 	movi	r2,-11
   2a404:	00000606 	br	2a420 <altera_avalon_uart_close+0x44>
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
   2a408:	e0bffe17 	ldw	r2,-8(fp)
   2a40c:	10c00417 	ldw	r3,16(r2)
   2a410:	e0bffe17 	ldw	r2,-8(fp)
   2a414:	10800517 	ldw	r2,20(r2)
   2a418:	18bff61e 	bne	r3,r2,2a3f4 <altera_avalon_uart_close+0x18>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
   2a41c:	0005883a 	mov	r2,zero
}
   2a420:	e037883a 	mov	sp,fp
   2a424:	df000017 	ldw	fp,0(sp)
   2a428:	dec00104 	addi	sp,sp,4
   2a42c:	f800283a 	ret

0002a430 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   2a430:	defffe04 	addi	sp,sp,-8
   2a434:	dfc00115 	stw	ra,4(sp)
   2a438:	df000015 	stw	fp,0(sp)
   2a43c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   2a440:	008000f4 	movhi	r2,3
   2a444:	108d3404 	addi	r2,r2,13520
   2a448:	10800017 	ldw	r2,0(r2)
   2a44c:	10000526 	beq	r2,zero,2a464 <alt_get_errno+0x34>
   2a450:	008000f4 	movhi	r2,3
   2a454:	108d3404 	addi	r2,r2,13520
   2a458:	10800017 	ldw	r2,0(r2)
   2a45c:	103ee83a 	callr	r2
   2a460:	00000206 	br	2a46c <alt_get_errno+0x3c>
   2a464:	008000f4 	movhi	r2,3
   2a468:	10961104 	addi	r2,r2,22596
}
   2a46c:	e037883a 	mov	sp,fp
   2a470:	dfc00117 	ldw	ra,4(sp)
   2a474:	df000017 	ldw	fp,0(sp)
   2a478:	dec00204 	addi	sp,sp,8
   2a47c:	f800283a 	ret

0002a480 <altera_avalon_uart_read>:
 */

int 
altera_avalon_uart_read(altera_avalon_uart_state* sp, char* ptr, int len,
  int flags)
{
   2a480:	deffef04 	addi	sp,sp,-68
   2a484:	dfc01015 	stw	ra,64(sp)
   2a488:	df000f15 	stw	fp,60(sp)
   2a48c:	df000f04 	addi	fp,sp,60
   2a490:	e13ffc15 	stw	r4,-16(fp)
   2a494:	e17ffd15 	stw	r5,-12(fp)
   2a498:	e1bffe15 	stw	r6,-8(fp)
   2a49c:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             block;
  alt_u32         next;
  alt_u8          read_would_block = 0;
   2a4a0:	e03ff105 	stb	zero,-60(fp)
  int             count = 0;
   2a4a4:	e03ff215 	stw	zero,-56(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  block = !(flags & O_NONBLOCK);
   2a4a8:	e0bfff17 	ldw	r2,-4(fp)
   2a4ac:	1090000c 	andi	r2,r2,16384
   2a4b0:	1005003a 	cmpeq	r2,r2,zero
   2a4b4:	10803fcc 	andi	r2,r2,255
   2a4b8:	e0bff315 	stw	r2,-52(fp)
  /*
   * Calculate which slot in the circular buffer is the next one to read
   * data from.
   */

  next = (sp->rx_start + 1) & ALT_AVALON_UART_BUF_MSK;
   2a4bc:	e0bffc17 	ldw	r2,-16(fp)
   2a4c0:	10800217 	ldw	r2,8(r2)
   2a4c4:	10800044 	addi	r2,r2,1
   2a4c8:	10800fcc 	andi	r2,r2,63
   2a4cc:	e0bff415 	stw	r2,-48(fp)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
   2a4d0:	00001906 	br	2a538 <altera_avalon_uart_read+0xb8>
    {
      count++;
   2a4d4:	e0bff217 	ldw	r2,-56(fp)
   2a4d8:	10800044 	addi	r2,r2,1
   2a4dc:	e0bff215 	stw	r2,-56(fp)
      *ptr++ = sp->rx_buf[sp->rx_start];
   2a4e0:	e0bffc17 	ldw	r2,-16(fp)
   2a4e4:	10800217 	ldw	r2,8(r2)
   2a4e8:	e0fffc17 	ldw	r3,-16(fp)
   2a4ec:	1885883a 	add	r2,r3,r2
   2a4f0:	10800704 	addi	r2,r2,28
   2a4f4:	10800003 	ldbu	r2,0(r2)
   2a4f8:	1007883a 	mov	r3,r2
   2a4fc:	e0bffd17 	ldw	r2,-12(fp)
   2a500:	10c00005 	stb	r3,0(r2)
   2a504:	e0bffd17 	ldw	r2,-12(fp)
   2a508:	10800044 	addi	r2,r2,1
   2a50c:	e0bffd15 	stw	r2,-12(fp)
      
      sp->rx_start = (++sp->rx_start) & ALT_AVALON_UART_BUF_MSK;
   2a510:	e0bffc17 	ldw	r2,-16(fp)
   2a514:	10800217 	ldw	r2,8(r2)
   2a518:	10c00044 	addi	r3,r2,1
   2a51c:	e0bffc17 	ldw	r2,-16(fp)
   2a520:	10c00215 	stw	r3,8(r2)
   2a524:	e0bffc17 	ldw	r2,-16(fp)
   2a528:	10800217 	ldw	r2,8(r2)
   2a52c:	10c00fcc 	andi	r3,r2,63
   2a530:	e0bffc17 	ldw	r2,-16(fp)
   2a534:	10c00215 	stw	r3,8(r2)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
   2a538:	e0fff217 	ldw	r3,-56(fp)
   2a53c:	e0bffe17 	ldw	r2,-8(fp)
   2a540:	1880050e 	bge	r3,r2,2a558 <altera_avalon_uart_read+0xd8>
   2a544:	e0bffc17 	ldw	r2,-16(fp)
   2a548:	10c00217 	ldw	r3,8(r2)
   2a54c:	e0bffc17 	ldw	r2,-16(fp)
   2a550:	10800317 	ldw	r2,12(r2)
   2a554:	18bfdf1e 	bne	r3,r2,2a4d4 <altera_avalon_uart_read+0x54>
    /*
     * If no data has been transferred, the circular buffer is empty, and
     * this is not a non-blocking access, block waiting for data to arrive.
     */

    if (!count && (sp->rx_start == sp->rx_end))
   2a558:	e0bff217 	ldw	r2,-56(fp)
   2a55c:	10002f1e 	bne	r2,zero,2a61c <altera_avalon_uart_read+0x19c>
   2a560:	e0bffc17 	ldw	r2,-16(fp)
   2a564:	10c00217 	ldw	r3,8(r2)
   2a568:	e0bffc17 	ldw	r2,-16(fp)
   2a56c:	10800317 	ldw	r2,12(r2)
   2a570:	18802a1e 	bne	r3,r2,2a61c <altera_avalon_uart_read+0x19c>
    {
      if (!block)
   2a574:	e0bff317 	ldw	r2,-52(fp)
   2a578:	1000061e 	bne	r2,zero,2a594 <altera_avalon_uart_read+0x114>
      {
        /* Set errno to indicate the reason we're not returning any data */

        ALT_ERRNO = EWOULDBLOCK;
   2a57c:	002a4300 	call	2a430 <alt_get_errno>
   2a580:	00c002c4 	movi	r3,11
   2a584:	10c00015 	stw	r3,0(r2)
        read_would_block = 1;
   2a588:	00800044 	movi	r2,1
   2a58c:	e0bff105 	stb	r2,-60(fp)
        break;
   2a590:	00002606 	br	2a62c <altera_avalon_uart_read+0x1ac>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   2a594:	0005303a 	rdctl	r2,status
   2a598:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   2a59c:	e0fff617 	ldw	r3,-40(fp)
   2a5a0:	00bfff84 	movi	r2,-2
   2a5a4:	1884703a 	and	r2,r3,r2
   2a5a8:	1001703a 	wrctl	status,r2
  
  return context;
   2a5ac:	e0bff617 	ldw	r2,-40(fp)
      {
       /* Block waiting for some data to arrive */

       /* First, ensure read interrupts are enabled to avoid deadlock */

       context = alt_irq_disable_all ();
   2a5b0:	e0bff515 	stw	r2,-44(fp)
       sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
   2a5b4:	e0bffc17 	ldw	r2,-16(fp)
   2a5b8:	10800117 	ldw	r2,4(r2)
   2a5bc:	10c02014 	ori	r3,r2,128
   2a5c0:	e0bffc17 	ldw	r2,-16(fp)
   2a5c4:	10c00115 	stw	r3,4(r2)
       IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
   2a5c8:	e0bffc17 	ldw	r2,-16(fp)
   2a5cc:	10800017 	ldw	r2,0(r2)
   2a5d0:	10800304 	addi	r2,r2,12
   2a5d4:	e0fffc17 	ldw	r3,-16(fp)
   2a5d8:	18c00117 	ldw	r3,4(r3)
   2a5dc:	10c00035 	stwio	r3,0(r2)
   2a5e0:	e0bff517 	ldw	r2,-44(fp)
   2a5e4:	e0bff715 	stw	r2,-36(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   2a5e8:	0005303a 	rdctl	r2,status
   2a5ec:	e0bff815 	stw	r2,-32(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   2a5f0:	e0fff817 	ldw	r3,-32(fp)
   2a5f4:	00bfff84 	movi	r2,-2
   2a5f8:	1884703a 	and	r2,r3,r2
   2a5fc:	e0bff815 	stw	r2,-32(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   2a600:	e0bff717 	ldw	r2,-36(fp)
   2a604:	1080004c 	andi	r2,r2,1
   2a608:	e0fff817 	ldw	r3,-32(fp)
   2a60c:	1884b03a 	or	r2,r3,r2
   2a610:	e0bff815 	stw	r2,-32(fp)
  
  NIOS2_WRITE_STATUS (status);
   2a614:	e0bff817 	ldw	r2,-32(fp)
   2a618:	1001703a 	wrctl	status,r2
                      OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                      0);
      }
    }
  }
  while (!count && len);
   2a61c:	e0bff217 	ldw	r2,-56(fp)
   2a620:	1000021e 	bne	r2,zero,2a62c <altera_avalon_uart_read+0x1ac>
   2a624:	e0bffe17 	ldw	r2,-8(fp)
   2a628:	103fc31e 	bne	r2,zero,2a538 <altera_avalon_uart_read+0xb8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   2a62c:	0005303a 	rdctl	r2,status
   2a630:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   2a634:	e0fff917 	ldw	r3,-28(fp)
   2a638:	00bfff84 	movi	r2,-2
   2a63c:	1884703a 	and	r2,r3,r2
   2a640:	1001703a 	wrctl	status,r2
  
  return context;
   2a644:	e0bff917 	ldw	r2,-28(fp)
  /*
   * Ensure that interrupts are enabled, so that the circular buffer can
   * re-fill.
   */

  context = alt_irq_disable_all ();
   2a648:	e0bff515 	stw	r2,-44(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
   2a64c:	e0bffc17 	ldw	r2,-16(fp)
   2a650:	10800117 	ldw	r2,4(r2)
   2a654:	10c02014 	ori	r3,r2,128
   2a658:	e0bffc17 	ldw	r2,-16(fp)
   2a65c:	10c00115 	stw	r3,4(r2)
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
   2a660:	e0bffc17 	ldw	r2,-16(fp)
   2a664:	10800017 	ldw	r2,0(r2)
   2a668:	10800304 	addi	r2,r2,12
   2a66c:	e0fffc17 	ldw	r3,-16(fp)
   2a670:	18c00117 	ldw	r3,4(r3)
   2a674:	10c00035 	stwio	r3,0(r2)
   2a678:	e0bff517 	ldw	r2,-44(fp)
   2a67c:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   2a680:	0005303a 	rdctl	r2,status
   2a684:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   2a688:	e0fffb17 	ldw	r3,-20(fp)
   2a68c:	00bfff84 	movi	r2,-2
   2a690:	1884703a 	and	r2,r3,r2
   2a694:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   2a698:	e0bffa17 	ldw	r2,-24(fp)
   2a69c:	1080004c 	andi	r2,r2,1
   2a6a0:	e0fffb17 	ldw	r3,-20(fp)
   2a6a4:	1884b03a 	or	r2,r3,r2
   2a6a8:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
   2a6ac:	e0bffb17 	ldw	r2,-20(fp)
   2a6b0:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* Return the number of bytes read */
  if(read_would_block) {
   2a6b4:	e0bff103 	ldbu	r2,-60(fp)
   2a6b8:	10000226 	beq	r2,zero,2a6c4 <altera_avalon_uart_read+0x244>
    return -EWOULDBLOCK;
   2a6bc:	00bffd44 	movi	r2,-11
   2a6c0:	00000106 	br	2a6c8 <altera_avalon_uart_read+0x248>
  }
  else {
    return count;
   2a6c4:	e0bff217 	ldw	r2,-56(fp)
  }
}
   2a6c8:	e037883a 	mov	sp,fp
   2a6cc:	dfc00117 	ldw	ra,4(sp)
   2a6d0:	df000017 	ldw	fp,0(sp)
   2a6d4:	dec00204 	addi	sp,sp,8
   2a6d8:	f800283a 	ret

0002a6dc <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   2a6dc:	defffe04 	addi	sp,sp,-8
   2a6e0:	dfc00115 	stw	ra,4(sp)
   2a6e4:	df000015 	stw	fp,0(sp)
   2a6e8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   2a6ec:	008000f4 	movhi	r2,3
   2a6f0:	108d3404 	addi	r2,r2,13520
   2a6f4:	10800017 	ldw	r2,0(r2)
   2a6f8:	10000526 	beq	r2,zero,2a710 <alt_get_errno+0x34>
   2a6fc:	008000f4 	movhi	r2,3
   2a700:	108d3404 	addi	r2,r2,13520
   2a704:	10800017 	ldw	r2,0(r2)
   2a708:	103ee83a 	callr	r2
   2a70c:	00000206 	br	2a718 <alt_get_errno+0x3c>
   2a710:	008000f4 	movhi	r2,3
   2a714:	10961104 	addi	r2,r2,22596
}
   2a718:	e037883a 	mov	sp,fp
   2a71c:	dfc00117 	ldw	ra,4(sp)
   2a720:	df000017 	ldw	fp,0(sp)
   2a724:	dec00204 	addi	sp,sp,8
   2a728:	f800283a 	ret

0002a72c <altera_avalon_uart_write>:
 */

int
altera_avalon_uart_write(altera_avalon_uart_state* sp, const char* ptr, int len,
  int flags)
{
   2a72c:	defff004 	addi	sp,sp,-64
   2a730:	dfc00f15 	stw	ra,60(sp)
   2a734:	df000e15 	stw	fp,56(sp)
   2a738:	df000e04 	addi	fp,sp,56
   2a73c:	e13ffc15 	stw	r4,-16(fp)
   2a740:	e17ffd15 	stw	r5,-12(fp)
   2a744:	e1bffe15 	stw	r6,-8(fp)
   2a748:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             no_block;
  alt_u32         next;
  int             count = len;
   2a74c:	e0bffe17 	ldw	r2,-8(fp)
   2a750:	e0bff215 	stw	r2,-56(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  no_block = (flags & O_NONBLOCK);
   2a754:	e0bfff17 	ldw	r2,-4(fp)
   2a758:	1090000c 	andi	r2,r2,16384
   2a75c:	e0bff315 	stw	r2,-52(fp)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
   2a760:	00004606 	br	2a87c <altera_avalon_uart_write+0x150>
  {
    /* Determine the next slot in the buffer to access */

    next = (sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK;
   2a764:	e0bffc17 	ldw	r2,-16(fp)
   2a768:	10800517 	ldw	r2,20(r2)
   2a76c:	10800044 	addi	r2,r2,1
   2a770:	10800fcc 	andi	r2,r2,63
   2a774:	e0bff415 	stw	r2,-48(fp)

    /* block waiting for space if necessary */

    if (next == sp->tx_start)
   2a778:	e0bffc17 	ldw	r2,-16(fp)
   2a77c:	10c00417 	ldw	r3,16(r2)
   2a780:	e0bff417 	ldw	r2,-48(fp)
   2a784:	18802c1e 	bne	r3,r2,2a838 <altera_avalon_uart_write+0x10c>
    {
      if (no_block)
   2a788:	e0bff317 	ldw	r2,-52(fp)
   2a78c:	10000426 	beq	r2,zero,2a7a0 <altera_avalon_uart_write+0x74>
      {
        /* Set errno to indicate why this function returned early */
 
        ALT_ERRNO = EWOULDBLOCK;
   2a790:	002a6dc0 	call	2a6dc <alt_get_errno>
   2a794:	00c002c4 	movi	r3,11
   2a798:	10c00015 	stw	r3,0(r2)
        break;
   2a79c:	00003906 	br	2a884 <altera_avalon_uart_write+0x158>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   2a7a0:	0005303a 	rdctl	r2,status
   2a7a4:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   2a7a8:	e0fff617 	ldw	r3,-40(fp)
   2a7ac:	00bfff84 	movi	r2,-2
   2a7b0:	1884703a 	and	r2,r3,r2
   2a7b4:	1001703a 	wrctl	status,r2
  
  return context;
   2a7b8:	e0bff617 	ldw	r2,-40(fp)
      {
        /* Block waiting for space in the circular buffer */

        /* First, ensure transmit interrupts are enabled to avoid deadlock */

        context = alt_irq_disable_all ();
   2a7bc:	e0bff515 	stw	r2,-44(fp)
        sp->ctrl |= (ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
   2a7c0:	e0bffc17 	ldw	r2,-16(fp)
   2a7c4:	10800117 	ldw	r2,4(r2)
   2a7c8:	10c11014 	ori	r3,r2,1088
   2a7cc:	e0bffc17 	ldw	r2,-16(fp)
   2a7d0:	10c00115 	stw	r3,4(r2)
                        ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
        IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
   2a7d4:	e0bffc17 	ldw	r2,-16(fp)
   2a7d8:	10800017 	ldw	r2,0(r2)
   2a7dc:	10800304 	addi	r2,r2,12
   2a7e0:	e0fffc17 	ldw	r3,-16(fp)
   2a7e4:	18c00117 	ldw	r3,4(r3)
   2a7e8:	10c00035 	stwio	r3,0(r2)
   2a7ec:	e0bff517 	ldw	r2,-44(fp)
   2a7f0:	e0bff715 	stw	r2,-36(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   2a7f4:	0005303a 	rdctl	r2,status
   2a7f8:	e0bff815 	stw	r2,-32(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   2a7fc:	e0fff817 	ldw	r3,-32(fp)
   2a800:	00bfff84 	movi	r2,-2
   2a804:	1884703a 	and	r2,r3,r2
   2a808:	e0bff815 	stw	r2,-32(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   2a80c:	e0bff717 	ldw	r2,-36(fp)
   2a810:	1080004c 	andi	r2,r2,1
   2a814:	e0fff817 	ldw	r3,-32(fp)
   2a818:	1884b03a 	or	r2,r3,r2
   2a81c:	e0bff815 	stw	r2,-32(fp)
  
  NIOS2_WRITE_STATUS (status);
   2a820:	e0bff817 	ldw	r2,-32(fp)
   2a824:	1001703a 	wrctl	status,r2
          ALT_FLAG_PEND (sp->events, 
                         ALT_UART_WRITE_RDY,
                         OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                         0);
        }
        while ((next == sp->tx_start));
   2a828:	e0bffc17 	ldw	r2,-16(fp)
   2a82c:	10c00417 	ldw	r3,16(r2)
   2a830:	e0bff417 	ldw	r2,-48(fp)
   2a834:	18bffc26 	beq	r3,r2,2a828 <altera_avalon_uart_write+0xfc>
      }
    }

    count--;
   2a838:	e0bff217 	ldw	r2,-56(fp)
   2a83c:	10bfffc4 	addi	r2,r2,-1
   2a840:	e0bff215 	stw	r2,-56(fp)

    /* Add the next character to the transmit buffer */

    sp->tx_buf[sp->tx_end] = *ptr++;
   2a844:	e0bffc17 	ldw	r2,-16(fp)
   2a848:	10800517 	ldw	r2,20(r2)
   2a84c:	e0fffd17 	ldw	r3,-12(fp)
   2a850:	18c00003 	ldbu	r3,0(r3)
   2a854:	e13ffc17 	ldw	r4,-16(fp)
   2a858:	2085883a 	add	r2,r4,r2
   2a85c:	10801704 	addi	r2,r2,92
   2a860:	10c00005 	stb	r3,0(r2)
   2a864:	e0bffd17 	ldw	r2,-12(fp)
   2a868:	10800044 	addi	r2,r2,1
   2a86c:	e0bffd15 	stw	r2,-12(fp)
    sp->tx_end = next;
   2a870:	e0bffc17 	ldw	r2,-16(fp)
   2a874:	e0fff417 	ldw	r3,-48(fp)
   2a878:	10c00515 	stw	r3,20(r2)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
   2a87c:	e0bff217 	ldw	r2,-56(fp)
   2a880:	103fb81e 	bne	r2,zero,2a764 <altera_avalon_uart_write+0x38>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   2a884:	0005303a 	rdctl	r2,status
   2a888:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   2a88c:	e0fff917 	ldw	r3,-28(fp)
   2a890:	00bfff84 	movi	r2,-2
   2a894:	1884703a 	and	r2,r3,r2
   2a898:	1001703a 	wrctl	status,r2
  
  return context;
   2a89c:	e0bff917 	ldw	r2,-28(fp)
  /* 
   * Ensure that interrupts are enabled, so that the circular buffer can 
   * drain.
   */

  context = alt_irq_disable_all ();
   2a8a0:	e0bff515 	stw	r2,-44(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
   2a8a4:	e0bffc17 	ldw	r2,-16(fp)
   2a8a8:	10800117 	ldw	r2,4(r2)
   2a8ac:	10c11014 	ori	r3,r2,1088
   2a8b0:	e0bffc17 	ldw	r2,-16(fp)
   2a8b4:	10c00115 	stw	r3,4(r2)
                 ALTERA_AVALON_UART_CONTROL_DCTS_MSK;
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
   2a8b8:	e0bffc17 	ldw	r2,-16(fp)
   2a8bc:	10800017 	ldw	r2,0(r2)
   2a8c0:	10800304 	addi	r2,r2,12
   2a8c4:	e0fffc17 	ldw	r3,-16(fp)
   2a8c8:	18c00117 	ldw	r3,4(r3)
   2a8cc:	10c00035 	stwio	r3,0(r2)
   2a8d0:	e0bff517 	ldw	r2,-44(fp)
   2a8d4:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   2a8d8:	0005303a 	rdctl	r2,status
   2a8dc:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   2a8e0:	e0fffb17 	ldw	r3,-20(fp)
   2a8e4:	00bfff84 	movi	r2,-2
   2a8e8:	1884703a 	and	r2,r3,r2
   2a8ec:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   2a8f0:	e0bffa17 	ldw	r2,-24(fp)
   2a8f4:	1080004c 	andi	r2,r2,1
   2a8f8:	e0fffb17 	ldw	r3,-20(fp)
   2a8fc:	1884b03a 	or	r2,r3,r2
   2a900:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
   2a904:	e0bffb17 	ldw	r2,-20(fp)
   2a908:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* return the number of bytes written */

  return (len - count);
   2a90c:	e0fffe17 	ldw	r3,-8(fp)
   2a910:	e0bff217 	ldw	r2,-56(fp)
   2a914:	1885c83a 	sub	r2,r3,r2
}
   2a918:	e037883a 	mov	sp,fp
   2a91c:	dfc00117 	ldw	ra,4(sp)
   2a920:	df000017 	ldw	fp,0(sp)
   2a924:	dec00204 	addi	sp,sp,8
   2a928:	f800283a 	ret

0002a92c <VIC_0_VECTOR_TABLE>:

    .section .text, "xa"
    .align 2
    .globl VIC_0_VECTOR_TABLE
VIC_0_VECTOR_TABLE:
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2a92c:	0030e03a 	nextpc	et
   2a930:	002ab2c1 	jmpi	2ab2c <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2a93c:	0030e03a 	nextpc	et
   2a940:	002ab2c1 	jmpi	2ab2c <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2a94c:	0030e03a 	nextpc	et
   2a950:	002ab2c1 	jmpi	2ab2c <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2a95c:	0030e03a 	nextpc	et
   2a960:	002ab2c1 	jmpi	2ab2c <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2a96c:	0030e03a 	nextpc	et
   2a970:	002ab2c1 	jmpi	2ab2c <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2a97c:	0030e03a 	nextpc	et
   2a980:	002ab2c1 	jmpi	2ab2c <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2a98c:	0030e03a 	nextpc	et
   2a990:	002ab2c1 	jmpi	2ab2c <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2a99c:	0030e03a 	nextpc	et
   2a9a0:	002ab2c1 	jmpi	2ab2c <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2a9ac:	0030e03a 	nextpc	et
   2a9b0:	002ab2c1 	jmpi	2ab2c <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2a9bc:	0030e03a 	nextpc	et
   2a9c0:	002ab2c1 	jmpi	2ab2c <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2a9cc:	0030e03a 	nextpc	et
   2a9d0:	002ab2c1 	jmpi	2ab2c <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2a9dc:	0030e03a 	nextpc	et
   2a9e0:	002ab2c1 	jmpi	2ab2c <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2a9ec:	0030e03a 	nextpc	et
   2a9f0:	002ab2c1 	jmpi	2ab2c <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2a9fc:	0030e03a 	nextpc	et
   2aa00:	002ab2c1 	jmpi	2ab2c <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2aa0c:	0030e03a 	nextpc	et
   2aa10:	002ab2c1 	jmpi	2ab2c <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2aa1c:	0030e03a 	nextpc	et
   2aa20:	002ab2c1 	jmpi	2ab2c <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2aa2c:	0030e03a 	nextpc	et
   2aa30:	002ab2c1 	jmpi	2ab2c <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2aa3c:	0030e03a 	nextpc	et
   2aa40:	002ab2c1 	jmpi	2ab2c <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2aa4c:	0030e03a 	nextpc	et
   2aa50:	002ab2c1 	jmpi	2ab2c <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2aa5c:	0030e03a 	nextpc	et
   2aa60:	002ab2c1 	jmpi	2ab2c <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2aa6c:	0030e03a 	nextpc	et
   2aa70:	002ab2c1 	jmpi	2ab2c <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2aa7c:	0030e03a 	nextpc	et
   2aa80:	002ab2c1 	jmpi	2ab2c <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2aa8c:	0030e03a 	nextpc	et
   2aa90:	002ab2c1 	jmpi	2ab2c <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2aa9c:	0030e03a 	nextpc	et
   2aaa0:	002ab2c1 	jmpi	2ab2c <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2aaac:	0030e03a 	nextpc	et
   2aab0:	002ab2c1 	jmpi	2ab2c <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2aabc:	0030e03a 	nextpc	et
   2aac0:	002ab2c1 	jmpi	2ab2c <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2aacc:	0030e03a 	nextpc	et
   2aad0:	002ab2c1 	jmpi	2ab2c <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2aadc:	0030e03a 	nextpc	et
   2aae0:	002ab2c1 	jmpi	2ab2c <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2aaec:	0030e03a 	nextpc	et
   2aaf0:	002ab2c1 	jmpi	2ab2c <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2aafc:	0030e03a 	nextpc	et
   2ab00:	002ab2c1 	jmpi	2ab2c <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2ab0c:	0030e03a 	nextpc	et
   2ab10:	002ab2c1 	jmpi	2ab2c <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2ab1c:	0030e03a 	nextpc	et
   2ab20:	002ab2c1 	jmpi	2ab2c <alt_shadow_non_preemptive_interrupt>
	...

0002ab2c <alt_shadow_non_preemptive_interrupt>:
    .section ALTERA_VIC_DRIVER_LINKER_SECTION
    .set nobreak
    .globl alt_shadow_non_preemptive_interrupt
alt_shadow_non_preemptive_interrupt:

    ldw r16, 4(et)               /* load ISR pointer */
   2ab2c:	c4000117 	ldw	r16,4(et)

     /*
      * Get SP from previous register set.
      */

    rdprs sp, sp, 0
   2ab30:	dec00038 	rdprs	sp,sp,0
  /*
   * Notify the operating system that we are at interrupt level.
   */
    ALT_OS_INT_ENTER_ASM

    ldw r4, 8(et)               /* load isr_context */
   2ab34:	c1000217 	ldw	r4,8(et)
    callr r16                   /* call ISR */
   2ab38:	803ee83a 	callr	r16
    /*
     * Notify the operating system that interrupt processing is complete.
     */
    ALT_OS_INT_EXIT_ASM

    addi ea, ea, -4             /* instruction that caused exception */
   2ab3c:	ef7fff04 	addi	ea,ea,-4
    eret
   2ab40:	ef80083a 	eret

0002ab44 <alt_vic_irq_init>:
  * @API Type:              Internal
  * @param pdev             pointer of type alt_vic_dev, main Device Structure.
  * @return                 None
  */
void alt_vic_irq_init (alt_vic_dev* pdev)
{
   2ab44:	defffd04 	addi	sp,sp,-12
   2ab48:	df000215 	stw	fp,8(sp)
   2ab4c:	df000204 	addi	fp,sp,8
   2ab50:	e13fff15 	stw	r4,-4(fp)
    alt_u32 i;
    static const int VEC_SIZE_ARRAY[]={4, 8, 16, 32, 64, 128, 256, 512};

    /* Stores the VIC instance to list */
    alt_vic_dev_list[pdev->intr_controller_id] = pdev;
   2ab54:	e0bfff17 	ldw	r2,-4(fp)
   2ab58:	10800117 	ldw	r2,4(r2)
   2ab5c:	1085883a 	add	r2,r2,r2
   2ab60:	1087883a 	add	r3,r2,r2
   2ab64:	d0a8f804 	addi	r2,gp,-23584
   2ab68:	1885883a 	add	r2,r3,r2
   2ab6c:	e0ffff17 	ldw	r3,-4(fp)
   2ab70:	10c00015 	stw	r3,0(r2)

    /* Disables all interrupts */
    IOWR_ALTERA_VIC_INT_ENABLE_CLR(pdev->base, 0xFFFFFFFF);
   2ab74:	e0bfff17 	ldw	r2,-4(fp)
   2ab78:	10800017 	ldw	r2,0(r2)
   2ab7c:	10802204 	addi	r2,r2,136
   2ab80:	00ffffc4 	movi	r3,-1
   2ab84:	10c00035 	stwio	r3,0(r2)

    /* Initialize INT_CONFIG for all interrupts in this VIC */
    for(i = 0; i < pdev->num_of_intr_ports; i++)
   2ab88:	e03ffe15 	stw	zero,-8(fp)
   2ab8c:	00001106 	br	2abd4 <alt_vic_irq_init+0x90>
    {
        IOWR_ALTERA_VIC_INT_CONFIG(pdev->base, i, pdev->int_config[i]);
   2ab90:	e0bfff17 	ldw	r2,-4(fp)
   2ab94:	10c00017 	ldw	r3,0(r2)
   2ab98:	e0bffe17 	ldw	r2,-8(fp)
   2ab9c:	1085883a 	add	r2,r2,r2
   2aba0:	1085883a 	add	r2,r2,r2
   2aba4:	1887883a 	add	r3,r3,r2
   2aba8:	e13fff17 	ldw	r4,-4(fp)
   2abac:	e0bffe17 	ldw	r2,-8(fp)
   2abb0:	108001c4 	addi	r2,r2,7
   2abb4:	1085883a 	add	r2,r2,r2
   2abb8:	1085883a 	add	r2,r2,r2
   2abbc:	2085883a 	add	r2,r4,r2
   2abc0:	10800017 	ldw	r2,0(r2)
   2abc4:	18800035 	stwio	r2,0(r3)

    /* Disables all interrupts */
    IOWR_ALTERA_VIC_INT_ENABLE_CLR(pdev->base, 0xFFFFFFFF);

    /* Initialize INT_CONFIG for all interrupts in this VIC */
    for(i = 0; i < pdev->num_of_intr_ports; i++)
   2abc8:	e0bffe17 	ldw	r2,-8(fp)
   2abcc:	10800044 	addi	r2,r2,1
   2abd0:	e0bffe15 	stw	r2,-8(fp)
   2abd4:	e0bfff17 	ldw	r2,-4(fp)
   2abd8:	10800217 	ldw	r2,8(r2)
   2abdc:	e0fffe17 	ldw	r3,-8(fp)
   2abe0:	18bfeb36 	bltu	r3,r2,2ab90 <alt_vic_irq_init+0x4c>
    {
        IOWR_ALTERA_VIC_INT_CONFIG(pdev->base, i, pdev->int_config[i]);
    }

    /* Set vector size and disable/enable daisy-chained input */
    for(i = 0; i < sizeof(VEC_SIZE_ARRAY)/sizeof(VEC_SIZE_ARRAY[0]); i++)
   2abe4:	e03ffe15 	stw	zero,-8(fp)
   2abe8:	00001806 	br	2ac4c <alt_vic_irq_init+0x108>
    {
        if(VEC_SIZE_ARRAY[i] == pdev->vec_size)
   2abec:	00c000f4 	movhi	r3,3
   2abf0:	18c3ed04 	addi	r3,r3,4020
   2abf4:	e0bffe17 	ldw	r2,-8(fp)
   2abf8:	1085883a 	add	r2,r2,r2
   2abfc:	1085883a 	add	r2,r2,r2
   2ac00:	1885883a 	add	r2,r3,r2
   2ac04:	10800017 	ldw	r2,0(r2)
   2ac08:	1007883a 	mov	r3,r2
   2ac0c:	e0bfff17 	ldw	r2,-4(fp)
   2ac10:	10800517 	ldw	r2,20(r2)
   2ac14:	18800a1e 	bne	r3,r2,2ac40 <alt_vic_irq_init+0xfc>
        {
            IOWR_ALTERA_VIC_CONFIG(pdev->base,
   2ac18:	e0bfff17 	ldw	r2,-4(fp)
   2ac1c:	10800017 	ldw	r2,0(r2)
   2ac20:	10802804 	addi	r2,r2,160
   2ac24:	e0ffff17 	ldw	r3,-4(fp)
   2ac28:	18c00417 	ldw	r3,16(r3)
   2ac2c:	180890fa 	slli	r4,r3,3
   2ac30:	e0fffe17 	ldw	r3,-8(fp)
   2ac34:	20c6b03a 	or	r3,r4,r3
   2ac38:	10c00035 	stwio	r3,0(r2)
                (i | (pdev->daisy_chain_present << ALTERA_VIC_CONFIG_DC_OFST)));
            break;
   2ac3c:	00000606 	br	2ac58 <alt_vic_irq_init+0x114>
    {
        IOWR_ALTERA_VIC_INT_CONFIG(pdev->base, i, pdev->int_config[i]);
    }

    /* Set vector size and disable/enable daisy-chained input */
    for(i = 0; i < sizeof(VEC_SIZE_ARRAY)/sizeof(VEC_SIZE_ARRAY[0]); i++)
   2ac40:	e0bffe17 	ldw	r2,-8(fp)
   2ac44:	10800044 	addi	r2,r2,1
   2ac48:	e0bffe15 	stw	r2,-8(fp)
   2ac4c:	e0bffe17 	ldw	r2,-8(fp)
   2ac50:	10800230 	cmpltui	r2,r2,8
   2ac54:	103fe51e 	bne	r2,zero,2abec <alt_vic_irq_init+0xa8>
            break;
        }
    }

    /* Set vector table base address */
    IOWR_ALTERA_VIC_VEC_TBL_BASE(pdev->base,((alt_u32)pdev->vec_addr));
   2ac58:	e0bfff17 	ldw	r2,-4(fp)
   2ac5c:	10800017 	ldw	r2,0(r2)
   2ac60:	10802a04 	addi	r2,r2,168
   2ac64:	e0ffff17 	ldw	r3,-4(fp)
   2ac68:	18c00617 	ldw	r3,24(r3)
   2ac6c:	10c00035 	stwio	r3,0(r2)
}
   2ac70:	e037883a 	mov	sp,fp
   2ac74:	df000017 	ldw	fp,0(sp)
   2ac78:	dec00104 	addi	sp,sp,4
   2ac7c:	f800283a 	ret

0002ac80 <alt_ic_isr_register>:
int alt_ic_isr_register(alt_u32 ic_id,
                        alt_u32 irq,
                        alt_isr_func isr,
                        void *isr_context,
                        void* flags)
{
   2ac80:	defff504 	addi	sp,sp,-44
   2ac84:	df000a15 	stw	fp,40(sp)
   2ac88:	df000a04 	addi	fp,sp,40
   2ac8c:	e13ffc15 	stw	r4,-16(fp)
   2ac90:	e17ffd15 	stw	r5,-12(fp)
   2ac94:	e1bffe15 	stw	r6,-8(fp)
   2ac98:	e1ffff15 	stw	r7,-4(fp)
    alt_vic_dev *pdev;
    alt_u32 *offset;
    alt_irq_context status;

    if(ic_id >= ALT_NUM_EXTERNAL_INTERRUPT_CONTROLLERS)
   2ac9c:	e0bffc17 	ldw	r2,-16(fp)
   2aca0:	10000226 	beq	r2,zero,2acac <alt_ic_isr_register+0x2c>
        return -1;
   2aca4:	00bfffc4 	movi	r2,-1
   2aca8:	00004706 	br	2adc8 <alt_ic_isr_register+0x148>

    /* Get VIC handle */
    pdev = alt_vic_dev_list[ic_id];
   2acac:	00c000f4 	movhi	r3,3
   2acb0:	18d61804 	addi	r3,r3,22624
   2acb4:	e0bffc17 	ldw	r2,-16(fp)
   2acb8:	1085883a 	add	r2,r2,r2
   2acbc:	1085883a 	add	r2,r2,r2
   2acc0:	1885883a 	add	r2,r3,r2
   2acc4:	10800017 	ldw	r2,0(r2)
   2acc8:	e0bff615 	stw	r2,-40(fp)

    if(irq < pdev->num_of_intr_ports)
   2accc:	e0bff617 	ldw	r2,-40(fp)
   2acd0:	10800217 	ldw	r2,8(r2)
   2acd4:	e0fffd17 	ldw	r3,-12(fp)
   2acd8:	18803a2e 	bgeu	r3,r2,2adc4 <alt_ic_isr_register+0x144>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   2acdc:	0005303a 	rdctl	r2,status
   2ace0:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   2ace4:	e0fff917 	ldw	r3,-28(fp)
   2ace8:	00bfff84 	movi	r2,-2
   2acec:	1884703a 	and	r2,r3,r2
   2acf0:	1001703a 	wrctl	status,r2
  
  return context;
   2acf4:	e0bff917 	ldw	r2,-28(fp)
    {
        /* Disable all interrupts */
        status = alt_irq_disable_all ();
   2acf8:	e0bff715 	stw	r2,-36(fp)

        /* Get table offset */
        offset = pdev->vec_addr + (irq * pdev->vec_size);
   2acfc:	e0bff617 	ldw	r2,-40(fp)
   2ad00:	10c00617 	ldw	r3,24(r2)
   2ad04:	e0bff617 	ldw	r2,-40(fp)
   2ad08:	11000517 	ldw	r4,20(r2)
   2ad0c:	e0bffd17 	ldw	r2,-12(fp)
   2ad10:	2085383a 	mul	r2,r4,r2
   2ad14:	1885883a 	add	r2,r3,r2
   2ad18:	e0bff815 	stw	r2,-32(fp)

        /* Write ISR and ISR context to vector table */
        ALT_VECTOR_TABLE_WRITE(offset+2, isr);
   2ad1c:	e0bff817 	ldw	r2,-32(fp)
   2ad20:	10800204 	addi	r2,r2,8
   2ad24:	e0fffe17 	ldw	r3,-8(fp)
   2ad28:	10c00015 	stw	r3,0(r2)
        ALT_VECTOR_TABLE_WRITE(offset+3, isr_context);
   2ad2c:	e0bff817 	ldw	r2,-32(fp)
   2ad30:	10800304 	addi	r2,r2,12
   2ad34:	e0ffff17 	ldw	r3,-4(fp)
   2ad38:	10c00015 	stw	r3,0(r2)

        if(isr)
   2ad3c:	e0bffe17 	ldw	r2,-8(fp)
   2ad40:	10000826 	beq	r2,zero,2ad64 <alt_ic_isr_register+0xe4>
        {
            /* Enable this IRQ on the VIC */
            IOWR_ALTERA_VIC_INT_ENABLE_SET(pdev->base, 1 << irq);
   2ad44:	e0bff617 	ldw	r2,-40(fp)
   2ad48:	10800017 	ldw	r2,0(r2)
   2ad4c:	10802104 	addi	r2,r2,132
   2ad50:	e0fffd17 	ldw	r3,-12(fp)
   2ad54:	01000044 	movi	r4,1
   2ad58:	20c6983a 	sll	r3,r4,r3
   2ad5c:	10c00035 	stwio	r3,0(r2)
   2ad60:	00000706 	br	2ad80 <alt_ic_isr_register+0x100>
        }
        else
        {
            /* Disable this IRQ on the VIC */
            IOWR_ALTERA_VIC_INT_ENABLE_CLR(pdev->base, 1 << irq);
   2ad64:	e0bff617 	ldw	r2,-40(fp)
   2ad68:	10800017 	ldw	r2,0(r2)
   2ad6c:	10802204 	addi	r2,r2,136
   2ad70:	e0fffd17 	ldw	r3,-12(fp)
   2ad74:	01000044 	movi	r4,1
   2ad78:	20c6983a 	sll	r3,r4,r3
   2ad7c:	10c00035 	stwio	r3,0(r2)
   2ad80:	e0bff717 	ldw	r2,-36(fp)
   2ad84:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   2ad88:	0005303a 	rdctl	r2,status
   2ad8c:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   2ad90:	e0fffb17 	ldw	r3,-20(fp)
   2ad94:	00bfff84 	movi	r2,-2
   2ad98:	1884703a 	and	r2,r3,r2
   2ad9c:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   2ada0:	e0bffa17 	ldw	r2,-24(fp)
   2ada4:	1080004c 	andi	r2,r2,1
   2ada8:	e0fffb17 	ldw	r3,-20(fp)
   2adac:	1884b03a 	or	r2,r3,r2
   2adb0:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
   2adb4:	e0bffb17 	ldw	r2,-20(fp)
   2adb8:	1001703a 	wrctl	status,r2
        }

        /* Re-enable all interrupts */
        alt_irq_enable_all(status);

        return 0;
   2adbc:	0005883a 	mov	r2,zero
   2adc0:	00000106 	br	2adc8 <alt_ic_isr_register+0x148>
    }

    return -1;
   2adc4:	00bfffc4 	movi	r2,-1
}
   2adc8:	e037883a 	mov	sp,fp
   2adcc:	df000017 	ldw	fp,0(sp)
   2add0:	dec00104 	addi	sp,sp,4
   2add4:	f800283a 	ret

0002add8 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
   2add8:	defffb04 	addi	sp,sp,-20
   2addc:	df000415 	stw	fp,16(sp)
   2ade0:	df000404 	addi	fp,sp,16
   2ade4:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
   2ade8:	008000c4 	movi	r2,3
   2adec:	e0bffd15 	stw	r2,-12(fp)
  }
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));
   2adf0:	e0fffd17 	ldw	r3,-12(fp)
   2adf4:	008003f4 	movhi	r2,15
   2adf8:	10909004 	addi	r2,r2,16960
   2adfc:	1885383a 	mul	r2,r3,r2
   2ae00:	00c17db4 	movhi	r3,1526
   2ae04:	18f84004 	addi	r3,r3,-7936
   2ae08:	1885203a 	divu	r2,r3,r2
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
   2ae0c:	00e00034 	movhi	r3,32768
   2ae10:	18ffffc4 	addi	r3,r3,-1
   2ae14:	1885203a 	divu	r2,r3,r2
   2ae18:	e0ffff17 	ldw	r3,-4(fp)
   2ae1c:	1885203a 	divu	r2,r3,r2
   2ae20:	e0bffe15 	stw	r2,-8(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
   2ae24:	e0bffe17 	ldw	r2,-8(fp)
   2ae28:	10002526 	beq	r2,zero,2aec0 <alt_busy_sleep+0xe8>
  {
    for(i=0;i<big_loops;i++)
   2ae2c:	e03ffc15 	stw	zero,-16(fp)
   2ae30:	00001406 	br	2ae84 <alt_busy_sleep+0xac>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
   2ae34:	00a00034 	movhi	r2,32768
   2ae38:	10bfffc4 	addi	r2,r2,-1
   2ae3c:	10bfffc4 	addi	r2,r2,-1
   2ae40:	103ffe1e 	bne	r2,zero,2ae3c <alt_busy_sleep+0x64>
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
      (cycles_per_loop * 1000000)));
   2ae44:	e0fffd17 	ldw	r3,-12(fp)
   2ae48:	008003f4 	movhi	r2,15
   2ae4c:	10909004 	addi	r2,r2,16960
   2ae50:	1885383a 	mul	r2,r3,r2
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
   2ae54:	00c17db4 	movhi	r3,1526
   2ae58:	18f84004 	addi	r3,r3,-7936
   2ae5c:	1885203a 	divu	r2,r3,r2
   2ae60:	00e00034 	movhi	r3,32768
   2ae64:	18ffffc4 	addi	r3,r3,-1
   2ae68:	1885203a 	divu	r2,r3,r2
   2ae6c:	e0ffff17 	ldw	r3,-4(fp)
   2ae70:	1885c83a 	sub	r2,r3,r2
   2ae74:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
   2ae78:	e0bffc17 	ldw	r2,-16(fp)
   2ae7c:	10800044 	addi	r2,r2,1
   2ae80:	e0bffc15 	stw	r2,-16(fp)
   2ae84:	e0fffc17 	ldw	r3,-16(fp)
   2ae88:	e0bffe17 	ldw	r2,-8(fp)
   2ae8c:	18bfe916 	blt	r3,r2,2ae34 <alt_busy_sleep+0x5c>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
   2ae90:	e0fffd17 	ldw	r3,-12(fp)
   2ae94:	008003f4 	movhi	r2,15
   2ae98:	10909004 	addi	r2,r2,16960
   2ae9c:	1885383a 	mul	r2,r3,r2
   2aea0:	00c17db4 	movhi	r3,1526
   2aea4:	18f84004 	addi	r3,r3,-7936
   2aea8:	1887203a 	divu	r3,r3,r2
   2aeac:	e0bfff17 	ldw	r2,-4(fp)
   2aeb0:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
   2aeb4:	10bfffc4 	addi	r2,r2,-1
   2aeb8:	103ffe1e 	bne	r2,zero,2aeb4 <alt_busy_sleep+0xdc>
   2aebc:	00000b06 	br	2aeec <alt_busy_sleep+0x114>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
   2aec0:	e0fffd17 	ldw	r3,-12(fp)
   2aec4:	008003f4 	movhi	r2,15
   2aec8:	10909004 	addi	r2,r2,16960
   2aecc:	1885383a 	mul	r2,r3,r2
   2aed0:	00c17db4 	movhi	r3,1526
   2aed4:	18f84004 	addi	r3,r3,-7936
   2aed8:	1887203a 	divu	r3,r3,r2
   2aedc:	e0bfff17 	ldw	r2,-4(fp)
   2aee0:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
   2aee4:	10bfffc4 	addi	r2,r2,-1
   2aee8:	00bffe16 	blt	zero,r2,2aee4 <alt_busy_sleep+0x10c>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
   2aeec:	0005883a 	mov	r2,zero
}
   2aef0:	e037883a 	mov	sp,fp
   2aef4:	df000017 	ldw	fp,0(sp)
   2aef8:	dec00104 	addi	sp,sp,4
   2aefc:	f800283a 	ret

0002af00 <alt_dcache_flush>:
 *
 * Any dirty lines in the data cache are written back to memory.
 */

void alt_dcache_flush (void* start, alt_u32 len)
{
   2af00:	defffd04 	addi	sp,sp,-12
   2af04:	df000215 	stw	fp,8(sp)
   2af08:	df000204 	addi	fp,sp,8
   2af0c:	e13ffe15 	stw	r4,-8(fp)
   2af10:	e17fff15 	stw	r5,-4(fp)
  {
    ALT_FLUSH_DATA(i);
  }

#endif /* NIOS2_DCACHE_SIZE > 0 */
}
   2af14:	e037883a 	mov	sp,fp
   2af18:	df000017 	ldw	fp,0(sp)
   2af1c:	dec00104 	addi	sp,sp,4
   2af20:	f800283a 	ret

0002af24 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
   2af24:	deffff04 	addi	sp,sp,-4
   2af28:	df000015 	stw	fp,0(sp)
   2af2c:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
   2af30:	e037883a 	mov	sp,fp
   2af34:	df000017 	ldw	fp,0(sp)
   2af38:	dec00104 	addi	sp,sp,4
   2af3c:	f800283a 	ret

0002af40 <alt_get_errno>:
   2af40:	defffe04 	addi	sp,sp,-8
   2af44:	dfc00115 	stw	ra,4(sp)
   2af48:	df000015 	stw	fp,0(sp)
   2af4c:	d839883a 	mov	fp,sp
   2af50:	008000f4 	movhi	r2,3
   2af54:	108d3404 	addi	r2,r2,13520
   2af58:	10800017 	ldw	r2,0(r2)
   2af5c:	10000526 	beq	r2,zero,2af74 <alt_get_errno+0x34>
   2af60:	008000f4 	movhi	r2,3
   2af64:	108d3404 	addi	r2,r2,13520
   2af68:	10800017 	ldw	r2,0(r2)
   2af6c:	103ee83a 	callr	r2
   2af70:	00000206 	br	2af7c <alt_get_errno+0x3c>
   2af74:	008000f4 	movhi	r2,3
   2af78:	10961104 	addi	r2,r2,22596
   2af7c:	e037883a 	mov	sp,fp
   2af80:	dfc00117 	ldw	ra,4(sp)
   2af84:	df000017 	ldw	fp,0(sp)
   2af88:	dec00204 	addi	sp,sp,8
   2af8c:	f800283a 	ret

0002af90 <alt_dev_llist_insert>:
   2af90:	defffa04 	addi	sp,sp,-24
   2af94:	dfc00515 	stw	ra,20(sp)
   2af98:	df000415 	stw	fp,16(sp)
   2af9c:	df000404 	addi	fp,sp,16
   2afa0:	e13ffe15 	stw	r4,-8(fp)
   2afa4:	e17fff15 	stw	r5,-4(fp)
   2afa8:	e0bffe17 	ldw	r2,-8(fp)
   2afac:	10000326 	beq	r2,zero,2afbc <alt_dev_llist_insert+0x2c>
   2afb0:	e0bffe17 	ldw	r2,-8(fp)
   2afb4:	10800217 	ldw	r2,8(r2)
   2afb8:	1000051e 	bne	r2,zero,2afd0 <alt_dev_llist_insert+0x40>
   2afbc:	002af400 	call	2af40 <alt_get_errno>
   2afc0:	00c00584 	movi	r3,22
   2afc4:	10c00015 	stw	r3,0(r2)
   2afc8:	00bffa84 	movi	r2,-22
   2afcc:	00001306 	br	2b01c <alt_dev_llist_insert+0x8c>
   2afd0:	e0bffe17 	ldw	r2,-8(fp)
   2afd4:	e0ffff17 	ldw	r3,-4(fp)
   2afd8:	e0fffc15 	stw	r3,-16(fp)
   2afdc:	e0bffd15 	stw	r2,-12(fp)
   2afe0:	e0bffd17 	ldw	r2,-12(fp)
   2afe4:	e0fffc17 	ldw	r3,-16(fp)
   2afe8:	10c00115 	stw	r3,4(r2)
   2afec:	e0bffc17 	ldw	r2,-16(fp)
   2aff0:	10c00017 	ldw	r3,0(r2)
   2aff4:	e0bffd17 	ldw	r2,-12(fp)
   2aff8:	10c00015 	stw	r3,0(r2)
   2affc:	e0bffc17 	ldw	r2,-16(fp)
   2b000:	10800017 	ldw	r2,0(r2)
   2b004:	e0fffd17 	ldw	r3,-12(fp)
   2b008:	10c00115 	stw	r3,4(r2)
   2b00c:	e0bffc17 	ldw	r2,-16(fp)
   2b010:	e0fffd17 	ldw	r3,-12(fp)
   2b014:	10c00015 	stw	r3,0(r2)
   2b018:	0005883a 	mov	r2,zero
   2b01c:	e037883a 	mov	sp,fp
   2b020:	dfc00117 	ldw	ra,4(sp)
   2b024:	df000017 	ldw	fp,0(sp)
   2b028:	dec00204 	addi	sp,sp,8
   2b02c:	f800283a 	ret

0002b030 <_do_ctors>:
   2b030:	defffd04 	addi	sp,sp,-12
   2b034:	dfc00215 	stw	ra,8(sp)
   2b038:	df000115 	stw	fp,4(sp)
   2b03c:	df000104 	addi	fp,sp,4
   2b040:	008000f4 	movhi	r2,3
   2b044:	10b16004 	addi	r2,r2,-14976
   2b048:	e0bfff15 	stw	r2,-4(fp)
   2b04c:	00000606 	br	2b068 <_do_ctors+0x38>
   2b050:	e0bfff17 	ldw	r2,-4(fp)
   2b054:	10800017 	ldw	r2,0(r2)
   2b058:	103ee83a 	callr	r2
   2b05c:	e0bfff17 	ldw	r2,-4(fp)
   2b060:	10bfff04 	addi	r2,r2,-4
   2b064:	e0bfff15 	stw	r2,-4(fp)
   2b068:	e0ffff17 	ldw	r3,-4(fp)
   2b06c:	008000f4 	movhi	r2,3
   2b070:	10b16104 	addi	r2,r2,-14972
   2b074:	18bff62e 	bgeu	r3,r2,2b050 <_do_ctors+0x20>
   2b078:	e037883a 	mov	sp,fp
   2b07c:	dfc00117 	ldw	ra,4(sp)
   2b080:	df000017 	ldw	fp,0(sp)
   2b084:	dec00204 	addi	sp,sp,8
   2b088:	f800283a 	ret

0002b08c <_do_dtors>:
   2b08c:	defffd04 	addi	sp,sp,-12
   2b090:	dfc00215 	stw	ra,8(sp)
   2b094:	df000115 	stw	fp,4(sp)
   2b098:	df000104 	addi	fp,sp,4
   2b09c:	008000f4 	movhi	r2,3
   2b0a0:	10b16004 	addi	r2,r2,-14976
   2b0a4:	e0bfff15 	stw	r2,-4(fp)
   2b0a8:	00000606 	br	2b0c4 <_do_dtors+0x38>
   2b0ac:	e0bfff17 	ldw	r2,-4(fp)
   2b0b0:	10800017 	ldw	r2,0(r2)
   2b0b4:	103ee83a 	callr	r2
   2b0b8:	e0bfff17 	ldw	r2,-4(fp)
   2b0bc:	10bfff04 	addi	r2,r2,-4
   2b0c0:	e0bfff15 	stw	r2,-4(fp)
   2b0c4:	e0ffff17 	ldw	r3,-4(fp)
   2b0c8:	008000f4 	movhi	r2,3
   2b0cc:	10b16104 	addi	r2,r2,-14972
   2b0d0:	18bff62e 	bgeu	r3,r2,2b0ac <_do_dtors+0x20>
   2b0d4:	e037883a 	mov	sp,fp
   2b0d8:	dfc00117 	ldw	ra,4(sp)
   2b0dc:	df000017 	ldw	fp,0(sp)
   2b0e0:	dec00204 	addi	sp,sp,8
   2b0e4:	f800283a 	ret

0002b0e8 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
   2b0e8:	defffa04 	addi	sp,sp,-24
   2b0ec:	dfc00515 	stw	ra,20(sp)
   2b0f0:	df000415 	stw	fp,16(sp)
   2b0f4:	df000404 	addi	fp,sp,16
   2b0f8:	e13ffe15 	stw	r4,-8(fp)
   2b0fc:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
   2b100:	e0bfff17 	ldw	r2,-4(fp)
   2b104:	10800017 	ldw	r2,0(r2)
   2b108:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
   2b10c:	e13ffe17 	ldw	r4,-8(fp)
   2b110:	0016a080 	call	16a08 <strlen>
   2b114:	10800044 	addi	r2,r2,1
   2b118:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
   2b11c:	00000d06 	br	2b154 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
   2b120:	e0bffc17 	ldw	r2,-16(fp)
   2b124:	10c00217 	ldw	r3,8(r2)
   2b128:	e0bffd17 	ldw	r2,-12(fp)
   2b12c:	1809883a 	mov	r4,r3
   2b130:	e17ffe17 	ldw	r5,-8(fp)
   2b134:	100d883a 	mov	r6,r2
   2b138:	002c1680 	call	2c168 <memcmp>
   2b13c:	1000021e 	bne	r2,zero,2b148 <alt_find_dev+0x60>
    {
      /* match found */

      return next;
   2b140:	e0bffc17 	ldw	r2,-16(fp)
   2b144:	00000706 	br	2b164 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
   2b148:	e0bffc17 	ldw	r2,-16(fp)
   2b14c:	10800017 	ldw	r2,0(r2)
   2b150:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
   2b154:	e0fffc17 	ldw	r3,-16(fp)
   2b158:	e0bfff17 	ldw	r2,-4(fp)
   2b15c:	18bff01e 	bne	r3,r2,2b120 <alt_find_dev+0x38>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
   2b160:	0005883a 	mov	r2,zero
}
   2b164:	e037883a 	mov	sp,fp
   2b168:	dfc00117 	ldw	ra,4(sp)
   2b16c:	df000017 	ldw	fp,0(sp)
   2b170:	dec00204 	addi	sp,sp,8
   2b174:	f800283a 	ret

0002b178 <alt_flash_open_dev>:
#include "priv/alt_file.h"

ALT_LLIST_HEAD(alt_flash_dev_list);

alt_flash_fd* alt_flash_open_dev(const char* name)
{
   2b178:	defffc04 	addi	sp,sp,-16
   2b17c:	dfc00315 	stw	ra,12(sp)
   2b180:	df000215 	stw	fp,8(sp)
   2b184:	df000204 	addi	fp,sp,8
   2b188:	e13fff15 	stw	r4,-4(fp)
  alt_flash_dev* dev = (alt_flash_dev*)alt_find_dev(name, &alt_flash_dev_list);
   2b18c:	e13fff17 	ldw	r4,-4(fp)
   2b190:	d1601c04 	addi	r5,gp,-32656
   2b194:	002b0e80 	call	2b0e8 <alt_find_dev>
   2b198:	e0bffe15 	stw	r2,-8(fp)

  if ((dev) && dev->open)
   2b19c:	e0bffe17 	ldw	r2,-8(fp)
   2b1a0:	10000926 	beq	r2,zero,2b1c8 <alt_flash_open_dev+0x50>
   2b1a4:	e0bffe17 	ldw	r2,-8(fp)
   2b1a8:	10800317 	ldw	r2,12(r2)
   2b1ac:	10000626 	beq	r2,zero,2b1c8 <alt_flash_open_dev+0x50>
  {
    return dev->open(dev, name);
   2b1b0:	e0bffe17 	ldw	r2,-8(fp)
   2b1b4:	10800317 	ldw	r2,12(r2)
   2b1b8:	e13ffe17 	ldw	r4,-8(fp)
   2b1bc:	e17fff17 	ldw	r5,-4(fp)
   2b1c0:	103ee83a 	callr	r2
   2b1c4:	00000106 	br	2b1cc <alt_flash_open_dev+0x54>
  }

  return dev;
   2b1c8:	e0bffe17 	ldw	r2,-8(fp)
}
   2b1cc:	e037883a 	mov	sp,fp
   2b1d0:	dfc00117 	ldw	ra,4(sp)
   2b1d4:	df000017 	ldw	fp,0(sp)
   2b1d8:	dec00204 	addi	sp,sp,8
   2b1dc:	f800283a 	ret

0002b1e0 <alt_flash_close_dev>:

void alt_flash_close_dev(alt_flash_fd* fd)
{
   2b1e0:	defffd04 	addi	sp,sp,-12
   2b1e4:	dfc00215 	stw	ra,8(sp)
   2b1e8:	df000115 	stw	fp,4(sp)
   2b1ec:	df000104 	addi	fp,sp,4
   2b1f0:	e13fff15 	stw	r4,-4(fp)
  if (fd && fd->close)
   2b1f4:	e0bfff17 	ldw	r2,-4(fp)
   2b1f8:	10000726 	beq	r2,zero,2b218 <alt_flash_close_dev+0x38>
   2b1fc:	e0bfff17 	ldw	r2,-4(fp)
   2b200:	10800417 	ldw	r2,16(r2)
   2b204:	10000426 	beq	r2,zero,2b218 <alt_flash_close_dev+0x38>
  {
    fd->close(fd);
   2b208:	e0bfff17 	ldw	r2,-4(fp)
   2b20c:	10800417 	ldw	r2,16(r2)
   2b210:	e13fff17 	ldw	r4,-4(fp)
   2b214:	103ee83a 	callr	r2
  }
  return;
   2b218:	0001883a 	nop
}
   2b21c:	e037883a 	mov	sp,fp
   2b220:	dfc00117 	ldw	ra,4(sp)
   2b224:	df000017 	ldw	fp,0(sp)
   2b228:	dec00204 	addi	sp,sp,8
   2b22c:	f800283a 	ret

0002b230 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
   2b230:	defffe04 	addi	sp,sp,-8
   2b234:	dfc00115 	stw	ra,4(sp)
   2b238:	df000015 	stw	fp,0(sp)
   2b23c:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
   2b240:	0009883a 	mov	r4,zero
   2b244:	01440004 	movi	r5,4096
   2b248:	002c0680 	call	2c068 <alt_icache_flush>
#endif
}
   2b24c:	e037883a 	mov	sp,fp
   2b250:	dfc00117 	ldw	ra,4(sp)
   2b254:	df000017 	ldw	fp,0(sp)
   2b258:	dec00204 	addi	sp,sp,8
   2b25c:	f800283a 	ret

0002b260 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
   2b260:	defff904 	addi	sp,sp,-28
   2b264:	dfc00615 	stw	ra,24(sp)
   2b268:	df000515 	stw	fp,20(sp)
   2b26c:	df000504 	addi	fp,sp,20
   2b270:	e13ffc15 	stw	r4,-16(fp)
   2b274:	e17ffd15 	stw	r5,-12(fp)
   2b278:	e1bffe15 	stw	r6,-8(fp)
   2b27c:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
   2b280:	e13ffd17 	ldw	r4,-12(fp)
   2b284:	e17ffe17 	ldw	r5,-8(fp)
   2b288:	e1bfff17 	ldw	r6,-4(fp)
   2b28c:	002b4b40 	call	2b4b4 <open>
   2b290:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
   2b294:	e0bffb17 	ldw	r2,-20(fp)
   2b298:	10001c16 	blt	r2,zero,2b30c <alt_open_fd+0xac>
  {
    fd->dev      = alt_fd_list[old].dev;
   2b29c:	00c000f4 	movhi	r3,3
   2b2a0:	18c6c804 	addi	r3,r3,6944
   2b2a4:	e0bffb17 	ldw	r2,-20(fp)
   2b2a8:	10800324 	muli	r2,r2,12
   2b2ac:	1885883a 	add	r2,r3,r2
   2b2b0:	10c00017 	ldw	r3,0(r2)
   2b2b4:	e0bffc17 	ldw	r2,-16(fp)
   2b2b8:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
   2b2bc:	00c000f4 	movhi	r3,3
   2b2c0:	18c6c804 	addi	r3,r3,6944
   2b2c4:	e0bffb17 	ldw	r2,-20(fp)
   2b2c8:	10800324 	muli	r2,r2,12
   2b2cc:	1885883a 	add	r2,r3,r2
   2b2d0:	10800104 	addi	r2,r2,4
   2b2d4:	10c00017 	ldw	r3,0(r2)
   2b2d8:	e0bffc17 	ldw	r2,-16(fp)
   2b2dc:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
   2b2e0:	00c000f4 	movhi	r3,3
   2b2e4:	18c6c804 	addi	r3,r3,6944
   2b2e8:	e0bffb17 	ldw	r2,-20(fp)
   2b2ec:	10800324 	muli	r2,r2,12
   2b2f0:	1885883a 	add	r2,r3,r2
   2b2f4:	10800204 	addi	r2,r2,8
   2b2f8:	10c00017 	ldw	r3,0(r2)
   2b2fc:	e0bffc17 	ldw	r2,-16(fp)
   2b300:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
   2b304:	e13ffb17 	ldw	r4,-20(fp)
   2b308:	00204540 	call	20454 <alt_release_fd>
  }
} 
   2b30c:	e037883a 	mov	sp,fp
   2b310:	dfc00117 	ldw	ra,4(sp)
   2b314:	df000017 	ldw	fp,0(sp)
   2b318:	dec00204 	addi	sp,sp,8
   2b31c:	f800283a 	ret

0002b320 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
   2b320:	defffb04 	addi	sp,sp,-20
   2b324:	dfc00415 	stw	ra,16(sp)
   2b328:	df000315 	stw	fp,12(sp)
   2b32c:	df000304 	addi	fp,sp,12
   2b330:	e13ffd15 	stw	r4,-12(fp)
   2b334:	e17ffe15 	stw	r5,-8(fp)
   2b338:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
   2b33c:	010000f4 	movhi	r4,3
   2b340:	2106cb04 	addi	r4,r4,6956
   2b344:	e17ffd17 	ldw	r5,-12(fp)
   2b348:	01800044 	movi	r6,1
   2b34c:	01c07fc4 	movi	r7,511
   2b350:	002b2600 	call	2b260 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
   2b354:	010000f4 	movhi	r4,3
   2b358:	2106c804 	addi	r4,r4,6944
   2b35c:	e17ffe17 	ldw	r5,-8(fp)
   2b360:	000d883a 	mov	r6,zero
   2b364:	01c07fc4 	movi	r7,511
   2b368:	002b2600 	call	2b260 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
   2b36c:	010000f4 	movhi	r4,3
   2b370:	2106ce04 	addi	r4,r4,6968
   2b374:	e17fff17 	ldw	r5,-4(fp)
   2b378:	01800044 	movi	r6,1
   2b37c:	01c07fc4 	movi	r7,511
   2b380:	002b2600 	call	2b260 <alt_open_fd>
}  
   2b384:	e037883a 	mov	sp,fp
   2b388:	dfc00117 	ldw	ra,4(sp)
   2b38c:	df000017 	ldw	fp,0(sp)
   2b390:	dec00204 	addi	sp,sp,8
   2b394:	f800283a 	ret

0002b398 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   2b398:	defffe04 	addi	sp,sp,-8
   2b39c:	dfc00115 	stw	ra,4(sp)
   2b3a0:	df000015 	stw	fp,0(sp)
   2b3a4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   2b3a8:	008000f4 	movhi	r2,3
   2b3ac:	108d3404 	addi	r2,r2,13520
   2b3b0:	10800017 	ldw	r2,0(r2)
   2b3b4:	10000526 	beq	r2,zero,2b3cc <alt_get_errno+0x34>
   2b3b8:	008000f4 	movhi	r2,3
   2b3bc:	108d3404 	addi	r2,r2,13520
   2b3c0:	10800017 	ldw	r2,0(r2)
   2b3c4:	103ee83a 	callr	r2
   2b3c8:	00000206 	br	2b3d4 <alt_get_errno+0x3c>
   2b3cc:	008000f4 	movhi	r2,3
   2b3d0:	10961104 	addi	r2,r2,22596
}
   2b3d4:	e037883a 	mov	sp,fp
   2b3d8:	dfc00117 	ldw	ra,4(sp)
   2b3dc:	df000017 	ldw	fp,0(sp)
   2b3e0:	dec00204 	addi	sp,sp,8
   2b3e4:	f800283a 	ret

0002b3e8 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
   2b3e8:	defffd04 	addi	sp,sp,-12
   2b3ec:	df000215 	stw	fp,8(sp)
   2b3f0:	df000204 	addi	fp,sp,8
   2b3f4:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
   2b3f8:	e0bfff17 	ldw	r2,-4(fp)
   2b3fc:	10800217 	ldw	r2,8(r2)
   2b400:	10d00034 	orhi	r3,r2,16384
   2b404:	e0bfff17 	ldw	r2,-4(fp)
   2b408:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
   2b40c:	e03ffe15 	stw	zero,-8(fp)
   2b410:	00001d06 	br	2b488 <alt_file_locked+0xa0>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
   2b414:	00c000f4 	movhi	r3,3
   2b418:	18c6c804 	addi	r3,r3,6944
   2b41c:	e0bffe17 	ldw	r2,-8(fp)
   2b420:	10800324 	muli	r2,r2,12
   2b424:	1885883a 	add	r2,r3,r2
   2b428:	10c00017 	ldw	r3,0(r2)
   2b42c:	e0bfff17 	ldw	r2,-4(fp)
   2b430:	10800017 	ldw	r2,0(r2)
   2b434:	1880111e 	bne	r3,r2,2b47c <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
   2b438:	00c000f4 	movhi	r3,3
   2b43c:	18c6c804 	addi	r3,r3,6944
   2b440:	e0bffe17 	ldw	r2,-8(fp)
   2b444:	10800324 	muli	r2,r2,12
   2b448:	1885883a 	add	r2,r3,r2
   2b44c:	10800204 	addi	r2,r2,8
   2b450:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
   2b454:	1000090e 	bge	r2,zero,2b47c <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
   2b458:	e0bffe17 	ldw	r2,-8(fp)
   2b45c:	10c00324 	muli	r3,r2,12
   2b460:	008000f4 	movhi	r2,3
   2b464:	1086c804 	addi	r2,r2,6944
   2b468:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
   2b46c:	e0bfff17 	ldw	r2,-4(fp)
   2b470:	18800226 	beq	r3,r2,2b47c <alt_file_locked+0x94>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
   2b474:	00bffcc4 	movi	r2,-13
   2b478:	00000a06 	br	2b4a4 <alt_file_locked+0xbc>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
   2b47c:	e0bffe17 	ldw	r2,-8(fp)
   2b480:	10800044 	addi	r2,r2,1
   2b484:	e0bffe15 	stw	r2,-8(fp)
   2b488:	008000f4 	movhi	r2,3
   2b48c:	108d3304 	addi	r2,r2,13516
   2b490:	10800017 	ldw	r2,0(r2)
   2b494:	1007883a 	mov	r3,r2
   2b498:	e0bffe17 	ldw	r2,-8(fp)
   2b49c:	18bfdd2e 	bgeu	r3,r2,2b414 <alt_file_locked+0x2c>
    }
  }
  
  /* The device is not locked */
 
  return 0;
   2b4a0:	0005883a 	mov	r2,zero
}
   2b4a4:	e037883a 	mov	sp,fp
   2b4a8:	df000017 	ldw	fp,0(sp)
   2b4ac:	dec00104 	addi	sp,sp,4
   2b4b0:	f800283a 	ret

0002b4b4 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
   2b4b4:	defff604 	addi	sp,sp,-40
   2b4b8:	dfc00915 	stw	ra,36(sp)
   2b4bc:	df000815 	stw	fp,32(sp)
   2b4c0:	df000804 	addi	fp,sp,32
   2b4c4:	e13ffd15 	stw	r4,-12(fp)
   2b4c8:	e17ffe15 	stw	r5,-8(fp)
   2b4cc:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
   2b4d0:	00bfffc4 	movi	r2,-1
   2b4d4:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
   2b4d8:	00bffb44 	movi	r2,-19
   2b4dc:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
   2b4e0:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
   2b4e4:	e13ffd17 	ldw	r4,-12(fp)
   2b4e8:	014000f4 	movhi	r5,3
   2b4ec:	294d3104 	addi	r5,r5,13508
   2b4f0:	002b0e80 	call	2b0e8 <alt_find_dev>
   2b4f4:	e0bff815 	stw	r2,-32(fp)
   2b4f8:	e0bff817 	ldw	r2,-32(fp)
   2b4fc:	1000051e 	bne	r2,zero,2b514 <open+0x60>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
   2b500:	e13ffd17 	ldw	r4,-12(fp)
   2b504:	002bea00 	call	2bea0 <alt_find_file>
   2b508:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
   2b50c:	00800044 	movi	r2,1
   2b510:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
   2b514:	e0bff817 	ldw	r2,-32(fp)
   2b518:	10002926 	beq	r2,zero,2b5c0 <open+0x10c>
  {
    if ((index = alt_get_fd (dev)) < 0)
   2b51c:	e13ff817 	ldw	r4,-32(fp)
   2b520:	002bfb40 	call	2bfb4 <alt_get_fd>
   2b524:	e0bff915 	stw	r2,-28(fp)
   2b528:	e0bff917 	ldw	r2,-28(fp)
   2b52c:	1000030e 	bge	r2,zero,2b53c <open+0x88>
    {
      status = index;
   2b530:	e0bff917 	ldw	r2,-28(fp)
   2b534:	e0bffa15 	stw	r2,-24(fp)
   2b538:	00002306 	br	2b5c8 <open+0x114>
    }
    else
    {
      fd = &alt_fd_list[index];
   2b53c:	e0bff917 	ldw	r2,-28(fp)
   2b540:	10c00324 	muli	r3,r2,12
   2b544:	008000f4 	movhi	r2,3
   2b548:	1086c804 	addi	r2,r2,6944
   2b54c:	1885883a 	add	r2,r3,r2
   2b550:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
   2b554:	e0fffe17 	ldw	r3,-8(fp)
   2b558:	00900034 	movhi	r2,16384
   2b55c:	10bfffc4 	addi	r2,r2,-1
   2b560:	1886703a 	and	r3,r3,r2
   2b564:	e0bffc17 	ldw	r2,-16(fp)
   2b568:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
   2b56c:	e0bffb17 	ldw	r2,-20(fp)
   2b570:	1000051e 	bne	r2,zero,2b588 <open+0xd4>
   2b574:	e13ffc17 	ldw	r4,-16(fp)
   2b578:	002b3e80 	call	2b3e8 <alt_file_locked>
   2b57c:	e0bffa15 	stw	r2,-24(fp)
   2b580:	e0bffa17 	ldw	r2,-24(fp)
   2b584:	10001016 	blt	r2,zero,2b5c8 <open+0x114>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
   2b588:	e0bff817 	ldw	r2,-32(fp)
   2b58c:	10800317 	ldw	r2,12(r2)
   2b590:	10000826 	beq	r2,zero,2b5b4 <open+0x100>
   2b594:	e0bff817 	ldw	r2,-32(fp)
   2b598:	10800317 	ldw	r2,12(r2)
   2b59c:	e13ffc17 	ldw	r4,-16(fp)
   2b5a0:	e17ffd17 	ldw	r5,-12(fp)
   2b5a4:	e1bffe17 	ldw	r6,-8(fp)
   2b5a8:	e1ffff17 	ldw	r7,-4(fp)
   2b5ac:	103ee83a 	callr	r2
   2b5b0:	00000106 	br	2b5b8 <open+0x104>
   2b5b4:	0005883a 	mov	r2,zero
   2b5b8:	e0bffa15 	stw	r2,-24(fp)
   2b5bc:	00000206 	br	2b5c8 <open+0x114>
      }
    }
  }
  else
  {
    status = -ENODEV;
   2b5c0:	00bffb44 	movi	r2,-19
   2b5c4:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
   2b5c8:	e0bffa17 	ldw	r2,-24(fp)
   2b5cc:	1000080e 	bge	r2,zero,2b5f0 <open+0x13c>
  {
    alt_release_fd (index);  
   2b5d0:	e13ff917 	ldw	r4,-28(fp)
   2b5d4:	00204540 	call	20454 <alt_release_fd>
    ALT_ERRNO = -status;
   2b5d8:	002b3980 	call	2b398 <alt_get_errno>
   2b5dc:	e0fffa17 	ldw	r3,-24(fp)
   2b5e0:	00c7c83a 	sub	r3,zero,r3
   2b5e4:	10c00015 	stw	r3,0(r2)
    return -1;
   2b5e8:	00bfffc4 	movi	r2,-1
   2b5ec:	00000106 	br	2b5f4 <open+0x140>
  }
  
  /* return the reference upon success */

  return index;
   2b5f0:	e0bff917 	ldw	r2,-28(fp)
}
   2b5f4:	e037883a 	mov	sp,fp
   2b5f8:	dfc00117 	ldw	ra,4(sp)
   2b5fc:	df000017 	ldw	fp,0(sp)
   2b600:	dec00204 	addi	sp,sp,8
   2b604:	f800283a 	ret

0002b608 <alt_program_amd>:
   2b608:	defff704 	addi	sp,sp,-36
   2b60c:	dfc00815 	stw	ra,32(sp)
   2b610:	df000715 	stw	fp,28(sp)
   2b614:	df000704 	addi	fp,sp,28
   2b618:	e13ffc15 	stw	r4,-16(fp)
   2b61c:	e17ffd15 	stw	r5,-12(fp)
   2b620:	e1bffe15 	stw	r6,-8(fp)
   2b624:	e1ffff15 	stw	r7,-4(fp)
   2b628:	e03ffa15 	stw	zero,-24(fp)
   2b62c:	e0bffc17 	ldw	r2,-16(fp)
   2b630:	e0bffb15 	stw	r2,-20(fp)
   2b634:	008000f4 	movhi	r2,3
   2b638:	10ae6704 	addi	r2,r2,-18020
   2b63c:	d8800015 	stw	r2,0(sp)
   2b640:	e13ffb17 	ldw	r4,-20(fp)
   2b644:	e17ffe17 	ldw	r5,-8(fp)
   2b648:	e1bfff17 	ldw	r6,-4(fp)
   2b64c:	e1c00217 	ldw	r7,8(fp)
   2b650:	00210cc0 	call	210cc <alt_flash_program_block>
   2b654:	e0bffa15 	stw	r2,-24(fp)
   2b658:	e0bffa17 	ldw	r2,-24(fp)
   2b65c:	e037883a 	mov	sp,fp
   2b660:	dfc00117 	ldw	ra,4(sp)
   2b664:	df000017 	ldw	fp,0(sp)
   2b668:	dec00204 	addi	sp,sp,8
   2b66c:	f800283a 	ret

0002b670 <alt_erase_block_amd>:
   2b670:	defff804 	addi	sp,sp,-32
   2b674:	dfc00715 	stw	ra,28(sp)
   2b678:	df000615 	stw	fp,24(sp)
   2b67c:	df000604 	addi	fp,sp,24
   2b680:	e13ffe15 	stw	r4,-8(fp)
   2b684:	e17fff15 	stw	r5,-4(fp)
   2b688:	e03ffa15 	stw	zero,-24(fp)
   2b68c:	e0bffe17 	ldw	r2,-8(fp)
   2b690:	e0bffc15 	stw	r2,-16(fp)
   2b694:	e0bffc17 	ldw	r2,-16(fp)
   2b698:	10c03317 	ldw	r3,204(r2)
   2b69c:	e0bffc17 	ldw	r2,-16(fp)
   2b6a0:	10800a17 	ldw	r2,40(r2)
   2b6a4:	1009883a 	mov	r4,r2
   2b6a8:	01415544 	movi	r5,1365
   2b6ac:	01802a84 	movi	r6,170
   2b6b0:	183ee83a 	callr	r3
   2b6b4:	e0bffc17 	ldw	r2,-16(fp)
   2b6b8:	10c03317 	ldw	r3,204(r2)
   2b6bc:	e0bffc17 	ldw	r2,-16(fp)
   2b6c0:	10800a17 	ldw	r2,40(r2)
   2b6c4:	1009883a 	mov	r4,r2
   2b6c8:	0140aa84 	movi	r5,682
   2b6cc:	01801544 	movi	r6,85
   2b6d0:	183ee83a 	callr	r3
   2b6d4:	e0bffc17 	ldw	r2,-16(fp)
   2b6d8:	10c03317 	ldw	r3,204(r2)
   2b6dc:	e0bffc17 	ldw	r2,-16(fp)
   2b6e0:	10800a17 	ldw	r2,40(r2)
   2b6e4:	1009883a 	mov	r4,r2
   2b6e8:	01415544 	movi	r5,1365
   2b6ec:	01802004 	movi	r6,128
   2b6f0:	183ee83a 	callr	r3
   2b6f4:	e0bffc17 	ldw	r2,-16(fp)
   2b6f8:	10c03317 	ldw	r3,204(r2)
   2b6fc:	e0bffc17 	ldw	r2,-16(fp)
   2b700:	10800a17 	ldw	r2,40(r2)
   2b704:	1009883a 	mov	r4,r2
   2b708:	01415544 	movi	r5,1365
   2b70c:	01802a84 	movi	r6,170
   2b710:	183ee83a 	callr	r3
   2b714:	e0bffc17 	ldw	r2,-16(fp)
   2b718:	10c03317 	ldw	r3,204(r2)
   2b71c:	e0bffc17 	ldw	r2,-16(fp)
   2b720:	10800a17 	ldw	r2,40(r2)
   2b724:	1009883a 	mov	r4,r2
   2b728:	0140aa84 	movi	r5,682
   2b72c:	01801544 	movi	r6,85
   2b730:	183ee83a 	callr	r3
   2b734:	e0bffc17 	ldw	r2,-16(fp)
   2b738:	10c03517 	ldw	r3,212(r2)
   2b73c:	e0bffc17 	ldw	r2,-16(fp)
   2b740:	11000a17 	ldw	r4,40(r2)
   2b744:	e0bfff17 	ldw	r2,-4(fp)
   2b748:	2085883a 	add	r2,r4,r2
   2b74c:	1009883a 	mov	r4,r2
   2b750:	01400c04 	movi	r5,48
   2b754:	183ee83a 	callr	r3
   2b758:	0109c404 	movi	r4,10000
   2b75c:	002081c0 	call	2081c <usleep>
   2b760:	00800c84 	movi	r2,50
   2b764:	e0bffb15 	stw	r2,-20(fp)
   2b768:	e0bffc17 	ldw	r2,-16(fp)
   2b76c:	10c00a17 	ldw	r3,40(r2)
   2b770:	e0bfff17 	ldw	r2,-4(fp)
   2b774:	1885883a 	add	r2,r3,r2
   2b778:	10800023 	ldbuio	r2,0(r2)
   2b77c:	10803fcc 	andi	r2,r2,255
   2b780:	e0bffd05 	stb	r2,-12(fp)
   2b784:	0100fa04 	movi	r4,1000
   2b788:	002081c0 	call	2081c <usleep>
   2b78c:	e0bffb17 	ldw	r2,-20(fp)
   2b790:	10bfffc4 	addi	r2,r2,-1
   2b794:	e0bffb15 	stw	r2,-20(fp)
   2b798:	e0bffd03 	ldbu	r2,-12(fp)
   2b79c:	10803fcc 	andi	r2,r2,255
   2b7a0:	1080020c 	andi	r2,r2,8
   2b7a4:	1000021e 	bne	r2,zero,2b7b0 <alt_erase_block_amd+0x140>
   2b7a8:	e0bffb17 	ldw	r2,-20(fp)
   2b7ac:	00bfee16 	blt	zero,r2,2b768 <alt_erase_block_amd+0xf8>
   2b7b0:	e0bffc17 	ldw	r2,-16(fp)
   2b7b4:	10803117 	ldw	r2,196(r2)
   2b7b8:	e0bffb15 	stw	r2,-20(fp)
   2b7bc:	00001506 	br	2b814 <alt_erase_block_amd+0x1a4>
   2b7c0:	e0bffc17 	ldw	r2,-16(fp)
   2b7c4:	10c00a17 	ldw	r3,40(r2)
   2b7c8:	e0bfff17 	ldw	r2,-4(fp)
   2b7cc:	1885883a 	add	r2,r3,r2
   2b7d0:	10800023 	ldbuio	r2,0(r2)
   2b7d4:	10803fcc 	andi	r2,r2,255
   2b7d8:	e0bffd05 	stb	r2,-12(fp)
   2b7dc:	e0bffd03 	ldbu	r2,-12(fp)
   2b7e0:	10803fcc 	andi	r2,r2,255
   2b7e4:	1080201c 	xori	r2,r2,128
   2b7e8:	10bfe004 	addi	r2,r2,-128
   2b7ec:	10000b16 	blt	r2,zero,2b81c <alt_erase_block_amd+0x1ac>
   2b7f0:	e0bffd03 	ldbu	r2,-12(fp)
   2b7f4:	10803fcc 	andi	r2,r2,255
   2b7f8:	1080080c 	andi	r2,r2,32
   2b7fc:	1000071e 	bne	r2,zero,2b81c <alt_erase_block_amd+0x1ac>
   2b800:	0100fa04 	movi	r4,1000
   2b804:	002081c0 	call	2081c <usleep>
   2b808:	e0bffb17 	ldw	r2,-20(fp)
   2b80c:	10bf0604 	addi	r2,r2,-1000
   2b810:	e0bffb15 	stw	r2,-20(fp)
   2b814:	e0bffb17 	ldw	r2,-20(fp)
   2b818:	00bfe916 	blt	zero,r2,2b7c0 <alt_erase_block_amd+0x150>
   2b81c:	e0bffb17 	ldw	r2,-20(fp)
   2b820:	00800316 	blt	zero,r2,2b830 <alt_erase_block_amd+0x1c0>
   2b824:	00bfe304 	movi	r2,-116
   2b828:	e0bffa15 	stw	r2,-24(fp)
   2b82c:	00000e06 	br	2b868 <alt_erase_block_amd+0x1f8>
   2b830:	e0bffc17 	ldw	r2,-16(fp)
   2b834:	10c00a17 	ldw	r3,40(r2)
   2b838:	e0bfff17 	ldw	r2,-4(fp)
   2b83c:	1885883a 	add	r2,r3,r2
   2b840:	10800023 	ldbuio	r2,0(r2)
   2b844:	10803fcc 	andi	r2,r2,255
   2b848:	e0bffd05 	stb	r2,-12(fp)
   2b84c:	e0bffd03 	ldbu	r2,-12(fp)
   2b850:	10803fcc 	andi	r2,r2,255
   2b854:	1080201c 	xori	r2,r2,128
   2b858:	10bfe004 	addi	r2,r2,-128
   2b85c:	10000216 	blt	r2,zero,2b868 <alt_erase_block_amd+0x1f8>
   2b860:	00bffec4 	movi	r2,-5
   2b864:	e0bffa15 	stw	r2,-24(fp)
   2b868:	e0bffa17 	ldw	r2,-24(fp)
   2b86c:	e037883a 	mov	sp,fp
   2b870:	dfc00117 	ldw	ra,4(sp)
   2b874:	df000017 	ldw	fp,0(sp)
   2b878:	dec00204 	addi	sp,sp,8
   2b87c:	f800283a 	ret

0002b880 <alt_wait_for_command_to_complete_amd>:
   2b880:	defff804 	addi	sp,sp,-32
   2b884:	dfc00715 	stw	ra,28(sp)
   2b888:	df000615 	stw	fp,24(sp)
   2b88c:	df000604 	addi	fp,sp,24
   2b890:	e13ffd15 	stw	r4,-12(fp)
   2b894:	e17ffe15 	stw	r5,-8(fp)
   2b898:	3005883a 	mov	r2,r6
   2b89c:	e0bfff05 	stb	r2,-4(fp)
   2b8a0:	e0bffd17 	ldw	r2,-12(fp)
   2b8a4:	10803017 	ldw	r2,192(r2)
   2b8a8:	10801924 	muli	r2,r2,100
   2b8ac:	e0bffa15 	stw	r2,-24(fp)
   2b8b0:	e03ffb15 	stw	zero,-20(fp)
   2b8b4:	e0bffd17 	ldw	r2,-12(fp)
   2b8b8:	10c00a17 	ldw	r3,40(r2)
   2b8bc:	e0bffe17 	ldw	r2,-8(fp)
   2b8c0:	1885883a 	add	r2,r3,r2
   2b8c4:	10800023 	ldbuio	r2,0(r2)
   2b8c8:	10803fcc 	andi	r2,r2,255
   2b8cc:	e0bffc05 	stb	r2,-16(fp)
   2b8d0:	00001606 	br	2b92c <alt_wait_for_command_to_complete_amd+0xac>
   2b8d4:	e0bffc03 	ldbu	r2,-16(fp)
   2b8d8:	10c03fcc 	andi	r3,r2,255
   2b8dc:	e0bfff03 	ldbu	r2,-4(fp)
   2b8e0:	1884f03a 	xor	r2,r3,r2
   2b8e4:	1080200c 	andi	r2,r2,128
   2b8e8:	10001226 	beq	r2,zero,2b934 <alt_wait_for_command_to_complete_amd+0xb4>
   2b8ec:	e0bffc03 	ldbu	r2,-16(fp)
   2b8f0:	10803fcc 	andi	r2,r2,255
   2b8f4:	1080080c 	andi	r2,r2,32
   2b8f8:	10000e1e 	bne	r2,zero,2b934 <alt_wait_for_command_to_complete_amd+0xb4>
   2b8fc:	01000044 	movi	r4,1
   2b900:	002081c0 	call	2081c <usleep>
   2b904:	e0bffa17 	ldw	r2,-24(fp)
   2b908:	10bfffc4 	addi	r2,r2,-1
   2b90c:	e0bffa15 	stw	r2,-24(fp)
   2b910:	e0bffd17 	ldw	r2,-12(fp)
   2b914:	10c00a17 	ldw	r3,40(r2)
   2b918:	e0bffe17 	ldw	r2,-8(fp)
   2b91c:	1885883a 	add	r2,r3,r2
   2b920:	10800023 	ldbuio	r2,0(r2)
   2b924:	10803fcc 	andi	r2,r2,255
   2b928:	e0bffc05 	stb	r2,-16(fp)
   2b92c:	e0bffa17 	ldw	r2,-24(fp)
   2b930:	00bfe816 	blt	zero,r2,2b8d4 <alt_wait_for_command_to_complete_amd+0x54>
   2b934:	e0bffa17 	ldw	r2,-24(fp)
   2b938:	1000031e 	bne	r2,zero,2b948 <alt_wait_for_command_to_complete_amd+0xc8>
   2b93c:	00bfe304 	movi	r2,-116
   2b940:	e0bffb15 	stw	r2,-20(fp)
   2b944:	00000f06 	br	2b984 <alt_wait_for_command_to_complete_amd+0x104>
   2b948:	e0bffd17 	ldw	r2,-12(fp)
   2b94c:	10c00a17 	ldw	r3,40(r2)
   2b950:	e0bffe17 	ldw	r2,-8(fp)
   2b954:	1885883a 	add	r2,r3,r2
   2b958:	10800023 	ldbuio	r2,0(r2)
   2b95c:	10803fcc 	andi	r2,r2,255
   2b960:	e0bffc05 	stb	r2,-16(fp)
   2b964:	e0bffc03 	ldbu	r2,-16(fp)
   2b968:	10c03fcc 	andi	r3,r2,255
   2b96c:	e0bfff03 	ldbu	r2,-4(fp)
   2b970:	1884f03a 	xor	r2,r3,r2
   2b974:	1080200c 	andi	r2,r2,128
   2b978:	10000226 	beq	r2,zero,2b984 <alt_wait_for_command_to_complete_amd+0x104>
   2b97c:	00bffec4 	movi	r2,-5
   2b980:	e0bffb15 	stw	r2,-20(fp)
   2b984:	e0bffb17 	ldw	r2,-20(fp)
   2b988:	e037883a 	mov	sp,fp
   2b98c:	dfc00117 	ldw	ra,4(sp)
   2b990:	df000017 	ldw	fp,0(sp)
   2b994:	dec00204 	addi	sp,sp,8
   2b998:	f800283a 	ret

0002b99c <alt_write_word_amd>:
   2b99c:	defff904 	addi	sp,sp,-28
   2b9a0:	dfc00615 	stw	ra,24(sp)
   2b9a4:	df000515 	stw	fp,20(sp)
   2b9a8:	df000504 	addi	fp,sp,20
   2b9ac:	e13ffd15 	stw	r4,-12(fp)
   2b9b0:	e17ffe15 	stw	r5,-8(fp)
   2b9b4:	e1bfff15 	stw	r6,-4(fp)
   2b9b8:	e03ffb15 	stw	zero,-20(fp)
   2b9bc:	e0bffd17 	ldw	r2,-12(fp)
   2b9c0:	10c03317 	ldw	r3,204(r2)
   2b9c4:	e0bffd17 	ldw	r2,-12(fp)
   2b9c8:	10800a17 	ldw	r2,40(r2)
   2b9cc:	1009883a 	mov	r4,r2
   2b9d0:	01415544 	movi	r5,1365
   2b9d4:	01802a84 	movi	r6,170
   2b9d8:	183ee83a 	callr	r3
   2b9dc:	e0bffd17 	ldw	r2,-12(fp)
   2b9e0:	10c03317 	ldw	r3,204(r2)
   2b9e4:	e0bffd17 	ldw	r2,-12(fp)
   2b9e8:	10800a17 	ldw	r2,40(r2)
   2b9ec:	1009883a 	mov	r4,r2
   2b9f0:	0140aa84 	movi	r5,682
   2b9f4:	01801544 	movi	r6,85
   2b9f8:	183ee83a 	callr	r3
   2b9fc:	e0bffd17 	ldw	r2,-12(fp)
   2ba00:	10c03317 	ldw	r3,204(r2)
   2ba04:	e0bffd17 	ldw	r2,-12(fp)
   2ba08:	10800a17 	ldw	r2,40(r2)
   2ba0c:	1009883a 	mov	r4,r2
   2ba10:	01415544 	movi	r5,1365
   2ba14:	01802804 	movi	r6,160
   2ba18:	183ee83a 	callr	r3
   2ba1c:	e0bfff17 	ldw	r2,-4(fp)
   2ba20:	10800003 	ldbu	r2,0(r2)
   2ba24:	e0bffc05 	stb	r2,-16(fp)
   2ba28:	e13ffd17 	ldw	r4,-12(fp)
   2ba2c:	e17ffe17 	ldw	r5,-8(fp)
   2ba30:	e1bfff17 	ldw	r6,-4(fp)
   2ba34:	0020f740 	call	20f74 <alt_write_value_to_flash>
   2ba38:	e0bffc03 	ldbu	r2,-16(fp)
   2ba3c:	e13ffd17 	ldw	r4,-12(fp)
   2ba40:	e17ffe17 	ldw	r5,-8(fp)
   2ba44:	100d883a 	mov	r6,r2
   2ba48:	002b8800 	call	2b880 <alt_wait_for_command_to_complete_amd>
   2ba4c:	e0bffb15 	stw	r2,-20(fp)
   2ba50:	e0bffb17 	ldw	r2,-20(fp)
   2ba54:	e037883a 	mov	sp,fp
   2ba58:	dfc00117 	ldw	ra,4(sp)
   2ba5c:	df000017 	ldw	fp,0(sp)
   2ba60:	dec00204 	addi	sp,sp,8
   2ba64:	f800283a 	ret

0002ba68 <alt_program_intel>:
   2ba68:	defff704 	addi	sp,sp,-36
   2ba6c:	dfc00815 	stw	ra,32(sp)
   2ba70:	df000715 	stw	fp,28(sp)
   2ba74:	df000704 	addi	fp,sp,28
   2ba78:	e13ffc15 	stw	r4,-16(fp)
   2ba7c:	e17ffd15 	stw	r5,-12(fp)
   2ba80:	e1bffe15 	stw	r6,-8(fp)
   2ba84:	e1ffff15 	stw	r7,-4(fp)
   2ba88:	e03ffa15 	stw	zero,-24(fp)
   2ba8c:	e0bffc17 	ldw	r2,-16(fp)
   2ba90:	e0bffb15 	stw	r2,-20(fp)
   2ba94:	e13ffb17 	ldw	r4,-20(fp)
   2ba98:	e17ffd17 	ldw	r5,-12(fp)
   2ba9c:	002bc500 	call	2bc50 <alt_unlock_block_intel>
   2baa0:	e0bffa15 	stw	r2,-24(fp)
   2baa4:	e0bffa17 	ldw	r2,-24(fp)
   2baa8:	1000091e 	bne	r2,zero,2bad0 <alt_program_intel+0x68>
   2baac:	008000f4 	movhi	r2,3
   2bab0:	10af7304 	addi	r2,r2,-16948
   2bab4:	d8800015 	stw	r2,0(sp)
   2bab8:	e13ffb17 	ldw	r4,-20(fp)
   2babc:	e17ffe17 	ldw	r5,-8(fp)
   2bac0:	e1bfff17 	ldw	r6,-4(fp)
   2bac4:	e1c00217 	ldw	r7,8(fp)
   2bac8:	00210cc0 	call	210cc <alt_flash_program_block>
   2bacc:	e0bffa15 	stw	r2,-24(fp)
   2bad0:	e0bffa17 	ldw	r2,-24(fp)
   2bad4:	e037883a 	mov	sp,fp
   2bad8:	dfc00117 	ldw	ra,4(sp)
   2badc:	df000017 	ldw	fp,0(sp)
   2bae0:	dec00204 	addi	sp,sp,8
   2bae4:	f800283a 	ret

0002bae8 <alt_erase_block_intel>:
   2bae8:	defff804 	addi	sp,sp,-32
   2baec:	dfc00715 	stw	ra,28(sp)
   2baf0:	df000615 	stw	fp,24(sp)
   2baf4:	df000604 	addi	fp,sp,24
   2baf8:	e13ffe15 	stw	r4,-8(fp)
   2bafc:	e17fff15 	stw	r5,-4(fp)
   2bb00:	e03ffa15 	stw	zero,-24(fp)
   2bb04:	e0bffe17 	ldw	r2,-8(fp)
   2bb08:	e0bffc15 	stw	r2,-16(fp)
   2bb0c:	e0bffc17 	ldw	r2,-16(fp)
   2bb10:	10803117 	ldw	r2,196(r2)
   2bb14:	e0bffb15 	stw	r2,-20(fp)
   2bb18:	e13ffc17 	ldw	r4,-16(fp)
   2bb1c:	e17fff17 	ldw	r5,-4(fp)
   2bb20:	002bc500 	call	2bc50 <alt_unlock_block_intel>
   2bb24:	e0bffa15 	stw	r2,-24(fp)
   2bb28:	e0bffa17 	ldw	r2,-24(fp)
   2bb2c:	1000421e 	bne	r2,zero,2bc38 <alt_erase_block_intel+0x150>
   2bb30:	e0bffc17 	ldw	r2,-16(fp)
   2bb34:	10c03517 	ldw	r3,212(r2)
   2bb38:	e0bffc17 	ldw	r2,-16(fp)
   2bb3c:	11000a17 	ldw	r4,40(r2)
   2bb40:	e0bfff17 	ldw	r2,-4(fp)
   2bb44:	2085883a 	add	r2,r4,r2
   2bb48:	1009883a 	mov	r4,r2
   2bb4c:	01400804 	movi	r5,32
   2bb50:	183ee83a 	callr	r3
   2bb54:	e0bffc17 	ldw	r2,-16(fp)
   2bb58:	10c03517 	ldw	r3,212(r2)
   2bb5c:	e0bffc17 	ldw	r2,-16(fp)
   2bb60:	11000a17 	ldw	r4,40(r2)
   2bb64:	e0bfff17 	ldw	r2,-4(fp)
   2bb68:	2085883a 	add	r2,r4,r2
   2bb6c:	1009883a 	mov	r4,r2
   2bb70:	01403404 	movi	r5,208
   2bb74:	183ee83a 	callr	r3
   2bb78:	e0bffc17 	ldw	r2,-16(fp)
   2bb7c:	10c00a17 	ldw	r3,40(r2)
   2bb80:	e0bfff17 	ldw	r2,-4(fp)
   2bb84:	1885883a 	add	r2,r3,r2
   2bb88:	10800023 	ldbuio	r2,0(r2)
   2bb8c:	10803fcc 	andi	r2,r2,255
   2bb90:	e0bffd05 	stb	r2,-12(fp)
   2bb94:	e0bffd03 	ldbu	r2,-12(fp)
   2bb98:	10803fcc 	andi	r2,r2,255
   2bb9c:	1080201c 	xori	r2,r2,128
   2bba0:	10bfe004 	addi	r2,r2,-128
   2bba4:	10000816 	blt	r2,zero,2bbc8 <alt_erase_block_intel+0xe0>
   2bba8:	0100fa04 	movi	r4,1000
   2bbac:	002081c0 	call	2081c <usleep>
   2bbb0:	e0bffb17 	ldw	r2,-20(fp)
   2bbb4:	10bf0604 	addi	r2,r2,-1000
   2bbb8:	e0bffb15 	stw	r2,-20(fp)
   2bbbc:	e0bffb17 	ldw	r2,-20(fp)
   2bbc0:	00bfed16 	blt	zero,r2,2bb78 <alt_erase_block_intel+0x90>
   2bbc4:	00000106 	br	2bbcc <alt_erase_block_intel+0xe4>
   2bbc8:	0001883a 	nop
   2bbcc:	e0bffb17 	ldw	r2,-20(fp)
   2bbd0:	00800316 	blt	zero,r2,2bbe0 <alt_erase_block_intel+0xf8>
   2bbd4:	00bfe304 	movi	r2,-116
   2bbd8:	e0bffa15 	stw	r2,-24(fp)
   2bbdc:	00000d06 	br	2bc14 <alt_erase_block_intel+0x12c>
   2bbe0:	e0bffd03 	ldbu	r2,-12(fp)
   2bbe4:	10803fcc 	andi	r2,r2,255
   2bbe8:	10801fcc 	andi	r2,r2,127
   2bbec:	10000926 	beq	r2,zero,2bc14 <alt_erase_block_intel+0x12c>
   2bbf0:	00bffec4 	movi	r2,-5
   2bbf4:	e0bffa15 	stw	r2,-24(fp)
   2bbf8:	e0bffc17 	ldw	r2,-16(fp)
   2bbfc:	10c00a17 	ldw	r3,40(r2)
   2bc00:	e0bfff17 	ldw	r2,-4(fp)
   2bc04:	1885883a 	add	r2,r3,r2
   2bc08:	10800023 	ldbuio	r2,0(r2)
   2bc0c:	10803fcc 	andi	r2,r2,255
   2bc10:	e0bffd05 	stb	r2,-12(fp)
   2bc14:	e0bffc17 	ldw	r2,-16(fp)
   2bc18:	10c03517 	ldw	r3,212(r2)
   2bc1c:	e0bffc17 	ldw	r2,-16(fp)
   2bc20:	11000a17 	ldw	r4,40(r2)
   2bc24:	e0bfff17 	ldw	r2,-4(fp)
   2bc28:	2085883a 	add	r2,r4,r2
   2bc2c:	1009883a 	mov	r4,r2
   2bc30:	01403fc4 	movi	r5,255
   2bc34:	183ee83a 	callr	r3
   2bc38:	e0bffa17 	ldw	r2,-24(fp)
   2bc3c:	e037883a 	mov	sp,fp
   2bc40:	dfc00117 	ldw	ra,4(sp)
   2bc44:	df000017 	ldw	fp,0(sp)
   2bc48:	dec00204 	addi	sp,sp,8
   2bc4c:	f800283a 	ret

0002bc50 <alt_unlock_block_intel>:
   2bc50:	defff904 	addi	sp,sp,-28
   2bc54:	dfc00615 	stw	ra,24(sp)
   2bc58:	df000515 	stw	fp,20(sp)
   2bc5c:	df000504 	addi	fp,sp,20
   2bc60:	e13ffe15 	stw	r4,-8(fp)
   2bc64:	e17fff15 	stw	r5,-4(fp)
   2bc68:	e03ffb15 	stw	zero,-20(fp)
   2bc6c:	e0bffe17 	ldw	r2,-8(fp)
   2bc70:	10803017 	ldw	r2,192(r2)
   2bc74:	10801924 	muli	r2,r2,100
   2bc78:	e0bffc15 	stw	r2,-16(fp)
   2bc7c:	e0bffe17 	ldw	r2,-8(fp)
   2bc80:	10c03517 	ldw	r3,212(r2)
   2bc84:	e0bffe17 	ldw	r2,-8(fp)
   2bc88:	11000a17 	ldw	r4,40(r2)
   2bc8c:	e0bfff17 	ldw	r2,-4(fp)
   2bc90:	2085883a 	add	r2,r4,r2
   2bc94:	1009883a 	mov	r4,r2
   2bc98:	01402404 	movi	r5,144
   2bc9c:	183ee83a 	callr	r3
   2bca0:	e0bffe17 	ldw	r2,-8(fp)
   2bca4:	10c00a17 	ldw	r3,40(r2)
   2bca8:	e0bfff17 	ldw	r2,-4(fp)
   2bcac:	10800104 	addi	r2,r2,4
   2bcb0:	1885883a 	add	r2,r3,r2
   2bcb4:	10800023 	ldbuio	r2,0(r2)
   2bcb8:	10803fcc 	andi	r2,r2,255
   2bcbc:	e0bffd05 	stb	r2,-12(fp)
   2bcc0:	e0bffd03 	ldbu	r2,-12(fp)
   2bcc4:	1080004c 	andi	r2,r2,1
   2bcc8:	10003126 	beq	r2,zero,2bd90 <alt_unlock_block_intel+0x140>
   2bccc:	e0bffe17 	ldw	r2,-8(fp)
   2bcd0:	10c03517 	ldw	r3,212(r2)
   2bcd4:	e0bffe17 	ldw	r2,-8(fp)
   2bcd8:	11000a17 	ldw	r4,40(r2)
   2bcdc:	e0bfff17 	ldw	r2,-4(fp)
   2bce0:	2085883a 	add	r2,r4,r2
   2bce4:	1009883a 	mov	r4,r2
   2bce8:	01401804 	movi	r5,96
   2bcec:	183ee83a 	callr	r3
   2bcf0:	e0bffe17 	ldw	r2,-8(fp)
   2bcf4:	10c03517 	ldw	r3,212(r2)
   2bcf8:	e0bffe17 	ldw	r2,-8(fp)
   2bcfc:	11000a17 	ldw	r4,40(r2)
   2bd00:	e0bfff17 	ldw	r2,-4(fp)
   2bd04:	2085883a 	add	r2,r4,r2
   2bd08:	1009883a 	mov	r4,r2
   2bd0c:	01403404 	movi	r5,208
   2bd10:	183ee83a 	callr	r3
   2bd14:	e0bffe17 	ldw	r2,-8(fp)
   2bd18:	10c00a17 	ldw	r3,40(r2)
   2bd1c:	e0bfff17 	ldw	r2,-4(fp)
   2bd20:	1885883a 	add	r2,r3,r2
   2bd24:	10800023 	ldbuio	r2,0(r2)
   2bd28:	10803fcc 	andi	r2,r2,255
   2bd2c:	e0bffd45 	stb	r2,-11(fp)
   2bd30:	e0bffd43 	ldbu	r2,-11(fp)
   2bd34:	10803fcc 	andi	r2,r2,255
   2bd38:	1080201c 	xori	r2,r2,128
   2bd3c:	10bfe004 	addi	r2,r2,-128
   2bd40:	10000816 	blt	r2,zero,2bd64 <alt_unlock_block_intel+0x114>
   2bd44:	e0bffc17 	ldw	r2,-16(fp)
   2bd48:	10bfffc4 	addi	r2,r2,-1
   2bd4c:	e0bffc15 	stw	r2,-16(fp)
   2bd50:	01000044 	movi	r4,1
   2bd54:	002081c0 	call	2081c <usleep>
   2bd58:	e0bffc17 	ldw	r2,-16(fp)
   2bd5c:	00bfed16 	blt	zero,r2,2bd14 <alt_unlock_block_intel+0xc4>
   2bd60:	00000106 	br	2bd68 <alt_unlock_block_intel+0x118>
   2bd64:	0001883a 	nop
   2bd68:	e0bffc17 	ldw	r2,-16(fp)
   2bd6c:	1000031e 	bne	r2,zero,2bd7c <alt_unlock_block_intel+0x12c>
   2bd70:	00bfe304 	movi	r2,-116
   2bd74:	e0bffb15 	stw	r2,-20(fp)
   2bd78:	00000506 	br	2bd90 <alt_unlock_block_intel+0x140>
   2bd7c:	e0bffd43 	ldbu	r2,-11(fp)
   2bd80:	10801fcc 	andi	r2,r2,127
   2bd84:	10000226 	beq	r2,zero,2bd90 <alt_unlock_block_intel+0x140>
   2bd88:	00bffec4 	movi	r2,-5
   2bd8c:	e0bffb15 	stw	r2,-20(fp)
   2bd90:	e0bffe17 	ldw	r2,-8(fp)
   2bd94:	10c03517 	ldw	r3,212(r2)
   2bd98:	e0bffe17 	ldw	r2,-8(fp)
   2bd9c:	11000a17 	ldw	r4,40(r2)
   2bda0:	e0bfff17 	ldw	r2,-4(fp)
   2bda4:	2085883a 	add	r2,r4,r2
   2bda8:	1009883a 	mov	r4,r2
   2bdac:	01403fc4 	movi	r5,255
   2bdb0:	183ee83a 	callr	r3
   2bdb4:	e0bffb17 	ldw	r2,-20(fp)
   2bdb8:	e037883a 	mov	sp,fp
   2bdbc:	dfc00117 	ldw	ra,4(sp)
   2bdc0:	df000017 	ldw	fp,0(sp)
   2bdc4:	dec00204 	addi	sp,sp,8
   2bdc8:	f800283a 	ret

0002bdcc <alt_write_word_intel>:
   2bdcc:	defff904 	addi	sp,sp,-28
   2bdd0:	dfc00615 	stw	ra,24(sp)
   2bdd4:	df000515 	stw	fp,20(sp)
   2bdd8:	df000504 	addi	fp,sp,20
   2bddc:	e13ffd15 	stw	r4,-12(fp)
   2bde0:	e17ffe15 	stw	r5,-8(fp)
   2bde4:	e1bfff15 	stw	r6,-4(fp)
   2bde8:	e03ffb15 	stw	zero,-20(fp)
   2bdec:	e0bffd17 	ldw	r2,-12(fp)
   2bdf0:	10c03517 	ldw	r3,212(r2)
   2bdf4:	e0bffd17 	ldw	r2,-12(fp)
   2bdf8:	11000a17 	ldw	r4,40(r2)
   2bdfc:	e0bffe17 	ldw	r2,-8(fp)
   2be00:	2085883a 	add	r2,r4,r2
   2be04:	1009883a 	mov	r4,r2
   2be08:	01401004 	movi	r5,64
   2be0c:	183ee83a 	callr	r3
   2be10:	e13ffd17 	ldw	r4,-12(fp)
   2be14:	e17ffe17 	ldw	r5,-8(fp)
   2be18:	e1bfff17 	ldw	r6,-4(fp)
   2be1c:	0020f740 	call	20f74 <alt_write_value_to_flash>
   2be20:	e0bffd17 	ldw	r2,-12(fp)
   2be24:	10c00a17 	ldw	r3,40(r2)
   2be28:	e0bffe17 	ldw	r2,-8(fp)
   2be2c:	1885883a 	add	r2,r3,r2
   2be30:	10800023 	ldbuio	r2,0(r2)
   2be34:	10803fcc 	andi	r2,r2,255
   2be38:	e0bffc05 	stb	r2,-16(fp)
   2be3c:	e0bffc03 	ldbu	r2,-16(fp)
   2be40:	10803fcc 	andi	r2,r2,255
   2be44:	1080201c 	xori	r2,r2,128
   2be48:	10bfe004 	addi	r2,r2,-128
   2be4c:	103ff40e 	bge	r2,zero,2be20 <alt_write_word_intel+0x54>
   2be50:	e0bffc03 	ldbu	r2,-16(fp)
   2be54:	10801fcc 	andi	r2,r2,127
   2be58:	10000226 	beq	r2,zero,2be64 <alt_write_word_intel+0x98>
   2be5c:	00bffec4 	movi	r2,-5
   2be60:	e0bffb15 	stw	r2,-20(fp)
   2be64:	e0bffd17 	ldw	r2,-12(fp)
   2be68:	10c03517 	ldw	r3,212(r2)
   2be6c:	e0bffd17 	ldw	r2,-12(fp)
   2be70:	11000a17 	ldw	r4,40(r2)
   2be74:	e0bffe17 	ldw	r2,-8(fp)
   2be78:	2085883a 	add	r2,r4,r2
   2be7c:	1009883a 	mov	r4,r2
   2be80:	01403fc4 	movi	r5,255
   2be84:	183ee83a 	callr	r3
   2be88:	e0bffb17 	ldw	r2,-20(fp)
   2be8c:	e037883a 	mov	sp,fp
   2be90:	dfc00117 	ldw	ra,4(sp)
   2be94:	df000017 	ldw	fp,0(sp)
   2be98:	dec00204 	addi	sp,sp,8
   2be9c:	f800283a 	ret

0002bea0 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
   2bea0:	defffb04 	addi	sp,sp,-20
   2bea4:	dfc00415 	stw	ra,16(sp)
   2bea8:	df000315 	stw	fp,12(sp)
   2beac:	df000304 	addi	fp,sp,12
   2beb0:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
   2beb4:	008000f4 	movhi	r2,3
   2beb8:	108d2f04 	addi	r2,r2,13500
   2bebc:	10800017 	ldw	r2,0(r2)
   2bec0:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
   2bec4:	00003106 	br	2bf8c <alt_find_file+0xec>
  {
    len = strlen(next->name);
   2bec8:	e0bffd17 	ldw	r2,-12(fp)
   2becc:	10800217 	ldw	r2,8(r2)
   2bed0:	1009883a 	mov	r4,r2
   2bed4:	0016a080 	call	16a08 <strlen>
   2bed8:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
   2bedc:	e0bffd17 	ldw	r2,-12(fp)
   2bee0:	10c00217 	ldw	r3,8(r2)
   2bee4:	e0bffe17 	ldw	r2,-8(fp)
   2bee8:	10bfffc4 	addi	r2,r2,-1
   2beec:	1885883a 	add	r2,r3,r2
   2bef0:	10800003 	ldbu	r2,0(r2)
   2bef4:	10803fcc 	andi	r2,r2,255
   2bef8:	1080201c 	xori	r2,r2,128
   2befc:	10bfe004 	addi	r2,r2,-128
   2bf00:	10800bd8 	cmpnei	r2,r2,47
   2bf04:	1000031e 	bne	r2,zero,2bf14 <alt_find_file+0x74>
    {
      len -= 1;
   2bf08:	e0bffe17 	ldw	r2,-8(fp)
   2bf0c:	10bfffc4 	addi	r2,r2,-1
   2bf10:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
   2bf14:	e0bffe17 	ldw	r2,-8(fp)
   2bf18:	e0ffff17 	ldw	r3,-4(fp)
   2bf1c:	1885883a 	add	r2,r3,r2
   2bf20:	10800003 	ldbu	r2,0(r2)
   2bf24:	10803fcc 	andi	r2,r2,255
   2bf28:	1080201c 	xori	r2,r2,128
   2bf2c:	10bfe004 	addi	r2,r2,-128
   2bf30:	10800be0 	cmpeqi	r2,r2,47
   2bf34:	1000081e 	bne	r2,zero,2bf58 <alt_find_file+0xb8>
   2bf38:	e0bffe17 	ldw	r2,-8(fp)
   2bf3c:	e0ffff17 	ldw	r3,-4(fp)
   2bf40:	1885883a 	add	r2,r3,r2
   2bf44:	10800003 	ldbu	r2,0(r2)
   2bf48:	10803fcc 	andi	r2,r2,255
   2bf4c:	1080201c 	xori	r2,r2,128
   2bf50:	10bfe004 	addi	r2,r2,-128
   2bf54:	10000a1e 	bne	r2,zero,2bf80 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
   2bf58:	e0bffd17 	ldw	r2,-12(fp)
   2bf5c:	10c00217 	ldw	r3,8(r2)
   2bf60:	e0bffe17 	ldw	r2,-8(fp)
   2bf64:	1809883a 	mov	r4,r3
   2bf68:	e17fff17 	ldw	r5,-4(fp)
   2bf6c:	100d883a 	mov	r6,r2
   2bf70:	002c1680 	call	2c168 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
   2bf74:	1000021e 	bne	r2,zero,2bf80 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
   2bf78:	e0bffd17 	ldw	r2,-12(fp)
   2bf7c:	00000806 	br	2bfa0 <alt_find_file+0x100>
    }
    next = (alt_dev*) next->llist.next;
   2bf80:	e0bffd17 	ldw	r2,-12(fp)
   2bf84:	10800017 	ldw	r2,0(r2)
   2bf88:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
   2bf8c:	e0fffd17 	ldw	r3,-12(fp)
   2bf90:	008000f4 	movhi	r2,3
   2bf94:	108d2f04 	addi	r2,r2,13500
   2bf98:	18bfcb1e 	bne	r3,r2,2bec8 <alt_find_file+0x28>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
   2bf9c:	0005883a 	mov	r2,zero
}
   2bfa0:	e037883a 	mov	sp,fp
   2bfa4:	dfc00117 	ldw	ra,4(sp)
   2bfa8:	df000017 	ldw	fp,0(sp)
   2bfac:	dec00204 	addi	sp,sp,8
   2bfb0:	f800283a 	ret

0002bfb4 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
   2bfb4:	defffc04 	addi	sp,sp,-16
   2bfb8:	df000315 	stw	fp,12(sp)
   2bfbc:	df000304 	addi	fp,sp,12
   2bfc0:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
   2bfc4:	00bffa04 	movi	r2,-24
   2bfc8:	e0bffe15 	stw	r2,-8(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
   2bfcc:	e03ffd15 	stw	zero,-12(fp)
   2bfd0:	00001d06 	br	2c048 <alt_get_fd+0x94>
  {
    if (!alt_fd_list[i].dev)
   2bfd4:	00c000f4 	movhi	r3,3
   2bfd8:	18c6c804 	addi	r3,r3,6944
   2bfdc:	e0bffd17 	ldw	r2,-12(fp)
   2bfe0:	10800324 	muli	r2,r2,12
   2bfe4:	1885883a 	add	r2,r3,r2
   2bfe8:	10800017 	ldw	r2,0(r2)
   2bfec:	1000131e 	bne	r2,zero,2c03c <alt_get_fd+0x88>
    {
      alt_fd_list[i].dev = dev;
   2bff0:	00c000f4 	movhi	r3,3
   2bff4:	18c6c804 	addi	r3,r3,6944
   2bff8:	e0bffd17 	ldw	r2,-12(fp)
   2bffc:	10800324 	muli	r2,r2,12
   2c000:	1885883a 	add	r2,r3,r2
   2c004:	e0ffff17 	ldw	r3,-4(fp)
   2c008:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
   2c00c:	008000f4 	movhi	r2,3
   2c010:	108d3304 	addi	r2,r2,13516
   2c014:	10c00017 	ldw	r3,0(r2)
   2c018:	e0bffd17 	ldw	r2,-12(fp)
   2c01c:	1880040e 	bge	r3,r2,2c030 <alt_get_fd+0x7c>
      {
        alt_max_fd = i;
   2c020:	008000f4 	movhi	r2,3
   2c024:	108d3304 	addi	r2,r2,13516
   2c028:	e0fffd17 	ldw	r3,-12(fp)
   2c02c:	10c00015 	stw	r3,0(r2)
      }
      rc = i;
   2c030:	e0bffd17 	ldw	r2,-12(fp)
   2c034:	e0bffe15 	stw	r2,-8(fp)
      goto alt_get_fd_exit;
   2c038:	00000606 	br	2c054 <alt_get_fd+0xa0>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
   2c03c:	e0bffd17 	ldw	r2,-12(fp)
   2c040:	10800044 	addi	r2,r2,1
   2c044:	e0bffd15 	stw	r2,-12(fp)
   2c048:	e0bffd17 	ldw	r2,-12(fp)
   2c04c:	10800810 	cmplti	r2,r2,32
   2c050:	103fe01e 	bne	r2,zero,2bfd4 <alt_get_fd+0x20>
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
   2c054:	e0bffe17 	ldw	r2,-8(fp)
}
   2c058:	e037883a 	mov	sp,fp
   2c05c:	df000017 	ldw	fp,0(sp)
   2c060:	dec00104 	addi	sp,sp,4
   2c064:	f800283a 	ret

0002c068 <alt_icache_flush>:
 * alt_icache_flush() is called to flush the instruction cache for a memory
 * region of length "len" bytes, starting at address "start".
 */

void alt_icache_flush (void* start, alt_u32 len)
{
   2c068:	defffb04 	addi	sp,sp,-20
   2c06c:	df000415 	stw	fp,16(sp)
   2c070:	df000404 	addi	fp,sp,16
   2c074:	e13ffe15 	stw	r4,-8(fp)
   2c078:	e17fff15 	stw	r5,-4(fp)

  /*
   * This is the most we would ever need to flush.
   */
 
  if (len > NIOS2_ICACHE_SIZE)
   2c07c:	e0bfff17 	ldw	r2,-4(fp)
   2c080:	10840070 	cmpltui	r2,r2,4097
   2c084:	1000021e 	bne	r2,zero,2c090 <alt_icache_flush+0x28>
  {
    len = NIOS2_ICACHE_SIZE;
   2c088:	00840004 	movi	r2,4096
   2c08c:	e0bfff15 	stw	r2,-4(fp)
  }

  end = ((char*) start) + len;
   2c090:	e0fffe17 	ldw	r3,-8(fp)
   2c094:	e0bfff17 	ldw	r2,-4(fp)
   2c098:	1885883a 	add	r2,r3,r2
   2c09c:	e0bffd15 	stw	r2,-12(fp)

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
   2c0a0:	e0bffe17 	ldw	r2,-8(fp)
   2c0a4:	e0bffc15 	stw	r2,-16(fp)
   2c0a8:	00000506 	br	2c0c0 <alt_icache_flush+0x58>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
   2c0ac:	e0bffc17 	ldw	r2,-16(fp)
   2c0b0:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
   2c0b4:	e0bffc17 	ldw	r2,-16(fp)
   2c0b8:	10800804 	addi	r2,r2,32
   2c0bc:	e0bffc15 	stw	r2,-16(fp)
   2c0c0:	e0fffc17 	ldw	r3,-16(fp)
   2c0c4:	e0bffd17 	ldw	r2,-12(fp)
   2c0c8:	18bff836 	bltu	r3,r2,2c0ac <alt_icache_flush+0x44>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
   2c0cc:	e0bffe17 	ldw	r2,-8(fp)
   2c0d0:	108007cc 	andi	r2,r2,31
   2c0d4:	10000226 	beq	r2,zero,2c0e0 <alt_icache_flush+0x78>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
   2c0d8:	e0bffc17 	ldw	r2,-16(fp)
   2c0dc:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
   2c0e0:	0000203a 	flushp

#endif /* NIOS2_ICACHE_SIZE > 0 */
}
   2c0e4:	e037883a 	mov	sp,fp
   2c0e8:	df000017 	ldw	fp,0(sp)
   2c0ec:	dec00104 	addi	sp,sp,4
   2c0f0:	f800283a 	ret

0002c0f4 <atexit>:
   2c0f4:	200b883a 	mov	r5,r4
   2c0f8:	000d883a 	mov	r6,zero
   2c0fc:	0009883a 	mov	r4,zero
   2c100:	000f883a 	mov	r7,zero
   2c104:	002c2781 	jmpi	2c278 <__register_exitproc>

0002c108 <exit>:
   2c108:	defffe04 	addi	sp,sp,-8
   2c10c:	000b883a 	mov	r5,zero
   2c110:	dc000015 	stw	r16,0(sp)
   2c114:	dfc00115 	stw	ra,4(sp)
   2c118:	2021883a 	mov	r16,r4
   2c11c:	002c3a80 	call	2c3a8 <__call_exitprocs>
   2c120:	008000f4 	movhi	r2,3
   2c124:	108d2a04 	addi	r2,r2,13480
   2c128:	11000017 	ldw	r4,0(r2)
   2c12c:	20800f17 	ldw	r2,60(r4)
   2c130:	10000126 	beq	r2,zero,2c138 <exit+0x30>
   2c134:	103ee83a 	callr	r2
   2c138:	8009883a 	mov	r4,r16
   2c13c:	002c5480 	call	2c548 <_exit>

0002c140 <malloc>:
   2c140:	008000f4 	movhi	r2,3
   2c144:	108d2b04 	addi	r2,r2,13484
   2c148:	200b883a 	mov	r5,r4
   2c14c:	11000017 	ldw	r4,0(r2)
   2c150:	001b6941 	jmpi	1b694 <_malloc_r>

0002c154 <free>:
   2c154:	008000f4 	movhi	r2,3
   2c158:	108d2b04 	addi	r2,r2,13484
   2c15c:	200b883a 	mov	r5,r4
   2c160:	11000017 	ldw	r4,0(r2)
   2c164:	001aafc1 	jmpi	1aafc <_free_r>

0002c168 <memcmp>:
   2c168:	01c000c4 	movi	r7,3
   2c16c:	3980192e 	bgeu	r7,r6,2c1d4 <memcmp+0x6c>
   2c170:	2904b03a 	or	r2,r5,r4
   2c174:	11c4703a 	and	r2,r2,r7
   2c178:	10000f26 	beq	r2,zero,2c1b8 <memcmp+0x50>
   2c17c:	20c00003 	ldbu	r3,0(r4)
   2c180:	28800003 	ldbu	r2,0(r5)
   2c184:	1880151e 	bne	r3,r2,2c1dc <memcmp+0x74>
   2c188:	31bfff84 	addi	r6,r6,-2
   2c18c:	01ffffc4 	movi	r7,-1
   2c190:	00000406 	br	2c1a4 <memcmp+0x3c>
   2c194:	20c00003 	ldbu	r3,0(r4)
   2c198:	28800003 	ldbu	r2,0(r5)
   2c19c:	31bfffc4 	addi	r6,r6,-1
   2c1a0:	18800e1e 	bne	r3,r2,2c1dc <memcmp+0x74>
   2c1a4:	21000044 	addi	r4,r4,1
   2c1a8:	29400044 	addi	r5,r5,1
   2c1ac:	31fff91e 	bne	r6,r7,2c194 <memcmp+0x2c>
   2c1b0:	0005883a 	mov	r2,zero
   2c1b4:	f800283a 	ret
   2c1b8:	20c00017 	ldw	r3,0(r4)
   2c1bc:	28800017 	ldw	r2,0(r5)
   2c1c0:	1880041e 	bne	r3,r2,2c1d4 <memcmp+0x6c>
   2c1c4:	31bfff04 	addi	r6,r6,-4
   2c1c8:	21000104 	addi	r4,r4,4
   2c1cc:	29400104 	addi	r5,r5,4
   2c1d0:	39bff936 	bltu	r7,r6,2c1b8 <memcmp+0x50>
   2c1d4:	303fe91e 	bne	r6,zero,2c17c <memcmp+0x14>
   2c1d8:	003ff506 	br	2c1b0 <memcmp+0x48>
   2c1dc:	1885c83a 	sub	r2,r3,r2
   2c1e0:	f800283a 	ret

0002c1e4 <strcpy>:
   2c1e4:	2906b03a 	or	r3,r5,r4
   2c1e8:	18c000cc 	andi	r3,r3,3
   2c1ec:	2005883a 	mov	r2,r4
   2c1f0:	18001a1e 	bne	r3,zero,2c25c <strcpy+0x78>
   2c1f4:	29800017 	ldw	r6,0(r5)
   2c1f8:	02bfbff4 	movhi	r10,65279
   2c1fc:	52bfbfc4 	addi	r10,r10,-257
   2c200:	02602074 	movhi	r9,32897
   2c204:	4a602004 	addi	r9,r9,-32640
   2c208:	0188303a 	nor	r4,zero,r6
   2c20c:	3287883a 	add	r3,r6,r10
   2c210:	20c6703a 	and	r3,r4,r3
   2c214:	1a46703a 	and	r3,r3,r9
   2c218:	1800101e 	bne	r3,zero,2c25c <strcpy+0x78>
   2c21c:	1007883a 	mov	r3,r2
   2c220:	19800015 	stw	r6,0(r3)
   2c224:	29400104 	addi	r5,r5,4
   2c228:	29800017 	ldw	r6,0(r5)
   2c22c:	18c00104 	addi	r3,r3,4
   2c230:	0190303a 	nor	r8,zero,r6
   2c234:	328f883a 	add	r7,r6,r10
   2c238:	41ce703a 	and	r7,r8,r7
   2c23c:	3a4e703a 	and	r7,r7,r9
   2c240:	383ff726 	beq	r7,zero,2c220 <strcpy+0x3c>
   2c244:	29800007 	ldb	r6,0(r5)
   2c248:	18c00044 	addi	r3,r3,1
   2c24c:	29400044 	addi	r5,r5,1
   2c250:	19bfffc5 	stb	r6,-1(r3)
   2c254:	3000021e 	bne	r6,zero,2c260 <strcpy+0x7c>
   2c258:	f800283a 	ret
   2c25c:	1007883a 	mov	r3,r2
   2c260:	29800007 	ldb	r6,0(r5)
   2c264:	18c00044 	addi	r3,r3,1
   2c268:	29400044 	addi	r5,r5,1
   2c26c:	19bfffc5 	stb	r6,-1(r3)
   2c270:	303ffb1e 	bne	r6,zero,2c260 <strcpy+0x7c>
   2c274:	f800283a 	ret

0002c278 <__register_exitproc>:
   2c278:	defffa04 	addi	sp,sp,-24
   2c27c:	008000f4 	movhi	r2,3
   2c280:	108d2a04 	addi	r2,r2,13480
   2c284:	dc000315 	stw	r16,12(sp)
   2c288:	14000017 	ldw	r16,0(r2)
   2c28c:	dc400415 	stw	r17,16(sp)
   2c290:	dfc00515 	stw	ra,20(sp)
   2c294:	80805217 	ldw	r2,328(r16)
   2c298:	2023883a 	mov	r17,r4
   2c29c:	10003e26 	beq	r2,zero,2c398 <__register_exitproc+0x120>
   2c2a0:	10c00117 	ldw	r3,4(r2)
   2c2a4:	020007c4 	movi	r8,31
   2c2a8:	40c0180e 	bge	r8,r3,2c30c <__register_exitproc+0x94>
   2c2ac:	008000f4 	movhi	r2,3
   2c2b0:	10b05004 	addi	r2,r2,-16064
   2c2b4:	1000061e 	bne	r2,zero,2c2d0 <__register_exitproc+0x58>
   2c2b8:	00bfffc4 	movi	r2,-1
   2c2bc:	dfc00517 	ldw	ra,20(sp)
   2c2c0:	dc400417 	ldw	r17,16(sp)
   2c2c4:	dc000317 	ldw	r16,12(sp)
   2c2c8:	dec00604 	addi	sp,sp,24
   2c2cc:	f800283a 	ret
   2c2d0:	01006404 	movi	r4,400
   2c2d4:	d9400015 	stw	r5,0(sp)
   2c2d8:	d9800115 	stw	r6,4(sp)
   2c2dc:	d9c00215 	stw	r7,8(sp)
   2c2e0:	002c1400 	call	2c140 <malloc>
   2c2e4:	d9400017 	ldw	r5,0(sp)
   2c2e8:	d9800117 	ldw	r6,4(sp)
   2c2ec:	d9c00217 	ldw	r7,8(sp)
   2c2f0:	103ff126 	beq	r2,zero,2c2b8 <__register_exitproc+0x40>
   2c2f4:	80c05217 	ldw	r3,328(r16)
   2c2f8:	10000115 	stw	zero,4(r2)
   2c2fc:	10c00015 	stw	r3,0(r2)
   2c300:	80805215 	stw	r2,328(r16)
   2c304:	10006215 	stw	zero,392(r2)
   2c308:	10006315 	stw	zero,396(r2)
   2c30c:	10c00117 	ldw	r3,4(r2)
   2c310:	88000d1e 	bne	r17,zero,2c348 <__register_exitproc+0xd0>
   2c314:	19000084 	addi	r4,r3,2
   2c318:	2109883a 	add	r4,r4,r4
   2c31c:	18c00044 	addi	r3,r3,1
   2c320:	2109883a 	add	r4,r4,r4
   2c324:	1109883a 	add	r4,r2,r4
   2c328:	10c00115 	stw	r3,4(r2)
   2c32c:	0005883a 	mov	r2,zero
   2c330:	21400015 	stw	r5,0(r4)
   2c334:	dfc00517 	ldw	ra,20(sp)
   2c338:	dc400417 	ldw	r17,16(sp)
   2c33c:	dc000317 	ldw	r16,12(sp)
   2c340:	dec00604 	addi	sp,sp,24
   2c344:	f800283a 	ret
   2c348:	02400044 	movi	r9,1
   2c34c:	12806217 	ldw	r10,392(r2)
   2c350:	48d2983a 	sll	r9,r9,r3
   2c354:	19000804 	addi	r4,r3,32
   2c358:	18d1883a 	add	r8,r3,r3
   2c35c:	2109883a 	add	r4,r4,r4
   2c360:	4211883a 	add	r8,r8,r8
   2c364:	2109883a 	add	r4,r4,r4
   2c368:	1109883a 	add	r4,r2,r4
   2c36c:	1211883a 	add	r8,r2,r8
   2c370:	5254b03a 	or	r10,r10,r9
   2c374:	21c02215 	stw	r7,136(r4)
   2c378:	41802215 	stw	r6,136(r8)
   2c37c:	12806215 	stw	r10,392(r2)
   2c380:	01000084 	movi	r4,2
   2c384:	893fe31e 	bne	r17,r4,2c314 <__register_exitproc+0x9c>
   2c388:	11006317 	ldw	r4,396(r2)
   2c38c:	2252b03a 	or	r9,r4,r9
   2c390:	12406315 	stw	r9,396(r2)
   2c394:	003fdf06 	br	2c314 <__register_exitproc+0x9c>
   2c398:	00800134 	movhi	r2,4
   2c39c:	108df804 	addi	r2,r2,14304
   2c3a0:	80805215 	stw	r2,328(r16)
   2c3a4:	003fbe06 	br	2c2a0 <__register_exitproc+0x28>

0002c3a8 <__call_exitprocs>:
   2c3a8:	008000f4 	movhi	r2,3
   2c3ac:	108d2a04 	addi	r2,r2,13480
   2c3b0:	10800017 	ldw	r2,0(r2)
   2c3b4:	defff304 	addi	sp,sp,-52
   2c3b8:	df000b15 	stw	fp,44(sp)
   2c3bc:	d8800015 	stw	r2,0(sp)
   2c3c0:	10805204 	addi	r2,r2,328
   2c3c4:	dd400815 	stw	r21,32(sp)
   2c3c8:	dfc00c15 	stw	ra,48(sp)
   2c3cc:	ddc00a15 	stw	r23,40(sp)
   2c3d0:	dd800915 	stw	r22,36(sp)
   2c3d4:	dd000715 	stw	r20,28(sp)
   2c3d8:	dcc00615 	stw	r19,24(sp)
   2c3dc:	dc800515 	stw	r18,20(sp)
   2c3e0:	dc400415 	stw	r17,16(sp)
   2c3e4:	dc000315 	stw	r16,12(sp)
   2c3e8:	d9000115 	stw	r4,4(sp)
   2c3ec:	2839883a 	mov	fp,r5
   2c3f0:	d8800215 	stw	r2,8(sp)
   2c3f4:	057fffc4 	movi	r21,-1
   2c3f8:	d8800017 	ldw	r2,0(sp)
   2c3fc:	ddc00217 	ldw	r23,8(sp)
   2c400:	14805217 	ldw	r18,328(r2)
   2c404:	90001726 	beq	r18,zero,2c464 <__call_exitprocs+0xbc>
   2c408:	94400117 	ldw	r17,4(r18)
   2c40c:	8c3fffc4 	addi	r16,r17,-1
   2c410:	80001116 	blt	r16,zero,2c458 <__call_exitprocs+0xb0>
   2c414:	8c400044 	addi	r17,r17,1
   2c418:	8427883a 	add	r19,r16,r16
   2c41c:	8c63883a 	add	r17,r17,r17
   2c420:	95802204 	addi	r22,r18,136
   2c424:	9ce7883a 	add	r19,r19,r19
   2c428:	8c63883a 	add	r17,r17,r17
   2c42c:	b4e7883a 	add	r19,r22,r19
   2c430:	9463883a 	add	r17,r18,r17
   2c434:	e0001726 	beq	fp,zero,2c494 <__call_exitprocs+0xec>
   2c438:	8c87c83a 	sub	r3,r17,r18
   2c43c:	b0c7883a 	add	r3,r22,r3
   2c440:	18c01e17 	ldw	r3,120(r3)
   2c444:	1f001326 	beq	r3,fp,2c494 <__call_exitprocs+0xec>
   2c448:	843fffc4 	addi	r16,r16,-1
   2c44c:	9cffff04 	addi	r19,r19,-4
   2c450:	8c7fff04 	addi	r17,r17,-4
   2c454:	857ff71e 	bne	r16,r21,2c434 <__call_exitprocs+0x8c>
   2c458:	008000f4 	movhi	r2,3
   2c45c:	10b05504 	addi	r2,r2,-16044
   2c460:	10002a1e 	bne	r2,zero,2c50c <__call_exitprocs+0x164>
   2c464:	dfc00c17 	ldw	ra,48(sp)
   2c468:	df000b17 	ldw	fp,44(sp)
   2c46c:	ddc00a17 	ldw	r23,40(sp)
   2c470:	dd800917 	ldw	r22,36(sp)
   2c474:	dd400817 	ldw	r21,32(sp)
   2c478:	dd000717 	ldw	r20,28(sp)
   2c47c:	dcc00617 	ldw	r19,24(sp)
   2c480:	dc800517 	ldw	r18,20(sp)
   2c484:	dc400417 	ldw	r17,16(sp)
   2c488:	dc000317 	ldw	r16,12(sp)
   2c48c:	dec00d04 	addi	sp,sp,52
   2c490:	f800283a 	ret
   2c494:	91000117 	ldw	r4,4(r18)
   2c498:	88c00017 	ldw	r3,0(r17)
   2c49c:	213fffc4 	addi	r4,r4,-1
   2c4a0:	24001526 	beq	r4,r16,2c4f8 <__call_exitprocs+0x150>
   2c4a4:	88000015 	stw	zero,0(r17)
   2c4a8:	183fe726 	beq	r3,zero,2c448 <__call_exitprocs+0xa0>
   2c4ac:	00800044 	movi	r2,1
   2c4b0:	1408983a 	sll	r4,r2,r16
   2c4b4:	91406217 	ldw	r5,392(r18)
   2c4b8:	95000117 	ldw	r20,4(r18)
   2c4bc:	214a703a 	and	r5,r4,r5
   2c4c0:	28000b26 	beq	r5,zero,2c4f0 <__call_exitprocs+0x148>
   2c4c4:	91406317 	ldw	r5,396(r18)
   2c4c8:	2148703a 	and	r4,r4,r5
   2c4cc:	20000c1e 	bne	r4,zero,2c500 <__call_exitprocs+0x158>
   2c4d0:	99400017 	ldw	r5,0(r19)
   2c4d4:	d9000117 	ldw	r4,4(sp)
   2c4d8:	183ee83a 	callr	r3
   2c4dc:	90c00117 	ldw	r3,4(r18)
   2c4e0:	1d3fc51e 	bne	r3,r20,2c3f8 <__call_exitprocs+0x50>
   2c4e4:	b8c00017 	ldw	r3,0(r23)
   2c4e8:	1cbfd726 	beq	r3,r18,2c448 <__call_exitprocs+0xa0>
   2c4ec:	003fc206 	br	2c3f8 <__call_exitprocs+0x50>
   2c4f0:	183ee83a 	callr	r3
   2c4f4:	003ff906 	br	2c4dc <__call_exitprocs+0x134>
   2c4f8:	94000115 	stw	r16,4(r18)
   2c4fc:	003fea06 	br	2c4a8 <__call_exitprocs+0x100>
   2c500:	99000017 	ldw	r4,0(r19)
   2c504:	183ee83a 	callr	r3
   2c508:	003ff406 	br	2c4dc <__call_exitprocs+0x134>
   2c50c:	90c00117 	ldw	r3,4(r18)
   2c510:	1800071e 	bne	r3,zero,2c530 <__call_exitprocs+0x188>
   2c514:	90c00017 	ldw	r3,0(r18)
   2c518:	18000926 	beq	r3,zero,2c540 <__call_exitprocs+0x198>
   2c51c:	9009883a 	mov	r4,r18
   2c520:	b8c00015 	stw	r3,0(r23)
   2c524:	002c1540 	call	2c154 <free>
   2c528:	bc800017 	ldw	r18,0(r23)
   2c52c:	003fb506 	br	2c404 <__call_exitprocs+0x5c>
   2c530:	90c00017 	ldw	r3,0(r18)
   2c534:	902f883a 	mov	r23,r18
   2c538:	1825883a 	mov	r18,r3
   2c53c:	003fb106 	br	2c404 <__call_exitprocs+0x5c>
   2c540:	0007883a 	mov	r3,zero
   2c544:	003ffb06 	br	2c534 <__call_exitprocs+0x18c>

0002c548 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
   2c548:	defffc04 	addi	sp,sp,-16
   2c54c:	df000315 	stw	fp,12(sp)
   2c550:	df000304 	addi	fp,sp,12
   2c554:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
   2c558:	0001883a 	nop
   2c55c:	e0bfff17 	ldw	r2,-4(fp)
   2c560:	e0bffd15 	stw	r2,-12(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  int r2 = exit_code;
   2c564:	e0bffd17 	ldw	r2,-12(fp)
   2c568:	e0bffe15 	stw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "D02"(r2), "D03"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
   2c56c:	e0bffe17 	ldw	r2,-8(fp)
   2c570:	10000226 	beq	r2,zero,2c57c <_exit+0x34>
    ALT_SIM_FAIL();
   2c574:	002af070 	cmpltui	zero,zero,43969
   2c578:	00000106 	br	2c580 <_exit+0x38>
  } else {
    ALT_SIM_PASS();
   2c57c:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
   2c580:	003fff06 	br	2c580 <_exit+0x38>
