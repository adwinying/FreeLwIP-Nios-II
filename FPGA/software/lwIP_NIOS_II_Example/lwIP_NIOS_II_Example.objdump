
lwIP_NIOS_II_Example.elf:     file format elf32-littlenios2
lwIP_NIOS_II_Example.elf
architecture: nios2, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00000020

Program Header:
    LOAD off    0x00001020 vaddr 0x00000020 paddr 0x00000020 align 2**12
         filesz 0x00032168 memsz 0x00032168 flags r-x
    LOAD off    0x00033188 vaddr 0x00032188 paddr 0x0003442c align 2**12
         filesz 0x000022a4 memsz 0x000022a4 flags rw-
    LOAD off    0x000356d0 vaddr 0x000366d0 paddr 0x000366d0 align 2**12
         filesz 0x00000000 memsz 0x0000e1d0 flags rw-
    LOAD off    0x00036000 vaddr 0x05000000 paddr 0x05000000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  05000000  05000000  00036000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .text         0002cf0c  00000020  00000020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000525c  0002cf2c  0002cf2c  0002df2c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .rwdata       000022a4  00032188  0003442c  00033188  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  4 .bss          0000e1d0  000366d0  000366d0  000356d0  2**2
                  ALLOC, SMALL_DATA
  5 .comment      00000023  00000000  00000000  00036020  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 00001600  00000000  00000000  00036048  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0003dd00  00000000  00000000  00037648  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000d9af  00000000  00000000  00075348  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000124d1  00000000  00000000  00082cf7  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00003eb0  00000000  00000000  000951c8  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00007e3a  00000000  00000000  00099078  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000143c5  00000000  00000000  000a0eb2  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_alt_sim_info 00000050  00000000  00000000  000b5278  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000a20  00000000  00000000  000b52c8  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .thread_model 00000003  00000000  00000000  000bca5e  2**0
                  CONTENTS, READONLY
 16 .cpu          00000003  00000000  00000000  000bca61  2**0
                  CONTENTS, READONLY
 17 .qsys         00000001  00000000  00000000  000bca64  2**0
                  CONTENTS, READONLY
 18 .simulation_enabled 00000001  00000000  00000000  000bca65  2**0
                  CONTENTS, READONLY
 19 .sysid_hash   00000004  00000000  00000000  000bca66  2**0
                  CONTENTS, READONLY
 20 .sysid_base   00000004  00000000  00000000  000bca6a  2**0
                  CONTENTS, READONLY
 21 .sysid_time   00000004  00000000  00000000  000bca6e  2**0
                  CONTENTS, READONLY
 22 .stderr_dev   00000009  00000000  00000000  000bca72  2**0
                  CONTENTS, READONLY
 23 .stdin_dev    00000009  00000000  00000000  000bca7b  2**0
                  CONTENTS, READONLY
 24 .stdout_dev   00000009  00000000  00000000  000bca84  2**0
                  CONTENTS, READONLY
 25 .sopc_system_name 0000000c  00000000  00000000  000bca8d  2**0
                  CONTENTS, READONLY
 26 .quartus_project_dir 0000002e  00000000  00000000  000bca99  2**0
                  CONTENTS, READONLY
 27 .jdi          00005066  00000000  00000000  000bcac7  2**0
                  CONTENTS, READONLY
 28 .sopcinfo     001a200d  00000000  00000000  000c1b2d  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
05000000 l    d  .entry	00000000 .entry
00000020 l    d  .text	00000000 .text
0002cf2c l    d  .rodata	00000000 .rodata
00032188 l    d  .rwdata	00000000 .rwdata
000366d0 l    d  .bss	00000000 .bss
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../lwIP_NIOS_II_Example_bsp/obj/HAL/src/crt0.o
00000098 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alteraTseEthernetif.c
0000009c l     F .text	00000064 low_level_init
00000100 l     F .text	00000234 low_level_input
00000000 l    df *ABS*	00000000 fs.c
0002cfe0 l     O .rodata	00000345 data_img_sics_gif
0002d325 l     O .rodata	00000298 data_404_html
0002d5bd l     O .rodata	00000671 data_index_html
00000000 l    df *ABS*	00000000 fsdata.c
00000000 l    df *ABS*	00000000 httpd.c
00000624 l     F .text	00000040 conn_err
00000664 l     F .text	00000060 close_conn
000006c4 l     F .text	000000f4 send_data
000007b8 l     F .text	000000cc http_poll
00000884 l     F .text	00000070 http_sent
000008f4 l     F .text	0000024c http_recv
00000b40 l     F .text	000000cc http_accept
00000000 l    df *ABS*	00000000 lwip_tse_mac.c
00000000 l    df *ABS*	00000000 tse_my_system.c
00000000 l    df *ABS*	00000000 api_lib.c
00000000 l    df *ABS*	00000000 api_msg.c
00000000 l    df *ABS*	00000000 err.c
000323c8 l     O .rwdata	0000003c err_strerr
00000000 l    df *ABS*	00000000 netbuf.c
00000000 l    df *ABS*	00000000 netdb.c
00000000 l    df *ABS*	00000000 netifapi.c
00000000 l    df *ABS*	00000000 sockets.c
00000000 l    df *ABS*	00000000 tcpip.c
00000000 l    df *ABS*	00000000 dhcp.c
00001984 l     F .text	00000080 dhcp_handle_nak
000039b0 l     F .text	00000050 dhcp_set_state
00002cc0 l     F .text	000001d0 dhcp_discover
00001a04 l     F .text	00000098 dhcp_check
00001a9c l     F .text	00000100 dhcp_handle_offer
00004a90 l     F .text	00000234 dhcp_get_option_ptr
00004cec l     F .text	000000b8 dhcp_get_option_long
00001b9c l     F .text	00000268 dhcp_select
00004354 l     F .text	000004a0 dhcp_create_request
00003a00 l     F .text	000000e4 dhcp_option
00003ae4 l     F .text	0000009c dhcp_option_byte
00003b80 l     F .text	000000d8 dhcp_option_short
00003c58 l     F .text	0000014c dhcp_option_long
0000490c l     F .text	00000184 dhcp_option_trailer
000047f4 l     F .text	00000118 dhcp_delete_request
00002180 l     F .text	00000078 dhcp_t2_timeout
00002108 l     F .text	00000078 dhcp_t1_timeout
00001f74 l     F .text	00000194 dhcp_timeout
00002e90 l     F .text	000003c0 dhcp_bind
000033b4 l     F .text	00000164 dhcp_rebind
00003518 l     F .text	000001b8 dhcp_reboot
000021f8 l     F .text	00000418 dhcp_handle_ack
00004cc4 l     F .text	00000028 dhcp_get_option_byte
00003ff4 l     F .text	00000360 dhcp_recv
00002b48 l     F .text	00000178 dhcp_decline
00003da4 l     F .text	000001d8 dhcp_unfold_reply
00003f7c l     F .text	00000078 dhcp_free_reply
000343b0 l     O .rwdata	00000004 xid.3597
00000000 l    df *ABS*	00000000 dns.c
00000000 l    df *ABS*	00000000 init.c
00004da4 l     F .text	0000001c lwip_sanity_check
00000000 l    df *ABS*	00000000 autoip.c
00000000 l    df *ABS*	00000000 icmp.c
00005510 l     F .text	00000270 icmp_send_response
00000000 l    df *ABS*	00000000 igmp.c
00000000 l    df *ABS*	00000000 inet.c
00036794 l     O .bss	00000010 str.2832
00000000 l    df *ABS*	00000000 inet_chksum.c
00005d14 l     F .text	0000012c lwip_standard_chksum
00000000 l    df *ABS*	00000000 ip.c
000366d0 l     O .bss	00000002 ip_id.3637
00000000 l    df *ABS*	00000000 ip_addr.c
00000000 l    df *ABS*	00000000 ip_frag.c
000366dc l     O .bss	00000004 reassdatagrams
000366e0 l     O .bss	00000002 ip_reass_pbufcount
00006f58 l     F .text	000001ec ip_reass_free_complete_datagram
00007374 l     F .text	00000090 ip_reass_dequeue_datagram
00007144 l     F .text	00000154 ip_reass_remove_oldest_datagram
00007298 l     F .text	000000dc ip_reass_enqueue_new_datagram
00007404 l     F .text	00000580 ip_reass_chain_frag_into_datagram_and_validate
000367a4 l     O .bss	000005e0 buf
00000000 l    df *ABS*	00000000 mem.c
00036d84 l     O .bss	00000654 ram_heap
000366e4 l     O .bss	00000004 ram
000366e8 l     O .bss	00000004 ram_end
000366ec l     O .bss	00000004 lfree
000366f0 l     O .bss	00000001 mem_sem
000081a8 l     F .text	000001f8 plug_holes
00000000 l    df *ABS*	00000000 memp.c
000373d8 l     O .bss	00000024 memp_tab
0002e9ec l     O .rodata	00000012 memp_sizes
0002e9fe l     O .rodata	00000012 memp_num
00032404 l     O .rwdata	00000024 memp_desc
000373fc l     O .bss	0000cf1b memp_memory
00000000 l    df *ABS*	00000000 netif.c
000366f4 l     O .bss	00000001 netifnum.3512
00000000 l    df *ABS*	00000000 pbuf.c
00000000 l    df *ABS*	00000000 raw.c
00036700 l     O .bss	00000004 raw_pcbs
00000000 l    df *ABS*	00000000 asn1_dec.c
00000000 l    df *ABS*	00000000 asn1_enc.c
00000000 l    df *ABS*	00000000 mib2.c
00000000 l    df *ABS*	00000000 mib_structs.c
00000000 l    df *ABS*	00000000 msg_in.c
00000000 l    df *ABS*	00000000 msg_out.c
00000000 l    df *ABS*	00000000 stats.c
00000000 l    df *ABS*	00000000 sys.c
00000000 l    df *ABS*	00000000 tcp.c
00036704 l     O .bss	00000001 tcp_timer
0000bcfc l     F .text	00000108 tcp_new_port
0000b91c l     F .text	00000030 tcp_accept_null
000343c8 l     O .rwdata	00000002 port.3552
0000cc20 l     F .text	000000e4 tcp_kill_prio
0000cd04 l     F .text	000000a0 tcp_kill_timewait
000343c4 l     O .rwdata	00000004 iss.3743
00000000 l    df *ABS*	00000000 tcp_in.c
00044318 l     O .bss	00000014 inseg
00036720 l     O .bss	00000004 tcphdr
00036724 l     O .bss	00000004 iphdr
00036728 l     O .bss	00000004 seqno
0003672c l     O .bss	00000004 ackno
00036730 l     O .bss	00000001 flags
00036732 l     O .bss	00000002 tcplen
00036734 l     O .bss	00000001 recv_flags
00036738 l     O .bss	00000004 recv_data
0000eb10 l     F .text	00000138 tcp_timewait_input
0000e850 l     F .text	000002c0 tcp_listen_input
0000ec48 l     F .text	00000c3c tcp_process
000116c4 l     F .text	000001f8 tcp_parseopt
0000faa0 l     F .text	00001c24 tcp_receive
0000f884 l     F .text	0000021c tcp_oos_insert_segment
00000000 l    df *ABS*	00000000 tcp_out.c
000118bc l     F .text	00000288 tcp_output_set_header
00013394 l     F .text	00000390 tcp_output_segment
00000000 l    df *ABS*	00000000 udp.c
00000000 l    df *ABS*	00000000 etharp.c
0004432c l     O .bss	00000118 arp_table
00036744 l     O .bss	00000001 etharp_cached_entry
00015034 l     F .text	000000ec free_etharp_q
000152a4 l     F .text	0000050c find_entry
000157b0 l     F .text	000000fc etharp_send_ip
000158ac l     F .text	0000023c update_arp_entry
0001671c l     F .text	00000284 etharp_raw
00000000 l    df *ABS*	00000000 ethernetif.c
00000000 l    df *ABS*	00000000 loopif.c
00000000 l    df *ABS*	00000000 auth.c
00000000 l    df *ABS*	00000000 chap.c
00000000 l    df *ABS*	00000000 chpms.c
00000000 l    df *ABS*	00000000 fsm.c
00000000 l    df *ABS*	00000000 ipcp.c
00000000 l    df *ABS*	00000000 lcp.c
00000000 l    df *ABS*	00000000 magic.c
00000000 l    df *ABS*	00000000 md5.c
00000000 l    df *ABS*	00000000 pap.c
00000000 l    df *ABS*	00000000 ppp.c
00000000 l    df *ABS*	00000000 ppp_oe.c
00000000 l    df *ABS*	00000000 randm.c
00000000 l    df *ABS*	00000000 vj.c
00000000 l    df *ABS*	00000000 slipif.c
00000000 l    df *ABS*	00000000 main.c
00044444 l     O .bss	00000018 lwipAlarm
00036748 l     O .bss	00000004 lwipProcessTimerFlag
0003674c l     O .bss	00000004 lwipTicksPer250mS
00036750 l     O .bss	00000004 lwip250mStimer
00036754 l     O .bss	00000004 ip_zero.3889
00000000 l    df *ABS*	00000000 impure.c
00032454 l     O .rwdata	00000400 impure_data
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 putchar.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 vfprintf.c
00017538 l     F .text	00000034 __sprint_r
0002ffca l     O .rodata	00000010 blanks.3515
0002ffda l     O .rodata	00000010 zeroes.3516
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 dtoa.c
00019654 l     F .text	00000208 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
0001b090 l     F .text	00000008 __fp_lock
0001b098 l     F .text	00000008 __fp_unlock
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 locale.c
0003000c l     O .rodata	00000030 lconv
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mprec.c
00030154 l     O .rodata	0000000c p05.2435
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 s_isinfd.c
00000000 l    df *ABS*	00000000 s_isnand.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 fp-bit.c
0001f160 l     F .text	00000354 _fpadd_parts
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
0001fea0 l     F .text	00000074 udivmodsi4
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_close.c
000206c8 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dev.c
000207e0 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_fstat.c
0002080c l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_isatty.c
00020908 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_load.c
000209f8 l     F .text	0000006c alt_load_section
00000000 l    df *ABS*	00000000 alt_lseek.c
00020ae4 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
00000000 l    df *ABS*	00000000 alt_read.c
00020cbc l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_remap_uncached.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
00034404 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_uncached_malloc.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
000211f4 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_sys_init.c
00021330 l     F .text	00000038 alt_dev_reg
00032e10 l     O .rwdata	0000009c vic_0
00032eac l     O .rwdata	000000d8 ext_flash
00032f84 l     O .rwdata	00001060 jtag_uart
00033fe4 l     O .rwdata	00000120 lcd
00034104 l     O .rwdata	00000030 sgdma_rx
00034134 l     O .rwdata	00000030 sgdma_tx
00034164 l     O .rwdata	000000c4 rs232
00034228 l     O .rwdata	000000c4 uart_0
000342ec l     O .rwdata	000000c4 uart_1
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash.c
000214b8 l     F .text	00000038 alt_flash_device_register
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_table.c
000222f0 l     F .text	00000080 alt_read_16bit_query_entry
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
000233a0 l     F .text	00000204 altera_avalon_jtag_uart_irq
000235a4 l     F .text	000000a4 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_lcd_16207.c
00034410 l     O .rwdata	00000004 colstart
00023c38 l     F .text	000000b4 lcd_write_command
00023cec l     F .text	000000d0 lcd_write_data
00023dbc l     F .text	000000cc lcd_clear_screen
00023e88 l     F .text	000001ec lcd_repaint_screen
00024074 l     F .text	000000cc lcd_scroll_up
00024140 l     F .text	000002bc lcd_handle_escape
000248e0 l     F .text	000000ac alt_lcd_16207_timeout
00000000 l    df *ABS*	00000000 altera_avalon_lcd_16207_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_sgdma.c
00024b24 l     F .text	00000050 alt_get_errno
000256c8 l     F .text	000000e4 alt_avalon_sgdma_irq
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
00025850 l     F .text	000000a0 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_tse.c
0003678f l     O .bss	00000001 tse_system_count.3776
0003678e l     O .bss	00000001 is_init.3858
00000000 l    df *ABS*	00000000 altera_avalon_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_init.c
0002aad8 l     F .text	00000098 altera_avalon_uart_irq
0002ab70 l     F .text	000000d8 altera_avalon_uart_rxirq
0002ac48 l     F .text	0000013c altera_avalon_uart_txirq
00000000 l    df *ABS*	00000000 altera_avalon_uart_read.c
0002add8 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 altera_avalon_uart_write.c
0002b084 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 altera_vic_irq_init.c
00031ee4 l     O .rodata	00000020 VEC_SIZE_ARRAY.1688
00000000 l    df *ABS*	00000000 altera_vic_isr_register.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_dcache_flush.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
0002b8e8 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_flash_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
0002bc08 l     F .text	000000c0 alt_open_fd
00000000 l    df *ABS*	00000000 alt_open.c
0002bd40 l     F .text	00000050 alt_get_errno
0002bd90 l     F .text	000000cc alt_file_locked
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_amd.c
0002c344 l     F .text	000000cc alt_write_word_amd
0002c228 l     F .text	0000011c alt_wait_for_command_to_complete_amd
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_intel.c
0002c5f8 l     F .text	0000017c alt_unlock_block_intel
0002c774 l     F .text	000000d4 alt_write_word_intel
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 ctype_.c
00032005 l     O .rodata	00000180 _ctype_b
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 strcpy.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
00000000 l    df *ABS*	00000000 
00017258 g     F .text	0000001c putchar
00006060 g     F .text	00000044 inet_chksum
0000ae8c g     F .text	00000054 raw_bind
0001d814 g     F .text	00000074 _mprec_log10
00007984 g     F .text	00000520 ip_reass
00026be0 g     F .text	000000d8 alt_tse_get_mac_info
00009d0c g     F .text	00000284 pbuf_realloc
0001d904 g     F .text	00000084 __any_on
0001e4d0 g     F .text	00000064 _isatty_r
0003003c g     O .rodata	00000028 __mprec_tinytens
00020c04 g     F .text	00000078 alt_main
0002cb8c g     F .text	00000094 strcpy
0000d410 g     F .text	00000030 tcp_next_iss
00020518 g     F .text	00000044 __ashldi3
00017274 g     F .text	00000084 _puts_r
00021dc8 g     F .text	00000040 alt_read_query_entry_32bit
0000bb10 g     F .text	000000ec tcp_update_rcv_ann_wnd
0001e534 g     F .text	0000006c _lseek_r
000366f8 g     O .bss	00000004 netif_list
00021580 g     F .text	000002ac alt_flash_cfi_write
0002dc50 g     O .rodata	00000010 file_index_html
0003442c g       *ABS*	00000000 __flash_rwdata_start
0002a7b8 g     F .text	000000f0 marvell_cfg_rgmii
0001fa00 g     F .text	0000005c __eqdf2
00013724 g     F .text	000002ac tcp_rst
00027dc8 g     F .text	00000210 alt_tse_phy_print_profile
000448a0 g       *ABS*	00000000 __alt_heap_start
0002a558 g     F .text	00000098 marvell_phy_cfg
000169a0 g     F .text	00000074 etharp_request
00017068 g     F .text	0000003c printf
00002610 g     F .text	00000244 dhcp_start
00024c98 g     F .text	00000110 alt_avalon_sgdma_do_sync_transfer
0000d058 g     F .text	00000030 tcp_err
000343b4 g     O .rwdata	00000004 ip_addr_any
00005e40 g     F .text	00000220 inet_chksum_pseudo
000029e8 g     F .text	000000b4 dhcp_network_changed
05000000 g       *ABS*	00000000 __alt_mem_sram
0001e128 g     F .text	0000005c __sseek
0001b120 g     F .text	0000010c __sinit
00011b44 g     F .text	00000054 tcp_send_ctrl
00014f40 g     F .text	0000009c udp_remove
00019388 g     F .text	0000013c __swbuf_r
0000687c g     F .text	0000049c ip_output_if
0001bdb8 g     F .text	0000009c _setlocale_r
0001b0ac g     F .text	00000064 __sfmoreglue
000090e8 g     F .text	000000f8 memp_free
00020c9c g     F .text	00000020 __malloc_unlock
0000a188 g     F .text	000001cc pbuf_free
0000cff8 g     F .text	00000030 tcp_recv
00026e24 g     F .text	00000a74 getPHYSpeed
0000a3e0 g     F .text	00000140 pbuf_cat
0004469c g     O .bss	00000034 alteraTseNetif
00025384 g     F .text	00000344 alt_avalon_sgdma_construct_descriptor_burst
0001c8b8 g     F .text	00000128 memmove
00006d18 g     F .text	000000b4 ip_output
000148a8 g     F .text	00000094 udp_sendto
0001b110 g     F .text	00000010 _cleanup
0001c9e0 g     F .text	000000a8 _Balloc
00013d7c g     F .text	000001f0 tcp_keepalive
00015120 g     F .text	00000184 etharp_tmr
000297cc g     F .text	000001bc alt_tse_phy_set_adv_1000
0003441c g     O .rwdata	00000001 max_mac_system
0000cda4 g     F .text	000001f8 tcp_alloc
00025e98 g     F .text	000009fc alt_tse_system_add_sys
0001fab8 g     F .text	00000064 __gtdf2
00000000  w      *UND*	00000000 __errno
0001493c g     F .text	000002e0 udp_sendto_if
00021f54 g     F .text	0000004c alt_write_flash_command_32bit_device_16bit_mode
05000000 g     F .entry	0000001c __reset
0000cfc8 g     F .text	00000030 tcp_arg
00015c74 g     F .text	00000400 etharp_arp_input
00036708 g     O .bss	00000004 tcp_active_pcbs
00024ef4 g     F .text	00000074 alt_avalon_sgdma_construct_stream_to_mem_desc_burst
00000020 g       *ABS*	00000000 __flash_exceptions_start
0001e468 g     F .text	00000068 _fstat_r
00036740 g     O .bss	00000004 udp_pcbs
00032188 g     O .rwdata	00000240 tse_mac_device
00021a74 g     F .text	000002d8 alt_flash_program_block
00036774 g     O .bss	00000004 errno
00016a14 g     F .text	00000140 ethernet_input
0002a0a0 g     F .text	000004b8 alt_tse_phy_set_common_speed
0000a3a0 g     F .text	00000040 pbuf_ref
000446d0 g     O .bss	00000020 pmac_groups
00009654 g     F .text	00000050 netif_set_netmask
0003677c g     O .bss	00000004 alt_argv
0003c3b0 g       *ABS*	00000000 _gp
0000cba4 g     F .text	0000007c tcp_recv_null
000211c4 g     F .text	00000030 usleep
000366d4 g     O .bss	00000004 current_netif
0000b294 g     F .text	0000020c tcp_close
0000bbfc g     F .text	00000100 tcp_recved
0002116c g     F .text	00000058 alt_uncached_malloc
0000d0fc g     F .text	00000134 tcp_pcb_purge
000259a4 g     F .text	00000060 tse_mac_initTransInfo2
00032c90 g     O .rwdata	00000180 alt_fd_list
000343bc g     O .rwdata	00000007 tcp_persist_backoff
00017250 g     F .text	00000008 _putchar_r
0002b2d4 g       .text	00000000 VIC_0_VECTOR_TABLE
0002ba90 g     F .text	00000090 alt_find_dev
00016e68 g     F .text	000000f8 memcpy
00008448 g     F .text	00000180 mem_free
00025c10 g     F .text	00000054 tse_mac_setMIImode
0003670c g     O .bss	00000004 tcp_ticks
00036710 g     O .bss	00000004 tcp_listen_pcbs
00027898 g     F .text	00000048 alt_tse_phy_rd_mdio_addr
000139d0 g     F .text	000000b4 tcp_rexmit_rto
0001b0a0 g     F .text	0000000c _cleanup_r
0001fbdc g     F .text	000000d4 __floatsidf
00006dcc g     F .text	000000f0 ip_addr_isbroadcast
00025a04 g     F .text	000000e0 tse_mac_sTxWrite
0002bcc8 g     F .text	00000078 alt_io_redirect
0000cf9c g     F .text	0000002c tcp_new
0001fb80 g     F .text	0000005c __ltdf2
00014e98 g     F .text	00000068 udp_disconnect
0000a950 g     F .text	0000019c pbuf_copy_partial
0002cf2c g       *ABS*	00000000 __DTOR_END__
000172f8 g     F .text	00000014 puts
000036d0 g     F .text	000001dc dhcp_release
0001d770 g     F .text	000000a4 __ratio
00032428 g     O .rwdata	0000002c tcp_state_str
0000b0ec g     F .text	00000044 raw_send
000060a4 g     F .text	0000010c inet_chksum_pbuf
0000aaec g     F .text	000001b8 pbuf_take
00024fe4 g     F .text	00000088 alt_avalon_sgdma_construct_mem_to_stream_desc_burst
000237a4 g     F .text	00000244 altera_avalon_jtag_uart_read
0002cae8 g     F .text	00000014 malloc
0001703c g     F .text	0000002c _printf_r
0001ffc0 g     F .text	00000008 __udivsi3
00044484 g     O .bss	00000100 tse
00020958 g     F .text	000000a0 isatty
00026894 g     F .text	00000164 alt_tse_sys_enable_mdio_sharing
00004df0 g     F .text	00000698 icmp_input
0003008c g     O .rodata	000000c8 __mprec_tens
00026b60 g     F .text	00000080 alt_tse_get_mac_info_index
000091e0 g     F .text	000000d8 netif_add
0001be54 g     F .text	0000000c __locale_charset
0000ca38 g     F .text	00000064 tcp_segs_free
0002ca10 g     F .text	0000008c alt_icache_flush
00036770 g     O .bss	00000004 __malloc_top_pad
00000590 g     F .text	00000094 fs_open
000343e0 g     O .rwdata	00000004 __mb_cur_max
0001be60 g     F .text	0000000c _localeconv_r
000094ac g     F .text	00000158 netif_set_ipaddr
0001cde0 g     F .text	0000003c __i2b
0001b774 g     F .text	000004e4 __sfvwrite_r
00025110 g     F .text	00000058 alt_avalon_sgdma_stop
00027938 g     F .text	0000012c alt_tse_phy_wr_mdio_reg
0001dfe8 g     F .text	00000064 _sbrk_r
0002c410 g     F .text	00000080 alt_program_intel
00027fd8 g     F .text	0000069c alt_tse_mac_group_init
00011b98 g     F .text	000000b8 tcp_write
00000c78 g     F .text	00000868 tse_mac_init
00015ae8 g     F .text	000000bc etharp_find_addr
0001e5a0 g     F .text	0000006c _read_r
0002b8a8 g     F .text	00000024 alt_dcache_flush
00032854 g     O .rwdata	0000000c __lc_ctype
000343fc g     O .rwdata	00000004 alt_max_fd
00021d4c g     F .text	0000003c alt_read_query_entry_8bit
00020300 g     F .text	00000104 __unpack_d
0001e318 g     F .text	0000013c _fclose_r
0002c490 g     F .text	00000168 alt_erase_block_intel
0000b634 g     F .text	000002e8 tcp_bind
0001b060 g     F .text	00000030 fflush
0003676c g     O .bss	00000004 __malloc_max_sbrked_mem
000054cc g     F .text	00000044 icmp_time_exceeded
00007ea4 g     F .text	00000304 ip_frag
0001f4b4 g     F .text	00000054 __adddf3
0002dc30 g     O .rodata	00000010 file_img_sics_gif
0001d4e4 g     F .text	00000148 __b2d
0001ebd4 g     F .text	0000058c __umoddi3
00020b34 g     F .text	000000d0 lseek
0000af74 g     F .text	00000178 raw_sendto
00027b30 g     F .text	00000298 alt_tse_phy_add_profile_default
00029234 g     F .text	00000598 alt_tse_phy_get_cap
000343d8 g     O .rwdata	00000004 _global_impure_ptr
0001d988 g     F .text	000005fc _realloc_r
0000d9a4 g     F .text	00000134 tcp_pcbs_sane
000448a0 g       *ABS*	00000000 __bss_end
00024b74 g     F .text	00000124 alt_avalon_sgdma_do_async_transfer
00021068 g     F .text	00000104 alt_tick
0001e60c g     F .text	000005c8 __udivdi3
0000d7a0 g     F .text	000000fc tcp_debug_print_flags
000038ac g     F .text	00000104 dhcp_stop
000290d4 g     F .text	00000160 alt_tse_phy_check_link
00030064 g     O .rodata	00000028 __mprec_bigtens
0001cbc4 g     F .text	00000104 __s2b
0001fd84 g     F .text	0000011c __floatunsidf
0002a6d4 g     F .text	000000e4 marvell_cfg_sgmii
0000a68c g     F .text	000002c4 pbuf_copy
00028f10 g     F .text	000001c4 alt_tse_phy_restart_an
0001d284 g     F .text	00000058 __mcmp
00013a84 g     F .text	000001d4 tcp_rexmit
0002aa30 g     F .text	000000a8 altera_avalon_uart_init
00034428 g     O .rwdata	00000004 __ctype_ptr
0001b338 g     F .text	00000018 __fp_lock_all
000446f0 g     O .bss	00000020 pphy_profiles
000096cc g     F .text	0000007c netif_set_up
00020fa4 g     F .text	000000c4 alt_alarm_stop
02001000 g       *ABS*	00000000 __alt_mem_descriptor_memory
00032c68 g     O .rwdata	00000028 alt_dev_null
00036714 g     O .bss	00000004 tcp_tmp_pcb
00028df8 g     F .text	00000118 alt_tse_phy_init
00016b54 g     F .text	0000002c lwipAlarmCallback
00022254 g     F .text	0000009c alt_set_flash_algorithm_func
00025168 g     F .text	00000064 alt_avalon_sgdma_check_descriptor_status
0002b8cc g     F .text	0000001c alt_dcache_flush_all
0001ccc8 g     F .text	00000068 __hi0bits
0001fcb0 g     F .text	000000d4 __fixdfsi
0000162c g     F .text	00000170 tse_mac_raw_send
000083a0 g     F .text	000000a8 mem_init
0002b4d4 g       .text	00000000 alt_shadow_non_preemptive_interrupt
00021e08 g     F .text	00000044 alt_write_flash_command_8bit_device_8bit_mode
0003442c g       *ABS*	00000000 __ram_rwdata_end
00012b00 g     F .text	00000894 tcp_output
000343f4 g     O .rwdata	00000008 alt_dev_list
00021244 g     F .text	000000ec write
000252a4 g     F .text	00000080 alt_avalon_sgdma_enable_desc_poll
000170a4 g     F .text	000000bc _putc_r
00032188 g       *ABS*	00000000 __ram_rodata_end
0002085c g     F .text	000000ac fstat
000204d4 g     F .text	00000044 __lshrdi3
0003673c g     O .bss	00000004 tcp_input_pcb
0000ad5c g     F .text	00000130 raw_input
0002a8a8 g     F .text	00000078 DP83848C_link_status_read
000129a4 g     F .text	0000015c tcp_send_empty_ack
000230a8 g     F .text	000000d4 alt_check_primary_table
00013c58 g     F .text	00000124 tcp_rexmit_fast
0001cffc g     F .text	0000012c __pow5mult
00036764 g     O .bss	00000004 __nlocale_changed
0001ffc8 g     F .text	00000008 __umodsi3
000218b8 g     F .text	00000064 alt_flash_cfi_read
00021fec g     F .text	00000038 alt_write_native_8bit
00005780 g     F .text	00000044 inet_addr
000096a4 g     F .text	00000028 netif_set_default
00014f00 g     F .text	00000040 udp_recv
00024f68 g     F .text	0000007c alt_avalon_sgdma_construct_mem_to_stream_desc
0002506c g     F .text	00000050 alt_avalon_sgdma_register_callback
000448a0 g       *ABS*	00000000 end
00021e4c g     F .text	00000074 alt_write_flash_command_16bit_device_8bit_mode
000243fc g     F .text	000004e4 altera_avalon_lcd_16207_write
00000c0c g     F .text	0000006c httpd_init
00009748 g     F .text	00000050 netif_set_down
000097cc g     F .text	00000540 pbuf_alloc
0002b0d4 g     F .text	00000200 altera_avalon_uart_write
00025cb4 g     F .text	000001e4 alt_tse_phy_add_profile
00022370 g     F .text	000005c8 alt_read_cfi_table
000232e0 g     F .text	000000c0 altera_avalon_jtag_uart_init
0002cf2c g       *ABS*	00000000 __CTOR_LIST__
02000000 g       *ABS*	00000000 __alt_stack_pointer
00025324 g     F .text	00000060 alt_avalon_sgdma_disable_desc_poll
000258f0 g     F .text	00000088 alt_avalon_timer_sc_init
0002a980 g     F .text	00000060 altera_avalon_uart_write_fd
00020030 g     F .text	000000ac __clzsi2
0002a9e0 g     F .text	00000050 altera_avalon_uart_close_fd
000239e8 g     F .text	00000250 altera_avalon_jtag_uart_write
00024da8 g     F .text	00000070 alt_avalon_sgdma_construct_mem_to_mem_desc
000214f0 g     F .text	00000090 alt_flash_cfi_init
0001b328 g     F .text	00000004 __sfp_lock_acquire
0001c7c0 g     F .text	000000f8 memchr
000343b8 g     O .rwdata	00000004 ip_addr_broadcast
0001756c g     F .text	00001df8 ___vfprintf_internal_r
00006ebc g     F .text	0000009c ip_reass_tmr
00024e98 g     F .text	0000005c alt_avalon_sgdma_construct_stream_to_mem_desc
0002dc40 g     O .rodata	00000010 file_404_html
0001b4a4 g     F .text	000002d0 _free_r
00014d84 g     F .text	00000114 udp_connect
0002cd50 g     F .text	000001a0 __call_exitprocs
000366d8 g     O .bss	00000004 current_header
00001598 g     F .text	00000094 tse_sgdmaRx_isr
00016da4 g     F .text	000000c4 lwipProcessTimers
00036760 g     O .bss	00000004 __mlocale_changed
0000179c g     F .text	000001a4 tse_mac_rcv
000092b8 g     F .text	00000058 netif_set_addr
00002a9c g     F .text	000000ac dhcp_arp_reply
000343e4 g     O .rwdata	00000004 __malloc_sbrk_base
00000020 g     F .text	0000007c _start
00036784 g     O .bss	00000004 _alt_tick_rate
000251cc g     F .text	00000050 alt_avalon_sgdma_open
00008f0c g     F .text	000001dc memp_malloc
0001d128 g     F .text	0000015c __lshift
00013f6c g     F .text	000002a4 tcp_zero_window_probe
00036788 g     O .bss	00000004 _alt_nticks
00027a64 g     F .text	000000cc alt_tse_phy_rd_mdio_reg
00020d0c g     F .text	000000f0 read
000213a8 g     F .text	00000110 alt_sys_init
00001eb8 g     F .text	000000bc dhcp_fine_tmr
0002cc20 g     F .text	00000130 __register_exitproc
0003678c g     O .bss	00000001 phy_profile_count
0001743c g     F .text	000000fc strncmp
00026aec g     F .text	00000074 alt_tse_get_mac_group_index
00021d88 g     F .text	00000040 alt_read_query_entry_16bit
00020e5c g     F .text	00000040 alt_remap_uncached
0001ce1c g     F .text	000001e0 __multiply
00023648 g     F .text	00000068 altera_avalon_jtag_uart_close
00032188 g       *ABS*	00000000 __ram_rwdata_start
0002cf2c g       *ABS*	00000000 __ram_rodata_start
0004445c g     O .bss	00000028 __malloc_current_mallinfo
00036718 g     O .bss	00000004 tcp_bound_pcbs
00022090 g     F .text	000001c4 alt_set_flash_width_func
0001d62c g     F .text	00000144 __d2b
0000ca9c g     F .text	0000006c tcp_seg_free
000278e0 g     F .text	00000058 alt_tse_phy_wr_mdio_addr
0002317c g     F .text	00000060 altera_avalon_jtag_uart_read_fd
0002c95c g     F .text	000000b4 alt_get_fd
0002b780 g     F .text	00000128 alt_busy_sleep
00020404 g     F .text	000000d0 __fpcmp_parts_d
0000be04 g     F .text	00000254 tcp_connect
0001e2b4 g     F .text	00000064 _close_r
000088ec g     F .text	000003ec mem_malloc
00029d78 g     F .text	00000328 alt_tse_phy_get_common_speed
0002c018 g     F .text	00000210 alt_erase_block_amd
0002cb10 g     F .text	0000007c memcmp
0002323c g     F .text	00000050 altera_avalon_jtag_uart_close_fd
000448a0 g       *ABS*	00000000 __alt_stack_base
0002328c g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
0003678d g     O .bss	00000001 mac_group_count
00003250 g     F .text	00000164 dhcp_renew
000194e0 g     F .text	00000174 __swsetup_r
00022938 g     F .text	00000770 alt_read_cfi_width
000014e0 g     F .text	000000b8 tse_sgdma_read_init
0001f84c g     F .text	000001b4 __divdf3
0001b22c g     F .text	000000fc __sfp
0001d888 g     F .text	0000007c __copybits
00011c50 g     F .text	00000d54 tcp_enqueue
0000d440 g     F .text	00000084 tcp_eff_send_mss
00032860 g     O .rwdata	00000408 __malloc_av_
0001b334 g     F .text	00000004 __sinit_lock_release
0001f568 g     F .text	000002e4 __muldf3
0001e04c g     F .text	00000054 __sread
00028674 g     F .text	0000041c alt_tse_mac_get_phy
0002c848 g     F .text	00000114 alt_find_file
0002b938 g     F .text	000000a0 alt_dev_llist_insert
00020c7c g     F .text	00000020 __malloc_lock
00020e9c g     F .text	00000108 sbrk
000250bc g     F .text	00000054 alt_avalon_sgdma_start
00002854 g     F .text	00000194 dhcp_inform
0001ae78 g     F .text	000001e8 _fflush_r
000057c4 g     F .text	000003f8 inet_aton
00026d98 g     F .text	0000008c alt_tse_mac_set_duplex
0001e1f8 g     F .text	000000bc _calloc_r
0000aee0 g     F .text	00000054 raw_connect
00034420 g     O .rwdata	00000008 alt_flash_dev_list
00021f0c g     F .text	00000048 alt_write_flash_command_16bit_device_16bit_mode
000366d0 g       *ABS*	00000000 __bss_start
00016f60 g     F .text	000000dc memset
00016b80 g     F .text	00000224 main
00036780 g     O .bss	00000004 alt_envp
00036768 g     O .bss	00000004 __malloc_max_total_mem
000231dc g     F .text	00000060 altera_avalon_jtag_uart_write_fd
000194c4 g     F .text	0000001c __swbuf
00005488 g     F .text	00000044 icmp_dest_unreach
0002498c g     F .text	00000138 altera_avalon_lcd_16207_init
00034414 g     O .rwdata	00000008 alt_sgdma_list
0000d028 g     F .text	00000030 tcp_sent
00009798 g     F .text	00000034 netif_is_up
0001e184 g     F .text	00000008 __sclose
02000000 g       *ABS*	00000000 __alt_heap_limit
0001e454 g     F .text	00000014 fclose
00005bbc g     F .text	00000158 inet_ntoa
00044710 g     O .bss	00000190 _atexit0
0001985c g     F .text	0000161c _dtoa_r
0001c03c g     F .text	00000784 _malloc_r
0000b1cc g     F .text	00000080 raw_new
00025b88 g     F .text	00000088 tse_mac_SwReset
00000334 g     F .text	000000e4 ethernetif_input
00034400 g     O .rwdata	00000004 alt_errno
00021fa0 g     F .text	0000004c alt_write_flash_command_32bit_device_32bit_mode
0001bc58 g     F .text	000000a8 _fwalk
00001940 g     F .text	00000044 lwip_strerr
0002191c g     F .text	00000158 alt_write_value_to_flash
00022024 g     F .text	00000038 alt_write_native_16bit
00017160 g     F .text	000000f0 putc
0001ff14 g     F .text	00000050 __divsi3
00026a38 g     F .text	00000048 alt_tse_mac_set_common_speed
0000b130 g     F .text	0000009c raw_remove
00030160 g     O .rodata	00000014 __thenan_df
0001b368 g     F .text	0000013c _malloc_trim_r
0002cf2c g       *ABS*	00000000 __CTOR_END__
00014c1c g     F .text	00000168 udp_bind
00036790 g     O .bss	00000004 alt_vic_dev_list
0000b24c g     F .text	00000048 tcp_tmr
000162e4 g     F .text	00000438 etharp_query
0000d500 g     F .text	00000254 tcp_debug_print
0001730c g     F .text	000000a4 strcmp
00004dc0 g     F .text	00000030 lwip_init
0002cf2c g       *ABS*	00000000 __flash_rodata_start
0002cf2c g       *ABS*	00000000 __DTOR_LIST__
00016074 g     F .text	00000270 etharp_output
0001fa5c g     F .text	0000005c __nedf2
00021368 g     F .text	00000040 alt_irq_init
000269f8 g     F .text	00000040 alt_tse_mac_get_common_speed
00020dfc g     F .text	00000060 alt_release_fd
00009604 g     F .text	00000050 netif_set_gw
00030174 g     O .rodata	00000100 __clz_tab
0000a354 g     F .text	0000004c pbuf_clen
0003675c g     O .bss	00000004 _PathLocale
0002ca9c g     F .text	00000014 atexit
0001e18c g     F .text	0000006c _write_r
0000cb08 g     F .text	00000034 tcp_setprio
00014854 g     F .text	00000054 udp_send
0001be6c g     F .text	0000001c setlocale
0000aca4 g     F .text	000000b8 pbuf_coalesce
0000af34 g     F .text	00000040 raw_recv
0000d89c g     F .text	00000108 tcp_debug_print_pcbs
00009310 g     F .text	000000bc netif_remove
000343dc g     O .rwdata	00000004 _impure_ptr
00036778 g     O .bss	00000004 alt_argc
0000c058 g     F .text	000008c4 tcp_slowtmr
0000d754 g     F .text	0000004c tcp_debug_print_state
0002ba34 g     F .text	0000005c _do_dtors
0002b4ec g     F .text	0000013c alt_vic_irq_init
0001d484 g     F .text	00000060 __ulp
0001df84 g     F .text	00000038 __isinfd
0000d088 g     F .text	00000030 tcp_accept
0001b350 g     F .text	00000018 __fp_unlock_all
00024ac4 g     F .text	00000060 altera_avalon_lcd_16207_write_fd
00000418 g     F .text	00000178 ethernetif_init
000343ec g     O .rwdata	00000008 alt_fs_list
00021ec0 g     F .text	0000004c alt_write_flash_command_32bit_device_8bit_mode
00000020 g       *ABS*	00000000 __ram_exceptions_start
0001be88 g     F .text	0000000c localeconv
0a000000 g       *ABS*	00000000 __alt_mem_onchip_memory2
0003671c g     O .bss	00000004 tcp_tw_pcbs
00029bd0 g     F .text	000001a8 alt_tse_phy_set_adv_10
0002b628 g     F .text	00000158 alt_ic_isr_register
00014210 g     F .text	00000644 udp_input
0003442c g       *ABS*	00000000 _edata
0002a920 g     F .text	00000060 altera_avalon_uart_read_fd
000448a0 g       *ABS*	00000000 _end
0002bb20 g     F .text	00000068 alt_flash_open_dev
00028a90 g     F .text	00000240 alt_tse_mac_associate_phy
00000020 g       *ABS*	00000000 __ram_exceptions_end
000236b0 g     F .text	000000f4 altera_avalon_jtag_uart_ioctl
000061b0 g     F .text	000000fc ip_route
0000b94c g     F .text	000001c4 tcp_listen_with_backlog
00044584 g     O .bss	00000118 lwip_stats
00009f90 g     F .text	000001f8 pbuf_header
000085c8 g     F .text	00000324 mem_realloc
000366fc g     O .bss	00000004 netif_default
0000d230 g     F .text	000001e0 tcp_pcb_remove
00036758 g     O .bss	00000004 lwipStaticIp
0002521c g     F .text	00000088 alt_avalon_sgdma_construct_descriptor
0001e0a0 g     F .text	00000088 __swrite
000343e8 g     O .rwdata	00000004 __malloc_trim_threshold
0000a520 g     F .text	00000040 pbuf_chain
0002cab0 g     F .text	00000038 exit
0000b4a0 g     F .text	00000194 tcp_abandon
0000d4c4 g     F .text	0000003c tcp_debug_state_str
0001bd00 g     F .text	000000b8 _fwalk_reent
00008d50 g     F .text	000001bc memp_init
0001d2dc g     F .text	000001a8 __mdiff
00008cd8 g     F .text	00000078 mem_calloc
0000c91c g     F .text	0000011c tcp_fasttmr
0002bb88 g     F .text	00000050 alt_flash_close_dev
0001ff64 g     F .text	0000005c __modsi3
00025c64 g     F .text	00000050 tse_mac_setGMIImode
0002a5f0 g     F .text	000000e4 marvell_cfg_gmii
02000000 g       *ABS*	00000000 __alt_data_end
0001b32c g     F .text	00000004 __sfp_lock_release
00000000 g       *ABS*	00000000 __alt_mem_sdram
00028cd0 g     F .text	00000128 alt_tse_phy_cfg_pcs
00015ba4 g     F .text	000000d0 etharp_ip_input
00031f04 g     O .rodata	00000101 _ctype_
04000000 g       *ABS*	00000000 __alt_mem_ext_flash
0002ad84 g     F .text	00000054 altera_avalon_uart_close
0002cef0 g     F .text	0000003c _exit
0001dfbc g     F .text	0000002c __isnand
00001e04 g     F .text	000000b4 dhcp_coarse_tmr
0002055c g     F .text	0000016c alt_alarm_start
0000cb3c g     F .text	00000068 tcp_seg_copy
0001ffd0 g     F .text	00000060 __muldi3
0001be94 g     F .text	000001a8 __smakebuf_r
0002205c g     F .text	00000034 alt_write_native_32bit
0000d0b8 g     F .text	00000044 tcp_poll
000173b0 g     F .text	0000008c strlen
0002be5c g     F .text	00000154 open
0001fb1c g     F .text	00000064 __gedf2
00014fdc g     F .text	00000058 udp_new
0002182c g     F .text	0000008c alt_flash_cfi_get_info
0002bbd8 g     F .text	00000030 alt_icache_flush_all
00025ae4 g     F .text	000000a4 tse_mac_aRxRead
000343cc g     O .rwdata	00000006 ethbroadcast
0002f06a g     O .rodata	0000000d tcp_backoff
00019364 g     F .text	00000024 __vfprintf_internal
0002ae28 g     F .text	0000025c altera_avalon_uart_read
00026cb8 g     F .text	000000e0 alt_tse_mac_set_speed
00024e18 g     F .text	00000080 alt_avalon_sgdma_construct_mem_to_mem_desc_burst
0001f508 g     F .text	00000060 __subdf3
0001cd30 g     F .text	000000b0 __lo0bits
00034408 g     O .rwdata	00000008 alt_alarm_list
0002b9d8 g     F .text	0000005c _do_ctors
00029988 g     F .text	00000248 alt_tse_phy_set_adv_100
0000dad8 g     F .text	00000d78 tcp_input
00020718 g     F .text	000000c8 close
0002bfb0 g     F .text	00000068 alt_program_amd
000062ac g     F .text	000005d0 ip_input
00020a64 g     F .text	00000080 alt_load
000343d2 g     O .rwdata	00000006 ethzero
000200dc g     F .text	00000224 __pack_d
00026a80 g     F .text	0000006c alt_tse_get_system_index
000257ac g     F .text	000000a4 alt_avalon_sgdma_init
0002cafc g     F .text	00000014 free
000093cc g     F .text	000000e0 netif_find
0001b330 g     F .text	00000004 __sinit_lock_acquire
0001cab0 g     F .text	00000114 __multadd
0001ca88 g     F .text	00000028 _Bfree
00025978 g     F .text	0000002c no_printf
0000a560 g     F .text	0000012c pbuf_dechain



Disassembly of section .entry:

05000000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && !defined(ALT_SIM_OPTIMIZE)
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
 5000000:	00840014 	movui	r2,4096
#endif

0:
    initi r2
 5000004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
 5000008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
 500000c:	00bffd16 	blt	zero,r2,5000004 <__reset+0x4>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
 5000010:	00400034 	movhi	at,0
    ori r1, r1, %lo(_start)
 5000014:	08400814 	ori	at,at,32
    jmp r1
 5000018:	0800683a 	jmp	at
 500001c:	00000000 	call	0 <__alt_mem_sdram>

Disassembly of section .text:

00000020 <_start>:
     * writing zero to SSTATUS register and executing an ERET instruction
     * to set STATUS.CRS to 0.
     */
    
    /* Get the current register set number (STATUS.CRS). */
    rdctl r2, status
      20:	0005303a 	rdctl	r2,status
    andi r2, r2, NIOS2_STATUS_CRS_MSK
      24:	10bf000c 	andi	r2,r2,64512
    
    /* Skip switching register set if STATUS.CRS is 0.  */
    beq r2, zero, 0f
      28:	10000426 	beq	r2,zero,3c <_start+0x1c>

    /* Set SSTATUS to 0 to get to set SSTATUS.PRS to 0. */
    .set nobreak
    movui sstatus, 0
      2c:	07800014 	movui	ba,0
    .set break

    /* Switch to register set 0 and jump to label. */
    movhi ea, %hi(0f)
      30:	07400034 	movhi	ea,0
    ori ea, ea, %lo(0f)
      34:	ef400f14 	ori	ea,ea,60
    eret
      38:	ef80083a 	eret

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
      3c:	06c08034 	movhi	sp,512
    ori sp, sp, %lo(__alt_stack_pointer)
      40:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
      44:	068000f4 	movhi	gp,3
    ori gp, gp, %lo(_gp)
      48:	d6b0ec14 	ori	gp,gp,50096
    /* 
     * Setup registers in shadow register sets
     * from 1 to NIOS2_NUM_OF_SHADOW_REG_SETS.
     */

    movui r2, 0     /* Contains value written into STATUS */
      4c:	00800014 	movui	r2,0
    movui r3, NIOS2_NUM_OF_SHADOW_REG_SETS  /* counter */
      50:	00c00054 	movui	r3,1
    movhi r4, 1     /* Constant to increment STATUS.PRS */
      54:	01000074 	movhi	r4,1
    
.Linitialize_shadow_registers:
    /* Increment STATUS.PRS */
    add r2, r2, r4
      58:	1105883a 	add	r2,r2,r4
    wrctl status, r2
      5c:	1001703a 	wrctl	status,r2

    /* Clear r0 in the shadow register set (not done by hardware) */
    wrprs r0, r0
      60:	0000a03a 	wrprs	zero,zero

    /* Write the GP in previous register set */
    wrprs gp, gp
      64:	d034a03a 	wrprs	gp,gp
    wrprs r30, r0    /* ba */
    wrprs r31, r0    /* ra */
#endif /* NIOS2_ECC_PRESENT */

    /* Decrement shadow register set counter */
    addi r3, r3, -1
      68:	18ffffc4 	addi	r3,r3,-1

    /* Done if index is 0. */
    bne r3, zero, .Linitialize_shadow_registers
      6c:	183ffa1e 	bne	r3,zero,58 <_start+0x38>
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
      70:	008000f4 	movhi	r2,3
    ori r2, r2, %lo(__bss_start)
      74:	1099b414 	ori	r2,r2,26320

    movhi r3, %hi(__bss_end)
      78:	00c00134 	movhi	r3,4
    ori r3, r3, %lo(__bss_end)
      7c:	18d22814 	ori	r3,r3,18592

    beq r2, r3, 1f
      80:	10c00326 	beq	r2,r3,90 <_start+0x70>

0:
    stw zero, (r2)
      84:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
      88:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
      8c:	10fffd36 	bltu	r2,r3,84 <_start+0x64>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
      90:	0020a640 	call	20a64 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
      94:	0020c040 	call	20c04 <alt_main>

00000098 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
      98:	003fff06 	br	98 <alt_after_alt_main>

0000009c <low_level_init>:
 * @param netif the already initialized lwip network interface structure
 *        for this ethernetif
 */
static void
low_level_init(struct netif *netif)
{
      9c:	defffc04 	addi	sp,sp,-16
      a0:	dfc00315 	stw	ra,12(sp)
      a4:	df000215 	stw	fp,8(sp)
      a8:	df000204 	addi	fp,sp,8
      ac:	e13fff15 	stw	r4,-4(fp)
  struct ethernetif *ethernetif = netif->state;
      b0:	e0bfff17 	ldw	r2,-4(fp)
      b4:	10800717 	ldw	r2,28(r2)
      b8:	e0bffe15 	stw	r2,-8(fp)
  
  /* set MAC hardware address length */
  netif->hwaddr_len = ETHARP_HWADDR_LEN;
      bc:	e0bfff17 	ldw	r2,-4(fp)
      c0:	00c00184 	movi	r3,6
      c4:	10c00985 	stb	r3,38(r2)

  /* maximum transfer unit */
  netif->mtu = 1500;
      c8:	e0bfff17 	ldw	r2,-4(fp)
      cc:	00c17704 	movi	r3,1500
      d0:	10c0090d 	sth	r3,36(r2)
  
  /* device capabilities */
  /* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */
  netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP;
      d4:	e0bfff17 	ldw	r2,-4(fp)
      d8:	00c00c84 	movi	r3,50
      dc:	10c00b45 	stb	r3,45(r2)
  
  tse_mac_init(0, ethernetif) != 0;
      e0:	0009883a 	mov	r4,zero
      e4:	e17ffe17 	ldw	r5,-8(fp)
      e8:	0000c780 	call	c78 <tse_mac_init>
}
      ec:	e037883a 	mov	sp,fp
      f0:	dfc00117 	ldw	ra,4(sp)
      f4:	df000017 	ldw	fp,0(sp)
      f8:	dec00204 	addi	sp,sp,8
      fc:	f800283a 	ret

00000100 <low_level_input>:
 * @return a pbuf filled with the received packet (including MAC header)
 *         NULL on memory error
 */
static struct pbuf *
low_level_input(struct netif *netif)
{
     100:	defff604 	addi	sp,sp,-40
     104:	dfc00915 	stw	ra,36(sp)
     108:	df000815 	stw	fp,32(sp)
     10c:	df000804 	addi	fp,sp,32
     110:	e13fff15 	stw	r4,-4(fp)
  struct ethernetif *ethernetif = netif->state;
     114:	e0bfff17 	ldw	r2,-4(fp)
     118:	10800717 	ldw	r2,28(r2)
     11c:	e0bff915 	stw	r2,-28(fp)
  struct pbuf *p, *nextPkt;
  u32_t cpu_sr;

    if(ethernetif->lwipRxCount == 0)
     120:	e0bff917 	ldw	r2,-28(fp)
     124:	10801517 	ldw	r2,84(r2)
     128:	1000021e 	bne	r2,zero,134 <low_level_input+0x34>
        return NULL;
     12c:	0005883a 	mov	r2,zero
     130:	00007b06 	br	320 <low_level_input+0x220>
    //  Dump current packet if there is no memory for the next packet.
    //  The lwipRxPbuf must contain pointers to pbufs at all times.
    nextPkt = pbuf_alloc(PBUF_RAW,  PBUF_POOL_BUFSIZE, PBUF_POOL);
     134:	010000c4 	movi	r4,3
     138:	01417b04 	movi	r5,1516
     13c:	018000c4 	movi	r6,3
     140:	00097cc0 	call	97cc <pbuf_alloc>
     144:	e0bffa15 	stw	r2,-24(fp)
    if(nextPkt == NULL)
     148:	e0bffa17 	ldw	r2,-24(fp)
     14c:	1000121e 	bne	r2,zero,198 <low_level_input+0x98>
        {
        LINK_STATS_INC(link.memerr);
     150:	00800134 	movhi	r2,4
     154:	10916104 	addi	r2,r2,17796
     158:	1080030b 	ldhu	r2,12(r2)
     15c:	10800044 	addi	r2,r2,1
     160:	1007883a 	mov	r3,r2
     164:	00800134 	movhi	r2,4
     168:	10916104 	addi	r2,r2,17796
     16c:	10c0030d 	sth	r3,12(r2)
        LINK_STATS_INC(link.drop);
     170:	00800134 	movhi	r2,4
     174:	10916104 	addi	r2,r2,17796
     178:	1080018b 	ldhu	r2,6(r2)
     17c:	10800044 	addi	r2,r2,1
     180:	1007883a 	mov	r3,r2
     184:	00800134 	movhi	r2,4
     188:	10916104 	addi	r2,r2,17796
     18c:	10c0018d 	sth	r3,6(r2)
        return NULL;
     190:	0005883a 	mov	r2,zero
     194:	00006206 	br	320 <low_level_input+0x220>
        }
    nextPkt = (void *) alt_remap_uncached(nextPkt,sizeof *nextPkt);
     198:	e13ffa17 	ldw	r4,-24(fp)
     19c:	01400404 	movi	r5,16
     1a0:	0020e5c0 	call	20e5c <alt_remap_uncached>
     1a4:	e0bffa15 	stw	r2,-24(fp)
    nextPkt->payload = (void *) alt_remap_uncached(nextPkt->payload, PBUF_POOL_BUFSIZE);
     1a8:	e0bffa17 	ldw	r2,-24(fp)
     1ac:	10800117 	ldw	r2,4(r2)
     1b0:	1009883a 	mov	r4,r2
     1b4:	01417b04 	movi	r5,1516
     1b8:	0020e5c0 	call	20e5c <alt_remap_uncached>
     1bc:	e0fffa17 	ldw	r3,-24(fp)
     1c0:	18800115 	stw	r2,4(r3)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
     1c4:	0005303a 	rdctl	r2,status
     1c8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
     1cc:	e0fffc17 	ldw	r3,-16(fp)
     1d0:	00bfff84 	movi	r2,-2
     1d4:	1884703a 	and	r2,r3,r2
     1d8:	1001703a 	wrctl	status,r2
  
  return context;
     1dc:	e0bffc17 	ldw	r2,-16(fp)
    cpu_sr = alt_irq_disable_all();
     1e0:	e0bffb15 	stw	r2,-20(fp)
    --ethernetif->lwipRxCount;
     1e4:	e0bff917 	ldw	r2,-28(fp)
     1e8:	10801517 	ldw	r2,84(r2)
     1ec:	10ffffc4 	addi	r3,r2,-1
     1f0:	e0bff917 	ldw	r2,-28(fp)
     1f4:	10c01515 	stw	r3,84(r2)
    alt_irq_enable_all(cpu_sr);
     1f8:	e0bffb17 	ldw	r2,-20(fp)
     1fc:	e0bffd15 	stw	r2,-12(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
     200:	0005303a 	rdctl	r2,status
     204:	e0bffe15 	stw	r2,-8(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
     208:	e0fffe17 	ldw	r3,-8(fp)
     20c:	00bfff84 	movi	r2,-2
     210:	1884703a 	and	r2,r3,r2
     214:	e0bffe15 	stw	r2,-8(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
     218:	e0bffd17 	ldw	r2,-12(fp)
     21c:	1080004c 	andi	r2,r2,1
     220:	e0fffe17 	ldw	r3,-8(fp)
     224:	1884b03a 	or	r2,r3,r2
     228:	e0bffe15 	stw	r2,-8(fp)
  
  NIOS2_WRITE_STATUS (status);
     22c:	e0bffe17 	ldw	r2,-8(fp)
     230:	1001703a 	wrctl	status,r2
    p = ethernetif->lwipRxPbuf[ ethernetif->lwipRxIndex ];
     234:	e0bff917 	ldw	r2,-28(fp)
     238:	10801417 	ldw	r2,80(r2)
     23c:	e0fff917 	ldw	r3,-28(fp)
     240:	108001c4 	addi	r2,r2,7
     244:	1085883a 	add	r2,r2,r2
     248:	1085883a 	add	r2,r2,r2
     24c:	1885883a 	add	r2,r3,r2
     250:	10800017 	ldw	r2,0(r2)
     254:	e0bff815 	stw	r2,-32(fp)
    ethernetif->lwipRxPbuf[ ethernetif->lwipRxIndex ] = nextPkt;
     258:	e0bff917 	ldw	r2,-28(fp)
     25c:	10801417 	ldw	r2,80(r2)
     260:	e0fff917 	ldw	r3,-28(fp)
     264:	108001c4 	addi	r2,r2,7
     268:	1085883a 	add	r2,r2,r2
     26c:	1085883a 	add	r2,r2,r2
     270:	1885883a 	add	r2,r3,r2
     274:	e0fffa17 	ldw	r3,-24(fp)
     278:	10c00015 	stw	r3,0(r2)
    if(++ethernetif->lwipRxIndex >= LWIP_RX_ETH_BUFFER)
     27c:	e0bff917 	ldw	r2,-28(fp)
     280:	10801417 	ldw	r2,80(r2)
     284:	10c00044 	addi	r3,r2,1
     288:	e0bff917 	ldw	r2,-28(fp)
     28c:	10c01415 	stw	r3,80(r2)
     290:	e0bff917 	ldw	r2,-28(fp)
     294:	10801417 	ldw	r2,80(r2)
     298:	10800310 	cmplti	r2,r2,12
     29c:	1000021e 	bne	r2,zero,2a8 <low_level_input+0x1a8>
        ethernetif->lwipRxIndex = 0;
     2a0:	e0bff917 	ldw	r2,-28(fp)
     2a4:	10001415 	stw	zero,80(r2)
    LWIP_ASSERT("low_level_input: pbuf in rx buffer is NULL", p != NULL );
     2a8:	e0bff817 	ldw	r2,-32(fp)
     2ac:	1000091e 	bne	r2,zero,2d4 <low_level_input+0x1d4>
     2b0:	010000f4 	movhi	r4,3
     2b4:	2133cb04 	addi	r4,r4,-12500
     2b8:	014000f4 	movhi	r5,3
     2bc:	2973d504 	addi	r5,r5,-12460
     2c0:	01801e44 	movi	r6,121
     2c4:	01c000f4 	movhi	r7,3
     2c8:	39f3e004 	addi	r7,r7,-12416
     2cc:	00170680 	call	17068 <printf>
     2d0:	003fff06 	br	2d0 <low_level_input+0x1d0>
    LWIP_ASSERT("low_level_input: pbuf->len in rx buffer is 0", p->len != 0 );
     2d4:	e0bff817 	ldw	r2,-32(fp)
     2d8:	1080028b 	ldhu	r2,10(r2)
     2dc:	10bfffcc 	andi	r2,r2,65535
     2e0:	1000091e 	bne	r2,zero,308 <low_level_input+0x208>
     2e4:	010000f4 	movhi	r4,3
     2e8:	2133cb04 	addi	r4,r4,-12500
     2ec:	014000f4 	movhi	r5,3
     2f0:	2973e804 	addi	r5,r5,-12384
     2f4:	01801e84 	movi	r6,122
     2f8:	01c000f4 	movhi	r7,3
     2fc:	39f3e004 	addi	r7,r7,-12416
     300:	00170680 	call	17068 <printf>
     304:	003fff06 	br	304 <low_level_input+0x204>
    if( p->len == 0 )
     308:	e0bff817 	ldw	r2,-32(fp)
     30c:	1080028b 	ldhu	r2,10(r2)
     310:	10bfffcc 	andi	r2,r2,65535
     314:	1000011e 	bne	r2,zero,31c <low_level_input+0x21c>
        p = NULL;
     318:	e03ff815 	stw	zero,-32(fp)
    return p;  
     31c:	e0bff817 	ldw	r2,-32(fp)
}
     320:	e037883a 	mov	sp,fp
     324:	dfc00117 	ldw	ra,4(sp)
     328:	df000017 	ldw	fp,0(sp)
     32c:	dec00204 	addi	sp,sp,8
     330:	f800283a 	ret

00000334 <ethernetif_input>:
 *
 * @param netif the lwip network interface structure for this ethernetif
 */
void
ethernetif_input(struct netif *netif)
{
     334:	defffa04 	addi	sp,sp,-24
     338:	dfc00515 	stw	ra,20(sp)
     33c:	df000415 	stw	fp,16(sp)
     340:	df000404 	addi	fp,sp,16
     344:	e13fff15 	stw	r4,-4(fp)
  struct ethernetif *ethernetif;
  struct eth_hdr *ethhdr;
  struct pbuf *p;

  ethernetif = netif->state;
     348:	e0bfff17 	ldw	r2,-4(fp)
     34c:	10800717 	ldw	r2,28(r2)
     350:	e0bffc15 	stw	r2,-16(fp)

  /* move received packet into a new pbuf */
  p = low_level_input(netif);
     354:	e13fff17 	ldw	r4,-4(fp)
     358:	00001000 	call	100 <low_level_input>
     35c:	e0bffd15 	stw	r2,-12(fp)
  /* no packet could be read, silently ignore this */
  if (p == NULL) return;
     360:	e0bffd17 	ldw	r2,-12(fp)
     364:	10002426 	beq	r2,zero,3f8 <ethernetif_input+0xc4>
  /* points to packet payload, which starts with an Ethernet header */
  ethhdr = p->payload;
     368:	e0bffd17 	ldw	r2,-12(fp)
     36c:	10800117 	ldw	r2,4(r2)
     370:	e0bffe15 	stw	r2,-8(fp)

  switch (htons(ethhdr->type)) {
     374:	e0bffe17 	ldw	r2,-8(fp)
     378:	1080038b 	ldhu	r2,14(r2)
     37c:	10bfffcc 	andi	r2,r2,65535
     380:	1004d23a 	srli	r2,r2,8
     384:	10ffffcc 	andi	r3,r2,65535
     388:	e0bffe17 	ldw	r2,-8(fp)
     38c:	1080038b 	ldhu	r2,14(r2)
     390:	10bfffcc 	andi	r2,r2,65535
     394:	1004923a 	slli	r2,r2,8
     398:	10bfffcc 	andi	r2,r2,65535
     39c:	1884b03a 	or	r2,r3,r2
     3a0:	10c20020 	cmpeqi	r3,r2,2048
     3a4:	1800021e 	bne	r3,zero,3b0 <ethernetif_input+0x7c>
     3a8:	108201a0 	cmpeqi	r2,r2,2054
     3ac:	10000d26 	beq	r2,zero,3e4 <ethernetif_input+0xb0>
  /* PPPoE packet? */
  case ETHTYPE_PPPOEDISC:
  case ETHTYPE_PPPOE:
#endif /* PPPOE_SUPPORT */
    /* full packet send to tcpip_thread to process */
    if (netif->input(p, netif)!=ERR_OK)
     3b0:	e0bfff17 	ldw	r2,-4(fp)
     3b4:	10800417 	ldw	r2,16(r2)
     3b8:	e13ffd17 	ldw	r4,-12(fp)
     3bc:	e17fff17 	ldw	r5,-4(fp)
     3c0:	103ee83a 	callr	r2
     3c4:	10803fcc 	andi	r2,r2,255
     3c8:	1080201c 	xori	r2,r2,128
     3cc:	10bfe004 	addi	r2,r2,-128
     3d0:	10000b26 	beq	r2,zero,400 <ethernetif_input+0xcc>
     { LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: IP input error\n"));
       pbuf_free(p);
     3d4:	e13ffd17 	ldw	r4,-12(fp)
     3d8:	000a1880 	call	a188 <pbuf_free>
       p = NULL;
     3dc:	e03ffd15 	stw	zero,-12(fp)
     }
    break;
     3e0:	00000706 	br	400 <ethernetif_input+0xcc>

  default:
    pbuf_free(p);
     3e4:	e13ffd17 	ldw	r4,-12(fp)
     3e8:	000a1880 	call	a188 <pbuf_free>
    p = NULL;
     3ec:	e03ffd15 	stw	zero,-12(fp)
    break;
     3f0:	0001883a 	nop
     3f4:	00000306 	br	404 <ethernetif_input+0xd0>
  ethernetif = netif->state;

  /* move received packet into a new pbuf */
  p = low_level_input(netif);
  /* no packet could be read, silently ignore this */
  if (p == NULL) return;
     3f8:	0001883a 	nop
     3fc:	00000106 	br	404 <ethernetif_input+0xd0>
    if (netif->input(p, netif)!=ERR_OK)
     { LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: IP input error\n"));
       pbuf_free(p);
       p = NULL;
     }
    break;
     400:	0001883a 	nop
  default:
    pbuf_free(p);
    p = NULL;
    break;
  }
}
     404:	e037883a 	mov	sp,fp
     408:	dfc00117 	ldw	ra,4(sp)
     40c:	df000017 	ldw	fp,0(sp)
     410:	dec00204 	addi	sp,sp,8
     414:	f800283a 	ret

00000418 <ethernetif_init>:
 *         ERR_MEM if private data couldn't be allocated
 *         any other err_t on error
 */
err_t
ethernetif_init(struct netif *netif)
{
     418:	defffa04 	addi	sp,sp,-24
     41c:	dfc00515 	stw	ra,20(sp)
     420:	df000415 	stw	fp,16(sp)
     424:	df000404 	addi	fp,sp,16
     428:	e13fff15 	stw	r4,-4(fp)
  int idx;
  struct pbuf *p;
  struct ethernetif *ethernetif;
  err_t tse_mac_raw_send(struct netif *netif, struct pbuf *p);  

  LWIP_ASSERT("netif != NULL", (netif != NULL));
     42c:	e0bfff17 	ldw	r2,-4(fp)
     430:	1000091e 	bne	r2,zero,458 <ethernetif_init+0x40>
     434:	010000f4 	movhi	r4,3
     438:	2133cb04 	addi	r4,r4,-12500
     43c:	014000f4 	movhi	r5,3
     440:	2973f404 	addi	r5,r5,-12336
     444:	01803144 	movi	r6,197
     448:	01c000f4 	movhi	r7,3
     44c:	39f3e004 	addi	r7,r7,-12416
     450:	00170680 	call	17068 <printf>
     454:	003fff06 	br	454 <ethernetif_init+0x3c>
    
  ethernetif = mem_malloc(sizeof(struct ethernetif));
     458:	01001704 	movi	r4,92
     45c:	00088ec0 	call	88ec <mem_malloc>
     460:	e0bffd15 	stw	r2,-12(fp)
  if (ethernetif == NULL) {
     464:	e0bffd17 	ldw	r2,-12(fp)
     468:	1000021e 	bne	r2,zero,474 <ethernetif_init+0x5c>
    LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_init: out of memory\n"));
    return ERR_MEM;
     46c:	00bfffc4 	movi	r2,-1
     470:	00004206 	br	57c <ethernetif_init+0x164>
   * The last argument should be replaced with your link speed, in units
   * of bits per second.
   */
  NETIF_INIT_SNMP(netif, snmp_ifType_ethernet_csmacd, LINK_SPEED_OF_YOUR_NETIF_IN_BPS);

  netif->state = ethernetif;
     474:	e0bfff17 	ldw	r2,-4(fp)
     478:	e0fffd17 	ldw	r3,-12(fp)
     47c:	10c00715 	stw	r3,28(r2)
  netif->name[0] = IFNAME0;
     480:	e0bfff17 	ldw	r2,-4(fp)
     484:	00c01944 	movi	r3,101
     488:	10c00b85 	stb	r3,46(r2)
  netif->name[1] = IFNAME1;
     48c:	e0bfff17 	ldw	r2,-4(fp)
     490:	00c01b84 	movi	r3,110
     494:	10c00bc5 	stb	r3,47(r2)
  /* We directly use etharp_output() here to save a function call.
   * You can instead declare your own function an call etharp_output()
   * from it if you have to do some checks before sending (e.g. if link
   * is available...) */
  netif->output = etharp_output;
     498:	e0bfff17 	ldw	r2,-4(fp)
     49c:	00c00074 	movhi	r3,1
     4a0:	18d81d04 	addi	r3,r3,24692
     4a4:	10c00515 	stw	r3,20(r2)
  netif->linkoutput = tse_mac_raw_send;
     4a8:	e0bfff17 	ldw	r2,-4(fp)
     4ac:	00c00034 	movhi	r3,0
     4b0:	18c58b04 	addi	r3,r3,5676
     4b4:	10c00615 	stw	r3,24(r2)
  
  ethernetif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
     4b8:	e0bfff17 	ldw	r2,-4(fp)
     4bc:	10c009c4 	addi	r3,r2,39
     4c0:	e0bffd17 	ldw	r2,-12(fp)
     4c4:	10c00015 	stw	r3,0(r2)
  
  /* initialize the rx buffer for access by the TSE ISR */
  for(idx = 0; idx < LWIP_RX_ETH_BUFFER; ++idx)
     4c8:	e03ffc15 	stw	zero,-16(fp)
     4cc:	00001f06 	br	54c <ethernetif_init+0x134>
    {
    p = pbuf_alloc(PBUF_RAW, PBUF_POOL_BUFSIZE, PBUF_POOL);
     4d0:	010000c4 	movi	r4,3
     4d4:	01417b04 	movi	r5,1516
     4d8:	018000c4 	movi	r6,3
     4dc:	00097cc0 	call	97cc <pbuf_alloc>
     4e0:	e0bffe15 	stw	r2,-8(fp)
    if (p == NULL)
     4e4:	e0bffe17 	ldw	r2,-8(fp)
     4e8:	1000021e 	bne	r2,zero,4f4 <ethernetif_init+0xdc>
      return ERR_MEM;
     4ec:	00bfffc4 	movi	r2,-1
     4f0:	00002206 	br	57c <ethernetif_init+0x164>
    p = (void *) alt_remap_uncached(p,sizeof *p);
     4f4:	e13ffe17 	ldw	r4,-8(fp)
     4f8:	01400404 	movi	r5,16
     4fc:	0020e5c0 	call	20e5c <alt_remap_uncached>
     500:	e0bffe15 	stw	r2,-8(fp)
    p->payload = (void *) alt_remap_uncached(p->payload,PBUF_POOL_BUFSIZE);
     504:	e0bffe17 	ldw	r2,-8(fp)
     508:	10800117 	ldw	r2,4(r2)
     50c:	1009883a 	mov	r4,r2
     510:	01417b04 	movi	r5,1516
     514:	0020e5c0 	call	20e5c <alt_remap_uncached>
     518:	e0fffe17 	ldw	r3,-8(fp)
     51c:	18800115 	stw	r2,4(r3)
    ethernetif->lwipRxPbuf[idx] = p;
     520:	e0fffd17 	ldw	r3,-12(fp)
     524:	e0bffc17 	ldw	r2,-16(fp)
     528:	108001c4 	addi	r2,r2,7
     52c:	1085883a 	add	r2,r2,r2
     530:	1085883a 	add	r2,r2,r2
     534:	1885883a 	add	r2,r3,r2
     538:	e0fffe17 	ldw	r3,-8(fp)
     53c:	10c00015 	stw	r3,0(r2)
  netif->linkoutput = tse_mac_raw_send;
  
  ethernetif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
  
  /* initialize the rx buffer for access by the TSE ISR */
  for(idx = 0; idx < LWIP_RX_ETH_BUFFER; ++idx)
     540:	e0bffc17 	ldw	r2,-16(fp)
     544:	10800044 	addi	r2,r2,1
     548:	e0bffc15 	stw	r2,-16(fp)
     54c:	e0bffc17 	ldw	r2,-16(fp)
     550:	10800310 	cmplti	r2,r2,12
     554:	103fde1e 	bne	r2,zero,4d0 <ethernetif_init+0xb8>
      return ERR_MEM;
    p = (void *) alt_remap_uncached(p,sizeof *p);
    p->payload = (void *) alt_remap_uncached(p->payload,PBUF_POOL_BUFSIZE);
    ethernetif->lwipRxPbuf[idx] = p;
    }
  ethernetif->lwipRxCount = 0;
     558:	e0bffd17 	ldw	r2,-12(fp)
     55c:	10001515 	stw	zero,84(r2)
  ethernetif->lwipRxIndex = 0;
     560:	e0bffd17 	ldw	r2,-12(fp)
     564:	10001415 	stw	zero,80(r2)
  ethernetif->lwipRxIndexIsr = 0;
     568:	e0bffd17 	ldw	r2,-12(fp)
     56c:	10001315 	stw	zero,76(r2)
                  
  /* initialize the low level hardware */
  low_level_init(netif);
     570:	e13fff17 	ldw	r4,-4(fp)
     574:	000009c0 	call	9c <low_level_init>
  return ERR_OK;
     578:	0005883a 	mov	r2,zero
}
     57c:	e037883a 	mov	sp,fp
     580:	dfc00117 	ldw	ra,4(sp)
     584:	df000017 	ldw	fp,0(sp)
     588:	dec00204 	addi	sp,sp,8
     58c:	f800283a 	ret

00000590 <fs_open>:


/*-----------------------------------------------------------------------------------*/
int
fs_open(const char *name, struct fs_file *file)
{
     590:	defffb04 	addi	sp,sp,-20
     594:	dfc00415 	stw	ra,16(sp)
     598:	df000315 	stw	fp,12(sp)
     59c:	df000304 	addi	fp,sp,12
     5a0:	e13ffe15 	stw	r4,-8(fp)
     5a4:	e17fff15 	stw	r5,-4(fp)
  const struct fsdata_file *f;

  for(f = FS_ROOT;
     5a8:	008000f4 	movhi	r2,3
     5ac:	10b71404 	addi	r2,r2,-9136
     5b0:	e0bffd15 	stw	r2,-12(fp)
     5b4:	00001306 	br	604 <fs_open+0x74>
      f != NULL;
      f = f->next) {
    if (!strcmp(name, (const char*)f->name)) {
     5b8:	e0bffd17 	ldw	r2,-12(fp)
     5bc:	10800117 	ldw	r2,4(r2)
     5c0:	e13ffe17 	ldw	r4,-8(fp)
     5c4:	100b883a 	mov	r5,r2
     5c8:	001730c0 	call	1730c <strcmp>
     5cc:	10000a1e 	bne	r2,zero,5f8 <fs_open+0x68>
      file->data = f->data;
     5d0:	e0bffd17 	ldw	r2,-12(fp)
     5d4:	10c00217 	ldw	r3,8(r2)
     5d8:	e0bfff17 	ldw	r2,-4(fp)
     5dc:	10c00015 	stw	r3,0(r2)
      file->len = f->len;
     5e0:	e0bffd17 	ldw	r2,-12(fp)
     5e4:	10c00317 	ldw	r3,12(r2)
     5e8:	e0bfff17 	ldw	r2,-4(fp)
     5ec:	10c00115 	stw	r3,4(r2)
      return 1;
     5f0:	00800044 	movi	r2,1
     5f4:	00000606 	br	610 <fs_open+0x80>
{
  const struct fsdata_file *f;

  for(f = FS_ROOT;
      f != NULL;
      f = f->next) {
     5f8:	e0bffd17 	ldw	r2,-12(fp)
     5fc:	10800017 	ldw	r2,0(r2)
     600:	e0bffd15 	stw	r2,-12(fp)
int
fs_open(const char *name, struct fs_file *file)
{
  const struct fsdata_file *f;

  for(f = FS_ROOT;
     604:	e0bffd17 	ldw	r2,-12(fp)
     608:	103feb1e 	bne	r2,zero,5b8 <fs_open+0x28>
      file->data = f->data;
      file->len = f->len;
      return 1;
    }
  }
  return 0;
     60c:	0005883a 	mov	r2,zero
}
     610:	e037883a 	mov	sp,fp
     614:	dfc00117 	ldw	ra,4(sp)
     618:	df000017 	ldw	fp,0(sp)
     61c:	dec00204 	addi	sp,sp,8
     620:	f800283a 	ret

00000624 <conn_err>:
};

/*-----------------------------------------------------------------------------------*/
static void
conn_err(void *arg, err_t err)
{
     624:	defffb04 	addi	sp,sp,-20
     628:	dfc00415 	stw	ra,16(sp)
     62c:	df000315 	stw	fp,12(sp)
     630:	df000304 	addi	fp,sp,12
     634:	e13ffe15 	stw	r4,-8(fp)
     638:	2805883a 	mov	r2,r5
     63c:	e0bfff05 	stb	r2,-4(fp)
  struct http_state *hs;

  LWIP_UNUSED_ARG(err);

  hs = arg;
     640:	e0bffe17 	ldw	r2,-8(fp)
     644:	e0bffd15 	stw	r2,-12(fp)
  mem_free(hs);
     648:	e13ffd17 	ldw	r4,-12(fp)
     64c:	00084480 	call	8448 <mem_free>
}
     650:	e037883a 	mov	sp,fp
     654:	dfc00117 	ldw	ra,4(sp)
     658:	df000017 	ldw	fp,0(sp)
     65c:	dec00204 	addi	sp,sp,8
     660:	f800283a 	ret

00000664 <close_conn>:
/*-----------------------------------------------------------------------------------*/
static void
close_conn(struct tcp_pcb *pcb, struct http_state *hs)
{
     664:	defffc04 	addi	sp,sp,-16
     668:	dfc00315 	stw	ra,12(sp)
     66c:	df000215 	stw	fp,8(sp)
     670:	df000204 	addi	fp,sp,8
     674:	e13ffe15 	stw	r4,-8(fp)
     678:	e17fff15 	stw	r5,-4(fp)
  tcp_arg(pcb, NULL);
     67c:	e13ffe17 	ldw	r4,-8(fp)
     680:	000b883a 	mov	r5,zero
     684:	000cfc80 	call	cfc8 <tcp_arg>
  tcp_sent(pcb, NULL);
     688:	e13ffe17 	ldw	r4,-8(fp)
     68c:	000b883a 	mov	r5,zero
     690:	000d0280 	call	d028 <tcp_sent>
  tcp_recv(pcb, NULL);
     694:	e13ffe17 	ldw	r4,-8(fp)
     698:	000b883a 	mov	r5,zero
     69c:	000cff80 	call	cff8 <tcp_recv>
  mem_free(hs);
     6a0:	e13fff17 	ldw	r4,-4(fp)
     6a4:	00084480 	call	8448 <mem_free>
  tcp_close(pcb);
     6a8:	e13ffe17 	ldw	r4,-8(fp)
     6ac:	000b2940 	call	b294 <tcp_close>
}
     6b0:	e037883a 	mov	sp,fp
     6b4:	dfc00117 	ldw	ra,4(sp)
     6b8:	df000017 	ldw	fp,0(sp)
     6bc:	dec00204 	addi	sp,sp,8
     6c0:	f800283a 	ret

000006c4 <send_data>:
/*-----------------------------------------------------------------------------------*/
static void
send_data(struct tcp_pcb *pcb, struct http_state *hs)
{
     6c4:	defffa04 	addi	sp,sp,-24
     6c8:	dfc00515 	stw	ra,20(sp)
     6cc:	df000415 	stw	fp,16(sp)
     6d0:	df000404 	addi	fp,sp,16
     6d4:	e13ffe15 	stw	r4,-8(fp)
     6d8:	e17fff15 	stw	r5,-4(fp)
  err_t err;
  u32_t len;

  /* We cannot send more data than space available in the send
     buffer. */     
  if (tcp_sndbuf(pcb) < hs->left) {
     6dc:	e0bffe17 	ldw	r2,-8(fp)
     6e0:	10801c8b 	ldhu	r2,114(r2)
     6e4:	10ffffcc 	andi	r3,r2,65535
     6e8:	e0bfff17 	ldw	r2,-4(fp)
     6ec:	10800017 	ldw	r2,0(r2)
     6f0:	1880052e 	bgeu	r3,r2,708 <send_data+0x44>
    len = tcp_sndbuf(pcb);
     6f4:	e0bffe17 	ldw	r2,-8(fp)
     6f8:	10801c8b 	ldhu	r2,114(r2)
     6fc:	10bfffcc 	andi	r2,r2,65535
     700:	e0bffc15 	stw	r2,-16(fp)
     704:	00000306 	br	714 <send_data+0x50>
  } else {
    len = hs->left;
     708:	e0bfff17 	ldw	r2,-4(fp)
     70c:	10800017 	ldw	r2,0(r2)
     710:	e0bffc15 	stw	r2,-16(fp)
    LWIP_ASSERT((len == hs->left), "hs->left did not fit into u16_t!");
  }

  do {
    err = tcp_write(pcb, hs->file, len, 0);
     714:	e0bfff17 	ldw	r2,-4(fp)
     718:	10c00117 	ldw	r3,4(r2)
     71c:	e0bffc17 	ldw	r2,-16(fp)
     720:	10bfffcc 	andi	r2,r2,65535
     724:	e13ffe17 	ldw	r4,-8(fp)
     728:	180b883a 	mov	r5,r3
     72c:	100d883a 	mov	r6,r2
     730:	000f883a 	mov	r7,zero
     734:	0011b980 	call	11b98 <tcp_write>
     738:	e0bffd05 	stb	r2,-12(fp)
    if (err == ERR_MEM) {
     73c:	e0bffd07 	ldb	r2,-12(fp)
     740:	10bfffd8 	cmpnei	r2,r2,-1
     744:	1000031e 	bne	r2,zero,754 <send_data+0x90>
      len /= 2;
     748:	e0bffc17 	ldw	r2,-16(fp)
     74c:	1004d07a 	srli	r2,r2,1
     750:	e0bffc15 	stw	r2,-16(fp)
    }
  } while (err == ERR_MEM && len > 1);  
     754:	e0bffd07 	ldb	r2,-12(fp)
     758:	10bfffd8 	cmpnei	r2,r2,-1
     75c:	1000031e 	bne	r2,zero,76c <send_data+0xa8>
     760:	e0bffc17 	ldw	r2,-16(fp)
     764:	108000a8 	cmpgeui	r2,r2,2
     768:	103fea1e 	bne	r2,zero,714 <send_data+0x50>
  
  if (err == ERR_OK) {
     76c:	e0bffd07 	ldb	r2,-12(fp)
     770:	10000c1e 	bne	r2,zero,7a4 <send_data+0xe0>
    hs->file += len;
     774:	e0bfff17 	ldw	r2,-4(fp)
     778:	10c00117 	ldw	r3,4(r2)
     77c:	e0bffc17 	ldw	r2,-16(fp)
     780:	1887883a 	add	r3,r3,r2
     784:	e0bfff17 	ldw	r2,-4(fp)
     788:	10c00115 	stw	r3,4(r2)
    hs->left -= len;
     78c:	e0bfff17 	ldw	r2,-4(fp)
     790:	10c00017 	ldw	r3,0(r2)
     794:	e0bffc17 	ldw	r2,-16(fp)
     798:	1887c83a 	sub	r3,r3,r2
     79c:	e0bfff17 	ldw	r2,-4(fp)
     7a0:	10c00015 	stw	r3,0(r2)
    /*  } else {
    printf("send_data: error %s len %d %d\n", lwip_strerr(err), len, tcp_sndbuf(pcb));*/
  }
}
     7a4:	e037883a 	mov	sp,fp
     7a8:	dfc00117 	ldw	ra,4(sp)
     7ac:	df000017 	ldw	fp,0(sp)
     7b0:	dec00204 	addi	sp,sp,8
     7b4:	f800283a 	ret

000007b8 <http_poll>:
/*-----------------------------------------------------------------------------------*/
static err_t
http_poll(void *arg, struct tcp_pcb *pcb)
{
     7b8:	defffb04 	addi	sp,sp,-20
     7bc:	dfc00415 	stw	ra,16(sp)
     7c0:	df000315 	stw	fp,12(sp)
     7c4:	df000304 	addi	fp,sp,12
     7c8:	e13ffe15 	stw	r4,-8(fp)
     7cc:	e17fff15 	stw	r5,-4(fp)
  struct http_state *hs;

  hs = arg;
     7d0:	e0bffe17 	ldw	r2,-8(fp)
     7d4:	e0bffd15 	stw	r2,-12(fp)
  
  /*  printf("Polll\n");*/
  if ((hs == NULL) && (pcb->state == ESTABLISHED)) {
     7d8:	e0bffd17 	ldw	r2,-12(fp)
     7dc:	1000091e 	bne	r2,zero,804 <http_poll+0x4c>
     7e0:	e0bfff17 	ldw	r2,-4(fp)
     7e4:	10800417 	ldw	r2,16(r2)
     7e8:	10800118 	cmpnei	r2,r2,4
     7ec:	1000051e 	bne	r2,zero,804 <http_poll+0x4c>
    /*    printf("Null, close\n");*/
    tcp_abort(pcb);
     7f0:	e13fff17 	ldw	r4,-4(fp)
     7f4:	01400044 	movi	r5,1
     7f8:	000b4a00 	call	b4a0 <tcp_abandon>
    return ERR_ABRT;
     7fc:	00bffec4 	movi	r2,-5
     800:	00001b06 	br	870 <http_poll+0xb8>
  } else if (hs != NULL) {
     804:	e0bffd17 	ldw	r2,-12(fp)
     808:	10001826 	beq	r2,zero,86c <http_poll+0xb4>
    ++hs->retries;
     80c:	e0bffd17 	ldw	r2,-12(fp)
     810:	10800203 	ldbu	r2,8(r2)
     814:	10800044 	addi	r2,r2,1
     818:	1007883a 	mov	r3,r2
     81c:	e0bffd17 	ldw	r2,-12(fp)
     820:	10c00205 	stb	r3,8(r2)
    if (hs->retries == 4) {
     824:	e0bffd17 	ldw	r2,-12(fp)
     828:	10800203 	ldbu	r2,8(r2)
     82c:	10803fcc 	andi	r2,r2,255
     830:	10800118 	cmpnei	r2,r2,4
     834:	10000a1e 	bne	r2,zero,860 <http_poll+0xa8>
      tcp_arg(pcb, NULL);
     838:	e13fff17 	ldw	r4,-4(fp)
     83c:	000b883a 	mov	r5,zero
     840:	000cfc80 	call	cfc8 <tcp_arg>
      mem_free(hs);
     844:	e13ffd17 	ldw	r4,-12(fp)
     848:	00084480 	call	8448 <mem_free>
      tcp_abort(pcb);
     84c:	e13fff17 	ldw	r4,-4(fp)
     850:	01400044 	movi	r5,1
     854:	000b4a00 	call	b4a0 <tcp_abandon>
      return ERR_ABRT;
     858:	00bffec4 	movi	r2,-5
     85c:	00000406 	br	870 <http_poll+0xb8>
    }
    send_data(pcb, hs);
     860:	e13fff17 	ldw	r4,-4(fp)
     864:	e17ffd17 	ldw	r5,-12(fp)
     868:	00006c40 	call	6c4 <send_data>
  }

  return ERR_OK;
     86c:	0005883a 	mov	r2,zero
}
     870:	e037883a 	mov	sp,fp
     874:	dfc00117 	ldw	ra,4(sp)
     878:	df000017 	ldw	fp,0(sp)
     87c:	dec00204 	addi	sp,sp,8
     880:	f800283a 	ret

00000884 <http_sent>:
/*-----------------------------------------------------------------------------------*/
static err_t
http_sent(void *arg, struct tcp_pcb *pcb, u16_t len)
{
     884:	defffa04 	addi	sp,sp,-24
     888:	dfc00515 	stw	ra,20(sp)
     88c:	df000415 	stw	fp,16(sp)
     890:	df000404 	addi	fp,sp,16
     894:	e13ffd15 	stw	r4,-12(fp)
     898:	e17ffe15 	stw	r5,-8(fp)
     89c:	3005883a 	mov	r2,r6
     8a0:	e0bfff0d 	sth	r2,-4(fp)
  struct http_state *hs;

  LWIP_UNUSED_ARG(len);

  hs = arg;
     8a4:	e0bffd17 	ldw	r2,-12(fp)
     8a8:	e0bffc15 	stw	r2,-16(fp)

  hs->retries = 0;
     8ac:	e0bffc17 	ldw	r2,-16(fp)
     8b0:	10000205 	stb	zero,8(r2)
  
  if (hs->left > 0) {    
     8b4:	e0bffc17 	ldw	r2,-16(fp)
     8b8:	10800017 	ldw	r2,0(r2)
     8bc:	10000426 	beq	r2,zero,8d0 <http_sent+0x4c>
    send_data(pcb, hs);
     8c0:	e13ffe17 	ldw	r4,-8(fp)
     8c4:	e17ffc17 	ldw	r5,-16(fp)
     8c8:	00006c40 	call	6c4 <send_data>
     8cc:	00000306 	br	8dc <http_sent+0x58>
  } else {
    close_conn(pcb, hs);
     8d0:	e13ffe17 	ldw	r4,-8(fp)
     8d4:	e17ffc17 	ldw	r5,-16(fp)
     8d8:	00006640 	call	664 <close_conn>
  }

  return ERR_OK;
     8dc:	0005883a 	mov	r2,zero
}
     8e0:	e037883a 	mov	sp,fp
     8e4:	dfc00117 	ldw	ra,4(sp)
     8e8:	df000017 	ldw	fp,0(sp)
     8ec:	dec00204 	addi	sp,sp,8
     8f0:	f800283a 	ret

000008f4 <http_recv>:
/*-----------------------------------------------------------------------------------*/
static err_t
http_recv(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
     8f4:	defff504 	addi	sp,sp,-44
     8f8:	dfc00a15 	stw	ra,40(sp)
     8fc:	df000915 	stw	fp,36(sp)
     900:	df000904 	addi	fp,sp,36
     904:	e13ffc15 	stw	r4,-16(fp)
     908:	e17ffd15 	stw	r5,-12(fp)
     90c:	e1bffe15 	stw	r6,-8(fp)
     910:	3805883a 	mov	r2,r7
     914:	e0bfff05 	stb	r2,-4(fp)
  int i;
  char *data;
  struct fs_file file;
  struct http_state *hs;

  hs = arg;
     918:	e0bffc17 	ldw	r2,-16(fp)
     91c:	e0bff815 	stw	r2,-32(fp)

  if (err == ERR_OK && p != NULL) {
     920:	e0bfff07 	ldb	r2,-4(fp)
     924:	1000791e 	bne	r2,zero,b0c <http_recv+0x218>
     928:	e0bffe17 	ldw	r2,-8(fp)
     92c:	10007726 	beq	r2,zero,b0c <http_recv+0x218>

    /* Inform TCP that we have taken the data. */
    tcp_recved(pcb, p->tot_len);
     930:	e0bffe17 	ldw	r2,-8(fp)
     934:	1080020b 	ldhu	r2,8(r2)
     938:	10bfffcc 	andi	r2,r2,65535
     93c:	e13ffd17 	ldw	r4,-12(fp)
     940:	100b883a 	mov	r5,r2
     944:	000bbfc0 	call	bbfc <tcp_recved>
    
    if (hs->file == NULL) {
     948:	e0bff817 	ldw	r2,-32(fp)
     94c:	10800117 	ldw	r2,4(r2)
     950:	10006c1e 	bne	r2,zero,b04 <http_recv+0x210>
      data = p->payload;
     954:	e0bffe17 	ldw	r2,-8(fp)
     958:	10800117 	ldw	r2,4(r2)
     95c:	e0bff915 	stw	r2,-28(fp)
      
      if (strncmp(data, "GET ", 4) == 0) {
     960:	e13ff917 	ldw	r4,-28(fp)
     964:	014000f4 	movhi	r5,3
     968:	29771804 	addi	r5,r5,-9120
     96c:	01800104 	movi	r6,4
     970:	001743c0 	call	1743c <strncmp>
     974:	10005d1e 	bne	r2,zero,aec <http_recv+0x1f8>
        for(i = 0; i < 40; i++) {
     978:	e03ff715 	stw	zero,-36(fp)
     97c:	00002606 	br	a18 <http_recv+0x124>
          if (((char *)data + 4)[i] == ' ' ||
     980:	e0bff717 	ldw	r2,-36(fp)
     984:	10800104 	addi	r2,r2,4
     988:	e0fff917 	ldw	r3,-28(fp)
     98c:	1885883a 	add	r2,r3,r2
     990:	10800003 	ldbu	r2,0(r2)
     994:	10803fcc 	andi	r2,r2,255
     998:	1080201c 	xori	r2,r2,128
     99c:	10bfe004 	addi	r2,r2,-128
     9a0:	10800820 	cmpeqi	r2,r2,32
     9a4:	1000141e 	bne	r2,zero,9f8 <http_recv+0x104>
             ((char *)data + 4)[i] == '\r' ||
     9a8:	e0bff717 	ldw	r2,-36(fp)
     9ac:	10800104 	addi	r2,r2,4
     9b0:	e0fff917 	ldw	r3,-28(fp)
     9b4:	1885883a 	add	r2,r3,r2
     9b8:	10800003 	ldbu	r2,0(r2)
    if (hs->file == NULL) {
      data = p->payload;
      
      if (strncmp(data, "GET ", 4) == 0) {
        for(i = 0; i < 40; i++) {
          if (((char *)data + 4)[i] == ' ' ||
     9bc:	10803fcc 	andi	r2,r2,255
     9c0:	1080201c 	xori	r2,r2,128
     9c4:	10bfe004 	addi	r2,r2,-128
     9c8:	10800360 	cmpeqi	r2,r2,13
     9cc:	10000a1e 	bne	r2,zero,9f8 <http_recv+0x104>
             ((char *)data + 4)[i] == '\r' ||
             ((char *)data + 4)[i] == '\n') {
     9d0:	e0bff717 	ldw	r2,-36(fp)
     9d4:	10800104 	addi	r2,r2,4
     9d8:	e0fff917 	ldw	r3,-28(fp)
     9dc:	1885883a 	add	r2,r3,r2
     9e0:	10800003 	ldbu	r2,0(r2)
      data = p->payload;
      
      if (strncmp(data, "GET ", 4) == 0) {
        for(i = 0; i < 40; i++) {
          if (((char *)data + 4)[i] == ' ' ||
             ((char *)data + 4)[i] == '\r' ||
     9e4:	10803fcc 	andi	r2,r2,255
     9e8:	1080201c 	xori	r2,r2,128
     9ec:	10bfe004 	addi	r2,r2,-128
     9f0:	10800298 	cmpnei	r2,r2,10
     9f4:	1000051e 	bne	r2,zero,a0c <http_recv+0x118>
             ((char *)data + 4)[i] == '\n') {
            ((char *)data + 4)[i] = 0;
     9f8:	e0bff717 	ldw	r2,-36(fp)
     9fc:	10800104 	addi	r2,r2,4
     a00:	e0fff917 	ldw	r3,-28(fp)
     a04:	1885883a 	add	r2,r3,r2
     a08:	10000005 	stb	zero,0(r2)
    
    if (hs->file == NULL) {
      data = p->payload;
      
      if (strncmp(data, "GET ", 4) == 0) {
        for(i = 0; i < 40; i++) {
     a0c:	e0bff717 	ldw	r2,-36(fp)
     a10:	10800044 	addi	r2,r2,1
     a14:	e0bff715 	stw	r2,-36(fp)
     a18:	e0bff717 	ldw	r2,-36(fp)
     a1c:	10800a10 	cmplti	r2,r2,40
     a20:	103fd71e 	bne	r2,zero,980 <http_recv+0x8c>
             ((char *)data + 4)[i] == '\n') {
            ((char *)data + 4)[i] = 0;
          }
        }

        if (*(char *)(data + 4) == '/' &&
     a24:	e0bff917 	ldw	r2,-28(fp)
     a28:	10800104 	addi	r2,r2,4
     a2c:	10800003 	ldbu	r2,0(r2)
     a30:	10803fcc 	andi	r2,r2,255
     a34:	1080201c 	xori	r2,r2,128
     a38:	10bfe004 	addi	r2,r2,-128
     a3c:	10800bd8 	cmpnei	r2,r2,47
     a40:	10000d1e 	bne	r2,zero,a78 <http_recv+0x184>
           *(char *)(data + 5) == 0) {
     a44:	e0bff917 	ldw	r2,-28(fp)
     a48:	10800144 	addi	r2,r2,5
     a4c:	10800003 	ldbu	r2,0(r2)
             ((char *)data + 4)[i] == '\n') {
            ((char *)data + 4)[i] = 0;
          }
        }

        if (*(char *)(data + 4) == '/' &&
     a50:	10803fcc 	andi	r2,r2,255
     a54:	1080201c 	xori	r2,r2,128
     a58:	10bfe004 	addi	r2,r2,-128
     a5c:	1000061e 	bne	r2,zero,a78 <http_recv+0x184>
           *(char *)(data + 5) == 0) {
          fs_open("/index.html", &file);
     a60:	e0bffa04 	addi	r2,fp,-24
     a64:	010000f4 	movhi	r4,3
     a68:	21371a04 	addi	r4,r4,-9112
     a6c:	100b883a 	mov	r5,r2
     a70:	00005900 	call	590 <fs_open>
     a74:	00000c06 	br	aa8 <http_recv+0x1b4>
        } else if (!fs_open((char *)data + 4, &file)) {
     a78:	e0bff917 	ldw	r2,-28(fp)
     a7c:	10c00104 	addi	r3,r2,4
     a80:	e0bffa04 	addi	r2,fp,-24
     a84:	1809883a 	mov	r4,r3
     a88:	100b883a 	mov	r5,r2
     a8c:	00005900 	call	590 <fs_open>
     a90:	1000051e 	bne	r2,zero,aa8 <http_recv+0x1b4>
          fs_open("/404.html", &file);
     a94:	e0bffa04 	addi	r2,fp,-24
     a98:	010000f4 	movhi	r4,3
     a9c:	21371d04 	addi	r4,r4,-9100
     aa0:	100b883a 	mov	r5,r2
     aa4:	00005900 	call	590 <fs_open>
        }

        hs->file = file.data;
     aa8:	e0fffa17 	ldw	r3,-24(fp)
     aac:	e0bff817 	ldw	r2,-32(fp)
     ab0:	10c00115 	stw	r3,4(r2)
        LWIP_ASSERT((file.len >= 0), "File length must be positive!");
        hs->left = file.len;
     ab4:	e0bffb17 	ldw	r2,-20(fp)
     ab8:	1007883a 	mov	r3,r2
     abc:	e0bff817 	ldw	r2,-32(fp)
     ac0:	10c00015 	stw	r3,0(r2)
        /* printf("data %p len %ld\n", hs->file, hs->left);*/

        pbuf_free(p);
     ac4:	e13ffe17 	ldw	r4,-8(fp)
     ac8:	000a1880 	call	a188 <pbuf_free>
        send_data(pcb, hs);
     acc:	e13ffd17 	ldw	r4,-12(fp)
     ad0:	e17ff817 	ldw	r5,-32(fp)
     ad4:	00006c40 	call	6c4 <send_data>

        /* Tell TCP that we wish be to informed of data that has been
           successfully sent by a call to the http_sent() function. */
        tcp_sent(pcb, http_sent);
     ad8:	e13ffd17 	ldw	r4,-12(fp)
     adc:	01400034 	movhi	r5,0
     ae0:	29422104 	addi	r5,r5,2180
     ae4:	000d0280 	call	d028 <tcp_sent>
     ae8:	00000806 	br	b0c <http_recv+0x218>
      } else {
        pbuf_free(p);
     aec:	e13ffe17 	ldw	r4,-8(fp)
     af0:	000a1880 	call	a188 <pbuf_free>
        close_conn(pcb, hs);
     af4:	e13ffd17 	ldw	r4,-12(fp)
     af8:	e17ff817 	ldw	r5,-32(fp)
     afc:	00006640 	call	664 <close_conn>
     b00:	00000206 	br	b0c <http_recv+0x218>
      }
    } else {
      pbuf_free(p);
     b04:	e13ffe17 	ldw	r4,-8(fp)
     b08:	000a1880 	call	a188 <pbuf_free>
    }
  }

  if (err == ERR_OK && p == NULL) {
     b0c:	e0bfff07 	ldb	r2,-4(fp)
     b10:	1000051e 	bne	r2,zero,b28 <http_recv+0x234>
     b14:	e0bffe17 	ldw	r2,-8(fp)
     b18:	1000031e 	bne	r2,zero,b28 <http_recv+0x234>
    close_conn(pcb, hs);
     b1c:	e13ffd17 	ldw	r4,-12(fp)
     b20:	e17ff817 	ldw	r5,-32(fp)
     b24:	00006640 	call	664 <close_conn>
  }
  return ERR_OK;
     b28:	0005883a 	mov	r2,zero
}
     b2c:	e037883a 	mov	sp,fp
     b30:	dfc00117 	ldw	ra,4(sp)
     b34:	df000017 	ldw	fp,0(sp)
     b38:	dec00204 	addi	sp,sp,8
     b3c:	f800283a 	ret

00000b40 <http_accept>:
/*-----------------------------------------------------------------------------------*/
static err_t
http_accept(void *arg, struct tcp_pcb *pcb, err_t err)
{
     b40:	defff904 	addi	sp,sp,-28
     b44:	dfc00615 	stw	ra,24(sp)
     b48:	df000515 	stw	fp,20(sp)
     b4c:	df000504 	addi	fp,sp,20
     b50:	e13ffd15 	stw	r4,-12(fp)
     b54:	e17ffe15 	stw	r5,-8(fp)
     b58:	3005883a 	mov	r2,r6
     b5c:	e0bfff05 	stb	r2,-4(fp)
  struct http_state *hs;
  struct tcp_pcb_listen *lpcb = (struct tcp_pcb_listen*)arg;
     b60:	e0bffd17 	ldw	r2,-12(fp)
     b64:	e0bffb15 	stw	r2,-20(fp)
  LWIP_UNUSED_ARG(err);

  /* Decrease the listen backlog counter */
  tcp_accepted(lpcb);

  tcp_setprio(pcb, TCP_PRIO_MIN);
     b68:	e13ffe17 	ldw	r4,-8(fp)
     b6c:	01400044 	movi	r5,1
     b70:	000cb080 	call	cb08 <tcp_setprio>
  
  /* Allocate memory for the structure that holds the state of the
     connection. */
  hs = (struct http_state *)mem_malloc(sizeof(struct http_state));
     b74:	01000304 	movi	r4,12
     b78:	00088ec0 	call	88ec <mem_malloc>
     b7c:	e0bffc15 	stw	r2,-16(fp)

  if (hs == NULL) {
     b80:	e0bffc17 	ldw	r2,-16(fp)
     b84:	1000051e 	bne	r2,zero,b9c <http_accept+0x5c>
    printf("http_accept: Out of memory\n");
     b88:	010000f4 	movhi	r4,3
     b8c:	21372004 	addi	r4,r4,-9088
     b90:	00172f80 	call	172f8 <puts>
    return ERR_MEM;
     b94:	00bfffc4 	movi	r2,-1
     b98:	00001706 	br	bf8 <http_accept+0xb8>
  }
  
  /* Initialize the structure. */
  hs->file = NULL;
     b9c:	e0bffc17 	ldw	r2,-16(fp)
     ba0:	10000115 	stw	zero,4(r2)
  hs->left = 0;
     ba4:	e0bffc17 	ldw	r2,-16(fp)
     ba8:	10000015 	stw	zero,0(r2)
  hs->retries = 0;
     bac:	e0bffc17 	ldw	r2,-16(fp)
     bb0:	10000205 	stb	zero,8(r2)
  
  /* Tell TCP that this is the structure we wish to be passed for our
     callbacks. */
  tcp_arg(pcb, hs);
     bb4:	e13ffe17 	ldw	r4,-8(fp)
     bb8:	e17ffc17 	ldw	r5,-16(fp)
     bbc:	000cfc80 	call	cfc8 <tcp_arg>

  /* Tell TCP that we wish to be informed of incoming data by a call
     to the http_recv() function. */
  tcp_recv(pcb, http_recv);
     bc0:	e13ffe17 	ldw	r4,-8(fp)
     bc4:	01400034 	movhi	r5,0
     bc8:	29423d04 	addi	r5,r5,2292
     bcc:	000cff80 	call	cff8 <tcp_recv>

  tcp_err(pcb, conn_err);
     bd0:	e13ffe17 	ldw	r4,-8(fp)
     bd4:	01400034 	movhi	r5,0
     bd8:	29418904 	addi	r5,r5,1572
     bdc:	000d0580 	call	d058 <tcp_err>
  
  tcp_poll(pcb, http_poll, 4);
     be0:	e13ffe17 	ldw	r4,-8(fp)
     be4:	01400034 	movhi	r5,0
     be8:	2941ee04 	addi	r5,r5,1976
     bec:	01800104 	movi	r6,4
     bf0:	000d0b80 	call	d0b8 <tcp_poll>

  return ERR_OK;
     bf4:	0005883a 	mov	r2,zero
}
     bf8:	e037883a 	mov	sp,fp
     bfc:	dfc00117 	ldw	ra,4(sp)
     c00:	df000017 	ldw	fp,0(sp)
     c04:	dec00204 	addi	sp,sp,8
     c08:	f800283a 	ret

00000c0c <httpd_init>:
/*-----------------------------------------------------------------------------------*/
void
httpd_init(void)
{
     c0c:	defffd04 	addi	sp,sp,-12
     c10:	dfc00215 	stw	ra,8(sp)
     c14:	df000115 	stw	fp,4(sp)
     c18:	df000104 	addi	fp,sp,4
  struct tcp_pcb *pcb;

  pcb = tcp_new();
     c1c:	000cf9c0 	call	cf9c <tcp_new>
     c20:	e0bfff15 	stw	r2,-4(fp)
  tcp_bind(pcb, IP_ADDR_ANY, 80);
     c24:	e13fff17 	ldw	r4,-4(fp)
     c28:	014000f4 	movhi	r5,3
     c2c:	2950ed04 	addi	r5,r5,17332
     c30:	01801404 	movi	r6,80
     c34:	000b6340 	call	b634 <tcp_bind>
  pcb = tcp_listen(pcb);
     c38:	e13fff17 	ldw	r4,-4(fp)
     c3c:	01403fc4 	movi	r5,255
     c40:	000b94c0 	call	b94c <tcp_listen_with_backlog>
     c44:	e0bfff15 	stw	r2,-4(fp)
  tcp_arg(pcb, pcb);
     c48:	e13fff17 	ldw	r4,-4(fp)
     c4c:	e17fff17 	ldw	r5,-4(fp)
     c50:	000cfc80 	call	cfc8 <tcp_arg>
  tcp_accept(pcb, http_accept);
     c54:	e13fff17 	ldw	r4,-4(fp)
     c58:	01400034 	movhi	r5,0
     c5c:	2942d004 	addi	r5,r5,2880
     c60:	000d0880 	call	d088 <tcp_accept>
}
     c64:	e037883a 	mov	sp,fp
     c68:	dfc00117 	ldw	ra,4(sp)
     c6c:	df000017 	ldw	fp,0(sp)
     c70:	dec00204 	addi	sp,sp,8
     c74:	f800283a 	ret

00000c78 <tse_mac_init>:
 * @API TYPE: Internal
 * @Param iface index of the NET structure associated with TSE instance
 * @Return 0 if ok, else -1 if error
 */
int tse_mac_init(int iface, struct ethernetif *ethernetif)
{
     c78:	defff004 	addi	sp,sp,-64
     c7c:	dfc00f15 	stw	ra,60(sp)
     c80:	df000e15 	stw	fp,56(sp)
     c84:	df000e04 	addi	fp,sp,56
     c88:	e13ffe15 	stw	r4,-8(fp)
     c8c:	e17fff15 	stw	r5,-4(fp)
   int speed, duplex, result;
   int x;
   
   alt_sgdma_dev *sgdma_tx_dev;
   alt_sgdma_dev *sgdma_rx_dev;
   alt_tse_system_info* tse_hw = (alt_tse_system_info *) tse[iface].tse;
     c90:	00c00134 	movhi	r3,4
     c94:	18d12104 	addi	r3,r3,17540
     c98:	e0bffe17 	ldw	r2,-8(fp)
     c9c:	1004917a 	slli	r2,r2,5
     ca0:	1885883a 	add	r2,r3,r2
     ca4:	10800704 	addi	r2,r2,28
     ca8:	10800017 	ldw	r2,0(r2)
     cac:	e0bff715 	stw	r2,-36(fp)
   np_tse_mac *mi_base;
   alt_tse_mac_info *pmac_info;
   
   dprintf(("[tse_mac_init]\n"));
     cb0:	010000f4 	movhi	r4,3
     cb4:	21372704 	addi	r4,r4,-9060
     cb8:	00172f80 	call	172f8 <puts>
#ifdef PRINTIF
   dprintf(("tse_mac_init %d\n", iface));
#endif    
   // These lines were done in prep_tse_mac 
   tse_hw = &tse_mac_device[iface];	
     cbc:	e0bffe17 	ldw	r2,-8(fp)
     cc0:	10c01224 	muli	r3,r2,72
     cc4:	008000f4 	movhi	r2,3
     cc8:	10886204 	addi	r2,r2,8584
     ccc:	1885883a 	add	r2,r3,r2
     cd0:	e0bff715 	stw	r2,-36(fp)
   tse[iface].tse = tse_hw;
     cd4:	00c00134 	movhi	r3,4
     cd8:	18d12104 	addi	r3,r3,17540
     cdc:	e0bffe17 	ldw	r2,-8(fp)
     ce0:	1004917a 	slli	r2,r2,5
     ce4:	1885883a 	add	r2,r3,r2
     ce8:	10800704 	addi	r2,r2,28
     cec:	e0fff717 	ldw	r3,-36(fp)
     cf0:	10c00015 	stw	r3,0(r2)
	
   // Store ethernetif for access, and the tse in ethernetif for access in tse_mac_raw_send/tse_mac_rcv
   tse[iface].ethernetif = ethernetif;
     cf4:	00c00134 	movhi	r3,4
     cf8:	18d12104 	addi	r3,r3,17540
     cfc:	e0bffe17 	ldw	r2,-8(fp)
     d00:	1004917a 	slli	r2,r2,5
     d04:	1885883a 	add	r2,r3,r2
     d08:	10800604 	addi	r2,r2,24
     d0c:	e0ffff17 	ldw	r3,-4(fp)
     d10:	10c00015 	stw	r3,0(r2)
   ethernetif->iface = iface;
     d14:	e0bfff17 	ldw	r2,-4(fp)
     d18:	e0fffe17 	ldw	r3,-8(fp)
     d1c:	10c00115 	stw	r3,4(r2)
   ethernetif->tse_info = &tse[iface];
     d20:	e0bffe17 	ldw	r2,-8(fp)
     d24:	1006917a 	slli	r3,r2,5
     d28:	00800134 	movhi	r2,4
     d2c:	10912104 	addi	r2,r2,17540
     d30:	1887883a 	add	r3,r3,r2
     d34:	e0bfff17 	ldw	r2,-4(fp)
     d38:	10c01615 	stw	r3,88(r2)

   if (tse_hw->ext_desc_mem == 1)
     d3c:	e0bff717 	ldw	r2,-36(fp)
     d40:	10800783 	ldbu	r2,30(r2)
     d44:	10803fcc 	andi	r2,r2,255
     d48:	10800058 	cmpnei	r2,r2,1
     d4c:	10000b1e 	bne	r2,zero,d7c <tse_mac_init+0x104>
      tse[iface].desc = (alt_sgdma_descriptor *) tse_hw->desc_mem_base;
     d50:	e0bff717 	ldw	r2,-36(fp)
     d54:	10800817 	ldw	r2,32(r2)
     d58:	1007883a 	mov	r3,r2
     d5c:	01000134 	movhi	r4,4
     d60:	21112104 	addi	r4,r4,17540
     d64:	e0bffe17 	ldw	r2,-8(fp)
     d68:	1004917a 	slli	r2,r2,5
     d6c:	2085883a 	add	r2,r4,r2
     d70:	10800504 	addi	r2,r2,20
     d74:	10c00015 	stw	r3,0(r2)
     d78:	00001206 	br	dc4 <tse_mac_init+0x14c>
   else
      {
      unsigned char *temp_desc = (unsigned char *)alt_uncached_malloc((4+ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE)*(sizeof(alt_sgdma_descriptor)));
     d7c:	01002804 	movi	r4,160
     d80:	002116c0 	call	2116c <alt_uncached_malloc>
     d84:	e0bff615 	stw	r2,-40(fp)
    
      while ((((alt_u32)temp_desc) % ALTERA_AVALON_SGDMA_DESCRIPTOR_SIZE) != 0)
     d88:	00000306 	br	d98 <tse_mac_init+0x120>
         temp_desc++;
     d8c:	e0bff617 	ldw	r2,-40(fp)
     d90:	10800044 	addi	r2,r2,1
     d94:	e0bff615 	stw	r2,-40(fp)
      tse[iface].desc = (alt_sgdma_descriptor *) tse_hw->desc_mem_base;
   else
      {
      unsigned char *temp_desc = (unsigned char *)alt_uncached_malloc((4+ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE)*(sizeof(alt_sgdma_descriptor)));
    
      while ((((alt_u32)temp_desc) % ALTERA_AVALON_SGDMA_DESCRIPTOR_SIZE) != 0)
     d98:	e0bff617 	ldw	r2,-40(fp)
     d9c:	108007cc 	andi	r2,r2,31
     da0:	103ffa1e 	bne	r2,zero,d8c <tse_mac_init+0x114>
         temp_desc++;
      tse[iface].desc = (alt_sgdma_descriptor *) temp_desc;
     da4:	00c00134 	movhi	r3,4
     da8:	18d12104 	addi	r3,r3,17540
     dac:	e0bffe17 	ldw	r2,-8(fp)
     db0:	1004917a 	slli	r2,r2,5
     db4:	1885883a 	add	r2,r3,r2
     db8:	10800504 	addi	r2,r2,20
     dbc:	e0fff617 	ldw	r3,-40(fp)
     dc0:	10c00015 	stw	r3,0(r2)
      }

   
   /* Get the Rx and Tx SGDMA addresses */
   sgdma_tx_dev = alt_avalon_sgdma_open(tse_hw->tse_sgdma_tx);
     dc4:	e0bff717 	ldw	r2,-36(fp)
     dc8:	10800517 	ldw	r2,20(r2)
     dcc:	1009883a 	mov	r4,r2
     dd0:	00251cc0 	call	251cc <alt_avalon_sgdma_open>
     dd4:	e0bff815 	stw	r2,-32(fp)
   if(!sgdma_tx_dev) 
     dd8:	e0bff817 	ldw	r2,-32(fp)
     ddc:	1000051e 	bne	r2,zero,df4 <tse_mac_init+0x17c>
      {
      dprintf(("[triple_speed_ethernet_init] Error opening TX SGDMA\n"));
     de0:	010000f4 	movhi	r4,3
     de4:	21372b04 	addi	r4,r4,-9044
     de8:	00172f80 	call	172f8 <puts>
      return ENP_RESOURCE;
     dec:	00bffa84 	movi	r2,-22
     df0:	0001b606 	br	14cc <tse_mac_init+0x854>
      }
  
   sgdma_rx_dev = alt_avalon_sgdma_open(tse_hw->tse_sgdma_rx);
     df4:	e0bff717 	ldw	r2,-36(fp)
     df8:	10800617 	ldw	r2,24(r2)
     dfc:	1009883a 	mov	r4,r2
     e00:	00251cc0 	call	251cc <alt_avalon_sgdma_open>
     e04:	e0bff915 	stw	r2,-28(fp)
   if(!sgdma_rx_dev) 
     e08:	e0bff917 	ldw	r2,-28(fp)
     e0c:	1000051e 	bne	r2,zero,e24 <tse_mac_init+0x1ac>
      {
      dprintf(("[triple_speed_ethernet_init] Error opening RX SGDMA\n"));
     e10:	010000f4 	movhi	r4,3
     e14:	21373804 	addi	r4,r4,-8992
     e18:	00172f80 	call	172f8 <puts>
      return ENP_RESOURCE;
     e1c:	00bffa84 	movi	r2,-22
     e20:	0001aa06 	br	14cc <tse_mac_init+0x854>
      }


   /* Initialize mtip_mac_trans_info structure with values from <system.h>*/

   tse_mac_initTransInfo2(&tse[iface].mi, (int)tse_hw->tse_mac_base,
     e24:	e0bffe17 	ldw	r2,-8(fp)
     e28:	1006917a 	slli	r3,r2,5
     e2c:	00800134 	movhi	r2,4
     e30:	10912104 	addi	r2,r2,17540
     e34:	1889883a 	add	r4,r3,r2
     e38:	e0bff717 	ldw	r2,-36(fp)
     e3c:	11400017 	ldw	r5,0(r2)
     e40:	e0fff817 	ldw	r3,-32(fp)
     e44:	e0bff917 	ldw	r2,-28(fp)
     e48:	d8000015 	stw	zero,0(sp)
     e4c:	180d883a 	mov	r6,r3
     e50:	100f883a 	mov	r7,r2
     e54:	00259a40 	call	259a4 <tse_mac_initTransInfo2>
                                   (unsigned int)sgdma_tx_dev,            
                                   (unsigned int)sgdma_rx_dev,
                                   0);
   mi_base = tse[iface].mi.base;
     e58:	00c00134 	movhi	r3,4
     e5c:	18d12104 	addi	r3,r3,17540
     e60:	e0bffe17 	ldw	r2,-8(fp)
     e64:	1004917a 	slli	r2,r2,5
     e68:	1885883a 	add	r2,r3,r2
     e6c:	10800017 	ldw	r2,0(r2)
     e70:	e0bffa15 	stw	r2,-24(fp)

   IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma->base,ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
     e74:	00c00134 	movhi	r3,4
     e78:	18d12104 	addi	r3,r3,17540
     e7c:	e0bffe17 	ldw	r2,-8(fp)
     e80:	1004917a 	slli	r2,r2,5
     e84:	1885883a 	add	r2,r3,r2
     e88:	10800204 	addi	r2,r2,8
     e8c:	10800017 	ldw	r2,0(r2)
     e90:	10800317 	ldw	r2,12(r2)
     e94:	10800404 	addi	r2,r2,16
     e98:	00c00074 	movhi	r3,1
     e9c:	10c00035 	stwio	r3,0(r2)
   IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma->base, 0x0);
     ea0:	00c00134 	movhi	r3,4
     ea4:	18d12104 	addi	r3,r3,17540
     ea8:	e0bffe17 	ldw	r2,-8(fp)
     eac:	1004917a 	slli	r2,r2,5
     eb0:	1885883a 	add	r2,r3,r2
     eb4:	10800204 	addi	r2,r2,8
     eb8:	10800017 	ldw	r2,0(r2)
     ebc:	10800317 	ldw	r2,12(r2)
     ec0:	10800404 	addi	r2,r2,16
     ec4:	0007883a 	mov	r3,zero
     ec8:	10c00035 	stwio	r3,0(r2)
   
   /* reset the PHY if necessary */
   result = getPHYSpeed(tse[iface].mi.base);
     ecc:	00c00134 	movhi	r3,4
     ed0:	18d12104 	addi	r3,r3,17540
     ed4:	e0bffe17 	ldw	r2,-8(fp)
     ed8:	1004917a 	slli	r2,r2,5
     edc:	1885883a 	add	r2,r3,r2
     ee0:	10800017 	ldw	r2,0(r2)
     ee4:	1009883a 	mov	r4,r2
     ee8:	0026e240 	call	26e24 <getPHYSpeed>
     eec:	e0bffb15 	stw	r2,-20(fp)
   speed  = (result >> 1) & 0x07;
     ef0:	e0bffb17 	ldw	r2,-20(fp)
     ef4:	1005d07a 	srai	r2,r2,1
     ef8:	108001cc 	andi	r2,r2,7
     efc:	e0bffc15 	stw	r2,-16(fp)
   duplex = result & 0x01;
     f00:	e0bffb17 	ldw	r2,-20(fp)
     f04:	1080004c 	andi	r2,r2,1
     f08:	e0bff415 	stw	r2,-48(fp)

   /* reset the mac */ 
   IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base,
     f0c:	00c00134 	movhi	r3,4
     f10:	18d12104 	addi	r3,r3,17540
     f14:	e0bffe17 	ldw	r2,-8(fp)
     f18:	1004917a 	slli	r2,r2,5
     f1c:	1885883a 	add	r2,r3,r2
     f20:	10800017 	ldw	r2,0(r2)
     f24:	10800204 	addi	r2,r2,8
     f28:	00c800c4 	movi	r3,8195
     f2c:	10c00035 	stwio	r3,0(r2)
                             mmac_cc_SW_RESET_mask | 
                             mmac_cc_TX_ENA_mask | 
                             mmac_cc_RX_ENA_mask);
  
   x=0;
     f30:	e03ff515 	stw	zero,-44(fp)
   while(IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base) & 
     f34:	00000706 	br	f54 <tse_mac_init+0x2dc>
         ALTERA_TSEMAC_CMD_SW_RESET_MSK) 
      {
      if( x++ > 10000 ) 
     f38:	e0bff517 	ldw	r2,-44(fp)
     f3c:	1089c448 	cmpgei	r2,r2,10001
     f40:	e0fff517 	ldw	r3,-44(fp)
     f44:	18c00044 	addi	r3,r3,1
     f48:	e0fff515 	stw	r3,-44(fp)
     f4c:	10803fcc 	andi	r2,r2,255
     f50:	10000b1e 	bne	r2,zero,f80 <tse_mac_init+0x308>
                             mmac_cc_SW_RESET_mask | 
                             mmac_cc_TX_ENA_mask | 
                             mmac_cc_RX_ENA_mask);
  
   x=0;
   while(IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base) & 
     f54:	00c00134 	movhi	r3,4
     f58:	18d12104 	addi	r3,r3,17540
     f5c:	e0bffe17 	ldw	r2,-8(fp)
     f60:	1004917a 	slli	r2,r2,5
     f64:	1885883a 	add	r2,r3,r2
     f68:	10800017 	ldw	r2,0(r2)
     f6c:	10800204 	addi	r2,r2,8
     f70:	10800037 	ldwio	r2,0(r2)
     f74:	1088000c 	andi	r2,r2,8192
     f78:	103fef1e 	bne	r2,zero,f38 <tse_mac_init+0x2c0>
     f7c:	00000106 	br	f84 <tse_mac_init+0x30c>
         ALTERA_TSEMAC_CMD_SW_RESET_MSK) 
      {
      if( x++ > 10000 ) 
         break;
     f80:	0001883a 	nop
      }
  
   if(x >= 10000)
     f84:	e0bff517 	ldw	r2,-44(fp)
     f88:	1089c410 	cmplti	r2,r2,10000
     f8c:	1000031e 	bne	r2,zero,f9c <tse_mac_init+0x324>
      dprintf(("TSEMAC SW reset bit never cleared!\n"));
     f90:	010000f4 	movhi	r4,3
     f94:	21374504 	addi	r4,r4,-8940
     f98:	00172f80 	call	172f8 <puts>

   dat = IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base);
     f9c:	00c00134 	movhi	r3,4
     fa0:	18d12104 	addi	r3,r3,17540
     fa4:	e0bffe17 	ldw	r2,-8(fp)
     fa8:	1004917a 	slli	r2,r2,5
     fac:	1885883a 	add	r2,r3,r2
     fb0:	10800017 	ldw	r2,0(r2)
     fb4:	10800204 	addi	r2,r2,8
     fb8:	10800037 	ldwio	r2,0(r2)
     fbc:	e0bff315 	stw	r2,-52(fp)
   if( (dat & 0x03) != 0 ) 
     fc0:	e0bff317 	ldw	r2,-52(fp)
     fc4:	108000cc 	andi	r2,r2,3
     fc8:	10000526 	beq	r2,zero,fe0 <tse_mac_init+0x368>
      printf("WARN: RX/TX not disabled after reset... missing PHY clock? CMD_CONFIG=0x%08x\n", dat);
     fcc:	010000f4 	movhi	r4,3
     fd0:	21374e04 	addi	r4,r4,-8904
     fd4:	e17ff317 	ldw	r5,-52(fp)
     fd8:	00170680 	call	17068 <printf>
     fdc:	00000506 	br	ff4 <tse_mac_init+0x37c>
   else
      printf("OK, x=%d, CMD_CONFIG=0x%08x\n", x, dat);
     fe0:	010000f4 	movhi	r4,3
     fe4:	21376204 	addi	r4,r4,-8824
     fe8:	e17ff517 	ldw	r5,-44(fp)
     fec:	e1bff317 	ldw	r6,-52(fp)
     ff0:	00170680 	call	17068 <printf>
  
   /* Initialize MAC registers */
   IOWR_ALTERA_TSEMAC_FRM_LENGTH(mi_base, PBUF_POOL_BUFSIZE+ETH_PAD_SIZE); 
     ff4:	e0bffa17 	ldw	r2,-24(fp)
     ff8:	10800504 	addi	r2,r2,20
     ffc:	00c17b84 	movi	r3,1518
    1000:	10c00035 	stwio	r3,0(r2)
   IOWR_ALTERA_TSEMAC_RX_ALMOST_EMPTY(mi_base, 8);
    1004:	e0bffa17 	ldw	r2,-24(fp)
    1008:	10800b04 	addi	r2,r2,44
    100c:	00c00204 	movi	r3,8
    1010:	10c00035 	stwio	r3,0(r2)
   IOWR_ALTERA_TSEMAC_RX_ALMOST_FULL(mi_base, 8);
    1014:	e0bffa17 	ldw	r2,-24(fp)
    1018:	10800c04 	addi	r2,r2,48
    101c:	00c00204 	movi	r3,8
    1020:	10c00035 	stwio	r3,0(r2)
   IOWR_ALTERA_TSEMAC_TX_ALMOST_EMPTY(mi_base, 8);
    1024:	e0bffa17 	ldw	r2,-24(fp)
    1028:	10800d04 	addi	r2,r2,52
    102c:	00c00204 	movi	r3,8
    1030:	10c00035 	stwio	r3,0(r2)
   IOWR_ALTERA_TSEMAC_TX_ALMOST_FULL(mi_base,  3);
    1034:	e0bffa17 	ldw	r2,-24(fp)
    1038:	10800e04 	addi	r2,r2,56
    103c:	00c000c4 	movi	r3,3
    1040:	10c00035 	stwio	r3,0(r2)
   IOWR_ALTERA_TSEMAC_TX_SECTION_EMPTY(mi_base, tse_hw->tse_tx_depth - 16); //1024/4;  
    1044:	e0bffa17 	ldw	r2,-24(fp)
    1048:	10800904 	addi	r2,r2,36
    104c:	e0fff717 	ldw	r3,-36(fp)
    1050:	18c0010b 	ldhu	r3,4(r3)
    1054:	18ffffcc 	andi	r3,r3,65535
    1058:	18fffc04 	addi	r3,r3,-16
    105c:	10c00035 	stwio	r3,0(r2)
   IOWR_ALTERA_TSEMAC_TX_SECTION_FULL(mi_base,  0); //32/4; // start transmit when there are 48 bytes
    1060:	e0bffa17 	ldw	r2,-24(fp)
    1064:	10800a04 	addi	r2,r2,40
    1068:	0007883a 	mov	r3,zero
    106c:	10c00035 	stwio	r3,0(r2)
   IOWR_ALTERA_TSEMAC_RX_SECTION_EMPTY(mi_base, tse_hw->tse_rx_depth - 16); //4000/4);
    1070:	e0bffa17 	ldw	r2,-24(fp)
    1074:	10800704 	addi	r2,r2,28
    1078:	e0fff717 	ldw	r3,-36(fp)
    107c:	18c0018b 	ldhu	r3,6(r3)
    1080:	18ffffcc 	andi	r3,r3,65535
    1084:	18fffc04 	addi	r3,r3,-16
    1088:	10c00035 	stwio	r3,0(r2)
   IOWR_ALTERA_TSEMAC_RX_SECTION_FULL(mi_base,  0);
    108c:	e0bffa17 	ldw	r2,-24(fp)
    1090:	10800804 	addi	r2,r2,32
    1094:	0007883a 	mov	r3,zero
    1098:	10c00035 	stwio	r3,0(r2)
   
   /* Enable TX shift 16 for removing two bytes from the start of all transmitted frames */
   IOWR_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK);
    109c:	00c00134 	movhi	r3,4
    10a0:	18d12104 	addi	r3,r3,17540
    10a4:	e0bffe17 	ldw	r2,-8(fp)
    10a8:	1004917a 	slli	r2,r2,5
    10ac:	1885883a 	add	r2,r3,r2
    10b0:	10800017 	ldw	r2,0(r2)
    10b4:	10803a04 	addi	r2,r2,232
    10b8:	00c00134 	movhi	r3,4
    10bc:	10c00035 	stwio	r3,0(r2)
 
   /*
    * check if the MAC supports the 16-bit shift option allowing us
    * to send BIASed frames without copying. Used by the send function later.
    */
   if((IORD_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK) == 0)
    10c0:	00c00134 	movhi	r3,4
    10c4:	18d12104 	addi	r3,r3,17540
    10c8:	e0bffe17 	ldw	r2,-8(fp)
    10cc:	1004917a 	slli	r2,r2,5
    10d0:	1885883a 	add	r2,r3,r2
    10d4:	10800017 	ldw	r2,0(r2)
    10d8:	10803a04 	addi	r2,r2,232
    10dc:	10800037 	ldwio	r2,0(r2)
    10e0:	1080012c 	andhi	r2,r2,4
    10e4:	1000041e 	bne	r2,zero,10f8 <tse_mac_init+0x480>
      {
      dprintf(("[tse_mac_init] Error: Incompatible %d value with TX_CMD_STAT register return TxShift16 value. \n",ETH_PAD_SIZE));
    10e8:	01000084 	movi	r4,2
    10ec:	00170680 	call	17068 <printf>
      return ERR_IF;
    10f0:	00bffd04 	movi	r2,-12
    10f4:	0000f506 	br	14cc <tse_mac_init+0x854>
      }
  
   /* Enable RX shift 16 for alignment of all received frames on 16-bit start address */
   IOWR_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK);
    10f8:	00c00134 	movhi	r3,4
    10fc:	18d12104 	addi	r3,r3,17540
    1100:	e0bffe17 	ldw	r2,-8(fp)
    1104:	1004917a 	slli	r2,r2,5
    1108:	1885883a 	add	r2,r3,r2
    110c:	10800017 	ldw	r2,0(r2)
    1110:	10803b04 	addi	r2,r2,236
    1114:	00c08034 	movhi	r3,512
    1118:	10c00035 	stwio	r3,0(r2)
 
   /* check if the MAC supports the 16-bit shift option at the RX CMD STATUS Register  */ 
   if((IORD_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK) == 0)
    111c:	00c00134 	movhi	r3,4
    1120:	18d12104 	addi	r3,r3,17540
    1124:	e0bffe17 	ldw	r2,-8(fp)
    1128:	1004917a 	slli	r2,r2,5
    112c:	1885883a 	add	r2,r3,r2
    1130:	10800017 	ldw	r2,0(r2)
    1134:	10803b04 	addi	r2,r2,236
    1138:	10800037 	ldwio	r2,0(r2)
    113c:	1080802c 	andhi	r2,r2,512
    1140:	1000041e 	bne	r2,zero,1154 <tse_mac_init+0x4dc>
      {
      dprintf(("[tse_mac_init] Error: Incompatible %d value with RX_CMD_STAT register return RxShift16 value. \n",ETH_PAD_SIZE));
    1144:	01000084 	movi	r4,2
    1148:	00170680 	call	17068 <printf>
      return ERR_IF;
    114c:	00bffd04 	movi	r2,-12
    1150:	0000de06 	br	14cc <tse_mac_init+0x854>
      }
   
   /* enable MAC */
   dat = ALTERA_TSEMAC_CMD_TX_ENA_MSK       |
    1154:	00810034 	movhi	r2,1024
    1158:	108080c4 	addi	r2,r2,515
    115c:	e0bff315 	stw	r2,-52(fp)
         ALTERA_TSEMAC_CMD_LOOPBACK_MSK     |     // promiscuous mode
#endif
         ALTERA_TSEMAC_CMD_TX_ADDR_INS_MSK  |
         ALTERA_TSEMAC_CMD_RX_ERR_DISC_MSK;  /* automatically discard frames with CRC errors */
    
   if((result & ALT_TSE_E_AN_NOT_COMPLETE) == 0) 
    1160:	e0bffb17 	ldw	r2,-20(fp)
    1164:	1080022c 	andhi	r2,r2,8
    1168:	1000461e 	bne	r2,zero,1284 <tse_mac_init+0x60c>
      {
	  speed = (result >> 1) & 0x07;
    116c:	e0bffb17 	ldw	r2,-20(fp)
    1170:	1005d07a 	srai	r2,r2,1
    1174:	108001cc 	andi	r2,r2,7
    1178:	e0bffc15 	stw	r2,-16(fp)
	  duplex = result & 0x01;
    117c:	e0bffb17 	ldw	r2,-20(fp)
    1180:	1080004c 	andi	r2,r2,1
    1184:	e0bff415 	stw	r2,-48(fp)
  
      /* 1000 Mbps */
      if(speed == 0x01)
    1188:	e0bffc17 	ldw	r2,-16(fp)
    118c:	10800058 	cmpnei	r2,r2,1
    1190:	1000121e 	bne	r2,zero,11dc <tse_mac_init+0x564>
         {
         dat |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
    1194:	e0bff317 	ldw	r2,-52(fp)
    1198:	10800214 	ori	r2,r2,8
    119c:	e0bff315 	stw	r2,-52(fp)
         dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
    11a0:	e0fff317 	ldw	r3,-52(fp)
    11a4:	00bf8034 	movhi	r2,65024
    11a8:	10bfffc4 	addi	r2,r2,-1
    11ac:	1884703a 	and	r2,r3,r2
    11b0:	e0bff315 	stw	r2,-52(fp)
         tse[iface].ethernetif->link_speed = 1000;
    11b4:	00c00134 	movhi	r3,4
    11b8:	18d12104 	addi	r3,r3,17540
    11bc:	e0bffe17 	ldw	r2,-8(fp)
    11c0:	1004917a 	slli	r2,r2,5
    11c4:	1885883a 	add	r2,r3,r2
    11c8:	10800604 	addi	r2,r2,24
    11cc:	10800017 	ldw	r2,0(r2)
    11d0:	00c0fa04 	movi	r3,1000
    11d4:	10c00315 	stw	r3,12(r2)
    11d8:	00003306 	br	12a8 <tse_mac_init+0x630>
         }
      /* 100 Mbps */
      else if(speed == 0x02)
    11dc:	e0bffc17 	ldw	r2,-16(fp)
    11e0:	10800098 	cmpnei	r2,r2,2
    11e4:	1000131e 	bne	r2,zero,1234 <tse_mac_init+0x5bc>
         {
         dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
    11e8:	e0fff317 	ldw	r3,-52(fp)
    11ec:	00bffdc4 	movi	r2,-9
    11f0:	1884703a 	and	r2,r3,r2
    11f4:	e0bff315 	stw	r2,-52(fp)
         dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
    11f8:	e0fff317 	ldw	r3,-52(fp)
    11fc:	00bf8034 	movhi	r2,65024
    1200:	10bfffc4 	addi	r2,r2,-1
    1204:	1884703a 	and	r2,r3,r2
    1208:	e0bff315 	stw	r2,-52(fp)
         tse[iface].ethernetif->link_speed = 100;
    120c:	00c00134 	movhi	r3,4
    1210:	18d12104 	addi	r3,r3,17540
    1214:	e0bffe17 	ldw	r2,-8(fp)
    1218:	1004917a 	slli	r2,r2,5
    121c:	1885883a 	add	r2,r3,r2
    1220:	10800604 	addi	r2,r2,24
    1224:	10800017 	ldw	r2,0(r2)
    1228:	00c01904 	movi	r3,100
    122c:	10c00315 	stw	r3,12(r2)
    1230:	00001d06 	br	12a8 <tse_mac_init+0x630>
         }
      /* 10 Mbps */
      else if(speed == 0x04)
    1234:	e0bffc17 	ldw	r2,-16(fp)
    1238:	10800118 	cmpnei	r2,r2,4
    123c:	10001a1e 	bne	r2,zero,12a8 <tse_mac_init+0x630>
         {
         dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
    1240:	e0fff317 	ldw	r3,-52(fp)
    1244:	00bffdc4 	movi	r2,-9
    1248:	1884703a 	and	r2,r3,r2
    124c:	e0bff315 	stw	r2,-52(fp)
         dat |= ALTERA_TSEMAC_CMD_ENA_10_MSK;
    1250:	e0bff317 	ldw	r2,-52(fp)
    1254:	10808034 	orhi	r2,r2,512
    1258:	e0bff315 	stw	r2,-52(fp)
         tse[iface].ethernetif->link_speed = 10;
    125c:	00c00134 	movhi	r3,4
    1260:	18d12104 	addi	r3,r3,17540
    1264:	e0bffe17 	ldw	r2,-8(fp)
    1268:	1004917a 	slli	r2,r2,5
    126c:	1885883a 	add	r2,r3,r2
    1270:	10800604 	addi	r2,r2,24
    1274:	10800017 	ldw	r2,0(r2)
    1278:	00c00284 	movi	r3,10
    127c:	10c00315 	stw	r3,12(r2)
    1280:	00000906 	br	12a8 <tse_mac_init+0x630>
         }
      }
   /* default to 100 Mbps if returned invalid speed */
   else
      {
      dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
    1284:	e0fff317 	ldw	r3,-52(fp)
    1288:	00bffdc4 	movi	r2,-9
    128c:	1884703a 	and	r2,r3,r2
    1290:	e0bff315 	stw	r2,-52(fp)
      dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
    1294:	e0fff317 	ldw	r3,-52(fp)
    1298:	00bf8034 	movhi	r2,65024
    129c:	10bfffc4 	addi	r2,r2,-1
    12a0:	1884703a 	and	r2,r3,r2
    12a4:	e0bff315 	stw	r2,-52(fp)
      }
  
   /* Half Duplex */
   if(duplex == TSE_PHY_DUPLEX_HALF)
    12a8:	e0bff417 	ldw	r2,-48(fp)
    12ac:	10000c1e 	bne	r2,zero,12e0 <tse_mac_init+0x668>
      {
      dat |= ALTERA_TSEMAC_CMD_HD_ENA_MSK;
    12b0:	e0bff317 	ldw	r2,-52(fp)
    12b4:	10810014 	ori	r2,r2,1024
    12b8:	e0bff315 	stw	r2,-52(fp)
      tse[iface].ethernetif->full_duplex = 0;
    12bc:	00c00134 	movhi	r3,4
    12c0:	18d12104 	addi	r3,r3,17540
    12c4:	e0bffe17 	ldw	r2,-8(fp)
    12c8:	1004917a 	slli	r2,r2,5
    12cc:	1885883a 	add	r2,r3,r2
    12d0:	10800604 	addi	r2,r2,24
    12d4:	10800017 	ldw	r2,0(r2)
    12d8:	10000415 	stw	zero,16(r2)
    12dc:	00000d06 	br	1314 <tse_mac_init+0x69c>
      }
   /* Full Duplex */
   else
      {
      dat &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
    12e0:	e0fff317 	ldw	r3,-52(fp)
    12e4:	00beffc4 	movi	r2,-1025
    12e8:	1884703a 	and	r2,r3,r2
    12ec:	e0bff315 	stw	r2,-52(fp)
      tse[iface].ethernetif->full_duplex = 1;
    12f0:	00c00134 	movhi	r3,4
    12f4:	18d12104 	addi	r3,r3,17540
    12f8:	e0bffe17 	ldw	r2,-8(fp)
    12fc:	1004917a 	slli	r2,r2,5
    1300:	1885883a 	add	r2,r3,r2
    1304:	10800604 	addi	r2,r2,24
    1308:	10800017 	ldw	r2,0(r2)
    130c:	00c00044 	movi	r3,1
    1310:	10c00415 	stw	r3,16(r2)
      }
          
   IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base, dat);
    1314:	00c00134 	movhi	r3,4
    1318:	18d12104 	addi	r3,r3,17540
    131c:	e0bffe17 	ldw	r2,-8(fp)
    1320:	1004917a 	slli	r2,r2,5
    1324:	1885883a 	add	r2,r3,r2
    1328:	10800017 	ldw	r2,0(r2)
    132c:	10800204 	addi	r2,r2,8
    1330:	e0fff317 	ldw	r3,-52(fp)
    1334:	10c00035 	stwio	r3,0(r2)
   printf("\nMAC post-initialization: CMD_CONFIG=0x%08x\n", 
    IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base));
    1338:	00c00134 	movhi	r3,4
    133c:	18d12104 	addi	r3,r3,17540
    1340:	e0bffe17 	ldw	r2,-8(fp)
    1344:	1004917a 	slli	r2,r2,5
    1348:	1885883a 	add	r2,r3,r2
    134c:	10800017 	ldw	r2,0(r2)
      dat &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
      tse[iface].ethernetif->full_duplex = 1;
      }
          
   IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base, dat);
   printf("\nMAC post-initialization: CMD_CONFIG=0x%08x\n", 
    1350:	10800204 	addi	r2,r2,8
    1354:	10800037 	ldwio	r2,0(r2)
    1358:	010000f4 	movhi	r4,3
    135c:	21376a04 	addi	r4,r4,-8792
    1360:	100b883a 	mov	r5,r2
    1364:	00170680 	call	17068 <printf>
    IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base));
  
   /* Set the MAC address */
     IOWR_ALTERA_TSEMAC_MAC_0(mi_base,
    1368:	e0bffa17 	ldw	r2,-24(fp)
    136c:	10800304 	addi	r2,r2,12
    1370:	e0ffff17 	ldw	r3,-4(fp)
    1374:	18c00017 	ldw	r3,0(r3)
    1378:	18c00003 	ldbu	r3,0(r3)
    137c:	19003fcc 	andi	r4,r3,255
    1380:	e0ffff17 	ldw	r3,-4(fp)
    1384:	18c00017 	ldw	r3,0(r3)
    1388:	18c00043 	ldbu	r3,1(r3)
    138c:	18c03fcc 	andi	r3,r3,255
    1390:	1806923a 	slli	r3,r3,8
    1394:	20c8b03a 	or	r4,r4,r3
    1398:	e0ffff17 	ldw	r3,-4(fp)
    139c:	18c00017 	ldw	r3,0(r3)
    13a0:	18c00083 	ldbu	r3,2(r3)
    13a4:	18c03fcc 	andi	r3,r3,255
    13a8:	1806943a 	slli	r3,r3,16
    13ac:	20c8b03a 	or	r4,r4,r3
    13b0:	e0ffff17 	ldw	r3,-4(fp)
    13b4:	18c00017 	ldw	r3,0(r3)
    13b8:	18c000c3 	ldbu	r3,3(r3)
    13bc:	18c03fcc 	andi	r3,r3,255
    13c0:	1806963a 	slli	r3,r3,24
    13c4:	20c6b03a 	or	r3,r4,r3
    13c8:	10c00035 	stwio	r3,0(r2)
                             ((int)((unsigned char) ethernetif->ethaddr->addr[0]) |
                              (int)((unsigned char) ethernetif->ethaddr->addr[1] <<  8) |
                              (int)((unsigned char) ethernetif->ethaddr->addr[2] << 16) |
                              (int)((unsigned char) ethernetif->ethaddr->addr[3] << 24)));

     IOWR_ALTERA_TSEMAC_MAC_1(mi_base,
    13cc:	e0bffa17 	ldw	r2,-24(fp)
    13d0:	10800404 	addi	r2,r2,16
    13d4:	e0ffff17 	ldw	r3,-4(fp)
    13d8:	18c00017 	ldw	r3,0(r3)
    13dc:	18c00103 	ldbu	r3,4(r3)
    13e0:	19003fcc 	andi	r4,r3,255
    13e4:	e0ffff17 	ldw	r3,-4(fp)
    13e8:	18c00017 	ldw	r3,0(r3)
    13ec:	18c00143 	ldbu	r3,5(r3)
    13f0:	18c03fcc 	andi	r3,r3,255
    13f4:	1806923a 	slli	r3,r3,8
    13f8:	20c6b03a 	or	r3,r4,r3
    13fc:	18ffffcc 	andi	r3,r3,65535
    1400:	10c00035 	stwio	r3,0(r2)
                             (((int)((unsigned char) ethernetif->ethaddr->addr[4]) |
                               (int)((unsigned char) ethernetif->ethaddr->addr[5] <<  8)) & 0xFFFF));
                                
   alt_avalon_sgdma_register_callback(tse[iface].mi.rx_sgdma,
    1404:	00c00134 	movhi	r3,4
    1408:	18d12104 	addi	r3,r3,17540
    140c:	e0bffe17 	ldw	r2,-8(fp)
    1410:	1004917a 	slli	r2,r2,5
    1414:	1885883a 	add	r2,r3,r2
    1418:	10800204 	addi	r2,r2,8
    141c:	10c00017 	ldw	r3,0(r2)
#ifndef ALTERA_TSE_IRQ_R
        (alt_avalon_sgdma_callback)&tse_sgdmaRx_isr,
#else
        (alt_avalon_sgdma_callback)&ALTERA_TSE_IRQ_R,
#endif
        (alt_u16)ALTERA_TSE_SGDMA_INTR_MASK,(void*)(&tse[iface]));
    1420:	e0bffe17 	ldw	r2,-8(fp)
    1424:	1008917a 	slli	r4,r2,5
    1428:	00800134 	movhi	r2,4
    142c:	10912104 	addi	r2,r2,17540
    1430:	2085883a 	add	r2,r4,r2

     IOWR_ALTERA_TSEMAC_MAC_1(mi_base,
                             (((int)((unsigned char) ethernetif->ethaddr->addr[4]) |
                               (int)((unsigned char) ethernetif->ethaddr->addr[5] <<  8)) & 0xFFFF));
                                
   alt_avalon_sgdma_register_callback(tse[iface].mi.rx_sgdma,
    1434:	1809883a 	mov	r4,r3
    1438:	01400034 	movhi	r5,0
    143c:	29456604 	addi	r5,r5,5528
    1440:	01800604 	movi	r6,24
    1444:	100f883a 	mov	r7,r2
    1448:	002506c0 	call	2506c <alt_avalon_sgdma_register_callback>
#else
        (alt_avalon_sgdma_callback)&ALTERA_TSE_IRQ_R,
#endif
        (alt_u16)ALTERA_TSE_SGDMA_INTR_MASK,(void*)(&tse[iface]));
    
   tse_sgdma_read_init(&tse[iface]);
    144c:	e0bffe17 	ldw	r2,-8(fp)
    1450:	1006917a 	slli	r3,r2,5
    1454:	00800134 	movhi	r2,4
    1458:	10912104 	addi	r2,r2,17540
    145c:	1885883a 	add	r2,r3,r2
    1460:	1009883a 	mov	r4,r2
    1464:	00014e00 	call	14e0 <tse_sgdma_read_init>
   //tse_sgdma_write_init(&tse[iface]);
   

   pmac_info = alt_tse_get_mac_info(mi_base);
    1468:	e13ffa17 	ldw	r4,-24(fp)
    146c:	0026be00 	call	26be0 <alt_tse_get_mac_info>
    1470:	e0bffd15 	stw	r2,-12(fp)
   alt_tse_phy_wr_mdio_addr(pmac_info->pphy_info, pmac_info->pphy_info->mdio_address);
    1474:	e0bffd17 	ldw	r2,-12(fp)
    1478:	10c00117 	ldw	r3,4(r2)
    147c:	e0bffd17 	ldw	r2,-12(fp)
    1480:	10800117 	ldw	r2,4(r2)
    1484:	10800003 	ldbu	r2,0(r2)
    1488:	10803fcc 	andi	r2,r2,255
    148c:	1809883a 	mov	r4,r3
    1490:	100b883a 	mov	r5,r2
    1494:	00278e00 	call	278e0 <alt_tse_phy_wr_mdio_addr>
   ethernetif->link_alive = alt_tse_phy_rd_mdio_reg(pmac_info->pphy_info, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) != 0;
    1498:	e0bffd17 	ldw	r2,-12(fp)
    149c:	10800117 	ldw	r2,4(r2)
    14a0:	1009883a 	mov	r4,r2
    14a4:	01400044 	movi	r5,1
    14a8:	01800144 	movi	r6,5
    14ac:	01c00044 	movi	r7,1
    14b0:	0027a640 	call	27a64 <alt_tse_phy_rd_mdio_reg>
    14b4:	1004c03a 	cmpne	r2,r2,zero
    14b8:	10c03fcc 	andi	r3,r2,255
    14bc:	e0bfff17 	ldw	r2,-4(fp)
    14c0:	10c00215 	stw	r3,8(r2)
   //IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma->base,ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
   //IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma->base, 0x0);
   //IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma, 0xff);
   

   return ethernetif->link_alive;
    14c4:	e0bfff17 	ldw	r2,-4(fp)
    14c8:	10800217 	ldw	r2,8(r2)
}
    14cc:	e037883a 	mov	sp,fp
    14d0:	dfc00117 	ldw	ra,4(sp)
    14d4:	df000017 	ldw	fp,0(sp)
    14d8:	dec00204 	addi	sp,sp,8
    14dc:	f800283a 	ret

000014e0 <tse_sgdma_read_init>:
 * 
 * @API TYPE - Internal
 * @return SUCCESS on success 
 */
int tse_sgdma_read_init(lwip_tse_info* tse_ptr)
{     
    14e0:	defffb04 	addi	sp,sp,-20
    14e4:	dfc00415 	stw	ra,16(sp)
    14e8:	df000315 	stw	fp,12(sp)
    14ec:	df000304 	addi	fp,sp,12
    14f0:	e13fff15 	stw	r4,-4(fp)
   struct ethernetif *ethernetif;
  
   ethernetif = tse_ptr->ethernetif;
    14f4:	e0bfff17 	ldw	r2,-4(fp)
    14f8:	10800617 	ldw	r2,24(r2)
    14fc:	e0bffe15 	stw	r2,-8(fp)
  
   alt_avalon_sgdma_construct_stream_to_mem_desc(
         (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],  // descriptor I want to work with
    1500:	e0bfff17 	ldw	r2,-4(fp)
    1504:	10800517 	ldw	r2,20(r2)
{     
   struct ethernetif *ethernetif;
  
   ethernetif = tse_ptr->ethernetif;
  
   alt_avalon_sgdma_construct_stream_to_mem_desc(
    1508:	11001004 	addi	r4,r2,64
         (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],  // descriptor I want to work with
         (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_RX_SGDMA_DESC_OFST],  // pointer to "next"
    150c:	e0bfff17 	ldw	r2,-4(fp)
    1510:	10800517 	ldw	r2,20(r2)
{     
   struct ethernetif *ethernetif;
  
   ethernetif = tse_ptr->ethernetif;
  
   alt_avalon_sgdma_construct_stream_to_mem_desc(
    1514:	10c01804 	addi	r3,r2,96
         (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],  // descriptor I want to work with
         (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_RX_SGDMA_DESC_OFST],  // pointer to "next"
         (alt_u32 *) ethernetif->lwipRxPbuf[tse_ptr->ethernetif->lwipRxIndexIsr]->payload,          // starting write_address
    1518:	e0bfff17 	ldw	r2,-4(fp)
    151c:	10800617 	ldw	r2,24(r2)
    1520:	10801317 	ldw	r2,76(r2)
    1524:	e17ffe17 	ldw	r5,-8(fp)
    1528:	108001c4 	addi	r2,r2,7
    152c:	1085883a 	add	r2,r2,r2
    1530:	1085883a 	add	r2,r2,r2
    1534:	2885883a 	add	r2,r5,r2
    1538:	10800017 	ldw	r2,0(r2)
    153c:	10800117 	ldw	r2,4(r2)
{     
   struct ethernetif *ethernetif;
  
   ethernetif = tse_ptr->ethernetif;
  
   alt_avalon_sgdma_construct_stream_to_mem_desc(
    1540:	d8000015 	stw	zero,0(sp)
    1544:	180b883a 	mov	r5,r3
    1548:	100d883a 	mov	r6,r2
    154c:	000f883a 	mov	r7,zero
    1550:	0024e980 	call	24e98 <alt_avalon_sgdma_construct_stream_to_mem_desc>
         (alt_u32 *) ethernetif->lwipRxPbuf[tse_ptr->ethernetif->lwipRxIndexIsr]->payload,          // starting write_address
         0,                                  // read until EOP
         0);          // don't write to constant address


   printf("[tse_sgdma_read_init] RX descriptor chain desc (%d depth) created\n",0); 
    1554:	010000f4 	movhi	r4,3
    1558:	21377604 	addi	r4,r4,-8744
    155c:	000b883a 	mov	r5,zero
    1560:	00170680 	call	17068 <printf>
   
   tse_mac_aRxRead( &tse_ptr->mi, &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
    1564:	e0ffff17 	ldw	r3,-4(fp)
    1568:	e0bfff17 	ldw	r2,-4(fp)
    156c:	10800517 	ldw	r2,20(r2)
    1570:	10801004 	addi	r2,r2,64
    1574:	1809883a 	mov	r4,r3
    1578:	100b883a 	mov	r5,r2
    157c:	0025ae40 	call	25ae4 <tse_mac_aRxRead>
  
   return SUCCESS;
    1580:	0005883a 	mov	r2,zero
}
    1584:	e037883a 	mov	sp,fp
    1588:	dfc00117 	ldw	ra,4(sp)
    158c:	df000017 	ldw	fp,0(sp)
    1590:	dec00204 	addi	sp,sp,8
    1594:	f800283a 	ret

00001598 <tse_sgdmaRx_isr>:
 * @API TYPE - callback
 * @param  context  - context of the TSE MAC instance
 * @param  intnum - temporary storage
 */
int tse_sgdmaRx_isr(void * context, u_long intnum)
{
    1598:	defffb04 	addi	sp,sp,-20
    159c:	dfc00415 	stw	ra,16(sp)
    15a0:	df000315 	stw	fp,12(sp)
    15a4:	df000304 	addi	fp,sp,12
    15a8:	e13ffe15 	stw	r4,-8(fp)
    15ac:	e17fff15 	stw	r5,-4(fp)
   lwip_tse_info* tse_ptr = (lwip_tse_info *) context;
    15b0:	e0bffe17 	ldw	r2,-8(fp)
    15b4:	e0bffd15 	stw	r2,-12(fp)

   IOWR_ALTERA_AVALON_SGDMA_CONTROL(&tse_ptr->mi.rx_sgdma->base,ALTERA_AVALON_SGDMA_CONTROL_CLEAR_INTERRUPT_MSK);
    15b8:	e0bffd17 	ldw	r2,-12(fp)
    15bc:	10800217 	ldw	r2,8(r2)
    15c0:	10800304 	addi	r2,r2,12
    15c4:	10800404 	addi	r2,r2,16
    15c8:	00e00034 	movhi	r3,32768
    15cc:	10c00035 	stwio	r3,0(r2)
   tse_mac_rcv(tse_ptr->ethernetif);    
    15d0:	e0bffd17 	ldw	r2,-12(fp)
    15d4:	10800617 	ldw	r2,24(r2)
    15d8:	1009883a 	mov	r4,r2
    15dc:	000179c0 	call	179c <tse_mac_rcv>
   tse_mac_aRxRead( &tse_ptr->mi, &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
    15e0:	e0fffd17 	ldw	r3,-12(fp)
    15e4:	e0bffd17 	ldw	r2,-12(fp)
    15e8:	10800517 	ldw	r2,20(r2)
    15ec:	10801004 	addi	r2,r2,64
    15f0:	1809883a 	mov	r4,r3
    15f4:	100b883a 	mov	r5,r2
    15f8:	0025ae40 	call	25ae4 <tse_mac_aRxRead>
   IOWR_ALTERA_AVALON_SGDMA_CONTROL(&tse_ptr->mi.rx_sgdma->base, ALTERA_TSE_SGDMA_INTR_MASK);
    15fc:	e0bffd17 	ldw	r2,-12(fp)
    1600:	10800217 	ldw	r2,8(r2)
    1604:	10800304 	addi	r2,r2,12
    1608:	10800404 	addi	r2,r2,16
    160c:	00c00604 	movi	r3,24
    1610:	10c00035 	stwio	r3,0(r2)
  
   return SUCCESS;
    1614:	0005883a 	mov	r2,zero
}
    1618:	e037883a 	mov	sp,fp
    161c:	dfc00117 	ldw	ra,4(sp)
    1620:	df000017 	ldw	fp,0(sp)
    1624:	dec00204 	addi	sp,sp,8
    1628:	f800283a 	ret

0000162c <tse_mac_raw_send>:
 * @param  data_bytes - number of bytes of the data payload to be sent to the MAC
 * @return SUCCESS if success, else a negative value
 */

err_t tse_mac_raw_send(struct netif *netif, struct pbuf *pkt)
{
    162c:	defe6a04 	addi	sp,sp,-1624
    1630:	dfc19515 	stw	ra,1620(sp)
    1634:	df019415 	stw	fp,1616(sp)
    1638:	df019404 	addi	fp,sp,1616
    163c:	e13ffe15 	stw	r4,-8(fp)
    1640:	e17fff15 	stw	r5,-4(fp)
   unsigned int       *ActualData;

   /* Intermediate buffers used for temporary copy of frames that cannot be directrly DMA'ed*/
   char buf2[1560];

   ethernetif = netif->state;
    1644:	e0bffe17 	ldw	r2,-8(fp)
    1648:	10800717 	ldw	r2,28(r2)
    164c:	e0be7215 	stw	r2,-1592(fp)
   tse_ptr = ethernetif->tse_info;
    1650:	e0be7217 	ldw	r2,-1592(fp)
    1654:	10801617 	ldw	r2,88(r2)
    1658:	e0be7315 	stw	r2,-1588(fp)
   mi = &tse_ptr->mi;
    165c:	e0be7317 	ldw	r2,-1588(fp)
    1660:	e0be7415 	stw	r2,-1584(fp)
  
   for(p = pkt; p != NULL; p = p->next)
    1664:	e0bfff17 	ldw	r2,-4(fp)
    1668:	e0be7015 	stw	r2,-1600(fp)
    166c:	00003b06 	br	175c <tse_mac_raw_send+0x130>
      {
      data = p->payload;
    1670:	e0be7017 	ldw	r2,-1600(fp)
    1674:	10800117 	ldw	r2,4(r2)
    1678:	e0be7115 	stw	r2,-1596(fp)
      len = p->len;
    167c:	e0be7017 	ldw	r2,-1600(fp)
    1680:	1080028b 	ldhu	r2,10(r2)
    1684:	10bfffcc 	andi	r2,r2,65535
    1688:	e0be7515 	stw	r2,-1580(fp)
       
      if(((unsigned long)data & 0x03) != 0) 
    168c:	e0be7117 	ldw	r2,-1596(fp)
    1690:	108000cc 	andi	r2,r2,3
    1694:	10000726 	beq	r2,zero,16b4 <tse_mac_raw_send+0x88>
         /* 
          * Copy data to temporary buffer <buf2>. This is done because of allignment 
          * issues. The SGDMA cannot copy the data directly from (data + ETH_PAD_SIZE)
          * because it needs a 32-bit alligned address space. 
          */
         memcpy(buf2,data,len);
    1698:	e0be7804 	addi	r2,fp,-1568
    169c:	1009883a 	mov	r4,r2
    16a0:	e17e7117 	ldw	r5,-1596(fp)
    16a4:	e1be7517 	ldw	r6,-1580(fp)
    16a8:	0016e680 	call	16e68 <memcpy>
         data = (alt_u32 *)buf2;
    16ac:	e0be7804 	addi	r2,fp,-1568
    16b0:	e0be7115 	stw	r2,-1596(fp)
         }  
       
      ActualData = (void *)alt_remap_uncached (data, len);
    16b4:	e13e7117 	ldw	r4,-1596(fp)
    16b8:	e17e7517 	ldw	r5,-1580(fp)
    16bc:	0020e5c0 	call	20e5c <alt_remap_uncached>
    16c0:	e0be7615 	stw	r2,-1576(fp)
      /* Write data to Tx FIFO using the DMA */
      alt_avalon_sgdma_construct_mem_to_stream_desc(
           (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_TX_SGDMA_DESC_OFST], // descriptor I want to work with
    16c4:	e0be7317 	ldw	r2,-1588(fp)
         data = (alt_u32 *)buf2;
         }  
       
      ActualData = (void *)alt_remap_uncached (data, len);
      /* Write data to Tx FIFO using the DMA */
      alt_avalon_sgdma_construct_mem_to_stream_desc(
    16c8:	11000517 	ldw	r4,20(r2)
           (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_TX_SGDMA_DESC_OFST], // descriptor I want to work with
           (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_TX_SGDMA_DESC_OFST],// pointer to "next"
    16cc:	e0be7317 	ldw	r2,-1588(fp)
    16d0:	10800517 	ldw	r2,20(r2)
         data = (alt_u32 *)buf2;
         }  
       
      ActualData = (void *)alt_remap_uncached (data, len);
      /* Write data to Tx FIFO using the DMA */
      alt_avalon_sgdma_construct_mem_to_stream_desc(
    16d4:	10c00804 	addi	r3,r2,32
    16d8:	e0be7517 	ldw	r2,-1580(fp)
    16dc:	10bfffcc 	andi	r2,r2,65535
    16e0:	e1be7017 	ldw	r6,-1600(fp)
    16e4:	e17fff17 	ldw	r5,-4(fp)
    16e8:	314b003a 	cmpeq	r5,r6,r5
    16ec:	29803fcc 	andi	r6,r5,255
           (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_TX_SGDMA_DESC_OFST],// pointer to "next"
           (alt_u32*)ActualData,                    // starting read address
           (len),                                   // # bytes
           0,                                       // don't read from constant address
           p == pkt,                                // generate sop
           p->next == NULL,                         // generate endofpacket signal
    16f0:	e17e7017 	ldw	r5,-1600(fp)
    16f4:	29400017 	ldw	r5,0(r5)
         data = (alt_u32 *)buf2;
         }  
       
      ActualData = (void *)alt_remap_uncached (data, len);
      /* Write data to Tx FIFO using the DMA */
      alt_avalon_sgdma_construct_mem_to_stream_desc(
    16f8:	280b003a 	cmpeq	r5,r5,zero
    16fc:	29403fcc 	andi	r5,r5,255
    1700:	d8000015 	stw	zero,0(sp)
    1704:	d9800115 	stw	r6,4(sp)
    1708:	d9400215 	stw	r5,8(sp)
    170c:	d8000315 	stw	zero,12(sp)
    1710:	180b883a 	mov	r5,r3
    1714:	e1be7617 	ldw	r6,-1576(fp)
    1718:	100f883a 	mov	r7,r2
    171c:	0024f680 	call	24f68 <alt_avalon_sgdma_construct_mem_to_stream_desc>
           0,                                       // don't read from constant address
           p == pkt,                                // generate sop
           p->next == NULL,                         // generate endofpacket signal
           0);                                      // atlantic channel (don't know/don't care: set to 0)
                  
      tx_length = tse_mac_sTxWrite(mi,&tse_ptr->desc[ALTERA_TSE_FIRST_TX_SGDMA_DESC_OFST]);
    1720:	e0be7317 	ldw	r2,-1588(fp)
    1724:	10800517 	ldw	r2,20(r2)
    1728:	e13e7417 	ldw	r4,-1584(fp)
    172c:	100b883a 	mov	r5,r2
    1730:	0025a040 	call	25a04 <tse_mac_sTxWrite>
    1734:	e0be7715 	stw	r2,-1572(fp)
      ethernetif->bytes_sent += tx_length;
    1738:	e0be7217 	ldw	r2,-1592(fp)
    173c:	10c00517 	ldw	r3,20(r2)
    1740:	e0be7717 	ldw	r2,-1572(fp)
    1744:	1887883a 	add	r3,r3,r2
    1748:	e0be7217 	ldw	r2,-1592(fp)
    174c:	10c00515 	stw	r3,20(r2)

   ethernetif = netif->state;
   tse_ptr = ethernetif->tse_info;
   mi = &tse_ptr->mi;
  
   for(p = pkt; p != NULL; p = p->next)
    1750:	e0be7017 	ldw	r2,-1600(fp)
    1754:	10800017 	ldw	r2,0(r2)
    1758:	e0be7015 	stw	r2,-1600(fp)
    175c:	e0be7017 	ldw	r2,-1600(fp)
    1760:	103fc31e 	bne	r2,zero,1670 <tse_mac_raw_send+0x44>
           0);                                      // atlantic channel (don't know/don't care: set to 0)
                  
      tx_length = tse_mac_sTxWrite(mi,&tse_ptr->desc[ALTERA_TSE_FIRST_TX_SGDMA_DESC_OFST]);
      ethernetif->bytes_sent += tx_length;
      }
   LINK_STATS_INC(link.xmit);
    1764:	00800134 	movhi	r2,4
    1768:	10916104 	addi	r2,r2,17796
    176c:	1080000b 	ldhu	r2,0(r2)
    1770:	10800044 	addi	r2,r2,1
    1774:	1007883a 	mov	r3,r2
    1778:	00800134 	movhi	r2,4
    177c:	10916104 	addi	r2,r2,17796
    1780:	10c0000d 	sth	r3,0(r2)
   return ERR_OK;
    1784:	0005883a 	mov	r2,zero
}
    1788:	e037883a 	mov	sp,fp
    178c:	dfc00117 	ldw	ra,4(sp)
    1790:	df000017 	ldw	fp,0(sp)
    1794:	dec00204 	addi	sp,sp,8
    1798:	f800283a 	ret

0000179c <tse_mac_rcv>:
 * 
 * @API TYPE        - callback internal function
 * @return SUCCESS on success
 */
int tse_mac_rcv(struct ethernetif *ethernetif)
{     
    179c:	defff804 	addi	sp,sp,-32
    17a0:	dfc00715 	stw	ra,28(sp)
    17a4:	df000615 	stw	fp,24(sp)
    17a8:	df000604 	addi	fp,sp,24
    17ac:	e13fff15 	stw	r4,-4(fp)
   int pklen;
   lwip_tse_info* tse_ptr;
   alt_u32 *uncached_packet_payload;
   struct pbuf *p;
  
   tse_ptr = ethernetif->tse_info;
    17b0:	e0bfff17 	ldw	r2,-4(fp)
    17b4:	10801617 	ldw	r2,88(r2)
    17b8:	e0bffb15 	stw	r2,-20(fp)
   pklen = IORD_16DIRECT(&(tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST].actual_bytes_transferred),0);
    17bc:	e0bffb17 	ldw	r2,-20(fp)
    17c0:	10800517 	ldw	r2,20(r2)
    17c4:	10801004 	addi	r2,r2,64
    17c8:	10800704 	addi	r2,r2,28
    17cc:	1080002b 	ldhuio	r2,0(r2)
    17d0:	10bfffcc 	andi	r2,r2,65535
    17d4:	e0bffc15 	stw	r2,-16(fp)
   p = ethernetif->lwipRxPbuf[ethernetif->lwipRxIndexIsr];
    17d8:	e0bfff17 	ldw	r2,-4(fp)
    17dc:	10801317 	ldw	r2,76(r2)
    17e0:	e0ffff17 	ldw	r3,-4(fp)
    17e4:	108001c4 	addi	r2,r2,7
    17e8:	1085883a 	add	r2,r2,r2
    17ec:	1085883a 	add	r2,r2,r2
    17f0:	1885883a 	add	r2,r3,r2
    17f4:	10800017 	ldw	r2,0(r2)
    17f8:	e0bffd15 	stw	r2,-12(fp)
   p->tot_len = pklen;
    17fc:	e0bffc17 	ldw	r2,-16(fp)
    1800:	1007883a 	mov	r3,r2
    1804:	e0bffd17 	ldw	r2,-12(fp)
    1808:	10c0020d 	sth	r3,8(r2)
   p->len = pklen;
    180c:	e0bffc17 	ldw	r2,-16(fp)
    1810:	1007883a 	mov	r3,r2
    1814:	e0bffd17 	ldw	r2,-12(fp)
    1818:	10c0028d 	sth	r3,10(r2)
   if ((IORD_ALTERA_TSE_SGDMA_DESC_STATUS(&tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]) & ( ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_CRC_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_PARITY_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_OVERFLOW_MSK |ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK )) == 0)
    181c:	e0bffb17 	ldw	r2,-20(fp)
    1820:	10800517 	ldw	r2,20(r2)
    1824:	10801704 	addi	r2,r2,92
    1828:	10800037 	ldwio	r2,0(r2)
    182c:	1005d43a 	srai	r2,r2,16
    1830:	10801fcc 	andi	r2,r2,127
    1834:	1000261e 	bne	r2,zero,18d0 <tse_mac_rcv+0x134>
      {
      if( ethernetif->lwipRxCount > LWIP_RX_ETH_BUFFER )
    1838:	e0bfff17 	ldw	r2,-4(fp)
    183c:	10801517 	ldw	r2,84(r2)
    1840:	10800350 	cmplti	r2,r2,13
    1844:	10000c1e 	bne	r2,zero,1878 <tse_mac_rcv+0xdc>
         {    
         LINK_STATS_INC(link.drop);
    1848:	00800134 	movhi	r2,4
    184c:	10916104 	addi	r2,r2,17796
    1850:	1080018b 	ldhu	r2,6(r2)
    1854:	10800044 	addi	r2,r2,1
    1858:	1007883a 	mov	r3,r2
    185c:	00800134 	movhi	r2,4
    1860:	10916104 	addi	r2,r2,17796
    1864:	10c0018d 	sth	r3,6(r2)
         dprintf(("No free buffers for rx\n"));
    1868:	010000f4 	movhi	r4,3
    186c:	21378704 	addi	r4,r4,-8676
    1870:	00172f80 	call	172f8 <puts>
    1874:	00001606 	br	18d0 <tse_mac_rcv+0x134>
         }
      else 
         {
         ethernetif->bytes_recv += pklen;
    1878:	e0bfff17 	ldw	r2,-4(fp)
    187c:	10c00617 	ldw	r3,24(r2)
    1880:	e0bffc17 	ldw	r2,-16(fp)
    1884:	1887883a 	add	r3,r3,r2
    1888:	e0bfff17 	ldw	r2,-4(fp)
    188c:	10c00615 	stw	r3,24(r2)
         //  Set up DMA for the next pbuf in the buffer
         ++ethernetif->lwipRxCount;
    1890:	e0bfff17 	ldw	r2,-4(fp)
    1894:	10801517 	ldw	r2,84(r2)
    1898:	10c00044 	addi	r3,r2,1
    189c:	e0bfff17 	ldw	r2,-4(fp)
    18a0:	10c01515 	stw	r3,84(r2)
         if( ++ethernetif->lwipRxIndexIsr >= LWIP_RX_ETH_BUFFER )
    18a4:	e0bfff17 	ldw	r2,-4(fp)
    18a8:	10801317 	ldw	r2,76(r2)
    18ac:	10c00044 	addi	r3,r2,1
    18b0:	e0bfff17 	ldw	r2,-4(fp)
    18b4:	10c01315 	stw	r3,76(r2)
    18b8:	e0bfff17 	ldw	r2,-4(fp)
    18bc:	10801317 	ldw	r2,76(r2)
    18c0:	10800310 	cmplti	r2,r2,12
    18c4:	1000021e 	bne	r2,zero,18d0 <tse_mac_rcv+0x134>
            ethernetif->lwipRxIndexIsr = 0;
    18c8:	e0bfff17 	ldw	r2,-4(fp)
    18cc:	10001315 	stw	zero,76(r2)
         }
      }      

   uncached_packet_payload = (alt_u32 *) ethernetif->lwipRxPbuf[ethernetif->lwipRxIndexIsr]->payload;
    18d0:	e0bfff17 	ldw	r2,-4(fp)
    18d4:	10801317 	ldw	r2,76(r2)
    18d8:	e0ffff17 	ldw	r3,-4(fp)
    18dc:	108001c4 	addi	r2,r2,7
    18e0:	1085883a 	add	r2,r2,r2
    18e4:	1085883a 	add	r2,r2,r2
    18e8:	1885883a 	add	r2,r3,r2
    18ec:	10800017 	ldw	r2,0(r2)
    18f0:	10800117 	ldw	r2,4(r2)
    18f4:	e0bffe15 	stw	r2,-8(fp)
   alt_avalon_sgdma_construct_stream_to_mem_desc(
         (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],  // descriptor I want to work with
    18f8:	e0bffb17 	ldw	r2,-20(fp)
    18fc:	10800517 	ldw	r2,20(r2)
            ethernetif->lwipRxIndexIsr = 0;
         }
      }      

   uncached_packet_payload = (alt_u32 *) ethernetif->lwipRxPbuf[ethernetif->lwipRxIndexIsr]->payload;
   alt_avalon_sgdma_construct_stream_to_mem_desc(
    1900:	10c01004 	addi	r3,r2,64
         (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],  // descriptor I want to work with
         (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_RX_SGDMA_DESC_OFST],  // pointer to "next"
    1904:	e0bffb17 	ldw	r2,-20(fp)
    1908:	10800517 	ldw	r2,20(r2)
            ethernetif->lwipRxIndexIsr = 0;
         }
      }      

   uncached_packet_payload = (alt_u32 *) ethernetif->lwipRxPbuf[ethernetif->lwipRxIndexIsr]->payload;
   alt_avalon_sgdma_construct_stream_to_mem_desc(
    190c:	10801804 	addi	r2,r2,96
    1910:	d8000015 	stw	zero,0(sp)
    1914:	1809883a 	mov	r4,r3
    1918:	100b883a 	mov	r5,r2
    191c:	e1bffe17 	ldw	r6,-8(fp)
    1920:	000f883a 	mov	r7,zero
    1924:	0024e980 	call	24e98 <alt_avalon_sgdma_construct_stream_to_mem_desc>
         (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_RX_SGDMA_DESC_OFST],  // pointer to "next"
         uncached_packet_payload,            // starting write_address
         0,                                  // read until EOP
         0);          // don't write to constant address

   return ERR_OK;
    1928:	0005883a 	mov	r2,zero
}
    192c:	e037883a 	mov	sp,fp
    1930:	dfc00117 	ldw	ra,4(sp)
    1934:	df000017 	ldw	fp,0(sp)
    1938:	dec00204 	addi	sp,sp,8
    193c:	f800283a 	ret

00001940 <lwip_strerr>:
 * @param err an lwip internal err_t
 * @return a string representation for err
 */
const char *
lwip_strerr(err_t err)
{
    1940:	defffe04 	addi	sp,sp,-8
    1944:	df000115 	stw	fp,4(sp)
    1948:	df000104 	addi	fp,sp,4
    194c:	2005883a 	mov	r2,r4
    1950:	e0bfff05 	stb	r2,-4(fp)
  return err_strerr[-err];
    1954:	e0bfff07 	ldb	r2,-4(fp)
    1958:	0085c83a 	sub	r2,zero,r2
    195c:	00c000f4 	movhi	r3,3
    1960:	18c8f204 	addi	r3,r3,9160
    1964:	1085883a 	add	r2,r2,r2
    1968:	1085883a 	add	r2,r2,r2
    196c:	1885883a 	add	r2,r3,r2
    1970:	10800017 	ldw	r2,0(r2)

}
    1974:	e037883a 	mov	sp,fp
    1978:	df000017 	ldw	fp,0(sp)
    197c:	dec00104 	addi	sp,sp,4
    1980:	f800283a 	ret

00001984 <dhcp_handle_nak>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_nak(struct netif *netif)
{
    1984:	defffc04 	addi	sp,sp,-16
    1988:	dfc00315 	stw	ra,12(sp)
    198c:	df000215 	stw	fp,8(sp)
    1990:	df000204 	addi	fp,sp,8
    1994:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    1998:	e0bfff17 	ldw	r2,-4(fp)
    199c:	10800817 	ldw	r2,32(r2)
    19a0:	e0bffe15 	stw	r2,-8(fp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n", 
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Set the interface down since the address must no longer be used, as per RFC2131 */
  netif_set_down(netif);
    19a4:	e13fff17 	ldw	r4,-4(fp)
    19a8:	00097480 	call	9748 <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
    19ac:	e13fff17 	ldw	r4,-4(fp)
    19b0:	014000f4 	movhi	r5,3
    19b4:	2950ed04 	addi	r5,r5,17332
    19b8:	00094ac0 	call	94ac <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
    19bc:	e13fff17 	ldw	r4,-4(fp)
    19c0:	014000f4 	movhi	r5,3
    19c4:	2950ed04 	addi	r5,r5,17332
    19c8:	00096040 	call	9604 <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY); 
    19cc:	e13fff17 	ldw	r4,-4(fp)
    19d0:	014000f4 	movhi	r5,3
    19d4:	2950ed04 	addi	r5,r5,17332
    19d8:	00096540 	call	9654 <netif_set_netmask>
  /* Change to a defined state */
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
    19dc:	e13ffe17 	ldw	r4,-8(fp)
    19e0:	01400304 	movi	r5,12
    19e4:	00039b00 	call	39b0 <dhcp_set_state>
  /* We can immediately restart discovery */
  dhcp_discover(netif);
    19e8:	e13fff17 	ldw	r4,-4(fp)
    19ec:	0002cc00 	call	2cc0 <dhcp_discover>
}
    19f0:	e037883a 	mov	sp,fp
    19f4:	dfc00117 	ldw	ra,4(sp)
    19f8:	df000017 	ldw	fp,0(sp)
    19fc:	dec00204 	addi	sp,sp,8
    1a00:	f800283a 	ret

00001a04 <dhcp_check>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_check(struct netif *netif)
{
    1a04:	defffb04 	addi	sp,sp,-20
    1a08:	dfc00415 	stw	ra,16(sp)
    1a0c:	df000315 	stw	fp,12(sp)
    1a10:	df000304 	addi	fp,sp,12
    1a14:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    1a18:	e0bfff17 	ldw	r2,-4(fp)
    1a1c:	10800817 	ldw	r2,32(r2)
    1a20:	e0bffd15 	stw	r2,-12(fp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0],
    (s16_t)netif->name[1]));
  dhcp_set_state(dhcp, DHCP_CHECKING);
    1a24:	e13ffd17 	ldw	r4,-12(fp)
    1a28:	01400204 	movi	r5,8
    1a2c:	00039b00 	call	39b0 <dhcp_set_state>
  /* create an ARP query for the offered IP address, expecting that no host
     responds, as the IP address should not be in use. */
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
    1a30:	e0bffd17 	ldw	r2,-12(fp)
    1a34:	10800a04 	addi	r2,r2,40
    1a38:	e13fff17 	ldw	r4,-4(fp)
    1a3c:	100b883a 	mov	r5,r2
    1a40:	000d883a 	mov	r6,zero
    1a44:	00162e40 	call	162e4 <etharp_query>
    1a48:	e0bffe05 	stb	r2,-8(fp)
  if (result != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("dhcp_check: could not perform ARP query\n"));
  }
  dhcp->tries++;
    1a4c:	e0bffd17 	ldw	r2,-12(fp)
    1a50:	108004c3 	ldbu	r2,19(r2)
    1a54:	10800044 	addi	r2,r2,1
    1a58:	1007883a 	mov	r3,r2
    1a5c:	e0bffd17 	ldw	r2,-12(fp)
    1a60:	10c004c5 	stb	r3,19(r2)
  msecs = 500;
    1a64:	00807d04 	movi	r2,500
    1a68:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    1a6c:	e0bffe8b 	ldhu	r2,-6(fp)
    1a70:	10c07cc4 	addi	r3,r2,499
    1a74:	00807d04 	movi	r2,500
    1a78:	1885283a 	div	r2,r3,r2
    1a7c:	1007883a 	mov	r3,r2
    1a80:	e0bffd17 	ldw	r2,-12(fp)
    1a84:	10c0078d 	sth	r3,30(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_check(): set request timeout %"U16_F" msecs\n", msecs));
}
    1a88:	e037883a 	mov	sp,fp
    1a8c:	dfc00117 	ldw	ra,4(sp)
    1a90:	df000017 	ldw	fp,0(sp)
    1a94:	dec00204 	addi	sp,sp,8
    1a98:	f800283a 	ret

00001a9c <dhcp_handle_offer>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_offer(struct netif *netif)
{
    1a9c:	defffa04 	addi	sp,sp,-24
    1aa0:	dfc00515 	stw	ra,20(sp)
    1aa4:	df000415 	stw	fp,16(sp)
    1aa8:	dc000315 	stw	r16,12(sp)
    1aac:	df000304 	addi	fp,sp,12
    1ab0:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    1ab4:	e0bfff17 	ldw	r2,-4(fp)
    1ab8:	10800817 	ldw	r2,32(r2)
    1abc:	e0bffd15 	stw	r2,-12(fp)
  /* obtain the server address */
  u8_t *option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SERVER_ID);
    1ac0:	e13ffd17 	ldw	r4,-12(fp)
    1ac4:	01400d84 	movi	r5,54
    1ac8:	0004a900 	call	4a90 <dhcp_get_option_ptr>
    1acc:	e0bffe15 	stw	r2,-8(fp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  if (option_ptr != NULL) {
    1ad0:	e0bffe17 	ldw	r2,-8(fp)
    1ad4:	10002b26 	beq	r2,zero,1b84 <dhcp_handle_offer+0xe8>
    dhcp->server_ip_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
    1ad8:	e0bffe17 	ldw	r2,-8(fp)
    1adc:	10800084 	addi	r2,r2,2
    1ae0:	1009883a 	mov	r4,r2
    1ae4:	0004cec0 	call	4cec <dhcp_get_option_long>
    1ae8:	1020d63a 	srli	r16,r2,24
    1aec:	e0bffe17 	ldw	r2,-8(fp)
    1af0:	10800084 	addi	r2,r2,2
    1af4:	1009883a 	mov	r4,r2
    1af8:	0004cec0 	call	4cec <dhcp_get_option_long>
    1afc:	1004d23a 	srli	r2,r2,8
    1b00:	10bfc00c 	andi	r2,r2,65280
    1b04:	80a0b03a 	or	r16,r16,r2
    1b08:	e0bffe17 	ldw	r2,-8(fp)
    1b0c:	10800084 	addi	r2,r2,2
    1b10:	1009883a 	mov	r4,r2
    1b14:	0004cec0 	call	4cec <dhcp_get_option_long>
    1b18:	10bfc00c 	andi	r2,r2,65280
    1b1c:	1004923a 	slli	r2,r2,8
    1b20:	80a0b03a 	or	r16,r16,r2
    1b24:	e0bffe17 	ldw	r2,-8(fp)
    1b28:	10800084 	addi	r2,r2,2
    1b2c:	1009883a 	mov	r4,r2
    1b30:	0004cec0 	call	4cec <dhcp_get_option_long>
    1b34:	1004963a 	slli	r2,r2,24
    1b38:	8086b03a 	or	r3,r16,r2
    1b3c:	e0bffd17 	ldw	r2,-12(fp)
    1b40:	10c00915 	stw	r3,36(r2)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n", dhcp->server_ip_addr.addr));
    /* remember offered address */
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
    1b44:	e0bffd17 	ldw	r2,-12(fp)
    1b48:	10800217 	ldw	r2,8(r2)
    1b4c:	10800404 	addi	r2,r2,16
    1b50:	10000726 	beq	r2,zero,1b70 <dhcp_handle_offer+0xd4>
    1b54:	e0bffd17 	ldw	r2,-12(fp)
    1b58:	10800217 	ldw	r2,8(r2)
    1b5c:	10c0040b 	ldhu	r3,16(r2)
    1b60:	1080048b 	ldhu	r2,18(r2)
    1b64:	1004943a 	slli	r2,r2,16
    1b68:	10c4b03a 	or	r2,r2,r3
    1b6c:	00000106 	br	1b74 <dhcp_handle_offer+0xd8>
    1b70:	0005883a 	mov	r2,zero
    1b74:	e0fffd17 	ldw	r3,-12(fp)
    1b78:	18800a15 	stw	r2,40(r3)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): offer for 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));

    dhcp_select(netif);
    1b7c:	e13fff17 	ldw	r4,-4(fp)
    1b80:	0001b9c0 	call	1b9c <dhcp_select>
  }
}
    1b84:	e037883a 	mov	sp,fp
    1b88:	dfc00217 	ldw	ra,8(sp)
    1b8c:	df000117 	ldw	fp,4(sp)
    1b90:	dc000017 	ldw	r16,0(sp)
    1b94:	dec00304 	addi	sp,sp,12
    1b98:	f800283a 	ret

00001b9c <dhcp_select>:
 * @param netif the netif under DHCP control
 * @return lwIP specific error (see error.h)
 */
static err_t
dhcp_select(struct netif *netif)
{
    1b9c:	defffa04 	addi	sp,sp,-24
    1ba0:	dfc00515 	stw	ra,20(sp)
    1ba4:	df000415 	stw	fp,16(sp)
    1ba8:	df000404 	addi	fp,sp,16
    1bac:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    1bb0:	e0bfff17 	ldw	r2,-4(fp)
    1bb4:	10800817 	ldw	r2,32(r2)
    1bb8:	e0bffd15 	stw	r2,-12(fp)
#if LWIP_NETIF_HOSTNAME
  const char *p;
#endif /* LWIP_NETIF_HOSTNAME */

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_select(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  dhcp_set_state(dhcp, DHCP_REQUESTING);
    1bbc:	e13ffd17 	ldw	r4,-12(fp)
    1bc0:	01400044 	movi	r5,1
    1bc4:	00039b00 	call	39b0 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
    1bc8:	e13fff17 	ldw	r4,-4(fp)
    1bcc:	00043540 	call	4354 <dhcp_create_request>
    1bd0:	e0bffe05 	stb	r2,-8(fp)
  if (result == ERR_OK) {
    1bd4:	e0bffe07 	ldb	r2,-8(fp)
    1bd8:	10006a1e 	bne	r2,zero,1d84 <dhcp_select+0x1e8>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
    1bdc:	e13ffd17 	ldw	r4,-12(fp)
    1be0:	01400d44 	movi	r5,53
    1be4:	01800044 	movi	r6,1
    1be8:	0003a000 	call	3a00 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
    1bec:	e13ffd17 	ldw	r4,-12(fp)
    1bf0:	014000c4 	movi	r5,3
    1bf4:	0003ae40 	call	3ae4 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    1bf8:	e13ffd17 	ldw	r4,-12(fp)
    1bfc:	01400e44 	movi	r5,57
    1c00:	01800084 	movi	r6,2
    1c04:	0003a000 	call	3a00 <dhcp_option>
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
    1c08:	e0bfff17 	ldw	r2,-4(fp)
    1c0c:	1080090b 	ldhu	r2,36(r2)
    1c10:	10bfffcc 	andi	r2,r2,65535
    1c14:	e13ffd17 	ldw	r4,-12(fp)
    1c18:	100b883a 	mov	r5,r2
    1c1c:	0003b800 	call	3b80 <dhcp_option_short>

    /* MUST request the offered IP address */
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
    1c20:	e13ffd17 	ldw	r4,-12(fp)
    1c24:	01400c84 	movi	r5,50
    1c28:	01800104 	movi	r6,4
    1c2c:	0003a000 	call	3a00 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
    1c30:	e0bffd17 	ldw	r2,-12(fp)
    1c34:	10800a17 	ldw	r2,40(r2)
    1c38:	1006d63a 	srli	r3,r2,24
    1c3c:	e0bffd17 	ldw	r2,-12(fp)
    1c40:	10800a17 	ldw	r2,40(r2)
    1c44:	1004d23a 	srli	r2,r2,8
    1c48:	10bfc00c 	andi	r2,r2,65280
    1c4c:	1886b03a 	or	r3,r3,r2
    1c50:	e0bffd17 	ldw	r2,-12(fp)
    1c54:	10800a17 	ldw	r2,40(r2)
    1c58:	10bfc00c 	andi	r2,r2,65280
    1c5c:	1004923a 	slli	r2,r2,8
    1c60:	1886b03a 	or	r3,r3,r2
    1c64:	e0bffd17 	ldw	r2,-12(fp)
    1c68:	10800a17 	ldw	r2,40(r2)
    1c6c:	1004963a 	slli	r2,r2,24
    1c70:	1884b03a 	or	r2,r3,r2
    1c74:	e13ffd17 	ldw	r4,-12(fp)
    1c78:	100b883a 	mov	r5,r2
    1c7c:	0003c580 	call	3c58 <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    1c80:	e13ffd17 	ldw	r4,-12(fp)
    1c84:	01400d84 	movi	r5,54
    1c88:	01800104 	movi	r6,4
    1c8c:	0003a000 	call	3a00 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
    1c90:	e0bffd17 	ldw	r2,-12(fp)
    1c94:	10800917 	ldw	r2,36(r2)
    1c98:	1006d63a 	srli	r3,r2,24
    1c9c:	e0bffd17 	ldw	r2,-12(fp)
    1ca0:	10800917 	ldw	r2,36(r2)
    1ca4:	1004d23a 	srli	r2,r2,8
    1ca8:	10bfc00c 	andi	r2,r2,65280
    1cac:	1886b03a 	or	r3,r3,r2
    1cb0:	e0bffd17 	ldw	r2,-12(fp)
    1cb4:	10800917 	ldw	r2,36(r2)
    1cb8:	10bfc00c 	andi	r2,r2,65280
    1cbc:	1004923a 	slli	r2,r2,8
    1cc0:	1886b03a 	or	r3,r3,r2
    1cc4:	e0bffd17 	ldw	r2,-12(fp)
    1cc8:	10800917 	ldw	r2,36(r2)
    1ccc:	1004963a 	slli	r2,r2,24
    1cd0:	1884b03a 	or	r2,r3,r2
    1cd4:	e13ffd17 	ldw	r4,-12(fp)
    1cd8:	100b883a 	mov	r5,r2
    1cdc:	0003c580 	call	3c58 <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
    1ce0:	e13ffd17 	ldw	r4,-12(fp)
    1ce4:	01400dc4 	movi	r5,55
    1ce8:	01800104 	movi	r6,4
    1cec:	0003a000 	call	3a00 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
    1cf0:	e13ffd17 	ldw	r4,-12(fp)
    1cf4:	01400044 	movi	r5,1
    1cf8:	0003ae40 	call	3ae4 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
    1cfc:	e13ffd17 	ldw	r4,-12(fp)
    1d00:	014000c4 	movi	r5,3
    1d04:	0003ae40 	call	3ae4 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
    1d08:	e13ffd17 	ldw	r4,-12(fp)
    1d0c:	01400704 	movi	r5,28
    1d10:	0003ae40 	call	3ae4 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
    1d14:	e13ffd17 	ldw	r4,-12(fp)
    1d18:	01400184 	movi	r5,6
    1d1c:	0003ae40 	call	3ae4 <dhcp_option_byte>
        dhcp_option_byte(dhcp, *p++);
      }
    }
#endif /* LWIP_NETIF_HOSTNAME */

    dhcp_option_trailer(dhcp);
    1d20:	e13ffd17 	ldw	r4,-12(fp)
    1d24:	000490c0 	call	490c <dhcp_option_trailer>
    /* shrink the pbuf to the actual content length */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    1d28:	e0bffd17 	ldw	r2,-12(fp)
    1d2c:	10c00517 	ldw	r3,20(r2)
    1d30:	e0bffd17 	ldw	r2,-12(fp)
    1d34:	1080070b 	ldhu	r2,28(r2)
    1d38:	10803c04 	addi	r2,r2,240
    1d3c:	10bfffcc 	andi	r2,r2,65535
    1d40:	1809883a 	mov	r4,r3
    1d44:	100b883a 	mov	r5,r2
    1d48:	0009d0c0 	call	9d0c <pbuf_realloc>

    /* send broadcast to any DHCP server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    1d4c:	e0bffd17 	ldw	r2,-12(fp)
    1d50:	10c00117 	ldw	r3,4(r2)
    1d54:	e0bffd17 	ldw	r2,-12(fp)
    1d58:	10800517 	ldw	r2,20(r2)
    1d5c:	e13fff17 	ldw	r4,-4(fp)
    1d60:	d9000015 	stw	r4,0(sp)
    1d64:	1809883a 	mov	r4,r3
    1d68:	100b883a 	mov	r5,r2
    1d6c:	018000f4 	movhi	r6,3
    1d70:	3190ee04 	addi	r6,r6,17336
    1d74:	01c010c4 	movi	r7,67
    1d78:	001493c0 	call	1493c <udp_sendto_if>
    dhcp_delete_request(netif);
    1d7c:	e13fff17 	ldw	r4,-4(fp)
    1d80:	00047f40 	call	47f4 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("dhcp_select: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
    1d84:	e0bffd17 	ldw	r2,-12(fp)
    1d88:	108004c3 	ldbu	r2,19(r2)
    1d8c:	10800044 	addi	r2,r2,1
    1d90:	1007883a 	mov	r3,r2
    1d94:	e0bffd17 	ldw	r2,-12(fp)
    1d98:	10c004c5 	stb	r3,19(r2)
  msecs = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
    1d9c:	e0bffd17 	ldw	r2,-12(fp)
    1da0:	108004c3 	ldbu	r2,19(r2)
    1da4:	10803fcc 	andi	r2,r2,255
    1da8:	108001a8 	cmpgeui	r2,r2,6
    1dac:	1000061e 	bne	r2,zero,1dc8 <dhcp_select+0x22c>
    1db0:	e0bffd17 	ldw	r2,-12(fp)
    1db4:	108004c3 	ldbu	r2,19(r2)
    1db8:	10803fcc 	andi	r2,r2,255
    1dbc:	00c0fa04 	movi	r3,1000
    1dc0:	1884983a 	sll	r2,r3,r2
    1dc4:	00000106 	br	1dcc <dhcp_select+0x230>
    1dc8:	00ba9804 	movi	r2,-5536
    1dcc:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    1dd0:	e0bffe8b 	ldhu	r2,-6(fp)
    1dd4:	10c07cc4 	addi	r3,r2,499
    1dd8:	00807d04 	movi	r2,500
    1ddc:	1885283a 	div	r2,r3,r2
    1de0:	1007883a 	mov	r3,r2
    1de4:	e0bffd17 	ldw	r2,-12(fp)
    1de8:	10c0078d 	sth	r3,30(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
    1dec:	e0bffe03 	ldbu	r2,-8(fp)
}
    1df0:	e037883a 	mov	sp,fp
    1df4:	dfc00117 	ldw	ra,4(sp)
    1df8:	df000017 	ldw	fp,0(sp)
    1dfc:	dec00204 	addi	sp,sp,8
    1e00:	f800283a 	ret

00001e04 <dhcp_coarse_tmr>:
 * The DHCP timer that checks for lease renewal/rebind timeouts.
 *
 */
void
dhcp_coarse_tmr()
{
    1e04:	defffd04 	addi	sp,sp,-12
    1e08:	dfc00215 	stw	ra,8(sp)
    1e0c:	df000115 	stw	fp,4(sp)
    1e10:	df000104 	addi	fp,sp,4
  struct netif *netif = netif_list;
    1e14:	008000f4 	movhi	r2,3
    1e18:	1099be04 	addi	r2,r2,26360
    1e1c:	10800017 	ldw	r2,0(r2)
    1e20:	e0bfff15 	stw	r2,-4(fp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
    1e24:	00001d06 	br	1e9c <dhcp_coarse_tmr+0x98>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
    1e28:	e0bfff17 	ldw	r2,-4(fp)
    1e2c:	10800817 	ldw	r2,32(r2)
    1e30:	10001726 	beq	r2,zero,1e90 <dhcp_coarse_tmr+0x8c>
      /* timer is active (non zero), and triggers (zeroes) now? */
      if (netif->dhcp->t2_timeout-- == 1) {
    1e34:	e0bfff17 	ldw	r2,-4(fp)
    1e38:	10800817 	ldw	r2,32(r2)
    1e3c:	10c0088b 	ldhu	r3,34(r2)
    1e40:	193fffcc 	andi	r4,r3,65535
    1e44:	21000060 	cmpeqi	r4,r4,1
    1e48:	18ffffc4 	addi	r3,r3,-1
    1e4c:	10c0088d 	sth	r3,34(r2)
    1e50:	20803fcc 	andi	r2,r4,255
    1e54:	10000326 	beq	r2,zero,1e64 <dhcp_coarse_tmr+0x60>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
        /* this clients' rebind timeout triggered */
        dhcp_t2_timeout(netif);
    1e58:	e13fff17 	ldw	r4,-4(fp)
    1e5c:	00021800 	call	2180 <dhcp_t2_timeout>
    1e60:	00000b06 	br	1e90 <dhcp_coarse_tmr+0x8c>
      /* timer is active (non zero), and triggers (zeroes) now */
      } else if (netif->dhcp->t1_timeout-- == 1) {
    1e64:	e0bfff17 	ldw	r2,-4(fp)
    1e68:	10800817 	ldw	r2,32(r2)
    1e6c:	10c0080b 	ldhu	r3,32(r2)
    1e70:	193fffcc 	andi	r4,r3,65535
    1e74:	21000060 	cmpeqi	r4,r4,1
    1e78:	18ffffc4 	addi	r3,r3,-1
    1e7c:	10c0080d 	sth	r3,32(r2)
    1e80:	20803fcc 	andi	r2,r4,255
    1e84:	10000226 	beq	r2,zero,1e90 <dhcp_coarse_tmr+0x8c>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t1 timeout\n"));
        /* this clients' renewal timeout triggered */
        dhcp_t1_timeout(netif);
    1e88:	e13fff17 	ldw	r4,-4(fp)
    1e8c:	00021080 	call	2108 <dhcp_t1_timeout>
      }
    }
    /* proceed to next netif */
    netif = netif->next;
    1e90:	e0bfff17 	ldw	r2,-4(fp)
    1e94:	10800017 	ldw	r2,0(r2)
    1e98:	e0bfff15 	stw	r2,-4(fp)
dhcp_coarse_tmr()
{
  struct netif *netif = netif_list;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
    1e9c:	e0bfff17 	ldw	r2,-4(fp)
    1ea0:	103fe11e 	bne	r2,zero,1e28 <dhcp_coarse_tmr+0x24>
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  }
}
    1ea4:	e037883a 	mov	sp,fp
    1ea8:	dfc00117 	ldw	ra,4(sp)
    1eac:	df000017 	ldw	fp,0(sp)
    1eb0:	dec00204 	addi	sp,sp,8
    1eb4:	f800283a 	ret

00001eb8 <dhcp_fine_tmr>:
 * This timer checks whether an outstanding DHCP request is timed out.
 * 
 */
void
dhcp_fine_tmr()
{
    1eb8:	defffd04 	addi	sp,sp,-12
    1ebc:	dfc00215 	stw	ra,8(sp)
    1ec0:	df000115 	stw	fp,4(sp)
    1ec4:	df000104 	addi	fp,sp,4
  struct netif *netif = netif_list;
    1ec8:	008000f4 	movhi	r2,3
    1ecc:	1099be04 	addi	r2,r2,26360
    1ed0:	10800017 	ldw	r2,0(r2)
    1ed4:	e0bfff15 	stw	r2,-4(fp)
  /* loop through netif's */
  while (netif != NULL) {
    1ed8:	00001f06 	br	1f58 <dhcp_fine_tmr+0xa0>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
    1edc:	e0bfff17 	ldw	r2,-4(fp)
    1ee0:	10800817 	ldw	r2,32(r2)
    1ee4:	10001926 	beq	r2,zero,1f4c <dhcp_fine_tmr+0x94>
      /* timer is active (non zero), and is about to trigger now */      
      if (netif->dhcp->request_timeout > 1) {
    1ee8:	e0bfff17 	ldw	r2,-4(fp)
    1eec:	10800817 	ldw	r2,32(r2)
    1ef0:	1080078b 	ldhu	r2,30(r2)
    1ef4:	10bfffcc 	andi	r2,r2,65535
    1ef8:	108000b0 	cmpltui	r2,r2,2
    1efc:	1000061e 	bne	r2,zero,1f18 <dhcp_fine_tmr+0x60>
        netif->dhcp->request_timeout--;
    1f00:	e0bfff17 	ldw	r2,-4(fp)
    1f04:	10800817 	ldw	r2,32(r2)
    1f08:	10c0078b 	ldhu	r3,30(r2)
    1f0c:	18ffffc4 	addi	r3,r3,-1
    1f10:	10c0078d 	sth	r3,30(r2)
    1f14:	00000d06 	br	1f4c <dhcp_fine_tmr+0x94>
      }
      else if (netif->dhcp->request_timeout == 1) {
    1f18:	e0bfff17 	ldw	r2,-4(fp)
    1f1c:	10800817 	ldw	r2,32(r2)
    1f20:	1080078b 	ldhu	r2,30(r2)
    1f24:	10bfffcc 	andi	r2,r2,65535
    1f28:	10800058 	cmpnei	r2,r2,1
    1f2c:	1000071e 	bne	r2,zero,1f4c <dhcp_fine_tmr+0x94>
        netif->dhcp->request_timeout--;
    1f30:	e0bfff17 	ldw	r2,-4(fp)
    1f34:	10800817 	ldw	r2,32(r2)
    1f38:	10c0078b 	ldhu	r3,30(r2)
    1f3c:	18ffffc4 	addi	r3,r3,-1
    1f40:	10c0078d 	sth	r3,30(r2)
        /* { netif->dhcp->request_timeout == 0 } */
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_fine_tmr(): request timeout\n"));
        /* this clients' request timeout triggered */
        dhcp_timeout(netif);
    1f44:	e13fff17 	ldw	r4,-4(fp)
    1f48:	0001f740 	call	1f74 <dhcp_timeout>
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
    1f4c:	e0bfff17 	ldw	r2,-4(fp)
    1f50:	10800017 	ldw	r2,0(r2)
    1f54:	e0bfff15 	stw	r2,-4(fp)
void
dhcp_fine_tmr()
{
  struct netif *netif = netif_list;
  /* loop through netif's */
  while (netif != NULL) {
    1f58:	e0bfff17 	ldw	r2,-4(fp)
    1f5c:	103fdf1e 	bne	r2,zero,1edc <dhcp_fine_tmr+0x24>
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  }
}
    1f60:	e037883a 	mov	sp,fp
    1f64:	dfc00117 	ldw	ra,4(sp)
    1f68:	df000017 	ldw	fp,0(sp)
    1f6c:	dec00204 	addi	sp,sp,8
    1f70:	f800283a 	ret

00001f74 <dhcp_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_timeout(struct netif *netif)
{
    1f74:	defffc04 	addi	sp,sp,-16
    1f78:	dfc00315 	stw	ra,12(sp)
    1f7c:	df000215 	stw	fp,8(sp)
    1f80:	df000204 	addi	fp,sp,8
    1f84:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    1f88:	e0bfff17 	ldw	r2,-4(fp)
    1f8c:	10800817 	ldw	r2,32(r2)
    1f90:	e0bffe15 	stw	r2,-8(fp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout()\n"));
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
    1f94:	e0bffe17 	ldw	r2,-8(fp)
    1f98:	10800483 	ldbu	r2,18(r2)
    1f9c:	10803fcc 	andi	r2,r2,255
    1fa0:	10800320 	cmpeqi	r2,r2,12
    1fa4:	1000051e 	bne	r2,zero,1fbc <dhcp_timeout+0x48>
    1fa8:	e0bffe17 	ldw	r2,-8(fp)
    1fac:	10800483 	ldbu	r2,18(r2)
    1fb0:	10803fcc 	andi	r2,r2,255
    1fb4:	10800198 	cmpnei	r2,r2,6
    1fb8:	1000031e 	bne	r2,zero,1fc8 <dhcp_timeout+0x54>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
    1fbc:	e13fff17 	ldw	r4,-4(fp)
    1fc0:	0002cc00 	call	2cc0 <dhcp_discover>
    1fc4:	00004b06 	br	20f4 <dhcp_timeout+0x180>
  /* receiving the requested lease timed out */
  } else if (dhcp->state == DHCP_REQUESTING) {
    1fc8:	e0bffe17 	ldw	r2,-8(fp)
    1fcc:	10800483 	ldbu	r2,18(r2)
    1fd0:	10803fcc 	andi	r2,r2,255
    1fd4:	10800058 	cmpnei	r2,r2,1
    1fd8:	10000d1e 	bne	r2,zero,2010 <dhcp_timeout+0x9c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
    if (dhcp->tries <= 5) {
    1fdc:	e0bffe17 	ldw	r2,-8(fp)
    1fe0:	108004c3 	ldbu	r2,19(r2)
    1fe4:	10803fcc 	andi	r2,r2,255
    1fe8:	108001a8 	cmpgeui	r2,r2,6
    1fec:	1000031e 	bne	r2,zero,1ffc <dhcp_timeout+0x88>
      dhcp_select(netif);
    1ff0:	e13fff17 	ldw	r4,-4(fp)
    1ff4:	0001b9c0 	call	1b9c <dhcp_select>
    1ff8:	00003e06 	br	20f4 <dhcp_timeout+0x180>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, releasing, restarting\n"));
      dhcp_release(netif);
    1ffc:	e13fff17 	ldw	r4,-4(fp)
    2000:	00036d00 	call	36d0 <dhcp_release>
      dhcp_discover(netif);
    2004:	e13fff17 	ldw	r4,-4(fp)
    2008:	0002cc00 	call	2cc0 <dhcp_discover>
    200c:	00003906 	br	20f4 <dhcp_timeout+0x180>
    }
#if DHCP_DOES_ARP_CHECK
  /* received no ARP reply for the offered address (which is good) */
  } else if (dhcp->state == DHCP_CHECKING) {
    2010:	e0bffe17 	ldw	r2,-8(fp)
    2014:	10800483 	ldbu	r2,18(r2)
    2018:	10803fcc 	andi	r2,r2,255
    201c:	10800218 	cmpnei	r2,r2,8
    2020:	10000b1e 	bne	r2,zero,2050 <dhcp_timeout+0xdc>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): CHECKING, ARP request timed out\n"));
    if (dhcp->tries <= 1) {
    2024:	e0bffe17 	ldw	r2,-8(fp)
    2028:	108004c3 	ldbu	r2,19(r2)
    202c:	10803fcc 	andi	r2,r2,255
    2030:	108000a8 	cmpgeui	r2,r2,2
    2034:	1000031e 	bne	r2,zero,2044 <dhcp_timeout+0xd0>
      dhcp_check(netif);
    2038:	e13fff17 	ldw	r4,-4(fp)
    203c:	0001a040 	call	1a04 <dhcp_check>
    2040:	00002c06 	br	20f4 <dhcp_timeout+0x180>
    /* no ARP replies on the offered address,
       looks like the IP address is indeed free */
    } else {
      /* bind the interface to the offered address */
      dhcp_bind(netif);
    2044:	e13fff17 	ldw	r4,-4(fp)
    2048:	0002e900 	call	2e90 <dhcp_bind>
    204c:	00002906 	br	20f4 <dhcp_timeout+0x180>
    }
#endif /* DHCP_DOES_ARP_CHECK */
  }
  /* did not get response to renew request? */
  else if (dhcp->state == DHCP_RENEWING) {
    2050:	e0bffe17 	ldw	r2,-8(fp)
    2054:	10800483 	ldbu	r2,18(r2)
    2058:	10803fcc 	andi	r2,r2,255
    205c:	10800158 	cmpnei	r2,r2,5
    2060:	1000031e 	bne	r2,zero,2070 <dhcp_timeout+0xfc>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RENEWING, DHCP request timed out\n"));
    /* just retry renewal */
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
    2064:	e13fff17 	ldw	r4,-4(fp)
    2068:	00032500 	call	3250 <dhcp_renew>
    206c:	00002106 	br	20f4 <dhcp_timeout+0x180>
  /* did not get response to rebind request? */
  } else if (dhcp->state == DHCP_REBINDING) {
    2070:	e0bffe17 	ldw	r2,-8(fp)
    2074:	10800483 	ldbu	r2,18(r2)
    2078:	10803fcc 	andi	r2,r2,255
    207c:	10800118 	cmpnei	r2,r2,4
    2080:	10000d1e 	bne	r2,zero,20b8 <dhcp_timeout+0x144>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
    if (dhcp->tries <= 8) {
    2084:	e0bffe17 	ldw	r2,-8(fp)
    2088:	108004c3 	ldbu	r2,19(r2)
    208c:	10803fcc 	andi	r2,r2,255
    2090:	10800268 	cmpgeui	r2,r2,9
    2094:	1000031e 	bne	r2,zero,20a4 <dhcp_timeout+0x130>
      dhcp_rebind(netif);
    2098:	e13fff17 	ldw	r4,-4(fp)
    209c:	00033b40 	call	33b4 <dhcp_rebind>
    20a0:	00001406 	br	20f4 <dhcp_timeout+0x180>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
    20a4:	e13fff17 	ldw	r4,-4(fp)
    20a8:	00036d00 	call	36d0 <dhcp_release>
      dhcp_discover(netif);
    20ac:	e13fff17 	ldw	r4,-4(fp)
    20b0:	0002cc00 	call	2cc0 <dhcp_discover>
    20b4:	00000f06 	br	20f4 <dhcp_timeout+0x180>
    }
  } else if (dhcp->state == DHCP_REBOOTING) {
    20b8:	e0bffe17 	ldw	r2,-8(fp)
    20bc:	10800483 	ldbu	r2,18(r2)
    20c0:	10803fcc 	andi	r2,r2,255
    20c4:	108000d8 	cmpnei	r2,r2,3
    20c8:	10000a1e 	bne	r2,zero,20f4 <dhcp_timeout+0x180>
    if (dhcp->tries < REBOOT_TRIES) {
    20cc:	e0bffe17 	ldw	r2,-8(fp)
    20d0:	108004c3 	ldbu	r2,19(r2)
    20d4:	10803fcc 	andi	r2,r2,255
    20d8:	108000a8 	cmpgeui	r2,r2,2
    20dc:	1000031e 	bne	r2,zero,20ec <dhcp_timeout+0x178>
      dhcp_reboot(netif);
    20e0:	e13fff17 	ldw	r4,-4(fp)
    20e4:	00035180 	call	3518 <dhcp_reboot>
    20e8:	00000206 	br	20f4 <dhcp_timeout+0x180>
    } else {
      dhcp_discover(netif);
    20ec:	e13fff17 	ldw	r4,-4(fp)
    20f0:	0002cc00 	call	2cc0 <dhcp_discover>
    }
  }
}
    20f4:	e037883a 	mov	sp,fp
    20f8:	dfc00117 	ldw	ra,4(sp)
    20fc:	df000017 	ldw	fp,0(sp)
    2100:	dec00204 	addi	sp,sp,8
    2104:	f800283a 	ret

00002108 <dhcp_t1_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_t1_timeout(struct netif *netif)
{
    2108:	defffc04 	addi	sp,sp,-16
    210c:	dfc00315 	stw	ra,12(sp)
    2110:	df000215 	stw	fp,8(sp)
    2114:	df000204 	addi	fp,sp,8
    2118:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    211c:	e0bfff17 	ldw	r2,-4(fp)
    2120:	10800817 	ldw	r2,32(r2)
    2124:	e0bffe15 	stw	r2,-8(fp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
    2128:	e0bffe17 	ldw	r2,-8(fp)
    212c:	10800483 	ldbu	r2,18(r2)
    2130:	10803fcc 	andi	r2,r2,255
    2134:	10800060 	cmpeqi	r2,r2,1
    2138:	10000a1e 	bne	r2,zero,2164 <dhcp_t1_timeout+0x5c>
    213c:	e0bffe17 	ldw	r2,-8(fp)
    2140:	10800483 	ldbu	r2,18(r2)
    2144:	10803fcc 	andi	r2,r2,255
    2148:	108002a0 	cmpeqi	r2,r2,10
    214c:	1000051e 	bne	r2,zero,2164 <dhcp_t1_timeout+0x5c>
    2150:	e0bffe17 	ldw	r2,-8(fp)
    2154:	10800483 	ldbu	r2,18(r2)
    2158:	10803fcc 	andi	r2,r2,255
    215c:	10800158 	cmpnei	r2,r2,5
    2160:	1000021e 	bne	r2,zero,216c <dhcp_t1_timeout+0x64>
    /* just retry to renew - note that the rebind timer (t2) will
     * eventually time-out if renew tries fail. */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t1_timeout(): must renew\n"));
    dhcp_renew(netif);
    2164:	e13fff17 	ldw	r4,-4(fp)
    2168:	00032500 	call	3250 <dhcp_renew>
  }
}
    216c:	e037883a 	mov	sp,fp
    2170:	dfc00117 	ldw	ra,4(sp)
    2174:	df000017 	ldw	fp,0(sp)
    2178:	dec00204 	addi	sp,sp,8
    217c:	f800283a 	ret

00002180 <dhcp_t2_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_t2_timeout(struct netif *netif)
{
    2180:	defffc04 	addi	sp,sp,-16
    2184:	dfc00315 	stw	ra,12(sp)
    2188:	df000215 	stw	fp,8(sp)
    218c:	df000204 	addi	fp,sp,8
    2190:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    2194:	e0bfff17 	ldw	r2,-4(fp)
    2198:	10800817 	ldw	r2,32(r2)
    219c:	e0bffe15 	stw	r2,-8(fp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
    21a0:	e0bffe17 	ldw	r2,-8(fp)
    21a4:	10800483 	ldbu	r2,18(r2)
    21a8:	10803fcc 	andi	r2,r2,255
    21ac:	10800060 	cmpeqi	r2,r2,1
    21b0:	10000a1e 	bne	r2,zero,21dc <dhcp_t2_timeout+0x5c>
    21b4:	e0bffe17 	ldw	r2,-8(fp)
    21b8:	10800483 	ldbu	r2,18(r2)
    21bc:	10803fcc 	andi	r2,r2,255
    21c0:	108002a0 	cmpeqi	r2,r2,10
    21c4:	1000051e 	bne	r2,zero,21dc <dhcp_t2_timeout+0x5c>
    21c8:	e0bffe17 	ldw	r2,-8(fp)
    21cc:	10800483 	ldbu	r2,18(r2)
    21d0:	10803fcc 	andi	r2,r2,255
    21d4:	10800158 	cmpnei	r2,r2,5
    21d8:	1000021e 	bne	r2,zero,21e4 <dhcp_t2_timeout+0x64>
    /* just retry to rebind */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout(): must rebind\n"));
    dhcp_rebind(netif);
    21dc:	e13fff17 	ldw	r4,-4(fp)
    21e0:	00033b40 	call	33b4 <dhcp_rebind>
  }
}
    21e4:	e037883a 	mov	sp,fp
    21e8:	dfc00117 	ldw	ra,4(sp)
    21ec:	df000017 	ldw	fp,0(sp)
    21f0:	dec00204 	addi	sp,sp,8
    21f4:	f800283a 	ret

000021f8 <dhcp_handle_ack>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_ack(struct netif *netif)
{
    21f8:	defff804 	addi	sp,sp,-32
    21fc:	dfc00715 	stw	ra,28(sp)
    2200:	df000615 	stw	fp,24(sp)
    2204:	dc400515 	stw	r17,20(sp)
    2208:	dc000415 	stw	r16,16(sp)
    220c:	df000404 	addi	fp,sp,16
    2210:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    2214:	e0bfff17 	ldw	r2,-4(fp)
    2218:	10800817 	ldw	r2,32(r2)
    221c:	e0bffd15 	stw	r2,-12(fp)
  u8_t *option_ptr;
  /* clear options we might not get from the ACK */
  dhcp->offered_sn_mask.addr = 0;
    2220:	e0bffd17 	ldw	r2,-12(fp)
    2224:	10000b15 	stw	zero,44(r2)
  dhcp->offered_gw_addr.addr = 0;
    2228:	e0bffd17 	ldw	r2,-12(fp)
    222c:	10000c15 	stw	zero,48(r2)
  dhcp->offered_bc_addr.addr = 0;
    2230:	e0bffd17 	ldw	r2,-12(fp)
    2234:	10000d15 	stw	zero,52(r2)

  /* lease time given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_LEASE_TIME);
    2238:	e13ffd17 	ldw	r4,-12(fp)
    223c:	01400cc4 	movi	r5,51
    2240:	0004a900 	call	4a90 <dhcp_get_option_ptr>
    2244:	e0bffe15 	stw	r2,-8(fp)
  if (option_ptr != NULL) {
    2248:	e0bffe17 	ldw	r2,-8(fp)
    224c:	10000626 	beq	r2,zero,2268 <dhcp_handle_ack+0x70>
    /* remember offered lease time */
    dhcp->offered_t0_lease = dhcp_get_option_long(option_ptr + 2);
    2250:	e0bffe17 	ldw	r2,-8(fp)
    2254:	10800084 	addi	r2,r2,2
    2258:	1009883a 	mov	r4,r2
    225c:	0004cec0 	call	4cec <dhcp_get_option_long>
    2260:	e0fffd17 	ldw	r3,-12(fp)
    2264:	18801115 	stw	r2,68(r3)
  }
  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T1);
    2268:	e13ffd17 	ldw	r4,-12(fp)
    226c:	01400e84 	movi	r5,58
    2270:	0004a900 	call	4a90 <dhcp_get_option_ptr>
    2274:	e0bffe15 	stw	r2,-8(fp)
  if (option_ptr != NULL) {
    2278:	e0bffe17 	ldw	r2,-8(fp)
    227c:	10000726 	beq	r2,zero,229c <dhcp_handle_ack+0xa4>
    /* remember given renewal period */
    dhcp->offered_t1_renew = dhcp_get_option_long(option_ptr + 2);
    2280:	e0bffe17 	ldw	r2,-8(fp)
    2284:	10800084 	addi	r2,r2,2
    2288:	1009883a 	mov	r4,r2
    228c:	0004cec0 	call	4cec <dhcp_get_option_long>
    2290:	e0fffd17 	ldw	r3,-12(fp)
    2294:	18801215 	stw	r2,72(r3)
    2298:	00000506 	br	22b0 <dhcp_handle_ack+0xb8>
  } else {
    /* calculate safe periods for renewal */
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
    229c:	e0bffd17 	ldw	r2,-12(fp)
    22a0:	10801117 	ldw	r2,68(r2)
    22a4:	1006d07a 	srli	r3,r2,1
    22a8:	e0bffd17 	ldw	r2,-12(fp)
    22ac:	10c01215 	stw	r3,72(r2)
  }

  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T2);
    22b0:	e13ffd17 	ldw	r4,-12(fp)
    22b4:	01400ec4 	movi	r5,59
    22b8:	0004a900 	call	4a90 <dhcp_get_option_ptr>
    22bc:	e0bffe15 	stw	r2,-8(fp)
  if (option_ptr != NULL) {
    22c0:	e0bffe17 	ldw	r2,-8(fp)
    22c4:	10000726 	beq	r2,zero,22e4 <dhcp_handle_ack+0xec>
    /* remember given rebind period */
    dhcp->offered_t2_rebind = dhcp_get_option_long(option_ptr + 2);
    22c8:	e0bffe17 	ldw	r2,-8(fp)
    22cc:	10800084 	addi	r2,r2,2
    22d0:	1009883a 	mov	r4,r2
    22d4:	0004cec0 	call	4cec <dhcp_get_option_long>
    22d8:	e0fffd17 	ldw	r3,-12(fp)
    22dc:	18801315 	stw	r2,76(r3)
    22e0:	00000406 	br	22f4 <dhcp_handle_ack+0xfc>
  } else {
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
    22e4:	e0bffd17 	ldw	r2,-12(fp)
    22e8:	10c01117 	ldw	r3,68(r2)
    22ec:	e0bffd17 	ldw	r2,-12(fp)
    22f0:	10c01315 	stw	r3,76(r2)
  }

  /* (y)our internet address */
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
    22f4:	e0bffd17 	ldw	r2,-12(fp)
    22f8:	10800217 	ldw	r2,8(r2)
    22fc:	10800404 	addi	r2,r2,16
    2300:	10000726 	beq	r2,zero,2320 <dhcp_handle_ack+0x128>
    2304:	e0bffd17 	ldw	r2,-12(fp)
    2308:	10800217 	ldw	r2,8(r2)
    230c:	10c0040b 	ldhu	r3,16(r2)
    2310:	1080048b 	ldhu	r2,18(r2)
    2314:	1004943a 	slli	r2,r2,16
    2318:	10c4b03a 	or	r2,r2,r3
    231c:	00000106 	br	2324 <dhcp_handle_ack+0x12c>
    2320:	0005883a 	mov	r2,zero
    2324:	e0fffd17 	ldw	r3,-12(fp)
    2328:	18800a15 	stw	r2,40(r3)
    strcpy(dhcp->boot_file_name, dhcp->msg_in->file);
  }
#endif

  /* subnet mask */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SUBNET_MASK);
    232c:	e13ffd17 	ldw	r4,-12(fp)
    2330:	01400044 	movi	r5,1
    2334:	0004a900 	call	4a90 <dhcp_get_option_ptr>
    2338:	e0bffe15 	stw	r2,-8(fp)
  /* subnet mask given? */
  if (option_ptr != NULL) {
    233c:	e0bffe17 	ldw	r2,-8(fp)
    2340:	10001b26 	beq	r2,zero,23b0 <dhcp_handle_ack+0x1b8>
    dhcp->offered_sn_mask.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
    2344:	e0bffe17 	ldw	r2,-8(fp)
    2348:	10800084 	addi	r2,r2,2
    234c:	1009883a 	mov	r4,r2
    2350:	0004cec0 	call	4cec <dhcp_get_option_long>
    2354:	1020d63a 	srli	r16,r2,24
    2358:	e0bffe17 	ldw	r2,-8(fp)
    235c:	10800084 	addi	r2,r2,2
    2360:	1009883a 	mov	r4,r2
    2364:	0004cec0 	call	4cec <dhcp_get_option_long>
    2368:	1004d23a 	srli	r2,r2,8
    236c:	10bfc00c 	andi	r2,r2,65280
    2370:	80a0b03a 	or	r16,r16,r2
    2374:	e0bffe17 	ldw	r2,-8(fp)
    2378:	10800084 	addi	r2,r2,2
    237c:	1009883a 	mov	r4,r2
    2380:	0004cec0 	call	4cec <dhcp_get_option_long>
    2384:	10bfc00c 	andi	r2,r2,65280
    2388:	1004923a 	slli	r2,r2,8
    238c:	80a0b03a 	or	r16,r16,r2
    2390:	e0bffe17 	ldw	r2,-8(fp)
    2394:	10800084 	addi	r2,r2,2
    2398:	1009883a 	mov	r4,r2
    239c:	0004cec0 	call	4cec <dhcp_get_option_long>
    23a0:	1004963a 	slli	r2,r2,24
    23a4:	8086b03a 	or	r3,r16,r2
    23a8:	e0bffd17 	ldw	r2,-12(fp)
    23ac:	10c00b15 	stw	r3,44(r2)
  }

  /* gateway router */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_ROUTER);
    23b0:	e13ffd17 	ldw	r4,-12(fp)
    23b4:	014000c4 	movi	r5,3
    23b8:	0004a900 	call	4a90 <dhcp_get_option_ptr>
    23bc:	e0bffe15 	stw	r2,-8(fp)
  if (option_ptr != NULL) {
    23c0:	e0bffe17 	ldw	r2,-8(fp)
    23c4:	10001b26 	beq	r2,zero,2434 <dhcp_handle_ack+0x23c>
    dhcp->offered_gw_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
    23c8:	e0bffe17 	ldw	r2,-8(fp)
    23cc:	10800084 	addi	r2,r2,2
    23d0:	1009883a 	mov	r4,r2
    23d4:	0004cec0 	call	4cec <dhcp_get_option_long>
    23d8:	1020d63a 	srli	r16,r2,24
    23dc:	e0bffe17 	ldw	r2,-8(fp)
    23e0:	10800084 	addi	r2,r2,2
    23e4:	1009883a 	mov	r4,r2
    23e8:	0004cec0 	call	4cec <dhcp_get_option_long>
    23ec:	1004d23a 	srli	r2,r2,8
    23f0:	10bfc00c 	andi	r2,r2,65280
    23f4:	80a0b03a 	or	r16,r16,r2
    23f8:	e0bffe17 	ldw	r2,-8(fp)
    23fc:	10800084 	addi	r2,r2,2
    2400:	1009883a 	mov	r4,r2
    2404:	0004cec0 	call	4cec <dhcp_get_option_long>
    2408:	10bfc00c 	andi	r2,r2,65280
    240c:	1004923a 	slli	r2,r2,8
    2410:	80a0b03a 	or	r16,r16,r2
    2414:	e0bffe17 	ldw	r2,-8(fp)
    2418:	10800084 	addi	r2,r2,2
    241c:	1009883a 	mov	r4,r2
    2420:	0004cec0 	call	4cec <dhcp_get_option_long>
    2424:	1004963a 	slli	r2,r2,24
    2428:	8086b03a 	or	r3,r16,r2
    242c:	e0bffd17 	ldw	r2,-12(fp)
    2430:	10c00c15 	stw	r3,48(r2)
  }

  /* broadcast address */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_BROADCAST);
    2434:	e13ffd17 	ldw	r4,-12(fp)
    2438:	01400704 	movi	r5,28
    243c:	0004a900 	call	4a90 <dhcp_get_option_ptr>
    2440:	e0bffe15 	stw	r2,-8(fp)
  if (option_ptr != NULL) {
    2444:	e0bffe17 	ldw	r2,-8(fp)
    2448:	10001b26 	beq	r2,zero,24b8 <dhcp_handle_ack+0x2c0>
    dhcp->offered_bc_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
    244c:	e0bffe17 	ldw	r2,-8(fp)
    2450:	10800084 	addi	r2,r2,2
    2454:	1009883a 	mov	r4,r2
    2458:	0004cec0 	call	4cec <dhcp_get_option_long>
    245c:	1020d63a 	srli	r16,r2,24
    2460:	e0bffe17 	ldw	r2,-8(fp)
    2464:	10800084 	addi	r2,r2,2
    2468:	1009883a 	mov	r4,r2
    246c:	0004cec0 	call	4cec <dhcp_get_option_long>
    2470:	1004d23a 	srli	r2,r2,8
    2474:	10bfc00c 	andi	r2,r2,65280
    2478:	80a0b03a 	or	r16,r16,r2
    247c:	e0bffe17 	ldw	r2,-8(fp)
    2480:	10800084 	addi	r2,r2,2
    2484:	1009883a 	mov	r4,r2
    2488:	0004cec0 	call	4cec <dhcp_get_option_long>
    248c:	10bfc00c 	andi	r2,r2,65280
    2490:	1004923a 	slli	r2,r2,8
    2494:	80a0b03a 	or	r16,r16,r2
    2498:	e0bffe17 	ldw	r2,-8(fp)
    249c:	10800084 	addi	r2,r2,2
    24a0:	1009883a 	mov	r4,r2
    24a4:	0004cec0 	call	4cec <dhcp_get_option_long>
    24a8:	1004963a 	slli	r2,r2,24
    24ac:	8086b03a 	or	r3,r16,r2
    24b0:	e0bffd17 	ldw	r2,-12(fp)
    24b4:	10c00d15 	stw	r3,52(r2)
  }
  
  /* DNS servers */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_DNS_SERVER);
    24b8:	e13ffd17 	ldw	r4,-12(fp)
    24bc:	01400184 	movi	r5,6
    24c0:	0004a900 	call	4a90 <dhcp_get_option_ptr>
    24c4:	e0bffe15 	stw	r2,-8(fp)
  if (option_ptr != NULL) {
    24c8:	e0bffe17 	ldw	r2,-8(fp)
    24cc:	10004926 	beq	r2,zero,25f4 <dhcp_handle_ack+0x3fc>
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
    24d0:	e0bffe17 	ldw	r2,-8(fp)
    24d4:	10800044 	addi	r2,r2,1
    24d8:	1009883a 	mov	r4,r2
    24dc:	0004cc40 	call	4cc4 <dhcp_get_option_byte>
    24e0:	10803fcc 	andi	r2,r2,255
    24e4:	1004d0ba 	srli	r2,r2,2
    24e8:	10c03fcc 	andi	r3,r2,255
    24ec:	e0bffd17 	ldw	r2,-12(fp)
    24f0:	10c00e15 	stw	r3,56(r2)
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
    24f4:	e0bffd17 	ldw	r2,-12(fp)
    24f8:	10800e17 	ldw	r2,56(r2)
    24fc:	108000f0 	cmpltui	r2,r2,3
    2500:	1000031e 	bne	r2,zero,2510 <dhcp_handle_ack+0x318>
      dhcp->dns_count = DHCP_MAX_DNS;
    2504:	e0bffd17 	ldw	r2,-12(fp)
    2508:	00c00084 	movi	r3,2
    250c:	10c00e15 	stw	r3,56(r2)
    for (n = 0; n < dhcp->dns_count; n++) {
    2510:	e03ffc05 	stb	zero,-16(fp)
    2514:	00003306 	br	25e4 <dhcp_handle_ack+0x3ec>
      dhcp->offered_dns_addr[n].addr = htonl(dhcp_get_option_long(&option_ptr[2 + n * 4]));
    2518:	e43ffc03 	ldbu	r16,-16(fp)
    251c:	e0bffc03 	ldbu	r2,-16(fp)
    2520:	1085883a 	add	r2,r2,r2
    2524:	1085883a 	add	r2,r2,r2
    2528:	10800084 	addi	r2,r2,2
    252c:	e0fffe17 	ldw	r3,-8(fp)
    2530:	1885883a 	add	r2,r3,r2
    2534:	1009883a 	mov	r4,r2
    2538:	0004cec0 	call	4cec <dhcp_get_option_long>
    253c:	1022d63a 	srli	r17,r2,24
    2540:	e0bffc03 	ldbu	r2,-16(fp)
    2544:	1085883a 	add	r2,r2,r2
    2548:	1085883a 	add	r2,r2,r2
    254c:	10800084 	addi	r2,r2,2
    2550:	e0fffe17 	ldw	r3,-8(fp)
    2554:	1885883a 	add	r2,r3,r2
    2558:	1009883a 	mov	r4,r2
    255c:	0004cec0 	call	4cec <dhcp_get_option_long>
    2560:	1004d23a 	srli	r2,r2,8
    2564:	10bfc00c 	andi	r2,r2,65280
    2568:	88a2b03a 	or	r17,r17,r2
    256c:	e0bffc03 	ldbu	r2,-16(fp)
    2570:	1085883a 	add	r2,r2,r2
    2574:	1085883a 	add	r2,r2,r2
    2578:	10800084 	addi	r2,r2,2
    257c:	e0fffe17 	ldw	r3,-8(fp)
    2580:	1885883a 	add	r2,r3,r2
    2584:	1009883a 	mov	r4,r2
    2588:	0004cec0 	call	4cec <dhcp_get_option_long>
    258c:	10bfc00c 	andi	r2,r2,65280
    2590:	1004923a 	slli	r2,r2,8
    2594:	88a2b03a 	or	r17,r17,r2
    2598:	e0bffc03 	ldbu	r2,-16(fp)
    259c:	1085883a 	add	r2,r2,r2
    25a0:	1085883a 	add	r2,r2,r2
    25a4:	10800084 	addi	r2,r2,2
    25a8:	e0fffe17 	ldw	r3,-8(fp)
    25ac:	1885883a 	add	r2,r3,r2
    25b0:	1009883a 	mov	r4,r2
    25b4:	0004cec0 	call	4cec <dhcp_get_option_long>
    25b8:	1004963a 	slli	r2,r2,24
    25bc:	8886b03a 	or	r3,r17,r2
    25c0:	e13ffd17 	ldw	r4,-12(fp)
    25c4:	808003c4 	addi	r2,r16,15
    25c8:	1085883a 	add	r2,r2,r2
    25cc:	1085883a 	add	r2,r2,r2
    25d0:	2085883a 	add	r2,r4,r2
    25d4:	10c00015 	stw	r3,0(r2)
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
    for (n = 0; n < dhcp->dns_count; n++) {
    25d8:	e0bffc03 	ldbu	r2,-16(fp)
    25dc:	10800044 	addi	r2,r2,1
    25e0:	e0bffc05 	stb	r2,-16(fp)
    25e4:	e0fffc03 	ldbu	r3,-16(fp)
    25e8:	e0bffd17 	ldw	r2,-12(fp)
    25ec:	10800e17 	ldw	r2,56(r2)
    25f0:	18bfc936 	bltu	r3,r2,2518 <dhcp_handle_ack+0x320>
    }
#if LWIP_DNS
    dns_setserver( n, (struct ip_addr *)(&ip_addr_any));
#endif /* LWIP_DNS */
  }
}
    25f4:	e037883a 	mov	sp,fp
    25f8:	dfc00317 	ldw	ra,12(sp)
    25fc:	df000217 	ldw	fp,8(sp)
    2600:	dc400117 	ldw	r17,4(sp)
    2604:	dc000017 	ldw	r16,0(sp)
    2608:	dec00404 	addi	sp,sp,16
    260c:	f800283a 	ret

00002610 <dhcp_start>:
 * - ERR_OK - No error
 * - ERR_MEM - Out of memory
 */
err_t
dhcp_start(struct netif *netif)
{
    2610:	defffb04 	addi	sp,sp,-20
    2614:	dfc00415 	stw	ra,16(sp)
    2618:	df000315 	stw	fp,12(sp)
    261c:	df000304 	addi	fp,sp,12
    2620:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp;
  err_t result = ERR_OK;
    2624:	e03ffe05 	stb	zero,-8(fp)

  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
    2628:	e0bfff17 	ldw	r2,-4(fp)
    262c:	1000091e 	bne	r2,zero,2654 <dhcp_start+0x44>
    2630:	010000f4 	movhi	r4,3
    2634:	2137d904 	addi	r4,r4,-8348
    2638:	014000f4 	movhi	r5,3
    263c:	2977e304 	addi	r5,r5,-8308
    2640:	01809304 	movi	r6,588
    2644:	01c000f4 	movhi	r7,3
    2648:	39f7e704 	addi	r7,r7,-8292
    264c:	00170680 	call	17068 <printf>
    2650:	003fff06 	br	2650 <dhcp_start+0x40>
  dhcp = netif->dhcp;
    2654:	e0bfff17 	ldw	r2,-4(fp)
    2658:	10800817 	ldw	r2,32(r2)
    265c:	e0bffd15 	stw	r2,-12(fp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Remove the flag that says this netif is handled by DHCP,
     it is set when we succeeded starting. */
  netif->flags &= ~NETIF_FLAG_DHCP;
    2660:	e0bfff17 	ldw	r2,-4(fp)
    2664:	10c00b43 	ldbu	r3,45(r2)
    2668:	00bffdc4 	movi	r2,-9
    266c:	1884703a 	and	r2,r3,r2
    2670:	1007883a 	mov	r3,r2
    2674:	e0bfff17 	ldw	r2,-4(fp)
    2678:	10c00b45 	stb	r3,45(r2)

  /* check MTU of the netif */
  if (netif->mtu < DHCP_MAX_MSG_LEN_MIN_REQUIRED) {
    267c:	e0bfff17 	ldw	r2,-4(fp)
    2680:	1080090b 	ldhu	r2,36(r2)
    2684:	10bfffcc 	andi	r2,r2,65535
    2688:	10809028 	cmpgeui	r2,r2,576
    268c:	1000021e 	bne	r2,zero,2698 <dhcp_start+0x88>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): Cannot use this netif with DHCP: MTU is too small\n"));
    return ERR_MEM;
    2690:	00bfffc4 	movi	r2,-1
    2694:	00006a06 	br	2840 <dhcp_start+0x230>
  }

  /* no DHCP client attached yet? */
  if (dhcp == NULL) {
    2698:	e0bffd17 	ldw	r2,-12(fp)
    269c:	10000b1e 	bne	r2,zero,26cc <dhcp_start+0xbc>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = mem_malloc(sizeof(struct dhcp));
    26a0:	01001404 	movi	r4,80
    26a4:	00088ec0 	call	88ec <mem_malloc>
    26a8:	e0bffd15 	stw	r2,-12(fp)
    if (dhcp == NULL) {
    26ac:	e0bffd17 	ldw	r2,-12(fp)
    26b0:	1000021e 	bne	r2,zero,26bc <dhcp_start+0xac>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
    26b4:	00bfffc4 	movi	r2,-1
    26b8:	00006106 	br	2840 <dhcp_start+0x230>
    }
    /* store this dhcp client in the netif */
    netif->dhcp = dhcp;
    26bc:	e0bfff17 	ldw	r2,-4(fp)
    26c0:	e0fffd17 	ldw	r3,-12(fp)
    26c4:	10c00815 	stw	r3,32(r2)
    26c8:	00002606 	br	2764 <dhcp_start+0x154>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): allocated dhcp"));
  /* already has DHCP client attached */
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(): restarting DHCP configuration\n"));
    if (dhcp->pcb != NULL) {
    26cc:	e0bffd17 	ldw	r2,-12(fp)
    26d0:	10800117 	ldw	r2,4(r2)
    26d4:	10000426 	beq	r2,zero,26e8 <dhcp_start+0xd8>
      udp_remove(dhcp->pcb);
    26d8:	e0bffd17 	ldw	r2,-12(fp)
    26dc:	10800117 	ldw	r2,4(r2)
    26e0:	1009883a 	mov	r4,r2
    26e4:	0014f400 	call	14f40 <udp_remove>
    }
    LWIP_ASSERT("pbuf p_out wasn't freed", dhcp->p_out == NULL);
    26e8:	e0bffd17 	ldw	r2,-12(fp)
    26ec:	10800517 	ldw	r2,20(r2)
    26f0:	10000926 	beq	r2,zero,2718 <dhcp_start+0x108>
    26f4:	010000f4 	movhi	r4,3
    26f8:	2137d904 	addi	r4,r4,-8348
    26fc:	014000f4 	movhi	r5,3
    2700:	2977ed04 	addi	r5,r5,-8268
    2704:	01809a84 	movi	r6,618
    2708:	01c000f4 	movhi	r7,3
    270c:	39f7e704 	addi	r7,r7,-8292
    2710:	00170680 	call	17068 <printf>
    2714:	003fff06 	br	2714 <dhcp_start+0x104>
    LWIP_ASSERT("reply wasn't freed", dhcp->msg_in == NULL &&
    2718:	e0bffd17 	ldw	r2,-12(fp)
    271c:	10800217 	ldw	r2,8(r2)
    2720:	1000071e 	bne	r2,zero,2740 <dhcp_start+0x130>
    2724:	e0bffd17 	ldw	r2,-12(fp)
    2728:	10800317 	ldw	r2,12(r2)
    272c:	1000041e 	bne	r2,zero,2740 <dhcp_start+0x130>
    2730:	e0bffd17 	ldw	r2,-12(fp)
    2734:	1080040b 	ldhu	r2,16(r2)
    2738:	10bfffcc 	andi	r2,r2,65535
    273c:	10000926 	beq	r2,zero,2764 <dhcp_start+0x154>
    2740:	010000f4 	movhi	r4,3
    2744:	2137d904 	addi	r4,r4,-8348
    2748:	014000f4 	movhi	r5,3
    274c:	2977f304 	addi	r5,r5,-8244
    2750:	01809b04 	movi	r6,620
    2754:	01c000f4 	movhi	r7,3
    2758:	39f7e704 	addi	r7,r7,-8292
    275c:	00170680 	call	17068 <printf>
    2760:	003fff06 	br	2760 <dhcp_start+0x150>
      dhcp->options_in == NULL && dhcp->options_in_len == 0);
  }
    
  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
    2764:	e13ffd17 	ldw	r4,-12(fp)
    2768:	000b883a 	mov	r5,zero
    276c:	01801404 	movi	r6,80
    2770:	0016f600 	call	16f60 <memset>
  /* allocate UDP PCB */
  dhcp->pcb = udp_new();
    2774:	0014fdc0 	call	14fdc <udp_new>
    2778:	e0fffd17 	ldw	r3,-12(fp)
    277c:	18800115 	stw	r2,4(r3)
  if (dhcp->pcb == NULL) {
    2780:	e0bffd17 	ldw	r2,-12(fp)
    2784:	10800117 	ldw	r2,4(r2)
    2788:	1000081e 	bne	r2,zero,27ac <dhcp_start+0x19c>
    LWIP_DEBUGF(DHCP_DEBUG  | LWIP_DBG_TRACE, ("dhcp_start(): could not obtain pcb\n"));
    mem_free((void *)dhcp);
    278c:	e13ffd17 	ldw	r4,-12(fp)
    2790:	00084480 	call	8448 <mem_free>
    netif->dhcp = dhcp = NULL;
    2794:	e03ffd15 	stw	zero,-12(fp)
    2798:	e0bfff17 	ldw	r2,-4(fp)
    279c:	e0fffd17 	ldw	r3,-12(fp)
    27a0:	10c00815 	stw	r3,32(r2)
    return ERR_MEM;
    27a4:	00bfffc4 	movi	r2,-1
    27a8:	00002506 	br	2840 <dhcp_start+0x230>
  }
#if IP_SOF_BROADCAST
  dhcp->pcb->so_options|=SOF_BROADCAST;
#endif /* IP_SOF_BROADCAST */
  /* set up local and remote port for the pcb */
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
    27ac:	e0bffd17 	ldw	r2,-12(fp)
    27b0:	10800117 	ldw	r2,4(r2)
    27b4:	1009883a 	mov	r4,r2
    27b8:	014000f4 	movhi	r5,3
    27bc:	2950ed04 	addi	r5,r5,17332
    27c0:	01801104 	movi	r6,68
    27c4:	0014c1c0 	call	14c1c <udp_bind>
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
    27c8:	e0bffd17 	ldw	r2,-12(fp)
    27cc:	10800117 	ldw	r2,4(r2)
    27d0:	1009883a 	mov	r4,r2
    27d4:	014000f4 	movhi	r5,3
    27d8:	2950ed04 	addi	r5,r5,17332
    27dc:	018010c4 	movi	r6,67
    27e0:	0014d840 	call	14d84 <udp_connect>
  /* set up the recv callback and argument */
  udp_recv(dhcp->pcb, dhcp_recv, netif);
    27e4:	e0bffd17 	ldw	r2,-12(fp)
    27e8:	10800117 	ldw	r2,4(r2)
    27ec:	1009883a 	mov	r4,r2
    27f0:	01400034 	movhi	r5,0
    27f4:	294ffd04 	addi	r5,r5,16372
    27f8:	e1bfff17 	ldw	r6,-4(fp)
    27fc:	0014f000 	call	14f00 <udp_recv>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));
  /* (re)start the DHCP negotiation */
  result = dhcp_discover(netif);
    2800:	e13fff17 	ldw	r4,-4(fp)
    2804:	0002cc00 	call	2cc0 <dhcp_discover>
    2808:	e0bffe05 	stb	r2,-8(fp)
  if (result != ERR_OK) {
    280c:	e0bffe07 	ldb	r2,-8(fp)
    2810:	10000426 	beq	r2,zero,2824 <dhcp_start+0x214>
    /* free resources allocated above */
    dhcp_stop(netif);
    2814:	e13fff17 	ldw	r4,-4(fp)
    2818:	00038ac0 	call	38ac <dhcp_stop>
    return ERR_MEM;
    281c:	00bfffc4 	movi	r2,-1
    2820:	00000706 	br	2840 <dhcp_start+0x230>
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
    2824:	e0bfff17 	ldw	r2,-4(fp)
    2828:	10800b43 	ldbu	r2,45(r2)
    282c:	10800214 	ori	r2,r2,8
    2830:	1007883a 	mov	r3,r2
    2834:	e0bfff17 	ldw	r2,-4(fp)
    2838:	10c00b45 	stb	r3,45(r2)
  return result;
    283c:	e0bffe03 	ldbu	r2,-8(fp)
}
    2840:	e037883a 	mov	sp,fp
    2844:	dfc00117 	ldw	ra,4(sp)
    2848:	df000017 	ldw	fp,0(sp)
    284c:	dec00204 	addi	sp,sp,8
    2850:	f800283a 	ret

00002854 <dhcp_inform>:
 *
 * @param netif The lwIP network interface
 */
void
dhcp_inform(struct netif *netif)
{
    2854:	defff904 	addi	sp,sp,-28
    2858:	dfc00615 	stw	ra,24(sp)
    285c:	df000515 	stw	fp,20(sp)
    2860:	df000504 	addi	fp,sp,20
    2864:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp, *old_dhcp;
  err_t result = ERR_OK;
    2868:	e03ffc05 	stb	zero,-16(fp)
  dhcp = mem_malloc(sizeof(struct dhcp));
    286c:	01001404 	movi	r4,80
    2870:	00088ec0 	call	88ec <mem_malloc>
    2874:	e0bffd15 	stw	r2,-12(fp)
  if (dhcp == NULL) {
    2878:	e0bffd17 	ldw	r2,-12(fp)
    287c:	10005426 	beq	r2,zero,29d0 <dhcp_inform+0x17c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_inform(): could not allocate dhcp\n"));
    return;
  }
  memset(dhcp, 0, sizeof(struct dhcp));
    2880:	e13ffd17 	ldw	r4,-12(fp)
    2884:	000b883a 	mov	r5,zero
    2888:	01801404 	movi	r6,80
    288c:	0016f600 	call	16f60 <memset>

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): allocated dhcp\n"));
  dhcp->pcb = udp_new();
    2890:	0014fdc0 	call	14fdc <udp_new>
    2894:	e0fffd17 	ldw	r3,-12(fp)
    2898:	18800115 	stw	r2,4(r3)
  if (dhcp->pcb == NULL) {
    289c:	e0bffd17 	ldw	r2,-12(fp)
    28a0:	10800117 	ldw	r2,4(r2)
    28a4:	10004626 	beq	r2,zero,29c0 <dhcp_inform+0x16c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_inform(): could not obtain pcb"));
    goto free_dhcp_and_return;
  }
  old_dhcp = netif->dhcp;
    28a8:	e0bfff17 	ldw	r2,-4(fp)
    28ac:	10800817 	ldw	r2,32(r2)
    28b0:	e0bffe15 	stw	r2,-8(fp)
  netif->dhcp = dhcp;
    28b4:	e0bfff17 	ldw	r2,-4(fp)
    28b8:	e0fffd17 	ldw	r3,-12(fp)
    28bc:	10c00815 	stw	r3,32(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): created new udp pcb\n"));
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
    28c0:	e13fff17 	ldw	r4,-4(fp)
    28c4:	00043540 	call	4354 <dhcp_create_request>
    28c8:	e0bffc05 	stb	r2,-16(fp)
  if (result == ERR_OK) {
    28cc:	e0bffc07 	ldb	r2,-16(fp)
    28d0:	1000311e 	bne	r2,zero,2998 <dhcp_inform+0x144>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
    28d4:	e13ffd17 	ldw	r4,-12(fp)
    28d8:	01400d44 	movi	r5,53
    28dc:	01800044 	movi	r6,1
    28e0:	0003a000 	call	3a00 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_INFORM);
    28e4:	e13ffd17 	ldw	r4,-12(fp)
    28e8:	01400204 	movi	r5,8
    28ec:	0003ae40 	call	3ae4 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    28f0:	e13ffd17 	ldw	r4,-12(fp)
    28f4:	01400e44 	movi	r5,57
    28f8:	01800084 	movi	r6,2
    28fc:	0003a000 	call	3a00 <dhcp_option>
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
    2900:	e0bfff17 	ldw	r2,-4(fp)
    2904:	1080090b 	ldhu	r2,36(r2)
    2908:	10bfffcc 	andi	r2,r2,65535
    290c:	e13ffd17 	ldw	r4,-12(fp)
    2910:	100b883a 	mov	r5,r2
    2914:	0003b800 	call	3b80 <dhcp_option_short>

    dhcp_option_trailer(dhcp);
    2918:	e13ffd17 	ldw	r4,-12(fp)
    291c:	000490c0 	call	490c <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    2920:	e0bffd17 	ldw	r2,-12(fp)
    2924:	10c00517 	ldw	r3,20(r2)
    2928:	e0bffd17 	ldw	r2,-12(fp)
    292c:	1080070b 	ldhu	r2,28(r2)
    2930:	10803c04 	addi	r2,r2,240
    2934:	10bfffcc 	andi	r2,r2,65535
    2938:	1809883a 	mov	r4,r3
    293c:	100b883a 	mov	r5,r2
    2940:	0009d0c0 	call	9d0c <pbuf_realloc>

#if IP_SOF_BROADCAST
    dhcp->pcb->so_options|=SOF_BROADCAST;
#endif /* IP_SOF_BROADCAST */
    udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
    2944:	e0bffd17 	ldw	r2,-12(fp)
    2948:	10800117 	ldw	r2,4(r2)
    294c:	1009883a 	mov	r4,r2
    2950:	014000f4 	movhi	r5,3
    2954:	2950ed04 	addi	r5,r5,17332
    2958:	01801104 	movi	r6,68
    295c:	0014c1c0 	call	14c1c <udp_bind>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_inform: INFORMING\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    2960:	e0bffd17 	ldw	r2,-12(fp)
    2964:	10c00117 	ldw	r3,4(r2)
    2968:	e0bffd17 	ldw	r2,-12(fp)
    296c:	10800517 	ldw	r2,20(r2)
    2970:	e13fff17 	ldw	r4,-4(fp)
    2974:	d9000015 	stw	r4,0(sp)
    2978:	1809883a 	mov	r4,r3
    297c:	100b883a 	mov	r5,r2
    2980:	018000f4 	movhi	r6,3
    2984:	3190ee04 	addi	r6,r6,17336
    2988:	01c010c4 	movi	r7,67
    298c:	001493c0 	call	1493c <udp_sendto_if>
    dhcp_delete_request(netif);
    2990:	e13fff17 	ldw	r4,-4(fp)
    2994:	00047f40 	call	47f4 <dhcp_delete_request>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  udp_remove(dhcp->pcb);
    2998:	e0bffd17 	ldw	r2,-12(fp)
    299c:	10800117 	ldw	r2,4(r2)
    29a0:	1009883a 	mov	r4,r2
    29a4:	0014f400 	call	14f40 <udp_remove>
  dhcp->pcb = NULL;
    29a8:	e0bffd17 	ldw	r2,-12(fp)
    29ac:	10000115 	stw	zero,4(r2)
  netif->dhcp = old_dhcp;
    29b0:	e0bfff17 	ldw	r2,-4(fp)
    29b4:	e0fffe17 	ldw	r3,-8(fp)
    29b8:	10c00815 	stw	r3,32(r2)
    29bc:	00000106 	br	29c4 <dhcp_inform+0x170>

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): allocated dhcp\n"));
  dhcp->pcb = udp_new();
  if (dhcp->pcb == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_inform(): could not obtain pcb"));
    goto free_dhcp_and_return;
    29c0:	0001883a 	nop

  udp_remove(dhcp->pcb);
  dhcp->pcb = NULL;
  netif->dhcp = old_dhcp;
free_dhcp_and_return:
  mem_free((void *)dhcp);
    29c4:	e13ffd17 	ldw	r4,-12(fp)
    29c8:	00084480 	call	8448 <mem_free>
    29cc:	00000106 	br	29d4 <dhcp_inform+0x180>
  struct dhcp *dhcp, *old_dhcp;
  err_t result = ERR_OK;
  dhcp = mem_malloc(sizeof(struct dhcp));
  if (dhcp == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_inform(): could not allocate dhcp\n"));
    return;
    29d0:	0001883a 	nop
  udp_remove(dhcp->pcb);
  dhcp->pcb = NULL;
  netif->dhcp = old_dhcp;
free_dhcp_and_return:
  mem_free((void *)dhcp);
}
    29d4:	e037883a 	mov	sp,fp
    29d8:	dfc00117 	ldw	ra,4(sp)
    29dc:	df000017 	ldw	fp,0(sp)
    29e0:	dec00204 	addi	sp,sp,8
    29e4:	f800283a 	ret

000029e8 <dhcp_network_changed>:
 * This enters the REBOOTING state to verify that the currently bound
 * address is still valid.
 */
void
dhcp_network_changed(struct netif *netif)
{
    29e8:	defffc04 	addi	sp,sp,-16
    29ec:	dfc00315 	stw	ra,12(sp)
    29f0:	df000215 	stw	fp,8(sp)
    29f4:	df000204 	addi	fp,sp,8
    29f8:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    29fc:	e0bfff17 	ldw	r2,-4(fp)
    2a00:	10800817 	ldw	r2,32(r2)
    2a04:	e0bffe15 	stw	r2,-8(fp)
  if (!dhcp)
    2a08:	e0bffe17 	ldw	r2,-8(fp)
    2a0c:	10001b26 	beq	r2,zero,2a7c <dhcp_network_changed+0x94>
    return;
  switch (dhcp->state) {
    2a10:	e0bffe17 	ldw	r2,-8(fp)
    2a14:	10800483 	ldbu	r2,18(r2)
    2a18:	10803fcc 	andi	r2,r2,255
    2a1c:	10c002a0 	cmpeqi	r3,r2,10
    2a20:	1800091e 	bne	r3,zero,2a48 <dhcp_network_changed+0x60>
    2a24:	10c002c8 	cmpgei	r3,r2,11
    2a28:	1800041e 	bne	r3,zero,2a3c <dhcp_network_changed+0x54>
    2a2c:	10bfff44 	addi	r2,r2,-3
    2a30:	108000e8 	cmpgeui	r2,r2,3
    2a34:	10000b1e 	bne	r2,zero,2a64 <dhcp_network_changed+0x7c>
    2a38:	00000306 	br	2a48 <dhcp_network_changed+0x60>
    2a3c:	10800360 	cmpeqi	r2,r2,13
    2a40:	1000101e 	bne	r2,zero,2a84 <dhcp_network_changed+0x9c>
    2a44:	00000706 	br	2a64 <dhcp_network_changed+0x7c>
  case DHCP_REBINDING:
  case DHCP_RENEWING:
  case DHCP_BOUND:
  case DHCP_REBOOTING:
    netif_set_down(netif);
    2a48:	e13fff17 	ldw	r4,-4(fp)
    2a4c:	00097480 	call	9748 <netif_set_down>
    dhcp->tries = 0;
    2a50:	e0bffe17 	ldw	r2,-8(fp)
    2a54:	100004c5 	stb	zero,19(r2)
    dhcp_reboot(netif);
    2a58:	e13fff17 	ldw	r4,-4(fp)
    2a5c:	00035180 	call	3518 <dhcp_reboot>
    break;
    2a60:	00000906 	br	2a88 <dhcp_network_changed+0xa0>
  case DHCP_OFF:
    /* stay off */
    break;
  default:
    dhcp->tries = 0;
    2a64:	e0bffe17 	ldw	r2,-8(fp)
    2a68:	100004c5 	stb	zero,19(r2)
    dhcp_discover(netif);
    2a6c:	e13fff17 	ldw	r4,-4(fp)
    2a70:	0002cc00 	call	2cc0 <dhcp_discover>
    break;
    2a74:	0001883a 	nop
    2a78:	00000306 	br	2a88 <dhcp_network_changed+0xa0>
void
dhcp_network_changed(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  if (!dhcp)
    return;
    2a7c:	0001883a 	nop
    2a80:	00000106 	br	2a88 <dhcp_network_changed+0xa0>
    dhcp->tries = 0;
    dhcp_reboot(netif);
    break;
  case DHCP_OFF:
    /* stay off */
    break;
    2a84:	0001883a 	nop
  default:
    dhcp->tries = 0;
    dhcp_discover(netif);
    break;
  }
}
    2a88:	e037883a 	mov	sp,fp
    2a8c:	dfc00117 	ldw	ra,4(sp)
    2a90:	df000017 	ldw	fp,0(sp)
    2a94:	dec00204 	addi	sp,sp,8
    2a98:	f800283a 	ret

00002a9c <dhcp_arp_reply>:
 *
 * @param netif the network interface on which the reply was received
 * @param addr The IP address we received a reply from
 */
void dhcp_arp_reply(struct netif *netif, struct ip_addr *addr)
{
    2a9c:	defffc04 	addi	sp,sp,-16
    2aa0:	dfc00315 	stw	ra,12(sp)
    2aa4:	df000215 	stw	fp,8(sp)
    2aa8:	df000204 	addi	fp,sp,8
    2aac:	e13ffe15 	stw	r4,-8(fp)
    2ab0:	e17fff15 	stw	r5,-4(fp)
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
    2ab4:	e0bffe17 	ldw	r2,-8(fp)
    2ab8:	1000091e 	bne	r2,zero,2ae0 <dhcp_arp_reply+0x44>
    2abc:	010000f4 	movhi	r4,3
    2ac0:	2137d904 	addi	r4,r4,-8348
    2ac4:	014000f4 	movhi	r5,3
    2ac8:	2977e304 	addi	r5,r5,-8308
    2acc:	0180bcc4 	movi	r6,755
    2ad0:	01c000f4 	movhi	r7,3
    2ad4:	39f7e704 	addi	r7,r7,-8292
    2ad8:	00170680 	call	17068 <printf>
    2adc:	003fff06 	br	2adc <dhcp_arp_reply+0x40>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_arp_reply()\n"));
  /* is a DHCP client doing an ARP check? */
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
    2ae0:	e0bffe17 	ldw	r2,-8(fp)
    2ae4:	10800817 	ldw	r2,32(r2)
    2ae8:	10001226 	beq	r2,zero,2b34 <dhcp_arp_reply+0x98>
    2aec:	e0bffe17 	ldw	r2,-8(fp)
    2af0:	10800817 	ldw	r2,32(r2)
    2af4:	10800483 	ldbu	r2,18(r2)
    2af8:	10803fcc 	andi	r2,r2,255
    2afc:	10800218 	cmpnei	r2,r2,8
    2b00:	10000c1e 	bne	r2,zero,2b34 <dhcp_arp_reply+0x98>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08"X32_F"\n", addr->addr));
    /* did a host respond with the address we
       were offered by the DHCP server? */
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
    2b04:	e0bfff17 	ldw	r2,-4(fp)
    2b08:	10c0000b 	ldhu	r3,0(r2)
    2b0c:	1080008b 	ldhu	r2,2(r2)
    2b10:	1004943a 	slli	r2,r2,16
    2b14:	10c4b03a 	or	r2,r2,r3
    2b18:	1007883a 	mov	r3,r2
    2b1c:	e0bffe17 	ldw	r2,-8(fp)
    2b20:	10800817 	ldw	r2,32(r2)
    2b24:	10800a17 	ldw	r2,40(r2)
    2b28:	1880021e 	bne	r3,r2,2b34 <dhcp_arp_reply+0x98>
      /* we will not accept the offered address */
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | LWIP_DBG_LEVEL_WARNING,
        ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));
      dhcp_decline(netif);
    2b2c:	e13ffe17 	ldw	r4,-8(fp)
    2b30:	0002b480 	call	2b48 <dhcp_decline>
    }
  }
}
    2b34:	e037883a 	mov	sp,fp
    2b38:	dfc00117 	ldw	ra,4(sp)
    2b3c:	df000017 	ldw	fp,0(sp)
    2b40:	dec00204 	addi	sp,sp,8
    2b44:	f800283a 	ret

00002b48 <dhcp_decline>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_decline(struct netif *netif)
{
    2b48:	defffa04 	addi	sp,sp,-24
    2b4c:	dfc00515 	stw	ra,20(sp)
    2b50:	df000415 	stw	fp,16(sp)
    2b54:	df000404 	addi	fp,sp,16
    2b58:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    2b5c:	e0bfff17 	ldw	r2,-4(fp)
    2b60:	10800817 	ldw	r2,32(r2)
    2b64:	e0bffd15 	stw	r2,-12(fp)
  err_t result = ERR_OK;
    2b68:	e03ffe05 	stb	zero,-8(fp)
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline()\n"));
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
    2b6c:	e13ffd17 	ldw	r4,-12(fp)
    2b70:	01400304 	movi	r5,12
    2b74:	00039b00 	call	39b0 <dhcp_set_state>
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
    2b78:	e13fff17 	ldw	r4,-4(fp)
    2b7c:	00043540 	call	4354 <dhcp_create_request>
    2b80:	e0bffe05 	stb	r2,-8(fp)
  if (result == ERR_OK) {
    2b84:	e0bffe07 	ldb	r2,-8(fp)
    2b88:	1000381e 	bne	r2,zero,2c6c <dhcp_decline+0x124>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
    2b8c:	e13ffd17 	ldw	r4,-12(fp)
    2b90:	01400d44 	movi	r5,53
    2b94:	01800044 	movi	r6,1
    2b98:	0003a000 	call	3a00 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DECLINE);
    2b9c:	e13ffd17 	ldw	r4,-12(fp)
    2ba0:	01400104 	movi	r5,4
    2ba4:	0003ae40 	call	3ae4 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
    2ba8:	e13ffd17 	ldw	r4,-12(fp)
    2bac:	01400c84 	movi	r5,50
    2bb0:	01800104 	movi	r6,4
    2bb4:	0003a000 	call	3a00 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
    2bb8:	e0bffd17 	ldw	r2,-12(fp)
    2bbc:	10800a17 	ldw	r2,40(r2)
    2bc0:	1006d63a 	srli	r3,r2,24
    2bc4:	e0bffd17 	ldw	r2,-12(fp)
    2bc8:	10800a17 	ldw	r2,40(r2)
    2bcc:	1004d23a 	srli	r2,r2,8
    2bd0:	10bfc00c 	andi	r2,r2,65280
    2bd4:	1886b03a 	or	r3,r3,r2
    2bd8:	e0bffd17 	ldw	r2,-12(fp)
    2bdc:	10800a17 	ldw	r2,40(r2)
    2be0:	10bfc00c 	andi	r2,r2,65280
    2be4:	1004923a 	slli	r2,r2,8
    2be8:	1886b03a 	or	r3,r3,r2
    2bec:	e0bffd17 	ldw	r2,-12(fp)
    2bf0:	10800a17 	ldw	r2,40(r2)
    2bf4:	1004963a 	slli	r2,r2,24
    2bf8:	1884b03a 	or	r2,r3,r2
    2bfc:	e13ffd17 	ldw	r4,-12(fp)
    2c00:	100b883a 	mov	r5,r2
    2c04:	0003c580 	call	3c58 <dhcp_option_long>

    dhcp_option_trailer(dhcp);
    2c08:	e13ffd17 	ldw	r4,-12(fp)
    2c0c:	000490c0 	call	490c <dhcp_option_trailer>
    /* resize pbuf to reflect true size of options */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    2c10:	e0bffd17 	ldw	r2,-12(fp)
    2c14:	10c00517 	ldw	r3,20(r2)
    2c18:	e0bffd17 	ldw	r2,-12(fp)
    2c1c:	1080070b 	ldhu	r2,28(r2)
    2c20:	10803c04 	addi	r2,r2,240
    2c24:	10bfffcc 	andi	r2,r2,65535
    2c28:	1809883a 	mov	r4,r3
    2c2c:	100b883a 	mov	r5,r2
    2c30:	0009d0c0 	call	9d0c <pbuf_realloc>

    /* per section 4.4.4, broadcast DECLINE messages */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    2c34:	e0bffd17 	ldw	r2,-12(fp)
    2c38:	10c00117 	ldw	r3,4(r2)
    2c3c:	e0bffd17 	ldw	r2,-12(fp)
    2c40:	10800517 	ldw	r2,20(r2)
    2c44:	e13fff17 	ldw	r4,-4(fp)
    2c48:	d9000015 	stw	r4,0(sp)
    2c4c:	1809883a 	mov	r4,r3
    2c50:	100b883a 	mov	r5,r2
    2c54:	018000f4 	movhi	r6,3
    2c58:	3190ee04 	addi	r6,r6,17336
    2c5c:	01c010c4 	movi	r7,67
    2c60:	001493c0 	call	1493c <udp_sendto_if>
    dhcp_delete_request(netif);
    2c64:	e13fff17 	ldw	r4,-4(fp)
    2c68:	00047f40 	call	47f4 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("dhcp_decline: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
    2c6c:	e0bffd17 	ldw	r2,-12(fp)
    2c70:	108004c3 	ldbu	r2,19(r2)
    2c74:	10800044 	addi	r2,r2,1
    2c78:	1007883a 	mov	r3,r2
    2c7c:	e0bffd17 	ldw	r2,-12(fp)
    2c80:	10c004c5 	stb	r3,19(r2)
  msecs = 10*1000;
    2c84:	0089c404 	movi	r2,10000
    2c88:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    2c8c:	e0bffe8b 	ldhu	r2,-6(fp)
    2c90:	10c07cc4 	addi	r3,r2,499
    2c94:	00807d04 	movi	r2,500
    2c98:	1885283a 	div	r2,r3,r2
    2c9c:	1007883a 	mov	r3,r2
    2ca0:	e0bffd17 	ldw	r2,-12(fp)
    2ca4:	10c0078d 	sth	r3,30(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
    2ca8:	e0bffe03 	ldbu	r2,-8(fp)
}
    2cac:	e037883a 	mov	sp,fp
    2cb0:	dfc00117 	ldw	ra,4(sp)
    2cb4:	df000017 	ldw	fp,0(sp)
    2cb8:	dec00204 	addi	sp,sp,8
    2cbc:	f800283a 	ret

00002cc0 <dhcp_discover>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
    2cc0:	defffa04 	addi	sp,sp,-24
    2cc4:	dfc00515 	stw	ra,20(sp)
    2cc8:	df000415 	stw	fp,16(sp)
    2ccc:	df000404 	addi	fp,sp,16
    2cd0:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    2cd4:	e0bfff17 	ldw	r2,-4(fp)
    2cd8:	10800817 	ldw	r2,32(r2)
    2cdc:	e0bffd15 	stw	r2,-12(fp)
  err_t result = ERR_OK;
    2ce0:	e03ffe05 	stb	zero,-8(fp)
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover()\n"));
  ip_addr_set(&dhcp->offered_ip_addr, IP_ADDR_ANY);
    2ce4:	008000f4 	movhi	r2,3
    2ce8:	1090ed04 	addi	r2,r2,17332
    2cec:	10c0000b 	ldhu	r3,0(r2)
    2cf0:	1080008b 	ldhu	r2,2(r2)
    2cf4:	1004943a 	slli	r2,r2,16
    2cf8:	10c4b03a 	or	r2,r2,r3
    2cfc:	1007883a 	mov	r3,r2
    2d00:	e0bffd17 	ldw	r2,-12(fp)
    2d04:	10c00a15 	stw	r3,40(r2)
  dhcp_set_state(dhcp, DHCP_SELECTING);
    2d08:	e13ffd17 	ldw	r4,-12(fp)
    2d0c:	01400184 	movi	r5,6
    2d10:	00039b00 	call	39b0 <dhcp_set_state>
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
    2d14:	e13fff17 	ldw	r4,-4(fp)
    2d18:	00043540 	call	4354 <dhcp_create_request>
    2d1c:	e0bffe05 	stb	r2,-8(fp)
  if (result == ERR_OK) {
    2d20:	e0bffe07 	ldb	r2,-8(fp)
    2d24:	10003a1e 	bne	r2,zero,2e10 <dhcp_discover+0x150>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
    2d28:	e13ffd17 	ldw	r4,-12(fp)
    2d2c:	01400d44 	movi	r5,53
    2d30:	01800044 	movi	r6,1
    2d34:	0003a000 	call	3a00 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DISCOVER);
    2d38:	e13ffd17 	ldw	r4,-12(fp)
    2d3c:	01400044 	movi	r5,1
    2d40:	0003ae40 	call	3ae4 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    2d44:	e13ffd17 	ldw	r4,-12(fp)
    2d48:	01400e44 	movi	r5,57
    2d4c:	01800084 	movi	r6,2
    2d50:	0003a000 	call	3a00 <dhcp_option>
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
    2d54:	e0bfff17 	ldw	r2,-4(fp)
    2d58:	1080090b 	ldhu	r2,36(r2)
    2d5c:	10bfffcc 	andi	r2,r2,65535
    2d60:	e13ffd17 	ldw	r4,-12(fp)
    2d64:	100b883a 	mov	r5,r2
    2d68:	0003b800 	call	3b80 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
    2d6c:	e13ffd17 	ldw	r4,-12(fp)
    2d70:	01400dc4 	movi	r5,55
    2d74:	01800104 	movi	r6,4
    2d78:	0003a000 	call	3a00 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
    2d7c:	e13ffd17 	ldw	r4,-12(fp)
    2d80:	01400044 	movi	r5,1
    2d84:	0003ae40 	call	3ae4 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
    2d88:	e13ffd17 	ldw	r4,-12(fp)
    2d8c:	014000c4 	movi	r5,3
    2d90:	0003ae40 	call	3ae4 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
    2d94:	e13ffd17 	ldw	r4,-12(fp)
    2d98:	01400704 	movi	r5,28
    2d9c:	0003ae40 	call	3ae4 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
    2da0:	e13ffd17 	ldw	r4,-12(fp)
    2da4:	01400184 	movi	r5,6
    2da8:	0003ae40 	call	3ae4 <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
    2dac:	e13ffd17 	ldw	r4,-12(fp)
    2db0:	000490c0 	call	490c <dhcp_option_trailer>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: realloc()ing\n"));
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    2db4:	e0bffd17 	ldw	r2,-12(fp)
    2db8:	10c00517 	ldw	r3,20(r2)
    2dbc:	e0bffd17 	ldw	r2,-12(fp)
    2dc0:	1080070b 	ldhu	r2,28(r2)
    2dc4:	10803c04 	addi	r2,r2,240
    2dc8:	10bfffcc 	andi	r2,r2,65535
    2dcc:	1809883a 	mov	r4,r3
    2dd0:	100b883a 	mov	r5,r2
    2dd4:	0009d0c0 	call	9d0c <pbuf_realloc>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, DHCP_SERVER_PORT)\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    2dd8:	e0bffd17 	ldw	r2,-12(fp)
    2ddc:	10c00117 	ldw	r3,4(r2)
    2de0:	e0bffd17 	ldw	r2,-12(fp)
    2de4:	10800517 	ldw	r2,20(r2)
    2de8:	e13fff17 	ldw	r4,-4(fp)
    2dec:	d9000015 	stw	r4,0(sp)
    2df0:	1809883a 	mov	r4,r3
    2df4:	100b883a 	mov	r5,r2
    2df8:	018000f4 	movhi	r6,3
    2dfc:	3190ee04 	addi	r6,r6,17336
    2e00:	01c010c4 	movi	r7,67
    2e04:	001493c0 	call	1493c <udp_sendto_if>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()ing\n"));
    dhcp_delete_request(netif);
    2e08:	e13fff17 	ldw	r4,-4(fp)
    2e0c:	00047f40 	call	47f4 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_discover: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
    2e10:	e0bffd17 	ldw	r2,-12(fp)
    2e14:	108004c3 	ldbu	r2,19(r2)
    2e18:	10800044 	addi	r2,r2,1
    2e1c:	1007883a 	mov	r3,r2
    2e20:	e0bffd17 	ldw	r2,-12(fp)
    2e24:	10c004c5 	stb	r3,19(r2)
  if(dhcp->tries >= LWIP_DHCP_AUTOIP_COOP_TRIES && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */
  msecs = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
    2e28:	e0bffd17 	ldw	r2,-12(fp)
    2e2c:	108004c3 	ldbu	r2,19(r2)
    2e30:	10803fcc 	andi	r2,r2,255
    2e34:	108001a8 	cmpgeui	r2,r2,6
    2e38:	1000061e 	bne	r2,zero,2e54 <dhcp_discover+0x194>
    2e3c:	e0bffd17 	ldw	r2,-12(fp)
    2e40:	108004c3 	ldbu	r2,19(r2)
    2e44:	10803fcc 	andi	r2,r2,255
    2e48:	00c0fa04 	movi	r3,1000
    2e4c:	1884983a 	sll	r2,r3,r2
    2e50:	00000106 	br	2e58 <dhcp_discover+0x198>
    2e54:	00ba9804 	movi	r2,-5536
    2e58:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    2e5c:	e0bffe8b 	ldhu	r2,-6(fp)
    2e60:	10c07cc4 	addi	r3,r2,499
    2e64:	00807d04 	movi	r2,500
    2e68:	1885283a 	div	r2,r3,r2
    2e6c:	1007883a 	mov	r3,r2
    2e70:	e0bffd17 	ldw	r2,-12(fp)
    2e74:	10c0078d 	sth	r3,30(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
    2e78:	e0bffe03 	ldbu	r2,-8(fp)
}
    2e7c:	e037883a 	mov	sp,fp
    2e80:	dfc00117 	ldw	ra,4(sp)
    2e84:	df000017 	ldw	fp,0(sp)
    2e88:	dec00204 	addi	sp,sp,8
    2e8c:	f800283a 	ret

00002e90 <dhcp_bind>:
 *
 * @param netif network interface to bind to the offered address
 */
static void
dhcp_bind(struct netif *netif)
{
    2e90:	defff804 	addi	sp,sp,-32
    2e94:	dfc00715 	stw	ra,28(sp)
    2e98:	df000615 	stw	fp,24(sp)
    2e9c:	df000604 	addi	fp,sp,24
    2ea0:	e13fff15 	stw	r4,-4(fp)
  u32_t timeout;
  struct dhcp *dhcp;
  struct ip_addr sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
    2ea4:	e0bfff17 	ldw	r2,-4(fp)
    2ea8:	1000091e 	bne	r2,zero,2ed0 <dhcp_bind+0x40>
    2eac:	010000f4 	movhi	r4,3
    2eb0:	2137d904 	addi	r4,r4,-8348
    2eb4:	014000f4 	movhi	r5,3
    2eb8:	2977f804 	addi	r5,r5,-8224
    2ebc:	0180dd84 	movi	r6,886
    2ec0:	01c000f4 	movhi	r7,3
    2ec4:	39f7e704 	addi	r7,r7,-8292
    2ec8:	00170680 	call	17068 <printf>
    2ecc:	003fff06 	br	2ecc <dhcp_bind+0x3c>
  dhcp = netif->dhcp;
    2ed0:	e0bfff17 	ldw	r2,-4(fp)
    2ed4:	10800817 	ldw	r2,32(r2)
    2ed8:	e0bffb15 	stw	r2,-20(fp)
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
    2edc:	e0bffb17 	ldw	r2,-20(fp)
    2ee0:	1000091e 	bne	r2,zero,2f08 <dhcp_bind+0x78>
    2ee4:	010000f4 	movhi	r4,3
    2ee8:	2137d904 	addi	r4,r4,-8348
    2eec:	014000f4 	movhi	r5,3
    2ef0:	2977ff04 	addi	r5,r5,-8196
    2ef4:	0180de04 	movi	r6,888
    2ef8:	01c000f4 	movhi	r7,3
    2efc:	39f7e704 	addi	r7,r7,-8292
    2f00:	00170680 	call	17068 <printf>
    2f04:	003fff06 	br	2f04 <dhcp_bind+0x74>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* temporary DHCP lease? */
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
    2f08:	e0bffb17 	ldw	r2,-20(fp)
    2f0c:	10801217 	ldw	r2,72(r2)
    2f10:	10bfffe0 	cmpeqi	r2,r2,-1
    2f14:	1000161e 	bne	r2,zero,2f70 <dhcp_bind+0xe0>
    /* set renewal period timer */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t1 renewal timer %"U32_F" secs\n", dhcp->offered_t1_renew));
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
    2f18:	e0bffb17 	ldw	r2,-20(fp)
    2f1c:	10801217 	ldw	r2,72(r2)
    2f20:	10c00784 	addi	r3,r2,30
    2f24:	00800f04 	movi	r2,60
    2f28:	1885203a 	divu	r2,r3,r2
    2f2c:	e0bffa15 	stw	r2,-24(fp)
    if(timeout > 0xffff) {
    2f30:	e0bffa17 	ldw	r2,-24(fp)
    2f34:	00ffffd4 	movui	r3,65535
    2f38:	1880022e 	bgeu	r3,r2,2f44 <dhcp_bind+0xb4>
      timeout = 0xffff;
    2f3c:	00bfffd4 	movui	r2,65535
    2f40:	e0bffa15 	stw	r2,-24(fp)
    }
    dhcp->t1_timeout = (u16_t)timeout;
    2f44:	e0bffa17 	ldw	r2,-24(fp)
    2f48:	1007883a 	mov	r3,r2
    2f4c:	e0bffb17 	ldw	r2,-20(fp)
    2f50:	10c0080d 	sth	r3,32(r2)
    if (dhcp->t1_timeout == 0) {
    2f54:	e0bffb17 	ldw	r2,-20(fp)
    2f58:	1080080b 	ldhu	r2,32(r2)
    2f5c:	10bfffcc 	andi	r2,r2,65535
    2f60:	1000031e 	bne	r2,zero,2f70 <dhcp_bind+0xe0>
      dhcp->t1_timeout = 1;
    2f64:	e0bffb17 	ldw	r2,-20(fp)
    2f68:	00c00044 	movi	r3,1
    2f6c:	10c0080d 	sth	r3,32(r2)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew*1000));
  }
  /* set renewal period timer */
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
    2f70:	e0bffb17 	ldw	r2,-20(fp)
    2f74:	10801317 	ldw	r2,76(r2)
    2f78:	10bfffe0 	cmpeqi	r2,r2,-1
    2f7c:	1000161e 	bne	r2,zero,2fd8 <dhcp_bind+0x148>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
    2f80:	e0bffb17 	ldw	r2,-20(fp)
    2f84:	10801317 	ldw	r2,76(r2)
    2f88:	10c00784 	addi	r3,r2,30
    2f8c:	00800f04 	movi	r2,60
    2f90:	1885203a 	divu	r2,r3,r2
    2f94:	e0bffa15 	stw	r2,-24(fp)
    if(timeout > 0xffff) {
    2f98:	e0bffa17 	ldw	r2,-24(fp)
    2f9c:	00ffffd4 	movui	r3,65535
    2fa0:	1880022e 	bgeu	r3,r2,2fac <dhcp_bind+0x11c>
      timeout = 0xffff;
    2fa4:	00bfffd4 	movui	r2,65535
    2fa8:	e0bffa15 	stw	r2,-24(fp)
    }
    dhcp->t2_timeout = (u16_t)timeout;
    2fac:	e0bffa17 	ldw	r2,-24(fp)
    2fb0:	1007883a 	mov	r3,r2
    2fb4:	e0bffb17 	ldw	r2,-20(fp)
    2fb8:	10c0088d 	sth	r3,34(r2)
    if (dhcp->t2_timeout == 0) {
    2fbc:	e0bffb17 	ldw	r2,-20(fp)
    2fc0:	1080088b 	ldhu	r2,34(r2)
    2fc4:	10bfffcc 	andi	r2,r2,65535
    2fc8:	1000031e 	bne	r2,zero,2fd8 <dhcp_bind+0x148>
      dhcp->t2_timeout = 1;
    2fcc:	e0bffb17 	ldw	r2,-20(fp)
    2fd0:	00c00044 	movi	r3,1
    2fd4:	10c0088d 	sth	r3,34(r2)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
    2fd8:	e0bffb17 	ldw	r2,-20(fp)
    2fdc:	10800b04 	addi	r2,r2,44
    2fe0:	10000326 	beq	r2,zero,2ff0 <dhcp_bind+0x160>
    2fe4:	e0bffb17 	ldw	r2,-20(fp)
    2fe8:	10800b17 	ldw	r2,44(r2)
    2fec:	00000106 	br	2ff4 <dhcp_bind+0x164>
    2ff0:	0005883a 	mov	r2,zero
    2ff4:	10ffffcc 	andi	r3,r2,65535
    2ff8:	e13ffc8b 	ldhu	r4,-14(fp)
    2ffc:	2008703a 	and	r4,r4,zero
    3000:	20c6b03a 	or	r3,r4,r3
    3004:	e0fffc8d 	sth	r3,-14(fp)
    3008:	1004d43a 	srli	r2,r2,16
    300c:	e0fffd0b 	ldhu	r3,-12(fp)
    3010:	1806703a 	and	r3,r3,zero
    3014:	1884b03a 	or	r2,r3,r2
    3018:	e0bffd0d 	sth	r2,-12(fp)

  /* subnet mask not given? */
  /* TODO: this is not a valid check. what if the network mask is 0? */
  if (sn_mask.addr == 0) {
    301c:	e0bffc8b 	ldhu	r2,-14(fp)
    3020:	e0fffd0b 	ldhu	r3,-12(fp)
    3024:	1806943a 	slli	r3,r3,16
    3028:	1884b03a 	or	r2,r3,r2
    302c:	10003b1e 	bne	r2,zero,311c <dhcp_bind+0x28c>
    /* choose a safe subnet mask given the network class */
    u8_t first_octet = ip4_addr1(&sn_mask);
    3030:	e0bffc8b 	ldhu	r2,-14(fp)
    3034:	e0fffd0b 	ldhu	r3,-12(fp)
    3038:	1806943a 	slli	r3,r3,16
    303c:	1884b03a 	or	r2,r3,r2
    3040:	1006d63a 	srli	r3,r2,24
    3044:	e0bffc8b 	ldhu	r2,-14(fp)
    3048:	e13ffd0b 	ldhu	r4,-12(fp)
    304c:	2008943a 	slli	r4,r4,16
    3050:	2084b03a 	or	r2,r4,r2
    3054:	1004d23a 	srli	r2,r2,8
    3058:	10bfc00c 	andi	r2,r2,65280
    305c:	1886b03a 	or	r3,r3,r2
    3060:	e0bffc8b 	ldhu	r2,-14(fp)
    3064:	e13ffd0b 	ldhu	r4,-12(fp)
    3068:	2008943a 	slli	r4,r4,16
    306c:	2084b03a 	or	r2,r4,r2
    3070:	10bfc00c 	andi	r2,r2,65280
    3074:	1004923a 	slli	r2,r2,8
    3078:	1886b03a 	or	r3,r3,r2
    307c:	e0bffc8b 	ldhu	r2,-14(fp)
    3080:	e13ffd0b 	ldhu	r4,-12(fp)
    3084:	2008943a 	slli	r4,r4,16
    3088:	2084b03a 	or	r2,r4,r2
    308c:	1004963a 	slli	r2,r2,24
    3090:	1884b03a 	or	r2,r3,r2
    3094:	1004d63a 	srli	r2,r2,24
    3098:	e0bffc05 	stb	r2,-16(fp)
    if (first_octet <= 127) {
    309c:	e0bffc03 	ldbu	r2,-16(fp)
    30a0:	10803fcc 	andi	r2,r2,255
    30a4:	1080201c 	xori	r2,r2,128
    30a8:	10bfe004 	addi	r2,r2,-128
    30ac:	10000816 	blt	r2,zero,30d0 <dhcp_bind+0x240>
      sn_mask.addr = htonl(0xff000000);
    30b0:	e0bffc8b 	ldhu	r2,-14(fp)
    30b4:	1004703a 	and	r2,r2,zero
    30b8:	10803fd4 	ori	r2,r2,255
    30bc:	e0bffc8d 	sth	r2,-14(fp)
    30c0:	e0bffd0b 	ldhu	r2,-12(fp)
    30c4:	1004703a 	and	r2,r2,zero
    30c8:	e0bffd0d 	sth	r2,-12(fp)
    30cc:	00001306 	br	311c <dhcp_bind+0x28c>
    } else if (first_octet >= 192) {
    30d0:	e0bffc03 	ldbu	r2,-16(fp)
    30d4:	10803030 	cmpltui	r2,r2,192
    30d8:	1000091e 	bne	r2,zero,3100 <dhcp_bind+0x270>
      sn_mask.addr = htonl(0xffffff00);
    30dc:	e0fffc8b 	ldhu	r3,-14(fp)
    30e0:	00bfffc4 	movi	r2,-1
    30e4:	1884b03a 	or	r2,r3,r2
    30e8:	e0bffc8d 	sth	r2,-14(fp)
    30ec:	e0bffd0b 	ldhu	r2,-12(fp)
    30f0:	1004703a 	and	r2,r2,zero
    30f4:	10803fd4 	ori	r2,r2,255
    30f8:	e0bffd0d 	sth	r2,-12(fp)
    30fc:	00000706 	br	311c <dhcp_bind+0x28c>
    } else {
      sn_mask.addr = htonl(0xffff0000);
    3100:	e0fffc8b 	ldhu	r3,-14(fp)
    3104:	00bfffc4 	movi	r2,-1
    3108:	1884b03a 	or	r2,r3,r2
    310c:	e0bffc8d 	sth	r2,-14(fp)
    3110:	e0bffd0b 	ldhu	r2,-12(fp)
    3114:	1004703a 	and	r2,r2,zero
    3118:	e0bffd0d 	sth	r2,-12(fp)
    }
  }

  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
    311c:	e0bffb17 	ldw	r2,-20(fp)
    3120:	10800c04 	addi	r2,r2,48
    3124:	10000326 	beq	r2,zero,3134 <dhcp_bind+0x2a4>
    3128:	e0bffb17 	ldw	r2,-20(fp)
    312c:	10800c17 	ldw	r2,48(r2)
    3130:	00000106 	br	3138 <dhcp_bind+0x2a8>
    3134:	0005883a 	mov	r2,zero
    3138:	10ffffcc 	andi	r3,r2,65535
    313c:	e13ffd8b 	ldhu	r4,-10(fp)
    3140:	2008703a 	and	r4,r4,zero
    3144:	20c6b03a 	or	r3,r4,r3
    3148:	e0fffd8d 	sth	r3,-10(fp)
    314c:	1004d43a 	srli	r2,r2,16
    3150:	e0fffe0b 	ldhu	r3,-8(fp)
    3154:	1806703a 	and	r3,r3,zero
    3158:	1884b03a 	or	r2,r3,r2
    315c:	e0bffe0d 	sth	r2,-8(fp)
  /* gateway address not given? */
  if (gw_addr.addr == 0) {
    3160:	e0bffd8b 	ldhu	r2,-10(fp)
    3164:	e0fffe0b 	ldhu	r3,-8(fp)
    3168:	1806943a 	slli	r3,r3,16
    316c:	1884b03a 	or	r2,r3,r2
    3170:	1000201e 	bne	r2,zero,31f4 <dhcp_bind+0x364>
    /* copy network address */
    gw_addr.addr = (dhcp->offered_ip_addr.addr & sn_mask.addr);
    3174:	e0bffb17 	ldw	r2,-20(fp)
    3178:	10c00a17 	ldw	r3,40(r2)
    317c:	e0bffc8b 	ldhu	r2,-14(fp)
    3180:	e13ffd0b 	ldhu	r4,-12(fp)
    3184:	2008943a 	slli	r4,r4,16
    3188:	2084b03a 	or	r2,r4,r2
    318c:	1884703a 	and	r2,r3,r2
    3190:	10ffffcc 	andi	r3,r2,65535
    3194:	e13ffd8b 	ldhu	r4,-10(fp)
    3198:	2008703a 	and	r4,r4,zero
    319c:	20c6b03a 	or	r3,r4,r3
    31a0:	e0fffd8d 	sth	r3,-10(fp)
    31a4:	1004d43a 	srli	r2,r2,16
    31a8:	e0fffe0b 	ldhu	r3,-8(fp)
    31ac:	1806703a 	and	r3,r3,zero
    31b0:	1884b03a 	or	r2,r3,r2
    31b4:	e0bffe0d 	sth	r2,-8(fp)
    /* use first host address on network as gateway */
    gw_addr.addr |= htonl(0x00000001);
    31b8:	e0bffd8b 	ldhu	r2,-10(fp)
    31bc:	e0fffe0b 	ldhu	r3,-8(fp)
    31c0:	1806943a 	slli	r3,r3,16
    31c4:	1884b03a 	or	r2,r3,r2
    31c8:	10804034 	orhi	r2,r2,256
    31cc:	10ffffcc 	andi	r3,r2,65535
    31d0:	e13ffd8b 	ldhu	r4,-10(fp)
    31d4:	2008703a 	and	r4,r4,zero
    31d8:	20c6b03a 	or	r3,r4,r3
    31dc:	e0fffd8d 	sth	r3,-10(fp)
    31e0:	1004d43a 	srli	r2,r2,16
    31e4:	e0fffe0b 	ldhu	r3,-8(fp)
    31e8:	1806703a 	and	r3,r3,zero
    31ec:	1884b03a 	or	r2,r3,r2
    31f0:	e0bffe0d 	sth	r2,-8(fp)
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_OFF;
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): IP: 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
    31f4:	e0bffb17 	ldw	r2,-20(fp)
    31f8:	10800a04 	addi	r2,r2,40
    31fc:	e13fff17 	ldw	r4,-4(fp)
    3200:	100b883a 	mov	r5,r2
    3204:	00094ac0 	call	94ac <netif_set_ipaddr>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): SN: 0x%08"X32_F"\n", sn_mask.addr));
  netif_set_netmask(netif, &sn_mask);
    3208:	e0bffc84 	addi	r2,fp,-14
    320c:	e13fff17 	ldw	r4,-4(fp)
    3210:	100b883a 	mov	r5,r2
    3214:	00096540 	call	9654 <netif_set_netmask>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): GW: 0x%08"X32_F"\n", gw_addr.addr));
  netif_set_gw(netif, &gw_addr);
    3218:	e0bffd84 	addi	r2,fp,-10
    321c:	e13fff17 	ldw	r4,-4(fp)
    3220:	100b883a 	mov	r5,r2
    3224:	00096040 	call	9604 <netif_set_gw>
  /* bring the interface up */
  netif_set_up(netif);
    3228:	e13fff17 	ldw	r4,-4(fp)
    322c:	00096cc0 	call	96cc <netif_set_up>
  /* netif is now bound to DHCP leased address */
  dhcp_set_state(dhcp, DHCP_BOUND);
    3230:	e13ffb17 	ldw	r4,-20(fp)
    3234:	01400284 	movi	r5,10
    3238:	00039b00 	call	39b0 <dhcp_set_state>
}
    323c:	e037883a 	mov	sp,fp
    3240:	dfc00117 	ldw	ra,4(sp)
    3244:	df000017 	ldw	fp,0(sp)
    3248:	dec00204 	addi	sp,sp,8
    324c:	f800283a 	ret

00003250 <dhcp_renew>:
 *
 * @param netif network interface which must renew its lease
 */
err_t
dhcp_renew(struct netif *netif)
{
    3250:	defffa04 	addi	sp,sp,-24
    3254:	dfc00515 	stw	ra,20(sp)
    3258:	df000415 	stw	fp,16(sp)
    325c:	df000404 	addi	fp,sp,16
    3260:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    3264:	e0bfff17 	ldw	r2,-4(fp)
    3268:	10800817 	ldw	r2,32(r2)
    326c:	e0bffd15 	stw	r2,-12(fp)
  u16_t msecs;
#if LWIP_NETIF_HOSTNAME
  const char *p;
#endif /* LWIP_NETIF_HOSTNAME */
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_renew()\n"));
  dhcp_set_state(dhcp, DHCP_RENEWING);
    3270:	e13ffd17 	ldw	r4,-12(fp)
    3274:	01400144 	movi	r5,5
    3278:	00039b00 	call	39b0 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
    327c:	e13fff17 	ldw	r4,-4(fp)
    3280:	00043540 	call	4354 <dhcp_create_request>
    3284:	e0bffe05 	stb	r2,-8(fp)
  if (result == ERR_OK) {
    3288:	e0bffe07 	ldb	r2,-8(fp)
    328c:	10002a1e 	bne	r2,zero,3338 <dhcp_renew+0xe8>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
    3290:	e13ffd17 	ldw	r4,-12(fp)
    3294:	01400d44 	movi	r5,53
    3298:	01800044 	movi	r6,1
    329c:	0003a000 	call	3a00 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
    32a0:	e13ffd17 	ldw	r4,-12(fp)
    32a4:	014000c4 	movi	r5,3
    32a8:	0003ae40 	call	3ae4 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    32ac:	e13ffd17 	ldw	r4,-12(fp)
    32b0:	01400e44 	movi	r5,57
    32b4:	01800084 	movi	r6,2
    32b8:	0003a000 	call	3a00 <dhcp_option>
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
    32bc:	e0bfff17 	ldw	r2,-4(fp)
    32c0:	1080090b 	ldhu	r2,36(r2)
    32c4:	10bfffcc 	andi	r2,r2,65535
    32c8:	e13ffd17 	ldw	r4,-12(fp)
    32cc:	100b883a 	mov	r5,r2
    32d0:	0003b800 	call	3b80 <dhcp_option_short>
#if 0
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif
    /* append DHCP message trailer */
    dhcp_option_trailer(dhcp);
    32d4:	e13ffd17 	ldw	r4,-12(fp)
    32d8:	000490c0 	call	490c <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    32dc:	e0bffd17 	ldw	r2,-12(fp)
    32e0:	10c00517 	ldw	r3,20(r2)
    32e4:	e0bffd17 	ldw	r2,-12(fp)
    32e8:	1080070b 	ldhu	r2,28(r2)
    32ec:	10803c04 	addi	r2,r2,240
    32f0:	10bfffcc 	andi	r2,r2,65535
    32f4:	1809883a 	mov	r4,r3
    32f8:	100b883a 	mov	r5,r2
    32fc:	0009d0c0 	call	9d0c <pbuf_realloc>

    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
    3300:	e0bffd17 	ldw	r2,-12(fp)
    3304:	11000117 	ldw	r4,4(r2)
    3308:	e0bffd17 	ldw	r2,-12(fp)
    330c:	10c00517 	ldw	r3,20(r2)
    3310:	e0bffd17 	ldw	r2,-12(fp)
    3314:	10800904 	addi	r2,r2,36
    3318:	e17fff17 	ldw	r5,-4(fp)
    331c:	d9400015 	stw	r5,0(sp)
    3320:	180b883a 	mov	r5,r3
    3324:	100d883a 	mov	r6,r2
    3328:	01c010c4 	movi	r7,67
    332c:	001493c0 	call	1493c <udp_sendto_if>
    dhcp_delete_request(netif);
    3330:	e13fff17 	ldw	r4,-4(fp)
    3334:	00047f40 	call	47f4 <dhcp_delete_request>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_renew: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
    3338:	e0bffd17 	ldw	r2,-12(fp)
    333c:	108004c3 	ldbu	r2,19(r2)
    3340:	10800044 	addi	r2,r2,1
    3344:	1007883a 	mov	r3,r2
    3348:	e0bffd17 	ldw	r2,-12(fp)
    334c:	10c004c5 	stb	r3,19(r2)
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
    3350:	e0bffd17 	ldw	r2,-12(fp)
    3354:	108004c3 	ldbu	r2,19(r2)
    3358:	10803fcc 	andi	r2,r2,255
    335c:	108002a8 	cmpgeui	r2,r2,10
    3360:	1000051e 	bne	r2,zero,3378 <dhcp_renew+0x128>
    3364:	e0bffd17 	ldw	r2,-12(fp)
    3368:	108004c3 	ldbu	r2,19(r2)
    336c:	10803fcc 	andi	r2,r2,255
    3370:	1081f424 	muli	r2,r2,2000
    3374:	00000106 	br	337c <dhcp_renew+0x12c>
    3378:	00938804 	movi	r2,20000
    337c:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    3380:	e0bffe8b 	ldhu	r2,-6(fp)
    3384:	10c07cc4 	addi	r3,r2,499
    3388:	00807d04 	movi	r2,500
    338c:	1885283a 	div	r2,r3,r2
    3390:	1007883a 	mov	r3,r2
    3394:	e0bffd17 	ldw	r2,-12(fp)
    3398:	10c0078d 	sth	r3,30(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
    339c:	e0bffe03 	ldbu	r2,-8(fp)
}
    33a0:	e037883a 	mov	sp,fp
    33a4:	dfc00117 	ldw	ra,4(sp)
    33a8:	df000017 	ldw	fp,0(sp)
    33ac:	dec00204 	addi	sp,sp,8
    33b0:	f800283a 	ret

000033b4 <dhcp_rebind>:
 *
 * @param netif network interface which must rebind with a DHCP server
 */
static err_t
dhcp_rebind(struct netif *netif)
{
    33b4:	defffa04 	addi	sp,sp,-24
    33b8:	dfc00515 	stw	ra,20(sp)
    33bc:	df000415 	stw	fp,16(sp)
    33c0:	df000404 	addi	fp,sp,16
    33c4:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    33c8:	e0bfff17 	ldw	r2,-4(fp)
    33cc:	10800817 	ldw	r2,32(r2)
    33d0:	e0bffd15 	stw	r2,-12(fp)
  u16_t msecs;
#if LWIP_NETIF_HOSTNAME
  const char *p;
#endif /* LWIP_NETIF_HOSTNAME */
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind()\n"));
  dhcp_set_state(dhcp, DHCP_REBINDING);
    33d4:	e13ffd17 	ldw	r4,-12(fp)
    33d8:	01400104 	movi	r5,4
    33dc:	00039b00 	call	39b0 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
    33e0:	e13fff17 	ldw	r4,-4(fp)
    33e4:	00043540 	call	4354 <dhcp_create_request>
    33e8:	e0bffe05 	stb	r2,-8(fp)
  if (result == ERR_OK) {
    33ec:	e0bffe07 	ldb	r2,-8(fp)
    33f0:	10002a1e 	bne	r2,zero,349c <dhcp_rebind+0xe8>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
    33f4:	e13ffd17 	ldw	r4,-12(fp)
    33f8:	01400d44 	movi	r5,53
    33fc:	01800044 	movi	r6,1
    3400:	0003a000 	call	3a00 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
    3404:	e13ffd17 	ldw	r4,-12(fp)
    3408:	014000c4 	movi	r5,3
    340c:	0003ae40 	call	3ae4 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    3410:	e13ffd17 	ldw	r4,-12(fp)
    3414:	01400e44 	movi	r5,57
    3418:	01800084 	movi	r6,2
    341c:	0003a000 	call	3a00 <dhcp_option>
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
    3420:	e0bfff17 	ldw	r2,-4(fp)
    3424:	1080090b 	ldhu	r2,36(r2)
    3428:	10bfffcc 	andi	r2,r2,65535
    342c:	e13ffd17 	ldw	r4,-12(fp)
    3430:	100b883a 	mov	r5,r2
    3434:	0003b800 	call	3b80 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif

    dhcp_option_trailer(dhcp);
    3438:	e13ffd17 	ldw	r4,-12(fp)
    343c:	000490c0 	call	490c <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    3440:	e0bffd17 	ldw	r2,-12(fp)
    3444:	10c00517 	ldw	r3,20(r2)
    3448:	e0bffd17 	ldw	r2,-12(fp)
    344c:	1080070b 	ldhu	r2,28(r2)
    3450:	10803c04 	addi	r2,r2,240
    3454:	10bfffcc 	andi	r2,r2,65535
    3458:	1809883a 	mov	r4,r3
    345c:	100b883a 	mov	r5,r2
    3460:	0009d0c0 	call	9d0c <pbuf_realloc>

    /* broadcast to server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    3464:	e0bffd17 	ldw	r2,-12(fp)
    3468:	10c00117 	ldw	r3,4(r2)
    346c:	e0bffd17 	ldw	r2,-12(fp)
    3470:	10800517 	ldw	r2,20(r2)
    3474:	e13fff17 	ldw	r4,-4(fp)
    3478:	d9000015 	stw	r4,0(sp)
    347c:	1809883a 	mov	r4,r3
    3480:	100b883a 	mov	r5,r2
    3484:	018000f4 	movhi	r6,3
    3488:	3190ee04 	addi	r6,r6,17336
    348c:	01c010c4 	movi	r7,67
    3490:	001493c0 	call	1493c <udp_sendto_if>
    dhcp_delete_request(netif);
    3494:	e13fff17 	ldw	r4,-4(fp)
    3498:	00047f40 	call	47f4 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_rebind: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
    349c:	e0bffd17 	ldw	r2,-12(fp)
    34a0:	108004c3 	ldbu	r2,19(r2)
    34a4:	10800044 	addi	r2,r2,1
    34a8:	1007883a 	mov	r3,r2
    34ac:	e0bffd17 	ldw	r2,-12(fp)
    34b0:	10c004c5 	stb	r3,19(r2)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    34b4:	e0bffd17 	ldw	r2,-12(fp)
    34b8:	108004c3 	ldbu	r2,19(r2)
    34bc:	10803fcc 	andi	r2,r2,255
    34c0:	108002a8 	cmpgeui	r2,r2,10
    34c4:	1000051e 	bne	r2,zero,34dc <dhcp_rebind+0x128>
    34c8:	e0bffd17 	ldw	r2,-12(fp)
    34cc:	108004c3 	ldbu	r2,19(r2)
    34d0:	10803fcc 	andi	r2,r2,255
    34d4:	1080fa24 	muli	r2,r2,1000
    34d8:	00000106 	br	34e0 <dhcp_rebind+0x12c>
    34dc:	0089c404 	movi	r2,10000
    34e0:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    34e4:	e0bffe8b 	ldhu	r2,-6(fp)
    34e8:	10c07cc4 	addi	r3,r2,499
    34ec:	00807d04 	movi	r2,500
    34f0:	1885283a 	div	r2,r3,r2
    34f4:	1007883a 	mov	r3,r2
    34f8:	e0bffd17 	ldw	r2,-12(fp)
    34fc:	10c0078d 	sth	r3,30(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
    3500:	e0bffe03 	ldbu	r2,-8(fp)
}
    3504:	e037883a 	mov	sp,fp
    3508:	dfc00117 	ldw	ra,4(sp)
    350c:	df000017 	ldw	fp,0(sp)
    3510:	dec00204 	addi	sp,sp,8
    3514:	f800283a 	ret

00003518 <dhcp_reboot>:
 *
 * @param netif network interface which must reboot
 */
static err_t
dhcp_reboot(struct netif *netif)
{
    3518:	defffa04 	addi	sp,sp,-24
    351c:	dfc00515 	stw	ra,20(sp)
    3520:	df000415 	stw	fp,16(sp)
    3524:	df000404 	addi	fp,sp,16
    3528:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    352c:	e0bfff17 	ldw	r2,-4(fp)
    3530:	10800817 	ldw	r2,32(r2)
    3534:	e0bffd15 	stw	r2,-12(fp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot()\n"));
  dhcp_set_state(dhcp, DHCP_REBOOTING);
    3538:	e13ffd17 	ldw	r4,-12(fp)
    353c:	014000c4 	movi	r5,3
    3540:	00039b00 	call	39b0 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
    3544:	e13fff17 	ldw	r4,-4(fp)
    3548:	00043540 	call	4354 <dhcp_create_request>
    354c:	e0bffe05 	stb	r2,-8(fp)
  if (result == ERR_OK) {
    3550:	e0bffe07 	ldb	r2,-8(fp)
    3554:	10003f1e 	bne	r2,zero,3654 <dhcp_reboot+0x13c>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
    3558:	e13ffd17 	ldw	r4,-12(fp)
    355c:	01400d44 	movi	r5,53
    3560:	01800044 	movi	r6,1
    3564:	0003a000 	call	3a00 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
    3568:	e13ffd17 	ldw	r4,-12(fp)
    356c:	014000c4 	movi	r5,3
    3570:	0003ae40 	call	3ae4 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    3574:	e13ffd17 	ldw	r4,-12(fp)
    3578:	01400e44 	movi	r5,57
    357c:	01800084 	movi	r6,2
    3580:	0003a000 	call	3a00 <dhcp_option>
    dhcp_option_short(dhcp, 576);
    3584:	e13ffd17 	ldw	r4,-12(fp)
    3588:	01409004 	movi	r5,576
    358c:	0003b800 	call	3b80 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
    3590:	e13ffd17 	ldw	r4,-12(fp)
    3594:	01400c84 	movi	r5,50
    3598:	01800104 	movi	r6,4
    359c:	0003a000 	call	3a00 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
    35a0:	e0bffd17 	ldw	r2,-12(fp)
    35a4:	10800a17 	ldw	r2,40(r2)
    35a8:	1006d63a 	srli	r3,r2,24
    35ac:	e0bffd17 	ldw	r2,-12(fp)
    35b0:	10800a17 	ldw	r2,40(r2)
    35b4:	1004d23a 	srli	r2,r2,8
    35b8:	10bfc00c 	andi	r2,r2,65280
    35bc:	1886b03a 	or	r3,r3,r2
    35c0:	e0bffd17 	ldw	r2,-12(fp)
    35c4:	10800a17 	ldw	r2,40(r2)
    35c8:	10bfc00c 	andi	r2,r2,65280
    35cc:	1004923a 	slli	r2,r2,8
    35d0:	1886b03a 	or	r3,r3,r2
    35d4:	e0bffd17 	ldw	r2,-12(fp)
    35d8:	10800a17 	ldw	r2,40(r2)
    35dc:	1004963a 	slli	r2,r2,24
    35e0:	1884b03a 	or	r2,r3,r2
    35e4:	e13ffd17 	ldw	r4,-12(fp)
    35e8:	100b883a 	mov	r5,r2
    35ec:	0003c580 	call	3c58 <dhcp_option_long>

    dhcp_option_trailer(dhcp);
    35f0:	e13ffd17 	ldw	r4,-12(fp)
    35f4:	000490c0 	call	490c <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    35f8:	e0bffd17 	ldw	r2,-12(fp)
    35fc:	10c00517 	ldw	r3,20(r2)
    3600:	e0bffd17 	ldw	r2,-12(fp)
    3604:	1080070b 	ldhu	r2,28(r2)
    3608:	10803c04 	addi	r2,r2,240
    360c:	10bfffcc 	andi	r2,r2,65535
    3610:	1809883a 	mov	r4,r3
    3614:	100b883a 	mov	r5,r2
    3618:	0009d0c0 	call	9d0c <pbuf_realloc>

    /* broadcast to server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    361c:	e0bffd17 	ldw	r2,-12(fp)
    3620:	10c00117 	ldw	r3,4(r2)
    3624:	e0bffd17 	ldw	r2,-12(fp)
    3628:	10800517 	ldw	r2,20(r2)
    362c:	e13fff17 	ldw	r4,-4(fp)
    3630:	d9000015 	stw	r4,0(sp)
    3634:	1809883a 	mov	r4,r3
    3638:	100b883a 	mov	r5,r2
    363c:	018000f4 	movhi	r6,3
    3640:	3190ee04 	addi	r6,r6,17336
    3644:	01c010c4 	movi	r7,67
    3648:	001493c0 	call	1493c <udp_sendto_if>
    dhcp_delete_request(netif);
    364c:	e13fff17 	ldw	r4,-4(fp)
    3650:	00047f40 	call	47f4 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot: REBOOTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_reboot: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
    3654:	e0bffd17 	ldw	r2,-12(fp)
    3658:	108004c3 	ldbu	r2,19(r2)
    365c:	10800044 	addi	r2,r2,1
    3660:	1007883a 	mov	r3,r2
    3664:	e0bffd17 	ldw	r2,-12(fp)
    3668:	10c004c5 	stb	r3,19(r2)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    366c:	e0bffd17 	ldw	r2,-12(fp)
    3670:	108004c3 	ldbu	r2,19(r2)
    3674:	10803fcc 	andi	r2,r2,255
    3678:	108002a8 	cmpgeui	r2,r2,10
    367c:	1000051e 	bne	r2,zero,3694 <dhcp_reboot+0x17c>
    3680:	e0bffd17 	ldw	r2,-12(fp)
    3684:	108004c3 	ldbu	r2,19(r2)
    3688:	10803fcc 	andi	r2,r2,255
    368c:	1080fa24 	muli	r2,r2,1000
    3690:	00000106 	br	3698 <dhcp_reboot+0x180>
    3694:	0089c404 	movi	r2,10000
    3698:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    369c:	e0bffe8b 	ldhu	r2,-6(fp)
    36a0:	10c07cc4 	addi	r3,r2,499
    36a4:	00807d04 	movi	r2,500
    36a8:	1885283a 	div	r2,r3,r2
    36ac:	1007883a 	mov	r3,r2
    36b0:	e0bffd17 	ldw	r2,-12(fp)
    36b4:	10c0078d 	sth	r3,30(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
    36b8:	e0bffe03 	ldbu	r2,-8(fp)
}
    36bc:	e037883a 	mov	sp,fp
    36c0:	dfc00117 	ldw	ra,4(sp)
    36c4:	df000017 	ldw	fp,0(sp)
    36c8:	dec00204 	addi	sp,sp,8
    36cc:	f800283a 	ret

000036d0 <dhcp_release>:
 *
 * @param netif network interface which must release its lease
 */
err_t
dhcp_release(struct netif *netif)
{
    36d0:	defffa04 	addi	sp,sp,-24
    36d4:	dfc00515 	stw	ra,20(sp)
    36d8:	df000415 	stw	fp,16(sp)
    36dc:	df000404 	addi	fp,sp,16
    36e0:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    36e4:	e0bfff17 	ldw	r2,-4(fp)
    36e8:	10800817 	ldw	r2,32(r2)
    36ec:	e0bffd15 	stw	r2,-12(fp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_release()\n"));

  /* idle DHCP client */
  dhcp_set_state(dhcp, DHCP_OFF);
    36f0:	e13ffd17 	ldw	r4,-12(fp)
    36f4:	01400344 	movi	r5,13
    36f8:	00039b00 	call	39b0 <dhcp_set_state>
  /* clean old DHCP offer */
  dhcp->server_ip_addr.addr = 0;
    36fc:	e0bffd17 	ldw	r2,-12(fp)
    3700:	10000915 	stw	zero,36(r2)
  dhcp->offered_ip_addr.addr = dhcp->offered_sn_mask.addr = 0;
    3704:	e0bffd17 	ldw	r2,-12(fp)
    3708:	10000b15 	stw	zero,44(r2)
    370c:	e0bffd17 	ldw	r2,-12(fp)
    3710:	10c00b17 	ldw	r3,44(r2)
    3714:	e0bffd17 	ldw	r2,-12(fp)
    3718:	10c00a15 	stw	r3,40(r2)
  dhcp->offered_gw_addr.addr = dhcp->offered_bc_addr.addr = 0;
    371c:	e0bffd17 	ldw	r2,-12(fp)
    3720:	10000d15 	stw	zero,52(r2)
    3724:	e0bffd17 	ldw	r2,-12(fp)
    3728:	10c00d17 	ldw	r3,52(r2)
    372c:	e0bffd17 	ldw	r2,-12(fp)
    3730:	10c00c15 	stw	r3,48(r2)
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
    3734:	e0bffd17 	ldw	r2,-12(fp)
    3738:	10001315 	stw	zero,76(r2)
    373c:	e0bffd17 	ldw	r2,-12(fp)
    3740:	10c01317 	ldw	r3,76(r2)
    3744:	e0bffd17 	ldw	r2,-12(fp)
    3748:	10c01215 	stw	r3,72(r2)
    374c:	e0bffd17 	ldw	r2,-12(fp)
    3750:	10c01217 	ldw	r3,72(r2)
    3754:	e0bffd17 	ldw	r2,-12(fp)
    3758:	10c01115 	stw	r3,68(r2)
  dhcp->dns_count = 0;
    375c:	e0bffd17 	ldw	r2,-12(fp)
    3760:	10000e15 	stw	zero,56(r2)
  
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
    3764:	e13fff17 	ldw	r4,-4(fp)
    3768:	00043540 	call	4354 <dhcp_create_request>
    376c:	e0bffe05 	stb	r2,-8(fp)
  if (result == ERR_OK) {
    3770:	e0bffe07 	ldb	r2,-8(fp)
    3774:	1000201e 	bne	r2,zero,37f8 <dhcp_release+0x128>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
    3778:	e13ffd17 	ldw	r4,-12(fp)
    377c:	01400d44 	movi	r5,53
    3780:	01800044 	movi	r6,1
    3784:	0003a000 	call	3a00 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_RELEASE);
    3788:	e13ffd17 	ldw	r4,-12(fp)
    378c:	014001c4 	movi	r5,7
    3790:	0003ae40 	call	3ae4 <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
    3794:	e13ffd17 	ldw	r4,-12(fp)
    3798:	000490c0 	call	490c <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    379c:	e0bffd17 	ldw	r2,-12(fp)
    37a0:	10c00517 	ldw	r3,20(r2)
    37a4:	e0bffd17 	ldw	r2,-12(fp)
    37a8:	1080070b 	ldhu	r2,28(r2)
    37ac:	10803c04 	addi	r2,r2,240
    37b0:	10bfffcc 	andi	r2,r2,65535
    37b4:	1809883a 	mov	r4,r3
    37b8:	100b883a 	mov	r5,r2
    37bc:	0009d0c0 	call	9d0c <pbuf_realloc>

    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
    37c0:	e0bffd17 	ldw	r2,-12(fp)
    37c4:	11000117 	ldw	r4,4(r2)
    37c8:	e0bffd17 	ldw	r2,-12(fp)
    37cc:	10c00517 	ldw	r3,20(r2)
    37d0:	e0bffd17 	ldw	r2,-12(fp)
    37d4:	10800904 	addi	r2,r2,36
    37d8:	e17fff17 	ldw	r5,-4(fp)
    37dc:	d9400015 	stw	r5,0(sp)
    37e0:	180b883a 	mov	r5,r3
    37e4:	100d883a 	mov	r6,r2
    37e8:	01c010c4 	movi	r7,67
    37ec:	001493c0 	call	1493c <udp_sendto_if>
    dhcp_delete_request(netif);
    37f0:	e13fff17 	ldw	r4,-4(fp)
    37f4:	00047f40 	call	47f4 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_release: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
    37f8:	e0bffd17 	ldw	r2,-12(fp)
    37fc:	108004c3 	ldbu	r2,19(r2)
    3800:	10800044 	addi	r2,r2,1
    3804:	1007883a 	mov	r3,r2
    3808:	e0bffd17 	ldw	r2,-12(fp)
    380c:	10c004c5 	stb	r3,19(r2)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    3810:	e0bffd17 	ldw	r2,-12(fp)
    3814:	108004c3 	ldbu	r2,19(r2)
    3818:	10803fcc 	andi	r2,r2,255
    381c:	108002a8 	cmpgeui	r2,r2,10
    3820:	1000051e 	bne	r2,zero,3838 <dhcp_release+0x168>
    3824:	e0bffd17 	ldw	r2,-12(fp)
    3828:	108004c3 	ldbu	r2,19(r2)
    382c:	10803fcc 	andi	r2,r2,255
    3830:	1080fa24 	muli	r2,r2,1000
    3834:	00000106 	br	383c <dhcp_release+0x16c>
    3838:	0089c404 	movi	r2,10000
    383c:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    3840:	e0bffe8b 	ldhu	r2,-6(fp)
    3844:	10c07cc4 	addi	r3,r2,499
    3848:	00807d04 	movi	r2,500
    384c:	1885283a 	div	r2,r3,r2
    3850:	1007883a 	mov	r3,r2
    3854:	e0bffd17 	ldw	r2,-12(fp)
    3858:	10c0078d 	sth	r3,30(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release(): set request timeout %"U16_F" msecs\n", msecs));
  /* bring the interface down */
  netif_set_down(netif);
    385c:	e13fff17 	ldw	r4,-4(fp)
    3860:	00097480 	call	9748 <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
    3864:	e13fff17 	ldw	r4,-4(fp)
    3868:	014000f4 	movhi	r5,3
    386c:	2950ed04 	addi	r5,r5,17332
    3870:	00094ac0 	call	94ac <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
    3874:	e13fff17 	ldw	r4,-4(fp)
    3878:	014000f4 	movhi	r5,3
    387c:	2950ed04 	addi	r5,r5,17332
    3880:	00096040 	call	9604 <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY);
    3884:	e13fff17 	ldw	r4,-4(fp)
    3888:	014000f4 	movhi	r5,3
    388c:	2950ed04 	addi	r5,r5,17332
    3890:	00096540 	call	9654 <netif_set_netmask>
  
  /* TODO: netif_down(netif); */
  return result;
    3894:	e0bffe03 	ldbu	r2,-8(fp)
}
    3898:	e037883a 	mov	sp,fp
    389c:	dfc00117 	ldw	ra,4(sp)
    38a0:	df000017 	ldw	fp,0(sp)
    38a4:	dec00204 	addi	sp,sp,8
    38a8:	f800283a 	ret

000038ac <dhcp_stop>:
 *
 * @param netif The network interface to stop DHCP on
 */
void
dhcp_stop(struct netif *netif)
{
    38ac:	defffc04 	addi	sp,sp,-16
    38b0:	dfc00315 	stw	ra,12(sp)
    38b4:	df000215 	stw	fp,8(sp)
    38b8:	df000204 	addi	fp,sp,8
    38bc:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    38c0:	e0bfff17 	ldw	r2,-4(fp)
    38c4:	10800817 	ldw	r2,32(r2)
    38c8:	e0bffe15 	stw	r2,-8(fp)
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
    38cc:	e0bfff17 	ldw	r2,-4(fp)
    38d0:	1000091e 	bne	r2,zero,38f8 <dhcp_stop+0x4c>
    38d4:	010000f4 	movhi	r4,3
    38d8:	2137d904 	addi	r4,r4,-8348
    38dc:	014000f4 	movhi	r5,3
    38e0:	29780504 	addi	r5,r5,-8172
    38e4:	01812c04 	movi	r6,1200
    38e8:	01c000f4 	movhi	r7,3
    38ec:	39f7e704 	addi	r7,r7,-8292
    38f0:	00170680 	call	17068 <printf>
    38f4:	003fff06 	br	38f4 <dhcp_stop+0x48>
  /* Remove the flag that says this netif is handled by DHCP. */
  netif->flags &= ~NETIF_FLAG_DHCP;
    38f8:	e0bfff17 	ldw	r2,-4(fp)
    38fc:	10c00b43 	ldbu	r3,45(r2)
    3900:	00bffdc4 	movi	r2,-9
    3904:	1884703a 	and	r2,r3,r2
    3908:	1007883a 	mov	r3,r2
    390c:	e0bfff17 	ldw	r2,-4(fp)
    3910:	10c00b45 	stb	r3,45(r2)

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_stop()\n"));
  /* netif is DHCP configured? */
  if (dhcp != NULL) {
    3914:	e0bffe17 	ldw	r2,-8(fp)
    3918:	10002026 	beq	r2,zero,399c <dhcp_stop+0xf0>
    autoip_stop(netif);
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_OFF;
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */

    if (dhcp->pcb != NULL) {
    391c:	e0bffe17 	ldw	r2,-8(fp)
    3920:	10800117 	ldw	r2,4(r2)
    3924:	10000626 	beq	r2,zero,3940 <dhcp_stop+0x94>
      udp_remove(dhcp->pcb);
    3928:	e0bffe17 	ldw	r2,-8(fp)
    392c:	10800117 	ldw	r2,4(r2)
    3930:	1009883a 	mov	r4,r2
    3934:	0014f400 	call	14f40 <udp_remove>
      dhcp->pcb = NULL;
    3938:	e0bffe17 	ldw	r2,-8(fp)
    393c:	10000115 	stw	zero,4(r2)
    }
    LWIP_ASSERT("reply wasn't freed", dhcp->msg_in == NULL &&
    3940:	e0bffe17 	ldw	r2,-8(fp)
    3944:	10800217 	ldw	r2,8(r2)
    3948:	1000071e 	bne	r2,zero,3968 <dhcp_stop+0xbc>
    394c:	e0bffe17 	ldw	r2,-8(fp)
    3950:	10800317 	ldw	r2,12(r2)
    3954:	1000041e 	bne	r2,zero,3968 <dhcp_stop+0xbc>
    3958:	e0bffe17 	ldw	r2,-8(fp)
    395c:	1080040b 	ldhu	r2,16(r2)
    3960:	10bfffcc 	andi	r2,r2,65535
    3964:	10000926 	beq	r2,zero,398c <dhcp_stop+0xe0>
    3968:	010000f4 	movhi	r4,3
    396c:	2137d904 	addi	r4,r4,-8348
    3970:	014000f4 	movhi	r5,3
    3974:	2977f304 	addi	r5,r5,-8244
    3978:	018130c4 	movi	r6,1219
    397c:	01c000f4 	movhi	r7,3
    3980:	39f7e704 	addi	r7,r7,-8292
    3984:	00170680 	call	17068 <printf>
    3988:	003fff06 	br	3988 <dhcp_stop+0xdc>
      dhcp->options_in == NULL && dhcp->options_in_len == 0);
    mem_free((void *)dhcp);
    398c:	e13ffe17 	ldw	r4,-8(fp)
    3990:	00084480 	call	8448 <mem_free>
    netif->dhcp = NULL;
    3994:	e0bfff17 	ldw	r2,-4(fp)
    3998:	10000815 	stw	zero,32(r2)
  }
}
    399c:	e037883a 	mov	sp,fp
    39a0:	dfc00117 	ldw	ra,4(sp)
    39a4:	df000017 	ldw	fp,0(sp)
    39a8:	dec00204 	addi	sp,sp,8
    39ac:	f800283a 	ret

000039b0 <dhcp_set_state>:
 *
 * TODO: we might also want to reset the timeout here?
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
    39b0:	defffd04 	addi	sp,sp,-12
    39b4:	df000215 	stw	fp,8(sp)
    39b8:	df000204 	addi	fp,sp,8
    39bc:	e13ffe15 	stw	r4,-8(fp)
    39c0:	2805883a 	mov	r2,r5
    39c4:	e0bfff05 	stb	r2,-4(fp)
  if (new_state != dhcp->state) {
    39c8:	e0bffe17 	ldw	r2,-8(fp)
    39cc:	10800483 	ldbu	r2,18(r2)
    39d0:	10c03fcc 	andi	r3,r2,255
    39d4:	e0bfff03 	ldbu	r2,-4(fp)
    39d8:	18800526 	beq	r3,r2,39f0 <dhcp_set_state+0x40>
    dhcp->state = new_state;
    39dc:	e0bffe17 	ldw	r2,-8(fp)
    39e0:	e0ffff03 	ldbu	r3,-4(fp)
    39e4:	10c00485 	stb	r3,18(r2)
    dhcp->tries = 0;
    39e8:	e0bffe17 	ldw	r2,-8(fp)
    39ec:	100004c5 	stb	zero,19(r2)
  }
}
    39f0:	e037883a 	mov	sp,fp
    39f4:	df000017 	ldw	fp,0(sp)
    39f8:	dec00104 	addi	sp,sp,4
    39fc:	f800283a 	ret

00003a00 <dhcp_option>:
 * DHCP message.
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
    3a00:	defffb04 	addi	sp,sp,-20
    3a04:	dfc00415 	stw	ra,16(sp)
    3a08:	df000315 	stw	fp,12(sp)
    3a0c:	df000304 	addi	fp,sp,12
    3a10:	e13ffd15 	stw	r4,-12(fp)
    3a14:	2807883a 	mov	r3,r5
    3a18:	3005883a 	mov	r2,r6
    3a1c:	e0fffe05 	stb	r3,-8(fp)
    3a20:	e0bfff05 	stb	r2,-4(fp)
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
    3a24:	e0bffd17 	ldw	r2,-12(fp)
    3a28:	1080070b 	ldhu	r2,28(r2)
    3a2c:	10ffffcc 	andi	r3,r2,65535
    3a30:	e0bfff03 	ldbu	r2,-4(fp)
    3a34:	1885883a 	add	r2,r3,r2
    3a38:	10800084 	addi	r2,r2,2
    3a3c:	10801170 	cmpltui	r2,r2,69
    3a40:	1000091e 	bne	r2,zero,3a68 <dhcp_option+0x68>
    3a44:	010000f4 	movhi	r4,3
    3a48:	2137d904 	addi	r4,r4,-8348
    3a4c:	014000f4 	movhi	r5,3
    3a50:	29780c04 	addi	r5,r5,-8144
    3a54:	01813844 	movi	r6,1249
    3a58:	01c000f4 	movhi	r7,3
    3a5c:	39f7e704 	addi	r7,r7,-8292
    3a60:	00170680 	call	17068 <printf>
    3a64:	003fff06 	br	3a64 <dhcp_option+0x64>
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
    3a68:	e0bffd17 	ldw	r2,-12(fp)
    3a6c:	11000617 	ldw	r4,24(r2)
    3a70:	e0bffd17 	ldw	r2,-12(fp)
    3a74:	1080070b 	ldhu	r2,28(r2)
    3a78:	10ffffcc 	andi	r3,r2,65535
    3a7c:	20c7883a 	add	r3,r4,r3
    3a80:	18c03c04 	addi	r3,r3,240
    3a84:	e13ffe03 	ldbu	r4,-8(fp)
    3a88:	19000005 	stb	r4,0(r3)
    3a8c:	10800044 	addi	r2,r2,1
    3a90:	1007883a 	mov	r3,r2
    3a94:	e0bffd17 	ldw	r2,-12(fp)
    3a98:	10c0070d 	sth	r3,28(r2)
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
    3a9c:	e0bffd17 	ldw	r2,-12(fp)
    3aa0:	11000617 	ldw	r4,24(r2)
    3aa4:	e0bffd17 	ldw	r2,-12(fp)
    3aa8:	1080070b 	ldhu	r2,28(r2)
    3aac:	10ffffcc 	andi	r3,r2,65535
    3ab0:	20c7883a 	add	r3,r4,r3
    3ab4:	18c03c04 	addi	r3,r3,240
    3ab8:	e13fff03 	ldbu	r4,-4(fp)
    3abc:	19000005 	stb	r4,0(r3)
    3ac0:	10800044 	addi	r2,r2,1
    3ac4:	1007883a 	mov	r3,r2
    3ac8:	e0bffd17 	ldw	r2,-12(fp)
    3acc:	10c0070d 	sth	r3,28(r2)
}
    3ad0:	e037883a 	mov	sp,fp
    3ad4:	dfc00117 	ldw	ra,4(sp)
    3ad8:	df000017 	ldw	fp,0(sp)
    3adc:	dec00204 	addi	sp,sp,8
    3ae0:	f800283a 	ret

00003ae4 <dhcp_option_byte>:
 * Concatenate a single byte to the outgoing DHCP message.
 *
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
    3ae4:	defffc04 	addi	sp,sp,-16
    3ae8:	dfc00315 	stw	ra,12(sp)
    3aec:	df000215 	stw	fp,8(sp)
    3af0:	df000204 	addi	fp,sp,8
    3af4:	e13ffe15 	stw	r4,-8(fp)
    3af8:	2805883a 	mov	r2,r5
    3afc:	e0bfff05 	stb	r2,-4(fp)
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
    3b00:	e0bffe17 	ldw	r2,-8(fp)
    3b04:	1080070b 	ldhu	r2,28(r2)
    3b08:	10bfffcc 	andi	r2,r2,65535
    3b0c:	10801130 	cmpltui	r2,r2,68
    3b10:	1000091e 	bne	r2,zero,3b38 <dhcp_option_byte+0x54>
    3b14:	010000f4 	movhi	r4,3
    3b18:	2137d904 	addi	r4,r4,-8348
    3b1c:	014000f4 	movhi	r5,3
    3b20:	29781e04 	addi	r5,r5,-8072
    3b24:	01813b04 	movi	r6,1260
    3b28:	01c000f4 	movhi	r7,3
    3b2c:	39f7e704 	addi	r7,r7,-8292
    3b30:	00170680 	call	17068 <printf>
    3b34:	003fff06 	br	3b34 <dhcp_option_byte+0x50>
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
    3b38:	e0bffe17 	ldw	r2,-8(fp)
    3b3c:	11000617 	ldw	r4,24(r2)
    3b40:	e0bffe17 	ldw	r2,-8(fp)
    3b44:	1080070b 	ldhu	r2,28(r2)
    3b48:	10ffffcc 	andi	r3,r2,65535
    3b4c:	20c7883a 	add	r3,r4,r3
    3b50:	18c03c04 	addi	r3,r3,240
    3b54:	e13fff03 	ldbu	r4,-4(fp)
    3b58:	19000005 	stb	r4,0(r3)
    3b5c:	10800044 	addi	r2,r2,1
    3b60:	1007883a 	mov	r3,r2
    3b64:	e0bffe17 	ldw	r2,-8(fp)
    3b68:	10c0070d 	sth	r3,28(r2)
}
    3b6c:	e037883a 	mov	sp,fp
    3b70:	dfc00117 	ldw	ra,4(sp)
    3b74:	df000017 	ldw	fp,0(sp)
    3b78:	dec00204 	addi	sp,sp,8
    3b7c:	f800283a 	ret

00003b80 <dhcp_option_short>:

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
    3b80:	defffc04 	addi	sp,sp,-16
    3b84:	dfc00315 	stw	ra,12(sp)
    3b88:	df000215 	stw	fp,8(sp)
    3b8c:	df000204 	addi	fp,sp,8
    3b90:	e13ffe15 	stw	r4,-8(fp)
    3b94:	2805883a 	mov	r2,r5
    3b98:	e0bfff0d 	sth	r2,-4(fp)
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
    3b9c:	e0bffe17 	ldw	r2,-8(fp)
    3ba0:	1080070b 	ldhu	r2,28(r2)
    3ba4:	10bfffcc 	andi	r2,r2,65535
    3ba8:	10800084 	addi	r2,r2,2
    3bac:	10801170 	cmpltui	r2,r2,69
    3bb0:	1000091e 	bne	r2,zero,3bd8 <dhcp_option_short+0x58>
    3bb4:	010000f4 	movhi	r4,3
    3bb8:	2137d904 	addi	r4,r4,-8348
    3bbc:	014000f4 	movhi	r5,3
    3bc0:	29782d04 	addi	r5,r5,-8012
    3bc4:	01813cc4 	movi	r6,1267
    3bc8:	01c000f4 	movhi	r7,3
    3bcc:	39f7e704 	addi	r7,r7,-8292
    3bd0:	00170680 	call	17068 <printf>
    3bd4:	003fff06 	br	3bd4 <dhcp_option_short+0x54>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
    3bd8:	e0bffe17 	ldw	r2,-8(fp)
    3bdc:	11400617 	ldw	r5,24(r2)
    3be0:	e0bffe17 	ldw	r2,-8(fp)
    3be4:	1080070b 	ldhu	r2,28(r2)
    3be8:	10ffffcc 	andi	r3,r2,65535
    3bec:	e13fff0b 	ldhu	r4,-4(fp)
    3bf0:	2008d23a 	srli	r4,r4,8
    3bf4:	28c7883a 	add	r3,r5,r3
    3bf8:	18c03c04 	addi	r3,r3,240
    3bfc:	19000005 	stb	r4,0(r3)
    3c00:	10800044 	addi	r2,r2,1
    3c04:	1007883a 	mov	r3,r2
    3c08:	e0bffe17 	ldw	r2,-8(fp)
    3c0c:	10c0070d 	sth	r3,28(r2)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
    3c10:	e0bffe17 	ldw	r2,-8(fp)
    3c14:	11400617 	ldw	r5,24(r2)
    3c18:	e0bffe17 	ldw	r2,-8(fp)
    3c1c:	1080070b 	ldhu	r2,28(r2)
    3c20:	10ffffcc 	andi	r3,r2,65535
    3c24:	e13fff0b 	ldhu	r4,-4(fp)
    3c28:	28c7883a 	add	r3,r5,r3
    3c2c:	18c03c04 	addi	r3,r3,240
    3c30:	19000005 	stb	r4,0(r3)
    3c34:	10800044 	addi	r2,r2,1
    3c38:	1007883a 	mov	r3,r2
    3c3c:	e0bffe17 	ldw	r2,-8(fp)
    3c40:	10c0070d 	sth	r3,28(r2)
}
    3c44:	e037883a 	mov	sp,fp
    3c48:	dfc00117 	ldw	ra,4(sp)
    3c4c:	df000017 	ldw	fp,0(sp)
    3c50:	dec00204 	addi	sp,sp,8
    3c54:	f800283a 	ret

00003c58 <dhcp_option_long>:

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
    3c58:	defffc04 	addi	sp,sp,-16
    3c5c:	dfc00315 	stw	ra,12(sp)
    3c60:	df000215 	stw	fp,8(sp)
    3c64:	df000204 	addi	fp,sp,8
    3c68:	e13ffe15 	stw	r4,-8(fp)
    3c6c:	e17fff15 	stw	r5,-4(fp)
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
    3c70:	e0bffe17 	ldw	r2,-8(fp)
    3c74:	1080070b 	ldhu	r2,28(r2)
    3c78:	10bfffcc 	andi	r2,r2,65535
    3c7c:	10800104 	addi	r2,r2,4
    3c80:	10801170 	cmpltui	r2,r2,69
    3c84:	1000091e 	bne	r2,zero,3cac <dhcp_option_long+0x54>
    3c88:	010000f4 	movhi	r4,3
    3c8c:	2137d904 	addi	r4,r4,-8348
    3c90:	014000f4 	movhi	r5,3
    3c94:	29783e04 	addi	r5,r5,-7944
    3c98:	01813ec4 	movi	r6,1275
    3c9c:	01c000f4 	movhi	r7,3
    3ca0:	39f7e704 	addi	r7,r7,-8292
    3ca4:	00170680 	call	17068 <printf>
    3ca8:	003fff06 	br	3ca8 <dhcp_option_long+0x50>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
    3cac:	e0bffe17 	ldw	r2,-8(fp)
    3cb0:	11400617 	ldw	r5,24(r2)
    3cb4:	e0bffe17 	ldw	r2,-8(fp)
    3cb8:	1080070b 	ldhu	r2,28(r2)
    3cbc:	10ffffcc 	andi	r3,r2,65535
    3cc0:	e13fff17 	ldw	r4,-4(fp)
    3cc4:	2008d63a 	srli	r4,r4,24
    3cc8:	28c7883a 	add	r3,r5,r3
    3ccc:	18c03c04 	addi	r3,r3,240
    3cd0:	19000005 	stb	r4,0(r3)
    3cd4:	10800044 	addi	r2,r2,1
    3cd8:	1007883a 	mov	r3,r2
    3cdc:	e0bffe17 	ldw	r2,-8(fp)
    3ce0:	10c0070d 	sth	r3,28(r2)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
    3ce4:	e0bffe17 	ldw	r2,-8(fp)
    3ce8:	11400617 	ldw	r5,24(r2)
    3cec:	e0bffe17 	ldw	r2,-8(fp)
    3cf0:	1080070b 	ldhu	r2,28(r2)
    3cf4:	10ffffcc 	andi	r3,r2,65535
    3cf8:	e13fff17 	ldw	r4,-4(fp)
    3cfc:	21003fec 	andhi	r4,r4,255
    3d00:	2008d43a 	srli	r4,r4,16
    3d04:	28c7883a 	add	r3,r5,r3
    3d08:	18c03c04 	addi	r3,r3,240
    3d0c:	19000005 	stb	r4,0(r3)
    3d10:	10800044 	addi	r2,r2,1
    3d14:	1007883a 	mov	r3,r2
    3d18:	e0bffe17 	ldw	r2,-8(fp)
    3d1c:	10c0070d 	sth	r3,28(r2)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
    3d20:	e0bffe17 	ldw	r2,-8(fp)
    3d24:	11400617 	ldw	r5,24(r2)
    3d28:	e0bffe17 	ldw	r2,-8(fp)
    3d2c:	1080070b 	ldhu	r2,28(r2)
    3d30:	10ffffcc 	andi	r3,r2,65535
    3d34:	e13fff17 	ldw	r4,-4(fp)
    3d38:	213fc00c 	andi	r4,r4,65280
    3d3c:	2008d23a 	srli	r4,r4,8
    3d40:	28c7883a 	add	r3,r5,r3
    3d44:	18c03c04 	addi	r3,r3,240
    3d48:	19000005 	stb	r4,0(r3)
    3d4c:	10800044 	addi	r2,r2,1
    3d50:	1007883a 	mov	r3,r2
    3d54:	e0bffe17 	ldw	r2,-8(fp)
    3d58:	10c0070d 	sth	r3,28(r2)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
    3d5c:	e0bffe17 	ldw	r2,-8(fp)
    3d60:	11400617 	ldw	r5,24(r2)
    3d64:	e0bffe17 	ldw	r2,-8(fp)
    3d68:	1080070b 	ldhu	r2,28(r2)
    3d6c:	10ffffcc 	andi	r3,r2,65535
    3d70:	e13fff17 	ldw	r4,-4(fp)
    3d74:	28c7883a 	add	r3,r5,r3
    3d78:	18c03c04 	addi	r3,r3,240
    3d7c:	19000005 	stb	r4,0(r3)
    3d80:	10800044 	addi	r2,r2,1
    3d84:	1007883a 	mov	r3,r2
    3d88:	e0bffe17 	ldw	r2,-8(fp)
    3d8c:	10c0070d 	sth	r3,28(r2)
}
    3d90:	e037883a 	mov	sp,fp
    3d94:	dfc00117 	ldw	ra,4(sp)
    3d98:	df000017 	ldw	fp,0(sp)
    3d9c:	dec00204 	addi	sp,sp,8
    3da0:	f800283a 	ret

00003da4 <dhcp_unfold_reply>:
 * use that further on.
 *
 */
static err_t
dhcp_unfold_reply(struct dhcp *dhcp, struct pbuf *p)
{
    3da4:	defffb04 	addi	sp,sp,-20
    3da8:	dfc00415 	stw	ra,16(sp)
    3dac:	df000315 	stw	fp,12(sp)
    3db0:	df000304 	addi	fp,sp,12
    3db4:	e13ffe15 	stw	r4,-8(fp)
    3db8:	e17fff15 	stw	r5,-4(fp)
  u16_t ret;
  LWIP_ERROR("dhcp != NULL", (dhcp != NULL), return ERR_ARG;);
    3dbc:	e0bffe17 	ldw	r2,-8(fp)
    3dc0:	1000091e 	bne	r2,zero,3de8 <dhcp_unfold_reply+0x44>
    3dc4:	010000f4 	movhi	r4,3
    3dc8:	2137d904 	addi	r4,r4,-8348
    3dcc:	014000f4 	movhi	r5,3
    3dd0:	29784e04 	addi	r5,r5,-7880
    3dd4:	01814404 	movi	r6,1296
    3dd8:	01c000f4 	movhi	r7,3
    3ddc:	39f7e704 	addi	r7,r7,-8292
    3de0:	00170680 	call	17068 <printf>
    3de4:	003fff06 	br	3de4 <dhcp_unfold_reply+0x40>
  /* free any left-overs from previous unfolds */
  dhcp_free_reply(dhcp);
    3de8:	e13ffe17 	ldw	r4,-8(fp)
    3dec:	0003f7c0 	call	3f7c <dhcp_free_reply>
  /* options present? */
  if (p->tot_len > (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN)) {
    3df0:	e0bfff17 	ldw	r2,-4(fp)
    3df4:	1080020b 	ldhu	r2,8(r2)
    3df8:	10bfffcc 	andi	r2,r2,65535
    3dfc:	10803c70 	cmpltui	r2,r2,241
    3e00:	1000141e 	bne	r2,zero,3e54 <dhcp_unfold_reply+0xb0>
    dhcp->options_in_len = p->tot_len - (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
    3e04:	e0bfff17 	ldw	r2,-4(fp)
    3e08:	1080020b 	ldhu	r2,8(r2)
    3e0c:	10bfc404 	addi	r2,r2,-240
    3e10:	1007883a 	mov	r3,r2
    3e14:	e0bffe17 	ldw	r2,-8(fp)
    3e18:	10c0040d 	sth	r3,16(r2)
    dhcp->options_in = mem_malloc(dhcp->options_in_len);
    3e1c:	e0bffe17 	ldw	r2,-8(fp)
    3e20:	1080040b 	ldhu	r2,16(r2)
    3e24:	10bfffcc 	andi	r2,r2,65535
    3e28:	1009883a 	mov	r4,r2
    3e2c:	00088ec0 	call	88ec <mem_malloc>
    3e30:	e0fffe17 	ldw	r3,-8(fp)
    3e34:	18800315 	stw	r2,12(r3)
    if (dhcp->options_in == NULL) {
    3e38:	e0bffe17 	ldw	r2,-8(fp)
    3e3c:	10800317 	ldw	r2,12(r2)
    3e40:	1000041e 	bne	r2,zero,3e54 <dhcp_unfold_reply+0xb0>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
        ("dhcp_unfold_reply(): could not allocate dhcp->options\n"));
      dhcp->options_in_len = 0;
    3e44:	e0bffe17 	ldw	r2,-8(fp)
    3e48:	1000040d 	sth	zero,16(r2)
      return ERR_MEM;
    3e4c:	00bfffc4 	movi	r2,-1
    3e50:	00004506 	br	3f68 <dhcp_unfold_reply+0x1c4>
    }
  }
  dhcp->msg_in = mem_malloc(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
    3e54:	01003c04 	movi	r4,240
    3e58:	00088ec0 	call	88ec <mem_malloc>
    3e5c:	e0fffe17 	ldw	r3,-8(fp)
    3e60:	18800215 	stw	r2,8(r3)
  if (dhcp->msg_in == NULL) {
    3e64:	e0bffe17 	ldw	r2,-8(fp)
    3e68:	10800217 	ldw	r2,8(r2)
    3e6c:	10000d1e 	bne	r2,zero,3ea4 <dhcp_unfold_reply+0x100>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("dhcp_unfold_reply(): could not allocate dhcp->msg_in\n"));
    if (dhcp->options_in != NULL) {
    3e70:	e0bffe17 	ldw	r2,-8(fp)
    3e74:	10800317 	ldw	r2,12(r2)
    3e78:	10000826 	beq	r2,zero,3e9c <dhcp_unfold_reply+0xf8>
      mem_free(dhcp->options_in);
    3e7c:	e0bffe17 	ldw	r2,-8(fp)
    3e80:	10800317 	ldw	r2,12(r2)
    3e84:	1009883a 	mov	r4,r2
    3e88:	00084480 	call	8448 <mem_free>
      dhcp->options_in = NULL;
    3e8c:	e0bffe17 	ldw	r2,-8(fp)
    3e90:	10000315 	stw	zero,12(r2)
      dhcp->options_in_len = 0;
    3e94:	e0bffe17 	ldw	r2,-8(fp)
    3e98:	1000040d 	sth	zero,16(r2)
    }
    return ERR_MEM;
    3e9c:	00bfffc4 	movi	r2,-1
    3ea0:	00003106 	br	3f68 <dhcp_unfold_reply+0x1c4>
  }

  /** copy the DHCP message without options */
  ret = pbuf_copy_partial(p, dhcp->msg_in, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN, 0);
    3ea4:	e0bffe17 	ldw	r2,-8(fp)
    3ea8:	10800217 	ldw	r2,8(r2)
    3eac:	e13fff17 	ldw	r4,-4(fp)
    3eb0:	100b883a 	mov	r5,r2
    3eb4:	01803c04 	movi	r6,240
    3eb8:	000f883a 	mov	r7,zero
    3ebc:	000a9500 	call	a950 <pbuf_copy_partial>
    3ec0:	e0bffd0d 	sth	r2,-12(fp)
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
    3ec4:	e0bffd0b 	ldhu	r2,-12(fp)
    3ec8:	10803c20 	cmpeqi	r2,r2,240
    3ecc:	1000091e 	bne	r2,zero,3ef4 <dhcp_unfold_reply+0x150>
    3ed0:	010000f4 	movhi	r4,3
    3ed4:	2137d904 	addi	r4,r4,-8348
    3ed8:	014000f4 	movhi	r5,3
    3edc:	29785204 	addi	r5,r5,-7864
    3ee0:	01814b04 	movi	r6,1324
    3ee4:	01c000f4 	movhi	r7,3
    3ee8:	39f7e704 	addi	r7,r7,-8292
    3eec:	00170680 	call	17068 <printf>
    3ef0:	003fff06 	br	3ef0 <dhcp_unfold_reply+0x14c>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_unfold_reply(): copied %"U16_F" bytes into dhcp->msg_in[]\n",
     sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN));

  if (dhcp->options_in != NULL) {
    3ef4:	e0bffe17 	ldw	r2,-8(fp)
    3ef8:	10800317 	ldw	r2,12(r2)
    3efc:	10001926 	beq	r2,zero,3f64 <dhcp_unfold_reply+0x1c0>
    /** copy the DHCP options */
    ret = pbuf_copy_partial(p, dhcp->options_in, dhcp->options_in_len, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
    3f00:	e0bffe17 	ldw	r2,-8(fp)
    3f04:	10c00317 	ldw	r3,12(r2)
    3f08:	e0bffe17 	ldw	r2,-8(fp)
    3f0c:	1080040b 	ldhu	r2,16(r2)
    3f10:	10bfffcc 	andi	r2,r2,65535
    3f14:	e13fff17 	ldw	r4,-4(fp)
    3f18:	180b883a 	mov	r5,r3
    3f1c:	100d883a 	mov	r6,r2
    3f20:	01c03c04 	movi	r7,240
    3f24:	000a9500 	call	a950 <pbuf_copy_partial>
    3f28:	e0bffd0d 	sth	r2,-12(fp)
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
    3f2c:	e0bffe17 	ldw	r2,-8(fp)
    3f30:	1080040b 	ldhu	r2,16(r2)
    3f34:	10ffffcc 	andi	r3,r2,65535
    3f38:	e0bffd0b 	ldhu	r2,-12(fp)
    3f3c:	18800926 	beq	r3,r2,3f64 <dhcp_unfold_reply+0x1c0>
    3f40:	010000f4 	movhi	r4,3
    3f44:	2137d904 	addi	r4,r4,-8348
    3f48:	014000f4 	movhi	r5,3
    3f4c:	29785f04 	addi	r5,r5,-7812
    3f50:	01814cc4 	movi	r6,1331
    3f54:	01c000f4 	movhi	r7,3
    3f58:	39f7e704 	addi	r7,r7,-8292
    3f5c:	00170680 	call	17068 <printf>
    3f60:	003fff06 	br	3f60 <dhcp_unfold_reply+0x1bc>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_unfold_reply(): copied %"U16_F" bytes to dhcp->options_in[]\n",
      dhcp->options_in_len));
  }
  LWIP_UNUSED_ARG(ret);
  return ERR_OK;
    3f64:	0005883a 	mov	r2,zero
}
    3f68:	e037883a 	mov	sp,fp
    3f6c:	dfc00117 	ldw	ra,4(sp)
    3f70:	df000017 	ldw	fp,0(sp)
    3f74:	dec00204 	addi	sp,sp,8
    3f78:	f800283a 	ret

00003f7c <dhcp_free_reply>:
/**
 * Free the incoming DHCP message including contiguous copy of
 * its DHCP options.
 */
static void dhcp_free_reply(struct dhcp *dhcp)
{
    3f7c:	defffd04 	addi	sp,sp,-12
    3f80:	dfc00215 	stw	ra,8(sp)
    3f84:	df000115 	stw	fp,4(sp)
    3f88:	df000104 	addi	fp,sp,4
    3f8c:	e13fff15 	stw	r4,-4(fp)
  if (dhcp->msg_in != NULL) {
    3f90:	e0bfff17 	ldw	r2,-4(fp)
    3f94:	10800217 	ldw	r2,8(r2)
    3f98:	10000626 	beq	r2,zero,3fb4 <dhcp_free_reply+0x38>
    mem_free((void *)dhcp->msg_in);
    3f9c:	e0bfff17 	ldw	r2,-4(fp)
    3fa0:	10800217 	ldw	r2,8(r2)
    3fa4:	1009883a 	mov	r4,r2
    3fa8:	00084480 	call	8448 <mem_free>
    dhcp->msg_in = NULL;
    3fac:	e0bfff17 	ldw	r2,-4(fp)
    3fb0:	10000215 	stw	zero,8(r2)
  }
  if (dhcp->options_in) {
    3fb4:	e0bfff17 	ldw	r2,-4(fp)
    3fb8:	10800317 	ldw	r2,12(r2)
    3fbc:	10000826 	beq	r2,zero,3fe0 <dhcp_free_reply+0x64>
    mem_free(dhcp->options_in);
    3fc0:	e0bfff17 	ldw	r2,-4(fp)
    3fc4:	10800317 	ldw	r2,12(r2)
    3fc8:	1009883a 	mov	r4,r2
    3fcc:	00084480 	call	8448 <mem_free>
    dhcp->options_in = NULL;
    3fd0:	e0bfff17 	ldw	r2,-4(fp)
    3fd4:	10000315 	stw	zero,12(r2)
    dhcp->options_in_len = 0;
    3fd8:	e0bfff17 	ldw	r2,-4(fp)
    3fdc:	1000040d 	sth	zero,16(r2)
  }
  LWIP_DEBUGF(DHCP_DEBUG, ("dhcp_free_reply(): free'd\n"));
}
    3fe0:	e037883a 	mov	sp,fp
    3fe4:	dfc00117 	ldw	ra,4(sp)
    3fe8:	df000017 	ldw	fp,0(sp)
    3fec:	dec00204 	addi	sp,sp,8
    3ff0:	f800283a 	ret

00003ff4 <dhcp_recv>:

/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, struct ip_addr *addr, u16_t port)
{
    3ff4:	defff304 	addi	sp,sp,-52
    3ff8:	dfc00c15 	stw	ra,48(sp)
    3ffc:	df000b15 	stw	fp,44(sp)
    4000:	df000b04 	addi	fp,sp,44
    4004:	e13ffb15 	stw	r4,-20(fp)
    4008:	e17ffc15 	stw	r5,-16(fp)
    400c:	e1bffd15 	stw	r6,-12(fp)
    4010:	e1fffe15 	stw	r7,-8(fp)
    4014:	e0800217 	ldw	r2,8(fp)
    4018:	e0bfff0d 	sth	r2,-4(fp)
  struct netif *netif = (struct netif *)arg;
    401c:	e0bffb17 	ldw	r2,-20(fp)
    4020:	e0bff615 	stw	r2,-40(fp)
  struct dhcp *dhcp = netif->dhcp;
    4024:	e0bff617 	ldw	r2,-40(fp)
    4028:	10800817 	ldw	r2,32(r2)
    402c:	e0bff715 	stw	r2,-36(fp)
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
    4030:	e0bffd17 	ldw	r2,-12(fp)
    4034:	10800117 	ldw	r2,4(r2)
    4038:	e0bff815 	stw	r2,-32(fp)
  /* prevent warnings about unused arguments */
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);

  LWIP_ASSERT("reply wasn't freed", dhcp->msg_in == NULL &&
    403c:	e0bff717 	ldw	r2,-36(fp)
    4040:	10800217 	ldw	r2,8(r2)
    4044:	1000071e 	bne	r2,zero,4064 <dhcp_recv+0x70>
    4048:	e0bff717 	ldw	r2,-36(fp)
    404c:	10800317 	ldw	r2,12(r2)
    4050:	1000041e 	bne	r2,zero,4064 <dhcp_recv+0x70>
    4054:	e0bff717 	ldw	r2,-36(fp)
    4058:	1080040b 	ldhu	r2,16(r2)
    405c:	10bfffcc 	andi	r2,r2,65535
    4060:	10000926 	beq	r2,zero,4088 <dhcp_recv+0x94>
    4064:	010000f4 	movhi	r4,3
    4068:	2137d904 	addi	r4,r4,-8348
    406c:	014000f4 	movhi	r5,3
    4070:	2977f304 	addi	r5,r5,-8244
    4074:	018158c4 	movi	r6,1379
    4078:	01c000f4 	movhi	r7,3
    407c:	39f7e704 	addi	r7,r7,-8292
    4080:	00170680 	call	17068 <printf>
    4084:	003fff06 	br	4084 <dhcp_recv+0x90>
    dhcp->options_in == NULL && dhcp->options_in_len == 0);

  if (p->len < DHCP_MIN_REPLY_LEN) {
    4088:	e0bffd17 	ldw	r2,-12(fp)
    408c:	1080028b 	ldhu	r2,10(r2)
    4090:	10bfffcc 	andi	r2,r2,65535
    4094:	10800b28 	cmpgeui	r2,r2,44
    4098:	10009a26 	beq	r2,zero,4304 <dhcp_recv+0x310>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP reply message too short\n"));
    goto free_pbuf_and_return;
  }

  if (reply_msg->op != DHCP_BOOTREPLY) {
    409c:	e0bff817 	ldw	r2,-32(fp)
    40a0:	10800003 	ldbu	r2,0(r2)
    40a4:	10803fcc 	andi	r2,r2,255
    40a8:	108000a0 	cmpeqi	r2,r2,2
    40ac:	10009726 	beq	r2,zero,430c <dhcp_recv+0x318>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
    40b0:	e03ff505 	stb	zero,-44(fp)
    40b4:	00001006 	br	40f8 <dhcp_recv+0x104>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
    40b8:	e0bff503 	ldbu	r2,-44(fp)
    40bc:	e0fff617 	ldw	r3,-40(fp)
    40c0:	1885883a 	add	r2,r3,r2
    40c4:	10800904 	addi	r2,r2,36
    40c8:	10c000c3 	ldbu	r3,3(r2)
    40cc:	e0bff503 	ldbu	r2,-44(fp)
    40d0:	e13ff817 	ldw	r4,-32(fp)
    40d4:	2085883a 	add	r2,r4,r2
    40d8:	10800704 	addi	r2,r2,28
    40dc:	10800003 	ldbu	r2,0(r2)
    40e0:	18c03fcc 	andi	r3,r3,255
    40e4:	10803fcc 	andi	r2,r2,255
    40e8:	18808a1e 	bne	r3,r2,4314 <dhcp_recv+0x320>
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
    40ec:	e0bff503 	ldbu	r2,-44(fp)
    40f0:	10800044 	addi	r2,r2,1
    40f4:	e0bff505 	stb	r2,-44(fp)
    40f8:	e0bff617 	ldw	r2,-40(fp)
    40fc:	10800983 	ldbu	r2,38(r2)
    4100:	10803fcc 	andi	r2,r2,255
    4104:	e0fff503 	ldbu	r3,-44(fp)
    4108:	18bfeb36 	bltu	r3,r2,40b8 <dhcp_recv+0xc4>
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
    }
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
    410c:	e0bff817 	ldw	r2,-32(fp)
    4110:	10c0010b 	ldhu	r3,4(r2)
    4114:	1080018b 	ldhu	r2,6(r2)
    4118:	1004943a 	slli	r2,r2,16
    411c:	10c4b03a 	or	r2,r2,r3
    4120:	1006d63a 	srli	r3,r2,24
    4124:	e0bff817 	ldw	r2,-32(fp)
    4128:	1100010b 	ldhu	r4,4(r2)
    412c:	1080018b 	ldhu	r2,6(r2)
    4130:	1004943a 	slli	r2,r2,16
    4134:	1104b03a 	or	r2,r2,r4
    4138:	1004d23a 	srli	r2,r2,8
    413c:	10bfc00c 	andi	r2,r2,65280
    4140:	1886b03a 	or	r3,r3,r2
    4144:	e0bff817 	ldw	r2,-32(fp)
    4148:	1100010b 	ldhu	r4,4(r2)
    414c:	1080018b 	ldhu	r2,6(r2)
    4150:	1004943a 	slli	r2,r2,16
    4154:	1104b03a 	or	r2,r2,r4
    4158:	10bfc00c 	andi	r2,r2,65280
    415c:	1004923a 	slli	r2,r2,8
    4160:	1886b03a 	or	r3,r3,r2
    4164:	e0bff817 	ldw	r2,-32(fp)
    4168:	1100010b 	ldhu	r4,4(r2)
    416c:	1080018b 	ldhu	r2,6(r2)
    4170:	1004943a 	slli	r2,r2,16
    4174:	1104b03a 	or	r2,r2,r4
    4178:	1004963a 	slli	r2,r2,24
    417c:	1886b03a 	or	r3,r3,r2
    4180:	e0bff717 	ldw	r2,-36(fp)
    4184:	10800017 	ldw	r2,0(r2)
    4188:	1880641e 	bne	r3,r2,431c <dhcp_recv+0x328>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("transaction id mismatch reply_msg->xid(%"X32_F")!=dhcp->xid(%"X32_F")\n",ntohl(reply_msg->xid),dhcp->xid));
    goto free_pbuf_and_return;
  }
  /* option fields could be unfold? */
  if (dhcp_unfold_reply(dhcp, p) != ERR_OK) {
    418c:	e13ff717 	ldw	r4,-36(fp)
    4190:	e17ffd17 	ldw	r5,-12(fp)
    4194:	0003da40 	call	3da4 <dhcp_unfold_reply>
    4198:	10803fcc 	andi	r2,r2,255
    419c:	1080201c 	xori	r2,r2,128
    41a0:	10bfe004 	addi	r2,r2,-128
    41a4:	10005f1e 	bne	r2,zero,4324 <dhcp_recv+0x330>
    goto free_pbuf_and_return;
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
    41a8:	e13ff717 	ldw	r4,-36(fp)
    41ac:	01400d44 	movi	r5,53
    41b0:	0004a900 	call	4a90 <dhcp_get_option_ptr>
    41b4:	e0bff915 	stw	r2,-28(fp)
  if (options_ptr == NULL) {
    41b8:	e0bff917 	ldw	r2,-28(fp)
    41bc:	10005b26 	beq	r2,zero,432c <dhcp_recv+0x338>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
    goto free_pbuf_and_return;
  }

  /* read DHCP message type */
  msg_type = dhcp_get_option_byte(options_ptr + 2);
    41c0:	e0bff917 	ldw	r2,-28(fp)
    41c4:	10800084 	addi	r2,r2,2
    41c8:	1009883a 	mov	r4,r2
    41cc:	0004cc40 	call	4cc4 <dhcp_get_option_byte>
    41d0:	e0bffa05 	stb	r2,-24(fp)
  /* message type is DHCP ACK? */
  if (msg_type == DHCP_ACK) {
    41d4:	e0bffa03 	ldbu	r2,-24(fp)
    41d8:	10800158 	cmpnei	r2,r2,5
    41dc:	1000201e 	bne	r2,zero,4260 <dhcp_recv+0x26c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
    41e0:	e0bff717 	ldw	r2,-36(fp)
    41e4:	10800483 	ldbu	r2,18(r2)
    41e8:	10803fcc 	andi	r2,r2,255
    41ec:	10800058 	cmpnei	r2,r2,1
    41f0:	1000071e 	bne	r2,zero,4210 <dhcp_recv+0x21c>
      dhcp_handle_ack(netif);
    41f4:	e13ff617 	ldw	r4,-40(fp)
    41f8:	00021f80 	call	21f8 <dhcp_handle_ack>
      dhcp->request_timeout = 0;
    41fc:	e0bff717 	ldw	r2,-36(fp)
    4200:	1000078d 	sth	zero,30(r2)
#if DHCP_DOES_ARP_CHECK
      /* check if the acknowledged lease address is already in use */
      dhcp_check(netif);
    4204:	e13ff617 	ldw	r4,-40(fp)
    4208:	0001a040 	call	1a04 <dhcp_check>
    420c:	00004806 	br	4330 <dhcp_recv+0x33c>
      /* bind interface to the acknowledged lease address */
      dhcp_bind(netif);
#endif
    }
    /* already bound to the given lease address? */
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
    4210:	e0bff717 	ldw	r2,-36(fp)
    4214:	10800483 	ldbu	r2,18(r2)
    4218:	10803fcc 	andi	r2,r2,255
    421c:	108000e0 	cmpeqi	r2,r2,3
    4220:	10000a1e 	bne	r2,zero,424c <dhcp_recv+0x258>
    4224:	e0bff717 	ldw	r2,-36(fp)
    4228:	10800483 	ldbu	r2,18(r2)
    422c:	10803fcc 	andi	r2,r2,255
    4230:	10800120 	cmpeqi	r2,r2,4
    4234:	1000051e 	bne	r2,zero,424c <dhcp_recv+0x258>
    4238:	e0bff717 	ldw	r2,-36(fp)
    423c:	10800483 	ldbu	r2,18(r2)
    4240:	10803fcc 	andi	r2,r2,255
    4244:	10800158 	cmpnei	r2,r2,5
    4248:	1000391e 	bne	r2,zero,4330 <dhcp_recv+0x33c>
      dhcp->request_timeout = 0;
    424c:	e0bff717 	ldw	r2,-36(fp)
    4250:	1000078d 	sth	zero,30(r2)
      dhcp_bind(netif);
    4254:	e13ff617 	ldw	r4,-40(fp)
    4258:	0002e900 	call	2e90 <dhcp_bind>
    425c:	00003406 	br	4330 <dhcp_recv+0x33c>
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
    4260:	e0bffa03 	ldbu	r2,-24(fp)
    4264:	10800198 	cmpnei	r2,r2,6
    4268:	1000191e 	bne	r2,zero,42d0 <dhcp_recv+0x2dc>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
    426c:	e0bff717 	ldw	r2,-36(fp)
    4270:	10800483 	ldbu	r2,18(r2)
      dhcp->request_timeout = 0;
      dhcp_bind(netif);
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
    4274:	10803fcc 	andi	r2,r2,255
    4278:	108000e0 	cmpeqi	r2,r2,3
    427c:	10000f1e 	bne	r2,zero,42bc <dhcp_recv+0x2c8>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
    4280:	e0bff717 	ldw	r2,-36(fp)
    4284:	10800483 	ldbu	r2,18(r2)
    4288:	10803fcc 	andi	r2,r2,255
    428c:	10800060 	cmpeqi	r2,r2,1
    4290:	10000a1e 	bne	r2,zero,42bc <dhcp_recv+0x2c8>
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
    4294:	e0bff717 	ldw	r2,-36(fp)
    4298:	10800483 	ldbu	r2,18(r2)
      dhcp_bind(netif);
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
    429c:	10803fcc 	andi	r2,r2,255
    42a0:	10800120 	cmpeqi	r2,r2,4
    42a4:	1000051e 	bne	r2,zero,42bc <dhcp_recv+0x2c8>
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
    42a8:	e0bff717 	ldw	r2,-36(fp)
    42ac:	10800483 	ldbu	r2,18(r2)
    42b0:	10803fcc 	andi	r2,r2,255
    42b4:	10800158 	cmpnei	r2,r2,5
    42b8:	1000051e 	bne	r2,zero,42d0 <dhcp_recv+0x2dc>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
    42bc:	e0bff717 	ldw	r2,-36(fp)
    42c0:	1000078d 	sth	zero,30(r2)
    dhcp_handle_nak(netif);
    42c4:	e13ff617 	ldw	r4,-40(fp)
    42c8:	00019840 	call	1984 <dhcp_handle_nak>
    42cc:	00001806 	br	4330 <dhcp_recv+0x33c>
  }
  /* received a DHCP_OFFER in DHCP_SELECTING state? */
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
    42d0:	e0bffa03 	ldbu	r2,-24(fp)
    42d4:	10800098 	cmpnei	r2,r2,2
    42d8:	1000151e 	bne	r2,zero,4330 <dhcp_recv+0x33c>
    42dc:	e0bff717 	ldw	r2,-36(fp)
    42e0:	10800483 	ldbu	r2,18(r2)
    42e4:	10803fcc 	andi	r2,r2,255
    42e8:	10800198 	cmpnei	r2,r2,6
    42ec:	1000101e 	bne	r2,zero,4330 <dhcp_recv+0x33c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_OFFER received in DHCP_SELECTING state\n"));
    dhcp->request_timeout = 0;
    42f0:	e0bff717 	ldw	r2,-36(fp)
    42f4:	1000078d 	sth	zero,30(r2)
    /* remember offered lease */
    dhcp_handle_offer(netif);
    42f8:	e13ff617 	ldw	r4,-40(fp)
    42fc:	0001a9c0 	call	1a9c <dhcp_handle_offer>
    4300:	00000b06 	br	4330 <dhcp_recv+0x33c>
  LWIP_ASSERT("reply wasn't freed", dhcp->msg_in == NULL &&
    dhcp->options_in == NULL && dhcp->options_in_len == 0);

  if (p->len < DHCP_MIN_REPLY_LEN) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP reply message too short\n"));
    goto free_pbuf_and_return;
    4304:	0001883a 	nop
    4308:	00000906 	br	4330 <dhcp_recv+0x33c>
  }

  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
    430c:	0001883a 	nop
    4310:	00000706 	br	4330 <dhcp_recv+0x33c>
  for (i = 0; i < netif->hwaddr_len; i++) {
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
        ("netif->hwaddr[%"U16_F"]==%02"X16_F" != reply_msg->chaddr[%"U16_F"]==%02"X16_F"\n",
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
    4314:	0001883a 	nop
    4318:	00000506 	br	4330 <dhcp_recv+0x33c>
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("transaction id mismatch reply_msg->xid(%"X32_F")!=dhcp->xid(%"X32_F")\n",ntohl(reply_msg->xid),dhcp->xid));
    goto free_pbuf_and_return;
    431c:	0001883a 	nop
    4320:	00000306 	br	4330 <dhcp_recv+0x33c>
  }
  /* option fields could be unfold? */
  if (dhcp_unfold_reply(dhcp, p) != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("problem unfolding DHCP message - too short on memory?\n"));
    goto free_pbuf_and_return;
    4324:	0001883a 	nop
    4328:	00000106 	br	4330 <dhcp_recv+0x33c>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
  if (options_ptr == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
    goto free_pbuf_and_return;
    432c:	0001883a 	nop
    dhcp->request_timeout = 0;
    /* remember offered lease */
    dhcp_handle_offer(netif);
  }
free_pbuf_and_return:
  dhcp_free_reply(dhcp);
    4330:	e13ff717 	ldw	r4,-36(fp)
    4334:	0003f7c0 	call	3f7c <dhcp_free_reply>
  pbuf_free(p);
    4338:	e13ffd17 	ldw	r4,-12(fp)
    433c:	000a1880 	call	a188 <pbuf_free>
}
    4340:	e037883a 	mov	sp,fp
    4344:	dfc00117 	ldw	ra,4(sp)
    4348:	df000017 	ldw	fp,0(sp)
    434c:	dec00204 	addi	sp,sp,8
    4350:	f800283a 	ret

00004354 <dhcp_create_request>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_create_request(struct netif *netif)
{
    4354:	defffb04 	addi	sp,sp,-20
    4358:	dfc00415 	stw	ra,16(sp)
    435c:	df000315 	stw	fp,12(sp)
    4360:	df000304 	addi	fp,sp,12
    4364:	e13fff15 	stw	r4,-4(fp)
  if (!xid_initialised) {
    xid = DHCP_GLOBAL_XID;
    xid_initialised = !xid_initialised;
  }
#endif
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
    4368:	e0bfff17 	ldw	r2,-4(fp)
    436c:	1000091e 	bne	r2,zero,4394 <dhcp_create_request+0x40>
    4370:	010000f4 	movhi	r4,3
    4374:	2137d904 	addi	r4,r4,-8348
    4378:	014000f4 	movhi	r5,3
    437c:	29786604 	addi	r5,r5,-7784
    4380:	018173c4 	movi	r6,1487
    4384:	01c000f4 	movhi	r7,3
    4388:	39f7e704 	addi	r7,r7,-8292
    438c:	00170680 	call	17068 <printf>
    4390:	003fff06 	br	4390 <dhcp_create_request+0x3c>
  dhcp = netif->dhcp;
    4394:	e0bfff17 	ldw	r2,-4(fp)
    4398:	10800817 	ldw	r2,32(r2)
    439c:	e0bffe15 	stw	r2,-8(fp)
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
    43a0:	e0bffe17 	ldw	r2,-8(fp)
    43a4:	1000091e 	bne	r2,zero,43cc <dhcp_create_request+0x78>
    43a8:	010000f4 	movhi	r4,3
    43ac:	2137d904 	addi	r4,r4,-8348
    43b0:	014000f4 	movhi	r5,3
    43b4:	29786f04 	addi	r5,r5,-7748
    43b8:	01817444 	movi	r6,1489
    43bc:	01c000f4 	movhi	r7,3
    43c0:	39f7e704 	addi	r7,r7,-8292
    43c4:	00170680 	call	17068 <printf>
    43c8:	003fff06 	br	43c8 <dhcp_create_request+0x74>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
    43cc:	e0bffe17 	ldw	r2,-8(fp)
    43d0:	10800517 	ldw	r2,20(r2)
    43d4:	10000926 	beq	r2,zero,43fc <dhcp_create_request+0xa8>
    43d8:	010000f4 	movhi	r4,3
    43dc:	2137d904 	addi	r4,r4,-8348
    43e0:	014000f4 	movhi	r5,3
    43e4:	29787804 	addi	r5,r5,-7712
    43e8:	01817484 	movi	r6,1490
    43ec:	01c000f4 	movhi	r7,3
    43f0:	39f7e704 	addi	r7,r7,-8292
    43f4:	00170680 	call	17068 <printf>
    43f8:	003fff06 	br	43f8 <dhcp_create_request+0xa4>
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
    43fc:	e0bffe17 	ldw	r2,-8(fp)
    4400:	10800617 	ldw	r2,24(r2)
    4404:	10000926 	beq	r2,zero,442c <dhcp_create_request+0xd8>
    4408:	010000f4 	movhi	r4,3
    440c:	2137d904 	addi	r4,r4,-8348
    4410:	014000f4 	movhi	r5,3
    4414:	29788304 	addi	r5,r5,-7668
    4418:	018174c4 	movi	r6,1491
    441c:	01c000f4 	movhi	r7,3
    4420:	39f7e704 	addi	r7,r7,-8292
    4424:	00170680 	call	17068 <printf>
    4428:	003fff06 	br	4428 <dhcp_create_request+0xd4>
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
    442c:	0009883a 	mov	r4,zero
    4430:	01404d04 	movi	r5,308
    4434:	000d883a 	mov	r6,zero
    4438:	00097cc0 	call	97cc <pbuf_alloc>
    443c:	e0fffe17 	ldw	r3,-8(fp)
    4440:	18800515 	stw	r2,20(r3)
  if (dhcp->p_out == NULL) {
    4444:	e0bffe17 	ldw	r2,-8(fp)
    4448:	10800517 	ldw	r2,20(r2)
    444c:	1000021e 	bne	r2,zero,4458 <dhcp_create_request+0x104>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("dhcp_create_request(): could not allocate pbuf\n"));
    return ERR_MEM;
    4450:	00bfffc4 	movi	r2,-1
    4454:	0000e206 	br	47e0 <dhcp_create_request+0x48c>
  }
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
    4458:	e0bffe17 	ldw	r2,-8(fp)
    445c:	10800517 	ldw	r2,20(r2)
    4460:	1080028b 	ldhu	r2,10(r2)
    4464:	10bfffcc 	andi	r2,r2,65535
    4468:	10804d28 	cmpgeui	r2,r2,308
    446c:	1000091e 	bne	r2,zero,4494 <dhcp_create_request+0x140>
    4470:	010000f4 	movhi	r4,3
    4474:	2137d904 	addi	r4,r4,-8348
    4478:	014000f4 	movhi	r5,3
    447c:	29788e04 	addi	r5,r5,-7624
    4480:	018176c4 	movi	r6,1499
    4484:	01c000f4 	movhi	r7,3
    4488:	39f7e704 	addi	r7,r7,-8292
    448c:	00170680 	call	17068 <printf>
    4490:	003fff06 	br	4490 <dhcp_create_request+0x13c>
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* reuse transaction identifier in retransmissions */
  if (dhcp->tries==0)
    4494:	e0bffe17 	ldw	r2,-8(fp)
    4498:	108004c3 	ldbu	r2,19(r2)
    449c:	10803fcc 	andi	r2,r2,255
    44a0:	1000031e 	bne	r2,zero,44b0 <dhcp_create_request+0x15c>
      xid++;
    44a4:	d0a00017 	ldw	r2,-32768(gp)
    44a8:	10800044 	addi	r2,r2,1
    44ac:	d0a00015 	stw	r2,-32768(gp)
  dhcp->xid = xid;
    44b0:	d0e00017 	ldw	r3,-32768(gp)
    44b4:	e0bffe17 	ldw	r2,-8(fp)
    44b8:	10c00015 	stw	r3,0(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
              ("transaction id xid(%"X32_F")\n", xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
    44bc:	e0bffe17 	ldw	r2,-8(fp)
    44c0:	10800517 	ldw	r2,20(r2)
    44c4:	10c00117 	ldw	r3,4(r2)
    44c8:	e0bffe17 	ldw	r2,-8(fp)
    44cc:	10c00615 	stw	r3,24(r2)

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
    44d0:	e0bffe17 	ldw	r2,-8(fp)
    44d4:	10800617 	ldw	r2,24(r2)
    44d8:	00c00044 	movi	r3,1
    44dc:	10c00005 	stb	r3,0(r2)
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
    44e0:	e0bffe17 	ldw	r2,-8(fp)
    44e4:	10800617 	ldw	r2,24(r2)
    44e8:	00c00044 	movi	r3,1
    44ec:	10c00045 	stb	r3,1(r2)
  /* TODO: make link layer independent */
  dhcp->msg_out->hlen = DHCP_HLEN_ETH;
    44f0:	e0bffe17 	ldw	r2,-8(fp)
    44f4:	10800617 	ldw	r2,24(r2)
    44f8:	00c00184 	movi	r3,6
    44fc:	10c00085 	stb	r3,2(r2)
  dhcp->msg_out->hops = 0;
    4500:	e0bffe17 	ldw	r2,-8(fp)
    4504:	10800617 	ldw	r2,24(r2)
    4508:	100000c5 	stb	zero,3(r2)
  dhcp->msg_out->xid = htonl(dhcp->xid);
    450c:	e0bffe17 	ldw	r2,-8(fp)
    4510:	10800617 	ldw	r2,24(r2)
    4514:	e0fffe17 	ldw	r3,-8(fp)
    4518:	18c00017 	ldw	r3,0(r3)
    451c:	1808d63a 	srli	r4,r3,24
    4520:	e0fffe17 	ldw	r3,-8(fp)
    4524:	18c00017 	ldw	r3,0(r3)
    4528:	1806d23a 	srli	r3,r3,8
    452c:	18ffc00c 	andi	r3,r3,65280
    4530:	20c8b03a 	or	r4,r4,r3
    4534:	e0fffe17 	ldw	r3,-8(fp)
    4538:	18c00017 	ldw	r3,0(r3)
    453c:	18ffc00c 	andi	r3,r3,65280
    4540:	1806923a 	slli	r3,r3,8
    4544:	20c8b03a 	or	r4,r4,r3
    4548:	e0fffe17 	ldw	r3,-8(fp)
    454c:	18c00017 	ldw	r3,0(r3)
    4550:	1806963a 	slli	r3,r3,24
    4554:	20c6b03a 	or	r3,r4,r3
    4558:	193fffcc 	andi	r4,r3,65535
    455c:	1140010b 	ldhu	r5,4(r2)
    4560:	280a703a 	and	r5,r5,zero
    4564:	2908b03a 	or	r4,r5,r4
    4568:	1100010d 	sth	r4,4(r2)
    456c:	1806d43a 	srli	r3,r3,16
    4570:	1100018b 	ldhu	r4,6(r2)
    4574:	2008703a 	and	r4,r4,zero
    4578:	20c6b03a 	or	r3,r4,r3
    457c:	10c0018d 	sth	r3,6(r2)
  dhcp->msg_out->secs = 0;
    4580:	e0bffe17 	ldw	r2,-8(fp)
    4584:	10800617 	ldw	r2,24(r2)
    4588:	1000020d 	sth	zero,8(r2)
  dhcp->msg_out->flags = 0;
    458c:	e0bffe17 	ldw	r2,-8(fp)
    4590:	10800617 	ldw	r2,24(r2)
    4594:	1000028d 	sth	zero,10(r2)
  dhcp->msg_out->ciaddr.addr = 0;
    4598:	e0bffe17 	ldw	r2,-8(fp)
    459c:	10800617 	ldw	r2,24(r2)
    45a0:	10c0030b 	ldhu	r3,12(r2)
    45a4:	1806703a 	and	r3,r3,zero
    45a8:	10c0030d 	sth	r3,12(r2)
    45ac:	10c0038b 	ldhu	r3,14(r2)
    45b0:	1806703a 	and	r3,r3,zero
    45b4:	10c0038d 	sth	r3,14(r2)
  if (dhcp->state==DHCP_BOUND || dhcp->state==DHCP_RENEWING || dhcp->state==DHCP_REBINDING) {
    45b8:	e0bffe17 	ldw	r2,-8(fp)
    45bc:	10800483 	ldbu	r2,18(r2)
    45c0:	10803fcc 	andi	r2,r2,255
    45c4:	108002a0 	cmpeqi	r2,r2,10
    45c8:	10000a1e 	bne	r2,zero,45f4 <dhcp_create_request+0x2a0>
    45cc:	e0bffe17 	ldw	r2,-8(fp)
    45d0:	10800483 	ldbu	r2,18(r2)
    45d4:	10803fcc 	andi	r2,r2,255
    45d8:	10800160 	cmpeqi	r2,r2,5
    45dc:	1000051e 	bne	r2,zero,45f4 <dhcp_create_request+0x2a0>
    45e0:	e0bffe17 	ldw	r2,-8(fp)
    45e4:	10800483 	ldbu	r2,18(r2)
    45e8:	10803fcc 	andi	r2,r2,255
    45ec:	10800118 	cmpnei	r2,r2,4
    45f0:	10000e1e 	bne	r2,zero,462c <dhcp_create_request+0x2d8>
    dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
    45f4:	e0bffe17 	ldw	r2,-8(fp)
    45f8:	10800617 	ldw	r2,24(r2)
    45fc:	e0ffff17 	ldw	r3,-4(fp)
    4600:	18c00117 	ldw	r3,4(r3)
    4604:	193fffcc 	andi	r4,r3,65535
    4608:	1140030b 	ldhu	r5,12(r2)
    460c:	280a703a 	and	r5,r5,zero
    4610:	2908b03a 	or	r4,r5,r4
    4614:	1100030d 	sth	r4,12(r2)
    4618:	1806d43a 	srli	r3,r3,16
    461c:	1100038b 	ldhu	r4,14(r2)
    4620:	2008703a 	and	r4,r4,zero
    4624:	20c6b03a 	or	r3,r4,r3
    4628:	10c0038d 	sth	r3,14(r2)
  }
  dhcp->msg_out->yiaddr.addr = 0;
    462c:	e0bffe17 	ldw	r2,-8(fp)
    4630:	10800617 	ldw	r2,24(r2)
    4634:	10c0040b 	ldhu	r3,16(r2)
    4638:	1806703a 	and	r3,r3,zero
    463c:	10c0040d 	sth	r3,16(r2)
    4640:	10c0048b 	ldhu	r3,18(r2)
    4644:	1806703a 	and	r3,r3,zero
    4648:	10c0048d 	sth	r3,18(r2)
  dhcp->msg_out->siaddr.addr = 0;
    464c:	e0bffe17 	ldw	r2,-8(fp)
    4650:	10800617 	ldw	r2,24(r2)
    4654:	10c0050b 	ldhu	r3,20(r2)
    4658:	1806703a 	and	r3,r3,zero
    465c:	10c0050d 	sth	r3,20(r2)
    4660:	10c0058b 	ldhu	r3,22(r2)
    4664:	1806703a 	and	r3,r3,zero
    4668:	10c0058d 	sth	r3,22(r2)
  dhcp->msg_out->giaddr.addr = 0;
    466c:	e0bffe17 	ldw	r2,-8(fp)
    4670:	10800617 	ldw	r2,24(r2)
    4674:	10c0060b 	ldhu	r3,24(r2)
    4678:	1806703a 	and	r3,r3,zero
    467c:	10c0060d 	sth	r3,24(r2)
    4680:	10c0068b 	ldhu	r3,26(r2)
    4684:	1806703a 	and	r3,r3,zero
    4688:	10c0068d 	sth	r3,26(r2)
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    468c:	e03ffd0d 	sth	zero,-12(fp)
    4690:	00001606 	br	46ec <dhcp_create_request+0x398>
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
    4694:	e0bffe17 	ldw	r2,-8(fp)
    4698:	11000617 	ldw	r4,24(r2)
    469c:	e0fffd0b 	ldhu	r3,-12(fp)
    46a0:	e0bfff17 	ldw	r2,-4(fp)
    46a4:	10800983 	ldbu	r2,38(r2)
    46a8:	10803fcc 	andi	r2,r2,255
    46ac:	10bfffcc 	andi	r2,r2,65535
    46b0:	e17ffd0b 	ldhu	r5,-12(fp)
    46b4:	2880062e 	bgeu	r5,r2,46d0 <dhcp_create_request+0x37c>
    46b8:	e0bffd0b 	ldhu	r2,-12(fp)
    46bc:	e17fff17 	ldw	r5,-4(fp)
    46c0:	2885883a 	add	r2,r5,r2
    46c4:	10800904 	addi	r2,r2,36
    46c8:	108000c3 	ldbu	r2,3(r2)
    46cc:	00000106 	br	46d4 <dhcp_create_request+0x380>
    46d0:	0005883a 	mov	r2,zero
    46d4:	20c7883a 	add	r3,r4,r3
    46d8:	18c00704 	addi	r3,r3,28
    46dc:	18800005 	stb	r2,0(r3)
    dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  }
  dhcp->msg_out->yiaddr.addr = 0;
  dhcp->msg_out->siaddr.addr = 0;
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    46e0:	e0bffd0b 	ldhu	r2,-12(fp)
    46e4:	10800044 	addi	r2,r2,1
    46e8:	e0bffd0d 	sth	r2,-12(fp)
    46ec:	e0bffd0b 	ldhu	r2,-12(fp)
    46f0:	10800430 	cmpltui	r2,r2,16
    46f4:	103fe71e 	bne	r2,zero,4694 <dhcp_create_request+0x340>
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    46f8:	e03ffd0d 	sth	zero,-12(fp)
    46fc:	00000906 	br	4724 <dhcp_create_request+0x3d0>
    dhcp->msg_out->sname[i] = 0;
    4700:	e0bffe17 	ldw	r2,-8(fp)
    4704:	10c00617 	ldw	r3,24(r2)
    4708:	e0bffd0b 	ldhu	r2,-12(fp)
    470c:	1885883a 	add	r2,r3,r2
    4710:	10800b04 	addi	r2,r2,44
    4714:	10000005 	stb	zero,0(r2)
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    4718:	e0bffd0b 	ldhu	r2,-12(fp)
    471c:	10800044 	addi	r2,r2,1
    4720:	e0bffd0d 	sth	r2,-12(fp)
    4724:	e0bffd0b 	ldhu	r2,-12(fp)
    4728:	10801030 	cmpltui	r2,r2,64
    472c:	103ff41e 	bne	r2,zero,4700 <dhcp_create_request+0x3ac>
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
    4730:	e03ffd0d 	sth	zero,-12(fp)
    4734:	00000906 	br	475c <dhcp_create_request+0x408>
    dhcp->msg_out->file[i] = 0;
    4738:	e0bffe17 	ldw	r2,-8(fp)
    473c:	10c00617 	ldw	r3,24(r2)
    4740:	e0bffd0b 	ldhu	r2,-12(fp)
    4744:	1885883a 	add	r2,r3,r2
    4748:	10801b04 	addi	r2,r2,108
    474c:	10000005 	stb	zero,0(r2)
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
    4750:	e0bffd0b 	ldhu	r2,-12(fp)
    4754:	10800044 	addi	r2,r2,1
    4758:	e0bffd0d 	sth	r2,-12(fp)
    475c:	e0bffd0b 	ldhu	r2,-12(fp)
    4760:	10802030 	cmpltui	r2,r2,128
    4764:	103ff41e 	bne	r2,zero,4738 <dhcp_create_request+0x3e4>
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
    4768:	e0bffe17 	ldw	r2,-8(fp)
    476c:	10800617 	ldw	r2,24(r2)
    4770:	10c03b0b 	ldhu	r3,236(r2)
    4774:	1806703a 	and	r3,r3,zero
    4778:	1809883a 	mov	r4,r3
    477c:	00e098c4 	movi	r3,-32157
    4780:	20c6b03a 	or	r3,r4,r3
    4784:	10c03b0d 	sth	r3,236(r2)
    4788:	10c03b8b 	ldhu	r3,238(r2)
    478c:	1806703a 	and	r3,r3,zero
    4790:	18d8d4d4 	ori	r3,r3,25427
    4794:	10c03b8d 	sth	r3,238(r2)
  dhcp->options_out_len = 0;
    4798:	e0bffe17 	ldw	r2,-8(fp)
    479c:	1000070d 	sth	zero,28(r2)
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    47a0:	e03ffd0d 	sth	zero,-12(fp)
    47a4:	00000a06 	br	47d0 <dhcp_create_request+0x47c>
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
    47a8:	e0bffe17 	ldw	r2,-8(fp)
    47ac:	11000617 	ldw	r4,24(r2)
    47b0:	e0bffd0b 	ldhu	r2,-12(fp)
    47b4:	e0fffd0b 	ldhu	r3,-12(fp)
    47b8:	2085883a 	add	r2,r4,r2
    47bc:	10803c04 	addi	r2,r2,240
    47c0:	10c00005 	stb	r3,0(r2)
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  dhcp->options_out_len = 0;
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    47c4:	e0bffd0b 	ldhu	r2,-12(fp)
    47c8:	10800044 	addi	r2,r2,1
    47cc:	e0bffd0d 	sth	r2,-12(fp)
    47d0:	e0bffd0b 	ldhu	r2,-12(fp)
    47d4:	10801130 	cmpltui	r2,r2,68
    47d8:	103ff31e 	bne	r2,zero,47a8 <dhcp_create_request+0x454>
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  }
  return ERR_OK;
    47dc:	0005883a 	mov	r2,zero
}
    47e0:	e037883a 	mov	sp,fp
    47e4:	dfc00117 	ldw	ra,4(sp)
    47e8:	df000017 	ldw	fp,0(sp)
    47ec:	dec00204 	addi	sp,sp,8
    47f0:	f800283a 	ret

000047f4 <dhcp_delete_request>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_delete_request(struct netif *netif)
{
    47f4:	defffc04 	addi	sp,sp,-16
    47f8:	dfc00315 	stw	ra,12(sp)
    47fc:	df000215 	stw	fp,8(sp)
    4800:	df000204 	addi	fp,sp,8
    4804:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp;
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
    4808:	e0bfff17 	ldw	r2,-4(fp)
    480c:	1000091e 	bne	r2,zero,4834 <dhcp_delete_request+0x40>
    4810:	010000f4 	movhi	r4,3
    4814:	2137d904 	addi	r4,r4,-8348
    4818:	014000f4 	movhi	r5,3
    481c:	29789f04 	addi	r5,r5,-7556
    4820:	01818484 	movi	r6,1554
    4824:	01c000f4 	movhi	r7,3
    4828:	39f7e704 	addi	r7,r7,-8292
    482c:	00170680 	call	17068 <printf>
    4830:	003fff06 	br	4830 <dhcp_delete_request+0x3c>
  dhcp = netif->dhcp;
    4834:	e0bfff17 	ldw	r2,-4(fp)
    4838:	10800817 	ldw	r2,32(r2)
    483c:	e0bffe15 	stw	r2,-8(fp)
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
    4840:	e0bffe17 	ldw	r2,-8(fp)
    4844:	1000091e 	bne	r2,zero,486c <dhcp_delete_request+0x78>
    4848:	010000f4 	movhi	r4,3
    484c:	2137d904 	addi	r4,r4,-8348
    4850:	014000f4 	movhi	r5,3
    4854:	2978a804 	addi	r5,r5,-7520
    4858:	01818504 	movi	r6,1556
    485c:	01c000f4 	movhi	r7,3
    4860:	39f7e704 	addi	r7,r7,-8292
    4864:	00170680 	call	17068 <printf>
    4868:	003fff06 	br	4868 <dhcp_delete_request+0x74>
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
    486c:	e0bffe17 	ldw	r2,-8(fp)
    4870:	10800517 	ldw	r2,20(r2)
    4874:	1000091e 	bne	r2,zero,489c <dhcp_delete_request+0xa8>
    4878:	010000f4 	movhi	r4,3
    487c:	2137d904 	addi	r4,r4,-8348
    4880:	014000f4 	movhi	r5,3
    4884:	2978b104 	addi	r5,r5,-7484
    4888:	01818544 	movi	r6,1557
    488c:	01c000f4 	movhi	r7,3
    4890:	39f7e704 	addi	r7,r7,-8292
    4894:	00170680 	call	17068 <printf>
    4898:	003fff06 	br	4898 <dhcp_delete_request+0xa4>
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
    489c:	e0bffe17 	ldw	r2,-8(fp)
    48a0:	10800617 	ldw	r2,24(r2)
    48a4:	1000091e 	bne	r2,zero,48cc <dhcp_delete_request+0xd8>
    48a8:	010000f4 	movhi	r4,3
    48ac:	2137d904 	addi	r4,r4,-8348
    48b0:	014000f4 	movhi	r5,3
    48b4:	2978bc04 	addi	r5,r5,-7440
    48b8:	01818584 	movi	r6,1558
    48bc:	01c000f4 	movhi	r7,3
    48c0:	39f7e704 	addi	r7,r7,-8292
    48c4:	00170680 	call	17068 <printf>
    48c8:	003fff06 	br	48c8 <dhcp_delete_request+0xd4>
  if (dhcp->p_out != NULL) {
    48cc:	e0bffe17 	ldw	r2,-8(fp)
    48d0:	10800517 	ldw	r2,20(r2)
    48d4:	10000426 	beq	r2,zero,48e8 <dhcp_delete_request+0xf4>
    pbuf_free(dhcp->p_out);
    48d8:	e0bffe17 	ldw	r2,-8(fp)
    48dc:	10800517 	ldw	r2,20(r2)
    48e0:	1009883a 	mov	r4,r2
    48e4:	000a1880 	call	a188 <pbuf_free>
  }
  dhcp->p_out = NULL;
    48e8:	e0bffe17 	ldw	r2,-8(fp)
    48ec:	10000515 	stw	zero,20(r2)
  dhcp->msg_out = NULL;
    48f0:	e0bffe17 	ldw	r2,-8(fp)
    48f4:	10000615 	stw	zero,24(r2)
}
    48f8:	e037883a 	mov	sp,fp
    48fc:	dfc00117 	ldw	ra,4(sp)
    4900:	df000017 	ldw	fp,0(sp)
    4904:	dec00204 	addi	sp,sp,8
    4908:	f800283a 	ret

0000490c <dhcp_option_trailer>:
 *
 * @param dhcp DHCP state structure
 */
static void
dhcp_option_trailer(struct dhcp *dhcp)
{
    490c:	defffd04 	addi	sp,sp,-12
    4910:	dfc00215 	stw	ra,8(sp)
    4914:	df000115 	stw	fp,4(sp)
    4918:	df000104 	addi	fp,sp,4
    491c:	e13fff15 	stw	r4,-4(fp)
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
    4920:	e0bfff17 	ldw	r2,-4(fp)
    4924:	1000091e 	bne	r2,zero,494c <dhcp_option_trailer+0x40>
    4928:	010000f4 	movhi	r4,3
    492c:	2137d904 	addi	r4,r4,-8348
    4930:	014000f4 	movhi	r5,3
    4934:	2978c704 	addi	r5,r5,-7396
    4938:	01818a44 	movi	r6,1577
    493c:	01c000f4 	movhi	r7,3
    4940:	39f7e704 	addi	r7,r7,-8292
    4944:	00170680 	call	17068 <printf>
    4948:	003fff06 	br	4948 <dhcp_option_trailer+0x3c>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
    494c:	e0bfff17 	ldw	r2,-4(fp)
    4950:	10800617 	ldw	r2,24(r2)
    4954:	1000091e 	bne	r2,zero,497c <dhcp_option_trailer+0x70>
    4958:	010000f4 	movhi	r4,3
    495c:	2137d904 	addi	r4,r4,-8348
    4960:	014000f4 	movhi	r5,3
    4964:	2978d004 	addi	r5,r5,-7360
    4968:	01818a84 	movi	r6,1578
    496c:	01c000f4 	movhi	r7,3
    4970:	39f7e704 	addi	r7,r7,-8292
    4974:	00170680 	call	17068 <printf>
    4978:	003fff06 	br	4978 <dhcp_option_trailer+0x6c>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
    497c:	e0bfff17 	ldw	r2,-4(fp)
    4980:	1080070b 	ldhu	r2,28(r2)
    4984:	10bfffcc 	andi	r2,r2,65535
    4988:	10801130 	cmpltui	r2,r2,68
    498c:	1000091e 	bne	r2,zero,49b4 <dhcp_option_trailer+0xa8>
    4990:	010000f4 	movhi	r4,3
    4994:	2137d904 	addi	r4,r4,-8348
    4998:	014000f4 	movhi	r5,3
    499c:	2978db04 	addi	r5,r5,-7316
    49a0:	01818ac4 	movi	r6,1579
    49a4:	01c000f4 	movhi	r7,3
    49a8:	39f7e704 	addi	r7,r7,-8292
    49ac:	00170680 	call	17068 <printf>
    49b0:	003fff06 	br	49b0 <dhcp_option_trailer+0xa4>
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
    49b4:	e0bfff17 	ldw	r2,-4(fp)
    49b8:	11000617 	ldw	r4,24(r2)
    49bc:	e0bfff17 	ldw	r2,-4(fp)
    49c0:	1080070b 	ldhu	r2,28(r2)
    49c4:	10ffffcc 	andi	r3,r2,65535
    49c8:	20c7883a 	add	r3,r4,r3
    49cc:	18c03c04 	addi	r3,r3,240
    49d0:	013fffc4 	movi	r4,-1
    49d4:	19000005 	stb	r4,0(r3)
    49d8:	10800044 	addi	r2,r2,1
    49dc:	1007883a 	mov	r3,r2
    49e0:	e0bfff17 	ldw	r2,-4(fp)
    49e4:	10c0070d 	sth	r3,28(r2)
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
    49e8:	00001a06 	br	4a54 <dhcp_option_trailer+0x148>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
    49ec:	e0bfff17 	ldw	r2,-4(fp)
    49f0:	1080070b 	ldhu	r2,28(r2)
    49f4:	10bfffcc 	andi	r2,r2,65535
    49f8:	10801130 	cmpltui	r2,r2,68
    49fc:	1000091e 	bne	r2,zero,4a24 <dhcp_option_trailer+0x118>
    4a00:	010000f4 	movhi	r4,3
    4a04:	2137d904 	addi	r4,r4,-8348
    4a08:	014000f4 	movhi	r5,3
    4a0c:	2978db04 	addi	r5,r5,-7316
    4a10:	01818c04 	movi	r6,1584
    4a14:	01c000f4 	movhi	r7,3
    4a18:	39f7e704 	addi	r7,r7,-8292
    4a1c:	00170680 	call	17068 <printf>
    4a20:	003fff06 	br	4a20 <dhcp_option_trailer+0x114>
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
    4a24:	e0bfff17 	ldw	r2,-4(fp)
    4a28:	11000617 	ldw	r4,24(r2)
    4a2c:	e0bfff17 	ldw	r2,-4(fp)
    4a30:	1080070b 	ldhu	r2,28(r2)
    4a34:	10ffffcc 	andi	r3,r2,65535
    4a38:	20c7883a 	add	r3,r4,r3
    4a3c:	18c03c04 	addi	r3,r3,240
    4a40:	18000005 	stb	zero,0(r3)
    4a44:	10800044 	addi	r2,r2,1
    4a48:	1007883a 	mov	r3,r2
    4a4c:	e0bfff17 	ldw	r2,-4(fp)
    4a50:	10c0070d 	sth	r3,28(r2)
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
    4a54:	e0bfff17 	ldw	r2,-4(fp)
    4a58:	1080070b 	ldhu	r2,28(r2)
    4a5c:	10bfffcc 	andi	r2,r2,65535
    4a60:	10801130 	cmpltui	r2,r2,68
    4a64:	103fe11e 	bne	r2,zero,49ec <dhcp_option_trailer+0xe0>
    4a68:	e0bfff17 	ldw	r2,-4(fp)
    4a6c:	1080070b 	ldhu	r2,28(r2)
    4a70:	10bfffcc 	andi	r2,r2,65535
    4a74:	108000cc 	andi	r2,r2,3
    4a78:	103fdc1e 	bne	r2,zero,49ec <dhcp_option_trailer+0xe0>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  }
}
    4a7c:	e037883a 	mov	sp,fp
    4a80:	dfc00117 	ldw	ra,4(sp)
    4a84:	df000017 	ldw	fp,0(sp)
    4a88:	dec00204 	addi	sp,sp,8
    4a8c:	f800283a 	ret

00004a90 <dhcp_get_option_ptr>:
 *
 * @return a byte offset into the UDP message where the option was found, or
 * zero if the given option was not found.
 */
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
    4a90:	defffa04 	addi	sp,sp,-24
    4a94:	df000515 	stw	fp,20(sp)
    4a98:	df000504 	addi	fp,sp,20
    4a9c:	e13ffe15 	stw	r4,-8(fp)
    4aa0:	2805883a 	mov	r2,r5
    4aa4:	e0bfff05 	stb	r2,-4(fp)
  u8_t overload = DHCP_OVERLOAD_NONE;
    4aa8:	e03ffb05 	stb	zero,-20(fp)

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
    4aac:	e0bffe17 	ldw	r2,-8(fp)
    4ab0:	10800317 	ldw	r2,12(r2)
    4ab4:	10007e26 	beq	r2,zero,4cb0 <dhcp_get_option_ptr+0x220>
    4ab8:	e0bffe17 	ldw	r2,-8(fp)
    4abc:	1080040b 	ldhu	r2,16(r2)
    4ac0:	10bfffcc 	andi	r2,r2,65535
    4ac4:	10007a26 	beq	r2,zero,4cb0 <dhcp_get_option_ptr+0x220>
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    4ac8:	e0bffe17 	ldw	r2,-8(fp)
    4acc:	10800317 	ldw	r2,12(r2)
    4ad0:	e0bffc15 	stw	r2,-16(fp)
    u16_t offset = 0;
    4ad4:	e03ffd0d 	sth	zero,-12(fp)
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
    4ad8:	00002a06 	br	4b84 <dhcp_get_option_ptr+0xf4>
      /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
      /* are the sname and/or file field overloaded with options? */
      if (options[offset] == DHCP_OPTION_OVERLOAD) {
    4adc:	e0bffd0b 	ldhu	r2,-12(fp)
    4ae0:	e0fffc17 	ldw	r3,-16(fp)
    4ae4:	1885883a 	add	r2,r3,r2
    4ae8:	10800003 	ldbu	r2,0(r2)
    4aec:	10803fcc 	andi	r2,r2,255
    4af0:	10800d18 	cmpnei	r2,r2,52
    4af4:	10000c1e 	bne	r2,zero,4b28 <dhcp_get_option_ptr+0x98>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded message detected\n"));
        /* skip option type and length */
        offset += 2;
    4af8:	e0bffd0b 	ldhu	r2,-12(fp)
    4afc:	10800084 	addi	r2,r2,2
    4b00:	e0bffd0d 	sth	r2,-12(fp)
        overload = options[offset++];
    4b04:	e0bffd0b 	ldhu	r2,-12(fp)
    4b08:	e0fffc17 	ldw	r3,-16(fp)
    4b0c:	1885883a 	add	r2,r3,r2
    4b10:	10800003 	ldbu	r2,0(r2)
    4b14:	e0bffb05 	stb	r2,-20(fp)
    4b18:	e0bffd0b 	ldhu	r2,-12(fp)
    4b1c:	10800044 	addi	r2,r2,1
    4b20:	e0bffd0d 	sth	r2,-12(fp)
    4b24:	00001706 	br	4b84 <dhcp_get_option_ptr+0xf4>
      }
      /* requested option found */
      else if (options[offset] == option_type) {
    4b28:	e0bffd0b 	ldhu	r2,-12(fp)
    4b2c:	e0fffc17 	ldw	r3,-16(fp)
    4b30:	1885883a 	add	r2,r3,r2
    4b34:	10800003 	ldbu	r2,0(r2)
    4b38:	10c03fcc 	andi	r3,r2,255
    4b3c:	e0bfff03 	ldbu	r2,-4(fp)
    4b40:	1880041e 	bne	r3,r2,4b54 <dhcp_get_option_ptr+0xc4>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("option found at offset %"U16_F" in options\n", offset));
        return &options[offset];
    4b44:	e0bffd0b 	ldhu	r2,-12(fp)
    4b48:	e0fffc17 	ldw	r3,-16(fp)
    4b4c:	1885883a 	add	r2,r3,r2
    4b50:	00005806 	br	4cb4 <dhcp_get_option_ptr+0x224>
      /* skip option */
      } else {
         LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", options[offset]));
        /* skip option type */
        offset++;
    4b54:	e0bffd0b 	ldhu	r2,-12(fp)
    4b58:	10800044 	addi	r2,r2,1
    4b5c:	e0bffd0d 	sth	r2,-12(fp)
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
    4b60:	e0bffd0b 	ldhu	r2,-12(fp)
    4b64:	e0fffc17 	ldw	r3,-16(fp)
    4b68:	1885883a 	add	r2,r3,r2
    4b6c:	10800003 	ldbu	r2,0(r2)
    4b70:	10c03fcc 	andi	r3,r2,255
    4b74:	e0bffd0b 	ldhu	r2,-12(fp)
    4b78:	1885883a 	add	r2,r3,r2
    4b7c:	10800044 	addi	r2,r2,1
    4b80:	e0bffd0d 	sth	r2,-12(fp)
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
    4b84:	e0bffe17 	ldw	r2,-8(fp)
    4b88:	1080040b 	ldhu	r2,16(r2)
    4b8c:	10bfffcc 	andi	r2,r2,65535
    4b90:	e0fffd0b 	ldhu	r3,-12(fp)
    4b94:	1880072e 	bgeu	r3,r2,4bb4 <dhcp_get_option_ptr+0x124>
    4b98:	e0bffd0b 	ldhu	r2,-12(fp)
    4b9c:	e0fffc17 	ldw	r3,-16(fp)
    4ba0:	1885883a 	add	r2,r3,r2
    4ba4:	10800003 	ldbu	r2,0(r2)
    4ba8:	10803fcc 	andi	r2,r2,255
    4bac:	10803fd8 	cmpnei	r2,r2,255
    4bb0:	103fca1e 	bne	r2,zero,4adc <dhcp_get_option_ptr+0x4c>
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
      }
    }
    /* is this an overloaded message? */
    if (overload != DHCP_OVERLOAD_NONE) {
    4bb4:	e0bffb03 	ldbu	r2,-20(fp)
    4bb8:	10003d26 	beq	r2,zero,4cb0 <dhcp_get_option_ptr+0x220>
      u16_t field_len;
      if (overload == DHCP_OVERLOAD_FILE) {
    4bbc:	e0bffb03 	ldbu	r2,-20(fp)
    4bc0:	10800058 	cmpnei	r2,r2,1
    4bc4:	1000071e 	bne	r2,zero,4be4 <dhcp_get_option_ptr+0x154>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded file field\n"));
        options = (u8_t *)&dhcp->msg_in->file;
    4bc8:	e0bffe17 	ldw	r2,-8(fp)
    4bcc:	10800217 	ldw	r2,8(r2)
    4bd0:	10801b04 	addi	r2,r2,108
    4bd4:	e0bffc15 	stw	r2,-16(fp)
        field_len = DHCP_FILE_LEN;
    4bd8:	00802004 	movi	r2,128
    4bdc:	e0bffd8d 	sth	r2,-10(fp)
    4be0:	00001006 	br	4c24 <dhcp_get_option_ptr+0x194>
      } else if (overload == DHCP_OVERLOAD_SNAME) {
    4be4:	e0bffb03 	ldbu	r2,-20(fp)
    4be8:	10800098 	cmpnei	r2,r2,2
    4bec:	1000071e 	bne	r2,zero,4c0c <dhcp_get_option_ptr+0x17c>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded sname field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
    4bf0:	e0bffe17 	ldw	r2,-8(fp)
    4bf4:	10800217 	ldw	r2,8(r2)
    4bf8:	10800b04 	addi	r2,r2,44
    4bfc:	e0bffc15 	stw	r2,-16(fp)
        field_len = DHCP_SNAME_LEN;
    4c00:	00801004 	movi	r2,64
    4c04:	e0bffd8d 	sth	r2,-10(fp)
    4c08:	00000606 	br	4c24 <dhcp_get_option_ptr+0x194>
      /* TODO: check if else if () is necessary */
      } else {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded sname and file field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
    4c0c:	e0bffe17 	ldw	r2,-8(fp)
    4c10:	10800217 	ldw	r2,8(r2)
    4c14:	10800b04 	addi	r2,r2,44
    4c18:	e0bffc15 	stw	r2,-16(fp)
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
    4c1c:	00803004 	movi	r2,192
    4c20:	e0bffd8d 	sth	r2,-10(fp)
      }
      offset = 0;
    4c24:	e03ffd0d 	sth	zero,-12(fp)

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
    4c28:	00001706 	br	4c88 <dhcp_get_option_ptr+0x1f8>
        if (options[offset] == option_type) {
    4c2c:	e0bffd0b 	ldhu	r2,-12(fp)
    4c30:	e0fffc17 	ldw	r3,-16(fp)
    4c34:	1885883a 	add	r2,r3,r2
    4c38:	10800003 	ldbu	r2,0(r2)
    4c3c:	10c03fcc 	andi	r3,r2,255
    4c40:	e0bfff03 	ldbu	r2,-4(fp)
    4c44:	1880041e 	bne	r3,r2,4c58 <dhcp_get_option_ptr+0x1c8>
           LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("option found at offset=%"U16_F"\n", offset));
          return &options[offset];
    4c48:	e0bffd0b 	ldhu	r2,-12(fp)
    4c4c:	e0fffc17 	ldw	r3,-16(fp)
    4c50:	1885883a 	add	r2,r3,r2
    4c54:	00001706 	br	4cb4 <dhcp_get_option_ptr+0x224>
        /* skip option */
        } else {
          LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("skipping option %"U16_F"\n", options[offset]));
          /* skip option type */
          offset++;
    4c58:	e0bffd0b 	ldhu	r2,-12(fp)
    4c5c:	10800044 	addi	r2,r2,1
    4c60:	e0bffd0d 	sth	r2,-12(fp)
          offset += 1 + options[offset];
    4c64:	e0bffd0b 	ldhu	r2,-12(fp)
    4c68:	e0fffc17 	ldw	r3,-16(fp)
    4c6c:	1885883a 	add	r2,r3,r2
    4c70:	10800003 	ldbu	r2,0(r2)
    4c74:	10c03fcc 	andi	r3,r2,255
    4c78:	e0bffd0b 	ldhu	r2,-12(fp)
    4c7c:	1885883a 	add	r2,r3,r2
    4c80:	10800044 	addi	r2,r2,1
    4c84:	e0bffd0d 	sth	r2,-12(fp)
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
      }
      offset = 0;

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
    4c88:	e0fffd0b 	ldhu	r3,-12(fp)
    4c8c:	e0bffd8b 	ldhu	r2,-10(fp)
    4c90:	1880072e 	bgeu	r3,r2,4cb0 <dhcp_get_option_ptr+0x220>
    4c94:	e0bffd0b 	ldhu	r2,-12(fp)
    4c98:	e0fffc17 	ldw	r3,-16(fp)
    4c9c:	1885883a 	add	r2,r3,r2
    4ca0:	10800003 	ldbu	r2,0(r2)
    4ca4:	10803fcc 	andi	r2,r2,255
    4ca8:	10803fd8 	cmpnei	r2,r2,255
    4cac:	103fdf1e 	bne	r2,zero,4c2c <dhcp_get_option_ptr+0x19c>
          offset += 1 + options[offset];
        }
      }
    }
  }
  return NULL;
    4cb0:	0005883a 	mov	r2,zero
}
    4cb4:	e037883a 	mov	sp,fp
    4cb8:	df000017 	ldw	fp,0(sp)
    4cbc:	dec00104 	addi	sp,sp,4
    4cc0:	f800283a 	ret

00004cc4 <dhcp_get_option_byte>:
 *
 * @return byte value at the given address.
 */
static u8_t
dhcp_get_option_byte(u8_t *ptr)
{
    4cc4:	defffe04 	addi	sp,sp,-8
    4cc8:	df000115 	stw	fp,4(sp)
    4ccc:	df000104 	addi	fp,sp,4
    4cd0:	e13fff15 	stw	r4,-4(fp)
  LWIP_DEBUGF(DHCP_DEBUG, ("option byte value=%"U16_F"\n", (u16_t)(*ptr)));
  return *ptr;
    4cd4:	e0bfff17 	ldw	r2,-4(fp)
    4cd8:	10800003 	ldbu	r2,0(r2)
}
    4cdc:	e037883a 	mov	sp,fp
    4ce0:	df000017 	ldw	fp,0(sp)
    4ce4:	dec00104 	addi	sp,sp,4
    4ce8:	f800283a 	ret

00004cec <dhcp_get_option_long>:
 * @param ptr pointer obtained by dhcp_get_option_ptr().
 *
 * @return byte value at the given address.
 */
static u32_t dhcp_get_option_long(u8_t *ptr)
{
    4cec:	defffd04 	addi	sp,sp,-12
    4cf0:	df000215 	stw	fp,8(sp)
    4cf4:	df000204 	addi	fp,sp,8
    4cf8:	e13fff15 	stw	r4,-4(fp)
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
    4cfc:	e0bfff17 	ldw	r2,-4(fp)
    4d00:	10800003 	ldbu	r2,0(r2)
    4d04:	10803fcc 	andi	r2,r2,255
    4d08:	1004963a 	slli	r2,r2,24
    4d0c:	e0bffe15 	stw	r2,-8(fp)
    4d10:	e0bfff17 	ldw	r2,-4(fp)
    4d14:	10800044 	addi	r2,r2,1
    4d18:	e0bfff15 	stw	r2,-4(fp)
  value |= (u32_t)(*ptr++) << 16;
    4d1c:	e0bfff17 	ldw	r2,-4(fp)
    4d20:	10800003 	ldbu	r2,0(r2)
    4d24:	10803fcc 	andi	r2,r2,255
    4d28:	1004943a 	slli	r2,r2,16
    4d2c:	e0fffe17 	ldw	r3,-8(fp)
    4d30:	1884b03a 	or	r2,r3,r2
    4d34:	e0bffe15 	stw	r2,-8(fp)
    4d38:	e0bfff17 	ldw	r2,-4(fp)
    4d3c:	10800044 	addi	r2,r2,1
    4d40:	e0bfff15 	stw	r2,-4(fp)
  value |= (u32_t)(*ptr++) << 8;
    4d44:	e0bfff17 	ldw	r2,-4(fp)
    4d48:	10800003 	ldbu	r2,0(r2)
    4d4c:	10803fcc 	andi	r2,r2,255
    4d50:	1004923a 	slli	r2,r2,8
    4d54:	e0fffe17 	ldw	r3,-8(fp)
    4d58:	1884b03a 	or	r2,r3,r2
    4d5c:	e0bffe15 	stw	r2,-8(fp)
    4d60:	e0bfff17 	ldw	r2,-4(fp)
    4d64:	10800044 	addi	r2,r2,1
    4d68:	e0bfff15 	stw	r2,-4(fp)
  value |= (u32_t)(*ptr++);
    4d6c:	e0bfff17 	ldw	r2,-4(fp)
    4d70:	10800003 	ldbu	r2,0(r2)
    4d74:	10803fcc 	andi	r2,r2,255
    4d78:	e0fffe17 	ldw	r3,-8(fp)
    4d7c:	1884b03a 	or	r2,r3,r2
    4d80:	e0bffe15 	stw	r2,-8(fp)
    4d84:	e0bfff17 	ldw	r2,-4(fp)
    4d88:	10800044 	addi	r2,r2,1
    4d8c:	e0bfff15 	stw	r2,-4(fp)
  LWIP_DEBUGF(DHCP_DEBUG, ("option long value=%"U32_F"\n", value));
  return value;
    4d90:	e0bffe17 	ldw	r2,-8(fp)
}
    4d94:	e037883a 	mov	sp,fp
    4d98:	df000017 	ldw	fp,0(sp)
    4d9c:	dec00104 	addi	sp,sp,4
    4da0:	f800283a 	ret

00004da4 <lwip_sanity_check>:
#endif

#ifdef LWIP_DEBUG
static void
lwip_sanity_check(void)
{
    4da4:	deffff04 	addi	sp,sp,-4
    4da8:	df000015 	stw	fp,0(sp)
    4dac:	d839883a 	mov	fp,sp
  if (TCP_WND > (PBUF_POOL_SIZE*PBUF_POOL_BUFSIZE))
    LWIP_PLATFORM_DIAG(("lwip_sanity_check: WARNING: TCP_WND is larger than space provided by PBUF_POOL_SIZE*PBUF_POOL_BUFSIZE\n"));
  if (TCP_WND < TCP_MSS)
    LWIP_PLATFORM_DIAG(("lwip_sanity_check: WARNING: TCP_WND is smaller than MSS\n"));
#endif /* LWIP_TCP */
}
    4db0:	e037883a 	mov	sp,fp
    4db4:	df000017 	ldw	fp,0(sp)
    4db8:	dec00104 	addi	sp,sp,4
    4dbc:	f800283a 	ret

00004dc0 <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
    4dc0:	defffe04 	addi	sp,sp,-8
    4dc4:	dfc00115 	stw	ra,4(sp)
    4dc8:	df000015 	stw	fp,0(sp)
    4dcc:	d839883a 	mov	fp,sp
  /* Sanity check user-configurable values */
  lwip_sanity_check();
    4dd0:	0004da40 	call	4da4 <lwip_sanity_check>

  /* Modules initialization */
  stats_init();
  sys_init();
  mem_init();
    4dd4:	00083a00 	call	83a0 <mem_init>
  memp_init();
    4dd8:	0008d500 	call	8d50 <memp_init>
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */
}
    4ddc:	e037883a 	mov	sp,fp
    4de0:	dfc00117 	ldw	ra,4(sp)
    4de4:	df000017 	ldw	fp,0(sp)
    4de8:	dec00204 	addi	sp,sp,8
    4dec:	f800283a 	ret

00004df0 <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
    4df0:	defff204 	addi	sp,sp,-56
    4df4:	dfc00d15 	stw	ra,52(sp)
    4df8:	df000c15 	stw	fp,48(sp)
    4dfc:	df000c04 	addi	fp,sp,48
    4e00:	e13ffe15 	stw	r4,-8(fp)
    4e04:	e17fff15 	stw	r5,-4(fp)
  struct icmp_echo_hdr *iecho;
  struct ip_hdr *iphdr;
  struct ip_addr tmpaddr;
  s16_t hlen;

  ICMP_STATS_INC(icmp.recv);
    4e08:	00800134 	movhi	r2,4
    4e0c:	10916104 	addi	r2,r2,17796
    4e10:	1080188b 	ldhu	r2,98(r2)
    4e14:	10800044 	addi	r2,r2,1
    4e18:	1007883a 	mov	r3,r2
    4e1c:	00800134 	movhi	r2,4
    4e20:	10916104 	addi	r2,r2,17796
    4e24:	10c0188d 	sth	r3,98(r2)
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
    4e28:	e0bffe17 	ldw	r2,-8(fp)
    4e2c:	10800117 	ldw	r2,4(r2)
    4e30:	e0bff715 	stw	r2,-36(fp)
  hlen = IPH_HL(iphdr) * 4;
    4e34:	e0bff717 	ldw	r2,-36(fp)
    4e38:	1080000b 	ldhu	r2,0(r2)
    4e3c:	10bfffcc 	andi	r2,r2,65535
    4e40:	1004d23a 	srli	r2,r2,8
    4e44:	10ffffcc 	andi	r3,r2,65535
    4e48:	e0bff717 	ldw	r2,-36(fp)
    4e4c:	1080000b 	ldhu	r2,0(r2)
    4e50:	10bfffcc 	andi	r2,r2,65535
    4e54:	1004923a 	slli	r2,r2,8
    4e58:	10bfffcc 	andi	r2,r2,65535
    4e5c:	1884b03a 	or	r2,r3,r2
    4e60:	1005d23a 	srai	r2,r2,8
    4e64:	108003cc 	andi	r2,r2,15
    4e68:	1085883a 	add	r2,r2,r2
    4e6c:	1085883a 	add	r2,r2,r2
    4e70:	e0bff90d 	sth	r2,-28(fp)
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
    4e74:	e0bff90b 	ldhu	r2,-28(fp)
    4e78:	0085c83a 	sub	r2,zero,r2
    4e7c:	10bfffcc 	andi	r2,r2,65535
    4e80:	10a0001c 	xori	r2,r2,32768
    4e84:	10a00004 	addi	r2,r2,-32768
    4e88:	e13ffe17 	ldw	r4,-8(fp)
    4e8c:	100b883a 	mov	r5,r2
    4e90:	0009f900 	call	9f90 <pbuf_header>
    4e94:	10803fcc 	andi	r2,r2,255
    4e98:	1000051e 	bne	r2,zero,4eb0 <icmp_input+0xc0>
    4e9c:	e0bffe17 	ldw	r2,-8(fp)
    4ea0:	1080020b 	ldhu	r2,8(r2)
    4ea4:	10bfffcc 	andi	r2,r2,65535
    4ea8:	10800128 	cmpgeui	r2,r2,4
    4eac:	1000061e 	bne	r2,zero,4ec8 <icmp_input+0xd8>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    4eb0:	e0bffe17 	ldw	r2,-8(fp)
    4eb4:	1080020b 	ldhu	r2,8(r2)
    4eb8:	10bfffcc 	andi	r2,r2,65535
    4ebc:	1009883a 	mov	r4,r2
    4ec0:	00170680 	call	17068 <printf>
    goto lenerr;
    4ec4:	00016106 	br	544c <icmp_input+0x65c>
  }

  type = *((u8_t *)p->payload);
    4ec8:	e0bffe17 	ldw	r2,-8(fp)
    4ecc:	10800117 	ldw	r2,4(r2)
    4ed0:	10800003 	ldbu	r2,0(r2)
    4ed4:	e0bff985 	stb	r2,-26(fp)
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
    4ed8:	e0bffe17 	ldw	r2,-8(fp)
    4edc:	10800117 	ldw	r2,4(r2)
    4ee0:	10800043 	ldbu	r2,1(r2)
    4ee4:	e0bff9c5 	stb	r2,-25(fp)
#endif /* LWIP_DEBUG */
  switch (type) {
    4ee8:	e0bff983 	ldbu	r2,-26(fp)
    4eec:	10800220 	cmpeqi	r2,r2,8
    4ef0:	10013e26 	beq	r2,zero,53ec <icmp_input+0x5fc>
  case ICMP_ECHO:
#if !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING
    {
      int accepted = 1;
    4ef4:	00800044 	movi	r2,1
    4ef8:	e0bff815 	stw	r2,-32(fp)
#if !LWIP_MULTICAST_PING
      /* multicast destination address? */
      if (ip_addr_ismulticast(&iphdr->dest)) {
    4efc:	e0bff717 	ldw	r2,-36(fp)
    4f00:	10c0040b 	ldhu	r3,16(r2)
    4f04:	1080048b 	ldhu	r2,18(r2)
    4f08:	1004943a 	slli	r2,r2,16
    4f0c:	10c4b03a 	or	r2,r2,r3
    4f10:	10803c0c 	andi	r2,r2,240
    4f14:	10803818 	cmpnei	r2,r2,224
    4f18:	1000011e 	bne	r2,zero,4f20 <icmp_input+0x130>
        accepted = 0;
    4f1c:	e03ff815 	stw	zero,-32(fp)
      }
#endif /* LWIP_MULTICAST_PING */
#if !LWIP_BROADCAST_PING
      /* broadcast destination address? */
      if (ip_addr_isbroadcast(&iphdr->dest, inp)) {
    4f20:	e0bff717 	ldw	r2,-36(fp)
    4f24:	10800404 	addi	r2,r2,16
    4f28:	1009883a 	mov	r4,r2
    4f2c:	e17fff17 	ldw	r5,-4(fp)
    4f30:	0006dcc0 	call	6dcc <ip_addr_isbroadcast>
    4f34:	10803fcc 	andi	r2,r2,255
    4f38:	10000126 	beq	r2,zero,4f40 <icmp_input+0x150>
        accepted = 0;
    4f3c:	e03ff815 	stw	zero,-32(fp)
      }
#endif /* LWIP_BROADCAST_PING */
      /* broadcast or multicast destination address not acceptd? */
      if (!accepted) {
    4f40:	e0bff817 	ldw	r2,-32(fp)
    4f44:	10000e1e 	bne	r2,zero,4f80 <icmp_input+0x190>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
    4f48:	010000f4 	movhi	r4,3
    4f4c:	2138eb04 	addi	r4,r4,-7252
    4f50:	00172f80 	call	172f8 <puts>
        ICMP_STATS_INC(icmp.err);
    4f54:	00800134 	movhi	r2,4
    4f58:	10916104 	addi	r2,r2,17796
    4f5c:	10801d0b 	ldhu	r2,116(r2)
    4f60:	10800044 	addi	r2,r2,1
    4f64:	1007883a 	mov	r3,r2
    4f68:	00800134 	movhi	r2,4
    4f6c:	10916104 	addi	r2,r2,17796
    4f70:	10c01d0d 	sth	r3,116(r2)
        pbuf_free(p);
    4f74:	e13ffe17 	ldw	r4,-8(fp)
    4f78:	000a1880 	call	a188 <pbuf_free>
    4f7c:	00013d06 	br	5474 <icmp_input+0x684>
        return;
      }
    }
#endif /* !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    4f80:	010000f4 	movhi	r4,3
    4f84:	2138f904 	addi	r4,r4,-7196
    4f88:	00172f80 	call	172f8 <puts>
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
    4f8c:	e0bffe17 	ldw	r2,-8(fp)
    4f90:	1080020b 	ldhu	r2,8(r2)
    4f94:	10bfffcc 	andi	r2,r2,65535
    4f98:	10800228 	cmpgeui	r2,r2,8
    4f9c:	1000041e 	bne	r2,zero,4fb0 <icmp_input+0x1c0>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
    4fa0:	010000f4 	movhi	r4,3
    4fa4:	2138fe04 	addi	r4,r4,-7176
    4fa8:	00172f80 	call	172f8 <puts>
      goto lenerr;
    4fac:	00012706 	br	544c <icmp_input+0x65c>
    }
    if (inet_chksum_pbuf(p) != 0) {
    4fb0:	e13ffe17 	ldw	r4,-8(fp)
    4fb4:	00060a40 	call	60a4 <inet_chksum_pbuf>
    4fb8:	10bfffcc 	andi	r2,r2,65535
    4fbc:	10000e26 	beq	r2,zero,4ff8 <icmp_input+0x208>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
    4fc0:	010000f4 	movhi	r4,3
    4fc4:	21390704 	addi	r4,r4,-7140
    4fc8:	00172f80 	call	172f8 <puts>
      pbuf_free(p);
    4fcc:	e13ffe17 	ldw	r4,-8(fp)
    4fd0:	000a1880 	call	a188 <pbuf_free>
      ICMP_STATS_INC(icmp.chkerr);
    4fd4:	00800134 	movhi	r2,4
    4fd8:	10916104 	addi	r2,r2,17796
    4fdc:	10801a0b 	ldhu	r2,104(r2)
    4fe0:	10800044 	addi	r2,r2,1
    4fe4:	1007883a 	mov	r3,r2
    4fe8:	00800134 	movhi	r2,4
    4fec:	10916104 	addi	r2,r2,17796
    4ff0:	10c01a0d 	sth	r3,104(r2)
    4ff4:	00011f06 	br	5474 <icmp_input+0x684>
      snmp_inc_icmpinerrors();
      return;
    }
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
    4ff8:	e13ffe17 	ldw	r4,-8(fp)
    4ffc:	01400884 	movi	r5,34
    5000:	0009f900 	call	9f90 <pbuf_header>
    5004:	10803fcc 	andi	r2,r2,255
    5008:	10006226 	beq	r2,zero,5194 <icmp_input+0x3a4>
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
    500c:	e0bff90f 	ldh	r2,-28(fp)
    5010:	e13ffe17 	ldw	r4,-8(fp)
    5014:	100b883a 	mov	r5,r2
    5018:	0009f900 	call	9f90 <pbuf_header>
    501c:	10803fcc 	andi	r2,r2,255
    5020:	10000926 	beq	r2,zero,5048 <icmp_input+0x258>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
    5024:	010000f4 	movhi	r4,3
    5028:	21391404 	addi	r4,r4,-7088
    502c:	014000f4 	movhi	r5,3
    5030:	29791e04 	addi	r5,r5,-7048
    5034:	01802584 	movi	r6,150
    5038:	01c000f4 	movhi	r7,3
    503c:	39f92b04 	addi	r7,r7,-6996
    5040:	00170680 	call	17068 <printf>
    5044:	003fff06 	br	5044 <icmp_input+0x254>
        goto memerr;
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
    5048:	e0bffe17 	ldw	r2,-8(fp)
    504c:	1080020b 	ldhu	r2,8(r2)
    5050:	10bfffcc 	andi	r2,r2,65535
    5054:	01000084 	movi	r4,2
    5058:	100b883a 	mov	r5,r2
    505c:	000d883a 	mov	r6,zero
    5060:	00097cc0 	call	97cc <pbuf_alloc>
    5064:	e0bffa15 	stw	r2,-24(fp)
      if (r == NULL) {
    5068:	e0bffa17 	ldw	r2,-24(fp)
    506c:	10000f1e 	bne	r2,zero,50ac <icmp_input+0x2bc>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
    5070:	010000f4 	movhi	r4,3
    5074:	21393204 	addi	r4,r4,-6968
    5078:	00172f80 	call	172f8 <puts>
        goto memerr;
    507c:	0001883a 	nop
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
memerr:
  pbuf_free(p);
    5080:	e13ffe17 	ldw	r4,-8(fp)
    5084:	000a1880 	call	a188 <pbuf_free>
  ICMP_STATS_INC(icmp.err);
    5088:	00800134 	movhi	r2,4
    508c:	10916104 	addi	r2,r2,17796
    5090:	10801d0b 	ldhu	r2,116(r2)
    5094:	10800044 	addi	r2,r2,1
    5098:	1007883a 	mov	r3,r2
    509c:	00800134 	movhi	r2,4
    50a0:	10916104 	addi	r2,r2,17796
    50a4:	10c01d0d 	sth	r3,116(r2)
    50a8:	0000f206 	br	5474 <icmp_input+0x684>
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
      if (r == NULL) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
    50ac:	e0bffa17 	ldw	r2,-24(fp)
    50b0:	1080028b 	ldhu	r2,10(r2)
    50b4:	10ffffcc 	andi	r3,r2,65535
    50b8:	e0bff90f 	ldh	r2,-28(fp)
    50bc:	10800204 	addi	r2,r2,8
    50c0:	1880092e 	bgeu	r3,r2,50e8 <icmp_input+0x2f8>
    50c4:	010000f4 	movhi	r4,3
    50c8:	21391404 	addi	r4,r4,-7088
    50cc:	014000f4 	movhi	r5,3
    50d0:	29793c04 	addi	r5,r5,-6928
    50d4:	01802804 	movi	r6,160
    50d8:	01c000f4 	movhi	r7,3
    50dc:	39f92b04 	addi	r7,r7,-6996
    50e0:	00170680 	call	17068 <printf>
    50e4:	003fff06 	br	50e4 <icmp_input+0x2f4>
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
    50e8:	e13ffa17 	ldw	r4,-24(fp)
    50ec:	e17ffe17 	ldw	r5,-8(fp)
    50f0:	000a68c0 	call	a68c <pbuf_copy>
    50f4:	10803fcc 	andi	r2,r2,255
    50f8:	1080201c 	xori	r2,r2,128
    50fc:	10bfe004 	addi	r2,r2,-128
    5100:	10000926 	beq	r2,zero,5128 <icmp_input+0x338>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
    5104:	010000f4 	movhi	r4,3
    5108:	21391404 	addi	r4,r4,-7088
    510c:	014000f4 	movhi	r5,3
    5110:	29794a04 	addi	r5,r5,-6872
    5114:	018028c4 	movi	r6,163
    5118:	01c000f4 	movhi	r7,3
    511c:	39f92b04 	addi	r7,r7,-6996
    5120:	00170680 	call	17068 <printf>
    5124:	003fff06 	br	5124 <icmp_input+0x334>
        goto memerr;
      }
      iphdr = r->payload;
    5128:	e0bffa17 	ldw	r2,-24(fp)
    512c:	10800117 	ldw	r2,4(r2)
    5130:	e0bff715 	stw	r2,-36(fp)
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
    5134:	e0bff90b 	ldhu	r2,-28(fp)
    5138:	0085c83a 	sub	r2,zero,r2
    513c:	10bfffcc 	andi	r2,r2,65535
    5140:	10a0001c 	xori	r2,r2,32768
    5144:	10a00004 	addi	r2,r2,-32768
    5148:	e13ffa17 	ldw	r4,-24(fp)
    514c:	100b883a 	mov	r5,r2
    5150:	0009f900 	call	9f90 <pbuf_header>
    5154:	10803fcc 	andi	r2,r2,255
    5158:	10000926 	beq	r2,zero,5180 <icmp_input+0x390>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
    515c:	010000f4 	movhi	r4,3
    5160:	21391404 	addi	r4,r4,-7088
    5164:	014000f4 	movhi	r5,3
    5168:	29795404 	addi	r5,r5,-6832
    516c:	01802a44 	movi	r6,169
    5170:	01c000f4 	movhi	r7,3
    5174:	39f92b04 	addi	r7,r7,-6996
    5178:	00170680 	call	17068 <printf>
    517c:	003fff06 	br	517c <icmp_input+0x38c>
        goto memerr;
      }
      /* free the original p */
      pbuf_free(p);
    5180:	e13ffe17 	ldw	r4,-8(fp)
    5184:	000a1880 	call	a188 <pbuf_free>
      /* we now have an identical copy of p that has room for link headers */
      p = r;
    5188:	e0bffa17 	ldw	r2,-24(fp)
    518c:	e0bffe15 	stw	r2,-8(fp)
    5190:	00000e06 	br	51cc <icmp_input+0x3dc>
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
    5194:	e13ffe17 	ldw	r4,-8(fp)
    5198:	017ff784 	movi	r5,-34
    519c:	0009f900 	call	9f90 <pbuf_header>
    51a0:	10803fcc 	andi	r2,r2,255
    51a4:	10000926 	beq	r2,zero,51cc <icmp_input+0x3dc>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
    51a8:	010000f4 	movhi	r4,3
    51ac:	21391404 	addi	r4,r4,-7088
    51b0:	014000f4 	movhi	r5,3
    51b4:	29795404 	addi	r5,r5,-6832
    51b8:	01802cc4 	movi	r6,179
    51bc:	01c000f4 	movhi	r7,3
    51c0:	39f92b04 	addi	r7,r7,-6996
    51c4:	00170680 	call	17068 <printf>
    51c8:	003fff06 	br	51c8 <icmp_input+0x3d8>
    }
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = p->payload;
    51cc:	e0bffe17 	ldw	r2,-8(fp)
    51d0:	10800117 	ldw	r2,4(r2)
    51d4:	e0bffb15 	stw	r2,-20(fp)
    tmpaddr.addr = iphdr->src.addr;
    51d8:	e0bff717 	ldw	r2,-36(fp)
    51dc:	10c0030b 	ldhu	r3,12(r2)
    51e0:	1080038b 	ldhu	r2,14(r2)
    51e4:	1004943a 	slli	r2,r2,16
    51e8:	10c4b03a 	or	r2,r2,r3
    51ec:	10ffffcc 	andi	r3,r2,65535
    51f0:	e13ffc8b 	ldhu	r4,-14(fp)
    51f4:	2008703a 	and	r4,r4,zero
    51f8:	20c6b03a 	or	r3,r4,r3
    51fc:	e0fffc8d 	sth	r3,-14(fp)
    5200:	1004d43a 	srli	r2,r2,16
    5204:	e0fffd0b 	ldhu	r3,-12(fp)
    5208:	1806703a 	and	r3,r3,zero
    520c:	1884b03a 	or	r2,r3,r2
    5210:	e0bffd0d 	sth	r2,-12(fp)
    iphdr->src.addr = iphdr->dest.addr;
    5214:	e0bff717 	ldw	r2,-36(fp)
    5218:	10c0040b 	ldhu	r3,16(r2)
    521c:	1080048b 	ldhu	r2,18(r2)
    5220:	1004943a 	slli	r2,r2,16
    5224:	10c4b03a 	or	r2,r2,r3
    5228:	1007883a 	mov	r3,r2
    522c:	e0bff717 	ldw	r2,-36(fp)
    5230:	193fffcc 	andi	r4,r3,65535
    5234:	1140030b 	ldhu	r5,12(r2)
    5238:	280a703a 	and	r5,r5,zero
    523c:	2908b03a 	or	r4,r5,r4
    5240:	1100030d 	sth	r4,12(r2)
    5244:	1806d43a 	srli	r3,r3,16
    5248:	1100038b 	ldhu	r4,14(r2)
    524c:	2008703a 	and	r4,r4,zero
    5250:	20c6b03a 	or	r3,r4,r3
    5254:	10c0038d 	sth	r3,14(r2)
    iphdr->dest.addr = tmpaddr.addr;
    5258:	e0bffc8b 	ldhu	r2,-14(fp)
    525c:	e0fffd0b 	ldhu	r3,-12(fp)
    5260:	1806943a 	slli	r3,r3,16
    5264:	1884b03a 	or	r2,r3,r2
    5268:	1007883a 	mov	r3,r2
    526c:	e0bff717 	ldw	r2,-36(fp)
    5270:	193fffcc 	andi	r4,r3,65535
    5274:	1140040b 	ldhu	r5,16(r2)
    5278:	280a703a 	and	r5,r5,zero
    527c:	2908b03a 	or	r4,r5,r4
    5280:	1100040d 	sth	r4,16(r2)
    5284:	1806d43a 	srli	r3,r3,16
    5288:	1100048b 	ldhu	r4,18(r2)
    528c:	2008703a 	and	r4,r4,zero
    5290:	20c6b03a 	or	r3,r4,r3
    5294:	10c0048d 	sth	r3,18(r2)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
    5298:	e0bffb17 	ldw	r2,-20(fp)
    529c:	10000005 	stb	zero,0(r2)
    /* adjust the checksum */
    if (iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {
    52a0:	e0bffb17 	ldw	r2,-20(fp)
    52a4:	1080008b 	ldhu	r2,2(r2)
    52a8:	10bfffcc 	andi	r2,r2,65535
    52ac:	10bffdf0 	cmpltui	r2,r2,65527
    52b0:	1000071e 	bne	r2,zero,52d0 <icmp_input+0x4e0>
      iecho->chksum += htons(ICMP_ECHO << 8) + 1;
    52b4:	e0bffb17 	ldw	r2,-20(fp)
    52b8:	1080008b 	ldhu	r2,2(r2)
    52bc:	10800244 	addi	r2,r2,9
    52c0:	1007883a 	mov	r3,r2
    52c4:	e0bffb17 	ldw	r2,-20(fp)
    52c8:	10c0008d 	sth	r3,2(r2)
    52cc:	00000606 	br	52e8 <icmp_input+0x4f8>
    } else {
      iecho->chksum += htons(ICMP_ECHO << 8);
    52d0:	e0bffb17 	ldw	r2,-20(fp)
    52d4:	1080008b 	ldhu	r2,2(r2)
    52d8:	10800204 	addi	r2,r2,8
    52dc:	1007883a 	mov	r3,r2
    52e0:	e0bffb17 	ldw	r2,-20(fp)
    52e4:	10c0008d 	sth	r3,2(r2)
    }

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
    52e8:	e0bff717 	ldw	r2,-36(fp)
    52ec:	1080020b 	ldhu	r2,8(r2)
    52f0:	10bfffcc 	andi	r2,r2,65535
    52f4:	1004d23a 	srli	r2,r2,8
    52f8:	10ffffcc 	andi	r3,r2,65535
    52fc:	e0bff717 	ldw	r2,-36(fp)
    5300:	1080020b 	ldhu	r2,8(r2)
    5304:	10bfffcc 	andi	r2,r2,65535
    5308:	1004923a 	slli	r2,r2,8
    530c:	10bfffcc 	andi	r2,r2,65535
    5310:	1884b03a 	or	r2,r3,r2
    5314:	1004923a 	slli	r2,r2,8
    5318:	10803fd4 	ori	r2,r2,255
    531c:	1007883a 	mov	r3,r2
    5320:	e0bff717 	ldw	r2,-36(fp)
    5324:	10c0020d 	sth	r3,8(r2)
    IPH_CHKSUM_SET(iphdr, 0);
    5328:	e0bff717 	ldw	r2,-36(fp)
    532c:	1000028d 	sth	zero,10(r2)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
    5330:	e13ff717 	ldw	r4,-36(fp)
    5334:	01400504 	movi	r5,20
    5338:	00060600 	call	6060 <inet_chksum>
    533c:	e0fff717 	ldw	r3,-36(fp)
    5340:	1880028d 	sth	r2,10(r3)
#endif /* CHECKSUM_GEN_IP */

    ICMP_STATS_INC(icmp.xmit);
    5344:	00800134 	movhi	r2,4
    5348:	10916104 	addi	r2,r2,17796
    534c:	1080180b 	ldhu	r2,96(r2)
    5350:	10800044 	addi	r2,r2,1
    5354:	1007883a 	mov	r3,r2
    5358:	00800134 	movhi	r2,4
    535c:	10916104 	addi	r2,r2,17796
    5360:	10c0180d 	sth	r3,96(r2)
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
    5364:	e0bff90f 	ldh	r2,-28(fp)
    5368:	e13ffe17 	ldw	r4,-8(fp)
    536c:	100b883a 	mov	r5,r2
    5370:	0009f900 	call	9f90 <pbuf_header>
    5374:	10803fcc 	andi	r2,r2,255
    5378:	10000926 	beq	r2,zero,53a0 <icmp_input+0x5b0>
      LWIP_ASSERT("Can't move over header in packet", 0);
    537c:	010000f4 	movhi	r4,3
    5380:	21391404 	addi	r4,r4,-7088
    5384:	014000f4 	movhi	r5,3
    5388:	29796104 	addi	r5,r5,-6780
    538c:	01803544 	movi	r6,213
    5390:	01c000f4 	movhi	r7,3
    5394:	39f92b04 	addi	r7,r7,-6996
    5398:	00170680 	call	17068 <printf>
    539c:	003fff06 	br	539c <icmp_input+0x5ac>
    } else {
      err_t ret;
      ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,
    53a0:	e0bff717 	ldw	r2,-36(fp)
    53a4:	10800304 	addi	r2,r2,12
    53a8:	d8000015 	stw	zero,0(sp)
    53ac:	00c00044 	movi	r3,1
    53b0:	d8c00115 	stw	r3,4(sp)
    53b4:	e0ffff17 	ldw	r3,-4(fp)
    53b8:	d8c00215 	stw	r3,8(sp)
    53bc:	e13ffe17 	ldw	r4,-8(fp)
    53c0:	100b883a 	mov	r5,r2
    53c4:	000d883a 	mov	r6,zero
    53c8:	01c03fc4 	movi	r7,255
    53cc:	000687c0 	call	687c <ip_output_if>
    53d0:	e0bffc05 	stb	r2,-16(fp)
                   ICMP_TTL, 0, IP_PROTO_ICMP, inp);
      if (ret != ERR_OK) {
    53d4:	e0bffc07 	ldb	r2,-16(fp)
    53d8:	10001826 	beq	r2,zero,543c <icmp_input+0x64c>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %c.\n", ret));
    53dc:	e0bffc07 	ldb	r2,-16(fp)
    53e0:	1009883a 	mov	r4,r2
    53e4:	00170680 	call	17068 <printf>
      }
    }
    break;
    53e8:	00001406 	br	543c <icmp_input+0x64c>
  default:
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
    53ec:	e0bff9c3 	ldbu	r2,-25(fp)
    53f0:	1009883a 	mov	r4,r2
    53f4:	00170680 	call	17068 <printf>
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    53f8:	00800134 	movhi	r2,4
    53fc:	10916104 	addi	r2,r2,17796
    5400:	10801c0b 	ldhu	r2,112(r2)
    5404:	10800044 	addi	r2,r2,1
    5408:	1007883a 	mov	r3,r2
    540c:	00800134 	movhi	r2,4
    5410:	10916104 	addi	r2,r2,17796
    5414:	10c01c0d 	sth	r3,112(r2)
    ICMP_STATS_INC(icmp.drop);
    5418:	00800134 	movhi	r2,4
    541c:	10916104 	addi	r2,r2,17796
    5420:	1080198b 	ldhu	r2,102(r2)
    5424:	10800044 	addi	r2,r2,1
    5428:	1007883a 	mov	r3,r2
    542c:	00800134 	movhi	r2,4
    5430:	10916104 	addi	r2,r2,17796
    5434:	10c0198d 	sth	r3,102(r2)
    5438:	00000106 	br	5440 <icmp_input+0x650>
                   ICMP_TTL, 0, IP_PROTO_ICMP, inp);
      if (ret != ERR_OK) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %c.\n", ret));
      }
    }
    break;
    543c:	0001883a 	nop
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
    5440:	e13ffe17 	ldw	r4,-8(fp)
    5444:	000a1880 	call	a188 <pbuf_free>
    5448:	00000a06 	br	5474 <icmp_input+0x684>
  return;
lenerr:
  pbuf_free(p);
    544c:	e13ffe17 	ldw	r4,-8(fp)
    5450:	000a1880 	call	a188 <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
    5454:	00800134 	movhi	r2,4
    5458:	10916104 	addi	r2,r2,17796
    545c:	10801a8b 	ldhu	r2,106(r2)
    5460:	10800044 	addi	r2,r2,1
    5464:	1007883a 	mov	r3,r2
    5468:	00800134 	movhi	r2,4
    546c:	10916104 	addi	r2,r2,17796
    5470:	10c01a8d 	sth	r3,106(r2)
  pbuf_free(p);
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
}
    5474:	e037883a 	mov	sp,fp
    5478:	dfc00117 	ldw	ra,4(sp)
    547c:	df000017 	ldw	fp,0(sp)
    5480:	dec00204 	addi	sp,sp,8
    5484:	f800283a 	ret

00005488 <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
    5488:	defffc04 	addi	sp,sp,-16
    548c:	dfc00315 	stw	ra,12(sp)
    5490:	df000215 	stw	fp,8(sp)
    5494:	df000204 	addi	fp,sp,8
    5498:	e13ffe15 	stw	r4,-8(fp)
    549c:	e17fff15 	stw	r5,-4(fp)
  icmp_send_response(p, ICMP_DUR, t);
    54a0:	e0bfff17 	ldw	r2,-4(fp)
    54a4:	10803fcc 	andi	r2,r2,255
    54a8:	e13ffe17 	ldw	r4,-8(fp)
    54ac:	014000c4 	movi	r5,3
    54b0:	100d883a 	mov	r6,r2
    54b4:	00055100 	call	5510 <icmp_send_response>
}
    54b8:	e037883a 	mov	sp,fp
    54bc:	dfc00117 	ldw	ra,4(sp)
    54c0:	df000017 	ldw	fp,0(sp)
    54c4:	dec00204 	addi	sp,sp,8
    54c8:	f800283a 	ret

000054cc <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
    54cc:	defffc04 	addi	sp,sp,-16
    54d0:	dfc00315 	stw	ra,12(sp)
    54d4:	df000215 	stw	fp,8(sp)
    54d8:	df000204 	addi	fp,sp,8
    54dc:	e13ffe15 	stw	r4,-8(fp)
    54e0:	e17fff15 	stw	r5,-4(fp)
  icmp_send_response(p, ICMP_TE, t);
    54e4:	e0bfff17 	ldw	r2,-4(fp)
    54e8:	10803fcc 	andi	r2,r2,255
    54ec:	e13ffe17 	ldw	r4,-8(fp)
    54f0:	014002c4 	movi	r5,11
    54f4:	100d883a 	mov	r6,r2
    54f8:	00055100 	call	5510 <icmp_send_response>
}
    54fc:	e037883a 	mov	sp,fp
    5500:	dfc00117 	ldw	ra,4(sp)
    5504:	df000017 	ldw	fp,0(sp)
    5508:	dec00204 	addi	sp,sp,8
    550c:	f800283a 	ret

00005510 <icmp_send_response>:
 * @param type Type of the ICMP header
 * @param code Code of the ICMP header
 */
static void
icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
{
    5510:	defff604 	addi	sp,sp,-40
    5514:	dfc00915 	stw	ra,36(sp)
    5518:	df000815 	stw	fp,32(sp)
    551c:	df000804 	addi	fp,sp,32
    5520:	e13ffd15 	stw	r4,-12(fp)
    5524:	2807883a 	mov	r3,r5
    5528:	3005883a 	mov	r2,r6
    552c:	e0fffe05 	stb	r3,-8(fp)
    5530:	e0bfff05 	stb	r2,-4(fp)
  struct ip_hdr *iphdr;
  /* we can use the echo header here */
  struct icmp_echo_hdr *icmphdr;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
    5534:	01000044 	movi	r4,1
    5538:	01400904 	movi	r5,36
    553c:	000d883a 	mov	r6,zero
    5540:	00097cc0 	call	97cc <pbuf_alloc>
    5544:	e0bffa15 	stw	r2,-24(fp)
                 PBUF_RAM);
  if (q == NULL) {
    5548:	e0bffa17 	ldw	r2,-24(fp)
    554c:	1000041e 	bne	r2,zero,5560 <icmp_send_response+0x50>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    5550:	010000f4 	movhi	r4,3
    5554:	21396a04 	addi	r4,r4,-6744
    5558:	00172f80 	call	172f8 <puts>
    return;
    555c:	00008306 	br	576c <icmp_send_response+0x25c>
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
    5560:	e0bffa17 	ldw	r2,-24(fp)
    5564:	1080028b 	ldhu	r2,10(r2)
    5568:	10bfffcc 	andi	r2,r2,65535
    556c:	10800928 	cmpgeui	r2,r2,36
    5570:	1000091e 	bne	r2,zero,5598 <icmp_send_response+0x88>
    5574:	010000f4 	movhi	r4,3
    5578:	21391404 	addi	r4,r4,-7088
    557c:	014000f4 	movhi	r5,3
    5580:	29797a04 	addi	r5,r5,-6680
    5584:	01804b04 	movi	r6,300
    5588:	01c000f4 	movhi	r7,3
    558c:	39f92b04 	addi	r7,r7,-6996
    5590:	00170680 	call	17068 <printf>
    5594:	003fff06 	br	5594 <icmp_send_response+0x84>
             (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
    5598:	e0bffd17 	ldw	r2,-12(fp)
    559c:	10800117 	ldw	r2,4(r2)
    55a0:	e0bffb15 	stw	r2,-20(fp)
  LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded from "));
    55a4:	010000f4 	movhi	r4,3
    55a8:	21398504 	addi	r4,r4,-6636
    55ac:	00170680 	call	17068 <printf>
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
    55b0:	e0bffb17 	ldw	r2,-20(fp)
    55b4:	10800304 	addi	r2,r2,12
    55b8:	10001526 	beq	r2,zero,5610 <icmp_send_response+0x100>
    55bc:	e0bffb17 	ldw	r2,-20(fp)
    55c0:	10c0030b 	ldhu	r3,12(r2)
    55c4:	1080038b 	ldhu	r2,14(r2)
    55c8:	1004943a 	slli	r2,r2,16
    55cc:	10c4b03a 	or	r2,r2,r3
    55d0:	1004d63a 	srli	r2,r2,24
    55d4:	10803fcc 	andi	r2,r2,255
    55d8:	1007883a 	mov	r3,r2
    55dc:	e0bffb17 	ldw	r2,-20(fp)
    55e0:	1100030b 	ldhu	r4,12(r2)
    55e4:	1080038b 	ldhu	r2,14(r2)
    55e8:	1004943a 	slli	r2,r2,16
    55ec:	1104b03a 	or	r2,r2,r4
    55f0:	1004d23a 	srli	r2,r2,8
    55f4:	1009883a 	mov	r4,r2
    55f8:	00bfc004 	movi	r2,-256
    55fc:	2084703a 	and	r2,r4,r2
    5600:	1884b03a 	or	r2,r3,r2
    5604:	10bfffcc 	andi	r2,r2,65535
    5608:	10803fcc 	andi	r2,r2,255
    560c:	00000106 	br	5614 <icmp_send_response+0x104>
    5610:	0005883a 	mov	r2,zero
    5614:	1009883a 	mov	r4,r2
    5618:	00170680 	call	17068 <printf>
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
    561c:	010000f4 	movhi	r4,3
    5620:	21398c04 	addi	r4,r4,-6608
    5624:	00170680 	call	17068 <printf>
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
    5628:	e0bffb17 	ldw	r2,-20(fp)
    562c:	10800404 	addi	r2,r2,16
    5630:	10001526 	beq	r2,zero,5688 <icmp_send_response+0x178>
    5634:	e0bffb17 	ldw	r2,-20(fp)
    5638:	10c0040b 	ldhu	r3,16(r2)
    563c:	1080048b 	ldhu	r2,18(r2)
    5640:	1004943a 	slli	r2,r2,16
    5644:	10c4b03a 	or	r2,r2,r3
    5648:	1004d63a 	srli	r2,r2,24
    564c:	10803fcc 	andi	r2,r2,255
    5650:	1007883a 	mov	r3,r2
    5654:	e0bffb17 	ldw	r2,-20(fp)
    5658:	1100040b 	ldhu	r4,16(r2)
    565c:	1080048b 	ldhu	r2,18(r2)
    5660:	1004943a 	slli	r2,r2,16
    5664:	1104b03a 	or	r2,r2,r4
    5668:	1004d23a 	srli	r2,r2,8
    566c:	1009883a 	mov	r4,r2
    5670:	00bfc004 	movi	r2,-256
    5674:	2084703a 	and	r2,r4,r2
    5678:	1884b03a 	or	r2,r3,r2
    567c:	10bfffcc 	andi	r2,r2,65535
    5680:	10803fcc 	andi	r2,r2,255
    5684:	00000106 	br	568c <icmp_send_response+0x17c>
    5688:	0005883a 	mov	r2,zero
    568c:	1009883a 	mov	r4,r2
    5690:	00170680 	call	17068 <printf>
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));
    5694:	01000284 	movi	r4,10
    5698:	00172580 	call	17258 <putchar>

  icmphdr = q->payload;
    569c:	e0bffa17 	ldw	r2,-24(fp)
    56a0:	10800117 	ldw	r2,4(r2)
    56a4:	e0bffc15 	stw	r2,-16(fp)
  icmphdr->type = type;
    56a8:	e0bffc17 	ldw	r2,-16(fp)
    56ac:	e0fffe03 	ldbu	r3,-8(fp)
    56b0:	10c00005 	stb	r3,0(r2)
  icmphdr->code = code;
    56b4:	e0bffc17 	ldw	r2,-16(fp)
    56b8:	e0ffff03 	ldbu	r3,-4(fp)
    56bc:	10c00045 	stb	r3,1(r2)
  icmphdr->id = 0;
    56c0:	e0bffc17 	ldw	r2,-16(fp)
    56c4:	1000010d 	sth	zero,4(r2)
  icmphdr->seqno = 0;
    56c8:	e0bffc17 	ldw	r2,-16(fp)
    56cc:	1000018d 	sth	zero,6(r2)

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
    56d0:	e0bffa17 	ldw	r2,-24(fp)
    56d4:	10800117 	ldw	r2,4(r2)
    56d8:	10c00204 	addi	r3,r2,8
    56dc:	e0bffd17 	ldw	r2,-12(fp)
    56e0:	10800117 	ldw	r2,4(r2)
    56e4:	1809883a 	mov	r4,r3
    56e8:	100b883a 	mov	r5,r2
    56ec:	01800704 	movi	r6,28
    56f0:	0016e680 	call	16e68 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  icmphdr->chksum = 0;
    56f4:	e0bffc17 	ldw	r2,-16(fp)
    56f8:	1000008d 	sth	zero,2(r2)
  icmphdr->chksum = inet_chksum(icmphdr, q->len);
    56fc:	e0bffa17 	ldw	r2,-24(fp)
    5700:	1080028b 	ldhu	r2,10(r2)
    5704:	10bfffcc 	andi	r2,r2,65535
    5708:	e13ffc17 	ldw	r4,-16(fp)
    570c:	100b883a 	mov	r5,r2
    5710:	00060600 	call	6060 <inet_chksum>
    5714:	e0fffc17 	ldw	r3,-16(fp)
    5718:	1880008d 	sth	r2,2(r3)
  ICMP_STATS_INC(icmp.xmit);
    571c:	00800134 	movhi	r2,4
    5720:	10916104 	addi	r2,r2,17796
    5724:	1080180b 	ldhu	r2,96(r2)
    5728:	10800044 	addi	r2,r2,1
    572c:	1007883a 	mov	r3,r2
    5730:	00800134 	movhi	r2,4
    5734:	10916104 	addi	r2,r2,17796
    5738:	10c0180d 	sth	r3,96(r2)
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
    573c:	e0bffb17 	ldw	r2,-20(fp)
    5740:	10800304 	addi	r2,r2,12
    5744:	d8000015 	stw	zero,0(sp)
    5748:	00c00044 	movi	r3,1
    574c:	d8c00115 	stw	r3,4(sp)
    5750:	e13ffa17 	ldw	r4,-24(fp)
    5754:	000b883a 	mov	r5,zero
    5758:	100d883a 	mov	r6,r2
    575c:	01c03fc4 	movi	r7,255
    5760:	0006d180 	call	6d18 <ip_output>
  pbuf_free(q);
    5764:	e13ffa17 	ldw	r4,-24(fp)
    5768:	000a1880 	call	a188 <pbuf_free>
}
    576c:	e037883a 	mov	sp,fp
    5770:	dfc00117 	ldw	ra,4(sp)
    5774:	df000017 	ldw	fp,0(sp)
    5778:	dec00204 	addi	sp,sp,8
    577c:	f800283a 	ret

00005780 <inet_addr>:
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @return ip address in network order
 */
u32_t
inet_addr(const char *cp)
{
    5780:	defffc04 	addi	sp,sp,-16
    5784:	dfc00315 	stw	ra,12(sp)
    5788:	df000215 	stw	fp,8(sp)
    578c:	df000204 	addi	fp,sp,8
    5790:	e13fff15 	stw	r4,-4(fp)
  struct in_addr val;

  if (inet_aton(cp, &val)) {
    5794:	e13fff17 	ldw	r4,-4(fp)
    5798:	e17ffe04 	addi	r5,fp,-8
    579c:	00057c40 	call	57c4 <inet_aton>
    57a0:	10000226 	beq	r2,zero,57ac <inet_addr+0x2c>
    return (val.s_addr);
    57a4:	e0bffe17 	ldw	r2,-8(fp)
    57a8:	00000106 	br	57b0 <inet_addr+0x30>
  }
  return (INADDR_NONE);
    57ac:	00bfffc4 	movi	r2,-1
}
    57b0:	e037883a 	mov	sp,fp
    57b4:	dfc00117 	ldw	ra,4(sp)
    57b8:	df000017 	ldw	fp,0(sp)
    57bc:	dec00204 	addi	sp,sp,8
    57c0:	f800283a 	ret

000057c4 <inet_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
inet_aton(const char *cp, struct in_addr *addr)
{
    57c4:	defff604 	addi	sp,sp,-40
    57c8:	df000915 	stw	fp,36(sp)
    57cc:	df000904 	addi	fp,sp,36
    57d0:	e13ffe15 	stw	r4,-8(fp)
    57d4:	e17fff15 	stw	r5,-4(fp)
  u32_t val;
  u8_t base;
  char c;
  u32_t parts[4];
  u32_t *pp = parts;
    57d8:	e0bffa04 	addi	r2,fp,-24
    57dc:	e0bff915 	stw	r2,-28(fp)

  c = *cp;
    57e0:	e0bffe17 	ldw	r2,-8(fp)
    57e4:	10800003 	ldbu	r2,0(r2)
    57e8:	e0bff845 	stb	r2,-31(fp)
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
    57ec:	e0bff843 	ldbu	r2,-31(fp)
    57f0:	10803fcc 	andi	r2,r2,255
    57f4:	10800c30 	cmpltui	r2,r2,48
    57f8:	1000041e 	bne	r2,zero,580c <inet_aton+0x48>
    57fc:	e0bff843 	ldbu	r2,-31(fp)
    5800:	10803fcc 	andi	r2,r2,255
    5804:	10800eb0 	cmpltui	r2,r2,58
    5808:	1000021e 	bne	r2,zero,5814 <inet_aton+0x50>
      return (0);
    580c:	0005883a 	mov	r2,zero
    5810:	0000e606 	br	5bac <inet_aton+0x3e8>
    val = 0;
    5814:	e03ff715 	stw	zero,-36(fp)
    base = 10;
    5818:	00800284 	movi	r2,10
    581c:	e0bff805 	stb	r2,-32(fp)
    if (c == '0') {
    5820:	e0bff847 	ldb	r2,-31(fp)
    5824:	10800c18 	cmpnei	r2,r2,48
    5828:	1000171e 	bne	r2,zero,5888 <inet_aton+0xc4>
      c = *++cp;
    582c:	e0bffe17 	ldw	r2,-8(fp)
    5830:	10800044 	addi	r2,r2,1
    5834:	e0bffe15 	stw	r2,-8(fp)
    5838:	e0bffe17 	ldw	r2,-8(fp)
    583c:	10800003 	ldbu	r2,0(r2)
    5840:	e0bff845 	stb	r2,-31(fp)
      if (c == 'x' || c == 'X') {
    5844:	e0bff847 	ldb	r2,-31(fp)
    5848:	10801e20 	cmpeqi	r2,r2,120
    584c:	1000031e 	bne	r2,zero,585c <inet_aton+0x98>
    5850:	e0bff847 	ldb	r2,-31(fp)
    5854:	10801618 	cmpnei	r2,r2,88
    5858:	1000091e 	bne	r2,zero,5880 <inet_aton+0xbc>
        base = 16;
    585c:	00800404 	movi	r2,16
    5860:	e0bff805 	stb	r2,-32(fp)
        c = *++cp;
    5864:	e0bffe17 	ldw	r2,-8(fp)
    5868:	10800044 	addi	r2,r2,1
    586c:	e0bffe15 	stw	r2,-8(fp)
    5870:	e0bffe17 	ldw	r2,-8(fp)
    5874:	10800003 	ldbu	r2,0(r2)
    5878:	e0bff845 	stb	r2,-31(fp)
    587c:	00000206 	br	5888 <inet_aton+0xc4>
      } else
        base = 8;
    5880:	00800204 	movi	r2,8
    5884:	e0bff805 	stb	r2,-32(fp)
    }
    for (;;) {
      if (isdigit(c)) {
    5888:	e0bff843 	ldbu	r2,-31(fp)
    588c:	10803fcc 	andi	r2,r2,255
    5890:	10800c30 	cmpltui	r2,r2,48
    5894:	1000121e 	bne	r2,zero,58e0 <inet_aton+0x11c>
    5898:	e0bff843 	ldbu	r2,-31(fp)
    589c:	10803fcc 	andi	r2,r2,255
    58a0:	10800ea8 	cmpgeui	r2,r2,58
    58a4:	10000e1e 	bne	r2,zero,58e0 <inet_aton+0x11c>
        val = (val * base) + (int)(c - '0');
    58a8:	e0fff803 	ldbu	r3,-32(fp)
    58ac:	e0bff717 	ldw	r2,-36(fp)
    58b0:	1887383a 	mul	r3,r3,r2
    58b4:	e0bff847 	ldb	r2,-31(fp)
    58b8:	1885883a 	add	r2,r3,r2
    58bc:	10bff404 	addi	r2,r2,-48
    58c0:	e0bff715 	stw	r2,-36(fp)
        c = *++cp;
    58c4:	e0bffe17 	ldw	r2,-8(fp)
    58c8:	10800044 	addi	r2,r2,1
    58cc:	e0bffe15 	stw	r2,-8(fp)
    58d0:	e0bffe17 	ldw	r2,-8(fp)
    58d4:	10800003 	ldbu	r2,0(r2)
    58d8:	e0bff845 	stb	r2,-31(fp)
      } else if (base == 16 && isxdigit(c)) {
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
        c = *++cp;
      } else
        break;
    }
    58dc:	003fea06 	br	5888 <inet_aton+0xc4>
    }
    for (;;) {
      if (isdigit(c)) {
        val = (val * base) + (int)(c - '0');
        c = *++cp;
      } else if (base == 16 && isxdigit(c)) {
    58e0:	e0bff803 	ldbu	r2,-32(fp)
    58e4:	10800418 	cmpnei	r2,r2,16
    58e8:	1000311e 	bne	r2,zero,59b0 <inet_aton+0x1ec>
    58ec:	e0bff843 	ldbu	r2,-31(fp)
    58f0:	10803fcc 	andi	r2,r2,255
    58f4:	10800c30 	cmpltui	r2,r2,48
    58f8:	1000041e 	bne	r2,zero,590c <inet_aton+0x148>
    58fc:	e0bff843 	ldbu	r2,-31(fp)
    5900:	10803fcc 	andi	r2,r2,255
    5904:	10800eb0 	cmpltui	r2,r2,58
    5908:	1000101e 	bne	r2,zero,594c <inet_aton+0x188>
    590c:	e0bff843 	ldbu	r2,-31(fp)
    5910:	10803fcc 	andi	r2,r2,255
    5914:	10801870 	cmpltui	r2,r2,97
    5918:	1000041e 	bne	r2,zero,592c <inet_aton+0x168>
    591c:	e0bff843 	ldbu	r2,-31(fp)
    5920:	10803fcc 	andi	r2,r2,255
    5924:	108019f0 	cmpltui	r2,r2,103
    5928:	1000081e 	bne	r2,zero,594c <inet_aton+0x188>
    592c:	e0bff843 	ldbu	r2,-31(fp)
    5930:	10803fcc 	andi	r2,r2,255
    5934:	10801070 	cmpltui	r2,r2,65
    5938:	10001d1e 	bne	r2,zero,59b0 <inet_aton+0x1ec>
    593c:	e0bff843 	ldbu	r2,-31(fp)
    5940:	10803fcc 	andi	r2,r2,255
    5944:	108011e8 	cmpgeui	r2,r2,71
    5948:	1000191e 	bne	r2,zero,59b0 <inet_aton+0x1ec>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
    594c:	e0bff717 	ldw	r2,-36(fp)
    5950:	1006913a 	slli	r3,r2,4
    5954:	e0bff847 	ldb	r2,-31(fp)
    5958:	11000284 	addi	r4,r2,10
    595c:	e0bff843 	ldbu	r2,-31(fp)
    5960:	10803fcc 	andi	r2,r2,255
    5964:	10801870 	cmpltui	r2,r2,97
    5968:	1000061e 	bne	r2,zero,5984 <inet_aton+0x1c0>
    596c:	e0bff843 	ldbu	r2,-31(fp)
    5970:	10803fcc 	andi	r2,r2,255
    5974:	10801ee8 	cmpgeui	r2,r2,123
    5978:	1000021e 	bne	r2,zero,5984 <inet_aton+0x1c0>
    597c:	00801844 	movi	r2,97
    5980:	00000106 	br	5988 <inet_aton+0x1c4>
    5984:	00801044 	movi	r2,65
    5988:	2085c83a 	sub	r2,r4,r2
    598c:	1884b03a 	or	r2,r3,r2
    5990:	e0bff715 	stw	r2,-36(fp)
        c = *++cp;
    5994:	e0bffe17 	ldw	r2,-8(fp)
    5998:	10800044 	addi	r2,r2,1
    599c:	e0bffe15 	stw	r2,-8(fp)
    59a0:	e0bffe17 	ldw	r2,-8(fp)
    59a4:	10800003 	ldbu	r2,0(r2)
    59a8:	e0bff845 	stb	r2,-31(fp)
      } else
        break;
    }
    59ac:	003fb606 	br	5888 <inet_aton+0xc4>
    if (c == '.') {
    59b0:	e0bff847 	ldb	r2,-31(fp)
    59b4:	10800b98 	cmpnei	r2,r2,46
    59b8:	1000131e 	bne	r2,zero,5a08 <inet_aton+0x244>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
    59bc:	e0bffa04 	addi	r2,fp,-24
    59c0:	10800304 	addi	r2,r2,12
    59c4:	e0fff917 	ldw	r3,-28(fp)
    59c8:	18800236 	bltu	r3,r2,59d4 <inet_aton+0x210>
        return (0);
    59cc:	0005883a 	mov	r2,zero
    59d0:	00007606 	br	5bac <inet_aton+0x3e8>
      *pp++ = val;
    59d4:	e0bff917 	ldw	r2,-28(fp)
    59d8:	e0fff717 	ldw	r3,-36(fp)
    59dc:	10c00015 	stw	r3,0(r2)
    59e0:	e0bff917 	ldw	r2,-28(fp)
    59e4:	10800104 	addi	r2,r2,4
    59e8:	e0bff915 	stw	r2,-28(fp)
      c = *++cp;
    59ec:	e0bffe17 	ldw	r2,-8(fp)
    59f0:	10800044 	addi	r2,r2,1
    59f4:	e0bffe15 	stw	r2,-8(fp)
    59f8:	e0bffe17 	ldw	r2,-8(fp)
    59fc:	10800003 	ldbu	r2,0(r2)
    5a00:	e0bff845 	stb	r2,-31(fp)
    } else
      break;
  }
    5a04:	003f7906 	br	57ec <inet_aton+0x28>
      if (pp >= parts + 3)
        return (0);
      *pp++ = val;
      c = *++cp;
    } else
      break;
    5a08:	0001883a 	nop
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && !isspace(c))
    5a0c:	e0bff847 	ldb	r2,-31(fp)
    5a10:	10001426 	beq	r2,zero,5a64 <inet_aton+0x2a0>
    5a14:	e0bff847 	ldb	r2,-31(fp)
    5a18:	10800820 	cmpeqi	r2,r2,32
    5a1c:	1000111e 	bne	r2,zero,5a64 <inet_aton+0x2a0>
    5a20:	e0bff847 	ldb	r2,-31(fp)
    5a24:	10800320 	cmpeqi	r2,r2,12
    5a28:	10000e1e 	bne	r2,zero,5a64 <inet_aton+0x2a0>
    5a2c:	e0bff847 	ldb	r2,-31(fp)
    5a30:	108002a0 	cmpeqi	r2,r2,10
    5a34:	10000b1e 	bne	r2,zero,5a64 <inet_aton+0x2a0>
    5a38:	e0bff847 	ldb	r2,-31(fp)
    5a3c:	10800360 	cmpeqi	r2,r2,13
    5a40:	1000081e 	bne	r2,zero,5a64 <inet_aton+0x2a0>
    5a44:	e0bff847 	ldb	r2,-31(fp)
    5a48:	10800260 	cmpeqi	r2,r2,9
    5a4c:	1000051e 	bne	r2,zero,5a64 <inet_aton+0x2a0>
    5a50:	e0bff847 	ldb	r2,-31(fp)
    5a54:	108002e0 	cmpeqi	r2,r2,11
    5a58:	1000021e 	bne	r2,zero,5a64 <inet_aton+0x2a0>
    return (0);
    5a5c:	0005883a 	mov	r2,zero
    5a60:	00005206 	br	5bac <inet_aton+0x3e8>
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  switch (pp - parts + 1) {
    5a64:	e0fff917 	ldw	r3,-28(fp)
    5a68:	e0bffa04 	addi	r2,fp,-24
    5a6c:	1885c83a 	sub	r2,r3,r2
    5a70:	1005d0ba 	srai	r2,r2,2
    5a74:	10800044 	addi	r2,r2,1
    5a78:	10c00168 	cmpgeui	r3,r2,5
    5a7c:	1800391e 	bne	r3,zero,5b64 <inet_aton+0x3a0>
    5a80:	1085883a 	add	r2,r2,r2
    5a84:	1087883a 	add	r3,r2,r2
    5a88:	00800034 	movhi	r2,0
    5a8c:	1096a704 	addi	r2,r2,23196
    5a90:	1885883a 	add	r2,r3,r2
    5a94:	10800017 	ldw	r2,0(r2)
    5a98:	1000683a 	jmp	r2
    5a9c:	00005ab0 	cmpltui	zero,zero,362
    5aa0:	00005b60 	cmpeqi	zero,zero,365
    5aa4:	00005ab8 	rdprs	zero,zero,362
    5aa8:	00005ae4 	muli	zero,zero,363
    5aac:	00005b1c 	xori	zero,zero,364

  case 0:
    return (0);       /* initial nondigit */
    5ab0:	0005883a 	mov	r2,zero
    5ab4:	00003d06 	br	5bac <inet_aton+0x3e8>

  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL)
    5ab8:	e0fff717 	ldw	r3,-36(fp)
    5abc:	00804034 	movhi	r2,256
    5ac0:	18800236 	bltu	r3,r2,5acc <inet_aton+0x308>
      return (0);
    5ac4:	0005883a 	mov	r2,zero
    5ac8:	00003806 	br	5bac <inet_aton+0x3e8>
    val |= parts[0] << 24;
    5acc:	e0bffa17 	ldw	r2,-24(fp)
    5ad0:	1004963a 	slli	r2,r2,24
    5ad4:	e0fff717 	ldw	r3,-36(fp)
    5ad8:	1884b03a 	or	r2,r3,r2
    5adc:	e0bff715 	stw	r2,-36(fp)
    break;
    5ae0:	00002006 	br	5b64 <inet_aton+0x3a0>

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff)
    5ae4:	e0bff717 	ldw	r2,-36(fp)
    5ae8:	00ffffd4 	movui	r3,65535
    5aec:	1880022e 	bgeu	r3,r2,5af8 <inet_aton+0x334>
      return (0);
    5af0:	0005883a 	mov	r2,zero
    5af4:	00002d06 	br	5bac <inet_aton+0x3e8>
    val |= (parts[0] << 24) | (parts[1] << 16);
    5af8:	e0bffa17 	ldw	r2,-24(fp)
    5afc:	1006963a 	slli	r3,r2,24
    5b00:	e0bffb17 	ldw	r2,-20(fp)
    5b04:	1004943a 	slli	r2,r2,16
    5b08:	1884b03a 	or	r2,r3,r2
    5b0c:	e0fff717 	ldw	r3,-36(fp)
    5b10:	1884b03a 	or	r2,r3,r2
    5b14:	e0bff715 	stw	r2,-36(fp)
    break;
    5b18:	00001206 	br	5b64 <inet_aton+0x3a0>

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff)
    5b1c:	e0bff717 	ldw	r2,-36(fp)
    5b20:	10804030 	cmpltui	r2,r2,256
    5b24:	1000021e 	bne	r2,zero,5b30 <inet_aton+0x36c>
      return (0);
    5b28:	0005883a 	mov	r2,zero
    5b2c:	00001f06 	br	5bac <inet_aton+0x3e8>
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
    5b30:	e0bffa17 	ldw	r2,-24(fp)
    5b34:	1006963a 	slli	r3,r2,24
    5b38:	e0bffb17 	ldw	r2,-20(fp)
    5b3c:	1004943a 	slli	r2,r2,16
    5b40:	1886b03a 	or	r3,r3,r2
    5b44:	e0bffc17 	ldw	r2,-16(fp)
    5b48:	1004923a 	slli	r2,r2,8
    5b4c:	1884b03a 	or	r2,r3,r2
    5b50:	e0fff717 	ldw	r3,-36(fp)
    5b54:	1884b03a 	or	r2,r3,r2
    5b58:	e0bff715 	stw	r2,-36(fp)
    break;
    5b5c:	00000106 	br	5b64 <inet_aton+0x3a0>

  case 0:
    return (0);       /* initial nondigit */

  case 1:             /* a -- 32 bits */
    break;
    5b60:	0001883a 	nop
    if (val > 0xff)
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
    break;
  }
  if (addr)
    5b64:	e0bfff17 	ldw	r2,-4(fp)
    5b68:	10000f26 	beq	r2,zero,5ba8 <inet_aton+0x3e4>
    addr->s_addr = htonl(val);
    5b6c:	e0bff717 	ldw	r2,-36(fp)
    5b70:	1006d63a 	srli	r3,r2,24
    5b74:	e0bff717 	ldw	r2,-36(fp)
    5b78:	1004d23a 	srli	r2,r2,8
    5b7c:	10bfc00c 	andi	r2,r2,65280
    5b80:	1886b03a 	or	r3,r3,r2
    5b84:	e0bff717 	ldw	r2,-36(fp)
    5b88:	10bfc00c 	andi	r2,r2,65280
    5b8c:	1004923a 	slli	r2,r2,8
    5b90:	1886b03a 	or	r3,r3,r2
    5b94:	e0bff717 	ldw	r2,-36(fp)
    5b98:	1004963a 	slli	r2,r2,24
    5b9c:	1886b03a 	or	r3,r3,r2
    5ba0:	e0bfff17 	ldw	r2,-4(fp)
    5ba4:	10c00015 	stw	r3,0(r2)
  return (1);
    5ba8:	00800044 	movi	r2,1
}
    5bac:	e037883a 	mov	sp,fp
    5bb0:	df000017 	ldw	fp,0(sp)
    5bb4:	dec00104 	addi	sp,sp,4
    5bb8:	f800283a 	ret

00005bbc <inet_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
{
    5bbc:	defff904 	addi	sp,sp,-28
    5bc0:	df000615 	stw	fp,24(sp)
    5bc4:	df000604 	addi	fp,sp,24
    5bc8:	e13fff15 	stw	r4,-4(fp)
  static char str[16];
  u32_t s_addr = addr.s_addr;
    5bcc:	e0bfff17 	ldw	r2,-4(fp)
    5bd0:	e0bffd15 	stw	r2,-12(fp)
  u8_t *ap;
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
    5bd4:	008000f4 	movhi	r2,3
    5bd8:	1099e504 	addi	r2,r2,26516
    5bdc:	e0bffa15 	stw	r2,-24(fp)
  ap = (u8_t *)&s_addr;
    5be0:	e0bffd04 	addi	r2,fp,-12
    5be4:	e0bffb15 	stw	r2,-20(fp)
  for(n = 0; n < 4; n++) {
    5be8:	e03ffc05 	stb	zero,-16(fp)
    5bec:	00003b06 	br	5cdc <inet_ntoa+0x120>
    i = 0;
    5bf0:	e03ffc45 	stb	zero,-15(fp)
    do {
      rem = *ap % (u8_t)10;
    5bf4:	e0bffb17 	ldw	r2,-20(fp)
    5bf8:	10800003 	ldbu	r2,0(r2)
    5bfc:	10803fcc 	andi	r2,r2,255
    5c00:	00c00284 	movi	r3,10
    5c04:	10c7203a 	divu	r3,r2,r3
    5c08:	18c002a4 	muli	r3,r3,10
    5c0c:	10c5c83a 	sub	r2,r2,r3
    5c10:	e0bffc85 	stb	r2,-14(fp)
      *ap /= (u8_t)10;
    5c14:	e0bffb17 	ldw	r2,-20(fp)
    5c18:	10800003 	ldbu	r2,0(r2)
    5c1c:	10c03fcc 	andi	r3,r2,255
    5c20:	00800284 	movi	r2,10
    5c24:	1885203a 	divu	r2,r3,r2
    5c28:	1007883a 	mov	r3,r2
    5c2c:	e0bffb17 	ldw	r2,-20(fp)
    5c30:	10c00005 	stb	r3,0(r2)
      inv[i++] = '0' + rem;
    5c34:	e0bffc43 	ldbu	r2,-15(fp)
    5c38:	e0fffc83 	ldbu	r3,-14(fp)
    5c3c:	18c00c04 	addi	r3,r3,48
    5c40:	e13ffe04 	addi	r4,fp,-8
    5c44:	2085883a 	add	r2,r4,r2
    5c48:	10c00005 	stb	r3,0(r2)
    5c4c:	e0bffc43 	ldbu	r2,-15(fp)
    5c50:	10800044 	addi	r2,r2,1
    5c54:	e0bffc45 	stb	r2,-15(fp)
    } while(*ap);
    5c58:	e0bffb17 	ldw	r2,-20(fp)
    5c5c:	10800003 	ldbu	r2,0(r2)
    5c60:	10803fcc 	andi	r2,r2,255
    5c64:	103fe31e 	bne	r2,zero,5bf4 <inet_ntoa+0x38>
    while(i--)
    5c68:	00000906 	br	5c90 <inet_ntoa+0xd4>
      *rp++ = inv[i];
    5c6c:	e0bffc43 	ldbu	r2,-15(fp)
    5c70:	e0fffe04 	addi	r3,fp,-8
    5c74:	1885883a 	add	r2,r3,r2
    5c78:	10c00003 	ldbu	r3,0(r2)
    5c7c:	e0bffa17 	ldw	r2,-24(fp)
    5c80:	10c00005 	stb	r3,0(r2)
    5c84:	e0bffa17 	ldw	r2,-24(fp)
    5c88:	10800044 	addi	r2,r2,1
    5c8c:	e0bffa15 	stw	r2,-24(fp)
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
    5c90:	e0bffc43 	ldbu	r2,-15(fp)
    5c94:	1004c03a 	cmpne	r2,r2,zero
    5c98:	e0fffc43 	ldbu	r3,-15(fp)
    5c9c:	18ffffc4 	addi	r3,r3,-1
    5ca0:	e0fffc45 	stb	r3,-15(fp)
    5ca4:	10803fcc 	andi	r2,r2,255
    5ca8:	103ff01e 	bne	r2,zero,5c6c <inet_ntoa+0xb0>
      *rp++ = inv[i];
    *rp++ = '.';
    5cac:	e0bffa17 	ldw	r2,-24(fp)
    5cb0:	00c00b84 	movi	r3,46
    5cb4:	10c00005 	stb	r3,0(r2)
    5cb8:	e0bffa17 	ldw	r2,-24(fp)
    5cbc:	10800044 	addi	r2,r2,1
    5cc0:	e0bffa15 	stw	r2,-24(fp)
    ap++;
    5cc4:	e0bffb17 	ldw	r2,-20(fp)
    5cc8:	10800044 	addi	r2,r2,1
    5ccc:	e0bffb15 	stw	r2,-20(fp)
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
    5cd0:	e0bffc03 	ldbu	r2,-16(fp)
    5cd4:	10800044 	addi	r2,r2,1
    5cd8:	e0bffc05 	stb	r2,-16(fp)
    5cdc:	e0bffc03 	ldbu	r2,-16(fp)
    5ce0:	10800130 	cmpltui	r2,r2,4
    5ce4:	103fc21e 	bne	r2,zero,5bf0 <inet_ntoa+0x34>
    while(i--)
      *rp++ = inv[i];
    *rp++ = '.';
    ap++;
  }
  *--rp = 0;
    5ce8:	e0bffa17 	ldw	r2,-24(fp)
    5cec:	10bfffc4 	addi	r2,r2,-1
    5cf0:	e0bffa15 	stw	r2,-24(fp)
    5cf4:	e0bffa17 	ldw	r2,-24(fp)
    5cf8:	10000005 	stb	zero,0(r2)
  return str;
    5cfc:	008000f4 	movhi	r2,3
    5d00:	1099e504 	addi	r2,r2,26516
}
    5d04:	e037883a 	mov	sp,fp
    5d08:	df000017 	ldw	fp,0(sp)
    5d0c:	dec00104 	addi	sp,sp,4
    5d10:	f800283a 	ret

00005d14 <lwip_standard_chksum>:
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
{
    5d14:	defffa04 	addi	sp,sp,-24
    5d18:	df000515 	stw	fp,20(sp)
    5d1c:	df000504 	addi	fp,sp,20
    5d20:	e13ffe15 	stw	r4,-8(fp)
    5d24:	2805883a 	mov	r2,r5
    5d28:	e0bfff0d 	sth	r2,-4(fp)
  u32_t acc;
  u16_t src;
  u8_t *octetptr;

  acc = 0;
    5d2c:	e03ffb15 	stw	zero,-20(fp)
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
    5d30:	e0bffe17 	ldw	r2,-8(fp)
    5d34:	e0bffc15 	stw	r2,-16(fp)
  while (len > 1) {
    5d38:	00001806 	br	5d9c <lwip_standard_chksum+0x88>
    /* declare first octet as most significant
       thus assume network order, ignoring host order */
    src = (*octetptr) << 8;
    5d3c:	e0bffc17 	ldw	r2,-16(fp)
    5d40:	10800003 	ldbu	r2,0(r2)
    5d44:	10803fcc 	andi	r2,r2,255
    5d48:	1004923a 	slli	r2,r2,8
    5d4c:	e0bffd0d 	sth	r2,-12(fp)
    octetptr++;
    5d50:	e0bffc17 	ldw	r2,-16(fp)
    5d54:	10800044 	addi	r2,r2,1
    5d58:	e0bffc15 	stw	r2,-16(fp)
    /* declare second octet as least significant */
    src |= (*octetptr);
    5d5c:	e0bffc17 	ldw	r2,-16(fp)
    5d60:	10800003 	ldbu	r2,0(r2)
    5d64:	10c03fcc 	andi	r3,r2,255
    5d68:	e0bffd0b 	ldhu	r2,-12(fp)
    5d6c:	1884b03a 	or	r2,r3,r2
    5d70:	e0bffd0d 	sth	r2,-12(fp)
    octetptr++;
    5d74:	e0bffc17 	ldw	r2,-16(fp)
    5d78:	10800044 	addi	r2,r2,1
    5d7c:	e0bffc15 	stw	r2,-16(fp)
    acc += src;
    5d80:	e0bffd0b 	ldhu	r2,-12(fp)
    5d84:	e0fffb17 	ldw	r3,-20(fp)
    5d88:	1885883a 	add	r2,r3,r2
    5d8c:	e0bffb15 	stw	r2,-20(fp)
    len -= 2;
    5d90:	e0bfff0b 	ldhu	r2,-4(fp)
    5d94:	10bfff84 	addi	r2,r2,-2
    5d98:	e0bfff0d 	sth	r2,-4(fp)
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
    5d9c:	e0bfff0b 	ldhu	r2,-4(fp)
    5da0:	108000a8 	cmpgeui	r2,r2,2
    5da4:	103fe51e 	bne	r2,zero,5d3c <lwip_standard_chksum+0x28>
    src |= (*octetptr);
    octetptr++;
    acc += src;
    len -= 2;
  }
  if (len > 0) {
    5da8:	e0bfff0b 	ldhu	r2,-4(fp)
    5dac:	10000926 	beq	r2,zero,5dd4 <lwip_standard_chksum+0xc0>
    /* accumulate remaining octet */
    src = (*octetptr) << 8;
    5db0:	e0bffc17 	ldw	r2,-16(fp)
    5db4:	10800003 	ldbu	r2,0(r2)
    5db8:	10803fcc 	andi	r2,r2,255
    5dbc:	1004923a 	slli	r2,r2,8
    5dc0:	e0bffd0d 	sth	r2,-12(fp)
    acc += src;
    5dc4:	e0bffd0b 	ldhu	r2,-12(fp)
    5dc8:	e0fffb17 	ldw	r3,-20(fp)
    5dcc:	1885883a 	add	r2,r3,r2
    5dd0:	e0bffb15 	stw	r2,-20(fp)
  }
  /* add deferred carry bits */
  acc = (acc >> 16) + (acc & 0x0000ffffUL);
    5dd4:	e0bffb17 	ldw	r2,-20(fp)
    5dd8:	1006d43a 	srli	r3,r2,16
    5ddc:	e0bffb17 	ldw	r2,-20(fp)
    5de0:	10bfffcc 	andi	r2,r2,65535
    5de4:	1885883a 	add	r2,r3,r2
    5de8:	e0bffb15 	stw	r2,-20(fp)
  if ((acc & 0xffff0000UL) != 0) {
    5dec:	e0bffb17 	ldw	r2,-20(fp)
    5df0:	10bfffec 	andhi	r2,r2,65535
    5df4:	10000626 	beq	r2,zero,5e10 <lwip_standard_chksum+0xfc>
    acc = (acc >> 16) + (acc & 0x0000ffffUL);
    5df8:	e0bffb17 	ldw	r2,-20(fp)
    5dfc:	1006d43a 	srli	r3,r2,16
    5e00:	e0bffb17 	ldw	r2,-20(fp)
    5e04:	10bfffcc 	andi	r2,r2,65535
    5e08:	1885883a 	add	r2,r3,r2
    5e0c:	e0bffb15 	stw	r2,-20(fp)
  }
  /* This maybe a little confusing: reorder sum using htons()
     instead of ntohs() since it has a little less call overhead.
     The caller must invert bits for Internet sum ! */
  return htons((u16_t)acc);
    5e10:	e0bffb17 	ldw	r2,-20(fp)
    5e14:	10bfffcc 	andi	r2,r2,65535
    5e18:	1004d23a 	srli	r2,r2,8
    5e1c:	1007883a 	mov	r3,r2
    5e20:	e0bffb17 	ldw	r2,-20(fp)
    5e24:	10bfffcc 	andi	r2,r2,65535
    5e28:	1004923a 	slli	r2,r2,8
    5e2c:	1884b03a 	or	r2,r3,r2
}
    5e30:	e037883a 	mov	sp,fp
    5e34:	df000017 	ldw	fp,0(sp)
    5e38:	dec00104 	addi	sp,sp,4
    5e3c:	f800283a 	ret

00005e40 <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len)
{
    5e40:	defff604 	addi	sp,sp,-40
    5e44:	dfc00915 	stw	ra,36(sp)
    5e48:	df000815 	stw	fp,32(sp)
    5e4c:	df000804 	addi	fp,sp,32
    5e50:	e13ffb15 	stw	r4,-20(fp)
    5e54:	e17ffc15 	stw	r5,-16(fp)
    5e58:	e1bffd15 	stw	r6,-12(fp)
    5e5c:	3805883a 	mov	r2,r7
    5e60:	e0c00217 	ldw	r3,8(fp)
    5e64:	e0bffe05 	stb	r2,-8(fp)
    5e68:	e0ffff0d 	sth	r3,-4(fp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
    5e6c:	e03ff815 	stw	zero,-32(fp)
  swapped = 0;
    5e70:	e03ffa05 	stb	zero,-24(fp)
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
    5e74:	e0bffb17 	ldw	r2,-20(fp)
    5e78:	e0bff915 	stw	r2,-28(fp)
    5e7c:	00002606 	br	5f18 <inet_chksum_pseudo+0xd8>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
    5e80:	e0bff917 	ldw	r2,-28(fp)
    5e84:	10c00117 	ldw	r3,4(r2)
    5e88:	e0bff917 	ldw	r2,-28(fp)
    5e8c:	1080028b 	ldhu	r2,10(r2)
    5e90:	10bfffcc 	andi	r2,r2,65535
    5e94:	1809883a 	mov	r4,r3
    5e98:	100b883a 	mov	r5,r2
    5e9c:	0005d140 	call	5d14 <lwip_standard_chksum>
    5ea0:	10bfffcc 	andi	r2,r2,65535
    5ea4:	e0fff817 	ldw	r3,-32(fp)
    5ea8:	1885883a 	add	r2,r3,r2
    5eac:	e0bff815 	stw	r2,-32(fp)
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
    5eb0:	e0bff817 	ldw	r2,-32(fp)
    5eb4:	1006d43a 	srli	r3,r2,16
    5eb8:	e0bff817 	ldw	r2,-32(fp)
    5ebc:	10bfffcc 	andi	r2,r2,65535
    5ec0:	1885883a 	add	r2,r3,r2
    5ec4:	e0bff815 	stw	r2,-32(fp)
    if (q->len % 2 != 0) {
    5ec8:	e0bff917 	ldw	r2,-28(fp)
    5ecc:	1080028b 	ldhu	r2,10(r2)
    5ed0:	1080004c 	andi	r2,r2,1
    5ed4:	10bfffcc 	andi	r2,r2,65535
    5ed8:	10000c26 	beq	r2,zero,5f0c <inet_chksum_pseudo+0xcc>
      swapped = 1 - swapped;
    5edc:	e0bffa03 	ldbu	r2,-24(fp)
    5ee0:	00c00044 	movi	r3,1
    5ee4:	1885c83a 	sub	r2,r3,r2
    5ee8:	e0bffa05 	stb	r2,-24(fp)
      acc = SWAP_BYTES_IN_WORD(acc);
    5eec:	e0bff817 	ldw	r2,-32(fp)
    5ef0:	10bfc00c 	andi	r2,r2,65280
    5ef4:	1006d23a 	srli	r3,r2,8
    5ef8:	e0bff817 	ldw	r2,-32(fp)
    5efc:	1004923a 	slli	r2,r2,8
    5f00:	10bfffcc 	andi	r2,r2,65535
    5f04:	1884b03a 	or	r2,r3,r2
    5f08:	e0bff815 	stw	r2,-32(fp)
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
    5f0c:	e0bff917 	ldw	r2,-28(fp)
    5f10:	10800017 	ldw	r2,0(r2)
    5f14:	e0bff915 	stw	r2,-28(fp)
    5f18:	e0bff917 	ldw	r2,-28(fp)
    5f1c:	103fd81e 	bne	r2,zero,5e80 <inet_chksum_pseudo+0x40>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
    5f20:	e0bffa03 	ldbu	r2,-24(fp)
    5f24:	10000826 	beq	r2,zero,5f48 <inet_chksum_pseudo+0x108>
    acc = SWAP_BYTES_IN_WORD(acc);
    5f28:	e0bff817 	ldw	r2,-32(fp)
    5f2c:	10bfc00c 	andi	r2,r2,65280
    5f30:	1006d23a 	srli	r3,r2,8
    5f34:	e0bff817 	ldw	r2,-32(fp)
    5f38:	1004923a 	slli	r2,r2,8
    5f3c:	10bfffcc 	andi	r2,r2,65535
    5f40:	1884b03a 	or	r2,r3,r2
    5f44:	e0bff815 	stw	r2,-32(fp)
  }
  acc += (src->addr & 0xffffUL);
    5f48:	e0bffc17 	ldw	r2,-16(fp)
    5f4c:	10c0000b 	ldhu	r3,0(r2)
    5f50:	1080008b 	ldhu	r2,2(r2)
    5f54:	1004943a 	slli	r2,r2,16
    5f58:	10c4b03a 	or	r2,r2,r3
    5f5c:	10bfffcc 	andi	r2,r2,65535
    5f60:	e0fff817 	ldw	r3,-32(fp)
    5f64:	1885883a 	add	r2,r3,r2
    5f68:	e0bff815 	stw	r2,-32(fp)
  acc += ((src->addr >> 16) & 0xffffUL);
    5f6c:	e0bffc17 	ldw	r2,-16(fp)
    5f70:	10c0000b 	ldhu	r3,0(r2)
    5f74:	1080008b 	ldhu	r2,2(r2)
    5f78:	1004943a 	slli	r2,r2,16
    5f7c:	10c4b03a 	or	r2,r2,r3
    5f80:	1004d43a 	srli	r2,r2,16
    5f84:	e0fff817 	ldw	r3,-32(fp)
    5f88:	1885883a 	add	r2,r3,r2
    5f8c:	e0bff815 	stw	r2,-32(fp)
  acc += (dest->addr & 0xffffUL);
    5f90:	e0bffd17 	ldw	r2,-12(fp)
    5f94:	10c0000b 	ldhu	r3,0(r2)
    5f98:	1080008b 	ldhu	r2,2(r2)
    5f9c:	1004943a 	slli	r2,r2,16
    5fa0:	10c4b03a 	or	r2,r2,r3
    5fa4:	10bfffcc 	andi	r2,r2,65535
    5fa8:	e0fff817 	ldw	r3,-32(fp)
    5fac:	1885883a 	add	r2,r3,r2
    5fb0:	e0bff815 	stw	r2,-32(fp)
  acc += ((dest->addr >> 16) & 0xffffUL);
    5fb4:	e0bffd17 	ldw	r2,-12(fp)
    5fb8:	10c0000b 	ldhu	r3,0(r2)
    5fbc:	1080008b 	ldhu	r2,2(r2)
    5fc0:	1004943a 	slli	r2,r2,16
    5fc4:	10c4b03a 	or	r2,r2,r3
    5fc8:	1004d43a 	srli	r2,r2,16
    5fcc:	e0fff817 	ldw	r3,-32(fp)
    5fd0:	1885883a 	add	r2,r3,r2
    5fd4:	e0bff815 	stw	r2,-32(fp)
  acc += (u32_t)htons((u16_t)proto);
    5fd8:	e0bffe03 	ldbu	r2,-8(fp)
    5fdc:	1004923a 	slli	r2,r2,8
    5fe0:	e0fff817 	ldw	r3,-32(fp)
    5fe4:	1885883a 	add	r2,r3,r2
    5fe8:	e0bff815 	stw	r2,-32(fp)
  acc += (u32_t)htons(proto_len);
    5fec:	e0bfff0b 	ldhu	r2,-4(fp)
    5ff0:	1004d23a 	srli	r2,r2,8
    5ff4:	10ffffcc 	andi	r3,r2,65535
    5ff8:	e0bfff0b 	ldhu	r2,-4(fp)
    5ffc:	1004923a 	slli	r2,r2,8
    6000:	10bfffcc 	andi	r2,r2,65535
    6004:	1884b03a 	or	r2,r3,r2
    6008:	e0fff817 	ldw	r3,-32(fp)
    600c:	1885883a 	add	r2,r3,r2
    6010:	e0bff815 	stw	r2,-32(fp)

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
    6014:	e0bff817 	ldw	r2,-32(fp)
    6018:	1006d43a 	srli	r3,r2,16
    601c:	e0bff817 	ldw	r2,-32(fp)
    6020:	10bfffcc 	andi	r2,r2,65535
    6024:	1885883a 	add	r2,r3,r2
    6028:	e0bff815 	stw	r2,-32(fp)
  acc = FOLD_U32T(acc);
    602c:	e0bff817 	ldw	r2,-32(fp)
    6030:	1006d43a 	srli	r3,r2,16
    6034:	e0bff817 	ldw	r2,-32(fp)
    6038:	10bfffcc 	andi	r2,r2,65535
    603c:	1885883a 	add	r2,r3,r2
    6040:	e0bff815 	stw	r2,-32(fp)
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
    6044:	e0bff817 	ldw	r2,-32(fp)
    6048:	0084303a 	nor	r2,zero,r2
}
    604c:	e037883a 	mov	sp,fp
    6050:	dfc00117 	ldw	ra,4(sp)
    6054:	df000017 	ldw	fp,0(sp)
    6058:	dec00204 	addi	sp,sp,8
    605c:	f800283a 	ret

00006060 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
    6060:	defffc04 	addi	sp,sp,-16
    6064:	dfc00315 	stw	ra,12(sp)
    6068:	df000215 	stw	fp,8(sp)
    606c:	df000204 	addi	fp,sp,8
    6070:	e13ffe15 	stw	r4,-8(fp)
    6074:	2805883a 	mov	r2,r5
    6078:	e0bfff0d 	sth	r2,-4(fp)
  return ~LWIP_CHKSUM(dataptr, len);
    607c:	e0bfff0b 	ldhu	r2,-4(fp)
    6080:	e13ffe17 	ldw	r4,-8(fp)
    6084:	100b883a 	mov	r5,r2
    6088:	0005d140 	call	5d14 <lwip_standard_chksum>
    608c:	0084303a 	nor	r2,zero,r2
}
    6090:	e037883a 	mov	sp,fp
    6094:	dfc00117 	ldw	ra,4(sp)
    6098:	df000017 	ldw	fp,0(sp)
    609c:	dec00204 	addi	sp,sp,8
    60a0:	f800283a 	ret

000060a4 <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
    60a4:	defffa04 	addi	sp,sp,-24
    60a8:	dfc00515 	stw	ra,20(sp)
    60ac:	df000415 	stw	fp,16(sp)
    60b0:	df000404 	addi	fp,sp,16
    60b4:	e13fff15 	stw	r4,-4(fp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
    60b8:	e03ffc15 	stw	zero,-16(fp)
  swapped = 0;
    60bc:	e03ffe05 	stb	zero,-8(fp)
  for(q = p; q != NULL; q = q->next) {
    60c0:	e0bfff17 	ldw	r2,-4(fp)
    60c4:	e0bffd15 	stw	r2,-12(fp)
    60c8:	00002606 	br	6164 <inet_chksum_pbuf+0xc0>
    acc += LWIP_CHKSUM(q->payload, q->len);
    60cc:	e0bffd17 	ldw	r2,-12(fp)
    60d0:	10c00117 	ldw	r3,4(r2)
    60d4:	e0bffd17 	ldw	r2,-12(fp)
    60d8:	1080028b 	ldhu	r2,10(r2)
    60dc:	10bfffcc 	andi	r2,r2,65535
    60e0:	1809883a 	mov	r4,r3
    60e4:	100b883a 	mov	r5,r2
    60e8:	0005d140 	call	5d14 <lwip_standard_chksum>
    60ec:	10bfffcc 	andi	r2,r2,65535
    60f0:	e0fffc17 	ldw	r3,-16(fp)
    60f4:	1885883a 	add	r2,r3,r2
    60f8:	e0bffc15 	stw	r2,-16(fp)
    acc = FOLD_U32T(acc);
    60fc:	e0bffc17 	ldw	r2,-16(fp)
    6100:	1006d43a 	srli	r3,r2,16
    6104:	e0bffc17 	ldw	r2,-16(fp)
    6108:	10bfffcc 	andi	r2,r2,65535
    610c:	1885883a 	add	r2,r3,r2
    6110:	e0bffc15 	stw	r2,-16(fp)
    if (q->len % 2 != 0) {
    6114:	e0bffd17 	ldw	r2,-12(fp)
    6118:	1080028b 	ldhu	r2,10(r2)
    611c:	1080004c 	andi	r2,r2,1
    6120:	10bfffcc 	andi	r2,r2,65535
    6124:	10000c26 	beq	r2,zero,6158 <inet_chksum_pbuf+0xb4>
      swapped = 1 - swapped;
    6128:	e0bffe03 	ldbu	r2,-8(fp)
    612c:	00c00044 	movi	r3,1
    6130:	1885c83a 	sub	r2,r3,r2
    6134:	e0bffe05 	stb	r2,-8(fp)
      acc = SWAP_BYTES_IN_WORD(acc);
    6138:	e0bffc17 	ldw	r2,-16(fp)
    613c:	10bfc00c 	andi	r2,r2,65280
    6140:	1006d23a 	srli	r3,r2,8
    6144:	e0bffc17 	ldw	r2,-16(fp)
    6148:	1004923a 	slli	r2,r2,8
    614c:	10bfffcc 	andi	r2,r2,65535
    6150:	1884b03a 	or	r2,r3,r2
    6154:	e0bffc15 	stw	r2,-16(fp)
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
    6158:	e0bffd17 	ldw	r2,-12(fp)
    615c:	10800017 	ldw	r2,0(r2)
    6160:	e0bffd15 	stw	r2,-12(fp)
    6164:	e0bffd17 	ldw	r2,-12(fp)
    6168:	103fd81e 	bne	r2,zero,60cc <inet_chksum_pbuf+0x28>
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    }
  }

  if (swapped) {
    616c:	e0bffe03 	ldbu	r2,-8(fp)
    6170:	10000826 	beq	r2,zero,6194 <inet_chksum_pbuf+0xf0>
    acc = SWAP_BYTES_IN_WORD(acc);
    6174:	e0bffc17 	ldw	r2,-16(fp)
    6178:	10bfc00c 	andi	r2,r2,65280
    617c:	1006d23a 	srli	r3,r2,8
    6180:	e0bffc17 	ldw	r2,-16(fp)
    6184:	1004923a 	slli	r2,r2,8
    6188:	10bfffcc 	andi	r2,r2,65535
    618c:	1884b03a 	or	r2,r3,r2
    6190:	e0bffc15 	stw	r2,-16(fp)
  }
  return (u16_t)~(acc & 0xffffUL);
    6194:	e0bffc17 	ldw	r2,-16(fp)
    6198:	0084303a 	nor	r2,zero,r2
}
    619c:	e037883a 	mov	sp,fp
    61a0:	dfc00117 	ldw	ra,4(sp)
    61a4:	df000017 	ldw	fp,0(sp)
    61a8:	dec00204 	addi	sp,sp,8
    61ac:	f800283a 	ret

000061b0 <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(struct ip_addr *dest)
{
    61b0:	defffc04 	addi	sp,sp,-16
    61b4:	dfc00315 	stw	ra,12(sp)
    61b8:	df000215 	stw	fp,8(sp)
    61bc:	df000204 	addi	fp,sp,8
    61c0:	e13fff15 	stw	r4,-4(fp)
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
    61c4:	008000f4 	movhi	r2,3
    61c8:	1099be04 	addi	r2,r2,26360
    61cc:	10800017 	ldw	r2,0(r2)
    61d0:	e0bffe15 	stw	r2,-8(fp)
    61d4:	00001606 	br	6230 <ip_route+0x80>
    /* network mask matches? */
    if (netif_is_up(netif)) {
    61d8:	e13ffe17 	ldw	r4,-8(fp)
    61dc:	00097980 	call	9798 <netif_is_up>
    61e0:	10803fcc 	andi	r2,r2,255
    61e4:	10000f26 	beq	r2,zero,6224 <ip_route+0x74>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
    61e8:	e0bfff17 	ldw	r2,-4(fp)
    61ec:	10c0000b 	ldhu	r3,0(r2)
    61f0:	1080008b 	ldhu	r2,2(r2)
    61f4:	1004943a 	slli	r2,r2,16
    61f8:	10c4b03a 	or	r2,r2,r3
    61fc:	1007883a 	mov	r3,r2
    6200:	e0bffe17 	ldw	r2,-8(fp)
    6204:	10800117 	ldw	r2,4(r2)
    6208:	1886f03a 	xor	r3,r3,r2
    620c:	e0bffe17 	ldw	r2,-8(fp)
    6210:	10800217 	ldw	r2,8(r2)
    6214:	1884703a 	and	r2,r3,r2
    6218:	1000021e 	bne	r2,zero,6224 <ip_route+0x74>
        /* return netif on which to forward IP packet */
        return netif;
    621c:	e0bffe17 	ldw	r2,-8(fp)
    6220:	00001d06 	br	6298 <ip_route+0xe8>
ip_route(struct ip_addr *dest)
{
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
    6224:	e0bffe17 	ldw	r2,-8(fp)
    6228:	10800017 	ldw	r2,0(r2)
    622c:	e0bffe15 	stw	r2,-8(fp)
    6230:	e0bffe17 	ldw	r2,-8(fp)
    6234:	103fe81e 	bne	r2,zero,61d8 <ip_route+0x28>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
    6238:	008000f4 	movhi	r2,3
    623c:	1099bf04 	addi	r2,r2,26364
    6240:	10800017 	ldw	r2,0(r2)
    6244:	10000726 	beq	r2,zero,6264 <ip_route+0xb4>
    6248:	008000f4 	movhi	r2,3
    624c:	1099bf04 	addi	r2,r2,26364
    6250:	10800017 	ldw	r2,0(r2)
    6254:	1009883a 	mov	r4,r2
    6258:	00097980 	call	9798 <netif_is_up>
    625c:	10803fcc 	andi	r2,r2,255
    6260:	10000a1e 	bne	r2,zero,628c <ip_route+0xdc>
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_route: No route to 0x%"X32_F"\n", dest->addr));
    IP_STATS_INC(ip.rterr);
    6264:	00800134 	movhi	r2,4
    6268:	10916104 	addi	r2,r2,17796
    626c:	1080158b 	ldhu	r2,86(r2)
    6270:	10800044 	addi	r2,r2,1
    6274:	1007883a 	mov	r3,r2
    6278:	00800134 	movhi	r2,4
    627c:	10916104 	addi	r2,r2,17796
    6280:	10c0158d 	sth	r3,86(r2)
    snmp_inc_ipoutnoroutes();
    return NULL;
    6284:	0005883a 	mov	r2,zero
    6288:	00000306 	br	6298 <ip_route+0xe8>
  }
  /* no matching netif found, use default netif */
  return netif_default;
    628c:	008000f4 	movhi	r2,3
    6290:	1099bf04 	addi	r2,r2,26364
    6294:	10800017 	ldw	r2,0(r2)
}
    6298:	e037883a 	mov	sp,fp
    629c:	dfc00117 	ldw	ra,4(sp)
    62a0:	df000017 	ldw	fp,0(sp)
    62a4:	dec00204 	addi	sp,sp,8
    62a8:	f800283a 	ret

000062ac <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
    62ac:	defff704 	addi	sp,sp,-36
    62b0:	dfc00815 	stw	ra,32(sp)
    62b4:	df000715 	stw	fp,28(sp)
    62b8:	df000704 	addi	fp,sp,28
    62bc:	e13ffe15 	stw	r4,-8(fp)
    62c0:	e17fff15 	stw	r5,-4(fp)
  struct ip_hdr *iphdr;
  struct netif *netif;
  u16_t iphdr_hlen;
  u16_t iphdr_len;
#if LWIP_DHCP
  int check_ip_src=1;
    62c4:	00800044 	movi	r2,1
    62c8:	e0bffb15 	stw	r2,-20(fp)
#endif /* LWIP_DHCP */

  IP_STATS_INC(ip.recv);
    62cc:	00800134 	movhi	r2,4
    62d0:	10916104 	addi	r2,r2,17796
    62d4:	1080128b 	ldhu	r2,74(r2)
    62d8:	10800044 	addi	r2,r2,1
    62dc:	1007883a 	mov	r3,r2
    62e0:	00800134 	movhi	r2,4
    62e4:	10916104 	addi	r2,r2,17796
    62e8:	10c0128d 	sth	r3,74(r2)
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
    62ec:	e0bffe17 	ldw	r2,-8(fp)
    62f0:	10800117 	ldw	r2,4(r2)
    62f4:	e0bff915 	stw	r2,-28(fp)
  if (IPH_V(iphdr) != 4) {
    62f8:	e0bff917 	ldw	r2,-28(fp)
    62fc:	1080000b 	ldhu	r2,0(r2)
    6300:	10bfffcc 	andi	r2,r2,65535
    6304:	1004d23a 	srli	r2,r2,8
    6308:	10ffffcc 	andi	r3,r2,65535
    630c:	e0bff917 	ldw	r2,-28(fp)
    6310:	1080000b 	ldhu	r2,0(r2)
    6314:	10bfffcc 	andi	r2,r2,65535
    6318:	1004923a 	slli	r2,r2,8
    631c:	10bfffcc 	andi	r2,r2,65535
    6320:	1884b03a 	or	r2,r3,r2
    6324:	1005d33a 	srai	r2,r2,12
    6328:	10800120 	cmpeqi	r2,r2,4
    632c:	1000141e 	bne	r2,zero,6380 <ip_input+0xd4>
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
    6330:	e13ffe17 	ldw	r4,-8(fp)
    6334:	000a1880 	call	a188 <pbuf_free>
    IP_STATS_INC(ip.err);
    6338:	00800134 	movhi	r2,4
    633c:	10916104 	addi	r2,r2,17796
    6340:	1080170b 	ldhu	r2,92(r2)
    6344:	10800044 	addi	r2,r2,1
    6348:	1007883a 	mov	r3,r2
    634c:	00800134 	movhi	r2,4
    6350:	10916104 	addi	r2,r2,17796
    6354:	10c0170d 	sth	r3,92(r2)
    IP_STATS_INC(ip.drop);
    6358:	00800134 	movhi	r2,4
    635c:	10916104 	addi	r2,r2,17796
    6360:	1080138b 	ldhu	r2,78(r2)
    6364:	10800044 	addi	r2,r2,1
    6368:	1007883a 	mov	r3,r2
    636c:	00800134 	movhi	r2,4
    6370:	10916104 	addi	r2,r2,17796
    6374:	10c0138d 	sth	r3,78(r2)
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
    6378:	0005883a 	mov	r2,zero
    637c:	00013a06 	br	6868 <ip_input+0x5bc>
  }

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
    6380:	e0bff917 	ldw	r2,-28(fp)
    6384:	1080000b 	ldhu	r2,0(r2)
    6388:	10bfffcc 	andi	r2,r2,65535
    638c:	1004d23a 	srli	r2,r2,8
    6390:	10ffffcc 	andi	r3,r2,65535
    6394:	e0bff917 	ldw	r2,-28(fp)
    6398:	1080000b 	ldhu	r2,0(r2)
    639c:	10bfffcc 	andi	r2,r2,65535
    63a0:	1004923a 	slli	r2,r2,8
    63a4:	10bfffcc 	andi	r2,r2,65535
    63a8:	1884b03a 	or	r2,r3,r2
    63ac:	1005d23a 	srai	r2,r2,8
    63b0:	108003cc 	andi	r2,r2,15
    63b4:	e0bffd0d 	sth	r2,-12(fp)
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
    63b8:	e0bffd0b 	ldhu	r2,-12(fp)
    63bc:	1085883a 	add	r2,r2,r2
    63c0:	1085883a 	add	r2,r2,r2
    63c4:	e0bffd0d 	sth	r2,-12(fp)
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
    63c8:	e0bff917 	ldw	r2,-28(fp)
    63cc:	1080008b 	ldhu	r2,2(r2)
    63d0:	10bfffcc 	andi	r2,r2,65535
    63d4:	1004d23a 	srli	r2,r2,8
    63d8:	1007883a 	mov	r3,r2
    63dc:	e0bff917 	ldw	r2,-28(fp)
    63e0:	1080008b 	ldhu	r2,2(r2)
    63e4:	10bfffcc 	andi	r2,r2,65535
    63e8:	1004923a 	slli	r2,r2,8
    63ec:	1884b03a 	or	r2,r3,r2
    63f0:	e0bffd8d 	sth	r2,-10(fp)

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
    63f4:	e0bffe17 	ldw	r2,-8(fp)
    63f8:	1080028b 	ldhu	r2,10(r2)
    63fc:	10ffffcc 	andi	r3,r2,65535
    6400:	e0bffd0b 	ldhu	r2,-12(fp)
    6404:	18800536 	bltu	r3,r2,641c <ip_input+0x170>
    6408:	e0bffe17 	ldw	r2,-8(fp)
    640c:	1080020b 	ldhu	r2,8(r2)
    6410:	10ffffcc 	andi	r3,r2,65535
    6414:	e0bffd8b 	ldhu	r2,-10(fp)
    6418:	1880142e 	bgeu	r3,r2,646c <ip_input+0x1c0>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
        ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), IP packet dropped.\n",
        iphdr_len, p->tot_len));
    }
    /* free (drop) packet pbufs */
    pbuf_free(p);
    641c:	e13ffe17 	ldw	r4,-8(fp)
    6420:	000a1880 	call	a188 <pbuf_free>
    IP_STATS_INC(ip.lenerr);
    6424:	00800134 	movhi	r2,4
    6428:	10916104 	addi	r2,r2,17796
    642c:	1080148b 	ldhu	r2,82(r2)
    6430:	10800044 	addi	r2,r2,1
    6434:	1007883a 	mov	r3,r2
    6438:	00800134 	movhi	r2,4
    643c:	10916104 	addi	r2,r2,17796
    6440:	10c0148d 	sth	r3,82(r2)
    IP_STATS_INC(ip.drop);
    6444:	00800134 	movhi	r2,4
    6448:	10916104 	addi	r2,r2,17796
    644c:	1080138b 	ldhu	r2,78(r2)
    6450:	10800044 	addi	r2,r2,1
    6454:	1007883a 	mov	r3,r2
    6458:	00800134 	movhi	r2,4
    645c:	10916104 	addi	r2,r2,17796
    6460:	10c0138d 	sth	r3,78(r2)
    snmp_inc_ipindiscards();
    return ERR_OK;
    6464:	0005883a 	mov	r2,zero
    6468:	0000ff06 	br	6868 <ip_input+0x5bc>
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
    646c:	e0bffd0b 	ldhu	r2,-12(fp)
    6470:	e13ff917 	ldw	r4,-28(fp)
    6474:	100b883a 	mov	r5,r2
    6478:	00060600 	call	6060 <inet_chksum>
    647c:	10bfffcc 	andi	r2,r2,65535
    6480:	10001426 	beq	r2,zero,64d4 <ip_input+0x228>

    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
      ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
    ip_debug_print(p);
    pbuf_free(p);
    6484:	e13ffe17 	ldw	r4,-8(fp)
    6488:	000a1880 	call	a188 <pbuf_free>
    IP_STATS_INC(ip.chkerr);
    648c:	00800134 	movhi	r2,4
    6490:	10916104 	addi	r2,r2,17796
    6494:	1080140b 	ldhu	r2,80(r2)
    6498:	10800044 	addi	r2,r2,1
    649c:	1007883a 	mov	r3,r2
    64a0:	00800134 	movhi	r2,4
    64a4:	10916104 	addi	r2,r2,17796
    64a8:	10c0140d 	sth	r3,80(r2)
    IP_STATS_INC(ip.drop);
    64ac:	00800134 	movhi	r2,4
    64b0:	10916104 	addi	r2,r2,17796
    64b4:	1080138b 	ldhu	r2,78(r2)
    64b8:	10800044 	addi	r2,r2,1
    64bc:	1007883a 	mov	r3,r2
    64c0:	00800134 	movhi	r2,4
    64c4:	10916104 	addi	r2,r2,17796
    64c8:	10c0138d 	sth	r3,78(r2)
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
    64cc:	0005883a 	mov	r2,zero
    64d0:	0000e506 	br	6868 <ip_input+0x5bc>
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
    64d4:	e0bffd8b 	ldhu	r2,-10(fp)
    64d8:	e13ffe17 	ldw	r4,-8(fp)
    64dc:	100b883a 	mov	r5,r2
    64e0:	0009d0c0 	call	9d0c <pbuf_realloc>
#endif /* LWIP_IGMP */
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
    64e4:	00800044 	movi	r2,1
    64e8:	e0bffc15 	stw	r2,-16(fp)
    netif = inp;
    64ec:	e0bfff17 	ldw	r2,-4(fp)
    64f0:	e0bffa15 	stw	r2,-24(fp)
          iphdr->dest.addr & netif->netmask.addr,
          netif->ip_addr.addr & netif->netmask.addr,
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
    64f4:	e13ffa17 	ldw	r4,-24(fp)
    64f8:	00097980 	call	9798 <netif_is_up>
    64fc:	10803fcc 	andi	r2,r2,255
    6500:	10001626 	beq	r2,zero,655c <ip_input+0x2b0>
    6504:	e0bffa17 	ldw	r2,-24(fp)
    6508:	10800104 	addi	r2,r2,4
    650c:	10001326 	beq	r2,zero,655c <ip_input+0x2b0>
    6510:	e0bffa17 	ldw	r2,-24(fp)
    6514:	10800117 	ldw	r2,4(r2)
    6518:	10001026 	beq	r2,zero,655c <ip_input+0x2b0>
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
    651c:	e0bff917 	ldw	r2,-28(fp)
    6520:	10c0040b 	ldhu	r3,16(r2)
    6524:	1080048b 	ldhu	r2,18(r2)
    6528:	1004943a 	slli	r2,r2,16
    652c:	10c4b03a 	or	r2,r2,r3
    6530:	1007883a 	mov	r3,r2
    6534:	e0bffa17 	ldw	r2,-24(fp)
    6538:	10800117 	ldw	r2,4(r2)
    653c:	18801b26 	beq	r3,r2,65ac <ip_input+0x300>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
    6540:	e0bff917 	ldw	r2,-28(fp)
    6544:	10800404 	addi	r2,r2,16
    6548:	1009883a 	mov	r4,r2
    654c:	e17ffa17 	ldw	r5,-24(fp)
    6550:	0006dcc0 	call	6dcc <ip_addr_isbroadcast>
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
    6554:	10803fcc 	andi	r2,r2,255
    6558:	1000141e 	bne	r2,zero,65ac <ip_input+0x300>
              netif->name[0], netif->name[1]));
          /* break out of for loop */
          break;
        }
      }
      if (first) {
    655c:	e0bffc17 	ldw	r2,-16(fp)
    6560:	10000626 	beq	r2,zero,657c <ip_input+0x2d0>
        first = 0;
    6564:	e03ffc15 	stw	zero,-16(fp)
        netif = netif_list;
    6568:	008000f4 	movhi	r2,3
    656c:	1099be04 	addi	r2,r2,26360
    6570:	10800017 	ldw	r2,0(r2)
    6574:	e0bffa15 	stw	r2,-24(fp)
    6578:	00000306 	br	6588 <ip_input+0x2dc>
      } else {
        netif = netif->next;
    657c:	e0bffa17 	ldw	r2,-24(fp)
    6580:	10800017 	ldw	r2,0(r2)
    6584:	e0bffa15 	stw	r2,-24(fp)
      }
      if (netif == inp) {
    6588:	e0fffa17 	ldw	r3,-24(fp)
    658c:	e0bfff17 	ldw	r2,-4(fp)
    6590:	1880031e 	bne	r3,r2,65a0 <ip_input+0x2f4>
        netif = netif->next;
    6594:	e0bffa17 	ldw	r2,-24(fp)
    6598:	10800017 	ldw	r2,0(r2)
    659c:	e0bffa15 	stw	r2,-24(fp)
      }
    } while(netif != NULL);
    65a0:	e0bffa17 	ldw	r2,-24(fp)
    65a4:	103fd31e 	bne	r2,zero,64f4 <ip_input+0x248>
    65a8:	00000106 	br	65b0 <ip_input+0x304>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
          LWIP_DEBUGF(IP_DEBUG, ("ip_input: packet accepted on interface %c%c\n",
              netif->name[0], netif->name[1]));
          /* break out of for loop */
          break;
    65ac:	0001883a 	nop
#if LWIP_DHCP
  /* Pass DHCP messages regardless of destination address. DHCP traffic is addressed
   * using link layer addressing (such as Ethernet MAC) so we must not filter on IP.
   * According to RFC 1542 section 3.1.1, referred by RFC 2131).
   */
  if (netif == NULL) {
    65b0:	e0bffa17 	ldw	r2,-24(fp)
    65b4:	1000221e 	bne	r2,zero,6640 <ip_input+0x394>
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
    65b8:	e0bff917 	ldw	r2,-28(fp)
    65bc:	1080020b 	ldhu	r2,8(r2)
    65c0:	10bfffcc 	andi	r2,r2,65535
    65c4:	1004d23a 	srli	r2,r2,8
    65c8:	10ffffcc 	andi	r3,r2,65535
    65cc:	e0bff917 	ldw	r2,-28(fp)
    65d0:	1080020b 	ldhu	r2,8(r2)
    65d4:	10bfffcc 	andi	r2,r2,65535
    65d8:	1004923a 	slli	r2,r2,8
    65dc:	10bfffcc 	andi	r2,r2,65535
    65e0:	1884b03a 	or	r2,r3,r2
    65e4:	10803fcc 	andi	r2,r2,255
    65e8:	10800458 	cmpnei	r2,r2,17
    65ec:	1000141e 	bne	r2,zero,6640 <ip_input+0x394>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest)));
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
    65f0:	e0bffd0b 	ldhu	r2,-12(fp)
    65f4:	e0fff917 	ldw	r3,-28(fp)
    65f8:	1885883a 	add	r2,r3,r2
    65fc:	1080008b 	ldhu	r2,2(r2)
    6600:	10bfffcc 	andi	r2,r2,65535
    6604:	1004d23a 	srli	r2,r2,8
    6608:	10ffffcc 	andi	r3,r2,65535
    660c:	e0bffd0b 	ldhu	r2,-12(fp)
    6610:	e13ff917 	ldw	r4,-28(fp)
    6614:	2085883a 	add	r2,r4,r2
    6618:	1080008b 	ldhu	r2,2(r2)
    661c:	10bfffcc 	andi	r2,r2,65535
    6620:	1004923a 	slli	r2,r2,8
    6624:	10bfffcc 	andi	r2,r2,65535
    6628:	1884b03a 	or	r2,r3,r2
    662c:	10801118 	cmpnei	r2,r2,68
    6630:	1000031e 	bne	r2,zero,6640 <ip_input+0x394>
        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip_input: DHCP packet accepted.\n"));
        netif = inp;
    6634:	e0bfff17 	ldw	r2,-4(fp)
    6638:	e0bffa15 	stw	r2,-24(fp)
        check_ip_src = 0;
    663c:	e03ffb15 	stw	zero,-20(fp)
#endif /* LWIP_DHCP */

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  /* DHCP servers need 0.0.0.0 to be allowed as source address (RFC 1.1.2.2: 3.2.1.3/a) */
  if (check_ip_src && (iphdr->src.addr != 0))
    6640:	e0bffb17 	ldw	r2,-20(fp)
    6644:	10002126 	beq	r2,zero,66cc <ip_input+0x420>
    6648:	e0bff917 	ldw	r2,-28(fp)
    664c:	10c0030b 	ldhu	r3,12(r2)
    6650:	1080038b 	ldhu	r2,14(r2)
    6654:	1004943a 	slli	r2,r2,16
    6658:	10c4b03a 	or	r2,r2,r3
    665c:	10001b26 	beq	r2,zero,66cc <ip_input+0x420>
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
    6660:	e0bff917 	ldw	r2,-28(fp)
    6664:	10800304 	addi	r2,r2,12
    6668:	1009883a 	mov	r4,r2
    666c:	e17fff17 	ldw	r5,-4(fp)
    6670:	0006dcc0 	call	6dcc <ip_addr_isbroadcast>
    6674:	10803fcc 	andi	r2,r2,255
    6678:	1000081e 	bne	r2,zero,669c <ip_input+0x3f0>
         (ip_addr_ismulticast(&(iphdr->src)))) {
    667c:	e0bff917 	ldw	r2,-28(fp)
    6680:	10c0030b 	ldhu	r3,12(r2)
    6684:	1080038b 	ldhu	r2,14(r2)
    6688:	1004943a 	slli	r2,r2,16
    668c:	10c4b03a 	or	r2,r2,r3
    6690:	10803c0c 	andi	r2,r2,240
  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  /* DHCP servers need 0.0.0.0 to be allowed as source address (RFC 1.1.2.2: 3.2.1.3/a) */
  if (check_ip_src && (iphdr->src.addr != 0))
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
    6694:	10803818 	cmpnei	r2,r2,224
    6698:	10000c1e 	bne	r2,zero,66cc <ip_input+0x420>
         (ip_addr_ismulticast(&(iphdr->src)))) {
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("ip_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
    669c:	e13ffe17 	ldw	r4,-8(fp)
    66a0:	000a1880 	call	a188 <pbuf_free>
      IP_STATS_INC(ip.drop);
    66a4:	00800134 	movhi	r2,4
    66a8:	10916104 	addi	r2,r2,17796
    66ac:	1080138b 	ldhu	r2,78(r2)
    66b0:	10800044 	addi	r2,r2,1
    66b4:	1007883a 	mov	r3,r2
    66b8:	00800134 	movhi	r2,4
    66bc:	10916104 	addi	r2,r2,17796
    66c0:	10c0138d 	sth	r3,78(r2)
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
      return ERR_OK;
    66c4:	0005883a 	mov	r2,zero
    66c8:	00006706 	br	6868 <ip_input+0x5bc>
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
    66cc:	e0bffa17 	ldw	r2,-24(fp)
    66d0:	1000041e 	bne	r2,zero,66e4 <ip_input+0x438>
#endif /* IP_FORWARD */
    {
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
    }
    pbuf_free(p);
    66d4:	e13ffe17 	ldw	r4,-8(fp)
    66d8:	000a1880 	call	a188 <pbuf_free>
    return ERR_OK;
    66dc:	0005883a 	mov	r2,zero
    66e0:	00006106 	br	6868 <ip_input+0x5bc>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
    66e4:	e0bff917 	ldw	r2,-28(fp)
    66e8:	1080018b 	ldhu	r2,6(r2)
    66ec:	10bfffcc 	andi	r2,r2,65535
    66f0:	10bfcfcc 	andi	r2,r2,65343
    66f4:	10000a26 	beq	r2,zero,6720 <ip_input+0x474>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & htons(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    /* reassemble the packet*/
    p = ip_reass(p);
    66f8:	e13ffe17 	ldw	r4,-8(fp)
    66fc:	00079840 	call	7984 <ip_reass>
    6700:	e0bffe15 	stw	r2,-8(fp)
    /* packet not fully reassembled yet? */
    if (p == NULL) {
    6704:	e0bffe17 	ldw	r2,-8(fp)
    6708:	1000021e 	bne	r2,zero,6714 <ip_input+0x468>
      return ERR_OK;
    670c:	0005883a 	mov	r2,zero
    6710:	00005506 	br	6868 <ip_input+0x5bc>
    }
    iphdr = p->payload;
    6714:	e0bffe17 	ldw	r2,-8(fp)
    6718:	10800117 	ldw	r2,4(r2)
    671c:	e0bff915 	stw	r2,-28(fp)
  /* send to upper layers */
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: \n"));
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

  current_netif = inp;
    6720:	e0bfff17 	ldw	r2,-4(fp)
    6724:	d0a8c915 	stw	r2,-23772(gp)
  current_header = iphdr;
    6728:	e0bff917 	ldw	r2,-28(fp)
    672c:	d0a8ca15 	stw	r2,-23768(gp)

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
    6730:	e13ffe17 	ldw	r4,-8(fp)
    6734:	e17fff17 	ldw	r5,-4(fp)
    6738:	000ad5c0 	call	ad5c <raw_input>
    673c:	10803fcc 	andi	r2,r2,255
    6740:	1000461e 	bne	r2,zero,685c <ip_input+0x5b0>
#endif /* LWIP_RAW */
  {

    switch (IPH_PROTO(iphdr)) {
    6744:	e0bff917 	ldw	r2,-28(fp)
    6748:	1080020b 	ldhu	r2,8(r2)
    674c:	10bfffcc 	andi	r2,r2,65535
    6750:	1004d23a 	srli	r2,r2,8
    6754:	10ffffcc 	andi	r3,r2,65535
    6758:	e0bff917 	ldw	r2,-28(fp)
    675c:	1080020b 	ldhu	r2,8(r2)
    6760:	10bfffcc 	andi	r2,r2,65535
    6764:	1004923a 	slli	r2,r2,8
    6768:	10bfffcc 	andi	r2,r2,65535
    676c:	1884b03a 	or	r2,r3,r2
    6770:	10803fcc 	andi	r2,r2,255
    6774:	10c001a0 	cmpeqi	r3,r2,6
    6778:	1800091e 	bne	r3,zero,67a0 <ip_input+0x4f4>
    677c:	10c00460 	cmpeqi	r3,r2,17
    6780:	1800031e 	bne	r3,zero,6790 <ip_input+0x4e4>
    6784:	10800060 	cmpeqi	r2,r2,1
    6788:	1000091e 	bne	r2,zero,67b0 <ip_input+0x504>
    678c:	00000c06 	br	67c0 <ip_input+0x514>
    case IP_PROTO_UDP:
#if LWIP_UDPLITE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      snmp_inc_ipindelivers();
      udp_input(p, inp);
    6790:	e13ffe17 	ldw	r4,-8(fp)
    6794:	e17fff17 	ldw	r5,-4(fp)
    6798:	00142100 	call	14210 <udp_input>
      break;
    679c:	00002f06 	br	685c <ip_input+0x5b0>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case IP_PROTO_TCP:
      snmp_inc_ipindelivers();
      tcp_input(p, inp);
    67a0:	e13ffe17 	ldw	r4,-8(fp)
    67a4:	e17fff17 	ldw	r5,-4(fp)
    67a8:	000dad80 	call	dad8 <tcp_input>
      break;
    67ac:	00002b06 	br	685c <ip_input+0x5b0>
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      snmp_inc_ipindelivers();
      icmp_input(p, inp);
    67b0:	e13ffe17 	ldw	r4,-8(fp)
    67b4:	e17fff17 	ldw	r5,-4(fp)
    67b8:	0004df00 	call	4df0 <icmp_input>
      break;
    67bc:	00002706 	br	685c <ip_input+0x5b0>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
    67c0:	e0bff917 	ldw	r2,-28(fp)
    67c4:	10800404 	addi	r2,r2,16
    67c8:	1009883a 	mov	r4,r2
    67cc:	e17fff17 	ldw	r5,-4(fp)
    67d0:	0006dcc0 	call	6dcc <ip_addr_isbroadcast>
    67d4:	10803fcc 	andi	r2,r2,255
    67d8:	10000e1e 	bne	r2,zero,6814 <ip_input+0x568>
          !ip_addr_ismulticast(&(iphdr->dest))) {
    67dc:	e0bff917 	ldw	r2,-28(fp)
    67e0:	10c0040b 	ldhu	r3,16(r2)
    67e4:	1080048b 	ldhu	r2,18(r2)
    67e8:	1004943a 	slli	r2,r2,16
    67ec:	10c4b03a 	or	r2,r2,r3
    67f0:	10803c0c 	andi	r2,r2,240
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
    67f4:	10803820 	cmpeqi	r2,r2,224
    67f8:	1000061e 	bne	r2,zero,6814 <ip_input+0x568>
          !ip_addr_ismulticast(&(iphdr->dest))) {
        p->payload = iphdr;
    67fc:	e0bffe17 	ldw	r2,-8(fp)
    6800:	e0fff917 	ldw	r3,-28(fp)
    6804:	10c00115 	stw	r3,4(r2)
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
    6808:	e13ffe17 	ldw	r4,-8(fp)
    680c:	01400084 	movi	r5,2
    6810:	00054880 	call	5488 <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      pbuf_free(p);
    6814:	e13ffe17 	ldw	r4,-8(fp)
    6818:	000a1880 	call	a188 <pbuf_free>

      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("Unsupported transport protocol %"U16_F"\n", IPH_PROTO(iphdr)));

      IP_STATS_INC(ip.proterr);
    681c:	00800134 	movhi	r2,4
    6820:	10916104 	addi	r2,r2,17796
    6824:	1080160b 	ldhu	r2,88(r2)
    6828:	10800044 	addi	r2,r2,1
    682c:	1007883a 	mov	r3,r2
    6830:	00800134 	movhi	r2,4
    6834:	10916104 	addi	r2,r2,17796
    6838:	10c0160d 	sth	r3,88(r2)
      IP_STATS_INC(ip.drop);
    683c:	00800134 	movhi	r2,4
    6840:	10916104 	addi	r2,r2,17796
    6844:	1080138b 	ldhu	r2,78(r2)
    6848:	10800044 	addi	r2,r2,1
    684c:	1007883a 	mov	r3,r2
    6850:	00800134 	movhi	r2,4
    6854:	10916104 	addi	r2,r2,17796
    6858:	10c0138d 	sth	r3,78(r2)
      snmp_inc_ipinunknownprotos();
    }
  }

  current_netif = NULL;
    685c:	d028c915 	stw	zero,-23772(gp)
  current_header = NULL;
    6860:	d028ca15 	stw	zero,-23768(gp)

  return ERR_OK;
    6864:	0005883a 	mov	r2,zero
}
    6868:	e037883a 	mov	sp,fp
    686c:	dfc00117 	ldw	ra,4(sp)
    6870:	df000017 	ldw	fp,0(sp)
    6874:	dec00204 	addi	sp,sp,8
    6878:	f800283a 	ret

0000687c <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
    687c:	defff604 	addi	sp,sp,-40
    6880:	dfc00915 	stw	ra,36(sp)
    6884:	df000815 	stw	fp,32(sp)
    6888:	df000804 	addi	fp,sp,32
    688c:	e13ffa15 	stw	r4,-24(fp)
    6890:	e17ffb15 	stw	r5,-20(fp)
    6894:	e1bffc15 	stw	r6,-16(fp)
    6898:	3805883a 	mov	r2,r7
    689c:	e1000217 	ldw	r4,8(fp)
    68a0:	e0c00317 	ldw	r3,12(fp)
    68a4:	e0bffd05 	stb	r2,-12(fp)
    68a8:	e13ffe05 	stb	r4,-8(fp)
    68ac:	e0ffff05 	stb	r3,-4(fp)
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
    68b0:	e0bffc17 	ldw	r2,-16(fp)
    68b4:	1000ef26 	beq	r2,zero,6c74 <ip_output_if+0x3f8>
    u16_t ip_hlen = IP_HLEN;
    68b8:	00800504 	movi	r2,20
    68bc:	e0bff80d 	sth	r2,-32(fp)
        memset(((char*)p->payload) + optlen, 0, optlen_aligned - optlen);
      }
    }
#endif /* IP_OPTIONS_SEND */
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
    68c0:	e13ffa17 	ldw	r4,-24(fp)
    68c4:	01400504 	movi	r5,20
    68c8:	0009f900 	call	9f90 <pbuf_header>
    68cc:	10803fcc 	andi	r2,r2,255
    68d0:	10000a26 	beq	r2,zero,68fc <ip_output_if+0x80>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
    68d4:	00800134 	movhi	r2,4
    68d8:	10916104 	addi	r2,r2,17796
    68dc:	1080170b 	ldhu	r2,92(r2)
    68e0:	10800044 	addi	r2,r2,1
    68e4:	1007883a 	mov	r3,r2
    68e8:	00800134 	movhi	r2,4
    68ec:	10916104 	addi	r2,r2,17796
    68f0:	10c0170d 	sth	r3,92(r2)
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    68f4:	00bfff84 	movi	r2,-2
    68f8:	00010206 	br	6d04 <ip_output_if+0x488>
    }

    iphdr = p->payload;
    68fc:	e0bffa17 	ldw	r2,-24(fp)
    6900:	10800117 	ldw	r2,4(r2)
    6904:	e0bff915 	stw	r2,-28(fp)
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
    6908:	e0bffa17 	ldw	r2,-24(fp)
    690c:	1080028b 	ldhu	r2,10(r2)
    6910:	10bfffcc 	andi	r2,r2,65535
    6914:	10800528 	cmpgeui	r2,r2,20
    6918:	1000091e 	bne	r2,zero,6940 <ip_output_if+0xc4>
    691c:	010000f4 	movhi	r4,3
    6920:	21398e04 	addi	r4,r4,-6600
    6924:	014000f4 	movhi	r5,3
    6928:	29799804 	addi	r5,r5,-6560
    692c:	01808a84 	movi	r6,554
    6930:	01c000f4 	movhi	r7,3
    6934:	39f9a404 	addi	r7,r7,-6512
    6938:	00170680 	call	17068 <printf>
    693c:	003fff06 	br	693c <ip_output_if+0xc0>
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
    6940:	e0bff917 	ldw	r2,-28(fp)
    6944:	1080020b 	ldhu	r2,8(r2)
    6948:	10bfffcc 	andi	r2,r2,65535
    694c:	1004d23a 	srli	r2,r2,8
    6950:	10ffffcc 	andi	r3,r2,65535
    6954:	e0bff917 	ldw	r2,-28(fp)
    6958:	1080020b 	ldhu	r2,8(r2)
    695c:	10bfffcc 	andi	r2,r2,65535
    6960:	1004923a 	slli	r2,r2,8
    6964:	10bfffcc 	andi	r2,r2,65535
    6968:	1884b03a 	or	r2,r3,r2
    696c:	10c03fcc 	andi	r3,r2,255
    6970:	e0bffd03 	ldbu	r2,-12(fp)
    6974:	1004923a 	slli	r2,r2,8
    6978:	1884b03a 	or	r2,r3,r2
    697c:	10bfc00c 	andi	r2,r2,65280
    6980:	1005d23a 	srai	r2,r2,8
    6984:	1007883a 	mov	r3,r2
    6988:	e0bff917 	ldw	r2,-28(fp)
    698c:	1080020b 	ldhu	r2,8(r2)
    6990:	10bfffcc 	andi	r2,r2,65535
    6994:	1004d23a 	srli	r2,r2,8
    6998:	113fffcc 	andi	r4,r2,65535
    699c:	e0bff917 	ldw	r2,-28(fp)
    69a0:	1080020b 	ldhu	r2,8(r2)
    69a4:	10bfffcc 	andi	r2,r2,65535
    69a8:	1004923a 	slli	r2,r2,8
    69ac:	10bfffcc 	andi	r2,r2,65535
    69b0:	2084b03a 	or	r2,r4,r2
    69b4:	11003fcc 	andi	r4,r2,255
    69b8:	e0bffd03 	ldbu	r2,-12(fp)
    69bc:	1004923a 	slli	r2,r2,8
    69c0:	2084b03a 	or	r2,r4,r2
    69c4:	1004923a 	slli	r2,r2,8
    69c8:	1884b03a 	or	r2,r3,r2
    69cc:	1007883a 	mov	r3,r2
    69d0:	e0bff917 	ldw	r2,-28(fp)
    69d4:	10c0020d 	sth	r3,8(r2)
    IPH_PROTO_SET(iphdr, proto);
    69d8:	e0ffff03 	ldbu	r3,-4(fp)
    69dc:	e0bff917 	ldw	r2,-28(fp)
    69e0:	1080020b 	ldhu	r2,8(r2)
    69e4:	10bfffcc 	andi	r2,r2,65535
    69e8:	1004d23a 	srli	r2,r2,8
    69ec:	113fffcc 	andi	r4,r2,65535
    69f0:	e0bff917 	ldw	r2,-28(fp)
    69f4:	1080020b 	ldhu	r2,8(r2)
    69f8:	10bfffcc 	andi	r2,r2,65535
    69fc:	1004923a 	slli	r2,r2,8
    6a00:	10bfffcc 	andi	r2,r2,65535
    6a04:	2088b03a 	or	r4,r4,r2
    6a08:	00bfc004 	movi	r2,-256
    6a0c:	2084703a 	and	r2,r4,r2
    6a10:	1884b03a 	or	r2,r3,r2
    6a14:	10bfc00c 	andi	r2,r2,65280
    6a18:	1005d23a 	srai	r2,r2,8
    6a1c:	1007883a 	mov	r3,r2
    6a20:	e13fff03 	ldbu	r4,-4(fp)
    6a24:	e0bff917 	ldw	r2,-28(fp)
    6a28:	1080020b 	ldhu	r2,8(r2)
    6a2c:	10bfffcc 	andi	r2,r2,65535
    6a30:	1004d23a 	srli	r2,r2,8
    6a34:	117fffcc 	andi	r5,r2,65535
    6a38:	e0bff917 	ldw	r2,-28(fp)
    6a3c:	1080020b 	ldhu	r2,8(r2)
    6a40:	10bfffcc 	andi	r2,r2,65535
    6a44:	1004923a 	slli	r2,r2,8
    6a48:	10bfffcc 	andi	r2,r2,65535
    6a4c:	288ab03a 	or	r5,r5,r2
    6a50:	00bfc004 	movi	r2,-256
    6a54:	2884703a 	and	r2,r5,r2
    6a58:	2084b03a 	or	r2,r4,r2
    6a5c:	1004923a 	slli	r2,r2,8
    6a60:	1884b03a 	or	r2,r3,r2
    6a64:	1007883a 	mov	r3,r2
    6a68:	e0bff917 	ldw	r2,-28(fp)
    6a6c:	10c0020d 	sth	r3,8(r2)

    ip_addr_set(&(iphdr->dest), dest);
    6a70:	e0bffc17 	ldw	r2,-16(fp)
    6a74:	10000726 	beq	r2,zero,6a94 <ip_output_if+0x218>
    6a78:	e0bffc17 	ldw	r2,-16(fp)
    6a7c:	10c0000b 	ldhu	r3,0(r2)
    6a80:	1080008b 	ldhu	r2,2(r2)
    6a84:	1004943a 	slli	r2,r2,16
    6a88:	10c4b03a 	or	r2,r2,r3
    6a8c:	1007883a 	mov	r3,r2
    6a90:	00000106 	br	6a98 <ip_output_if+0x21c>
    6a94:	0007883a 	mov	r3,zero
    6a98:	e0bff917 	ldw	r2,-28(fp)
    6a9c:	193fffcc 	andi	r4,r3,65535
    6aa0:	1140040b 	ldhu	r5,16(r2)
    6aa4:	280a703a 	and	r5,r5,zero
    6aa8:	2908b03a 	or	r4,r5,r4
    6aac:	1100040d 	sth	r4,16(r2)
    6ab0:	1806d43a 	srli	r3,r3,16
    6ab4:	1100048b 	ldhu	r4,18(r2)
    6ab8:	2008703a 	and	r4,r4,zero
    6abc:	20c6b03a 	or	r3,r4,r3
    6ac0:	10c0048d 	sth	r3,18(r2)

    IPH_VHLTOS_SET(iphdr, 4, ip_hlen / 4, tos);
    6ac4:	e0bff80b 	ldhu	r2,-32(fp)
    6ac8:	1004d0ba 	srli	r2,r2,2
    6acc:	10bfffcc 	andi	r2,r2,65535
    6ad0:	1004923a 	slli	r2,r2,8
    6ad4:	10d00014 	ori	r3,r2,16384
    6ad8:	e0bffe03 	ldbu	r2,-8(fp)
    6adc:	1884b03a 	or	r2,r3,r2
    6ae0:	10bfc00c 	andi	r2,r2,65280
    6ae4:	1005d23a 	srai	r2,r2,8
    6ae8:	1007883a 	mov	r3,r2
    6aec:	e0bff80b 	ldhu	r2,-32(fp)
    6af0:	1004d0ba 	srli	r2,r2,2
    6af4:	10bfffcc 	andi	r2,r2,65535
    6af8:	1004923a 	slli	r2,r2,8
    6afc:	11100014 	ori	r4,r2,16384
    6b00:	e0bffe03 	ldbu	r2,-8(fp)
    6b04:	2084b03a 	or	r2,r4,r2
    6b08:	1004923a 	slli	r2,r2,8
    6b0c:	1884b03a 	or	r2,r3,r2
    6b10:	1007883a 	mov	r3,r2
    6b14:	e0bff917 	ldw	r2,-28(fp)
    6b18:	10c0000d 	sth	r3,0(r2)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
    6b1c:	e0bffa17 	ldw	r2,-24(fp)
    6b20:	1080020b 	ldhu	r2,8(r2)
    6b24:	10bfffcc 	andi	r2,r2,65535
    6b28:	1004d23a 	srli	r2,r2,8
    6b2c:	1007883a 	mov	r3,r2
    6b30:	e0bffa17 	ldw	r2,-24(fp)
    6b34:	1080020b 	ldhu	r2,8(r2)
    6b38:	10bfffcc 	andi	r2,r2,65535
    6b3c:	1004923a 	slli	r2,r2,8
    6b40:	1884b03a 	or	r2,r3,r2
    6b44:	1007883a 	mov	r3,r2
    6b48:	e0bff917 	ldw	r2,-28(fp)
    6b4c:	10c0008d 	sth	r3,2(r2)
    IPH_OFFSET_SET(iphdr, 0);
    6b50:	e0bff917 	ldw	r2,-28(fp)
    6b54:	1000018d 	sth	zero,6(r2)
    IPH_ID_SET(iphdr, htons(ip_id));
    6b58:	d0a8c80b 	ldhu	r2,-23776(gp)
    6b5c:	10bfffcc 	andi	r2,r2,65535
    6b60:	1004d23a 	srli	r2,r2,8
    6b64:	1007883a 	mov	r3,r2
    6b68:	d0a8c80b 	ldhu	r2,-23776(gp)
    6b6c:	10bfffcc 	andi	r2,r2,65535
    6b70:	1004923a 	slli	r2,r2,8
    6b74:	1884b03a 	or	r2,r3,r2
    6b78:	1007883a 	mov	r3,r2
    6b7c:	e0bff917 	ldw	r2,-28(fp)
    6b80:	10c0010d 	sth	r3,4(r2)
    ++ip_id;
    6b84:	d0a8c80b 	ldhu	r2,-23776(gp)
    6b88:	10800044 	addi	r2,r2,1
    6b8c:	d0a8c80d 	sth	r2,-23776(gp)

    if (ip_addr_isany(src)) {
    6b90:	e0bffb17 	ldw	r2,-20(fp)
    6b94:	10000626 	beq	r2,zero,6bb0 <ip_output_if+0x334>
    6b98:	e0bffb17 	ldw	r2,-20(fp)
    6b9c:	10c0000b 	ldhu	r3,0(r2)
    6ba0:	1080008b 	ldhu	r2,2(r2)
    6ba4:	1004943a 	slli	r2,r2,16
    6ba8:	10c4b03a 	or	r2,r2,r3
    6bac:	1000131e 	bne	r2,zero,6bfc <ip_output_if+0x380>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
    6bb0:	e0800417 	ldw	r2,16(fp)
    6bb4:	10800104 	addi	r2,r2,4
    6bb8:	10000326 	beq	r2,zero,6bc8 <ip_output_if+0x34c>
    6bbc:	e0800417 	ldw	r2,16(fp)
    6bc0:	10c00117 	ldw	r3,4(r2)
    6bc4:	00000106 	br	6bcc <ip_output_if+0x350>
    6bc8:	0007883a 	mov	r3,zero
    6bcc:	e0bff917 	ldw	r2,-28(fp)
    6bd0:	193fffcc 	andi	r4,r3,65535
    6bd4:	1140030b 	ldhu	r5,12(r2)
    6bd8:	280a703a 	and	r5,r5,zero
    6bdc:	2908b03a 	or	r4,r5,r4
    6be0:	1100030d 	sth	r4,12(r2)
    6be4:	1806d43a 	srli	r3,r3,16
    6be8:	1100038b 	ldhu	r4,14(r2)
    6bec:	2008703a 	and	r4,r4,zero
    6bf0:	20c6b03a 	or	r3,r4,r3
    6bf4:	10c0038d 	sth	r3,14(r2)
    6bf8:	00001506 	br	6c50 <ip_output_if+0x3d4>
    } else {
      ip_addr_set(&(iphdr->src), src);
    6bfc:	e0bffb17 	ldw	r2,-20(fp)
    6c00:	10000726 	beq	r2,zero,6c20 <ip_output_if+0x3a4>
    6c04:	e0bffb17 	ldw	r2,-20(fp)
    6c08:	10c0000b 	ldhu	r3,0(r2)
    6c0c:	1080008b 	ldhu	r2,2(r2)
    6c10:	1004943a 	slli	r2,r2,16
    6c14:	10c4b03a 	or	r2,r2,r3
    6c18:	1007883a 	mov	r3,r2
    6c1c:	00000106 	br	6c24 <ip_output_if+0x3a8>
    6c20:	0007883a 	mov	r3,zero
    6c24:	e0bff917 	ldw	r2,-28(fp)
    6c28:	193fffcc 	andi	r4,r3,65535
    6c2c:	1140030b 	ldhu	r5,12(r2)
    6c30:	280a703a 	and	r5,r5,zero
    6c34:	2908b03a 	or	r4,r5,r4
    6c38:	1100030d 	sth	r4,12(r2)
    6c3c:	1806d43a 	srli	r3,r3,16
    6c40:	1100038b 	ldhu	r4,14(r2)
    6c44:	2008703a 	and	r4,r4,zero
    6c48:	20c6b03a 	or	r3,r4,r3
    6c4c:	10c0038d 	sth	r3,14(r2)
    }

    IPH_CHKSUM_SET(iphdr, 0);
    6c50:	e0bff917 	ldw	r2,-28(fp)
    6c54:	1000028d 	sth	zero,10(r2)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, ip_hlen));
    6c58:	e0bff80b 	ldhu	r2,-32(fp)
    6c5c:	e13ff917 	ldw	r4,-28(fp)
    6c60:	100b883a 	mov	r5,r2
    6c64:	00060600 	call	6060 <inet_chksum>
    6c68:	e0fff917 	ldw	r3,-28(fp)
    6c6c:	1880028d 	sth	r2,10(r3)
    6c70:	00000606 	br	6c8c <ip_output_if+0x410>
#endif
  } else {
    /* IP header already included in p */
    iphdr = p->payload;
    6c74:	e0bffa17 	ldw	r2,-24(fp)
    6c78:	10800117 	ldw	r2,4(r2)
    6c7c:	e0bff915 	stw	r2,-28(fp)
    dest = &(iphdr->dest);
    6c80:	e0bff917 	ldw	r2,-28(fp)
    6c84:	10800404 	addi	r2,r2,16
    6c88:	e0bffc15 	stw	r2,-16(fp)
  }

  IP_STATS_INC(ip.xmit);
    6c8c:	00800134 	movhi	r2,4
    6c90:	10916104 	addi	r2,r2,17796
    6c94:	1080120b 	ldhu	r2,72(r2)
    6c98:	10800044 	addi	r2,r2,1
    6c9c:	1007883a 	mov	r3,r2
    6ca0:	00800134 	movhi	r2,4
    6ca4:	10916104 	addi	r2,r2,17796
    6ca8:	10c0120d 	sth	r3,72(r2)
    return netif_loop_output(netif, p, dest);
  }
#endif /* ENABLE_LOOPBACK */
#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu)) {
    6cac:	e0800417 	ldw	r2,16(fp)
    6cb0:	1080090b 	ldhu	r2,36(r2)
    6cb4:	10bfffcc 	andi	r2,r2,65535
    6cb8:	10000c26 	beq	r2,zero,6cec <ip_output_if+0x470>
    6cbc:	e0bffa17 	ldw	r2,-24(fp)
    6cc0:	1080020b 	ldhu	r2,8(r2)
    6cc4:	e0c00417 	ldw	r3,16(fp)
    6cc8:	18c0090b 	ldhu	r3,36(r3)
    6ccc:	10bfffcc 	andi	r2,r2,65535
    6cd0:	18ffffcc 	andi	r3,r3,65535
    6cd4:	1880052e 	bgeu	r3,r2,6cec <ip_output_if+0x470>
    return ip_frag(p,netif,dest);
    6cd8:	e13ffa17 	ldw	r4,-24(fp)
    6cdc:	e1400417 	ldw	r5,16(fp)
    6ce0:	e1bffc17 	ldw	r6,-16(fp)
    6ce4:	0007ea40 	call	7ea4 <ip_frag>
    6ce8:	00000606 	br	6d04 <ip_output_if+0x488>
  }
#endif

  LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));
  return netif->output(netif, p, dest);
    6cec:	e0800417 	ldw	r2,16(fp)
    6cf0:	10800517 	ldw	r2,20(r2)
    6cf4:	e1000417 	ldw	r4,16(fp)
    6cf8:	e17ffa17 	ldw	r5,-24(fp)
    6cfc:	e1bffc17 	ldw	r6,-16(fp)
    6d00:	103ee83a 	callr	r2
}
    6d04:	e037883a 	mov	sp,fp
    6d08:	dfc00117 	ldw	ra,4(sp)
    6d0c:	df000017 	ldw	fp,0(sp)
    6d10:	dec00204 	addi	sp,sp,8
    6d14:	f800283a 	ret

00006d18 <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
    6d18:	defff404 	addi	sp,sp,-48
    6d1c:	dfc00b15 	stw	ra,44(sp)
    6d20:	df000a15 	stw	fp,40(sp)
    6d24:	df000a04 	addi	fp,sp,40
    6d28:	e13ffa15 	stw	r4,-24(fp)
    6d2c:	e17ffb15 	stw	r5,-20(fp)
    6d30:	e1bffc15 	stw	r6,-16(fp)
    6d34:	3805883a 	mov	r2,r7
    6d38:	e1000217 	ldw	r4,8(fp)
    6d3c:	e0c00317 	ldw	r3,12(fp)
    6d40:	e0bffd05 	stb	r2,-12(fp)
    6d44:	e13ffe05 	stb	r4,-8(fp)
    6d48:	e0ffff05 	stb	r3,-4(fp)
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
    6d4c:	e13ffc17 	ldw	r4,-16(fp)
    6d50:	00061b00 	call	61b0 <ip_route>
    6d54:	e0bff915 	stw	r2,-28(fp)
    6d58:	e0bff917 	ldw	r2,-28(fp)
    6d5c:	10000a1e 	bne	r2,zero,6d88 <ip_output+0x70>
    LWIP_DEBUGF(IP_DEBUG, ("ip_output: No route to 0x%"X32_F"\n", dest->addr));
    IP_STATS_INC(ip.rterr);
    6d60:	00800134 	movhi	r2,4
    6d64:	10916104 	addi	r2,r2,17796
    6d68:	1080158b 	ldhu	r2,86(r2)
    6d6c:	10800044 	addi	r2,r2,1
    6d70:	1007883a 	mov	r3,r2
    6d74:	00800134 	movhi	r2,4
    6d78:	10916104 	addi	r2,r2,17796
    6d7c:	10c0158d 	sth	r3,86(r2)
    return ERR_RTE;
    6d80:	00bfff04 	movi	r2,-4
    6d84:	00000c06 	br	6db8 <ip_output+0xa0>
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
    6d88:	e0bffd03 	ldbu	r2,-12(fp)
    6d8c:	e13ffe03 	ldbu	r4,-8(fp)
    6d90:	e0ffff03 	ldbu	r3,-4(fp)
    6d94:	d9000015 	stw	r4,0(sp)
    6d98:	d8c00115 	stw	r3,4(sp)
    6d9c:	e0fff917 	ldw	r3,-28(fp)
    6da0:	d8c00215 	stw	r3,8(sp)
    6da4:	e13ffa17 	ldw	r4,-24(fp)
    6da8:	e17ffb17 	ldw	r5,-20(fp)
    6dac:	e1bffc17 	ldw	r6,-16(fp)
    6db0:	100f883a 	mov	r7,r2
    6db4:	000687c0 	call	687c <ip_output_if>
}
    6db8:	e037883a 	mov	sp,fp
    6dbc:	dfc00117 	ldw	ra,4(sp)
    6dc0:	df000017 	ldw	fp,0(sp)
    6dc4:	dec00204 	addi	sp,sp,8
    6dc8:	f800283a 	ret

00006dcc <ip_addr_isbroadcast>:
 * @param addr address to be checked
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
{
    6dcc:	defffc04 	addi	sp,sp,-16
    6dd0:	df000315 	stw	fp,12(sp)
    6dd4:	df000304 	addi	fp,sp,12
    6dd8:	e13ffe15 	stw	r4,-8(fp)
    6ddc:	e17fff15 	stw	r5,-4(fp)
  u32_t addr2test;

  addr2test = addr->addr;
    6de0:	e0bffe17 	ldw	r2,-8(fp)
    6de4:	10c0000b 	ldhu	r3,0(r2)
    6de8:	1080008b 	ldhu	r2,2(r2)
    6dec:	1004943a 	slli	r2,r2,16
    6df0:	10c4b03a 	or	r2,r2,r3
    6df4:	e0bffd15 	stw	r2,-12(fp)
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
    6df8:	e0bffd17 	ldw	r2,-12(fp)
    6dfc:	10bfffe0 	cmpeqi	r2,r2,-1
    6e00:	1000021e 	bne	r2,zero,6e0c <ip_addr_isbroadcast+0x40>
    6e04:	e0bffd17 	ldw	r2,-12(fp)
    6e08:	1000021e 	bne	r2,zero,6e14 <ip_addr_isbroadcast+0x48>
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
    6e0c:	00800044 	movi	r2,1
    6e10:	00002606 	br	6eac <ip_addr_isbroadcast+0xe0>
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
    6e14:	e0bfff17 	ldw	r2,-4(fp)
    6e18:	10800b43 	ldbu	r2,45(r2)
    6e1c:	10803fcc 	andi	r2,r2,255
    6e20:	1080008c 	andi	r2,r2,2
    6e24:	1000021e 	bne	r2,zero,6e30 <ip_addr_isbroadcast+0x64>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
    6e28:	0005883a 	mov	r2,zero
    6e2c:	00001f06 	br	6eac <ip_addr_isbroadcast+0xe0>
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
    6e30:	e0bfff17 	ldw	r2,-4(fp)
    6e34:	10c00117 	ldw	r3,4(r2)
    6e38:	e0bffd17 	ldw	r2,-12(fp)
    6e3c:	1880021e 	bne	r3,r2,6e48 <ip_addr_isbroadcast+0x7c>
    return 0;
    6e40:	0005883a 	mov	r2,zero
    6e44:	00001906 	br	6eac <ip_addr_isbroadcast+0xe0>
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
    6e48:	e0bffe17 	ldw	r2,-8(fp)
    6e4c:	10c0000b 	ldhu	r3,0(r2)
    6e50:	1080008b 	ldhu	r2,2(r2)
    6e54:	1004943a 	slli	r2,r2,16
    6e58:	10c4b03a 	or	r2,r2,r3
    6e5c:	1007883a 	mov	r3,r2
    6e60:	e0bfff17 	ldw	r2,-4(fp)
    6e64:	10800117 	ldw	r2,4(r2)
    6e68:	1886f03a 	xor	r3,r3,r2
    6e6c:	e0bfff17 	ldw	r2,-4(fp)
    6e70:	10800217 	ldw	r2,8(r2)
    6e74:	1884703a 	and	r2,r3,r2
    6e78:	10000b1e 	bne	r2,zero,6ea8 <ip_addr_isbroadcast+0xdc>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
    6e7c:	e0bfff17 	ldw	r2,-4(fp)
    6e80:	10800217 	ldw	r2,8(r2)
    6e84:	0086303a 	nor	r3,zero,r2
    6e88:	e0bffd17 	ldw	r2,-12(fp)
    6e8c:	1886703a 	and	r3,r3,r2
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    6e90:	e0bfff17 	ldw	r2,-4(fp)
    6e94:	10800217 	ldw	r2,8(r2)
    6e98:	0084303a 	nor	r2,zero,r2
  else if (addr2test == netif->ip_addr.addr)
    return 0;
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
    6e9c:	1880021e 	bne	r3,r2,6ea8 <ip_addr_isbroadcast+0xdc>
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
    6ea0:	00800044 	movi	r2,1
    6ea4:	00000106 	br	6eac <ip_addr_isbroadcast+0xe0>
  else
    return 0;
    6ea8:	0005883a 	mov	r2,zero
}
    6eac:	e037883a 	mov	sp,fp
    6eb0:	df000017 	ldw	fp,0(sp)
    6eb4:	dec00104 	addi	sp,sp,4
    6eb8:	f800283a 	ret

00006ebc <ip_reass_tmr>:
 *
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
    6ebc:	defffb04 	addi	sp,sp,-20
    6ec0:	dfc00415 	stw	ra,16(sp)
    6ec4:	df000315 	stw	fp,12(sp)
    6ec8:	df000304 	addi	fp,sp,12
  struct ip_reassdata *r, *prev = NULL;
    6ecc:	e03ffe15 	stw	zero,-8(fp)

  r = reassdatagrams;
    6ed0:	d0a8cb17 	ldw	r2,-23764(gp)
    6ed4:	e0bffd15 	stw	r2,-12(fp)
  while (r != NULL) {
    6ed8:	00001806 	br	6f3c <ip_reass_tmr+0x80>
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
    6edc:	e0bffd17 	ldw	r2,-12(fp)
    6ee0:	108007c3 	ldbu	r2,31(r2)
    6ee4:	10803fcc 	andi	r2,r2,255
    6ee8:	10000c26 	beq	r2,zero,6f1c <ip_reass_tmr+0x60>
      r->timer--;
    6eec:	e0bffd17 	ldw	r2,-12(fp)
    6ef0:	108007c3 	ldbu	r2,31(r2)
    6ef4:	10bfffc4 	addi	r2,r2,-1
    6ef8:	1007883a 	mov	r3,r2
    6efc:	e0bffd17 	ldw	r2,-12(fp)
    6f00:	10c007c5 	stb	r3,31(r2)
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
      prev = r;
    6f04:	e0bffd17 	ldw	r2,-12(fp)
    6f08:	e0bffe15 	stw	r2,-8(fp)
      r = r->next;
    6f0c:	e0bffd17 	ldw	r2,-12(fp)
    6f10:	10800017 	ldw	r2,0(r2)
    6f14:	e0bffd15 	stw	r2,-12(fp)
    6f18:	00000806 	br	6f3c <ip_reass_tmr+0x80>
    } else {
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
    6f1c:	e0bffd17 	ldw	r2,-12(fp)
    6f20:	e0bfff15 	stw	r2,-4(fp)
      /* get the next pointer before freeing */
      r = r->next;
    6f24:	e0bffd17 	ldw	r2,-12(fp)
    6f28:	10800017 	ldw	r2,0(r2)
    6f2c:	e0bffd15 	stw	r2,-12(fp)
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
    6f30:	e13fff17 	ldw	r4,-4(fp)
    6f34:	e17ffe17 	ldw	r5,-8(fp)
    6f38:	0006f580 	call	6f58 <ip_reass_free_complete_datagram>
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  while (r != NULL) {
    6f3c:	e0bffd17 	ldw	r2,-12(fp)
    6f40:	103fe61e 	bne	r2,zero,6edc <ip_reass_tmr+0x20>
      r = r->next;
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
     }
   }
}
    6f44:	e037883a 	mov	sp,fp
    6f48:	dfc00117 	ldw	ra,4(sp)
    6f4c:	df000017 	ldw	fp,0(sp)
    6f50:	dec00204 	addi	sp,sp,8
    6f54:	f800283a 	ret

00006f58 <ip_reass_free_complete_datagram>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
    6f58:	defff804 	addi	sp,sp,-32
    6f5c:	dfc00715 	stw	ra,28(sp)
    6f60:	df000615 	stw	fp,24(sp)
    6f64:	df000604 	addi	fp,sp,24
    6f68:	e13ffe15 	stw	r4,-8(fp)
    6f6c:	e17fff15 	stw	r5,-4(fp)
  int pbufs_freed = 0;
    6f70:	e03ffa15 	stw	zero,-24(fp)
  struct pbuf *p;
  struct ip_reass_helper *iprh;

  LWIP_ASSERT("prev != ipr", prev != ipr);
    6f74:	e0ffff17 	ldw	r3,-4(fp)
    6f78:	e0bffe17 	ldw	r2,-8(fp)
    6f7c:	1880091e 	bne	r3,r2,6fa4 <ip_reass_free_complete_datagram+0x4c>
    6f80:	010000f4 	movhi	r4,3
    6f84:	2139aa04 	addi	r4,r4,-6488
    6f88:	014000f4 	movhi	r5,3
    6f8c:	2979b404 	addi	r5,r5,-6448
    6f90:	01802884 	movi	r6,162
    6f94:	01c000f4 	movhi	r7,3
    6f98:	39f9b704 	addi	r7,r7,-6436
    6f9c:	00170680 	call	17068 <printf>
    6fa0:	003fff06 	br	6fa0 <ip_reass_free_complete_datagram+0x48>
  if (prev != NULL) {
    6fa4:	e0bfff17 	ldw	r2,-4(fp)
    6fa8:	10000d26 	beq	r2,zero,6fe0 <ip_reass_free_complete_datagram+0x88>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
    6fac:	e0bfff17 	ldw	r2,-4(fp)
    6fb0:	10c00017 	ldw	r3,0(r2)
    6fb4:	e0bffe17 	ldw	r2,-8(fp)
    6fb8:	18800926 	beq	r3,r2,6fe0 <ip_reass_free_complete_datagram+0x88>
    6fbc:	010000f4 	movhi	r4,3
    6fc0:	2139aa04 	addi	r4,r4,-6488
    6fc4:	014000f4 	movhi	r5,3
    6fc8:	2979bf04 	addi	r5,r5,-6404
    6fcc:	01802904 	movi	r6,164
    6fd0:	01c000f4 	movhi	r7,3
    6fd4:	39f9b704 	addi	r7,r7,-6436
    6fd8:	00170680 	call	17068 <printf>
    6fdc:	003fff06 	br	6fdc <ip_reass_free_complete_datagram+0x84>
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
    6fe0:	e0bffe17 	ldw	r2,-8(fp)
    6fe4:	10800117 	ldw	r2,4(r2)
    6fe8:	10800117 	ldw	r2,4(r2)
    6fec:	e0bffc15 	stw	r2,-16(fp)
  if (iprh->start == 0) {
    6ff0:	e0bffc17 	ldw	r2,-16(fp)
    6ff4:	1080010b 	ldhu	r2,4(r2)
    6ff8:	10bfffcc 	andi	r2,r2,65535
    6ffc:	10001e1e 	bne	r2,zero,7078 <ip_reass_free_complete_datagram+0x120>
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
    7000:	e0bffe17 	ldw	r2,-8(fp)
    7004:	10800117 	ldw	r2,4(r2)
    7008:	e0bffb15 	stw	r2,-20(fp)
    ipr->p = iprh->next_pbuf;
    700c:	e0bffc17 	ldw	r2,-16(fp)
    7010:	10c0000b 	ldhu	r3,0(r2)
    7014:	1080008b 	ldhu	r2,2(r2)
    7018:	1004943a 	slli	r2,r2,16
    701c:	10c4b03a 	or	r2,r2,r3
    7020:	1007883a 	mov	r3,r2
    7024:	e0bffe17 	ldw	r2,-8(fp)
    7028:	10c00115 	stw	r3,4(r2)
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
    702c:	e0bffb17 	ldw	r2,-20(fp)
    7030:	10c00117 	ldw	r3,4(r2)
    7034:	e0bffe17 	ldw	r2,-8(fp)
    7038:	10800204 	addi	r2,r2,8
    703c:	1809883a 	mov	r4,r3
    7040:	100b883a 	mov	r5,r2
    7044:	01800504 	movi	r6,20
    7048:	0016e680 	call	16e68 <memcpy>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
    704c:	e13ffb17 	ldw	r4,-20(fp)
    7050:	01400044 	movi	r5,1
    7054:	00054cc0 	call	54cc <icmp_time_exceeded>
    pbufs_freed += pbuf_clen(p);
    7058:	e13ffb17 	ldw	r4,-20(fp)
    705c:	000a3540 	call	a354 <pbuf_clen>
    7060:	10803fcc 	andi	r2,r2,255
    7064:	e0fffa17 	ldw	r3,-24(fp)
    7068:	1885883a 	add	r2,r3,r2
    706c:	e0bffa15 	stw	r2,-24(fp)
    pbuf_free(p);
    7070:	e13ffb17 	ldw	r4,-20(fp)
    7074:	000a1880 	call	a188 <pbuf_free>
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
    7078:	e0bffe17 	ldw	r2,-8(fp)
    707c:	10800117 	ldw	r2,4(r2)
    7080:	e0bffb15 	stw	r2,-20(fp)
  while (p != NULL) {
    7084:	00001306 	br	70d4 <ip_reass_free_complete_datagram+0x17c>
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
    7088:	e0bffb17 	ldw	r2,-20(fp)
    708c:	10800117 	ldw	r2,4(r2)
    7090:	e0bffc15 	stw	r2,-16(fp)
    pcur = p;
    7094:	e0bffb17 	ldw	r2,-20(fp)
    7098:	e0bffd15 	stw	r2,-12(fp)
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
    709c:	e0bffc17 	ldw	r2,-16(fp)
    70a0:	10c0000b 	ldhu	r3,0(r2)
    70a4:	1080008b 	ldhu	r2,2(r2)
    70a8:	1004943a 	slli	r2,r2,16
    70ac:	10c4b03a 	or	r2,r2,r3
    70b0:	e0bffb15 	stw	r2,-20(fp)
    pbufs_freed += pbuf_clen(pcur);
    70b4:	e13ffd17 	ldw	r4,-12(fp)
    70b8:	000a3540 	call	a354 <pbuf_clen>
    70bc:	10803fcc 	andi	r2,r2,255
    70c0:	e0fffa17 	ldw	r3,-24(fp)
    70c4:	1885883a 	add	r2,r3,r2
    70c8:	e0bffa15 	stw	r2,-24(fp)
    pbuf_free(pcur);    
    70cc:	e13ffd17 	ldw	r4,-12(fp)
    70d0:	000a1880 	call	a188 <pbuf_free>
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
    70d4:	e0bffb17 	ldw	r2,-20(fp)
    70d8:	103feb1e 	bne	r2,zero,7088 <ip_reass_free_complete_datagram+0x130>
    p = iprh->next_pbuf;
    pbufs_freed += pbuf_clen(pcur);
    pbuf_free(pcur);    
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
    70dc:	e13ffe17 	ldw	r4,-8(fp)
    70e0:	e17fff17 	ldw	r5,-4(fp)
    70e4:	00073740 	call	7374 <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
    70e8:	d0a8cc0b 	ldhu	r2,-23760(gp)
    70ec:	10ffffcc 	andi	r3,r2,65535
    70f0:	e0bffa17 	ldw	r2,-24(fp)
    70f4:	1880090e 	bge	r3,r2,711c <ip_reass_free_complete_datagram+0x1c4>
    70f8:	010000f4 	movhi	r4,3
    70fc:	2139aa04 	addi	r4,r4,-6488
    7100:	014000f4 	movhi	r5,3
    7104:	2979c404 	addi	r5,r5,-6384
    7108:	01803144 	movi	r6,197
    710c:	01c000f4 	movhi	r7,3
    7110:	39f9b704 	addi	r7,r7,-6436
    7114:	00170680 	call	17068 <printf>
    7118:	003fff06 	br	7118 <ip_reass_free_complete_datagram+0x1c0>
  ip_reass_pbufcount -= pbufs_freed;
    711c:	d0e8cc0b 	ldhu	r3,-23760(gp)
    7120:	e0bffa17 	ldw	r2,-24(fp)
    7124:	1885c83a 	sub	r2,r3,r2
    7128:	d0a8cc0d 	sth	r2,-23760(gp)

  return pbufs_freed;
    712c:	e0bffa17 	ldw	r2,-24(fp)
}
    7130:	e037883a 	mov	sp,fp
    7134:	dfc00117 	ldw	ra,4(sp)
    7138:	df000017 	ldw	fp,0(sp)
    713c:	dec00204 	addi	sp,sp,8
    7140:	f800283a 	ret

00007144 <ip_reass_remove_oldest_datagram>:
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
    7144:	defff604 	addi	sp,sp,-40
    7148:	dfc00915 	stw	ra,36(sp)
    714c:	df000815 	stw	fp,32(sp)
    7150:	df000804 	addi	fp,sp,32
    7154:	e13ffe15 	stw	r4,-8(fp)
    7158:	e17fff15 	stw	r5,-4(fp)
  /* @todo Can't we simply remove the last datagram in the
   *       linked list behind reassdatagrams?
   */
  struct ip_reassdata *r, *oldest, *prev;
  int pbufs_freed = 0, pbufs_freed_current;
    715c:	e03ffb15 	stw	zero,-20(fp)
  int other_datagrams;

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    7160:	e03ff915 	stw	zero,-28(fp)
    prev = NULL;
    7164:	e03ffa15 	stw	zero,-24(fp)
    other_datagrams = 0;
    7168:	e03ffc15 	stw	zero,-16(fp)
    r = reassdatagrams;
    716c:	d0a8cb17 	ldw	r2,-23764(gp)
    7170:	e0bff815 	stw	r2,-32(fp)
    while (r != NULL) {
    7174:	00003006 	br	7238 <ip_reass_remove_oldest_datagram+0xf4>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
    7178:	e0bff817 	ldw	r2,-32(fp)
    717c:	10c00517 	ldw	r3,20(r2)
    7180:	e0bffe17 	ldw	r2,-8(fp)
    7184:	1100030b 	ldhu	r4,12(r2)
    7188:	1080038b 	ldhu	r2,14(r2)
    718c:	1004943a 	slli	r2,r2,16
    7190:	1104b03a 	or	r2,r2,r4
    7194:	18800f1e 	bne	r3,r2,71d4 <ip_reass_remove_oldest_datagram+0x90>
    7198:	e0bff817 	ldw	r2,-32(fp)
    719c:	10c00617 	ldw	r3,24(r2)
    71a0:	e0bffe17 	ldw	r2,-8(fp)
    71a4:	1100040b 	ldhu	r4,16(r2)
    71a8:	1080048b 	ldhu	r2,18(r2)
    71ac:	1004943a 	slli	r2,r2,16
    71b0:	1104b03a 	or	r2,r2,r4
    71b4:	1880071e 	bne	r3,r2,71d4 <ip_reass_remove_oldest_datagram+0x90>
    71b8:	e0bff817 	ldw	r2,-32(fp)
    71bc:	10c0030b 	ldhu	r3,12(r2)
    71c0:	e0bffe17 	ldw	r2,-8(fp)
    71c4:	1080010b 	ldhu	r2,4(r2)
    71c8:	18ffffcc 	andi	r3,r3,65535
    71cc:	10bfffcc 	andi	r2,r2,65535
    71d0:	18801126 	beq	r3,r2,7218 <ip_reass_remove_oldest_datagram+0xd4>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
    71d4:	e0bffc17 	ldw	r2,-16(fp)
    71d8:	10800044 	addi	r2,r2,1
    71dc:	e0bffc15 	stw	r2,-16(fp)
        if (oldest == NULL) {
    71e0:	e0bff917 	ldw	r2,-28(fp)
    71e4:	1000031e 	bne	r2,zero,71f4 <ip_reass_remove_oldest_datagram+0xb0>
          oldest = r;
    71e8:	e0bff817 	ldw	r2,-32(fp)
    71ec:	e0bff915 	stw	r2,-28(fp)
    71f0:	00000906 	br	7218 <ip_reass_remove_oldest_datagram+0xd4>
        } else if (r->timer <= oldest->timer) {
    71f4:	e0bff817 	ldw	r2,-32(fp)
    71f8:	108007c3 	ldbu	r2,31(r2)
    71fc:	e0fff917 	ldw	r3,-28(fp)
    7200:	18c007c3 	ldbu	r3,31(r3)
    7204:	10803fcc 	andi	r2,r2,255
    7208:	18c03fcc 	andi	r3,r3,255
    720c:	18800236 	bltu	r3,r2,7218 <ip_reass_remove_oldest_datagram+0xd4>
          /* older than the previous oldest */
          oldest = r;
    7210:	e0bff817 	ldw	r2,-32(fp)
    7214:	e0bff915 	stw	r2,-28(fp)
        }
      }
      if (r->next != NULL) {
    7218:	e0bff817 	ldw	r2,-32(fp)
    721c:	10800017 	ldw	r2,0(r2)
    7220:	10000226 	beq	r2,zero,722c <ip_reass_remove_oldest_datagram+0xe8>
        prev = r;
    7224:	e0bff817 	ldw	r2,-32(fp)
    7228:	e0bffa15 	stw	r2,-24(fp)
      }
      r = r->next;
    722c:	e0bff817 	ldw	r2,-32(fp)
    7230:	10800017 	ldw	r2,0(r2)
    7234:	e0bff815 	stw	r2,-32(fp)
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
    7238:	e0bff817 	ldw	r2,-32(fp)
    723c:	103fce1e 	bne	r2,zero,7178 <ip_reass_remove_oldest_datagram+0x34>
      if (r->next != NULL) {
        prev = r;
      }
      r = r->next;
    }
    if (oldest != NULL) {
    7240:	e0bff917 	ldw	r2,-28(fp)
    7244:	10000826 	beq	r2,zero,7268 <ip_reass_remove_oldest_datagram+0x124>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
    7248:	e13ff917 	ldw	r4,-28(fp)
    724c:	e17ffa17 	ldw	r5,-24(fp)
    7250:	0006f580 	call	6f58 <ip_reass_free_complete_datagram>
    7254:	e0bffd15 	stw	r2,-12(fp)
      pbufs_freed += pbufs_freed_current;
    7258:	e0fffb17 	ldw	r3,-20(fp)
    725c:	e0bffd17 	ldw	r2,-12(fp)
    7260:	1885883a 	add	r2,r3,r2
    7264:	e0bffb15 	stw	r2,-20(fp)
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
    7268:	e0fffb17 	ldw	r3,-20(fp)
    726c:	e0bfff17 	ldw	r2,-4(fp)
    7270:	1880030e 	bge	r3,r2,7280 <ip_reass_remove_oldest_datagram+0x13c>
    7274:	e0bffc17 	ldw	r2,-16(fp)
    7278:	10800088 	cmpgei	r2,r2,2
    727c:	103fb81e 	bne	r2,zero,7160 <ip_reass_remove_oldest_datagram+0x1c>
  return pbufs_freed;
    7280:	e0bffb17 	ldw	r2,-20(fp)
}
    7284:	e037883a 	mov	sp,fp
    7288:	dfc00117 	ldw	ra,4(sp)
    728c:	df000017 	ldw	fp,0(sp)
    7290:	dec00204 	addi	sp,sp,8
    7294:	f800283a 	ret

00007298 <ip_reass_enqueue_new_datagram>:
 * @param clen number of pbufs needed to enqueue (used for freeing other datagrams if not enough space)
 * @return A pointer to the queue location into which the fragment was enqueued
 */
static struct ip_reassdata*
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
    7298:	defffb04 	addi	sp,sp,-20
    729c:	dfc00415 	stw	ra,16(sp)
    72a0:	df000315 	stw	fp,12(sp)
    72a4:	df000304 	addi	fp,sp,12
    72a8:	e13ffe15 	stw	r4,-8(fp)
    72ac:	e17fff15 	stw	r5,-4(fp)
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = memp_malloc(MEMP_REASSDATA);
    72b0:	01000144 	movi	r4,5
    72b4:	0008f0c0 	call	8f0c <memp_malloc>
    72b8:	e0bffd15 	stw	r2,-12(fp)
  if (ipr == NULL) {
    72bc:	e0bffd17 	ldw	r2,-12(fp)
    72c0:	1000141e 	bne	r2,zero,7314 <ip_reass_enqueue_new_datagram+0x7c>
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
    72c4:	e13ffe17 	ldw	r4,-8(fp)
    72c8:	e17fff17 	ldw	r5,-4(fp)
    72cc:	00071440 	call	7144 <ip_reass_remove_oldest_datagram>
    72d0:	e0ffff17 	ldw	r3,-4(fp)
    72d4:	10c00316 	blt	r2,r3,72e4 <ip_reass_enqueue_new_datagram+0x4c>
      ipr = memp_malloc(MEMP_REASSDATA);
    72d8:	01000144 	movi	r4,5
    72dc:	0008f0c0 	call	8f0c <memp_malloc>
    72e0:	e0bffd15 	stw	r2,-12(fp)
    }
    if (ipr == NULL)
    72e4:	e0bffd17 	ldw	r2,-12(fp)
    72e8:	10000a1e 	bne	r2,zero,7314 <ip_reass_enqueue_new_datagram+0x7c>
#endif /* IP_REASS_FREE_OLDEST */
    {
      IPFRAG_STATS_INC(ip_frag.memerr);
    72ec:	00800134 	movhi	r2,4
    72f0:	10916104 	addi	r2,r2,17796
    72f4:	10800f0b 	ldhu	r2,60(r2)
    72f8:	10800044 	addi	r2,r2,1
    72fc:	1007883a 	mov	r3,r2
    7300:	00800134 	movhi	r2,4
    7304:	10916104 	addi	r2,r2,17796
    7308:	10c00f0d 	sth	r3,60(r2)
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
    730c:	0005883a 	mov	r2,zero
    7310:	00001306 	br	7360 <ip_reass_enqueue_new_datagram+0xc8>
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
    7314:	e13ffd17 	ldw	r4,-12(fp)
    7318:	000b883a 	mov	r5,zero
    731c:	01800804 	movi	r6,32
    7320:	0016f600 	call	16f60 <memset>
  ipr->timer = IP_REASS_MAXAGE;
    7324:	e0bffd17 	ldw	r2,-12(fp)
    7328:	00c000c4 	movi	r3,3
    732c:	10c007c5 	stb	r3,31(r2)

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
    7330:	d0e8cb17 	ldw	r3,-23764(gp)
    7334:	e0bffd17 	ldw	r2,-12(fp)
    7338:	10c00015 	stw	r3,0(r2)
  reassdatagrams = ipr;
    733c:	e0bffd17 	ldw	r2,-12(fp)
    7340:	d0a8cb15 	stw	r2,-23764(gp)
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
    7344:	e0bffd17 	ldw	r2,-12(fp)
    7348:	10800204 	addi	r2,r2,8
    734c:	1009883a 	mov	r4,r2
    7350:	e17ffe17 	ldw	r5,-8(fp)
    7354:	01800504 	movi	r6,20
    7358:	0016e680 	call	16e68 <memcpy>
  return ipr;
    735c:	e0bffd17 	ldw	r2,-12(fp)
}
    7360:	e037883a 	mov	sp,fp
    7364:	dfc00117 	ldw	ra,4(sp)
    7368:	df000017 	ldw	fp,0(sp)
    736c:	dec00204 	addi	sp,sp,8
    7370:	f800283a 	ret

00007374 <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
    7374:	defffc04 	addi	sp,sp,-16
    7378:	dfc00315 	stw	ra,12(sp)
    737c:	df000215 	stw	fp,8(sp)
    7380:	df000204 	addi	fp,sp,8
    7384:	e13ffe15 	stw	r4,-8(fp)
    7388:	e17fff15 	stw	r5,-4(fp)
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
    738c:	d0e8cb17 	ldw	r3,-23764(gp)
    7390:	e0bffe17 	ldw	r2,-8(fp)
    7394:	1880041e 	bne	r3,r2,73a8 <ip_reass_dequeue_datagram+0x34>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
    7398:	e0bffe17 	ldw	r2,-8(fp)
    739c:	10800017 	ldw	r2,0(r2)
    73a0:	d0a8cb15 	stw	r2,-23764(gp)
    73a4:	00000f06 	br	73e4 <ip_reass_dequeue_datagram+0x70>
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
    73a8:	e0bfff17 	ldw	r2,-4(fp)
    73ac:	1000091e 	bne	r2,zero,73d4 <ip_reass_dequeue_datagram+0x60>
    73b0:	010000f4 	movhi	r4,3
    73b4:	2139aa04 	addi	r4,r4,-6488
    73b8:	014000f4 	movhi	r5,3
    73bc:	2979cb04 	addi	r5,r5,-6356
    73c0:	01804c84 	movi	r6,306
    73c4:	01c000f4 	movhi	r7,3
    73c8:	39f9b704 	addi	r7,r7,-6436
    73cc:	00170680 	call	17068 <printf>
    73d0:	003fff06 	br	73d0 <ip_reass_dequeue_datagram+0x5c>
    prev->next = ipr->next;
    73d4:	e0bffe17 	ldw	r2,-8(fp)
    73d8:	10c00017 	ldw	r3,0(r2)
    73dc:	e0bfff17 	ldw	r2,-4(fp)
    73e0:	10c00015 	stw	r3,0(r2)
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
    73e4:	01000144 	movi	r4,5
    73e8:	e17ffe17 	ldw	r5,-8(fp)
    73ec:	00090e80 	call	90e8 <memp_free>
}
    73f0:	e037883a 	mov	sp,fp
    73f4:	dfc00117 	ldw	ra,4(sp)
    73f8:	df000017 	ldw	fp,0(sp)
    73fc:	dec00204 	addi	sp,sp,8
    7400:	f800283a 	ret

00007404 <ip_reass_chain_frag_into_datagram_and_validate>:
 * @param new_p points to the pbuf for the current fragment
 * @return 0 if invalid, >0 otherwise
 */
static int
ip_reass_chain_frag_into_datagram_and_validate(struct ip_reassdata *ipr, struct pbuf *new_p)
{
    7404:	defff404 	addi	sp,sp,-48
    7408:	dfc00b15 	stw	ra,44(sp)
    740c:	df000a15 	stw	fp,40(sp)
    7410:	dc000915 	stw	r16,36(sp)
    7414:	df000904 	addi	fp,sp,36
    7418:	e13ffe15 	stw	r4,-8(fp)
    741c:	e17fff15 	stw	r5,-4(fp)
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
    7420:	e03ff815 	stw	zero,-32(fp)
  struct pbuf *q;
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;
    7424:	00800044 	movi	r2,1
    7428:	e0bffa15 	stw	r2,-24(fp)

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
    742c:	e0bfff17 	ldw	r2,-4(fp)
    7430:	10800117 	ldw	r2,4(r2)
    7434:	e0bffb15 	stw	r2,-20(fp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    7438:	e0bffb17 	ldw	r2,-20(fp)
    743c:	1080008b 	ldhu	r2,2(r2)
    7440:	10bfffcc 	andi	r2,r2,65535
    7444:	1004d23a 	srli	r2,r2,8
    7448:	1007883a 	mov	r3,r2
    744c:	e0bffb17 	ldw	r2,-20(fp)
    7450:	1080008b 	ldhu	r2,2(r2)
    7454:	10bfffcc 	andi	r2,r2,65535
    7458:	1004923a 	slli	r2,r2,8
    745c:	1884b03a 	or	r2,r3,r2
    7460:	1007883a 	mov	r3,r2
    7464:	e0bffb17 	ldw	r2,-20(fp)
    7468:	1080000b 	ldhu	r2,0(r2)
    746c:	10bfffcc 	andi	r2,r2,65535
    7470:	1004d23a 	srli	r2,r2,8
    7474:	113fffcc 	andi	r4,r2,65535
    7478:	e0bffb17 	ldw	r2,-20(fp)
    747c:	1080000b 	ldhu	r2,0(r2)
    7480:	10bfffcc 	andi	r2,r2,65535
    7484:	1004923a 	slli	r2,r2,8
    7488:	10bfffcc 	andi	r2,r2,65535
    748c:	2084b03a 	or	r2,r4,r2
    7490:	1005d23a 	srai	r2,r2,8
    7494:	108003cc 	andi	r2,r2,15
    7498:	10bfff24 	muli	r2,r2,-4
    749c:	1885883a 	add	r2,r3,r2
    74a0:	e0bffc0d 	sth	r2,-16(fp)
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
    74a4:	e0bffb17 	ldw	r2,-20(fp)
    74a8:	1080018b 	ldhu	r2,6(r2)
    74ac:	10bfffcc 	andi	r2,r2,65535
    74b0:	1004d23a 	srli	r2,r2,8
    74b4:	10ffffcc 	andi	r3,r2,65535
    74b8:	e0bffb17 	ldw	r2,-20(fp)
    74bc:	1080018b 	ldhu	r2,6(r2)
    74c0:	10bfffcc 	andi	r2,r2,65535
    74c4:	1004923a 	slli	r2,r2,8
    74c8:	10bfffcc 	andi	r2,r2,65535
    74cc:	1884b03a 	or	r2,r3,r2
    74d0:	1087ffcc 	andi	r2,r2,8191
    74d4:	100490fa 	slli	r2,r2,3
    74d8:	e0bffc8d 	sth	r2,-14(fp)
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
    74dc:	e0bfff17 	ldw	r2,-4(fp)
    74e0:	10800117 	ldw	r2,4(r2)
    74e4:	e0bff715 	stw	r2,-36(fp)
  iprh->next_pbuf = NULL;
    74e8:	e0bff717 	ldw	r2,-36(fp)
    74ec:	10c0000b 	ldhu	r3,0(r2)
    74f0:	1806703a 	and	r3,r3,zero
    74f4:	10c0000d 	sth	r3,0(r2)
    74f8:	10c0008b 	ldhu	r3,2(r2)
    74fc:	1806703a 	and	r3,r3,zero
    7500:	10c0008d 	sth	r3,2(r2)
  iprh->start = offset;
    7504:	e0bff717 	ldw	r2,-36(fp)
    7508:	e0fffc8b 	ldhu	r3,-14(fp)
    750c:	10c0010d 	sth	r3,4(r2)
  iprh->end = offset + len;
    7510:	e0fffc8b 	ldhu	r3,-14(fp)
    7514:	e0bffc0b 	ldhu	r2,-16(fp)
    7518:	1885883a 	add	r2,r3,r2
    751c:	1007883a 	mov	r3,r2
    7520:	e0bff717 	ldw	r2,-36(fp)
    7524:	10c0018d 	sth	r3,6(r2)

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    7528:	e0bffe17 	ldw	r2,-8(fp)
    752c:	10800117 	ldw	r2,4(r2)
    7530:	e0bff915 	stw	r2,-28(fp)
    7534:	00005906 	br	769c <ip_reass_chain_frag_into_datagram_and_validate+0x298>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
    7538:	e0bff917 	ldw	r2,-28(fp)
    753c:	10800117 	ldw	r2,4(r2)
    7540:	e0bffd15 	stw	r2,-12(fp)
    if (iprh->start < iprh_tmp->start) {
    7544:	e0bff717 	ldw	r2,-36(fp)
    7548:	10c0010b 	ldhu	r3,4(r2)
    754c:	e0bffd17 	ldw	r2,-12(fp)
    7550:	1080010b 	ldhu	r2,4(r2)
    7554:	18ffffcc 	andi	r3,r3,65535
    7558:	10bfffcc 	andi	r2,r2,65535
    755c:	18802f2e 	bgeu	r3,r2,761c <ip_reass_chain_frag_into_datagram_and_validate+0x218>
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
    7560:	e0bff717 	ldw	r2,-36(fp)
    7564:	e0fff917 	ldw	r3,-28(fp)
    7568:	18ffffcc 	andi	r3,r3,65535
    756c:	1100000b 	ldhu	r4,0(r2)
    7570:	2008703a 	and	r4,r4,zero
    7574:	20c6b03a 	or	r3,r4,r3
    7578:	10c0000d 	sth	r3,0(r2)
    757c:	e0fff917 	ldw	r3,-28(fp)
    7580:	1806d43a 	srli	r3,r3,16
    7584:	1100008b 	ldhu	r4,2(r2)
    7588:	2008703a 	and	r4,r4,zero
    758c:	20c6b03a 	or	r3,r4,r3
    7590:	10c0008d 	sth	r3,2(r2)
      if (iprh_prev != NULL) {
    7594:	e0bff817 	ldw	r2,-32(fp)
    7598:	10001c26 	beq	r2,zero,760c <ip_reass_chain_frag_into_datagram_and_validate+0x208>
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
    759c:	e0bff717 	ldw	r2,-36(fp)
    75a0:	10c0010b 	ldhu	r3,4(r2)
    75a4:	e0bff817 	ldw	r2,-32(fp)
    75a8:	1080018b 	ldhu	r2,6(r2)
    75ac:	18ffffcc 	andi	r3,r3,65535
    75b0:	10bfffcc 	andi	r2,r2,65535
    75b4:	1880e436 	bltu	r3,r2,7948 <ip_reass_chain_frag_into_datagram_and_validate+0x544>
    75b8:	e0bff717 	ldw	r2,-36(fp)
    75bc:	1080018b 	ldhu	r2,6(r2)
    75c0:	e0fffd17 	ldw	r3,-12(fp)
    75c4:	18c0010b 	ldhu	r3,4(r3)
    75c8:	10bfffcc 	andi	r2,r2,65535
    75cc:	18ffffcc 	andi	r3,r3,65535
    75d0:	1880dd36 	bltu	r3,r2,7948 <ip_reass_chain_frag_into_datagram_and_validate+0x544>
          /* fragment overlaps with previous or following, throw away */
          goto freepbuf;
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
    75d4:	e0bff817 	ldw	r2,-32(fp)
    75d8:	e0ffff17 	ldw	r3,-4(fp)
    75dc:	18ffffcc 	andi	r3,r3,65535
    75e0:	1100000b 	ldhu	r4,0(r2)
    75e4:	2008703a 	and	r4,r4,zero
    75e8:	20c6b03a 	or	r3,r4,r3
    75ec:	10c0000d 	sth	r3,0(r2)
    75f0:	e0ffff17 	ldw	r3,-4(fp)
    75f4:	1806d43a 	srli	r3,r3,16
    75f8:	1100008b 	ldhu	r4,2(r2)
    75fc:	2008703a 	and	r4,r4,zero
    7600:	20c6b03a 	or	r3,r4,r3
    7604:	10c0008d 	sth	r3,2(r2)
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
    7608:	00002606 	br	76a4 <ip_reass_chain_frag_into_datagram_and_validate+0x2a0>
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
    760c:	e0bffe17 	ldw	r2,-8(fp)
    7610:	e0ffff17 	ldw	r3,-4(fp)
    7614:	10c00115 	stw	r3,4(r2)
      }
      break;
    7618:	00002206 	br	76a4 <ip_reass_chain_frag_into_datagram_and_validate+0x2a0>
    } else if(iprh->start == iprh_tmp->start) {
    761c:	e0bff717 	ldw	r2,-36(fp)
    7620:	10c0010b 	ldhu	r3,4(r2)
    7624:	e0bffd17 	ldw	r2,-12(fp)
    7628:	1080010b 	ldhu	r2,4(r2)
    762c:	18ffffcc 	andi	r3,r3,65535
    7630:	10bfffcc 	andi	r2,r2,65535
    7634:	1880c126 	beq	r3,r2,793c <ip_reass_chain_frag_into_datagram_and_validate+0x538>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
    7638:	e0bff717 	ldw	r2,-36(fp)
    763c:	10c0010b 	ldhu	r3,4(r2)
    7640:	e0bffd17 	ldw	r2,-12(fp)
    7644:	1080018b 	ldhu	r2,6(r2)
    7648:	18ffffcc 	andi	r3,r3,65535
    764c:	10bfffcc 	andi	r2,r2,65535
    7650:	1880bc36 	bltu	r3,r2,7944 <ip_reass_chain_frag_into_datagram_and_validate+0x540>
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
    7654:	e0bff817 	ldw	r2,-32(fp)
    7658:	10000826 	beq	r2,zero,767c <ip_reass_chain_frag_into_datagram_and_validate+0x278>
        if (iprh_prev->end != iprh_tmp->start) {
    765c:	e0bff817 	ldw	r2,-32(fp)
    7660:	10c0018b 	ldhu	r3,6(r2)
    7664:	e0bffd17 	ldw	r2,-12(fp)
    7668:	1080010b 	ldhu	r2,4(r2)
    766c:	18ffffcc 	andi	r3,r3,65535
    7670:	10bfffcc 	andi	r2,r2,65535
    7674:	18800126 	beq	r3,r2,767c <ip_reass_chain_frag_into_datagram_and_validate+0x278>
          /* There is a fragment missing between the current
           * and the previous fragment */
          valid = 0;
    7678:	e03ffa15 	stw	zero,-24(fp)
        }
      }
    }
    q = iprh_tmp->next_pbuf;
    767c:	e0bffd17 	ldw	r2,-12(fp)
    7680:	10c0000b 	ldhu	r3,0(r2)
    7684:	1080008b 	ldhu	r2,2(r2)
    7688:	1004943a 	slli	r2,r2,16
    768c:	10c4b03a 	or	r2,r2,r3
    7690:	e0bff915 	stw	r2,-28(fp)
    iprh_prev = iprh_tmp;
    7694:	e0bffd17 	ldw	r2,-12(fp)
    7698:	e0bff815 	stw	r2,-32(fp)
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    769c:	e0bff917 	ldw	r2,-28(fp)
    76a0:	103fa51e 	bne	r2,zero,7538 <ip_reass_chain_frag_into_datagram_and_validate+0x134>
    q = iprh_tmp->next_pbuf;
    iprh_prev = iprh_tmp;
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
    76a4:	e0bff917 	ldw	r2,-28(fp)
    76a8:	1000371e 	bne	r2,zero,7788 <ip_reass_chain_frag_into_datagram_and_validate+0x384>
    if (iprh_prev != NULL) {
    76ac:	e0bff817 	ldw	r2,-32(fp)
    76b0:	10002626 	beq	r2,zero,774c <ip_reass_chain_frag_into_datagram_and_validate+0x348>
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
    76b4:	e0bff817 	ldw	r2,-32(fp)
    76b8:	1080018b 	ldhu	r2,6(r2)
    76bc:	e0fff717 	ldw	r3,-36(fp)
    76c0:	18c0010b 	ldhu	r3,4(r3)
    76c4:	10bfffcc 	andi	r2,r2,65535
    76c8:	18ffffcc 	andi	r3,r3,65535
    76cc:	1880092e 	bgeu	r3,r2,76f4 <ip_reass_chain_frag_into_datagram_and_validate+0x2f0>
    76d0:	010000f4 	movhi	r4,3
    76d4:	2139aa04 	addi	r4,r4,-6488
    76d8:	014000f4 	movhi	r5,3
    76dc:	2979d204 	addi	r5,r5,-6328
    76e0:	01806304 	movi	r6,396
    76e4:	01c000f4 	movhi	r7,3
    76e8:	39f9b704 	addi	r7,r7,-6436
    76ec:	00170680 	call	17068 <printf>
    76f0:	003fff06 	br	76f0 <ip_reass_chain_frag_into_datagram_and_validate+0x2ec>
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
    76f4:	e0bff817 	ldw	r2,-32(fp)
    76f8:	e0ffff17 	ldw	r3,-4(fp)
    76fc:	18ffffcc 	andi	r3,r3,65535
    7700:	1100000b 	ldhu	r4,0(r2)
    7704:	2008703a 	and	r4,r4,zero
    7708:	20c6b03a 	or	r3,r4,r3
    770c:	10c0000d 	sth	r3,0(r2)
    7710:	e0ffff17 	ldw	r3,-4(fp)
    7714:	1806d43a 	srli	r3,r3,16
    7718:	1100008b 	ldhu	r4,2(r2)
    771c:	2008703a 	and	r4,r4,zero
    7720:	20c6b03a 	or	r3,r4,r3
    7724:	10c0008d 	sth	r3,2(r2)
      if (iprh_prev->end != iprh->start) {
    7728:	e0bff817 	ldw	r2,-32(fp)
    772c:	10c0018b 	ldhu	r3,6(r2)
    7730:	e0bff717 	ldw	r2,-36(fp)
    7734:	1080010b 	ldhu	r2,4(r2)
    7738:	18ffffcc 	andi	r3,r3,65535
    773c:	10bfffcc 	andi	r2,r2,65535
    7740:	18801126 	beq	r3,r2,7788 <ip_reass_chain_frag_into_datagram_and_validate+0x384>
        valid = 0;
    7744:	e03ffa15 	stw	zero,-24(fp)
    7748:	00000f06 	br	7788 <ip_reass_chain_frag_into_datagram_and_validate+0x384>
      }
    } else {
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
    774c:	e0bffe17 	ldw	r2,-8(fp)
    7750:	10800117 	ldw	r2,4(r2)
    7754:	10000926 	beq	r2,zero,777c <ip_reass_chain_frag_into_datagram_and_validate+0x378>
    7758:	010000f4 	movhi	r4,3
    775c:	2139aa04 	addi	r4,r4,-6488
    7760:	014000f4 	movhi	r5,3
    7764:	2979da04 	addi	r5,r5,-6296
    7768:	01806544 	movi	r6,405
    776c:	01c000f4 	movhi	r7,3
    7770:	39f9b704 	addi	r7,r7,-6436
    7774:	00170680 	call	17068 <printf>
    7778:	003fff06 	br	7778 <ip_reass_chain_frag_into_datagram_and_validate+0x374>
        ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
    777c:	e0bffe17 	ldw	r2,-8(fp)
    7780:	e0ffff17 	ldw	r3,-4(fp)
    7784:	10c00115 	stw	r3,4(r2)
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
    7788:	e0bffe17 	ldw	r2,-8(fp)
    778c:	10800783 	ldbu	r2,30(r2)
    7790:	10803fcc 	andi	r2,r2,255
    7794:	1080004c 	andi	r2,r2,1
    7798:	10006626 	beq	r2,zero,7934 <ip_reass_chain_frag_into_datagram_and_validate+0x530>
    /* and had no wholes so far */
    if (valid) {
    779c:	e0bffa17 	ldw	r2,-24(fp)
    77a0:	10006226 	beq	r2,zero,792c <ip_reass_chain_frag_into_datagram_and_validate+0x528>
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
    77a4:	e0bffe17 	ldw	r2,-8(fp)
    77a8:	10800117 	ldw	r2,4(r2)
    77ac:	10800117 	ldw	r2,4(r2)
    77b0:	1080010b 	ldhu	r2,4(r2)
    77b4:	10bfffcc 	andi	r2,r2,65535
    77b8:	10000226 	beq	r2,zero,77c4 <ip_reass_chain_frag_into_datagram_and_validate+0x3c0>
        valid = 0;
    77bc:	e03ffa15 	stw	zero,-24(fp)
    77c0:	00005a06 	br	792c <ip_reass_chain_frag_into_datagram_and_validate+0x528>
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
    77c4:	e0bff717 	ldw	r2,-36(fp)
    77c8:	e0bff815 	stw	r2,-32(fp)
        q = iprh->next_pbuf;
    77cc:	e0bff717 	ldw	r2,-36(fp)
    77d0:	10c0000b 	ldhu	r3,0(r2)
    77d4:	1080008b 	ldhu	r2,2(r2)
    77d8:	1004943a 	slli	r2,r2,16
    77dc:	10c4b03a 	or	r2,r2,r3
    77e0:	e0bff915 	stw	r2,-28(fp)
        while (q != NULL) {
    77e4:	00001406 	br	7838 <ip_reass_chain_frag_into_datagram_and_validate+0x434>
          iprh = (struct ip_reass_helper*)q->payload;
    77e8:	e0bff917 	ldw	r2,-28(fp)
    77ec:	10800117 	ldw	r2,4(r2)
    77f0:	e0bff715 	stw	r2,-36(fp)
          if (iprh_prev->end != iprh->start) {
    77f4:	e0bff817 	ldw	r2,-32(fp)
    77f8:	10c0018b 	ldhu	r3,6(r2)
    77fc:	e0bff717 	ldw	r2,-36(fp)
    7800:	1080010b 	ldhu	r2,4(r2)
    7804:	18ffffcc 	andi	r3,r3,65535
    7808:	10bfffcc 	andi	r2,r2,65535
    780c:	18800226 	beq	r3,r2,7818 <ip_reass_chain_frag_into_datagram_and_validate+0x414>
            valid = 0;
    7810:	e03ffa15 	stw	zero,-24(fp)
            break;
    7814:	00000a06 	br	7840 <ip_reass_chain_frag_into_datagram_and_validate+0x43c>
          }
          iprh_prev = iprh;
    7818:	e0bff717 	ldw	r2,-36(fp)
    781c:	e0bff815 	stw	r2,-32(fp)
          q = iprh->next_pbuf;
    7820:	e0bff717 	ldw	r2,-36(fp)
    7824:	10c0000b 	ldhu	r3,0(r2)
    7828:	1080008b 	ldhu	r2,2(r2)
    782c:	1004943a 	slli	r2,r2,16
    7830:	10c4b03a 	or	r2,r2,r3
    7834:	e0bff915 	stw	r2,-28(fp)
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
    7838:	e0bff917 	ldw	r2,-28(fp)
    783c:	103fea1e 	bne	r2,zero,77e8 <ip_reass_chain_frag_into_datagram_and_validate+0x3e4>
          iprh_prev = iprh;
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
    7840:	e0bffa17 	ldw	r2,-24(fp)
    7844:	10003926 	beq	r2,zero,792c <ip_reass_chain_frag_into_datagram_and_validate+0x528>
          LWIP_ASSERT("sanity check", ipr->p != NULL);
    7848:	e0bffe17 	ldw	r2,-8(fp)
    784c:	10800117 	ldw	r2,4(r2)
    7850:	1000091e 	bne	r2,zero,7878 <ip_reass_chain_frag_into_datagram_and_validate+0x474>
    7854:	010000f4 	movhi	r4,3
    7858:	2139aa04 	addi	r4,r4,-6488
    785c:	014000f4 	movhi	r5,3
    7860:	2979e804 	addi	r5,r5,-6240
    7864:	01806d44 	movi	r6,437
    7868:	01c000f4 	movhi	r7,3
    786c:	39f9b704 	addi	r7,r7,-6436
    7870:	00170680 	call	17068 <printf>
    7874:	003fff06 	br	7874 <ip_reass_chain_frag_into_datagram_and_validate+0x470>
          LWIP_ASSERT("sanity check",
    7878:	e0bffe17 	ldw	r2,-8(fp)
    787c:	10800117 	ldw	r2,4(r2)
    7880:	10c00117 	ldw	r3,4(r2)
    7884:	e0bff717 	ldw	r2,-36(fp)
    7888:	1880091e 	bne	r3,r2,78b0 <ip_reass_chain_frag_into_datagram_and_validate+0x4ac>
    788c:	010000f4 	movhi	r4,3
    7890:	2139aa04 	addi	r4,r4,-6488
    7894:	014000f4 	movhi	r5,3
    7898:	2979e804 	addi	r5,r5,-6240
    789c:	01806dc4 	movi	r6,439
    78a0:	01c000f4 	movhi	r7,3
    78a4:	39f9b704 	addi	r7,r7,-6436
    78a8:	00170680 	call	17068 <printf>
    78ac:	003fff06 	br	78ac <ip_reass_chain_frag_into_datagram_and_validate+0x4a8>
            ((struct ip_reass_helper*)ipr->p->payload) != iprh);
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
    78b0:	e0bff717 	ldw	r2,-36(fp)
    78b4:	10c0000b 	ldhu	r3,0(r2)
    78b8:	1080008b 	ldhu	r2,2(r2)
    78bc:	1004943a 	slli	r2,r2,16
    78c0:	10c4b03a 	or	r2,r2,r3
    78c4:	10000926 	beq	r2,zero,78ec <ip_reass_chain_frag_into_datagram_and_validate+0x4e8>
    78c8:	010000f4 	movhi	r4,3
    78cc:	2139aa04 	addi	r4,r4,-6488
    78d0:	014000f4 	movhi	r5,3
    78d4:	2979ec04 	addi	r5,r5,-6224
    78d8:	01806e44 	movi	r6,441
    78dc:	01c000f4 	movhi	r7,3
    78e0:	39f9b704 	addi	r7,r7,-6436
    78e4:	00170680 	call	17068 <printf>
    78e8:	003fff06 	br	78e8 <ip_reass_chain_frag_into_datagram_and_validate+0x4e4>
            iprh->next_pbuf == NULL);
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
    78ec:	e0bff717 	ldw	r2,-36(fp)
    78f0:	10c0018b 	ldhu	r3,6(r2)
    78f4:	e0bffe17 	ldw	r2,-8(fp)
    78f8:	1080070b 	ldhu	r2,28(r2)
    78fc:	18ffffcc 	andi	r3,r3,65535
    7900:	10bfffcc 	andi	r2,r2,65535
    7904:	18800926 	beq	r3,r2,792c <ip_reass_chain_frag_into_datagram_and_validate+0x528>
    7908:	010000f4 	movhi	r4,3
    790c:	2139aa04 	addi	r4,r4,-6488
    7910:	014000f4 	movhi	r5,3
    7914:	2979f504 	addi	r5,r5,-6188
    7918:	01806ec4 	movi	r6,443
    791c:	01c000f4 	movhi	r7,3
    7920:	39f9b704 	addi	r7,r7,-6436
    7924:	00170680 	call	17068 <printf>
    7928:	003fff06 	br	7928 <ip_reass_chain_frag_into_datagram_and_validate+0x524>
      }
    }
    /* If valid is 0 here, there are some fragments missing in the middle
     * (since MF == 0 has already arrived). Such datagrams simply time out if
     * no more fragments are received... */
    return valid;
    792c:	e0bffa17 	ldw	r2,-24(fp)
    7930:	00000e06 	br	796c <ip_reass_chain_frag_into_datagram_and_validate+0x568>
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
    7934:	0005883a 	mov	r2,zero
    7938:	00000c06 	br	796c <ip_reass_chain_frag_into_datagram_and_validate+0x568>
        ipr->p = new_p;
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
    793c:	0001883a 	nop
    7940:	00000106 	br	7948 <ip_reass_chain_frag_into_datagram_and_validate+0x544>
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
    7944:	0001883a 	nop
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
    7948:	d428cc0b 	ldhu	r16,-23760(gp)
    794c:	e13fff17 	ldw	r4,-4(fp)
    7950:	000a3540 	call	a354 <pbuf_clen>
    7954:	10803fcc 	andi	r2,r2,255
    7958:	8085c83a 	sub	r2,r16,r2
    795c:	d0a8cc0d 	sth	r2,-23760(gp)
  pbuf_free(new_p);
    7960:	e13fff17 	ldw	r4,-4(fp)
    7964:	000a1880 	call	a188 <pbuf_free>
  return 0;
    7968:	0005883a 	mov	r2,zero
#endif /* IP_REASS_CHECK_OVERLAP */
}
    796c:	e037883a 	mov	sp,fp
    7970:	dfc00217 	ldw	ra,8(sp)
    7974:	df000117 	ldw	fp,4(sp)
    7978:	dc000017 	ldw	r16,0(sp)
    797c:	dec00304 	addi	sp,sp,12
    7980:	f800283a 	ret

00007984 <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
    7984:	defff504 	addi	sp,sp,-44
    7988:	dfc00a15 	stw	ra,40(sp)
    798c:	df000915 	stw	fp,36(sp)
    7990:	dc000815 	stw	r16,32(sp)
    7994:	df000804 	addi	fp,sp,32
    7998:	e13fff15 	stw	r4,-4(fp)
  struct ip_hdr *fraghdr;
  struct ip_reassdata *ipr;
  struct ip_reass_helper *iprh;
  u16_t offset, len;
  u8_t clen;
  struct ip_reassdata *ipr_prev = NULL;
    799c:	e03ffa15 	stw	zero,-24(fp)

  IPFRAG_STATS_INC(ip_frag.recv);
    79a0:	00800134 	movhi	r2,4
    79a4:	10916104 	addi	r2,r2,17796
    79a8:	10800c8b 	ldhu	r2,50(r2)
    79ac:	10800044 	addi	r2,r2,1
    79b0:	1007883a 	mov	r3,r2
    79b4:	00800134 	movhi	r2,4
    79b8:	10916104 	addi	r2,r2,17796
    79bc:	10c00c8d 	sth	r3,50(r2)
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
    79c0:	e0bfff17 	ldw	r2,-4(fp)
    79c4:	10800117 	ldw	r2,4(r2)
    79c8:	e0bffb15 	stw	r2,-20(fp)

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
    79cc:	e0bffb17 	ldw	r2,-20(fp)
    79d0:	1080000b 	ldhu	r2,0(r2)
    79d4:	10bfffcc 	andi	r2,r2,65535
    79d8:	1004d23a 	srli	r2,r2,8
    79dc:	10ffffcc 	andi	r3,r2,65535
    79e0:	e0bffb17 	ldw	r2,-20(fp)
    79e4:	1080000b 	ldhu	r2,0(r2)
    79e8:	10bfffcc 	andi	r2,r2,65535
    79ec:	1004923a 	slli	r2,r2,8
    79f0:	10bfffcc 	andi	r2,r2,65535
    79f4:	1884b03a 	or	r2,r3,r2
    79f8:	1005d23a 	srai	r2,r2,8
    79fc:	108003cc 	andi	r2,r2,15
    7a00:	1085883a 	add	r2,r2,r2
    7a04:	1085883a 	add	r2,r2,r2
    7a08:	10800520 	cmpeqi	r2,r2,20
    7a0c:	1000091e 	bne	r2,zero,7a34 <ip_reass+0xb0>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    7a10:	00800134 	movhi	r2,4
    7a14:	10916104 	addi	r2,r2,17796
    7a18:	1080110b 	ldhu	r2,68(r2)
    7a1c:	10800044 	addi	r2,r2,1
    7a20:	1007883a 	mov	r3,r2
    7a24:	00800134 	movhi	r2,4
    7a28:	10916104 	addi	r2,r2,17796
    7a2c:	10c0110d 	sth	r3,68(r2)
    goto nullreturn;
    7a30:	00010b06 	br	7e60 <ip_reass+0x4dc>
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
    7a34:	e0bffb17 	ldw	r2,-20(fp)
    7a38:	1080018b 	ldhu	r2,6(r2)
    7a3c:	10bfffcc 	andi	r2,r2,65535
    7a40:	1004d23a 	srli	r2,r2,8
    7a44:	10ffffcc 	andi	r3,r2,65535
    7a48:	e0bffb17 	ldw	r2,-20(fp)
    7a4c:	1080018b 	ldhu	r2,6(r2)
    7a50:	10bfffcc 	andi	r2,r2,65535
    7a54:	1004923a 	slli	r2,r2,8
    7a58:	10bfffcc 	andi	r2,r2,65535
    7a5c:	1884b03a 	or	r2,r3,r2
    7a60:	1087ffcc 	andi	r2,r2,8191
    7a64:	100490fa 	slli	r2,r2,3
    7a68:	e0bffc0d 	sth	r2,-16(fp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    7a6c:	e0bffb17 	ldw	r2,-20(fp)
    7a70:	1080008b 	ldhu	r2,2(r2)
    7a74:	10bfffcc 	andi	r2,r2,65535
    7a78:	1004d23a 	srli	r2,r2,8
    7a7c:	1007883a 	mov	r3,r2
    7a80:	e0bffb17 	ldw	r2,-20(fp)
    7a84:	1080008b 	ldhu	r2,2(r2)
    7a88:	10bfffcc 	andi	r2,r2,65535
    7a8c:	1004923a 	slli	r2,r2,8
    7a90:	1884b03a 	or	r2,r3,r2
    7a94:	1007883a 	mov	r3,r2
    7a98:	e0bffb17 	ldw	r2,-20(fp)
    7a9c:	1080000b 	ldhu	r2,0(r2)
    7aa0:	10bfffcc 	andi	r2,r2,65535
    7aa4:	1004d23a 	srli	r2,r2,8
    7aa8:	113fffcc 	andi	r4,r2,65535
    7aac:	e0bffb17 	ldw	r2,-20(fp)
    7ab0:	1080000b 	ldhu	r2,0(r2)
    7ab4:	10bfffcc 	andi	r2,r2,65535
    7ab8:	1004923a 	slli	r2,r2,8
    7abc:	10bfffcc 	andi	r2,r2,65535
    7ac0:	2084b03a 	or	r2,r4,r2
    7ac4:	1005d23a 	srai	r2,r2,8
    7ac8:	108003cc 	andi	r2,r2,15
    7acc:	10bfff24 	muli	r2,r2,-4
    7ad0:	1885883a 	add	r2,r3,r2
    7ad4:	e0bffc8d 	sth	r2,-14(fp)

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
    7ad8:	e13fff17 	ldw	r4,-4(fp)
    7adc:	000a3540 	call	a354 <pbuf_clen>
    7ae0:	e0bffd05 	stb	r2,-12(fp)
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
    7ae4:	d0a8cc0b 	ldhu	r2,-23760(gp)
    7ae8:	10ffffcc 	andi	r3,r2,65535
    7aec:	e0bffd03 	ldbu	r2,-12(fp)
    7af0:	1885883a 	add	r2,r3,r2
    7af4:	108002d0 	cmplti	r2,r2,11
    7af8:	1000141e 	bne	r2,zero,7b4c <ip_reass+0x1c8>
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
    7afc:	e0bffd03 	ldbu	r2,-12(fp)
    7b00:	e13ffb17 	ldw	r4,-20(fp)
    7b04:	100b883a 	mov	r5,r2
    7b08:	00071440 	call	7144 <ip_reass_remove_oldest_datagram>
    7b0c:	10000626 	beq	r2,zero,7b28 <ip_reass+0x1a4>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
    7b10:	d0a8cc0b 	ldhu	r2,-23760(gp)
    7b14:	10ffffcc 	andi	r3,r2,65535
    7b18:	e0bffd03 	ldbu	r2,-12(fp)
    7b1c:	1885883a 	add	r2,r3,r2

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
    7b20:	108002d0 	cmplti	r2,r2,11
    7b24:	1000091e 	bne	r2,zero,7b4c <ip_reass+0x1c8>
#endif /* IP_REASS_FREE_OLDEST */
    {
      /* No datagram could be freed and still too many pbufs enqueued */
      LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: Overflow condition: pbufct=%d, clen=%d, MAX=%d\n",
        ip_reass_pbufcount, clen, IP_REASS_MAX_PBUFS));
      IPFRAG_STATS_INC(ip_frag.memerr);
    7b28:	00800134 	movhi	r2,4
    7b2c:	10916104 	addi	r2,r2,17796
    7b30:	10800f0b 	ldhu	r2,60(r2)
    7b34:	10800044 	addi	r2,r2,1
    7b38:	1007883a 	mov	r3,r2
    7b3c:	00800134 	movhi	r2,4
    7b40:	10916104 	addi	r2,r2,17796
    7b44:	10c00f0d 	sth	r3,60(r2)
      /* @todo: send ICMP time exceeded here? */
      /* drop this pbuf */
      goto nullreturn;
    7b48:	0000c506 	br	7e60 <ip_reass+0x4dc>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
    7b4c:	d0a8cb17 	ldw	r2,-23764(gp)
    7b50:	e0bff915 	stw	r2,-28(fp)
    7b54:	00002506 	br	7bec <ip_reass+0x268>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
    7b58:	e0bff917 	ldw	r2,-28(fp)
    7b5c:	10c00517 	ldw	r3,20(r2)
    7b60:	e0bffb17 	ldw	r2,-20(fp)
    7b64:	1100030b 	ldhu	r4,12(r2)
    7b68:	1080038b 	ldhu	r2,14(r2)
    7b6c:	1004943a 	slli	r2,r2,16
    7b70:	1104b03a 	or	r2,r2,r4
    7b74:	1880181e 	bne	r3,r2,7bd8 <ip_reass+0x254>
    7b78:	e0bff917 	ldw	r2,-28(fp)
    7b7c:	10c00617 	ldw	r3,24(r2)
    7b80:	e0bffb17 	ldw	r2,-20(fp)
    7b84:	1100040b 	ldhu	r4,16(r2)
    7b88:	1080048b 	ldhu	r2,18(r2)
    7b8c:	1004943a 	slli	r2,r2,16
    7b90:	1104b03a 	or	r2,r2,r4
    7b94:	1880101e 	bne	r3,r2,7bd8 <ip_reass+0x254>
    7b98:	e0bff917 	ldw	r2,-28(fp)
    7b9c:	10c0030b 	ldhu	r3,12(r2)
    7ba0:	e0bffb17 	ldw	r2,-20(fp)
    7ba4:	1080010b 	ldhu	r2,4(r2)
    7ba8:	18ffffcc 	andi	r3,r3,65535
    7bac:	10bfffcc 	andi	r2,r2,65535
    7bb0:	1880091e 	bne	r3,r2,7bd8 <ip_reass+0x254>
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass: matching previous fragment ID=%"X16_F"\n",
        ntohs(IPH_ID(fraghdr))));
      IPFRAG_STATS_INC(ip_frag.cachehit);
    7bb4:	00800134 	movhi	r2,4
    7bb8:	10916104 	addi	r2,r2,17796
    7bbc:	1080118b 	ldhu	r2,70(r2)
    7bc0:	10800044 	addi	r2,r2,1
    7bc4:	1007883a 	mov	r3,r2
    7bc8:	00800134 	movhi	r2,4
    7bcc:	10916104 	addi	r2,r2,17796
    7bd0:	10c0118d 	sth	r3,70(r2)
      break;
    7bd4:	00000706 	br	7bf4 <ip_reass+0x270>
    }
    ipr_prev = ipr;
    7bd8:	e0bff917 	ldw	r2,-28(fp)
    7bdc:	e0bffa15 	stw	r2,-24(fp)
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
    7be0:	e0bff917 	ldw	r2,-28(fp)
    7be4:	10800017 	ldw	r2,0(r2)
    7be8:	e0bff915 	stw	r2,-28(fp)
    7bec:	e0bff917 	ldw	r2,-28(fp)
    7bf0:	103fd91e 	bne	r2,zero,7b58 <ip_reass+0x1d4>
      break;
    }
    ipr_prev = ipr;
  }

  if (ipr == NULL) {
    7bf4:	e0bff917 	ldw	r2,-28(fp)
    7bf8:	1000081e 	bne	r2,zero,7c1c <ip_reass+0x298>
  /* Enqueue a new datagram into the datagram queue */
    ipr = ip_reass_enqueue_new_datagram(fraghdr, clen);
    7bfc:	e0bffd03 	ldbu	r2,-12(fp)
    7c00:	e13ffb17 	ldw	r4,-20(fp)
    7c04:	100b883a 	mov	r5,r2
    7c08:	00072980 	call	7298 <ip_reass_enqueue_new_datagram>
    7c0c:	e0bff915 	stw	r2,-28(fp)
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
    7c10:	e0bff917 	ldw	r2,-28(fp)
    7c14:	1000211e 	bne	r2,zero,7c9c <ip_reass+0x318>
      goto nullreturn;
    7c18:	00009106 	br	7e60 <ip_reass+0x4dc>
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
    7c1c:	e0bffb17 	ldw	r2,-20(fp)
    7c20:	1080018b 	ldhu	r2,6(r2)
    7c24:	10bfffcc 	andi	r2,r2,65535
    7c28:	1004d23a 	srli	r2,r2,8
    7c2c:	10ffffcc 	andi	r3,r2,65535
    7c30:	e0bffb17 	ldw	r2,-20(fp)
    7c34:	1080018b 	ldhu	r2,6(r2)
    7c38:	10bfffcc 	andi	r2,r2,65535
    7c3c:	1004923a 	slli	r2,r2,8
    7c40:	10bfffcc 	andi	r2,r2,65535
    7c44:	1884b03a 	or	r2,r3,r2
    7c48:	1087ffcc 	andi	r2,r2,8191
    7c4c:	1000131e 	bne	r2,zero,7c9c <ip_reass+0x318>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
    7c50:	e0bff917 	ldw	r2,-28(fp)
    7c54:	1080038b 	ldhu	r2,14(r2)
    7c58:	10bfffcc 	andi	r2,r2,65535
    7c5c:	1004d23a 	srli	r2,r2,8
    7c60:	10ffffcc 	andi	r3,r2,65535
    7c64:	e0bff917 	ldw	r2,-28(fp)
    7c68:	1080038b 	ldhu	r2,14(r2)
    7c6c:	10bfffcc 	andi	r2,r2,65535
    7c70:	1004923a 	slli	r2,r2,8
    7c74:	10bfffcc 	andi	r2,r2,65535
    7c78:	1884b03a 	or	r2,r3,r2
    7c7c:	1087ffcc 	andi	r2,r2,8191
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
    7c80:	10000626 	beq	r2,zero,7c9c <ip_reass+0x318>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
    7c84:	e0bff917 	ldw	r2,-28(fp)
    7c88:	10800204 	addi	r2,r2,8
    7c8c:	1009883a 	mov	r4,r2
    7c90:	e17ffb17 	ldw	r5,-20(fp)
    7c94:	01800504 	movi	r6,20
    7c98:	0016e680 	call	16e68 <memcpy>
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
    7c9c:	e0fffd03 	ldbu	r3,-12(fp)
    7ca0:	d0a8cc0b 	ldhu	r2,-23760(gp)
    7ca4:	1885883a 	add	r2,r3,r2
    7ca8:	d0a8cc0d 	sth	r2,-23760(gp)

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
    7cac:	e0bffb17 	ldw	r2,-20(fp)
    7cb0:	1080018b 	ldhu	r2,6(r2)
    7cb4:	10bfffcc 	andi	r2,r2,65535
    7cb8:	1004d23a 	srli	r2,r2,8
    7cbc:	10ffffcc 	andi	r3,r2,65535
    7cc0:	e0bffb17 	ldw	r2,-20(fp)
    7cc4:	1080018b 	ldhu	r2,6(r2)
    7cc8:	10bfffcc 	andi	r2,r2,65535
    7ccc:	1004923a 	slli	r2,r2,8
    7cd0:	10bfffcc 	andi	r2,r2,65535
    7cd4:	1884b03a 	or	r2,r3,r2
    7cd8:	1088000c 	andi	r2,r2,8192
    7cdc:	10000c1e 	bne	r2,zero,7d10 <ip_reass+0x38c>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
    7ce0:	e0bff917 	ldw	r2,-28(fp)
    7ce4:	10800783 	ldbu	r2,30(r2)
    7ce8:	10800054 	ori	r2,r2,1
    7cec:	1007883a 	mov	r3,r2
    7cf0:	e0bff917 	ldw	r2,-28(fp)
    7cf4:	10c00785 	stb	r3,30(r2)
    ipr->datagram_len = offset + len;
    7cf8:	e0fffc0b 	ldhu	r3,-16(fp)
    7cfc:	e0bffc8b 	ldhu	r2,-14(fp)
    7d00:	1885883a 	add	r2,r3,r2
    7d04:	1007883a 	mov	r3,r2
    7d08:	e0bff917 	ldw	r2,-28(fp)
    7d0c:	10c0070d 	sth	r3,28(r2)
     ("ip_reass: last fragment seen, total len %"S16_F"\n",
      ipr->datagram_len));
  }
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
    7d10:	e13ff917 	ldw	r4,-28(fp)
    7d14:	e17fff17 	ldw	r5,-4(fp)
    7d18:	00074040 	call	7404 <ip_reass_chain_frag_into_datagram_and_validate>
    7d1c:	10004e26 	beq	r2,zero,7e58 <ip_reass+0x4d4>
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
    7d20:	e0bff917 	ldw	r2,-28(fp)
    7d24:	1080070b 	ldhu	r2,28(r2)
    7d28:	10800504 	addi	r2,r2,20
    7d2c:	1007883a 	mov	r3,r2
    7d30:	e0bff917 	ldw	r2,-28(fp)
    7d34:	10c0070d 	sth	r3,28(r2)

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
    7d38:	e0bff917 	ldw	r2,-28(fp)
    7d3c:	10800117 	ldw	r2,4(r2)
    7d40:	10800117 	ldw	r2,4(r2)
    7d44:	10c0000b 	ldhu	r3,0(r2)
    7d48:	1080008b 	ldhu	r2,2(r2)
    7d4c:	1004943a 	slli	r2,r2,16
    7d50:	10c4b03a 	or	r2,r2,r3
    7d54:	e0bff815 	stw	r2,-32(fp)

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
    7d58:	e0bff917 	ldw	r2,-28(fp)
    7d5c:	10800117 	ldw	r2,4(r2)
    7d60:	10800117 	ldw	r2,4(r2)
    7d64:	e0bffb15 	stw	r2,-20(fp)
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
    7d68:	e0bff917 	ldw	r2,-28(fp)
    7d6c:	10800204 	addi	r2,r2,8
    7d70:	e13ffb17 	ldw	r4,-20(fp)
    7d74:	100b883a 	mov	r5,r2
    7d78:	01800504 	movi	r6,20
    7d7c:	0016e680 	call	16e68 <memcpy>
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
    7d80:	e0bff917 	ldw	r2,-28(fp)
    7d84:	1080070b 	ldhu	r2,28(r2)
    7d88:	10bfffcc 	andi	r2,r2,65535
    7d8c:	1004d23a 	srli	r2,r2,8
    7d90:	1007883a 	mov	r3,r2
    7d94:	e0bff917 	ldw	r2,-28(fp)
    7d98:	1080070b 	ldhu	r2,28(r2)
    7d9c:	10bfffcc 	andi	r2,r2,65535
    7da0:	1004923a 	slli	r2,r2,8
    7da4:	1884b03a 	or	r2,r3,r2
    7da8:	1007883a 	mov	r3,r2
    7dac:	e0bffb17 	ldw	r2,-20(fp)
    7db0:	10c0008d 	sth	r3,2(r2)
    IPH_OFFSET_SET(fraghdr, 0);
    7db4:	e0bffb17 	ldw	r2,-20(fp)
    7db8:	1000018d 	sth	zero,6(r2)
    IPH_CHKSUM_SET(fraghdr, 0);
    7dbc:	e0bffb17 	ldw	r2,-20(fp)
    7dc0:	1000028d 	sth	zero,10(r2)
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
    7dc4:	e13ffb17 	ldw	r4,-20(fp)
    7dc8:	01400504 	movi	r5,20
    7dcc:	00060600 	call	6060 <inet_chksum>
    7dd0:	e0fffb17 	ldw	r3,-20(fp)
    7dd4:	1880028d 	sth	r2,10(r3)

    p = ipr->p;
    7dd8:	e0bff917 	ldw	r2,-28(fp)
    7ddc:	10800117 	ldw	r2,4(r2)
    7de0:	e0bfff15 	stw	r2,-4(fp)

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
    7de4:	00000f06 	br	7e24 <ip_reass+0x4a0>
      iprh = (struct ip_reass_helper*)r->payload;
    7de8:	e0bff817 	ldw	r2,-32(fp)
    7dec:	10800117 	ldw	r2,4(r2)
    7df0:	e0bffe15 	stw	r2,-8(fp)

      /* hide the ip header for every succeding fragment */
      pbuf_header(r, -IP_HLEN);
    7df4:	e13ff817 	ldw	r4,-32(fp)
    7df8:	017ffb04 	movi	r5,-20
    7dfc:	0009f900 	call	9f90 <pbuf_header>
      pbuf_cat(p, r);
    7e00:	e13fff17 	ldw	r4,-4(fp)
    7e04:	e17ff817 	ldw	r5,-32(fp)
    7e08:	000a3e00 	call	a3e0 <pbuf_cat>
      r = iprh->next_pbuf;
    7e0c:	e0bffe17 	ldw	r2,-8(fp)
    7e10:	10c0000b 	ldhu	r3,0(r2)
    7e14:	1080008b 	ldhu	r2,2(r2)
    7e18:	1004943a 	slli	r2,r2,16
    7e1c:	10c4b03a 	or	r2,r2,r3
    7e20:	e0bff815 	stw	r2,-32(fp)
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
    7e24:	e0bff817 	ldw	r2,-32(fp)
    7e28:	103fef1e 	bne	r2,zero,7de8 <ip_reass+0x464>
      pbuf_header(r, -IP_HLEN);
      pbuf_cat(p, r);
      r = iprh->next_pbuf;
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
    7e2c:	e13ff917 	ldw	r4,-28(fp)
    7e30:	e17ffa17 	ldw	r5,-24(fp)
    7e34:	00073740 	call	7374 <ip_reass_dequeue_datagram>

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
    7e38:	d428cc0b 	ldhu	r16,-23760(gp)
    7e3c:	e13fff17 	ldw	r4,-4(fp)
    7e40:	000a3540 	call	a354 <pbuf_clen>
    7e44:	10803fcc 	andi	r2,r2,255
    7e48:	8085c83a 	sub	r2,r16,r2
    7e4c:	d0a8cc0d 	sth	r2,-23760(gp)

    /* Return the pbuf chain */
    return p;
    7e50:	e0bfff17 	ldw	r2,-4(fp)
    7e54:	00000d06 	br	7e8c <ip_reass+0x508>
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
    7e58:	0005883a 	mov	r2,zero
    7e5c:	00000b06 	br	7e8c <ip_reass+0x508>

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
    7e60:	00800134 	movhi	r2,4
    7e64:	10916104 	addi	r2,r2,17796
    7e68:	10800d8b 	ldhu	r2,54(r2)
    7e6c:	10800044 	addi	r2,r2,1
    7e70:	1007883a 	mov	r3,r2
    7e74:	00800134 	movhi	r2,4
    7e78:	10916104 	addi	r2,r2,17796
    7e7c:	10c00d8d 	sth	r3,54(r2)
  pbuf_free(p);
    7e80:	e13fff17 	ldw	r4,-4(fp)
    7e84:	000a1880 	call	a188 <pbuf_free>
  return NULL;
    7e88:	0005883a 	mov	r2,zero
}
    7e8c:	e037883a 	mov	sp,fp
    7e90:	dfc00217 	ldw	ra,8(sp)
    7e94:	df000117 	ldw	fp,4(sp)
    7e98:	dc000017 	ldw	r16,0(sp)
    7e9c:	dec00304 	addi	sp,sp,12
    7ea0:	f800283a 	ret

00007ea4 <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
    7ea4:	defff304 	addi	sp,sp,-52
    7ea8:	dfc00c15 	stw	ra,48(sp)
    7eac:	df000b15 	stw	fp,44(sp)
    7eb0:	df000b04 	addi	fp,sp,44
    7eb4:	e13ffd15 	stw	r4,-12(fp)
    7eb8:	e17ffe15 	stw	r5,-8(fp)
    7ebc:	e1bfff15 	stw	r6,-4(fp)
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
    7ec0:	e0bffe17 	ldw	r2,-8(fp)
    7ec4:	1080090b 	ldhu	r2,36(r2)
    7ec8:	e0bff70d 	sth	r2,-36(fp)
  u16_t ofo, omf;
  u16_t last;
  u16_t poff = IP_HLEN;
    7ecc:	00800504 	movi	r2,20
    7ed0:	e0bff60d 	sth	r2,-40(fp)
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
    7ed4:	01000084 	movi	r4,2
    7ed8:	000b883a 	mov	r5,zero
    7edc:	01800084 	movi	r6,2
    7ee0:	00097cc0 	call	97cc <pbuf_alloc>
    7ee4:	e0bff815 	stw	r2,-32(fp)
  if (rambuf == NULL) {
    7ee8:	e0bff817 	ldw	r2,-32(fp)
    7eec:	1000021e 	bne	r2,zero,7ef8 <ip_frag+0x54>
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
    7ef0:	00bfffc4 	movi	r2,-1
    7ef4:	0000a706 	br	8194 <ip_frag+0x2f0>
  }
  rambuf->tot_len = rambuf->len = mtu;
    7ef8:	e0bff817 	ldw	r2,-32(fp)
    7efc:	e0fff70b 	ldhu	r3,-36(fp)
    7f00:	10c0028d 	sth	r3,10(r2)
    7f04:	e0bff817 	ldw	r2,-32(fp)
    7f08:	10c0028b 	ldhu	r3,10(r2)
    7f0c:	e0bff817 	ldw	r2,-32(fp)
    7f10:	10c0020d 	sth	r3,8(r2)
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
    7f14:	008000f4 	movhi	r2,3
    7f18:	1099e904 	addi	r2,r2,26532
    7f1c:	10c000c4 	addi	r3,r2,3
    7f20:	00bfff04 	movi	r2,-4
    7f24:	1884703a 	and	r2,r3,r2
    7f28:	1007883a 	mov	r3,r2
    7f2c:	e0bff817 	ldw	r2,-32(fp)
    7f30:	10c00115 	stw	r3,4(r2)

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
    7f34:	e0bff817 	ldw	r2,-32(fp)
    7f38:	10800117 	ldw	r2,4(r2)
    7f3c:	e0bff915 	stw	r2,-28(fp)
  SMEMCPY(iphdr, p->payload, IP_HLEN);
    7f40:	e0bffd17 	ldw	r2,-12(fp)
    7f44:	10800117 	ldw	r2,4(r2)
    7f48:	e13ff917 	ldw	r4,-28(fp)
    7f4c:	100b883a 	mov	r5,r2
    7f50:	01800504 	movi	r6,20
    7f54:	0016e680 	call	16e68 <memcpy>
  original_iphdr = p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
    7f58:	e0bff917 	ldw	r2,-28(fp)
    7f5c:	1080018b 	ldhu	r2,6(r2)
    7f60:	10bfffcc 	andi	r2,r2,65535
    7f64:	1004d23a 	srli	r2,r2,8
    7f68:	1007883a 	mov	r3,r2
    7f6c:	e0bff917 	ldw	r2,-28(fp)
    7f70:	1080018b 	ldhu	r2,6(r2)
    7f74:	10bfffcc 	andi	r2,r2,65535
    7f78:	1004923a 	slli	r2,r2,8
    7f7c:	1884b03a 	or	r2,r3,r2
    7f80:	e0bff68d 	sth	r2,-38(fp)
  ofo = tmp & IP_OFFMASK;
    7f84:	e0bff68b 	ldhu	r2,-38(fp)
    7f88:	1087ffcc 	andi	r2,r2,8191
    7f8c:	e0bff58d 	sth	r2,-42(fp)
  omf = tmp & IP_MF;
    7f90:	e0bff68b 	ldhu	r2,-38(fp)
    7f94:	1088000c 	andi	r2,r2,8192
    7f98:	e0bffa0d 	sth	r2,-24(fp)

  left = p->tot_len - IP_HLEN;
    7f9c:	e0bffd17 	ldw	r2,-12(fp)
    7fa0:	1080020b 	ldhu	r2,8(r2)
    7fa4:	10bffb04 	addi	r2,r2,-20
    7fa8:	e0bff50d 	sth	r2,-44(fp)

  nfb = (mtu - IP_HLEN) / 8;
    7fac:	e0bff70b 	ldhu	r2,-36(fp)
    7fb0:	10bffb04 	addi	r2,r2,-20
    7fb4:	1000010e 	bge	r2,zero,7fbc <ip_frag+0x118>
    7fb8:	108001c4 	addi	r2,r2,7
    7fbc:	1005d0fa 	srai	r2,r2,3
    7fc0:	e0bffa8d 	sth	r2,-22(fp)

  while (left) {
    7fc4:	00006e06 	br	8180 <ip_frag+0x2dc>
    last = (left <= mtu - IP_HLEN);
    7fc8:	e0bff50b 	ldhu	r2,-44(fp)
    7fcc:	e0fff70b 	ldhu	r3,-36(fp)
    7fd0:	18fffb04 	addi	r3,r3,-20
    7fd4:	1884403a 	cmpge	r2,r3,r2
    7fd8:	10803fcc 	andi	r2,r2,255
    7fdc:	e0bffb0d 	sth	r2,-20(fp)

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
    7fe0:	e0bff58b 	ldhu	r2,-42(fp)
    7fe4:	1087ffcc 	andi	r2,r2,8191
    7fe8:	1007883a 	mov	r3,r2
    7fec:	e0bffa0b 	ldhu	r2,-24(fp)
    7ff0:	1884b03a 	or	r2,r3,r2
    7ff4:	e0bff68d 	sth	r2,-38(fp)
    if (!last)
    7ff8:	e0bffb0b 	ldhu	r2,-20(fp)
    7ffc:	1000031e 	bne	r2,zero,800c <ip_frag+0x168>
      tmp = tmp | IP_MF;
    8000:	e0bff68b 	ldhu	r2,-38(fp)
    8004:	10880014 	ori	r2,r2,8192
    8008:	e0bff68d 	sth	r2,-38(fp)

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
    800c:	e0bffb0b 	ldhu	r2,-20(fp)
    8010:	1000031e 	bne	r2,zero,8020 <ip_frag+0x17c>
    8014:	e0bffa8b 	ldhu	r2,-22(fp)
    8018:	100490fa 	slli	r2,r2,3
    801c:	00000106 	br	8024 <ip_frag+0x180>
    8020:	e0bff50b 	ldhu	r2,-44(fp)
    8024:	e0bffb8d 	sth	r2,-18(fp)

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
    8028:	e0bff917 	ldw	r2,-28(fp)
    802c:	11400504 	addi	r5,r2,20
    8030:	e0fffb8b 	ldhu	r3,-18(fp)
    8034:	e0bff60b 	ldhu	r2,-40(fp)
    8038:	e13ffd17 	ldw	r4,-12(fp)
    803c:	180d883a 	mov	r6,r3
    8040:	100f883a 	mov	r7,r2
    8044:	000a9500 	call	a950 <pbuf_copy_partial>
    8048:	e0fff60b 	ldhu	r3,-40(fp)
    804c:	10c5883a 	add	r2,r2,r3
    8050:	e0bff60d 	sth	r2,-40(fp)
    }
    poff = newpbuflen;
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
    8054:	e0bff68b 	ldhu	r2,-38(fp)
    8058:	1004d23a 	srli	r2,r2,8
    805c:	1007883a 	mov	r3,r2
    8060:	e0bff68b 	ldhu	r2,-38(fp)
    8064:	1004923a 	slli	r2,r2,8
    8068:	1884b03a 	or	r2,r3,r2
    806c:	1007883a 	mov	r3,r2
    8070:	e0bff917 	ldw	r2,-28(fp)
    8074:	10c0018d 	sth	r3,6(r2)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
    8078:	e0bffb8b 	ldhu	r2,-18(fp)
    807c:	10800504 	addi	r2,r2,20
    8080:	10bfc00c 	andi	r2,r2,65280
    8084:	1005d23a 	srai	r2,r2,8
    8088:	1007883a 	mov	r3,r2
    808c:	e0bffb8b 	ldhu	r2,-18(fp)
    8090:	10800504 	addi	r2,r2,20
    8094:	1004923a 	slli	r2,r2,8
    8098:	1884b03a 	or	r2,r3,r2
    809c:	1007883a 	mov	r3,r2
    80a0:	e0bff917 	ldw	r2,-28(fp)
    80a4:	10c0008d 	sth	r3,2(r2)
    IPH_CHKSUM_SET(iphdr, 0);
    80a8:	e0bff917 	ldw	r2,-28(fp)
    80ac:	1000028d 	sth	zero,10(r2)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
    80b0:	e13ff917 	ldw	r4,-28(fp)
    80b4:	01400504 	movi	r5,20
    80b8:	00060600 	call	6060 <inet_chksum>
    80bc:	e0fff917 	ldw	r3,-28(fp)
    80c0:	1880028d 	sth	r2,10(r3)

#if IP_FRAG_USES_STATIC_BUF
    if (last)
    80c4:	e0bffb0b 	ldhu	r2,-20(fp)
    80c8:	10000626 	beq	r2,zero,80e4 <ip_frag+0x240>
      pbuf_realloc(rambuf, left + IP_HLEN);
    80cc:	e0bff50b 	ldhu	r2,-44(fp)
    80d0:	10800504 	addi	r2,r2,20
    80d4:	10bfffcc 	andi	r2,r2,65535
    80d8:	e13ff817 	ldw	r4,-32(fp)
    80dc:	100b883a 	mov	r5,r2
    80e0:	0009d0c0 	call	9d0c <pbuf_realloc>
    /* This part is ugly: we alloc a RAM based pbuf for 
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
    80e4:	01000084 	movi	r4,2
    80e8:	000b883a 	mov	r5,zero
    80ec:	000d883a 	mov	r6,zero
    80f0:	00097cc0 	call	97cc <pbuf_alloc>
    80f4:	e0bffc15 	stw	r2,-16(fp)
    if (header != NULL) {
    80f8:	e0bffc17 	ldw	r2,-16(fp)
    80fc:	10001c26 	beq	r2,zero,8170 <ip_frag+0x2cc>
      pbuf_chain(header, rambuf);
    8100:	e13ffc17 	ldw	r4,-16(fp)
    8104:	e17ff817 	ldw	r5,-32(fp)
    8108:	000a5200 	call	a520 <pbuf_chain>
      netif->output(netif, header, dest);
    810c:	e0bffe17 	ldw	r2,-8(fp)
    8110:	10800517 	ldw	r2,20(r2)
    8114:	e13ffe17 	ldw	r4,-8(fp)
    8118:	e17ffc17 	ldw	r5,-16(fp)
    811c:	e1bfff17 	ldw	r6,-4(fp)
    8120:	103ee83a 	callr	r2
      IPFRAG_STATS_INC(ip_frag.xmit);
    8124:	00800134 	movhi	r2,4
    8128:	10916104 	addi	r2,r2,17796
    812c:	10800c0b 	ldhu	r2,48(r2)
    8130:	10800044 	addi	r2,r2,1
    8134:	1007883a 	mov	r3,r2
    8138:	00800134 	movhi	r2,4
    813c:	10916104 	addi	r2,r2,17796
    8140:	10c00c0d 	sth	r3,48(r2)
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    8144:	e13ffc17 	ldw	r4,-16(fp)
    8148:	000a1880 	call	a188 <pbuf_free>
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    814c:	e0fff50b 	ldhu	r3,-44(fp)
    8150:	e0bffb8b 	ldhu	r2,-18(fp)
    8154:	1885c83a 	sub	r2,r3,r2
    8158:	e0bff50d 	sth	r2,-44(fp)
    ofo += nfb;
    815c:	e0fff58b 	ldhu	r3,-42(fp)
    8160:	e0bffa8b 	ldhu	r2,-22(fp)
    8164:	1885883a 	add	r2,r3,r2
    8168:	e0bff58d 	sth	r2,-42(fp)
    816c:	00000406 	br	8180 <ip_frag+0x2dc>
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
    8170:	e13ff817 	ldw	r4,-32(fp)
    8174:	000a1880 	call	a188 <pbuf_free>
      return ERR_MEM;
    8178:	00bfffc4 	movi	r2,-1
    817c:	00000506 	br	8194 <ip_frag+0x2f0>

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
    8180:	e0bff50b 	ldhu	r2,-44(fp)
    8184:	103f901e 	bne	r2,zero,7fc8 <ip_frag+0x124>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
    8188:	e13ff817 	ldw	r4,-32(fp)
    818c:	000a1880 	call	a188 <pbuf_free>
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
    8190:	0005883a 	mov	r2,zero
}
    8194:	e037883a 	mov	sp,fp
    8198:	dfc00117 	ldw	ra,4(sp)
    819c:	df000017 	ldw	fp,0(sp)
    81a0:	dec00204 	addi	sp,sp,8
    81a4:	f800283a 	ret

000081a8 <plug_holes>:
 * This assumes access to the heap is protected by the calling function
 * already.
 */
static void
plug_holes(struct mem *mem)
{
    81a8:	defffb04 	addi	sp,sp,-20
    81ac:	dfc00415 	stw	ra,16(sp)
    81b0:	df000315 	stw	fp,12(sp)
    81b4:	df000304 	addi	fp,sp,12
    81b8:	e13fff15 	stw	r4,-4(fp)
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
    81bc:	d0a8cd17 	ldw	r2,-23756(gp)
    81c0:	e0ffff17 	ldw	r3,-4(fp)
    81c4:	1880092e 	bgeu	r3,r2,81ec <plug_holes+0x44>
    81c8:	010000f4 	movhi	r4,3
    81cc:	213a0104 	addi	r4,r4,-6140
    81d0:	014000f4 	movhi	r5,3
    81d4:	297a0b04 	addi	r5,r5,-6100
    81d8:	01803944 	movi	r6,229
    81dc:	01c000f4 	movhi	r7,3
    81e0:	39fa1104 	addi	r7,r7,-6076
    81e4:	00170680 	call	17068 <printf>
    81e8:	003fff06 	br	81e8 <plug_holes+0x40>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
    81ec:	d0a8ce17 	ldw	r2,-23752(gp)
    81f0:	e0ffff17 	ldw	r3,-4(fp)
    81f4:	18800936 	bltu	r3,r2,821c <plug_holes+0x74>
    81f8:	010000f4 	movhi	r4,3
    81fc:	213a0104 	addi	r4,r4,-6140
    8200:	014000f4 	movhi	r5,3
    8204:	297a1604 	addi	r5,r5,-6056
    8208:	01803984 	movi	r6,230
    820c:	01c000f4 	movhi	r7,3
    8210:	39fa1104 	addi	r7,r7,-6076
    8214:	00170680 	call	17068 <printf>
    8218:	003fff06 	br	8218 <plug_holes+0x70>
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);
    821c:	e0bfff17 	ldw	r2,-4(fp)
    8220:	10800103 	ldbu	r2,4(r2)
    8224:	10803fcc 	andi	r2,r2,255
    8228:	10000926 	beq	r2,zero,8250 <plug_holes+0xa8>
    822c:	010000f4 	movhi	r4,3
    8230:	213a0104 	addi	r4,r4,-6140
    8234:	014000f4 	movhi	r5,3
    8238:	297a1d04 	addi	r5,r5,-6028
    823c:	018039c4 	movi	r6,231
    8240:	01c000f4 	movhi	r7,3
    8244:	39fa1104 	addi	r7,r7,-6076
    8248:	00170680 	call	17068 <printf>
    824c:	003fff06 	br	824c <plug_holes+0xa4>

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
    8250:	e0bfff17 	ldw	r2,-4(fp)
    8254:	1080000b 	ldhu	r2,0(r2)
    8258:	10bfffcc 	andi	r2,r2,65535
    825c:	10819070 	cmpltui	r2,r2,1601
    8260:	1000091e 	bne	r2,zero,8288 <plug_holes+0xe0>
    8264:	010000f4 	movhi	r4,3
    8268:	213a0104 	addi	r4,r4,-6140
    826c:	014000f4 	movhi	r5,3
    8270:	297a2404 	addi	r5,r5,-6000
    8274:	01803a84 	movi	r6,234
    8278:	01c000f4 	movhi	r7,3
    827c:	39fa1104 	addi	r7,r7,-6076
    8280:	00170680 	call	17068 <printf>
    8284:	003fff06 	br	8284 <plug_holes+0xdc>

  nmem = (struct mem *)&ram[mem->next];
    8288:	d0e8cd17 	ldw	r3,-23756(gp)
    828c:	e0bfff17 	ldw	r2,-4(fp)
    8290:	1080000b 	ldhu	r2,0(r2)
    8294:	10bfffcc 	andi	r2,r2,65535
    8298:	1885883a 	add	r2,r3,r2
    829c:	e0bffd15 	stw	r2,-12(fp)
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
    82a0:	e0ffff17 	ldw	r3,-4(fp)
    82a4:	e0bffd17 	ldw	r2,-12(fp)
    82a8:	18801926 	beq	r3,r2,8310 <plug_holes+0x168>
    82ac:	e0bffd17 	ldw	r2,-12(fp)
    82b0:	10800103 	ldbu	r2,4(r2)
    82b4:	10803fcc 	andi	r2,r2,255
    82b8:	1000151e 	bne	r2,zero,8310 <plug_holes+0x168>
    82bc:	d0a8ce17 	ldw	r2,-23752(gp)
    82c0:	e0fffd17 	ldw	r3,-12(fp)
    82c4:	18801226 	beq	r3,r2,8310 <plug_holes+0x168>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
    82c8:	d0e8cf17 	ldw	r3,-23748(gp)
    82cc:	e0bffd17 	ldw	r2,-12(fp)
    82d0:	1880021e 	bne	r3,r2,82dc <plug_holes+0x134>
      lfree = mem;
    82d4:	e0bfff17 	ldw	r2,-4(fp)
    82d8:	d0a8cf15 	stw	r2,-23748(gp)
    }
    mem->next = nmem->next;
    82dc:	e0bffd17 	ldw	r2,-12(fp)
    82e0:	10c0000b 	ldhu	r3,0(r2)
    82e4:	e0bfff17 	ldw	r2,-4(fp)
    82e8:	10c0000d 	sth	r3,0(r2)
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
    82ec:	d0e8cd17 	ldw	r3,-23756(gp)
    82f0:	e0bffd17 	ldw	r2,-12(fp)
    82f4:	1080000b 	ldhu	r2,0(r2)
    82f8:	10bfffcc 	andi	r2,r2,65535
    82fc:	1885883a 	add	r2,r3,r2
    8300:	e13fff17 	ldw	r4,-4(fp)
    8304:	d0e8cd17 	ldw	r3,-23756(gp)
    8308:	20c7c83a 	sub	r3,r4,r3
    830c:	10c0008d 	sth	r3,2(r2)
  }

  /* plug hole backward */
  pmem = (struct mem *)&ram[mem->prev];
    8310:	d0e8cd17 	ldw	r3,-23756(gp)
    8314:	e0bfff17 	ldw	r2,-4(fp)
    8318:	1080008b 	ldhu	r2,2(r2)
    831c:	10bfffcc 	andi	r2,r2,65535
    8320:	1885883a 	add	r2,r3,r2
    8324:	e0bffe15 	stw	r2,-8(fp)
  if (pmem != mem && pmem->used == 0) {
    8328:	e0fffe17 	ldw	r3,-8(fp)
    832c:	e0bfff17 	ldw	r2,-4(fp)
    8330:	18801626 	beq	r3,r2,838c <plug_holes+0x1e4>
    8334:	e0bffe17 	ldw	r2,-8(fp)
    8338:	10800103 	ldbu	r2,4(r2)
    833c:	10803fcc 	andi	r2,r2,255
    8340:	1000121e 	bne	r2,zero,838c <plug_holes+0x1e4>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
    8344:	d0e8cf17 	ldw	r3,-23748(gp)
    8348:	e0bfff17 	ldw	r2,-4(fp)
    834c:	1880021e 	bne	r3,r2,8358 <plug_holes+0x1b0>
      lfree = pmem;
    8350:	e0bffe17 	ldw	r2,-8(fp)
    8354:	d0a8cf15 	stw	r2,-23748(gp)
    }
    pmem->next = mem->next;
    8358:	e0bfff17 	ldw	r2,-4(fp)
    835c:	10c0000b 	ldhu	r3,0(r2)
    8360:	e0bffe17 	ldw	r2,-8(fp)
    8364:	10c0000d 	sth	r3,0(r2)
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
    8368:	d0e8cd17 	ldw	r3,-23756(gp)
    836c:	e0bfff17 	ldw	r2,-4(fp)
    8370:	1080000b 	ldhu	r2,0(r2)
    8374:	10bfffcc 	andi	r2,r2,65535
    8378:	1885883a 	add	r2,r3,r2
    837c:	e13ffe17 	ldw	r4,-8(fp)
    8380:	d0e8cd17 	ldw	r3,-23756(gp)
    8384:	20c7c83a 	sub	r3,r4,r3
    8388:	10c0008d 	sth	r3,2(r2)
  }
}
    838c:	e037883a 	mov	sp,fp
    8390:	dfc00117 	ldw	ra,4(sp)
    8394:	df000017 	ldw	fp,0(sp)
    8398:	dec00204 	addi	sp,sp,8
    839c:	f800283a 	ret

000083a0 <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
    83a0:	defffe04 	addi	sp,sp,-8
    83a4:	df000115 	stw	fp,4(sp)
    83a8:	df000104 	addi	fp,sp,4

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
    83ac:	008000f4 	movhi	r2,3
    83b0:	109b6104 	addi	r2,r2,28036
    83b4:	10c000c4 	addi	r3,r2,3
    83b8:	00bfff04 	movi	r2,-4
    83bc:	1884703a 	and	r2,r3,r2
    83c0:	d0a8cd15 	stw	r2,-23756(gp)
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
    83c4:	d0a8cd17 	ldw	r2,-23756(gp)
    83c8:	e0bfff15 	stw	r2,-4(fp)
  mem->next = MEM_SIZE_ALIGNED;
    83cc:	e0bfff17 	ldw	r2,-4(fp)
    83d0:	00c19004 	movi	r3,1600
    83d4:	10c0000d 	sth	r3,0(r2)
  mem->prev = 0;
    83d8:	e0bfff17 	ldw	r2,-4(fp)
    83dc:	1000008d 	sth	zero,2(r2)
  mem->used = 0;
    83e0:	e0bfff17 	ldw	r2,-4(fp)
    83e4:	10000105 	stb	zero,4(r2)
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
    83e8:	d0a8cd17 	ldw	r2,-23756(gp)
    83ec:	10819004 	addi	r2,r2,1600
    83f0:	d0a8ce15 	stw	r2,-23752(gp)
  ram_end->used = 1;
    83f4:	d0a8ce17 	ldw	r2,-23752(gp)
    83f8:	00c00044 	movi	r3,1
    83fc:	10c00105 	stb	r3,4(r2)
  ram_end->next = MEM_SIZE_ALIGNED;
    8400:	d0a8ce17 	ldw	r2,-23752(gp)
    8404:	00c19004 	movi	r3,1600
    8408:	10c0000d 	sth	r3,0(r2)
  ram_end->prev = MEM_SIZE_ALIGNED;
    840c:	d0a8ce17 	ldw	r2,-23752(gp)
    8410:	00c19004 	movi	r3,1600
    8414:	10c0008d 	sth	r3,2(r2)

  mem_sem = sys_sem_new(1);
    8418:	00800044 	movi	r2,1
    841c:	d0a8d005 	stb	r2,-23744(gp)

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)ram;
    8420:	d0a8cd17 	ldw	r2,-23756(gp)
    8424:	d0a8cf15 	stw	r2,-23748(gp)

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
    8428:	00800134 	movhi	r2,4
    842c:	10916104 	addi	r2,r2,17796
    8430:	00c19004 	movi	r3,1600
    8434:	10c02a0d 	sth	r3,168(r2)
}
    8438:	e037883a 	mov	sp,fp
    843c:	df000017 	ldw	fp,0(sp)
    8440:	dec00104 	addi	sp,sp,4
    8444:	f800283a 	ret

00008448 <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
    8448:	defffc04 	addi	sp,sp,-16
    844c:	dfc00315 	stw	ra,12(sp)
    8450:	df000215 	stw	fp,8(sp)
    8454:	df000204 	addi	fp,sp,8
    8458:	e13fff15 	stw	r4,-4(fp)
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
    845c:	e0bfff17 	ldw	r2,-4(fp)
    8460:	10005326 	beq	r2,zero,85b0 <mem_free+0x168>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
    8464:	e0bfff17 	ldw	r2,-4(fp)
    8468:	108000cc 	andi	r2,r2,3
    846c:	10000926 	beq	r2,zero,8494 <mem_free+0x4c>
    8470:	010000f4 	movhi	r4,3
    8474:	213a0104 	addi	r4,r4,-6140
    8478:	014000f4 	movhi	r5,3
    847c:	297a2f04 	addi	r5,r5,-5956
    8480:	01804c84 	movi	r6,306
    8484:	01c000f4 	movhi	r7,3
    8488:	39fa1104 	addi	r7,r7,-6076
    848c:	00170680 	call	17068 <printf>
    8490:	003fff06 	br	8490 <mem_free+0x48>

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
    8494:	d0a8cd17 	ldw	r2,-23756(gp)
    8498:	e0ffff17 	ldw	r3,-4(fp)
    849c:	18800336 	bltu	r3,r2,84ac <mem_free+0x64>
    84a0:	d0a8ce17 	ldw	r2,-23752(gp)
    84a4:	e0ffff17 	ldw	r3,-4(fp)
    84a8:	18800936 	bltu	r3,r2,84d0 <mem_free+0x88>
    84ac:	010000f4 	movhi	r4,3
    84b0:	213a0104 	addi	r4,r4,-6140
    84b4:	014000f4 	movhi	r5,3
    84b8:	297a3804 	addi	r5,r5,-5920
    84bc:	01804d44 	movi	r6,309
    84c0:	01c000f4 	movhi	r7,3
    84c4:	39fa1104 	addi	r7,r7,-6076
    84c8:	00170680 	call	17068 <printf>
    84cc:	003fff06 	br	84cc <mem_free+0x84>
    (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
    84d0:	d0a8cd17 	ldw	r2,-23756(gp)
    84d4:	e0ffff17 	ldw	r3,-4(fp)
    84d8:	18800336 	bltu	r3,r2,84e8 <mem_free+0xa0>
    84dc:	d0a8ce17 	ldw	r2,-23752(gp)
    84e0:	e0ffff17 	ldw	r3,-4(fp)
    84e4:	18800936 	bltu	r3,r2,850c <mem_free+0xc4>
    SYS_ARCH_DECL_PROTECT(lev);
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
    MEM_STATS_INC(illegal);
    84e8:	00800134 	movhi	r2,4
    84ec:	10916104 	addi	r2,r2,17796
    84f0:	10802c0b 	ldhu	r2,176(r2)
    84f4:	10800044 	addi	r2,r2,1
    84f8:	1007883a 	mov	r3,r2
    84fc:	00800134 	movhi	r2,4
    8500:	10916104 	addi	r2,r2,17796
    8504:	10c02c0d 	sth	r3,176(r2)
    SYS_ARCH_UNPROTECT(lev);
    return;
    8508:	00002a06 	br	85b4 <mem_free+0x16c>
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
    850c:	e0bfff17 	ldw	r2,-4(fp)
    8510:	10bffe04 	addi	r2,r2,-8
    8514:	e0bffe15 	stw	r2,-8(fp)
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
    8518:	e0bffe17 	ldw	r2,-8(fp)
    851c:	10800103 	ldbu	r2,4(r2)
    8520:	10803fcc 	andi	r2,r2,255
    8524:	1000091e 	bne	r2,zero,854c <mem_free+0x104>
    8528:	010000f4 	movhi	r4,3
    852c:	213a0104 	addi	r4,r4,-6140
    8530:	014000f4 	movhi	r5,3
    8534:	297a3e04 	addi	r5,r5,-5896
    8538:	01805144 	movi	r6,325
    853c:	01c000f4 	movhi	r7,3
    8540:	39fa1104 	addi	r7,r7,-6076
    8544:	00170680 	call	17068 <printf>
    8548:	003fff06 	br	8548 <mem_free+0x100>
  /* ... and is now unused. */
  mem->used = 0;
    854c:	e0bffe17 	ldw	r2,-8(fp)
    8550:	10000105 	stb	zero,4(r2)

  if (mem < lfree) {
    8554:	d0a8cf17 	ldw	r2,-23748(gp)
    8558:	e0fffe17 	ldw	r3,-8(fp)
    855c:	1880022e 	bgeu	r3,r2,8568 <mem_free+0x120>
    /* the newly freed struct is now the lowest */
    lfree = mem;
    8560:	e0bffe17 	ldw	r2,-8(fp)
    8564:	d0a8cf15 	stw	r2,-23748(gp)
  }

  MEM_STATS_DEC_USED(used, mem->next - ((u8_t *)mem - ram));
    8568:	00800134 	movhi	r2,4
    856c:	10916104 	addi	r2,r2,17796
    8570:	10c02a8b 	ldhu	r3,170(r2)
    8574:	e13ffe17 	ldw	r4,-8(fp)
    8578:	d0a8cd17 	ldw	r2,-23756(gp)
    857c:	2085c83a 	sub	r2,r4,r2
    8580:	1009883a 	mov	r4,r2
    8584:	e0bffe17 	ldw	r2,-8(fp)
    8588:	1080000b 	ldhu	r2,0(r2)
    858c:	2085c83a 	sub	r2,r4,r2
    8590:	1885883a 	add	r2,r3,r2
    8594:	1007883a 	mov	r3,r2
    8598:	00800134 	movhi	r2,4
    859c:	10916104 	addi	r2,r2,17796
    85a0:	10c02a8d 	sth	r3,170(r2)

  /* finally, see if prev or next are free also */
  plug_holes(mem);
    85a4:	e13ffe17 	ldw	r4,-8(fp)
    85a8:	00081a80 	call	81a8 <plug_holes>
    85ac:	00000106 	br	85b4 <mem_free+0x16c>
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
    85b0:	0001883a 	nop
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
}
    85b4:	e037883a 	mov	sp,fp
    85b8:	dfc00117 	ldw	ra,4(sp)
    85bc:	df000017 	ldw	fp,0(sp)
    85c0:	dec00204 	addi	sp,sp,8
    85c4:	f800283a 	ret

000085c8 <mem_realloc>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_realloc(void *rmem, mem_size_t newsize)
{
    85c8:	defff804 	addi	sp,sp,-32
    85cc:	dfc00715 	stw	ra,28(sp)
    85d0:	df000615 	stw	fp,24(sp)
    85d4:	df000604 	addi	fp,sp,24
    85d8:	e13ffe15 	stw	r4,-8(fp)
    85dc:	2805883a 	mov	r2,r5
    85e0:	e0bfff0d 	sth	r2,-4(fp)
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
    85e4:	e0bfff0b 	ldhu	r2,-4(fp)
    85e8:	108000c4 	addi	r2,r2,3
    85ec:	1007883a 	mov	r3,r2
    85f0:	00bfff04 	movi	r2,-4
    85f4:	1884703a 	and	r2,r3,r2
    85f8:	e0bfff0d 	sth	r2,-4(fp)

  if(newsize < MIN_SIZE_ALIGNED) {
    85fc:	e0bfff0b 	ldhu	r2,-4(fp)
    8600:	10800328 	cmpgeui	r2,r2,12
    8604:	1000021e 	bne	r2,zero,8610 <mem_realloc+0x48>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
    8608:	00800304 	movi	r2,12
    860c:	e0bfff0d 	sth	r2,-4(fp)
  }

  if (newsize > MEM_SIZE_ALIGNED) {
    8610:	e0bfff0b 	ldhu	r2,-4(fp)
    8614:	10819070 	cmpltui	r2,r2,1601
    8618:	1000021e 	bne	r2,zero,8624 <mem_realloc+0x5c>
    return NULL;
    861c:	0005883a 	mov	r2,zero
    8620:	0000ad06 	br	88d8 <mem_realloc+0x310>
  }

  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
    8624:	d0a8cd17 	ldw	r2,-23756(gp)
    8628:	e0fffe17 	ldw	r3,-8(fp)
    862c:	18800336 	bltu	r3,r2,863c <mem_realloc+0x74>
    8630:	d0a8ce17 	ldw	r2,-23752(gp)
    8634:	e0fffe17 	ldw	r3,-8(fp)
    8638:	18800936 	bltu	r3,r2,8660 <mem_realloc+0x98>
    863c:	010000f4 	movhi	r4,3
    8640:	213a0104 	addi	r4,r4,-6140
    8644:	014000f4 	movhi	r5,3
    8648:	297a4304 	addi	r5,r5,-5876
    864c:	01805ec4 	movi	r6,379
    8650:	01c000f4 	movhi	r7,3
    8654:	39fa1104 	addi	r7,r7,-6076
    8658:	00170680 	call	17068 <printf>
    865c:	003fff06 	br	865c <mem_realloc+0x94>
   (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
    8660:	d0a8cd17 	ldw	r2,-23756(gp)
    8664:	e0fffe17 	ldw	r3,-8(fp)
    8668:	18800336 	bltu	r3,r2,8678 <mem_realloc+0xb0>
    866c:	d0a8ce17 	ldw	r2,-23752(gp)
    8670:	e0fffe17 	ldw	r3,-8(fp)
    8674:	18800a36 	bltu	r3,r2,86a0 <mem_realloc+0xd8>
    SYS_ARCH_DECL_PROTECT(lev);
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_realloc: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
    MEM_STATS_INC(illegal);
    8678:	00800134 	movhi	r2,4
    867c:	10916104 	addi	r2,r2,17796
    8680:	10802c0b 	ldhu	r2,176(r2)
    8684:	10800044 	addi	r2,r2,1
    8688:	1007883a 	mov	r3,r2
    868c:	00800134 	movhi	r2,4
    8690:	10916104 	addi	r2,r2,17796
    8694:	10c02c0d 	sth	r3,176(r2)
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
    8698:	e0bffe17 	ldw	r2,-8(fp)
    869c:	00008e06 	br	88d8 <mem_realloc+0x310>
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
    86a0:	e0bffe17 	ldw	r2,-8(fp)
    86a4:	10bffe04 	addi	r2,r2,-8
    86a8:	e0bffa15 	stw	r2,-24(fp)
  /* ... and its offset pointer */
  ptr = (u8_t *)mem - ram;
    86ac:	e0fffa17 	ldw	r3,-24(fp)
    86b0:	d0a8cd17 	ldw	r2,-23756(gp)
    86b4:	1885c83a 	sub	r2,r3,r2
    86b8:	e0bffb0d 	sth	r2,-20(fp)

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
    86bc:	e0bffa17 	ldw	r2,-24(fp)
    86c0:	10c0000b 	ldhu	r3,0(r2)
    86c4:	e0bffb0b 	ldhu	r2,-20(fp)
    86c8:	1885c83a 	sub	r2,r3,r2
    86cc:	10bffe04 	addi	r2,r2,-8
    86d0:	e0bffb8d 	sth	r2,-18(fp)
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
    86d4:	e0bfff0b 	ldhu	r2,-4(fp)
    86d8:	e0fffb8b 	ldhu	r3,-18(fp)
    86dc:	1880092e 	bgeu	r3,r2,8704 <mem_realloc+0x13c>
    86e0:	010000f4 	movhi	r4,3
    86e4:	213a0104 	addi	r4,r4,-6140
    86e8:	014000f4 	movhi	r5,3
    86ec:	297a4a04 	addi	r5,r5,-5848
    86f0:	01806304 	movi	r6,396
    86f4:	01c000f4 	movhi	r7,3
    86f8:	39fa1104 	addi	r7,r7,-6076
    86fc:	00170680 	call	17068 <printf>
    8700:	003fff06 	br	8700 <mem_realloc+0x138>
  if (newsize > size) {
    8704:	e0bfff0b 	ldhu	r2,-4(fp)
    8708:	e0fffb8b 	ldhu	r3,-18(fp)
    870c:	1880022e 	bgeu	r3,r2,8718 <mem_realloc+0x150>
    /* not supported */
    return NULL;
    8710:	0005883a 	mov	r2,zero
    8714:	00007006 	br	88d8 <mem_realloc+0x310>
  }
  if (newsize == size) {
    8718:	e0ffff0b 	ldhu	r3,-4(fp)
    871c:	e0bffb8b 	ldhu	r2,-18(fp)
    8720:	1880021e 	bne	r3,r2,872c <mem_realloc+0x164>
    /* No change in size, simply return */
    return rmem;
    8724:	e0bffe17 	ldw	r2,-8(fp)
    8728:	00006b06 	br	88d8 <mem_realloc+0x310>
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();

  MEM_STATS_DEC_USED(used, (size - newsize));
    872c:	00800134 	movhi	r2,4
    8730:	10916104 	addi	r2,r2,17796
    8734:	10c02a8b 	ldhu	r3,170(r2)
    8738:	e13fff0b 	ldhu	r4,-4(fp)
    873c:	e0bffb8b 	ldhu	r2,-18(fp)
    8740:	2085c83a 	sub	r2,r4,r2
    8744:	1885883a 	add	r2,r3,r2
    8748:	1007883a 	mov	r3,r2
    874c:	00800134 	movhi	r2,4
    8750:	10916104 	addi	r2,r2,17796
    8754:	10c02a8d 	sth	r3,170(r2)

  mem2 = (struct mem *)&ram[mem->next];
    8758:	d0e8cd17 	ldw	r3,-23756(gp)
    875c:	e0bffa17 	ldw	r2,-24(fp)
    8760:	1080000b 	ldhu	r2,0(r2)
    8764:	10bfffcc 	andi	r2,r2,65535
    8768:	1885883a 	add	r2,r3,r2
    876c:	e0bffc15 	stw	r2,-16(fp)
  if(mem2->used == 0) {
    8770:	e0bffc17 	ldw	r2,-16(fp)
    8774:	10800103 	ldbu	r2,4(r2)
    8778:	10803fcc 	andi	r2,r2,255
    877c:	10002b1e 	bne	r2,zero,882c <mem_realloc+0x264>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
    8780:	e0bffc17 	ldw	r2,-16(fp)
    8784:	1080000b 	ldhu	r2,0(r2)
    8788:	e0bffd0d 	sth	r2,-12(fp)
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    878c:	e0fffb0b 	ldhu	r3,-20(fp)
    8790:	e0bfff0b 	ldhu	r2,-4(fp)
    8794:	1885883a 	add	r2,r3,r2
    8798:	10800204 	addi	r2,r2,8
    879c:	e0bffd8d 	sth	r2,-10(fp)
    if (lfree == mem2) {
    87a0:	d0e8cf17 	ldw	r3,-23748(gp)
    87a4:	e0bffc17 	ldw	r2,-16(fp)
    87a8:	1880041e 	bne	r3,r2,87bc <mem_realloc+0x1f4>
      lfree = (struct mem *)&ram[ptr2];
    87ac:	d0e8cd17 	ldw	r3,-23756(gp)
    87b0:	e0bffd8b 	ldhu	r2,-10(fp)
    87b4:	1885883a 	add	r2,r3,r2
    87b8:	d0a8cf15 	stw	r2,-23748(gp)
    }
    mem2 = (struct mem *)&ram[ptr2];
    87bc:	d0e8cd17 	ldw	r3,-23756(gp)
    87c0:	e0bffd8b 	ldhu	r2,-10(fp)
    87c4:	1885883a 	add	r2,r3,r2
    87c8:	e0bffc15 	stw	r2,-16(fp)
    mem2->used = 0;
    87cc:	e0bffc17 	ldw	r2,-16(fp)
    87d0:	10000105 	stb	zero,4(r2)
    /* restore the next pointer */
    mem2->next = next;
    87d4:	e0bffc17 	ldw	r2,-16(fp)
    87d8:	e0fffd0b 	ldhu	r3,-12(fp)
    87dc:	10c0000d 	sth	r3,0(r2)
    /* link it back to mem */
    mem2->prev = ptr;
    87e0:	e0bffc17 	ldw	r2,-16(fp)
    87e4:	e0fffb0b 	ldhu	r3,-20(fp)
    87e8:	10c0008d 	sth	r3,2(r2)
    /* link mem to it */
    mem->next = ptr2;
    87ec:	e0bffa17 	ldw	r2,-24(fp)
    87f0:	e0fffd8b 	ldhu	r3,-10(fp)
    87f4:	10c0000d 	sth	r3,0(r2)
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
    87f8:	e0bffc17 	ldw	r2,-16(fp)
    87fc:	1080000b 	ldhu	r2,0(r2)
    8800:	10bfffcc 	andi	r2,r2,65535
    8804:	10819020 	cmpeqi	r2,r2,1600
    8808:	1000321e 	bne	r2,zero,88d4 <mem_realloc+0x30c>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
    880c:	d0e8cd17 	ldw	r3,-23756(gp)
    8810:	e0bffc17 	ldw	r2,-16(fp)
    8814:	1080000b 	ldhu	r2,0(r2)
    8818:	10bfffcc 	andi	r2,r2,65535
    881c:	1885883a 	add	r2,r3,r2
    8820:	e0fffd8b 	ldhu	r3,-10(fp)
    8824:	10c0008d 	sth	r3,2(r2)
    8828:	00002a06 	br	88d4 <mem_realloc+0x30c>
    }
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
    882c:	e0bfff0b 	ldhu	r2,-4(fp)
    8830:	10800504 	addi	r2,r2,20
    8834:	e0fffb8b 	ldhu	r3,-18(fp)
    8838:	18802636 	bltu	r3,r2,88d4 <mem_realloc+0x30c>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    883c:	e0fffb0b 	ldhu	r3,-20(fp)
    8840:	e0bfff0b 	ldhu	r2,-4(fp)
    8844:	1885883a 	add	r2,r3,r2
    8848:	10800204 	addi	r2,r2,8
    884c:	e0bffd8d 	sth	r2,-10(fp)
    mem2 = (struct mem *)&ram[ptr2];
    8850:	d0e8cd17 	ldw	r3,-23756(gp)
    8854:	e0bffd8b 	ldhu	r2,-10(fp)
    8858:	1885883a 	add	r2,r3,r2
    885c:	e0bffc15 	stw	r2,-16(fp)
    if (mem2 < lfree) {
    8860:	d0a8cf17 	ldw	r2,-23748(gp)
    8864:	e0fffc17 	ldw	r3,-16(fp)
    8868:	1880022e 	bgeu	r3,r2,8874 <mem_realloc+0x2ac>
      lfree = mem2;
    886c:	e0bffc17 	ldw	r2,-16(fp)
    8870:	d0a8cf15 	stw	r2,-23748(gp)
    }
    mem2->used = 0;
    8874:	e0bffc17 	ldw	r2,-16(fp)
    8878:	10000105 	stb	zero,4(r2)
    mem2->next = mem->next;
    887c:	e0bffa17 	ldw	r2,-24(fp)
    8880:	10c0000b 	ldhu	r3,0(r2)
    8884:	e0bffc17 	ldw	r2,-16(fp)
    8888:	10c0000d 	sth	r3,0(r2)
    mem2->prev = ptr;
    888c:	e0bffc17 	ldw	r2,-16(fp)
    8890:	e0fffb0b 	ldhu	r3,-20(fp)
    8894:	10c0008d 	sth	r3,2(r2)
    mem->next = ptr2;
    8898:	e0bffa17 	ldw	r2,-24(fp)
    889c:	e0fffd8b 	ldhu	r3,-10(fp)
    88a0:	10c0000d 	sth	r3,0(r2)
    if (mem2->next != MEM_SIZE_ALIGNED) {
    88a4:	e0bffc17 	ldw	r2,-16(fp)
    88a8:	1080000b 	ldhu	r2,0(r2)
    88ac:	10bfffcc 	andi	r2,r2,65535
    88b0:	10819020 	cmpeqi	r2,r2,1600
    88b4:	1000071e 	bne	r2,zero,88d4 <mem_realloc+0x30c>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
    88b8:	d0e8cd17 	ldw	r3,-23756(gp)
    88bc:	e0bffc17 	ldw	r2,-16(fp)
    88c0:	1080000b 	ldhu	r2,0(r2)
    88c4:	10bfffcc 	andi	r2,r2,65535
    88c8:	1885883a 	add	r2,r3,r2
    88cc:	e0fffd8b 	ldhu	r3,-10(fp)
    88d0:	10c0008d 	sth	r3,2(r2)
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  return rmem;
    88d4:	e0bffe17 	ldw	r2,-8(fp)
}
    88d8:	e037883a 	mov	sp,fp
    88dc:	dfc00117 	ldw	ra,4(sp)
    88e0:	df000017 	ldw	fp,0(sp)
    88e4:	dec00204 	addi	sp,sp,8
    88e8:	f800283a 	ret

000088ec <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
    88ec:	defff904 	addi	sp,sp,-28
    88f0:	dfc00615 	stw	ra,24(sp)
    88f4:	df000515 	stw	fp,20(sp)
    88f8:	df000504 	addi	fp,sp,20
    88fc:	2005883a 	mov	r2,r4
    8900:	e0bfff0d 	sth	r2,-4(fp)
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
    8904:	e0bfff0b 	ldhu	r2,-4(fp)
    8908:	1000021e 	bne	r2,zero,8914 <mem_malloc+0x28>
    return NULL;
    890c:	0005883a 	mov	r2,zero
    8910:	0000ec06 	br	8cc4 <mem_malloc+0x3d8>
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
    8914:	e0bfff0b 	ldhu	r2,-4(fp)
    8918:	108000c4 	addi	r2,r2,3
    891c:	1007883a 	mov	r3,r2
    8920:	00bfff04 	movi	r2,-4
    8924:	1884703a 	and	r2,r3,r2
    8928:	e0bfff0d 	sth	r2,-4(fp)

  if(size < MIN_SIZE_ALIGNED) {
    892c:	e0bfff0b 	ldhu	r2,-4(fp)
    8930:	10800328 	cmpgeui	r2,r2,12
    8934:	1000021e 	bne	r2,zero,8940 <mem_malloc+0x54>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
    8938:	00800304 	movi	r2,12
    893c:	e0bfff0d 	sth	r2,-4(fp)
  }

  if (size > MEM_SIZE_ALIGNED) {
    8940:	e0bfff0b 	ldhu	r2,-4(fp)
    8944:	10819070 	cmpltui	r2,r2,1601
    8948:	1000021e 	bne	r2,zero,8954 <mem_malloc+0x68>
    return NULL;
    894c:	0005883a 	mov	r2,zero
    8950:	0000dc06 	br	8cc4 <mem_malloc+0x3d8>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
    8954:	d0a8cf17 	ldw	r2,-23748(gp)
    8958:	1007883a 	mov	r3,r2
    895c:	d0a8cd17 	ldw	r2,-23756(gp)
    8960:	1885c83a 	sub	r2,r3,r2
    8964:	e0bffb0d 	sth	r2,-20(fp)
    8968:	0000c806 	br	8c8c <mem_malloc+0x3a0>
         ptr = ((struct mem *)&ram[ptr])->next) {
      mem = (struct mem *)&ram[ptr];
    896c:	d0e8cd17 	ldw	r3,-23756(gp)
    8970:	e0bffb0b 	ldhu	r2,-20(fp)
    8974:	1885883a 	add	r2,r3,r2
    8978:	e0bffc15 	stw	r2,-16(fp)
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
    897c:	e0bffc17 	ldw	r2,-16(fp)
    8980:	10800103 	ldbu	r2,4(r2)
    8984:	10803fcc 	andi	r2,r2,255
    8988:	1000bb1e 	bne	r2,zero,8c78 <mem_malloc+0x38c>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
    898c:	e0bffc17 	ldw	r2,-16(fp)
    8990:	1080000b 	ldhu	r2,0(r2)
    8994:	10ffffcc 	andi	r3,r2,65535
    8998:	e0bffb0b 	ldhu	r2,-20(fp)
    899c:	1885c83a 	sub	r2,r3,r2
    89a0:	10fffe04 	addi	r3,r2,-8
    89a4:	e0bfff0b 	ldhu	r2,-4(fp)
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
    89a8:	1880b336 	bltu	r3,r2,8c78 <mem_malloc+0x38c>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
    89ac:	e0bffc17 	ldw	r2,-16(fp)
    89b0:	1080000b 	ldhu	r2,0(r2)
    89b4:	10ffffcc 	andi	r3,r2,65535
    89b8:	e0bffb0b 	ldhu	r2,-20(fp)
    89bc:	1885c83a 	sub	r2,r3,r2
    89c0:	10fffe04 	addi	r3,r2,-8
    89c4:	e0bfff0b 	ldhu	r2,-4(fp)
    89c8:	10800504 	addi	r2,r2,20
    89cc:	18803e36 	bltu	r3,r2,8ac8 <mem_malloc+0x1dc>
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
    89d0:	e0fffb0b 	ldhu	r3,-20(fp)
    89d4:	e0bfff0b 	ldhu	r2,-4(fp)
    89d8:	1885883a 	add	r2,r3,r2
    89dc:	10800204 	addi	r2,r2,8
    89e0:	e0bffd0d 	sth	r2,-12(fp)
          /* create mem2 struct */
          mem2 = (struct mem *)&ram[ptr2];
    89e4:	d0e8cd17 	ldw	r3,-23756(gp)
    89e8:	e0bffd0b 	ldhu	r2,-12(fp)
    89ec:	1885883a 	add	r2,r3,r2
    89f0:	e0bffe15 	stw	r2,-8(fp)
          mem2->used = 0;
    89f4:	e0bffe17 	ldw	r2,-8(fp)
    89f8:	10000105 	stb	zero,4(r2)
          mem2->next = mem->next;
    89fc:	e0bffc17 	ldw	r2,-16(fp)
    8a00:	10c0000b 	ldhu	r3,0(r2)
    8a04:	e0bffe17 	ldw	r2,-8(fp)
    8a08:	10c0000d 	sth	r3,0(r2)
          mem2->prev = ptr;
    8a0c:	e0bffe17 	ldw	r2,-8(fp)
    8a10:	e0fffb0b 	ldhu	r3,-20(fp)
    8a14:	10c0008d 	sth	r3,2(r2)
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
    8a18:	e0bffc17 	ldw	r2,-16(fp)
    8a1c:	e0fffd0b 	ldhu	r3,-12(fp)
    8a20:	10c0000d 	sth	r3,0(r2)
          mem->used = 1;
    8a24:	e0bffc17 	ldw	r2,-16(fp)
    8a28:	00c00044 	movi	r3,1
    8a2c:	10c00105 	stb	r3,4(r2)

          if (mem2->next != MEM_SIZE_ALIGNED) {
    8a30:	e0bffe17 	ldw	r2,-8(fp)
    8a34:	1080000b 	ldhu	r2,0(r2)
    8a38:	10bfffcc 	andi	r2,r2,65535
    8a3c:	10819020 	cmpeqi	r2,r2,1600
    8a40:	1000071e 	bne	r2,zero,8a60 <mem_malloc+0x174>
            ((struct mem *)&ram[mem2->next])->prev = ptr2;
    8a44:	d0e8cd17 	ldw	r3,-23756(gp)
    8a48:	e0bffe17 	ldw	r2,-8(fp)
    8a4c:	1080000b 	ldhu	r2,0(r2)
    8a50:	10bfffcc 	andi	r2,r2,65535
    8a54:	1885883a 	add	r2,r3,r2
    8a58:	e0fffd0b 	ldhu	r3,-12(fp)
    8a5c:	10c0008d 	sth	r3,2(r2)
          }
          MEM_STATS_INC_USED(used, (size + SIZEOF_STRUCT_MEM));
    8a60:	00800134 	movhi	r2,4
    8a64:	10916104 	addi	r2,r2,17796
    8a68:	10c02a8b 	ldhu	r3,170(r2)
    8a6c:	e0bfff0b 	ldhu	r2,-4(fp)
    8a70:	1885883a 	add	r2,r3,r2
    8a74:	10800204 	addi	r2,r2,8
    8a78:	1007883a 	mov	r3,r2
    8a7c:	00800134 	movhi	r2,4
    8a80:	10916104 	addi	r2,r2,17796
    8a84:	10c02a8d 	sth	r3,170(r2)
    8a88:	00800134 	movhi	r2,4
    8a8c:	10916104 	addi	r2,r2,17796
    8a90:	10c02b0b 	ldhu	r3,172(r2)
    8a94:	00800134 	movhi	r2,4
    8a98:	10916104 	addi	r2,r2,17796
    8a9c:	10802a8b 	ldhu	r2,170(r2)
    8aa0:	18ffffcc 	andi	r3,r3,65535
    8aa4:	10bfffcc 	andi	r2,r2,65535
    8aa8:	1880282e 	bgeu	r3,r2,8b4c <mem_malloc+0x260>
    8aac:	00800134 	movhi	r2,4
    8ab0:	10916104 	addi	r2,r2,17796
    8ab4:	10c02a8b 	ldhu	r3,170(r2)
    8ab8:	00800134 	movhi	r2,4
    8abc:	10916104 	addi	r2,r2,17796
    8ac0:	10c02b0d 	sth	r3,172(r2)
    8ac4:	00002106 	br	8b4c <mem_malloc+0x260>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
    8ac8:	e0bffc17 	ldw	r2,-16(fp)
    8acc:	00c00044 	movi	r3,1
    8ad0:	10c00105 	stb	r3,4(r2)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
    8ad4:	00800134 	movhi	r2,4
    8ad8:	10916104 	addi	r2,r2,17796
    8adc:	10c02a8b 	ldhu	r3,170(r2)
    8ae0:	e0bffc17 	ldw	r2,-16(fp)
    8ae4:	1100000b 	ldhu	r4,0(r2)
    8ae8:	d0a8cd17 	ldw	r2,-23756(gp)
    8aec:	100b883a 	mov	r5,r2
    8af0:	e0bffc17 	ldw	r2,-16(fp)
    8af4:	2885c83a 	sub	r2,r5,r2
    8af8:	2085883a 	add	r2,r4,r2
    8afc:	1885883a 	add	r2,r3,r2
    8b00:	1007883a 	mov	r3,r2
    8b04:	00800134 	movhi	r2,4
    8b08:	10916104 	addi	r2,r2,17796
    8b0c:	10c02a8d 	sth	r3,170(r2)
    8b10:	00800134 	movhi	r2,4
    8b14:	10916104 	addi	r2,r2,17796
    8b18:	10c02b0b 	ldhu	r3,172(r2)
    8b1c:	00800134 	movhi	r2,4
    8b20:	10916104 	addi	r2,r2,17796
    8b24:	10802a8b 	ldhu	r2,170(r2)
    8b28:	18ffffcc 	andi	r3,r3,65535
    8b2c:	10bfffcc 	andi	r2,r2,65535
    8b30:	1880062e 	bgeu	r3,r2,8b4c <mem_malloc+0x260>
    8b34:	00800134 	movhi	r2,4
    8b38:	10916104 	addi	r2,r2,17796
    8b3c:	10c02a8b 	ldhu	r3,170(r2)
    8b40:	00800134 	movhi	r2,4
    8b44:	10916104 	addi	r2,r2,17796
    8b48:	10c02b0d 	sth	r3,172(r2)
        }

        if (mem == lfree) {
    8b4c:	d0a8cf17 	ldw	r2,-23748(gp)
    8b50:	e0fffc17 	ldw	r3,-16(fp)
    8b54:	18801e1e 	bne	r3,r2,8bd0 <mem_malloc+0x2e4>
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
    8b58:	00000606 	br	8b74 <mem_malloc+0x288>
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
    8b5c:	d0e8cd17 	ldw	r3,-23756(gp)
    8b60:	d0a8cf17 	ldw	r2,-23748(gp)
    8b64:	1080000b 	ldhu	r2,0(r2)
    8b68:	10bfffcc 	andi	r2,r2,65535
    8b6c:	1885883a 	add	r2,r3,r2
    8b70:	d0a8cf15 	stw	r2,-23748(gp)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
    8b74:	d0a8cf17 	ldw	r2,-23748(gp)
    8b78:	10800103 	ldbu	r2,4(r2)
    8b7c:	10803fcc 	andi	r2,r2,255
    8b80:	10000326 	beq	r2,zero,8b90 <mem_malloc+0x2a4>
    8b84:	d0e8cf17 	ldw	r3,-23748(gp)
    8b88:	d0a8ce17 	ldw	r2,-23752(gp)
    8b8c:	18bff31e 	bne	r3,r2,8b5c <mem_malloc+0x270>
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
          }
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
    8b90:	d0e8cf17 	ldw	r3,-23748(gp)
    8b94:	d0a8ce17 	ldw	r2,-23752(gp)
    8b98:	18800d26 	beq	r3,r2,8bd0 <mem_malloc+0x2e4>
    8b9c:	d0a8cf17 	ldw	r2,-23748(gp)
    8ba0:	10800103 	ldbu	r2,4(r2)
    8ba4:	10803fcc 	andi	r2,r2,255
    8ba8:	10000926 	beq	r2,zero,8bd0 <mem_malloc+0x2e4>
    8bac:	010000f4 	movhi	r4,3
    8bb0:	213a0104 	addi	r4,r4,-6140
    8bb4:	014000f4 	movhi	r5,3
    8bb8:	297a5304 	addi	r5,r5,-5812
    8bbc:	01809204 	movi	r6,584
    8bc0:	01c000f4 	movhi	r7,3
    8bc4:	39fa1104 	addi	r7,r7,-6076
    8bc8:	00170680 	call	17068 <printf>
    8bcc:	003fff06 	br	8bcc <mem_malloc+0x2e0>
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_sem_signal(mem_sem);
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
    8bd0:	e0ffff0b 	ldhu	r3,-4(fp)
    8bd4:	e0bffc17 	ldw	r2,-16(fp)
    8bd8:	1885883a 	add	r2,r3,r2
    8bdc:	10800204 	addi	r2,r2,8
    8be0:	d0e8ce17 	ldw	r3,-23752(gp)
    8be4:	1880092e 	bgeu	r3,r2,8c0c <mem_malloc+0x320>
    8be8:	010000f4 	movhi	r4,3
    8bec:	213a0104 	addi	r4,r4,-6140
    8bf0:	014000f4 	movhi	r5,3
    8bf4:	297a5a04 	addi	r5,r5,-5784
    8bf8:	01809344 	movi	r6,589
    8bfc:	01c000f4 	movhi	r7,3
    8c00:	39fa1104 	addi	r7,r7,-6076
    8c04:	00170680 	call	17068 <printf>
    8c08:	003fff06 	br	8c08 <mem_malloc+0x31c>
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
    8c0c:	e0bffc17 	ldw	r2,-16(fp)
    8c10:	108000cc 	andi	r2,r2,3
    8c14:	10000926 	beq	r2,zero,8c3c <mem_malloc+0x350>
    8c18:	010000f4 	movhi	r4,3
    8c1c:	213a0104 	addi	r4,r4,-6140
    8c20:	014000f4 	movhi	r5,3
    8c24:	297a6604 	addi	r5,r5,-5736
    8c28:	018093c4 	movi	r6,591
    8c2c:	01c000f4 	movhi	r7,3
    8c30:	39fa1104 	addi	r7,r7,-6076
    8c34:	00170680 	call	17068 <printf>
    8c38:	003fff06 	br	8c38 <mem_malloc+0x34c>
         ((mem_ptr_t)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
    8c3c:	e0bffc17 	ldw	r2,-16(fp)
    8c40:	108000cc 	andi	r2,r2,3
    8c44:	10000926 	beq	r2,zero,8c6c <mem_malloc+0x380>
    8c48:	010000f4 	movhi	r4,3
    8c4c:	213a0104 	addi	r4,r4,-6140
    8c50:	014000f4 	movhi	r5,3
    8c54:	297a7204 	addi	r5,r5,-5688
    8c58:	01809444 	movi	r6,593
    8c5c:	01c000f4 	movhi	r7,3
    8c60:	39fa1104 	addi	r7,r7,-6076
    8c64:	00170680 	call	17068 <printf>
    8c68:	003fff06 	br	8c68 <mem_malloc+0x37c>
          (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);

        return (u8_t *)mem + SIZEOF_STRUCT_MEM;
    8c6c:	e0bffc17 	ldw	r2,-16(fp)
    8c70:	10800204 	addi	r2,r2,8
    8c74:	00001306 	br	8cc4 <mem_malloc+0x3d8>

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
         ptr = ((struct mem *)&ram[ptr])->next) {
    8c78:	d0e8cd17 	ldw	r3,-23756(gp)
    8c7c:	e0bffb0b 	ldhu	r2,-20(fp)
    8c80:	1885883a 	add	r2,r3,r2
    8c84:	1080000b 	ldhu	r2,0(r2)
    8c88:	e0bffb0d 	sth	r2,-20(fp)
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
    8c8c:	e0fffb0b 	ldhu	r3,-20(fp)
    8c90:	e0bfff0b 	ldhu	r2,-4(fp)
    8c94:	01019004 	movi	r4,1600
    8c98:	2085c83a 	sub	r2,r4,r2
    8c9c:	18bf3316 	blt	r3,r2,896c <mem_malloc+0x80>
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
    /* if we got interrupted by a mem_free, try again */
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
    8ca0:	00800134 	movhi	r2,4
    8ca4:	10916104 	addi	r2,r2,17796
    8ca8:	10802b8b 	ldhu	r2,174(r2)
    8cac:	10800044 	addi	r2,r2,1
    8cb0:	1007883a 	mov	r3,r2
    8cb4:	00800134 	movhi	r2,4
    8cb8:	10916104 	addi	r2,r2,17796
    8cbc:	10c02b8d 	sth	r3,174(r2)
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  return NULL;
    8cc0:	0005883a 	mov	r2,zero
}
    8cc4:	e037883a 	mov	sp,fp
    8cc8:	dfc00117 	ldw	ra,4(sp)
    8ccc:	df000017 	ldw	fp,0(sp)
    8cd0:	dec00204 	addi	sp,sp,8
    8cd4:	f800283a 	ret

00008cd8 <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
    8cd8:	defffb04 	addi	sp,sp,-20
    8cdc:	dfc00415 	stw	ra,16(sp)
    8ce0:	df000315 	stw	fp,12(sp)
    8ce4:	df000304 	addi	fp,sp,12
    8ce8:	2007883a 	mov	r3,r4
    8cec:	2805883a 	mov	r2,r5
    8cf0:	e0fffe0d 	sth	r3,-8(fp)
    8cf4:	e0bfff0d 	sth	r2,-4(fp)
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
    8cf8:	e0fffe0b 	ldhu	r3,-8(fp)
    8cfc:	e0bfff0b 	ldhu	r2,-4(fp)
    8d00:	1885383a 	mul	r2,r3,r2
    8d04:	10bfffcc 	andi	r2,r2,65535
    8d08:	1009883a 	mov	r4,r2
    8d0c:	00088ec0 	call	88ec <mem_malloc>
    8d10:	e0bffd15 	stw	r2,-12(fp)
  if (p) {
    8d14:	e0bffd17 	ldw	r2,-12(fp)
    8d18:	10000726 	beq	r2,zero,8d38 <mem_calloc+0x60>
    /* zero the memory */
    memset(p, 0, count * size);
    8d1c:	e0fffe0b 	ldhu	r3,-8(fp)
    8d20:	e0bfff0b 	ldhu	r2,-4(fp)
    8d24:	1885383a 	mul	r2,r3,r2
    8d28:	e13ffd17 	ldw	r4,-12(fp)
    8d2c:	000b883a 	mov	r5,zero
    8d30:	100d883a 	mov	r6,r2
    8d34:	0016f600 	call	16f60 <memset>
  }
  return p;
    8d38:	e0bffd17 	ldw	r2,-12(fp)
}
    8d3c:	e037883a 	mov	sp,fp
    8d40:	dfc00117 	ldw	ra,4(sp)
    8d44:	df000017 	ldw	fp,0(sp)
    8d48:	dec00204 	addi	sp,sp,8
    8d4c:	f800283a 	ret

00008d50 <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
    8d50:	defffd04 	addi	sp,sp,-12
    8d54:	df000215 	stw	fp,8(sp)
    8d58:	df000204 	addi	fp,sp,8
  struct memp *memp;
  u16_t i, j;

  for (i = 0; i < MEMP_MAX; ++i) {
    8d5c:	e03fff0d 	sth	zero,-4(fp)
    8d60:	00002506 	br	8df8 <memp_init+0xa8>
    MEMP_STATS_AVAIL(used, i, 0);
    8d64:	e0bfff0b 	ldhu	r2,-4(fp)
    8d68:	00c00134 	movhi	r3,4
    8d6c:	18d16104 	addi	r3,r3,17796
    8d70:	108002a4 	muli	r2,r2,10
    8d74:	1885883a 	add	r2,r3,r2
    8d78:	10802d04 	addi	r2,r2,180
    8d7c:	1000000d 	sth	zero,0(r2)
    MEMP_STATS_AVAIL(max, i, 0);
    8d80:	e0bfff0b 	ldhu	r2,-4(fp)
    8d84:	00c00134 	movhi	r3,4
    8d88:	18d16104 	addi	r3,r3,17796
    8d8c:	108002a4 	muli	r2,r2,10
    8d90:	1885883a 	add	r2,r3,r2
    8d94:	10802d84 	addi	r2,r2,182
    8d98:	1000000d 	sth	zero,0(r2)
    MEMP_STATS_AVAIL(err, i, 0);
    8d9c:	e0bfff0b 	ldhu	r2,-4(fp)
    8da0:	00c00134 	movhi	r3,4
    8da4:	18d16104 	addi	r3,r3,17796
    8da8:	108002a4 	muli	r2,r2,10
    8dac:	1885883a 	add	r2,r3,r2
    8db0:	10802e04 	addi	r2,r2,184
    8db4:	1000000d 	sth	zero,0(r2)
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
    8db8:	e17fff0b 	ldhu	r5,-4(fp)
    8dbc:	e0bfff0b 	ldhu	r2,-4(fp)
    8dc0:	00c000f4 	movhi	r3,3
    8dc4:	18fa7f84 	addi	r3,r3,-5634
    8dc8:	1085883a 	add	r2,r2,r2
    8dcc:	1885883a 	add	r2,r3,r2
    8dd0:	10c0000b 	ldhu	r3,0(r2)
    8dd4:	01000134 	movhi	r4,4
    8dd8:	21116104 	addi	r4,r4,17796
    8ddc:	288002a4 	muli	r2,r5,10
    8de0:	2085883a 	add	r2,r4,r2
    8de4:	10802c84 	addi	r2,r2,178
    8de8:	10c0000d 	sth	r3,0(r2)
memp_init(void)
{
  struct memp *memp;
  u16_t i, j;

  for (i = 0; i < MEMP_MAX; ++i) {
    8dec:	e0bfff0b 	ldhu	r2,-4(fp)
    8df0:	10800044 	addi	r2,r2,1
    8df4:	e0bfff0d 	sth	r2,-4(fp)
    8df8:	e0bfff0b 	ldhu	r2,-4(fp)
    8dfc:	10800270 	cmpltui	r2,r2,9
    8e00:	103fd81e 	bne	r2,zero,8d64 <memp_init+0x14>
    MEMP_STATS_AVAIL(max, i, 0);
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
    8e04:	008000f4 	movhi	r2,3
    8e08:	109cff04 	addi	r2,r2,29692
    8e0c:	10c000c4 	addi	r3,r2,3
    8e10:	00bfff04 	movi	r2,-4
    8e14:	1884703a 	and	r2,r3,r2
    8e18:	e0bffe15 	stw	r2,-8(fp)
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    8e1c:	e03fff0d 	sth	zero,-4(fp)
    8e20:	00003306 	br	8ef0 <memp_init+0x1a0>
    memp_tab[i] = NULL;
    8e24:	e0bfff0b 	ldhu	r2,-4(fp)
    8e28:	00c000f4 	movhi	r3,3
    8e2c:	18dcf604 	addi	r3,r3,29656
    8e30:	1085883a 	add	r2,r2,r2
    8e34:	1085883a 	add	r2,r2,r2
    8e38:	1885883a 	add	r2,r3,r2
    8e3c:	10000015 	stw	zero,0(r2)
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
    8e40:	e03fff8d 	sth	zero,-2(fp)
    8e44:	00001e06 	br	8ec0 <memp_init+0x170>
      memp->next = memp_tab[i];
    8e48:	e0bfff0b 	ldhu	r2,-4(fp)
    8e4c:	00c000f4 	movhi	r3,3
    8e50:	18dcf604 	addi	r3,r3,29656
    8e54:	1085883a 	add	r2,r2,r2
    8e58:	1085883a 	add	r2,r2,r2
    8e5c:	1885883a 	add	r2,r3,r2
    8e60:	10c00017 	ldw	r3,0(r2)
    8e64:	e0bffe17 	ldw	r2,-8(fp)
    8e68:	10c00015 	stw	r3,0(r2)
      memp_tab[i] = memp;
    8e6c:	e0bfff0b 	ldhu	r2,-4(fp)
    8e70:	00c000f4 	movhi	r3,3
    8e74:	18dcf604 	addi	r3,r3,29656
    8e78:	1085883a 	add	r2,r2,r2
    8e7c:	1085883a 	add	r2,r2,r2
    8e80:	1885883a 	add	r2,r3,r2
    8e84:	e0fffe17 	ldw	r3,-8(fp)
    8e88:	10c00015 	stw	r3,0(r2)
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
    8e8c:	e0bfff0b 	ldhu	r2,-4(fp)
    8e90:	00c000f4 	movhi	r3,3
    8e94:	18fa7b04 	addi	r3,r3,-5652
    8e98:	1085883a 	add	r2,r2,r2
    8e9c:	1885883a 	add	r2,r3,r2
    8ea0:	1080000b 	ldhu	r2,0(r2)
    8ea4:	10bfffcc 	andi	r2,r2,65535
    8ea8:	e0fffe17 	ldw	r3,-8(fp)
    8eac:	1885883a 	add	r2,r3,r2
    8eb0:	e0bffe15 	stw	r2,-8(fp)
  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
    8eb4:	e0bfff8b 	ldhu	r2,-2(fp)
    8eb8:	10800044 	addi	r2,r2,1
    8ebc:	e0bfff8d 	sth	r2,-2(fp)
    8ec0:	e0bfff0b 	ldhu	r2,-4(fp)
    8ec4:	00c000f4 	movhi	r3,3
    8ec8:	18fa7f84 	addi	r3,r3,-5634
    8ecc:	1085883a 	add	r2,r2,r2
    8ed0:	1885883a 	add	r2,r3,r2
    8ed4:	1080000b 	ldhu	r2,0(r2)
    8ed8:	10bfffcc 	andi	r2,r2,65535
    8edc:	e0ffff8b 	ldhu	r3,-2(fp)
    8ee0:	18bfd936 	bltu	r3,r2,8e48 <memp_init+0xf8>
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    8ee4:	e0bfff0b 	ldhu	r2,-4(fp)
    8ee8:	10800044 	addi	r2,r2,1
    8eec:	e0bfff0d 	sth	r2,-4(fp)
    8ef0:	e0bfff0b 	ldhu	r2,-4(fp)
    8ef4:	10800270 	cmpltui	r2,r2,9
    8ef8:	103fca1e 	bne	r2,zero,8e24 <memp_init+0xd4>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
    8efc:	e037883a 	mov	sp,fp
    8f00:	df000017 	ldw	fp,0(sp)
    8f04:	dec00104 	addi	sp,sp,4
    8f08:	f800283a 	ret

00008f0c <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
    8f0c:	defffc04 	addi	sp,sp,-16
    8f10:	dfc00315 	stw	ra,12(sp)
    8f14:	df000215 	stw	fp,8(sp)
    8f18:	df000204 	addi	fp,sp,8
    8f1c:	e13fff15 	stw	r4,-4(fp)
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
    8f20:	e0bfff17 	ldw	r2,-4(fp)
    8f24:	10800270 	cmpltui	r2,r2,9
    8f28:	1000091e 	bne	r2,zero,8f50 <memp_malloc+0x44>
    8f2c:	010000f4 	movhi	r4,3
    8f30:	213a9d04 	addi	r4,r4,-5516
    8f34:	014000f4 	movhi	r5,3
    8f38:	297aa704 	addi	r5,r5,-5476
    8f3c:	01804ec4 	movi	r6,315
    8f40:	01c000f4 	movhi	r7,3
    8f44:	39faaf04 	addi	r7,r7,-5444
    8f48:	00170680 	call	17068 <printf>
    8f4c:	003fff06 	br	8f4c <memp_malloc+0x40>
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
    8f50:	00c000f4 	movhi	r3,3
    8f54:	18dcf604 	addi	r3,r3,29656
    8f58:	e0bfff17 	ldw	r2,-4(fp)
    8f5c:	1085883a 	add	r2,r2,r2
    8f60:	1085883a 	add	r2,r2,r2
    8f64:	1885883a 	add	r2,r3,r2
    8f68:	10800017 	ldw	r2,0(r2)
    8f6c:	e0bffe15 	stw	r2,-8(fp)
  
  if (memp != NULL) {
    8f70:	e0bffe17 	ldw	r2,-8(fp)
    8f74:	10004426 	beq	r2,zero,9088 <memp_malloc+0x17c>
    memp_tab[type] = memp->next;
    8f78:	e0bffe17 	ldw	r2,-8(fp)
    8f7c:	10c00017 	ldw	r3,0(r2)
    8f80:	010000f4 	movhi	r4,3
    8f84:	211cf604 	addi	r4,r4,29656
    8f88:	e0bfff17 	ldw	r2,-4(fp)
    8f8c:	1085883a 	add	r2,r2,r2
    8f90:	1085883a 	add	r2,r2,r2
    8f94:	2085883a 	add	r2,r4,r2
    8f98:	10c00015 	stw	r3,0(r2)
#if MEMP_OVERFLOW_CHECK
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    8f9c:	00c00134 	movhi	r3,4
    8fa0:	18d16104 	addi	r3,r3,17796
    8fa4:	e0bfff17 	ldw	r2,-4(fp)
    8fa8:	108002a4 	muli	r2,r2,10
    8fac:	1885883a 	add	r2,r3,r2
    8fb0:	10802d04 	addi	r2,r2,180
    8fb4:	1080000b 	ldhu	r2,0(r2)
    8fb8:	10800044 	addi	r2,r2,1
    8fbc:	1007883a 	mov	r3,r2
    8fc0:	01000134 	movhi	r4,4
    8fc4:	21116104 	addi	r4,r4,17796
    8fc8:	e0bfff17 	ldw	r2,-4(fp)
    8fcc:	108002a4 	muli	r2,r2,10
    8fd0:	2085883a 	add	r2,r4,r2
    8fd4:	10802d04 	addi	r2,r2,180
    8fd8:	10c0000d 	sth	r3,0(r2)
    8fdc:	00c00134 	movhi	r3,4
    8fe0:	18d16104 	addi	r3,r3,17796
    8fe4:	e0bfff17 	ldw	r2,-4(fp)
    8fe8:	108002a4 	muli	r2,r2,10
    8fec:	1885883a 	add	r2,r3,r2
    8ff0:	10802d84 	addi	r2,r2,182
    8ff4:	10c0000b 	ldhu	r3,0(r2)
    8ff8:	01000134 	movhi	r4,4
    8ffc:	21116104 	addi	r4,r4,17796
    9000:	e0bfff17 	ldw	r2,-4(fp)
    9004:	108002a4 	muli	r2,r2,10
    9008:	2085883a 	add	r2,r4,r2
    900c:	10802d04 	addi	r2,r2,180
    9010:	1080000b 	ldhu	r2,0(r2)
    9014:	18ffffcc 	andi	r3,r3,65535
    9018:	10bfffcc 	andi	r2,r2,65535
    901c:	18800e2e 	bgeu	r3,r2,9058 <memp_malloc+0x14c>
    9020:	00c00134 	movhi	r3,4
    9024:	18d16104 	addi	r3,r3,17796
    9028:	e0bfff17 	ldw	r2,-4(fp)
    902c:	108002a4 	muli	r2,r2,10
    9030:	1885883a 	add	r2,r3,r2
    9034:	10802d04 	addi	r2,r2,180
    9038:	10c0000b 	ldhu	r3,0(r2)
    903c:	01000134 	movhi	r4,4
    9040:	21116104 	addi	r4,r4,17796
    9044:	e0bfff17 	ldw	r2,-4(fp)
    9048:	108002a4 	muli	r2,r2,10
    904c:	2085883a 	add	r2,r4,r2
    9050:	10802d84 	addi	r2,r2,182
    9054:	10c0000d 	sth	r3,0(r2)
    LWIP_ASSERT("memp_malloc: memp properly aligned",
    9058:	e0bffe17 	ldw	r2,-8(fp)
    905c:	108000cc 	andi	r2,r2,3
    9060:	10001a26 	beq	r2,zero,90cc <memp_malloc+0x1c0>
    9064:	010000f4 	movhi	r4,3
    9068:	213a9d04 	addi	r4,r4,-5516
    906c:	014000f4 	movhi	r5,3
    9070:	297ab504 	addi	r5,r5,-5420
    9074:	01805344 	movi	r6,333
    9078:	01c000f4 	movhi	r7,3
    907c:	39faaf04 	addi	r7,r7,-5444
    9080:	00170680 	call	17068 <printf>
    9084:	003fff06 	br	9084 <memp_malloc+0x178>
                ((mem_ptr_t)memp % MEM_ALIGNMENT) == 0);
    memp = (struct memp*)((u8_t*)memp + MEMP_SIZE);
  } else {
    LWIP_DEBUGF(MEMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("memp_malloc: out of memory in pool %s\n", memp_desc[type]));
    MEMP_STATS_INC(err, type);
    9088:	00c00134 	movhi	r3,4
    908c:	18d16104 	addi	r3,r3,17796
    9090:	e0bfff17 	ldw	r2,-4(fp)
    9094:	108002a4 	muli	r2,r2,10
    9098:	1885883a 	add	r2,r3,r2
    909c:	10802e04 	addi	r2,r2,184
    90a0:	1080000b 	ldhu	r2,0(r2)
    90a4:	10800044 	addi	r2,r2,1
    90a8:	1007883a 	mov	r3,r2
    90ac:	01000134 	movhi	r4,4
    90b0:	21116104 	addi	r4,r4,17796
    90b4:	e0bfff17 	ldw	r2,-4(fp)
    90b8:	108002a4 	muli	r2,r2,10
    90bc:	2085883a 	add	r2,r4,r2
    90c0:	10802e04 	addi	r2,r2,184
    90c4:	10c0000d 	sth	r3,0(r2)
    90c8:	00000106 	br	90d0 <memp_malloc+0x1c4>
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    LWIP_ASSERT("memp_malloc: memp properly aligned",
                ((mem_ptr_t)memp % MEM_ALIGNMENT) == 0);
    memp = (struct memp*)((u8_t*)memp + MEMP_SIZE);
    90cc:	0001883a 	nop
    MEMP_STATS_INC(err, type);
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
    90d0:	e0bffe17 	ldw	r2,-8(fp)
}
    90d4:	e037883a 	mov	sp,fp
    90d8:	dfc00117 	ldw	ra,4(sp)
    90dc:	df000017 	ldw	fp,0(sp)
    90e0:	dec00204 	addi	sp,sp,8
    90e4:	f800283a 	ret

000090e8 <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
    90e8:	defffb04 	addi	sp,sp,-20
    90ec:	dfc00415 	stw	ra,16(sp)
    90f0:	df000315 	stw	fp,12(sp)
    90f4:	df000304 	addi	fp,sp,12
    90f8:	e13ffe15 	stw	r4,-8(fp)
    90fc:	e17fff15 	stw	r5,-4(fp)
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
    9100:	e0bfff17 	ldw	r2,-4(fp)
    9104:	10003026 	beq	r2,zero,91c8 <memp_free+0xe0>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
    9108:	e0bfff17 	ldw	r2,-4(fp)
    910c:	108000cc 	andi	r2,r2,3
    9110:	10000926 	beq	r2,zero,9138 <memp_free+0x50>
    9114:	010000f4 	movhi	r4,3
    9118:	213a9d04 	addi	r4,r4,-5516
    911c:	014000f4 	movhi	r5,3
    9120:	297abe04 	addi	r5,r5,-5384
    9124:	01805a44 	movi	r6,361
    9128:	01c000f4 	movhi	r7,3
    912c:	39faaf04 	addi	r7,r7,-5444
    9130:	00170680 	call	17068 <printf>
    9134:	003fff06 	br	9134 <memp_free+0x4c>
                ((mem_ptr_t)mem % MEM_ALIGNMENT) == 0);

  memp = (struct memp *)((u8_t*)mem - MEMP_SIZE);
    9138:	e0bfff17 	ldw	r2,-4(fp)
    913c:	e0bffd15 	stw	r2,-12(fp)
#else
  memp_overflow_check_element(memp, memp_sizes[type]);
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
    9140:	00c00134 	movhi	r3,4
    9144:	18d16104 	addi	r3,r3,17796
    9148:	e0bffe17 	ldw	r2,-8(fp)
    914c:	108002a4 	muli	r2,r2,10
    9150:	1885883a 	add	r2,r3,r2
    9154:	10802d04 	addi	r2,r2,180
    9158:	1080000b 	ldhu	r2,0(r2)
    915c:	10bfffc4 	addi	r2,r2,-1
    9160:	1007883a 	mov	r3,r2
    9164:	01000134 	movhi	r4,4
    9168:	21116104 	addi	r4,r4,17796
    916c:	e0bffe17 	ldw	r2,-8(fp)
    9170:	108002a4 	muli	r2,r2,10
    9174:	2085883a 	add	r2,r4,r2
    9178:	10802d04 	addi	r2,r2,180
    917c:	10c0000d 	sth	r3,0(r2)
  
  memp->next = memp_tab[type]; 
    9180:	00c000f4 	movhi	r3,3
    9184:	18dcf604 	addi	r3,r3,29656
    9188:	e0bffe17 	ldw	r2,-8(fp)
    918c:	1085883a 	add	r2,r2,r2
    9190:	1085883a 	add	r2,r2,r2
    9194:	1885883a 	add	r2,r3,r2
    9198:	10c00017 	ldw	r3,0(r2)
    919c:	e0bffd17 	ldw	r2,-12(fp)
    91a0:	10c00015 	stw	r3,0(r2)
  memp_tab[type] = memp;
    91a4:	00c000f4 	movhi	r3,3
    91a8:	18dcf604 	addi	r3,r3,29656
    91ac:	e0bffe17 	ldw	r2,-8(fp)
    91b0:	1085883a 	add	r2,r2,r2
    91b4:	1085883a 	add	r2,r2,r2
    91b8:	1885883a 	add	r2,r3,r2
    91bc:	e0fffd17 	ldw	r3,-12(fp)
    91c0:	10c00015 	stw	r3,0(r2)
    91c4:	00000106 	br	91cc <memp_free+0xe4>
{
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
    return;
    91c8:	0001883a 	nop
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
    91cc:	e037883a 	mov	sp,fp
    91d0:	dfc00117 	ldw	ra,4(sp)
    91d4:	df000017 	ldw	fp,0(sp)
    91d8:	dec00204 	addi	sp,sp,8
    91dc:	f800283a 	ret

000091e0 <netif_add>:
netif_add(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
  struct ip_addr *gw,
  void *state,
  err_t (* init)(struct netif *netif),
  err_t (* input)(struct pbuf *p, struct netif *netif))
{
    91e0:	defffa04 	addi	sp,sp,-24
    91e4:	dfc00515 	stw	ra,20(sp)
    91e8:	df000415 	stw	fp,16(sp)
    91ec:	df000404 	addi	fp,sp,16
    91f0:	e13ffc15 	stw	r4,-16(fp)
    91f4:	e17ffd15 	stw	r5,-12(fp)
    91f8:	e1bffe15 	stw	r6,-8(fp)
    91fc:	e1ffff15 	stw	r7,-4(fp)
  static u8_t netifnum = 0;

  /* reset new interface configuration state */
  netif->ip_addr.addr = 0;
    9200:	e0bffc17 	ldw	r2,-16(fp)
    9204:	10000115 	stw	zero,4(r2)
  netif->netmask.addr = 0;
    9208:	e0bffc17 	ldw	r2,-16(fp)
    920c:	10000215 	stw	zero,8(r2)
  netif->gw.addr = 0;
    9210:	e0bffc17 	ldw	r2,-16(fp)
    9214:	10000315 	stw	zero,12(r2)
  netif->flags = 0;
    9218:	e0bffc17 	ldw	r2,-16(fp)
    921c:	10000b45 	stb	zero,45(r2)
#if LWIP_DHCP
  /* netif not under DHCP control by default */
  netif->dhcp = NULL;
    9220:	e0bffc17 	ldw	r2,-16(fp)
    9224:	10000815 	stw	zero,32(r2)
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
    9228:	e0bffc17 	ldw	r2,-16(fp)
    922c:	e0c00217 	ldw	r3,8(fp)
    9230:	10c00715 	stw	r3,28(r2)
  netif->num = netifnum++;
    9234:	d0a8d103 	ldbu	r2,-23740(gp)
    9238:	e0fffc17 	ldw	r3,-16(fp)
    923c:	18800c05 	stb	r2,48(r3)
    9240:	10800044 	addi	r2,r2,1
    9244:	d0a8d105 	stb	r2,-23740(gp)
  netif->input = input;
    9248:	e0bffc17 	ldw	r2,-16(fp)
    924c:	e0c00417 	ldw	r3,16(fp)
    9250:	10c00415 	stw	r3,16(r2)
#endif /* LWIP_NETIF_HWADDRHINT*/
#if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
  netif->loop_cnt_current = 0;
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

  netif_set_addr(netif, ipaddr, netmask, gw);
    9254:	e13ffc17 	ldw	r4,-16(fp)
    9258:	e17ffd17 	ldw	r5,-12(fp)
    925c:	e1bffe17 	ldw	r6,-8(fp)
    9260:	e1ffff17 	ldw	r7,-4(fp)
    9264:	00092b80 	call	92b8 <netif_set_addr>

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
    9268:	e0800317 	ldw	r2,12(fp)
    926c:	e13ffc17 	ldw	r4,-16(fp)
    9270:	103ee83a 	callr	r2
    9274:	10803fcc 	andi	r2,r2,255
    9278:	1080201c 	xori	r2,r2,128
    927c:	10bfe004 	addi	r2,r2,-128
    9280:	10000226 	beq	r2,zero,928c <netif_add+0xac>
    return NULL;
    9284:	0005883a 	mov	r2,zero
    9288:	00000606 	br	92a4 <netif_add+0xc4>
  }

  /* add this netif to the list */
  netif->next = netif_list;
    928c:	d0e8d217 	ldw	r3,-23736(gp)
    9290:	e0bffc17 	ldw	r2,-16(fp)
    9294:	10c00015 	stw	r3,0(r2)
  netif_list = netif;
    9298:	e0bffc17 	ldw	r2,-16(fp)
    929c:	d0a8d215 	stw	r2,-23736(gp)
  LWIP_DEBUGF(NETIF_DEBUG, (" netmask "));
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
    92a0:	e0bffc17 	ldw	r2,-16(fp)
}
    92a4:	e037883a 	mov	sp,fp
    92a8:	dfc00117 	ldw	ra,4(sp)
    92ac:	df000017 	ldw	fp,0(sp)
    92b0:	dec00204 	addi	sp,sp,8
    92b4:	f800283a 	ret

000092b8 <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
    struct ip_addr *gw)
{
    92b8:	defffa04 	addi	sp,sp,-24
    92bc:	dfc00515 	stw	ra,20(sp)
    92c0:	df000415 	stw	fp,16(sp)
    92c4:	df000404 	addi	fp,sp,16
    92c8:	e13ffc15 	stw	r4,-16(fp)
    92cc:	e17ffd15 	stw	r5,-12(fp)
    92d0:	e1bffe15 	stw	r6,-8(fp)
    92d4:	e1ffff15 	stw	r7,-4(fp)
  netif_set_ipaddr(netif, ipaddr);
    92d8:	e13ffc17 	ldw	r4,-16(fp)
    92dc:	e17ffd17 	ldw	r5,-12(fp)
    92e0:	00094ac0 	call	94ac <netif_set_ipaddr>
  netif_set_netmask(netif, netmask);
    92e4:	e13ffc17 	ldw	r4,-16(fp)
    92e8:	e17ffe17 	ldw	r5,-8(fp)
    92ec:	00096540 	call	9654 <netif_set_netmask>
  netif_set_gw(netif, gw);
    92f0:	e13ffc17 	ldw	r4,-16(fp)
    92f4:	e17fff17 	ldw	r5,-4(fp)
    92f8:	00096040 	call	9604 <netif_set_gw>
}
    92fc:	e037883a 	mov	sp,fp
    9300:	dfc00117 	ldw	ra,4(sp)
    9304:	df000017 	ldw	fp,0(sp)
    9308:	dec00204 	addi	sp,sp,8
    930c:	f800283a 	ret

00009310 <netif_remove>:
 * Remove a network interface from the list of lwIP netifs.
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
    9310:	defffc04 	addi	sp,sp,-16
    9314:	dfc00315 	stw	ra,12(sp)
    9318:	df000215 	stw	fp,8(sp)
    931c:	df000204 	addi	fp,sp,8
    9320:	e13fff15 	stw	r4,-4(fp)
  if ( netif == NULL ) return;
    9324:	e0bfff17 	ldw	r2,-4(fp)
    9328:	10002026 	beq	r2,zero,93ac <netif_remove+0x9c>
#endif /* LWIP_IGMP */

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
    932c:	d0e8d217 	ldw	r3,-23736(gp)
    9330:	e0bfff17 	ldw	r2,-4(fp)
    9334:	1880041e 	bne	r3,r2,9348 <netif_remove+0x38>
    netif_list = netif->next;
    9338:	e0bfff17 	ldw	r2,-4(fp)
    933c:	10800017 	ldw	r2,0(r2)
    9340:	d0a8d215 	stw	r2,-23736(gp)
    9344:	00001306 	br	9394 <netif_remove+0x84>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
    9348:	d0a8d217 	ldw	r2,-23736(gp)
    934c:	e0bffe15 	stw	r2,-8(fp)
    9350:	00000c06 	br	9384 <netif_remove+0x74>
      if (tmpNetif->next == netif) {
    9354:	e0bffe17 	ldw	r2,-8(fp)
    9358:	10c00017 	ldw	r3,0(r2)
    935c:	e0bfff17 	ldw	r2,-4(fp)
    9360:	1880051e 	bne	r3,r2,9378 <netif_remove+0x68>
        tmpNetif->next = netif->next;
    9364:	e0bfff17 	ldw	r2,-4(fp)
    9368:	10c00017 	ldw	r3,0(r2)
    936c:	e0bffe17 	ldw	r2,-8(fp)
    9370:	10c00015 	stw	r3,0(r2)
        snmp_dec_iflist();
        break;
    9374:	00000506 	br	938c <netif_remove+0x7c>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
    9378:	e0bffe17 	ldw	r2,-8(fp)
    937c:	10800017 	ldw	r2,0(r2)
    9380:	e0bffe15 	stw	r2,-8(fp)
    9384:	e0bffe17 	ldw	r2,-8(fp)
    9388:	103ff21e 	bne	r2,zero,9354 <netif_remove+0x44>
        tmpNetif->next = netif->next;
        snmp_dec_iflist();
        break;
      }
    }
    if (tmpNetif == NULL)
    938c:	e0bffe17 	ldw	r2,-8(fp)
    9390:	10000826 	beq	r2,zero,93b4 <netif_remove+0xa4>
      return; /*  we didn't find any netif today */
  }
  /* this netif is default? */
  if (netif_default == netif)
    9394:	d0e8d317 	ldw	r3,-23732(gp)
    9398:	e0bfff17 	ldw	r2,-4(fp)
    939c:	1880061e 	bne	r3,r2,93b8 <netif_remove+0xa8>
    /* reset default netif */
    netif_set_default(NULL);
    93a0:	0009883a 	mov	r4,zero
    93a4:	00096a40 	call	96a4 <netif_set_default>
    93a8:	00000306 	br	93b8 <netif_remove+0xa8>
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  if ( netif == NULL ) return;
    93ac:	0001883a 	nop
    93b0:	00000106 	br	93b8 <netif_remove+0xa8>
        snmp_dec_iflist();
        break;
      }
    }
    if (tmpNetif == NULL)
      return; /*  we didn't find any netif today */
    93b4:	0001883a 	nop
  /* this netif is default? */
  if (netif_default == netif)
    /* reset default netif */
    netif_set_default(NULL);
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
    93b8:	e037883a 	mov	sp,fp
    93bc:	dfc00117 	ldw	ra,4(sp)
    93c0:	df000017 	ldw	fp,0(sp)
    93c4:	dec00204 	addi	sp,sp,8
    93c8:	f800283a 	ret

000093cc <netif_find>:
 * @param name the name of the netif (like netif->name) plus concatenated number
 * in ascii representation (e.g. 'en0')
 */
struct netif *
netif_find(char *name)
{
    93cc:	defffc04 	addi	sp,sp,-16
    93d0:	df000315 	stw	fp,12(sp)
    93d4:	df000304 	addi	fp,sp,12
    93d8:	e13fff15 	stw	r4,-4(fp)
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
    93dc:	e0bfff17 	ldw	r2,-4(fp)
    93e0:	1000021e 	bne	r2,zero,93ec <netif_find+0x20>
    return NULL;
    93e4:	0005883a 	mov	r2,zero
    93e8:	00002c06 	br	949c <netif_find+0xd0>
  }

  num = name[2] - '0';
    93ec:	e0bfff17 	ldw	r2,-4(fp)
    93f0:	10800084 	addi	r2,r2,2
    93f4:	10800003 	ldbu	r2,0(r2)
    93f8:	10bff404 	addi	r2,r2,-48
    93fc:	e0bffe05 	stb	r2,-8(fp)

  for(netif = netif_list; netif != NULL; netif = netif->next) {
    9400:	d0a8d217 	ldw	r2,-23736(gp)
    9404:	e0bffd15 	stw	r2,-12(fp)
    9408:	00002106 	br	9490 <netif_find+0xc4>
    if (num == netif->num &&
    940c:	e0bffd17 	ldw	r2,-12(fp)
    9410:	10800c03 	ldbu	r2,48(r2)
    9414:	10c03fcc 	andi	r3,r2,255
    9418:	e0bffe03 	ldbu	r2,-8(fp)
    941c:	1880191e 	bne	r3,r2,9484 <netif_find+0xb8>
       name[0] == netif->name[0] &&
    9420:	e0bfff17 	ldw	r2,-4(fp)
    9424:	10c00003 	ldbu	r3,0(r2)
    9428:	e0bffd17 	ldw	r2,-12(fp)
    942c:	10800b83 	ldbu	r2,46(r2)
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
    if (num == netif->num &&
    9430:	18c03fcc 	andi	r3,r3,255
    9434:	18c0201c 	xori	r3,r3,128
    9438:	18ffe004 	addi	r3,r3,-128
    943c:	10803fcc 	andi	r2,r2,255
    9440:	1080201c 	xori	r2,r2,128
    9444:	10bfe004 	addi	r2,r2,-128
    9448:	18800e1e 	bne	r3,r2,9484 <netif_find+0xb8>
       name[0] == netif->name[0] &&
       name[1] == netif->name[1]) {
    944c:	e0bfff17 	ldw	r2,-4(fp)
    9450:	10800044 	addi	r2,r2,1
    9454:	10c00003 	ldbu	r3,0(r2)
    9458:	e0bffd17 	ldw	r2,-12(fp)
    945c:	10800bc3 	ldbu	r2,47(r2)

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
    if (num == netif->num &&
       name[0] == netif->name[0] &&
    9460:	18c03fcc 	andi	r3,r3,255
    9464:	18c0201c 	xori	r3,r3,128
    9468:	18ffe004 	addi	r3,r3,-128
    946c:	10803fcc 	andi	r2,r2,255
    9470:	1080201c 	xori	r2,r2,128
    9474:	10bfe004 	addi	r2,r2,-128
    9478:	1880021e 	bne	r3,r2,9484 <netif_find+0xb8>
       name[1] == netif->name[1]) {
      LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
      return netif;
    947c:	e0bffd17 	ldw	r2,-12(fp)
    9480:	00000606 	br	949c <netif_find+0xd0>
    return NULL;
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
    9484:	e0bffd17 	ldw	r2,-12(fp)
    9488:	10800017 	ldw	r2,0(r2)
    948c:	e0bffd15 	stw	r2,-12(fp)
    9490:	e0bffd17 	ldw	r2,-12(fp)
    9494:	103fdd1e 	bne	r2,zero,940c <netif_find+0x40>
      LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
      return netif;
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
    9498:	0005883a 	mov	r2,zero
}
    949c:	e037883a 	mov	sp,fp
    94a0:	df000017 	ldw	fp,0(sp)
    94a4:	dec00104 	addi	sp,sp,4
    94a8:	f800283a 	ret

000094ac <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, struct ip_addr *ipaddr)
{
    94ac:	defff904 	addi	sp,sp,-28
    94b0:	dfc00615 	stw	ra,24(sp)
    94b4:	df000515 	stw	fp,20(sp)
    94b8:	df000504 	addi	fp,sp,20
    94bc:	e13ffe15 	stw	r4,-8(fp)
    94c0:	e17fff15 	stw	r5,-4(fp)
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
    94c4:	e0bfff17 	ldw	r2,-4(fp)
    94c8:	10c0000b 	ldhu	r3,0(r2)
    94cc:	1080008b 	ldhu	r2,2(r2)
    94d0:	1004943a 	slli	r2,r2,16
    94d4:	10c4b03a 	or	r2,r2,r3
    94d8:	1007883a 	mov	r3,r2
    94dc:	e0bffe17 	ldw	r2,-8(fp)
    94e0:	10800117 	ldw	r2,4(r2)
    94e4:	18803726 	beq	r3,r2,95c4 <netif_set_ipaddr+0x118>
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    94e8:	008000f4 	movhi	r2,3
    94ec:	1099c204 	addi	r2,r2,26376
    94f0:	10800017 	ldw	r2,0(r2)
    94f4:	e0bffb15 	stw	r2,-20(fp)
    while (pcb != NULL) {
    94f8:	00001106 	br	9540 <netif_set_ipaddr+0x94>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
    94fc:	e0bffb17 	ldw	r2,-20(fp)
    9500:	10c00017 	ldw	r3,0(r2)
    9504:	e0bffe17 	ldw	r2,-8(fp)
    9508:	10800117 	ldw	r2,4(r2)
    950c:	1880091e 	bne	r3,r2,9534 <netif_set_ipaddr+0x88>
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
    9510:	e0bffb17 	ldw	r2,-20(fp)
    9514:	10800317 	ldw	r2,12(r2)
    9518:	e0bffd15 	stw	r2,-12(fp)
        LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
    951c:	e13ffb17 	ldw	r4,-20(fp)
    9520:	01400044 	movi	r5,1
    9524:	000b4a00 	call	b4a0 <tcp_abandon>
        pcb = next;
    9528:	e0bffd17 	ldw	r2,-12(fp)
    952c:	e0bffb15 	stw	r2,-20(fp)
    9530:	00000306 	br	9540 <netif_set_ipaddr+0x94>
      } else {
        pcb = pcb->next;
    9534:	e0bffb17 	ldw	r2,-20(fp)
    9538:	10800317 	ldw	r2,12(r2)
    953c:	e0bffb15 	stw	r2,-20(fp)
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
    9540:	e0bffb17 	ldw	r2,-20(fp)
    9544:	103fed1e 	bne	r2,zero,94fc <netif_set_ipaddr+0x50>
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    9548:	008000f4 	movhi	r2,3
    954c:	1099c404 	addi	r2,r2,26384
    9550:	10800017 	ldw	r2,0(r2)
    9554:	e0bffc15 	stw	r2,-16(fp)
    9558:	00001806 	br	95bc <netif_set_ipaddr+0x110>
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
    955c:	e0bffc17 	ldw	r2,-16(fp)
    9560:	10001326 	beq	r2,zero,95b0 <netif_set_ipaddr+0x104>
    9564:	e0bffc17 	ldw	r2,-16(fp)
    9568:	10800017 	ldw	r2,0(r2)
    956c:	10001026 	beq	r2,zero,95b0 <netif_set_ipaddr+0x104>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
    9570:	e0bffc17 	ldw	r2,-16(fp)
    9574:	10c00017 	ldw	r3,0(r2)
    9578:	e0bffe17 	ldw	r2,-8(fp)
    957c:	10800117 	ldw	r2,4(r2)
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
    9580:	18800b1e 	bne	r3,r2,95b0 <netif_set_ipaddr+0x104>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
    9584:	e0bfff17 	ldw	r2,-4(fp)
    9588:	10000626 	beq	r2,zero,95a4 <netif_set_ipaddr+0xf8>
    958c:	e0bfff17 	ldw	r2,-4(fp)
    9590:	10c0000b 	ldhu	r3,0(r2)
    9594:	1080008b 	ldhu	r2,2(r2)
    9598:	1004943a 	slli	r2,r2,16
    959c:	10c4b03a 	or	r2,r2,r3
    95a0:	00000106 	br	95a8 <netif_set_ipaddr+0xfc>
    95a4:	0005883a 	mov	r2,zero
    95a8:	e0fffc17 	ldw	r3,-16(fp)
    95ac:	18800015 	stw	r2,0(r3)
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    95b0:	e0bffc17 	ldw	r2,-16(fp)
    95b4:	10800317 	ldw	r2,12(r2)
    95b8:	e0bffc15 	stw	r2,-16(fp)
    95bc:	e0bffc17 	ldw	r2,-16(fp)
    95c0:	103fe61e 	bne	r2,zero,955c <netif_set_ipaddr+0xb0>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
    95c4:	e0bfff17 	ldw	r2,-4(fp)
    95c8:	10000626 	beq	r2,zero,95e4 <netif_set_ipaddr+0x138>
    95cc:	e0bfff17 	ldw	r2,-4(fp)
    95d0:	10c0000b 	ldhu	r3,0(r2)
    95d4:	1080008b 	ldhu	r2,2(r2)
    95d8:	1004943a 	slli	r2,r2,16
    95dc:	10c4b03a 	or	r2,r2,r3
    95e0:	00000106 	br	95e8 <netif_set_ipaddr+0x13c>
    95e4:	0005883a 	mov	r2,zero
    95e8:	e0fffe17 	ldw	r3,-8(fp)
    95ec:	18800115 	stw	r2,4(r3)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->ip_addr),
    ip4_addr2(&netif->ip_addr),
    ip4_addr3(&netif->ip_addr),
    ip4_addr4(&netif->ip_addr)));
}
    95f0:	e037883a 	mov	sp,fp
    95f4:	dfc00117 	ldw	ra,4(sp)
    95f8:	df000017 	ldw	fp,0(sp)
    95fc:	dec00204 	addi	sp,sp,8
    9600:	f800283a 	ret

00009604 <netif_set_gw>:
 *
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, struct ip_addr *gw)
{
    9604:	defffd04 	addi	sp,sp,-12
    9608:	df000215 	stw	fp,8(sp)
    960c:	df000204 	addi	fp,sp,8
    9610:	e13ffe15 	stw	r4,-8(fp)
    9614:	e17fff15 	stw	r5,-4(fp)
  ip_addr_set(&(netif->gw), gw);
    9618:	e0bfff17 	ldw	r2,-4(fp)
    961c:	10000626 	beq	r2,zero,9638 <netif_set_gw+0x34>
    9620:	e0bfff17 	ldw	r2,-4(fp)
    9624:	10c0000b 	ldhu	r3,0(r2)
    9628:	1080008b 	ldhu	r2,2(r2)
    962c:	1004943a 	slli	r2,r2,16
    9630:	10c4b03a 	or	r2,r2,r3
    9634:	00000106 	br	963c <netif_set_gw+0x38>
    9638:	0005883a 	mov	r2,zero
    963c:	e0fffe17 	ldw	r3,-8(fp)
    9640:	18800315 	stw	r2,12(r3)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->gw),
    ip4_addr2(&netif->gw),
    ip4_addr3(&netif->gw),
    ip4_addr4(&netif->gw)));
}
    9644:	e037883a 	mov	sp,fp
    9648:	df000017 	ldw	fp,0(sp)
    964c:	dec00104 	addi	sp,sp,4
    9650:	f800283a 	ret

00009654 <netif_set_netmask>:
 * @note call netif_set_addr() if you also want to change ip address and
 * default gateway
 */
void
netif_set_netmask(struct netif *netif, struct ip_addr *netmask)
{
    9654:	defffd04 	addi	sp,sp,-12
    9658:	df000215 	stw	fp,8(sp)
    965c:	df000204 	addi	fp,sp,8
    9660:	e13ffe15 	stw	r4,-8(fp)
    9664:	e17fff15 	stw	r5,-4(fp)
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
    9668:	e0bfff17 	ldw	r2,-4(fp)
    966c:	10000626 	beq	r2,zero,9688 <netif_set_netmask+0x34>
    9670:	e0bfff17 	ldw	r2,-4(fp)
    9674:	10c0000b 	ldhu	r3,0(r2)
    9678:	1080008b 	ldhu	r2,2(r2)
    967c:	1004943a 	slli	r2,r2,16
    9680:	10c4b03a 	or	r2,r2,r3
    9684:	00000106 	br	968c <netif_set_netmask+0x38>
    9688:	0005883a 	mov	r2,zero
    968c:	e0fffe17 	ldw	r3,-8(fp)
    9690:	18800215 	stw	r2,8(r3)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->netmask),
    ip4_addr2(&netif->netmask),
    ip4_addr3(&netif->netmask),
    ip4_addr4(&netif->netmask)));
}
    9694:	e037883a 	mov	sp,fp
    9698:	df000017 	ldw	fp,0(sp)
    969c:	dec00104 	addi	sp,sp,4
    96a0:	f800283a 	ret

000096a4 <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
    96a4:	defffe04 	addi	sp,sp,-8
    96a8:	df000115 	stw	fp,4(sp)
    96ac:	df000104 	addi	fp,sp,4
    96b0:	e13fff15 	stw	r4,-4(fp)
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
    96b4:	e0bfff17 	ldw	r2,-4(fp)
    96b8:	d0a8d315 	stw	r2,-23732(gp)
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
    96bc:	e037883a 	mov	sp,fp
    96c0:	df000017 	ldw	fp,0(sp)
    96c4:	dec00104 	addi	sp,sp,4
    96c8:	f800283a 	ret

000096cc <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
    96cc:	defffd04 	addi	sp,sp,-12
    96d0:	dfc00215 	stw	ra,8(sp)
    96d4:	df000115 	stw	fp,4(sp)
    96d8:	df000104 	addi	fp,sp,4
    96dc:	e13fff15 	stw	r4,-4(fp)
  if ( !(netif->flags & NETIF_FLAG_UP )) {
    96e0:	e0bfff17 	ldw	r2,-4(fp)
    96e4:	10800b43 	ldbu	r2,45(r2)
    96e8:	10803fcc 	andi	r2,r2,255
    96ec:	1080004c 	andi	r2,r2,1
    96f0:	1000101e 	bne	r2,zero,9734 <netif_set_up+0x68>
    netif->flags |= NETIF_FLAG_UP;
    96f4:	e0bfff17 	ldw	r2,-4(fp)
    96f8:	10800b43 	ldbu	r2,45(r2)
    96fc:	10800054 	ori	r2,r2,1
    9700:	1007883a 	mov	r3,r2
    9704:	e0bfff17 	ldw	r2,-4(fp)
    9708:	10c00b45 	stb	r3,45(r2)
    NETIF_LINK_CALLBACK(netif);
    NETIF_STATUS_CALLBACK(netif);

#if LWIP_ARP
    /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */ 
    if (netif->flags & NETIF_FLAG_ETHARP) {
    970c:	e0bfff17 	ldw	r2,-4(fp)
    9710:	10800b43 	ldbu	r2,45(r2)
    9714:	10803fcc 	andi	r2,r2,255
    9718:	1080080c 	andi	r2,r2,32
    971c:	10000526 	beq	r2,zero,9734 <netif_set_up+0x68>
      etharp_gratuitous(netif);
    9720:	e0bfff17 	ldw	r2,-4(fp)
    9724:	10800104 	addi	r2,r2,4
    9728:	e13fff17 	ldw	r4,-4(fp)
    972c:	100b883a 	mov	r5,r2
    9730:	00169a00 	call	169a0 <etharp_request>
    if (netif->flags & NETIF_FLAG_IGMP) {
      igmp_report_groups( netif);
    }
#endif /* LWIP_IGMP */
  }
}
    9734:	e037883a 	mov	sp,fp
    9738:	dfc00117 	ldw	ra,4(sp)
    973c:	df000017 	ldw	fp,0(sp)
    9740:	dec00204 	addi	sp,sp,8
    9744:	f800283a 	ret

00009748 <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
    9748:	defffe04 	addi	sp,sp,-8
    974c:	df000115 	stw	fp,4(sp)
    9750:	df000104 	addi	fp,sp,4
    9754:	e13fff15 	stw	r4,-4(fp)
  if ( netif->flags & NETIF_FLAG_UP )
    9758:	e0bfff17 	ldw	r2,-4(fp)
    975c:	10800b43 	ldbu	r2,45(r2)
    9760:	10803fcc 	andi	r2,r2,255
    9764:	1080004c 	andi	r2,r2,1
    9768:	10000726 	beq	r2,zero,9788 <netif_set_down+0x40>
    {
      netif->flags &= ~NETIF_FLAG_UP;
    976c:	e0bfff17 	ldw	r2,-4(fp)
    9770:	10c00b43 	ldbu	r3,45(r2)
    9774:	00bfff84 	movi	r2,-2
    9778:	1884703a 	and	r2,r3,r2
    977c:	1007883a 	mov	r3,r2
    9780:	e0bfff17 	ldw	r2,-4(fp)
    9784:	10c00b45 	stb	r3,45(r2)
#endif
      
      NETIF_LINK_CALLBACK(netif);
      NETIF_STATUS_CALLBACK(netif);
    }
}
    9788:	e037883a 	mov	sp,fp
    978c:	df000017 	ldw	fp,0(sp)
    9790:	dec00104 	addi	sp,sp,4
    9794:	f800283a 	ret

00009798 <netif_is_up>:

/**
 * Ask if an interface is up
 */ 
u8_t netif_is_up(struct netif *netif)
{
    9798:	defffe04 	addi	sp,sp,-8
    979c:	df000115 	stw	fp,4(sp)
    97a0:	df000104 	addi	fp,sp,4
    97a4:	e13fff15 	stw	r4,-4(fp)
  return (netif->flags & NETIF_FLAG_UP)?1:0;
    97a8:	e0bfff17 	ldw	r2,-4(fp)
    97ac:	10800b43 	ldbu	r2,45(r2)
    97b0:	10803fcc 	andi	r2,r2,255
    97b4:	1080004c 	andi	r2,r2,1
    97b8:	1004c03a 	cmpne	r2,r2,zero
}
    97bc:	e037883a 	mov	sp,fp
    97c0:	df000017 	ldw	fp,0(sp)
    97c4:	dec00104 	addi	sp,sp,4
    97c8:	f800283a 	ret

000097cc <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
    97cc:	defff604 	addi	sp,sp,-40
    97d0:	dfc00915 	stw	ra,36(sp)
    97d4:	df000815 	stw	fp,32(sp)
    97d8:	df000804 	addi	fp,sp,32
    97dc:	e13ffd15 	stw	r4,-12(fp)
    97e0:	2805883a 	mov	r2,r5
    97e4:	e1bfff15 	stw	r6,-4(fp)
    97e8:	e0bffe0d 	sth	r2,-8(fp)
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
    97ec:	e03ffa0d 	sth	zero,-24(fp)
  switch (layer) {
    97f0:	e0bffd17 	ldw	r2,-12(fp)
    97f4:	10c00060 	cmpeqi	r3,r2,1
    97f8:	1800091e 	bne	r3,zero,9820 <pbuf_alloc+0x54>
    97fc:	0080052e 	bgeu	zero,r2,9814 <pbuf_alloc+0x48>
    9800:	10c000a0 	cmpeqi	r3,r2,2
    9804:	1800091e 	bne	r3,zero,982c <pbuf_alloc+0x60>
    9808:	108000e0 	cmpeqi	r2,r2,3
    980c:	1000141e 	bne	r2,zero,9860 <pbuf_alloc+0x94>
    9810:	00000a06 	br	983c <pbuf_alloc+0x70>
  case PBUF_TRANSPORT:
    /* add room for transport (often TCP) layer header */
    offset += PBUF_TRANSPORT_HLEN;
    9814:	e0bffa0b 	ldhu	r2,-24(fp)
    9818:	10800504 	addi	r2,r2,20
    981c:	e0bffa0d 	sth	r2,-24(fp)
    /* FALLTHROUGH */
  case PBUF_IP:
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
    9820:	e0bffa0b 	ldhu	r2,-24(fp)
    9824:	10800504 	addi	r2,r2,20
    9828:	e0bffa0d 	sth	r2,-24(fp)
    /* FALLTHROUGH */
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
    982c:	e0bffa0b 	ldhu	r2,-24(fp)
    9830:	10800384 	addi	r2,r2,14
    9834:	e0bffa0d 	sth	r2,-24(fp)
    break;
    9838:	00000a06 	br	9864 <pbuf_alloc+0x98>
  case PBUF_RAW:
    break;
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
    983c:	010000f4 	movhi	r4,3
    9840:	213ac604 	addi	r4,r4,-5352
    9844:	014000f4 	movhi	r5,3
    9848:	297ad004 	addi	r5,r5,-5312
    984c:	018033c4 	movi	r6,207
    9850:	01c000f4 	movhi	r7,3
    9854:	39fad704 	addi	r7,r7,-5284
    9858:	00170680 	call	17068 <printf>
    985c:	003fff06 	br	985c <pbuf_alloc+0x90>
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
    break;
  case PBUF_RAW:
    break;
    9860:	0001883a 	nop
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
    return NULL;
  }

  switch (type) {
    9864:	e0bfff17 	ldw	r2,-4(fp)
    9868:	10c000e8 	cmpgeui	r3,r2,3
    986c:	1800021e 	bne	r3,zero,9878 <pbuf_alloc+0xac>
    9870:	0080fa36 	bltu	zero,r2,9c5c <pbuf_alloc+0x490>
    9874:	0000c106 	br	9b7c <pbuf_alloc+0x3b0>
    9878:	108000e0 	cmpeqi	r2,r2,3
    987c:	10010e26 	beq	r2,zero,9cb8 <pbuf_alloc+0x4ec>
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
    p = memp_malloc(MEMP_PBUF_POOL);
    9880:	01000204 	movi	r4,8
    9884:	0008f0c0 	call	8f0c <memp_malloc>
    9888:	e0bff815 	stw	r2,-32(fp)
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
    988c:	e0bff817 	ldw	r2,-32(fp)
    9890:	1000021e 	bne	r2,zero,989c <pbuf_alloc+0xd0>
      PBUF_POOL_IS_EMPTY();
      return NULL;
    9894:	0005883a 	mov	r2,zero
    9898:	00011706 	br	9cf8 <pbuf_alloc+0x52c>
    }
    p->type = type;
    989c:	e0bfff17 	ldw	r2,-4(fp)
    98a0:	1007883a 	mov	r3,r2
    98a4:	e0bff817 	ldw	r2,-32(fp)
    98a8:	10c00305 	stb	r3,12(r2)
    p->next = NULL;
    98ac:	e0bff817 	ldw	r2,-32(fp)
    98b0:	10000015 	stw	zero,0(r2)

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
    98b4:	e0bffa0b 	ldhu	r2,-24(fp)
    98b8:	10800404 	addi	r2,r2,16
    98bc:	e0fff817 	ldw	r3,-32(fp)
    98c0:	1885883a 	add	r2,r3,r2
    98c4:	10c000c4 	addi	r3,r2,3
    98c8:	00bfff04 	movi	r2,-4
    98cc:	1884703a 	and	r2,r3,r2
    98d0:	1007883a 	mov	r3,r2
    98d4:	e0bff817 	ldw	r2,-32(fp)
    98d8:	10c00115 	stw	r3,4(r2)
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
    98dc:	e0bff817 	ldw	r2,-32(fp)
    98e0:	10800117 	ldw	r2,4(r2)
    98e4:	108000cc 	andi	r2,r2,3
    98e8:	10000926 	beq	r2,zero,9910 <pbuf_alloc+0x144>
    98ec:	010000f4 	movhi	r4,3
    98f0:	213ac604 	addi	r4,r4,-5352
    98f4:	014000f4 	movhi	r5,3
    98f8:	297add04 	addi	r5,r5,-5260
    98fc:	01803884 	movi	r6,226
    9900:	01c000f4 	movhi	r7,3
    9904:	39fad704 	addi	r7,r7,-5284
    9908:	00170680 	call	17068 <printf>
    990c:	003fff06 	br	990c <pbuf_alloc+0x140>
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
    9910:	e0bff817 	ldw	r2,-32(fp)
    9914:	e0fffe0b 	ldhu	r3,-8(fp)
    9918:	10c0020d 	sth	r3,8(r2)
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
    991c:	e0bffa0b 	ldhu	r2,-24(fp)
    9920:	10c000c4 	addi	r3,r2,3
    9924:	00bfff04 	movi	r2,-4
    9928:	1884703a 	and	r2,r3,r2
    992c:	00c17b04 	movi	r3,1516
    9930:	1885c83a 	sub	r2,r3,r2
    9934:	e0fffe0b 	ldhu	r3,-8(fp)
    9938:	1880010e 	bge	r3,r2,9940 <pbuf_alloc+0x174>
    993c:	1805883a 	mov	r2,r3
    9940:	1007883a 	mov	r3,r2
    9944:	e0bff817 	ldw	r2,-32(fp)
    9948:	10c0028d 	sth	r3,10(r2)
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
    994c:	e0bff817 	ldw	r2,-32(fp)
    9950:	10c00117 	ldw	r3,4(r2)
    9954:	e0bff817 	ldw	r2,-32(fp)
    9958:	1080028b 	ldhu	r2,10(r2)
    995c:	10bfffcc 	andi	r2,r2,65535
    9960:	1885883a 	add	r2,r3,r2
    9964:	e0fff817 	ldw	r3,-32(fp)
    9968:	18c17f04 	addi	r3,r3,1532
    996c:	1880092e 	bgeu	r3,r2,9994 <pbuf_alloc+0x1c8>
    9970:	010000f4 	movhi	r4,3
    9974:	213ac604 	addi	r4,r4,-5352
    9978:	014000f4 	movhi	r5,3
    997c:	297ae904 	addi	r5,r5,-5212
    9980:	01803a44 	movi	r6,233
    9984:	01c000f4 	movhi	r7,3
    9988:	39fad704 	addi	r7,r7,-5284
    998c:	00170680 	call	17068 <printf>
    9990:	003fff06 	br	9990 <pbuf_alloc+0x1c4>
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    LWIP_ASSERT("PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",
    9994:	e0bffa0b 	ldhu	r2,-24(fp)
    9998:	10c000c4 	addi	r3,r2,3
    999c:	00bfff04 	movi	r2,-4
    99a0:	1884703a 	and	r2,r3,r2
    99a4:	00c17b04 	movi	r3,1516
    99a8:	1885c83a 	sub	r2,r3,r2
    99ac:	00800916 	blt	zero,r2,99d4 <pbuf_alloc+0x208>
    99b0:	010000f4 	movhi	r4,3
    99b4:	213ac604 	addi	r4,r4,-5352
    99b8:	014000f4 	movhi	r5,3
    99bc:	297af604 	addi	r5,r5,-5160
    99c0:	01803ac4 	movi	r6,235
    99c4:	01c000f4 	movhi	r7,3
    99c8:	39fad704 	addi	r7,r7,-5284
    99cc:	00170680 	call	17068 <printf>
    99d0:	003fff06 	br	99d0 <pbuf_alloc+0x204>
      (PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)) > 0 );
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
    99d4:	e0bff817 	ldw	r2,-32(fp)
    99d8:	00c00044 	movi	r3,1
    99dc:	10c0038d 	sth	r3,14(r2)

    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
    99e0:	e0bff817 	ldw	r2,-32(fp)
    99e4:	e0bff915 	stw	r2,-28(fp)
    /* remaining length to be allocated */
    rem_len = length - p->len;
    99e8:	e0fffe0b 	ldhu	r3,-8(fp)
    99ec:	e0bff817 	ldw	r2,-32(fp)
    99f0:	1080028b 	ldhu	r2,10(r2)
    99f4:	10bfffcc 	andi	r2,r2,65535
    99f8:	1885c83a 	sub	r2,r3,r2
    99fc:	e0bffb15 	stw	r2,-20(fp)
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
    9a00:	00005b06 	br	9b70 <pbuf_alloc+0x3a4>
      q = memp_malloc(MEMP_PBUF_POOL);
    9a04:	01000204 	movi	r4,8
    9a08:	0008f0c0 	call	8f0c <memp_malloc>
    9a0c:	e0bffc15 	stw	r2,-16(fp)
      if (q == NULL) {
    9a10:	e0bffc17 	ldw	r2,-16(fp)
    9a14:	1000041e 	bne	r2,zero,9a28 <pbuf_alloc+0x25c>
        PBUF_POOL_IS_EMPTY();
        /* free chain so far allocated */
        pbuf_free(p);
    9a18:	e13ff817 	ldw	r4,-32(fp)
    9a1c:	000a1880 	call	a188 <pbuf_free>
        /* bail out unsuccesfully */
        return NULL;
    9a20:	0005883a 	mov	r2,zero
    9a24:	0000b406 	br	9cf8 <pbuf_alloc+0x52c>
      }
      q->type = type;
    9a28:	e0bfff17 	ldw	r2,-4(fp)
    9a2c:	1007883a 	mov	r3,r2
    9a30:	e0bffc17 	ldw	r2,-16(fp)
    9a34:	10c00305 	stb	r3,12(r2)
      q->flags = 0;
    9a38:	e0bffc17 	ldw	r2,-16(fp)
    9a3c:	10000345 	stb	zero,13(r2)
      q->next = NULL;
    9a40:	e0bffc17 	ldw	r2,-16(fp)
    9a44:	10000015 	stw	zero,0(r2)
      /* make previous pbuf point to this pbuf */
      r->next = q;
    9a48:	e0bff917 	ldw	r2,-28(fp)
    9a4c:	e0fffc17 	ldw	r3,-16(fp)
    9a50:	10c00015 	stw	r3,0(r2)
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
    9a54:	e0bffb17 	ldw	r2,-20(fp)
    9a58:	00ffff94 	movui	r3,65534
    9a5c:	1880090e 	bge	r3,r2,9a84 <pbuf_alloc+0x2b8>
    9a60:	010000f4 	movhi	r4,3
    9a64:	213ac604 	addi	r4,r4,-5352
    9a68:	014000f4 	movhi	r5,3
    9a6c:	297b0304 	addi	r5,r5,-5108
    9a70:	01804144 	movi	r6,261
    9a74:	01c000f4 	movhi	r7,3
    9a78:	39fad704 	addi	r7,r7,-5284
    9a7c:	00170680 	call	17068 <printf>
    9a80:	003fff06 	br	9a80 <pbuf_alloc+0x2b4>
      q->tot_len = (u16_t)rem_len;
    9a84:	e0bffb17 	ldw	r2,-20(fp)
    9a88:	1007883a 	mov	r3,r2
    9a8c:	e0bffc17 	ldw	r2,-16(fp)
    9a90:	10c0020d 	sth	r3,8(r2)
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
    9a94:	e0bffb17 	ldw	r2,-20(fp)
    9a98:	10bfffcc 	andi	r2,r2,65535
    9a9c:	10817b28 	cmpgeui	r2,r2,1516
    9aa0:	1000021e 	bne	r2,zero,9aac <pbuf_alloc+0x2e0>
    9aa4:	e0bffb17 	ldw	r2,-20(fp)
    9aa8:	00000106 	br	9ab0 <pbuf_alloc+0x2e4>
    9aac:	00817b04 	movi	r2,1516
    9ab0:	e0fffc17 	ldw	r3,-16(fp)
    9ab4:	1880028d 	sth	r2,10(r3)
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
    9ab8:	e0bffc17 	ldw	r2,-16(fp)
    9abc:	10c00404 	addi	r3,r2,16
    9ac0:	e0bffc17 	ldw	r2,-16(fp)
    9ac4:	10c00115 	stw	r3,4(r2)
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
    9ac8:	e0bffc17 	ldw	r2,-16(fp)
    9acc:	10800117 	ldw	r2,4(r2)
    9ad0:	108000cc 	andi	r2,r2,3
    9ad4:	10000926 	beq	r2,zero,9afc <pbuf_alloc+0x330>
    9ad8:	010000f4 	movhi	r4,3
    9adc:	213ac604 	addi	r4,r4,-5352
    9ae0:	014000f4 	movhi	r5,3
    9ae4:	297b0804 	addi	r5,r5,-5088
    9ae8:	018042c4 	movi	r6,267
    9aec:	01c000f4 	movhi	r7,3
    9af0:	39fad704 	addi	r7,r7,-5284
    9af4:	00170680 	call	17068 <printf>
    9af8:	003fff06 	br	9af8 <pbuf_alloc+0x32c>
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
    9afc:	e0bff817 	ldw	r2,-32(fp)
    9b00:	10c00117 	ldw	r3,4(r2)
    9b04:	e0bff817 	ldw	r2,-32(fp)
    9b08:	1080028b 	ldhu	r2,10(r2)
    9b0c:	10bfffcc 	andi	r2,r2,65535
    9b10:	1885883a 	add	r2,r3,r2
    9b14:	e0fff817 	ldw	r3,-32(fp)
    9b18:	18c17f04 	addi	r3,r3,1532
    9b1c:	1880092e 	bgeu	r3,r2,9b44 <pbuf_alloc+0x378>
    9b20:	010000f4 	movhi	r4,3
    9b24:	213ac604 	addi	r4,r4,-5352
    9b28:	014000f4 	movhi	r5,3
    9b2c:	297ae904 	addi	r5,r5,-5212
    9b30:	01804384 	movi	r6,270
    9b34:	01c000f4 	movhi	r7,3
    9b38:	39fad704 	addi	r7,r7,-5284
    9b3c:	00170680 	call	17068 <printf>
    9b40:	003fff06 	br	9b40 <pbuf_alloc+0x374>
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
    9b44:	e0bffc17 	ldw	r2,-16(fp)
    9b48:	00c00044 	movi	r3,1
    9b4c:	10c0038d 	sth	r3,14(r2)
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
    9b50:	e0bffc17 	ldw	r2,-16(fp)
    9b54:	1080028b 	ldhu	r2,10(r2)
    9b58:	10bfffcc 	andi	r2,r2,65535
    9b5c:	e0fffb17 	ldw	r3,-20(fp)
    9b60:	1885c83a 	sub	r2,r3,r2
    9b64:	e0bffb15 	stw	r2,-20(fp)
      /* remember this pbuf for linkage in next iteration */
      r = q;
    9b68:	e0bffc17 	ldw	r2,-16(fp)
    9b6c:	e0bff915 	stw	r2,-28(fp)
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
    9b70:	e0bffb17 	ldw	r2,-20(fp)
    9b74:	00bfa316 	blt	zero,r2,9a04 <pbuf_alloc+0x238>
      r = q;
    }
    /* end of chain */
    /*r->next = NULL;*/

    break;
    9b78:	00005906 	br	9ce0 <pbuf_alloc+0x514>
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
    9b7c:	e0bffa0b 	ldhu	r2,-24(fp)
    9b80:	108004c4 	addi	r2,r2,19
    9b84:	1007883a 	mov	r3,r2
    9b88:	00bfff04 	movi	r2,-4
    9b8c:	1884703a 	and	r2,r3,r2
    9b90:	1007883a 	mov	r3,r2
    9b94:	e0bffe0b 	ldhu	r2,-8(fp)
    9b98:	108000c4 	addi	r2,r2,3
    9b9c:	1009883a 	mov	r4,r2
    9ba0:	00bfff04 	movi	r2,-4
    9ba4:	2084703a 	and	r2,r4,r2
    9ba8:	1885883a 	add	r2,r3,r2
    9bac:	10bfffcc 	andi	r2,r2,65535
    9bb0:	1009883a 	mov	r4,r2
    9bb4:	00088ec0 	call	88ec <mem_malloc>
    9bb8:	e0bff815 	stw	r2,-32(fp)
    if (p == NULL) {
    9bbc:	e0bff817 	ldw	r2,-32(fp)
    9bc0:	1000021e 	bne	r2,zero,9bcc <pbuf_alloc+0x400>
      return NULL;
    9bc4:	0005883a 	mov	r2,zero
    9bc8:	00004b06 	br	9cf8 <pbuf_alloc+0x52c>
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
    9bcc:	e0bffa0b 	ldhu	r2,-24(fp)
    9bd0:	10800404 	addi	r2,r2,16
    9bd4:	e0fff817 	ldw	r3,-32(fp)
    9bd8:	1885883a 	add	r2,r3,r2
    9bdc:	10c000c4 	addi	r3,r2,3
    9be0:	00bfff04 	movi	r2,-4
    9be4:	1884703a 	and	r2,r3,r2
    9be8:	1007883a 	mov	r3,r2
    9bec:	e0bff817 	ldw	r2,-32(fp)
    9bf0:	10c00115 	stw	r3,4(r2)
    p->len = p->tot_len = length;
    9bf4:	e0bff817 	ldw	r2,-32(fp)
    9bf8:	e0fffe0b 	ldhu	r3,-8(fp)
    9bfc:	10c0020d 	sth	r3,8(r2)
    9c00:	e0bff817 	ldw	r2,-32(fp)
    9c04:	10c0020b 	ldhu	r3,8(r2)
    9c08:	e0bff817 	ldw	r2,-32(fp)
    9c0c:	10c0028d 	sth	r3,10(r2)
    p->next = NULL;
    9c10:	e0bff817 	ldw	r2,-32(fp)
    9c14:	10000015 	stw	zero,0(r2)
    p->type = type;
    9c18:	e0bfff17 	ldw	r2,-4(fp)
    9c1c:	1007883a 	mov	r3,r2
    9c20:	e0bff817 	ldw	r2,-32(fp)
    9c24:	10c00305 	stb	r3,12(r2)

    LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
    9c28:	e0bff817 	ldw	r2,-32(fp)
    9c2c:	10800117 	ldw	r2,4(r2)
    9c30:	108000cc 	andi	r2,r2,3
    9c34:	10002926 	beq	r2,zero,9cdc <pbuf_alloc+0x510>
    9c38:	010000f4 	movhi	r4,3
    9c3c:	213ac604 	addi	r4,r4,-5352
    9c40:	014000f4 	movhi	r5,3
    9c44:	297b1404 	addi	r5,r5,-5040
    9c48:	01804984 	movi	r6,294
    9c4c:	01c000f4 	movhi	r7,3
    9c50:	39fad704 	addi	r7,r7,-5284
    9c54:	00170680 	call	17068 <printf>
    9c58:	003fff06 	br	9c58 <pbuf_alloc+0x48c>
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = memp_malloc(MEMP_PBUF);
    9c5c:	010001c4 	movi	r4,7
    9c60:	0008f0c0 	call	8f0c <memp_malloc>
    9c64:	e0bff815 	stw	r2,-32(fp)
    if (p == NULL) {
    9c68:	e0bff817 	ldw	r2,-32(fp)
    9c6c:	1000021e 	bne	r2,zero,9c78 <pbuf_alloc+0x4ac>
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                  ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
    9c70:	0005883a 	mov	r2,zero
    9c74:	00002006 	br	9cf8 <pbuf_alloc+0x52c>
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
    9c78:	e0bff817 	ldw	r2,-32(fp)
    9c7c:	10000115 	stw	zero,4(r2)
    p->len = p->tot_len = length;
    9c80:	e0bff817 	ldw	r2,-32(fp)
    9c84:	e0fffe0b 	ldhu	r3,-8(fp)
    9c88:	10c0020d 	sth	r3,8(r2)
    9c8c:	e0bff817 	ldw	r2,-32(fp)
    9c90:	10c0020b 	ldhu	r3,8(r2)
    9c94:	e0bff817 	ldw	r2,-32(fp)
    9c98:	10c0028d 	sth	r3,10(r2)
    p->next = NULL;
    9c9c:	e0bff817 	ldw	r2,-32(fp)
    9ca0:	10000015 	stw	zero,0(r2)
    p->type = type;
    9ca4:	e0bfff17 	ldw	r2,-4(fp)
    9ca8:	1007883a 	mov	r3,r2
    9cac:	e0bff817 	ldw	r2,-32(fp)
    9cb0:	10c00305 	stb	r3,12(r2)
    break;
    9cb4:	00000a06 	br	9ce0 <pbuf_alloc+0x514>
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
    9cb8:	010000f4 	movhi	r4,3
    9cbc:	213ac604 	addi	r4,r4,-5352
    9cc0:	014000f4 	movhi	r5,3
    9cc4:	297b1f04 	addi	r5,r5,-4996
    9cc8:	01804ec4 	movi	r6,315
    9ccc:	01c000f4 	movhi	r7,3
    9cd0:	39fad704 	addi	r7,r7,-5284
    9cd4:	00170680 	call	17068 <printf>
    9cd8:	003fff06 	br	9cd8 <pbuf_alloc+0x50c>
    p->next = NULL;
    p->type = type;

    LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
           ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    break;
    9cdc:	0001883a 	nop
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
    return NULL;
  }
  /* set reference count */
  p->ref = 1;
    9ce0:	e0bff817 	ldw	r2,-32(fp)
    9ce4:	00c00044 	movi	r3,1
    9ce8:	10c0038d 	sth	r3,14(r2)
  /* set flags */
  p->flags = 0;
    9cec:	e0bff817 	ldw	r2,-32(fp)
    9cf0:	10000345 	stb	zero,13(r2)
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
    9cf4:	e0bff817 	ldw	r2,-32(fp)
}
    9cf8:	e037883a 	mov	sp,fp
    9cfc:	dfc00117 	ldw	ra,4(sp)
    9d00:	df000017 	ldw	fp,0(sp)
    9d04:	dec00204 	addi	sp,sp,8
    9d08:	f800283a 	ret

00009d0c <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
    9d0c:	defff904 	addi	sp,sp,-28
    9d10:	dfc00615 	stw	ra,24(sp)
    9d14:	df000515 	stw	fp,20(sp)
    9d18:	df000504 	addi	fp,sp,20
    9d1c:	e13ffe15 	stw	r4,-8(fp)
    9d20:	2805883a 	mov	r2,r5
    9d24:	e0bfff0d 	sth	r2,-4(fp)
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  s32_t grow;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
    9d28:	e0bffe17 	ldw	r2,-8(fp)
    9d2c:	1000091e 	bne	r2,zero,9d54 <pbuf_realloc+0x48>
    9d30:	010000f4 	movhi	r4,3
    9d34:	213ac604 	addi	r4,r4,-5352
    9d38:	014000f4 	movhi	r5,3
    9d3c:	297b2604 	addi	r5,r5,-4968
    9d40:	01805744 	movi	r6,349
    9d44:	01c000f4 	movhi	r7,3
    9d48:	39fad704 	addi	r7,r7,-5284
    9d4c:	00170680 	call	17068 <printf>
    9d50:	003fff06 	br	9d50 <pbuf_realloc+0x44>
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
    9d54:	e0bffe17 	ldw	r2,-8(fp)
    9d58:	10800303 	ldbu	r2,12(r2)
    9d5c:	10803fcc 	andi	r2,r2,255
    9d60:	108000e0 	cmpeqi	r2,r2,3
    9d64:	1000171e 	bne	r2,zero,9dc4 <pbuf_realloc+0xb8>
    9d68:	e0bffe17 	ldw	r2,-8(fp)
    9d6c:	10800303 	ldbu	r2,12(r2)
    9d70:	10803fcc 	andi	r2,r2,255
    9d74:	10800060 	cmpeqi	r2,r2,1
    9d78:	1000121e 	bne	r2,zero,9dc4 <pbuf_realloc+0xb8>
    9d7c:	e0bffe17 	ldw	r2,-8(fp)
    9d80:	10800303 	ldbu	r2,12(r2)
    9d84:	10803fcc 	andi	r2,r2,255
    9d88:	10000e26 	beq	r2,zero,9dc4 <pbuf_realloc+0xb8>
    9d8c:	e0bffe17 	ldw	r2,-8(fp)
    9d90:	10800303 	ldbu	r2,12(r2)
    9d94:	10803fcc 	andi	r2,r2,255
    9d98:	108000a0 	cmpeqi	r2,r2,2
    9d9c:	1000091e 	bne	r2,zero,9dc4 <pbuf_realloc+0xb8>
    9da0:	010000f4 	movhi	r4,3
    9da4:	213ac604 	addi	r4,r4,-5352
    9da8:	014000f4 	movhi	r5,3
    9dac:	297b2c04 	addi	r5,r5,-4944
    9db0:	01805844 	movi	r6,353
    9db4:	01c000f4 	movhi	r7,3
    9db8:	39fad704 	addi	r7,r7,-5284
    9dbc:	00170680 	call	17068 <printf>
    9dc0:	003fff06 	br	9dc0 <pbuf_realloc+0xb4>
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
    9dc4:	e0bffe17 	ldw	r2,-8(fp)
    9dc8:	1080020b 	ldhu	r2,8(r2)
    9dcc:	10bfffcc 	andi	r2,r2,65535
    9dd0:	e0ffff0b 	ldhu	r3,-4(fp)
    9dd4:	1880682e 	bgeu	r3,r2,9f78 <pbuf_realloc+0x26c>
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
    9dd8:	e0ffff0b 	ldhu	r3,-4(fp)
    9ddc:	e0bffe17 	ldw	r2,-8(fp)
    9de0:	1080020b 	ldhu	r2,8(r2)
    9de4:	10bfffcc 	andi	r2,r2,65535
    9de8:	1885c83a 	sub	r2,r3,r2
    9dec:	e0bffd15 	stw	r2,-12(fp)

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
    9df0:	e0bfff0b 	ldhu	r2,-4(fp)
    9df4:	e0bffc0d 	sth	r2,-16(fp)
  q = p;
    9df8:	e0bffe17 	ldw	r2,-8(fp)
    9dfc:	e0bffb15 	stw	r2,-20(fp)
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
    9e00:	00002606 	br	9e9c <pbuf_realloc+0x190>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
    9e04:	e0bffb17 	ldw	r2,-20(fp)
    9e08:	1080028b 	ldhu	r2,10(r2)
    9e0c:	e0fffc0b 	ldhu	r3,-16(fp)
    9e10:	1885c83a 	sub	r2,r3,r2
    9e14:	e0bffc0d 	sth	r2,-16(fp)
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
    9e18:	e0bffd17 	ldw	r2,-12(fp)
    9e1c:	00ffff94 	movui	r3,65534
    9e20:	1880090e 	bge	r3,r2,9e48 <pbuf_realloc+0x13c>
    9e24:	010000f4 	movhi	r4,3
    9e28:	213ac604 	addi	r4,r4,-5352
    9e2c:	014000f4 	movhi	r5,3
    9e30:	297b3304 	addi	r5,r5,-4916
    9e34:	01805d44 	movi	r6,373
    9e38:	01c000f4 	movhi	r7,3
    9e3c:	39fad704 	addi	r7,r7,-5284
    9e40:	00170680 	call	17068 <printf>
    9e44:	003fff06 	br	9e44 <pbuf_realloc+0x138>
    q->tot_len += (u16_t)grow;
    9e48:	e0bffb17 	ldw	r2,-20(fp)
    9e4c:	10c0020b 	ldhu	r3,8(r2)
    9e50:	e0bffd17 	ldw	r2,-12(fp)
    9e54:	1885883a 	add	r2,r3,r2
    9e58:	1007883a 	mov	r3,r2
    9e5c:	e0bffb17 	ldw	r2,-20(fp)
    9e60:	10c0020d 	sth	r3,8(r2)
    /* proceed to next pbuf in chain */
    q = q->next;
    9e64:	e0bffb17 	ldw	r2,-20(fp)
    9e68:	10800017 	ldw	r2,0(r2)
    9e6c:	e0bffb15 	stw	r2,-20(fp)
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
    9e70:	e0bffb17 	ldw	r2,-20(fp)
    9e74:	1000091e 	bne	r2,zero,9e9c <pbuf_realloc+0x190>
    9e78:	010000f4 	movhi	r4,3
    9e7c:	213ac604 	addi	r4,r4,-5352
    9e80:	014000f4 	movhi	r5,3
    9e84:	297b3804 	addi	r5,r5,-4896
    9e88:	01805e44 	movi	r6,377
    9e8c:	01c000f4 	movhi	r7,3
    9e90:	39fad704 	addi	r7,r7,-5284
    9e94:	00170680 	call	17068 <printf>
    9e98:	003fff06 	br	9e98 <pbuf_realloc+0x18c>

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
    9e9c:	e0bffb17 	ldw	r2,-20(fp)
    9ea0:	1080028b 	ldhu	r2,10(r2)
    9ea4:	10ffffcc 	andi	r3,r2,65535
    9ea8:	e0bffc0b 	ldhu	r2,-16(fp)
    9eac:	18bfd536 	bltu	r3,r2,9e04 <pbuf_realloc+0xf8>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
    9eb0:	e0bffb17 	ldw	r2,-20(fp)
    9eb4:	10800303 	ldbu	r2,12(r2)
    9eb8:	10803fcc 	andi	r2,r2,255
    9ebc:	10001d1e 	bne	r2,zero,9f34 <pbuf_realloc+0x228>
    9ec0:	e0bffb17 	ldw	r2,-20(fp)
    9ec4:	1080028b 	ldhu	r2,10(r2)
    9ec8:	10ffffcc 	andi	r3,r2,65535
    9ecc:	e0bffc0b 	ldhu	r2,-16(fp)
    9ed0:	18801826 	beq	r3,r2,9f34 <pbuf_realloc+0x228>
    /* reallocate and adjust the length of the pbuf that will be split */
    q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
    9ed4:	e0bffb17 	ldw	r2,-20(fp)
    9ed8:	10800117 	ldw	r2,4(r2)
    9edc:	1007883a 	mov	r3,r2
    9ee0:	e0bffb17 	ldw	r2,-20(fp)
    9ee4:	1885c83a 	sub	r2,r3,r2
    9ee8:	1007883a 	mov	r3,r2
    9eec:	e0bffc0b 	ldhu	r2,-16(fp)
    9ef0:	1885883a 	add	r2,r3,r2
    9ef4:	10bfffcc 	andi	r2,r2,65535
    9ef8:	e13ffb17 	ldw	r4,-20(fp)
    9efc:	100b883a 	mov	r5,r2
    9f00:	00085c80 	call	85c8 <mem_realloc>
    9f04:	e0bffb15 	stw	r2,-20(fp)
    LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
    9f08:	e0bffb17 	ldw	r2,-20(fp)
    9f0c:	1000091e 	bne	r2,zero,9f34 <pbuf_realloc+0x228>
    9f10:	010000f4 	movhi	r4,3
    9f14:	213ac604 	addi	r4,r4,-5352
    9f18:	014000f4 	movhi	r5,3
    9f1c:	297b3e04 	addi	r5,r5,-4872
    9f20:	018060c4 	movi	r6,387
    9f24:	01c000f4 	movhi	r7,3
    9f28:	39fad704 	addi	r7,r7,-5284
    9f2c:	00170680 	call	17068 <printf>
    9f30:	003fff06 	br	9f30 <pbuf_realloc+0x224>
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
    9f34:	e0bffb17 	ldw	r2,-20(fp)
    9f38:	e0fffc0b 	ldhu	r3,-16(fp)
    9f3c:	10c0028d 	sth	r3,10(r2)
  q->tot_len = q->len;
    9f40:	e0bffb17 	ldw	r2,-20(fp)
    9f44:	10c0028b 	ldhu	r3,10(r2)
    9f48:	e0bffb17 	ldw	r2,-20(fp)
    9f4c:	10c0020d 	sth	r3,8(r2)

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
    9f50:	e0bffb17 	ldw	r2,-20(fp)
    9f54:	10800017 	ldw	r2,0(r2)
    9f58:	10000426 	beq	r2,zero,9f6c <pbuf_realloc+0x260>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
    9f5c:	e0bffb17 	ldw	r2,-20(fp)
    9f60:	10800017 	ldw	r2,0(r2)
    9f64:	1009883a 	mov	r4,r2
    9f68:	000a1880 	call	a188 <pbuf_free>
  }
  /* q is last packet in chain */
  q->next = NULL;
    9f6c:	e0bffb17 	ldw	r2,-20(fp)
    9f70:	10000015 	stw	zero,0(r2)
    9f74:	00000106 	br	9f7c <pbuf_realloc+0x270>
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
    /* enlarging not yet supported */
    return;
    9f78:	0001883a 	nop
    pbuf_free(q->next);
  }
  /* q is last packet in chain */
  q->next = NULL;

}
    9f7c:	e037883a 	mov	sp,fp
    9f80:	dfc00117 	ldw	ra,4(sp)
    9f84:	df000017 	ldw	fp,0(sp)
    9f88:	dec00204 	addi	sp,sp,8
    9f8c:	f800283a 	ret

00009f90 <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
    9f90:	defffa04 	addi	sp,sp,-24
    9f94:	dfc00515 	stw	ra,20(sp)
    9f98:	df000415 	stw	fp,16(sp)
    9f9c:	df000404 	addi	fp,sp,16
    9fa0:	e13ffe15 	stw	r4,-8(fp)
    9fa4:	2805883a 	mov	r2,r5
    9fa8:	e0bfff0d 	sth	r2,-4(fp)
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
    9fac:	e0bffe17 	ldw	r2,-8(fp)
    9fb0:	1000091e 	bne	r2,zero,9fd8 <pbuf_header+0x48>
    9fb4:	010000f4 	movhi	r4,3
    9fb8:	213ac604 	addi	r4,r4,-5352
    9fbc:	014000f4 	movhi	r5,3
    9fc0:	297b4504 	addi	r5,r5,-4844
    9fc4:	01806b84 	movi	r6,430
    9fc8:	01c000f4 	movhi	r7,3
    9fcc:	39fad704 	addi	r7,r7,-5284
    9fd0:	00170680 	call	17068 <printf>
    9fd4:	003fff06 	br	9fd4 <pbuf_header+0x44>
  if ((header_size_increment == 0) || (p == NULL))
    9fd8:	e0bfff0f 	ldh	r2,-4(fp)
    9fdc:	10000226 	beq	r2,zero,9fe8 <pbuf_header+0x58>
    9fe0:	e0bffe17 	ldw	r2,-8(fp)
    9fe4:	1000021e 	bne	r2,zero,9ff0 <pbuf_header+0x60>
    return 0;
    9fe8:	0005883a 	mov	r2,zero
    9fec:	00006106 	br	a174 <pbuf_header+0x1e4>
 
  if (header_size_increment < 0){
    9ff0:	e0bfff0f 	ldh	r2,-4(fp)
    9ff4:	1000110e 	bge	r2,zero,a03c <pbuf_header+0xac>
    increment_magnitude = -header_size_increment;
    9ff8:	e0bfff0b 	ldhu	r2,-4(fp)
    9ffc:	0085c83a 	sub	r2,zero,r2
    a000:	e0bffc0d 	sth	r2,-16(fp)
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
    a004:	e0bffe17 	ldw	r2,-8(fp)
    a008:	1080028b 	ldhu	r2,10(r2)
    a00c:	10ffffcc 	andi	r3,r2,65535
    a010:	e0bffc0b 	ldhu	r2,-16(fp)
    a014:	18800b2e 	bgeu	r3,r2,a044 <pbuf_header+0xb4>
    a018:	010000f4 	movhi	r4,3
    a01c:	213ac604 	addi	r4,r4,-5352
    a020:	014000f4 	movhi	r5,3
    a024:	297b4804 	addi	r5,r5,-4832
    a028:	01806d44 	movi	r6,437
    a02c:	01c000f4 	movhi	r7,3
    a030:	39fad704 	addi	r7,r7,-5284
    a034:	00170680 	call	17068 <printf>
    a038:	003fff06 	br	a038 <pbuf_header+0xa8>
  } else {
    increment_magnitude = header_size_increment;
    a03c:	e0bfff0b 	ldhu	r2,-4(fp)
    a040:	e0bffc0d 	sth	r2,-16(fp)
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
    a044:	e0bffe17 	ldw	r2,-8(fp)
    a048:	10800303 	ldbu	r2,12(r2)
    a04c:	10803fcc 	andi	r2,r2,255
    a050:	e0bffc8d 	sth	r2,-14(fp)
  /* remember current payload pointer */
  payload = p->payload;
    a054:	e0bffe17 	ldw	r2,-8(fp)
    a058:	10800117 	ldw	r2,4(r2)
    a05c:	e0bffd15 	stw	r2,-12(fp)

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
    a060:	e0bffc8b 	ldhu	r2,-14(fp)
    a064:	10000326 	beq	r2,zero,a074 <pbuf_header+0xe4>
    a068:	e0bffc8b 	ldhu	r2,-14(fp)
    a06c:	108000d8 	cmpnei	r2,r2,3
    a070:	1000111e 	bne	r2,zero,a0b8 <pbuf_header+0x128>
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
    a074:	e0bffe17 	ldw	r2,-8(fp)
    a078:	10c00117 	ldw	r3,4(r2)
    a07c:	e0bfff0f 	ldh	r2,-4(fp)
    a080:	0085c83a 	sub	r2,zero,r2
    a084:	1887883a 	add	r3,r3,r2
    a088:	e0bffe17 	ldw	r2,-8(fp)
    a08c:	10c00115 	stw	r3,4(r2)
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
    a090:	e0bffe17 	ldw	r2,-8(fp)
    a094:	10c00117 	ldw	r3,4(r2)
    a098:	e0bffe17 	ldw	r2,-8(fp)
    a09c:	10800404 	addi	r2,r2,16
    a0a0:	1880252e 	bgeu	r3,r2,a138 <pbuf_header+0x1a8>
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
        ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
        (void *)p->payload, (void *)(p + 1)));
      /* restore old payload pointer */
      p->payload = payload;
    a0a4:	e0bffe17 	ldw	r2,-8(fp)
    a0a8:	e0fffd17 	ldw	r3,-12(fp)
    a0ac:	10c00115 	stw	r3,4(r2)
      /* bail out unsuccesfully */
      return 1;
    a0b0:	00800044 	movi	r2,1
    a0b4:	00002f06 	br	a174 <pbuf_header+0x1e4>
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
    a0b8:	e0bffc8b 	ldhu	r2,-14(fp)
    a0bc:	108000a0 	cmpeqi	r2,r2,2
    a0c0:	1000031e 	bne	r2,zero,a0d0 <pbuf_header+0x140>
    a0c4:	e0bffc8b 	ldhu	r2,-14(fp)
    a0c8:	10800058 	cmpnei	r2,r2,1
    a0cc:	1000111e 	bne	r2,zero,a114 <pbuf_header+0x184>
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
    a0d0:	e0bfff0f 	ldh	r2,-4(fp)
    a0d4:	10000d0e 	bge	r2,zero,a10c <pbuf_header+0x17c>
    a0d8:	e0bffe17 	ldw	r2,-8(fp)
    a0dc:	1080028b 	ldhu	r2,10(r2)
    a0e0:	10ffffcc 	andi	r3,r2,65535
    a0e4:	e0bffc0b 	ldhu	r2,-16(fp)
    a0e8:	18800836 	bltu	r3,r2,a10c <pbuf_header+0x17c>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    a0ec:	e0bffe17 	ldw	r2,-8(fp)
    a0f0:	10c00117 	ldw	r3,4(r2)
    a0f4:	e0bfff0f 	ldh	r2,-4(fp)
    a0f8:	0085c83a 	sub	r2,zero,r2
    a0fc:	1887883a 	add	r3,r3,r2
    a100:	e0bffe17 	ldw	r2,-8(fp)
    a104:	10c00115 	stw	r3,4(r2)
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
    a108:	00000b06 	br	a138 <pbuf_header+0x1a8>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
    a10c:	00800044 	movi	r2,1
    a110:	00001806 	br	a174 <pbuf_header+0x1e4>
    }
  }
  else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    a114:	010000f4 	movhi	r4,3
    a118:	213ac604 	addi	r4,r4,-5352
    a11c:	014000f4 	movhi	r5,3
    a120:	297b5004 	addi	r5,r5,-4800
    a124:	01807904 	movi	r6,484
    a128:	01c000f4 	movhi	r7,3
    a12c:	39fad704 	addi	r7,r7,-5284
    a130:	00170680 	call	17068 <printf>
    a134:	003fff06 	br	a134 <pbuf_header+0x1a4>
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
    a138:	e0bffe17 	ldw	r2,-8(fp)
    a13c:	10c0028b 	ldhu	r3,10(r2)
    a140:	e0bfff0b 	ldhu	r2,-4(fp)
    a144:	1885883a 	add	r2,r3,r2
    a148:	1007883a 	mov	r3,r2
    a14c:	e0bffe17 	ldw	r2,-8(fp)
    a150:	10c0028d 	sth	r3,10(r2)
  p->tot_len += header_size_increment;
    a154:	e0bffe17 	ldw	r2,-8(fp)
    a158:	10c0020b 	ldhu	r3,8(r2)
    a15c:	e0bfff0b 	ldhu	r2,-4(fp)
    a160:	1885883a 	add	r2,r3,r2
    a164:	1007883a 	mov	r3,r2
    a168:	e0bffe17 	ldw	r2,-8(fp)
    a16c:	10c0020d 	sth	r3,8(r2)

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
    a170:	0005883a 	mov	r2,zero
}
    a174:	e037883a 	mov	sp,fp
    a178:	dfc00117 	ldw	ra,4(sp)
    a17c:	df000017 	ldw	fp,0(sp)
    a180:	dec00204 	addi	sp,sp,8
    a184:	f800283a 	ret

0000a188 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
    a188:	defffa04 	addi	sp,sp,-24
    a18c:	dfc00515 	stw	ra,20(sp)
    a190:	df000415 	stw	fp,16(sp)
    a194:	df000404 	addi	fp,sp,16
    a198:	e13fff15 	stw	r4,-4(fp)
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
    a19c:	e0bfff17 	ldw	r2,-4(fp)
    a1a0:	10000d1e 	bne	r2,zero,a1d8 <pbuf_free+0x50>
    LWIP_ASSERT("p != NULL", p != NULL);
    a1a4:	e0bfff17 	ldw	r2,-4(fp)
    a1a8:	1000091e 	bne	r2,zero,a1d0 <pbuf_free+0x48>
    a1ac:	010000f4 	movhi	r4,3
    a1b0:	213ac604 	addi	r4,r4,-5352
    a1b4:	014000f4 	movhi	r5,3
    a1b8:	297b4504 	addi	r5,r5,-4844
    a1bc:	01808684 	movi	r6,538
    a1c0:	01c000f4 	movhi	r7,3
    a1c4:	39fad704 	addi	r7,r7,-5284
    a1c8:	00170680 	call	17068 <printf>
    a1cc:	003fff06 	br	a1cc <pbuf_free+0x44>
    /* if assertions are disabled, proceed with debug output */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
      ("pbuf_free(p == NULL) was called.\n"));
    return 0;
    a1d0:	0005883a 	mov	r2,zero
    a1d4:	00005a06 	br	a340 <pbuf_free+0x1b8>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
    a1d8:	e0bfff17 	ldw	r2,-4(fp)
    a1dc:	10800303 	ldbu	r2,12(r2)
    a1e0:	10803fcc 	andi	r2,r2,255
    a1e4:	10001826 	beq	r2,zero,a248 <pbuf_free+0xc0>
    a1e8:	e0bfff17 	ldw	r2,-4(fp)
    a1ec:	10800303 	ldbu	r2,12(r2)
    a1f0:	10803fcc 	andi	r2,r2,255
    a1f4:	10800060 	cmpeqi	r2,r2,1
    a1f8:	1000131e 	bne	r2,zero,a248 <pbuf_free+0xc0>
    a1fc:	e0bfff17 	ldw	r2,-4(fp)
    a200:	10800303 	ldbu	r2,12(r2)
    a204:	10803fcc 	andi	r2,r2,255
    a208:	108000a0 	cmpeqi	r2,r2,2
    a20c:	10000e1e 	bne	r2,zero,a248 <pbuf_free+0xc0>
    a210:	e0bfff17 	ldw	r2,-4(fp)
    a214:	10800303 	ldbu	r2,12(r2)
    a218:	10803fcc 	andi	r2,r2,255
    a21c:	108000e0 	cmpeqi	r2,r2,3
    a220:	1000091e 	bne	r2,zero,a248 <pbuf_free+0xc0>
    a224:	010000f4 	movhi	r4,3
    a228:	213ac604 	addi	r4,r4,-5352
    a22c:	014000f4 	movhi	r5,3
    a230:	297b5404 	addi	r5,r5,-4784
    a234:	01808984 	movi	r6,550
    a238:	01c000f4 	movhi	r7,3
    a23c:	39fad704 	addi	r7,r7,-5284
    a240:	00170680 	call	17068 <printf>
    a244:	003fff06 	br	a244 <pbuf_free+0xbc>
    p->type == PBUF_RAM || p->type == PBUF_ROM ||
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
    a248:	e03ffc05 	stb	zero,-16(fp)
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
    a24c:	00003906 	br	a334 <pbuf_free+0x1ac>
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
    a250:	e0bfff17 	ldw	r2,-4(fp)
    a254:	1080038b 	ldhu	r2,14(r2)
    a258:	10bfffcc 	andi	r2,r2,65535
    a25c:	1000091e 	bne	r2,zero,a284 <pbuf_free+0xfc>
    a260:	010000f4 	movhi	r4,3
    a264:	213ac604 	addi	r4,r4,-5352
    a268:	014000f4 	movhi	r5,3
    a26c:	297b5a04 	addi	r5,r5,-4760
    a270:	01808cc4 	movi	r6,563
    a274:	01c000f4 	movhi	r7,3
    a278:	39fad704 	addi	r7,r7,-5284
    a27c:	00170680 	call	17068 <printf>
    a280:	003fff06 	br	a280 <pbuf_free+0xf8>
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
    a284:	e0bfff17 	ldw	r2,-4(fp)
    a288:	1080038b 	ldhu	r2,14(r2)
    a28c:	10bfffc4 	addi	r2,r2,-1
    a290:	1007883a 	mov	r3,r2
    a294:	e0bfff17 	ldw	r2,-4(fp)
    a298:	10c0038d 	sth	r3,14(r2)
    a29c:	e0bfff17 	ldw	r2,-4(fp)
    a2a0:	1080038b 	ldhu	r2,14(r2)
    a2a4:	e0bffc8d 	sth	r2,-14(fp)
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
    a2a8:	e0bffc8b 	ldhu	r2,-14(fp)
    a2ac:	1000201e 	bne	r2,zero,a330 <pbuf_free+0x1a8>
      /* remember next pbuf in chain for next iteration */
      q = p->next;
    a2b0:	e0bfff17 	ldw	r2,-4(fp)
    a2b4:	10800017 	ldw	r2,0(r2)
    a2b8:	e0bffd15 	stw	r2,-12(fp)
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
    a2bc:	e0bfff17 	ldw	r2,-4(fp)
    a2c0:	10800303 	ldbu	r2,12(r2)
    a2c4:	10803fcc 	andi	r2,r2,255
    a2c8:	e0bffe0d 	sth	r2,-8(fp)
      /* is this a pbuf from the pool? */
      if (type == PBUF_POOL) {
    a2cc:	e0bffe0b 	ldhu	r2,-8(fp)
    a2d0:	108000d8 	cmpnei	r2,r2,3
    a2d4:	1000041e 	bne	r2,zero,a2e8 <pbuf_free+0x160>
        memp_free(MEMP_PBUF_POOL, p);
    a2d8:	01000204 	movi	r4,8
    a2dc:	e17fff17 	ldw	r5,-4(fp)
    a2e0:	00090e80 	call	90e8 <memp_free>
    a2e4:	00000c06 	br	a318 <pbuf_free+0x190>
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
    a2e8:	e0bffe0b 	ldhu	r2,-8(fp)
    a2ec:	10800060 	cmpeqi	r2,r2,1
    a2f0:	1000031e 	bne	r2,zero,a300 <pbuf_free+0x178>
    a2f4:	e0bffe0b 	ldhu	r2,-8(fp)
    a2f8:	10800098 	cmpnei	r2,r2,2
    a2fc:	1000041e 	bne	r2,zero,a310 <pbuf_free+0x188>
        memp_free(MEMP_PBUF, p);
    a300:	010001c4 	movi	r4,7
    a304:	e17fff17 	ldw	r5,-4(fp)
    a308:	00090e80 	call	90e8 <memp_free>
    a30c:	00000206 	br	a318 <pbuf_free+0x190>
      /* type == PBUF_RAM */
      } else {
        mem_free(p);
    a310:	e13fff17 	ldw	r4,-4(fp)
    a314:	00084480 	call	8448 <mem_free>
      }
      count++;
    a318:	e0bffc03 	ldbu	r2,-16(fp)
    a31c:	10800044 	addi	r2,r2,1
    a320:	e0bffc05 	stb	r2,-16(fp)
      /* proceed to next pbuf */
      p = q;
    a324:	e0bffd17 	ldw	r2,-12(fp)
    a328:	e0bfff15 	stw	r2,-4(fp)
    a32c:	00000106 	br	a334 <pbuf_free+0x1ac>
    /* p->ref > 0, this pbuf is still referenced to */
    /* (and so the remaining pbufs in chain as well) */
    } else {
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: %p has ref %"U16_F", ending here.\n", (void *)p, ref));
      /* stop walking through the chain */
      p = NULL;
    a330:	e03fff15 	stw	zero,-4(fp)
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
    a334:	e0bfff17 	ldw	r2,-4(fp)
    a338:	103fc51e 	bne	r2,zero,a250 <pbuf_free+0xc8>
      p = NULL;
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
    a33c:	e0bffc03 	ldbu	r2,-16(fp)
}
    a340:	e037883a 	mov	sp,fp
    a344:	dfc00117 	ldw	ra,4(sp)
    a348:	df000017 	ldw	fp,0(sp)
    a34c:	dec00204 	addi	sp,sp,8
    a350:	f800283a 	ret

0000a354 <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
    a354:	defffd04 	addi	sp,sp,-12
    a358:	df000215 	stw	fp,8(sp)
    a35c:	df000204 	addi	fp,sp,8
    a360:	e13fff15 	stw	r4,-4(fp)
  u8_t len;

  len = 0;
    a364:	e03ffe05 	stb	zero,-8(fp)
  while (p != NULL) {
    a368:	00000606 	br	a384 <pbuf_clen+0x30>
    ++len;
    a36c:	e0bffe03 	ldbu	r2,-8(fp)
    a370:	10800044 	addi	r2,r2,1
    a374:	e0bffe05 	stb	r2,-8(fp)
    p = p->next;
    a378:	e0bfff17 	ldw	r2,-4(fp)
    a37c:	10800017 	ldw	r2,0(r2)
    a380:	e0bfff15 	stw	r2,-4(fp)
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
    a384:	e0bfff17 	ldw	r2,-4(fp)
    a388:	103ff81e 	bne	r2,zero,a36c <pbuf_clen+0x18>
    ++len;
    p = p->next;
  }
  return len;
    a38c:	e0bffe03 	ldbu	r2,-8(fp)
}
    a390:	e037883a 	mov	sp,fp
    a394:	df000017 	ldw	fp,0(sp)
    a398:	dec00104 	addi	sp,sp,4
    a39c:	f800283a 	ret

0000a3a0 <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
    a3a0:	defffe04 	addi	sp,sp,-8
    a3a4:	df000115 	stw	fp,4(sp)
    a3a8:	df000104 	addi	fp,sp,4
    a3ac:	e13fff15 	stw	r4,-4(fp)
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
    a3b0:	e0bfff17 	ldw	r2,-4(fp)
    a3b4:	10000626 	beq	r2,zero,a3d0 <pbuf_ref+0x30>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
    a3b8:	e0bfff17 	ldw	r2,-4(fp)
    a3bc:	1080038b 	ldhu	r2,14(r2)
    a3c0:	10800044 	addi	r2,r2,1
    a3c4:	1007883a 	mov	r3,r2
    a3c8:	e0bfff17 	ldw	r2,-4(fp)
    a3cc:	10c0038d 	sth	r3,14(r2)
    SYS_ARCH_UNPROTECT(old_level);
  }
}
    a3d0:	e037883a 	mov	sp,fp
    a3d4:	df000017 	ldw	fp,0(sp)
    a3d8:	dec00104 	addi	sp,sp,4
    a3dc:	f800283a 	ret

0000a3e0 <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
    a3e0:	defffb04 	addi	sp,sp,-20
    a3e4:	dfc00415 	stw	ra,16(sp)
    a3e8:	df000315 	stw	fp,12(sp)
    a3ec:	df000304 	addi	fp,sp,12
    a3f0:	e13ffe15 	stw	r4,-8(fp)
    a3f4:	e17fff15 	stw	r5,-4(fp)
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
    a3f8:	e0bffe17 	ldw	r2,-8(fp)
    a3fc:	10000226 	beq	r2,zero,a408 <pbuf_cat+0x28>
    a400:	e0bfff17 	ldw	r2,-4(fp)
    a404:	1000091e 	bne	r2,zero,a42c <pbuf_cat+0x4c>
    a408:	010000f4 	movhi	r4,3
    a40c:	213ac604 	addi	r4,r4,-5352
    a410:	014000f4 	movhi	r5,3
    a414:	297b6004 	addi	r5,r5,-4736
    a418:	0180a344 	movi	r6,653
    a41c:	01c000f4 	movhi	r7,3
    a420:	39fad704 	addi	r7,r7,-5284
    a424:	00170680 	call	17068 <printf>
    a428:	003fff06 	br	a428 <pbuf_cat+0x48>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
    a42c:	e0bffe17 	ldw	r2,-8(fp)
    a430:	e0bffd15 	stw	r2,-12(fp)
    a434:	00000b06 	br	a464 <pbuf_cat+0x84>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
    a438:	e0bffd17 	ldw	r2,-12(fp)
    a43c:	10c0020b 	ldhu	r3,8(r2)
    a440:	e0bfff17 	ldw	r2,-4(fp)
    a444:	1080020b 	ldhu	r2,8(r2)
    a448:	1885883a 	add	r2,r3,r2
    a44c:	1007883a 	mov	r3,r2
    a450:	e0bffd17 	ldw	r2,-12(fp)
    a454:	10c0020d 	sth	r3,8(r2)

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
    a458:	e0bffd17 	ldw	r2,-12(fp)
    a45c:	10800017 	ldw	r2,0(r2)
    a460:	e0bffd15 	stw	r2,-12(fp)
    a464:	e0bffd17 	ldw	r2,-12(fp)
    a468:	10800017 	ldw	r2,0(r2)
    a46c:	103ff21e 	bne	r2,zero,a438 <pbuf_cat+0x58>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
    a470:	e0bffd17 	ldw	r2,-12(fp)
    a474:	10c0020b 	ldhu	r3,8(r2)
    a478:	e0bffd17 	ldw	r2,-12(fp)
    a47c:	1080028b 	ldhu	r2,10(r2)
    a480:	18ffffcc 	andi	r3,r3,65535
    a484:	10bfffcc 	andi	r2,r2,65535
    a488:	18800926 	beq	r3,r2,a4b0 <pbuf_cat+0xd0>
    a48c:	010000f4 	movhi	r4,3
    a490:	213ac604 	addi	r4,r4,-5352
    a494:	014000f4 	movhi	r5,3
    a498:	297b6e04 	addi	r5,r5,-4680
    a49c:	0180a544 	movi	r6,661
    a4a0:	01c000f4 	movhi	r7,3
    a4a4:	39fad704 	addi	r7,r7,-5284
    a4a8:	00170680 	call	17068 <printf>
    a4ac:	003fff06 	br	a4ac <pbuf_cat+0xcc>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
    a4b0:	e0bffd17 	ldw	r2,-12(fp)
    a4b4:	10800017 	ldw	r2,0(r2)
    a4b8:	10000926 	beq	r2,zero,a4e0 <pbuf_cat+0x100>
    a4bc:	010000f4 	movhi	r4,3
    a4c0:	213ac604 	addi	r4,r4,-5352
    a4c4:	014000f4 	movhi	r5,3
    a4c8:	297b7a04 	addi	r5,r5,-4632
    a4cc:	0180a584 	movi	r6,662
    a4d0:	01c000f4 	movhi	r7,3
    a4d4:	39fad704 	addi	r7,r7,-5284
    a4d8:	00170680 	call	17068 <printf>
    a4dc:	003fff06 	br	a4dc <pbuf_cat+0xfc>
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
    a4e0:	e0bffd17 	ldw	r2,-12(fp)
    a4e4:	10c0020b 	ldhu	r3,8(r2)
    a4e8:	e0bfff17 	ldw	r2,-4(fp)
    a4ec:	1080020b 	ldhu	r2,8(r2)
    a4f0:	1885883a 	add	r2,r3,r2
    a4f4:	1007883a 	mov	r3,r2
    a4f8:	e0bffd17 	ldw	r2,-12(fp)
    a4fc:	10c0020d 	sth	r3,8(r2)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
    a500:	e0bffd17 	ldw	r2,-12(fp)
    a504:	e0ffff17 	ldw	r3,-4(fp)
    a508:	10c00015 	stw	r3,0(r2)
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
    a50c:	e037883a 	mov	sp,fp
    a510:	dfc00117 	ldw	ra,4(sp)
    a514:	df000017 	ldw	fp,0(sp)
    a518:	dec00204 	addi	sp,sp,8
    a51c:	f800283a 	ret

0000a520 <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
    a520:	defffc04 	addi	sp,sp,-16
    a524:	dfc00315 	stw	ra,12(sp)
    a528:	df000215 	stw	fp,8(sp)
    a52c:	df000204 	addi	fp,sp,8
    a530:	e13ffe15 	stw	r4,-8(fp)
    a534:	e17fff15 	stw	r5,-4(fp)
  pbuf_cat(h, t);
    a538:	e13ffe17 	ldw	r4,-8(fp)
    a53c:	e17fff17 	ldw	r5,-4(fp)
    a540:	000a3e00 	call	a3e0 <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
    a544:	e13fff17 	ldw	r4,-4(fp)
    a548:	000a3a00 	call	a3a0 <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
    a54c:	e037883a 	mov	sp,fp
    a550:	dfc00117 	ldw	ra,4(sp)
    a554:	df000017 	ldw	fp,0(sp)
    a558:	dec00204 	addi	sp,sp,8
    a55c:	f800283a 	ret

0000a560 <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
    a560:	defffb04 	addi	sp,sp,-20
    a564:	dfc00415 	stw	ra,16(sp)
    a568:	df000315 	stw	fp,12(sp)
    a56c:	df000304 	addi	fp,sp,12
    a570:	e13fff15 	stw	r4,-4(fp)
  struct pbuf *q;
  u8_t tail_gone = 1;
    a574:	00800044 	movi	r2,1
    a578:	e0bffd05 	stb	r2,-12(fp)
  /* tail */
  q = p->next;
    a57c:	e0bfff17 	ldw	r2,-4(fp)
    a580:	10800017 	ldw	r2,0(r2)
    a584:	e0bffe15 	stw	r2,-8(fp)
  /* pbuf has successor in chain? */
  if (q != NULL) {
    a588:	e0bffe17 	ldw	r2,-8(fp)
    a58c:	10002526 	beq	r2,zero,a624 <pbuf_dechain+0xc4>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
    a590:	e0bffe17 	ldw	r2,-8(fp)
    a594:	1080020b 	ldhu	r2,8(r2)
    a598:	10ffffcc 	andi	r3,r2,65535
    a59c:	e0bfff17 	ldw	r2,-4(fp)
    a5a0:	1080020b 	ldhu	r2,8(r2)
    a5a4:	113fffcc 	andi	r4,r2,65535
    a5a8:	e0bfff17 	ldw	r2,-4(fp)
    a5ac:	1080028b 	ldhu	r2,10(r2)
    a5b0:	10bfffcc 	andi	r2,r2,65535
    a5b4:	2085c83a 	sub	r2,r4,r2
    a5b8:	18800926 	beq	r3,r2,a5e0 <pbuf_dechain+0x80>
    a5bc:	010000f4 	movhi	r4,3
    a5c0:	213ac604 	addi	r4,r4,-5352
    a5c4:	014000f4 	movhi	r5,3
    a5c8:	297b7e04 	addi	r5,r5,-4616
    a5cc:	0180b2c4 	movi	r6,715
    a5d0:	01c000f4 	movhi	r7,3
    a5d4:	39fad704 	addi	r7,r7,-5284
    a5d8:	00170680 	call	17068 <printf>
    a5dc:	003fff06 	br	a5dc <pbuf_dechain+0x7c>
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
    a5e0:	e0bfff17 	ldw	r2,-4(fp)
    a5e4:	10c0020b 	ldhu	r3,8(r2)
    a5e8:	e0bfff17 	ldw	r2,-4(fp)
    a5ec:	1080028b 	ldhu	r2,10(r2)
    a5f0:	1885c83a 	sub	r2,r3,r2
    a5f4:	1007883a 	mov	r3,r2
    a5f8:	e0bffe17 	ldw	r2,-8(fp)
    a5fc:	10c0020d 	sth	r3,8(r2)
    /* decouple pbuf from remainder */
    p->next = NULL;
    a600:	e0bfff17 	ldw	r2,-4(fp)
    a604:	10000015 	stw	zero,0(r2)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
    a608:	e0bfff17 	ldw	r2,-4(fp)
    a60c:	10c0028b 	ldhu	r3,10(r2)
    a610:	e0bfff17 	ldw	r2,-4(fp)
    a614:	10c0020d 	sth	r3,8(r2)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
    a618:	e13ffe17 	ldw	r4,-8(fp)
    a61c:	000a1880 	call	a188 <pbuf_free>
    a620:	e0bffd05 	stb	r2,-12(fp)
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
    a624:	e0bfff17 	ldw	r2,-4(fp)
    a628:	10c0020b 	ldhu	r3,8(r2)
    a62c:	e0bfff17 	ldw	r2,-4(fp)
    a630:	1080028b 	ldhu	r2,10(r2)
    a634:	18ffffcc 	andi	r3,r3,65535
    a638:	10bfffcc 	andi	r2,r2,65535
    a63c:	18800926 	beq	r3,r2,a664 <pbuf_dechain+0x104>
    a640:	010000f4 	movhi	r4,3
    a644:	213ac604 	addi	r4,r4,-5352
    a648:	014000f4 	movhi	r5,3
    a64c:	297b8704 	addi	r5,r5,-4580
    a650:	0180b704 	movi	r6,732
    a654:	01c000f4 	movhi	r7,3
    a658:	39fad704 	addi	r7,r7,-5284
    a65c:	00170680 	call	17068 <printf>
    a660:	003fff06 	br	a660 <pbuf_dechain+0x100>
  return ((tail_gone > 0) ? NULL : q);
    a664:	e0bffd03 	ldbu	r2,-12(fp)
    a668:	1000021e 	bne	r2,zero,a674 <pbuf_dechain+0x114>
    a66c:	e0bffe17 	ldw	r2,-8(fp)
    a670:	00000106 	br	a678 <pbuf_dechain+0x118>
    a674:	0005883a 	mov	r2,zero
}
    a678:	e037883a 	mov	sp,fp
    a67c:	dfc00117 	ldw	ra,4(sp)
    a680:	df000017 	ldw	fp,0(sp)
    a684:	dec00204 	addi	sp,sp,8
    a688:	f800283a 	ret

0000a68c <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
    a68c:	defffa04 	addi	sp,sp,-24
    a690:	dfc00515 	stw	ra,20(sp)
    a694:	df000415 	stw	fp,16(sp)
    a698:	df000404 	addi	fp,sp,16
    a69c:	e13ffe15 	stw	r4,-8(fp)
    a6a0:	e17fff15 	stw	r5,-4(fp)
  u16_t offset_to=0, offset_from=0, len;
    a6a4:	e03ffc0d 	sth	zero,-16(fp)
    a6a8:	e03ffc8d 	sth	zero,-14(fp)

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
    a6ac:	e0bffe17 	ldw	r2,-8(fp)
    a6b0:	10000926 	beq	r2,zero,a6d8 <pbuf_copy+0x4c>
    a6b4:	e0bfff17 	ldw	r2,-4(fp)
    a6b8:	10000726 	beq	r2,zero,a6d8 <pbuf_copy+0x4c>
    a6bc:	e0bffe17 	ldw	r2,-8(fp)
    a6c0:	10c0020b 	ldhu	r3,8(r2)
    a6c4:	e0bfff17 	ldw	r2,-4(fp)
    a6c8:	1080020b 	ldhu	r2,8(r2)
    a6cc:	18ffffcc 	andi	r3,r3,65535
    a6d0:	10bfffcc 	andi	r2,r2,65535
    a6d4:	1880092e 	bgeu	r3,r2,a6fc <pbuf_copy+0x70>
    a6d8:	010000f4 	movhi	r4,3
    a6dc:	213ac604 	addi	r4,r4,-5352
    a6e0:	014000f4 	movhi	r5,3
    a6e4:	297b8d04 	addi	r5,r5,-4556
    a6e8:	0180bf04 	movi	r6,764
    a6ec:	01c000f4 	movhi	r7,3
    a6f0:	39fad704 	addi	r7,r7,-5284
    a6f4:	00170680 	call	17068 <printf>
    a6f8:	003fff06 	br	a6f8 <pbuf_copy+0x6c>
             (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);

  /* iterate through pbuf chain */
  do
  {
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
    a6fc:	e0bffe17 	ldw	r2,-8(fp)
    a700:	1000091e 	bne	r2,zero,a728 <pbuf_copy+0x9c>
    a704:	010000f4 	movhi	r4,3
    a708:	213ac604 	addi	r4,r4,-5352
    a70c:	014000f4 	movhi	r5,3
    a710:	297b9904 	addi	r5,r5,-4508
    a714:	0180c044 	movi	r6,769
    a718:	01c000f4 	movhi	r7,3
    a71c:	39fad704 	addi	r7,r7,-5284
    a720:	00170680 	call	17068 <printf>
    a724:	003fff06 	br	a724 <pbuf_copy+0x98>
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
    a728:	e0bffe17 	ldw	r2,-8(fp)
    a72c:	1080028b 	ldhu	r2,10(r2)
    a730:	10ffffcc 	andi	r3,r2,65535
    a734:	e0bffc0b 	ldhu	r2,-16(fp)
    a738:	1887c83a 	sub	r3,r3,r2
    a73c:	e0bfff17 	ldw	r2,-4(fp)
    a740:	1080028b 	ldhu	r2,10(r2)
    a744:	113fffcc 	andi	r4,r2,65535
    a748:	e0bffc8b 	ldhu	r2,-14(fp)
    a74c:	2085c83a 	sub	r2,r4,r2
    a750:	18800616 	blt	r3,r2,a76c <pbuf_copy+0xe0>
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
    a754:	e0bfff17 	ldw	r2,-4(fp)
    a758:	10c0028b 	ldhu	r3,10(r2)
    a75c:	e0bffc8b 	ldhu	r2,-14(fp)
    a760:	1885c83a 	sub	r2,r3,r2
    a764:	e0bffd0d 	sth	r2,-12(fp)
    a768:	00000506 	br	a780 <pbuf_copy+0xf4>
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    a76c:	e0bffe17 	ldw	r2,-8(fp)
    a770:	10c0028b 	ldhu	r3,10(r2)
    a774:	e0bffc0b 	ldhu	r2,-16(fp)
    a778:	1885c83a 	sub	r2,r3,r2
    a77c:	e0bffd0d 	sth	r2,-12(fp)
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
    a780:	e0bffe17 	ldw	r2,-8(fp)
    a784:	10c00117 	ldw	r3,4(r2)
    a788:	e0bffc0b 	ldhu	r2,-16(fp)
    a78c:	1889883a 	add	r4,r3,r2
    a790:	e0bfff17 	ldw	r2,-4(fp)
    a794:	10c00117 	ldw	r3,4(r2)
    a798:	e0bffc8b 	ldhu	r2,-14(fp)
    a79c:	1887883a 	add	r3,r3,r2
    a7a0:	e0bffd0b 	ldhu	r2,-12(fp)
    a7a4:	180b883a 	mov	r5,r3
    a7a8:	100d883a 	mov	r6,r2
    a7ac:	0016e680 	call	16e68 <memcpy>
    offset_to += len;
    a7b0:	e0fffc0b 	ldhu	r3,-16(fp)
    a7b4:	e0bffd0b 	ldhu	r2,-12(fp)
    a7b8:	1885883a 	add	r2,r3,r2
    a7bc:	e0bffc0d 	sth	r2,-16(fp)
    offset_from += len;
    a7c0:	e0fffc8b 	ldhu	r3,-14(fp)
    a7c4:	e0bffd0b 	ldhu	r2,-12(fp)
    a7c8:	1885883a 	add	r2,r3,r2
    a7cc:	e0bffc8d 	sth	r2,-14(fp)
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    a7d0:	e0bffe17 	ldw	r2,-8(fp)
    a7d4:	1080028b 	ldhu	r2,10(r2)
    a7d8:	10ffffcc 	andi	r3,r2,65535
    a7dc:	e0bffc0b 	ldhu	r2,-16(fp)
    a7e0:	1880092e 	bgeu	r3,r2,a808 <pbuf_copy+0x17c>
    a7e4:	010000f4 	movhi	r4,3
    a7e8:	213ac604 	addi	r4,r4,-5352
    a7ec:	014000f4 	movhi	r5,3
    a7f0:	297b9d04 	addi	r5,r5,-4492
    a7f4:	0180c344 	movi	r6,781
    a7f8:	01c000f4 	movhi	r7,3
    a7fc:	39fad704 	addi	r7,r7,-5284
    a800:	00170680 	call	17068 <printf>
    a804:	003fff06 	br	a804 <pbuf_copy+0x178>
    if (offset_to == p_to->len) {
    a808:	e0bffe17 	ldw	r2,-8(fp)
    a80c:	1080028b 	ldhu	r2,10(r2)
    a810:	10ffffcc 	andi	r3,r2,65535
    a814:	e0bffc0b 	ldhu	r2,-16(fp)
    a818:	1880041e 	bne	r3,r2,a82c <pbuf_copy+0x1a0>
      /* on to next p_to (if any) */
      offset_to = 0;
    a81c:	e03ffc0d 	sth	zero,-16(fp)
      p_to = p_to->next;
    a820:	e0bffe17 	ldw	r2,-8(fp)
    a824:	10800017 	ldw	r2,0(r2)
    a828:	e0bffe15 	stw	r2,-8(fp)
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
    a82c:	e0bfff17 	ldw	r2,-4(fp)
    a830:	1080028b 	ldhu	r2,10(r2)
    a834:	10ffffcc 	andi	r3,r2,65535
    a838:	e0bffc8b 	ldhu	r2,-14(fp)
    a83c:	1880092e 	bgeu	r3,r2,a864 <pbuf_copy+0x1d8>
    a840:	010000f4 	movhi	r4,3
    a844:	213ac604 	addi	r4,r4,-5352
    a848:	014000f4 	movhi	r5,3
    a84c:	297ba304 	addi	r5,r5,-4468
    a850:	0180c4c4 	movi	r6,787
    a854:	01c000f4 	movhi	r7,3
    a858:	39fad704 	addi	r7,r7,-5284
    a85c:	00170680 	call	17068 <printf>
    a860:	003fff06 	br	a860 <pbuf_copy+0x1d4>
    if (offset_from >= p_from->len) {
    a864:	e0bfff17 	ldw	r2,-4(fp)
    a868:	1080028b 	ldhu	r2,10(r2)
    a86c:	10bfffcc 	andi	r2,r2,65535
    a870:	e0fffc8b 	ldhu	r3,-14(fp)
    a874:	18800436 	bltu	r3,r2,a888 <pbuf_copy+0x1fc>
      /* on to next p_from (if any) */
      offset_from = 0;
    a878:	e03ffc8d 	sth	zero,-14(fp)
      p_from = p_from->next;
    a87c:	e0bfff17 	ldw	r2,-4(fp)
    a880:	10800017 	ldw	r2,0(r2)
    a884:	e0bfff15 	stw	r2,-4(fp)
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
    a888:	e0bfff17 	ldw	r2,-4(fp)
    a88c:	10001326 	beq	r2,zero,a8dc <pbuf_copy+0x250>
    a890:	e0bfff17 	ldw	r2,-4(fp)
    a894:	10c0028b 	ldhu	r3,10(r2)
    a898:	e0bfff17 	ldw	r2,-4(fp)
    a89c:	1080020b 	ldhu	r2,8(r2)
    a8a0:	18ffffcc 	andi	r3,r3,65535
    a8a4:	10bfffcc 	andi	r2,r2,65535
    a8a8:	18800c1e 	bne	r3,r2,a8dc <pbuf_copy+0x250>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
    a8ac:	e0bfff17 	ldw	r2,-4(fp)
    a8b0:	10800017 	ldw	r2,0(r2)
    a8b4:	10000926 	beq	r2,zero,a8dc <pbuf_copy+0x250>
    a8b8:	010000f4 	movhi	r4,3
    a8bc:	213ac604 	addi	r4,r4,-5352
    a8c0:	014000f4 	movhi	r5,3
    a8c4:	297baa04 	addi	r5,r5,-4440
    a8c8:	0180c744 	movi	r6,797
    a8cc:	01c000f4 	movhi	r7,3
    a8d0:	39fad704 	addi	r7,r7,-5284
    a8d4:	00170680 	call	17068 <printf>
    a8d8:	003fff06 	br	a8d8 <pbuf_copy+0x24c>
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
    a8dc:	e0bffe17 	ldw	r2,-8(fp)
    a8e0:	10001326 	beq	r2,zero,a930 <pbuf_copy+0x2a4>
    a8e4:	e0bffe17 	ldw	r2,-8(fp)
    a8e8:	10c0028b 	ldhu	r3,10(r2)
    a8ec:	e0bffe17 	ldw	r2,-8(fp)
    a8f0:	1080020b 	ldhu	r2,8(r2)
    a8f4:	18ffffcc 	andi	r3,r3,65535
    a8f8:	10bfffcc 	andi	r2,r2,65535
    a8fc:	18800c1e 	bne	r3,r2,a930 <pbuf_copy+0x2a4>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
    a900:	e0bffe17 	ldw	r2,-8(fp)
    a904:	10800017 	ldw	r2,0(r2)
    a908:	10000926 	beq	r2,zero,a930 <pbuf_copy+0x2a4>
    a90c:	010000f4 	movhi	r4,3
    a910:	213ac604 	addi	r4,r4,-5352
    a914:	014000f4 	movhi	r5,3
    a918:	297baa04 	addi	r5,r5,-4440
    a91c:	0180c884 	movi	r6,802
    a920:	01c000f4 	movhi	r7,3
    a924:	39fad704 	addi	r7,r7,-5284
    a928:	00170680 	call	17068 <printf>
    a92c:	003fff06 	br	a92c <pbuf_copy+0x2a0>
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
    a930:	e0bfff17 	ldw	r2,-4(fp)
    a934:	103f711e 	bne	r2,zero,a6fc <pbuf_copy+0x70>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
    a938:	0005883a 	mov	r2,zero
}
    a93c:	e037883a 	mov	sp,fp
    a940:	dfc00117 	ldw	ra,4(sp)
    a944:	df000017 	ldw	fp,0(sp)
    a948:	dec00204 	addi	sp,sp,8
    a94c:	f800283a 	ret

0000a950 <pbuf_copy_partial>:
 * @param offset offset into the packet buffer from where to begin copying len bytes
 * @return the number of bytes copied, or 0 on failure
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
    a950:	defff704 	addi	sp,sp,-36
    a954:	dfc00815 	stw	ra,32(sp)
    a958:	df000715 	stw	fp,28(sp)
    a95c:	df000704 	addi	fp,sp,28
    a960:	e13ffc15 	stw	r4,-16(fp)
    a964:	e17ffd15 	stw	r5,-12(fp)
    a968:	3007883a 	mov	r3,r6
    a96c:	3805883a 	mov	r2,r7
    a970:	e0fffe0d 	sth	r3,-8(fp)
    a974:	e0bfff0d 	sth	r2,-4(fp)
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;
    a978:	e03ffb0d 	sth	zero,-20(fp)

  LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
    a97c:	e0bffc17 	ldw	r2,-16(fp)
    a980:	1000091e 	bne	r2,zero,a9a8 <pbuf_copy_partial+0x58>
    a984:	010000f4 	movhi	r4,3
    a988:	213ac604 	addi	r4,r4,-5352
    a98c:	014000f4 	movhi	r5,3
    a990:	297bb504 	addi	r5,r5,-4396
    a994:	0180cf04 	movi	r6,828
    a998:	01c000f4 	movhi	r7,3
    a99c:	39fad704 	addi	r7,r7,-5284
    a9a0:	00170680 	call	17068 <printf>
    a9a4:	003fff06 	br	a9a4 <pbuf_copy_partial+0x54>
  LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
    a9a8:	e0bffd17 	ldw	r2,-12(fp)
    a9ac:	1000091e 	bne	r2,zero,a9d4 <pbuf_copy_partial+0x84>
    a9b0:	010000f4 	movhi	r4,3
    a9b4:	213ac604 	addi	r4,r4,-5352
    a9b8:	014000f4 	movhi	r5,3
    a9bc:	297bbd04 	addi	r5,r5,-4364
    a9c0:	0180cf44 	movi	r6,829
    a9c4:	01c000f4 	movhi	r7,3
    a9c8:	39fad704 	addi	r7,r7,-5284
    a9cc:	00170680 	call	17068 <printf>
    a9d0:	003fff06 	br	a9d0 <pbuf_copy_partial+0x80>

  left = 0;
    a9d4:	e03ffa0d 	sth	zero,-24(fp)

  if((buf == NULL) || (dataptr == NULL)) {
    a9d8:	e0bffc17 	ldw	r2,-16(fp)
    a9dc:	10000226 	beq	r2,zero,a9e8 <pbuf_copy_partial+0x98>
    a9e0:	e0bffd17 	ldw	r2,-12(fp)
    a9e4:	1000021e 	bne	r2,zero,a9f0 <pbuf_copy_partial+0xa0>
    return 0;
    a9e8:	0005883a 	mov	r2,zero
    a9ec:	00003a06 	br	aad8 <pbuf_copy_partial+0x188>
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
    a9f0:	e0bffc17 	ldw	r2,-16(fp)
    a9f4:	e0bff915 	stw	r2,-28(fp)
    a9f8:	00003206 	br	aac4 <pbuf_copy_partial+0x174>
    if ((offset != 0) && (offset >= p->len)) {
    a9fc:	e0bfff0b 	ldhu	r2,-4(fp)
    aa00:	10000b26 	beq	r2,zero,aa30 <pbuf_copy_partial+0xe0>
    aa04:	e0bff917 	ldw	r2,-28(fp)
    aa08:	1080028b 	ldhu	r2,10(r2)
    aa0c:	10bfffcc 	andi	r2,r2,65535
    aa10:	e0ffff0b 	ldhu	r3,-4(fp)
    aa14:	18800636 	bltu	r3,r2,aa30 <pbuf_copy_partial+0xe0>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
    aa18:	e0bff917 	ldw	r2,-28(fp)
    aa1c:	1080028b 	ldhu	r2,10(r2)
    aa20:	e0ffff0b 	ldhu	r3,-4(fp)
    aa24:	1885c83a 	sub	r2,r3,r2
    aa28:	e0bfff0d 	sth	r2,-4(fp)
    aa2c:	00002206 	br	aab8 <pbuf_copy_partial+0x168>
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
    aa30:	e0bff917 	ldw	r2,-28(fp)
    aa34:	10c0028b 	ldhu	r3,10(r2)
    aa38:	e0bfff0b 	ldhu	r2,-4(fp)
    aa3c:	1885c83a 	sub	r2,r3,r2
    aa40:	e0bffa8d 	sth	r2,-22(fp)
      if (buf_copy_len > len)
    aa44:	e0bffa8b 	ldhu	r2,-22(fp)
    aa48:	e0fffe0b 	ldhu	r3,-8(fp)
    aa4c:	1880022e 	bgeu	r3,r2,aa58 <pbuf_copy_partial+0x108>
          buf_copy_len = len;
    aa50:	e0bffe0b 	ldhu	r2,-8(fp)
    aa54:	e0bffa8d 	sth	r2,-22(fp)
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
    aa58:	e0bffa0b 	ldhu	r2,-24(fp)
    aa5c:	e0fffd17 	ldw	r3,-12(fp)
    aa60:	1889883a 	add	r4,r3,r2
    aa64:	e0bff917 	ldw	r2,-28(fp)
    aa68:	10c00117 	ldw	r3,4(r2)
    aa6c:	e0bfff0b 	ldhu	r2,-4(fp)
    aa70:	1887883a 	add	r3,r3,r2
    aa74:	e0bffa8b 	ldhu	r2,-22(fp)
    aa78:	180b883a 	mov	r5,r3
    aa7c:	100d883a 	mov	r6,r2
    aa80:	0016e680 	call	16e68 <memcpy>
      copied_total += buf_copy_len;
    aa84:	e0fffb0b 	ldhu	r3,-20(fp)
    aa88:	e0bffa8b 	ldhu	r2,-22(fp)
    aa8c:	1885883a 	add	r2,r3,r2
    aa90:	e0bffb0d 	sth	r2,-20(fp)
      left += buf_copy_len;
    aa94:	e0fffa0b 	ldhu	r3,-24(fp)
    aa98:	e0bffa8b 	ldhu	r2,-22(fp)
    aa9c:	1885883a 	add	r2,r3,r2
    aaa0:	e0bffa0d 	sth	r2,-24(fp)
      len -= buf_copy_len;
    aaa4:	e0fffe0b 	ldhu	r3,-8(fp)
    aaa8:	e0bffa8b 	ldhu	r2,-22(fp)
    aaac:	1885c83a 	sub	r2,r3,r2
    aab0:	e0bffe0d 	sth	r2,-8(fp)
      offset = 0;
    aab4:	e03fff0d 	sth	zero,-4(fp)
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
    aab8:	e0bff917 	ldw	r2,-28(fp)
    aabc:	10800017 	ldw	r2,0(r2)
    aac0:	e0bff915 	stw	r2,-28(fp)
    aac4:	e0bffe0b 	ldhu	r2,-8(fp)
    aac8:	10000226 	beq	r2,zero,aad4 <pbuf_copy_partial+0x184>
    aacc:	e0bff917 	ldw	r2,-28(fp)
    aad0:	103fca1e 	bne	r2,zero,a9fc <pbuf_copy_partial+0xac>
      left += buf_copy_len;
      len -= buf_copy_len;
      offset = 0;
    }
  }
  return copied_total;
    aad4:	e0bffb0b 	ldhu	r2,-20(fp)
}
    aad8:	e037883a 	mov	sp,fp
    aadc:	dfc00117 	ldw	ra,4(sp)
    aae0:	df000017 	ldw	fp,0(sp)
    aae4:	dec00204 	addi	sp,sp,8
    aae8:	f800283a 	ret

0000aaec <pbuf_take>:
 *
 * @return ERR_OK if successful, ERR_MEM if the pbuf is not big enough
 */
err_t
pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len)
{
    aaec:	defff804 	addi	sp,sp,-32
    aaf0:	dfc00715 	stw	ra,28(sp)
    aaf4:	df000615 	stw	fp,24(sp)
    aaf8:	df000604 	addi	fp,sp,24
    aafc:	e13ffd15 	stw	r4,-12(fp)
    ab00:	e17ffe15 	stw	r5,-8(fp)
    ab04:	3005883a 	mov	r2,r6
    ab08:	e0bfff0d 	sth	r2,-4(fp)
  struct pbuf *p;
  u16_t buf_copy_len;
  u16_t total_copy_len = len;
    ab0c:	e0bfff0b 	ldhu	r2,-4(fp)
    ab10:	e0bffb8d 	sth	r2,-18(fp)
  u16_t copied_total = 0;
    ab14:	e03ffc0d 	sth	zero,-16(fp)

  LWIP_ERROR("pbuf_take: invalid buf", (buf != NULL), return 0;);
    ab18:	e0bffd17 	ldw	r2,-12(fp)
    ab1c:	1000091e 	bne	r2,zero,ab44 <pbuf_take+0x58>
    ab20:	010000f4 	movhi	r4,3
    ab24:	213ac604 	addi	r4,r4,-5352
    ab28:	014000f4 	movhi	r5,3
    ab2c:	297bc604 	addi	r5,r5,-4328
    ab30:	0180db04 	movi	r6,876
    ab34:	01c000f4 	movhi	r7,3
    ab38:	39fad704 	addi	r7,r7,-5284
    ab3c:	00170680 	call	17068 <printf>
    ab40:	003fff06 	br	ab40 <pbuf_take+0x54>
  LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return 0;);
    ab44:	e0bffe17 	ldw	r2,-8(fp)
    ab48:	1000091e 	bne	r2,zero,ab70 <pbuf_take+0x84>
    ab4c:	010000f4 	movhi	r4,3
    ab50:	213ac604 	addi	r4,r4,-5352
    ab54:	014000f4 	movhi	r5,3
    ab58:	297bcc04 	addi	r5,r5,-4304
    ab5c:	0180db44 	movi	r6,877
    ab60:	01c000f4 	movhi	r7,3
    ab64:	39fad704 	addi	r7,r7,-5284
    ab68:	00170680 	call	17068 <printf>
    ab6c:	003fff06 	br	ab6c <pbuf_take+0x80>

  if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
    ab70:	e0bffd17 	ldw	r2,-12(fp)
    ab74:	10000726 	beq	r2,zero,ab94 <pbuf_take+0xa8>
    ab78:	e0bffe17 	ldw	r2,-8(fp)
    ab7c:	10000526 	beq	r2,zero,ab94 <pbuf_take+0xa8>
    ab80:	e0bffd17 	ldw	r2,-12(fp)
    ab84:	1080020b 	ldhu	r2,8(r2)
    ab88:	10ffffcc 	andi	r3,r2,65535
    ab8c:	e0bfff0b 	ldhu	r2,-4(fp)
    ab90:	1880022e 	bgeu	r3,r2,ab9c <pbuf_take+0xb0>
    return ERR_ARG;
    ab94:	00bffd84 	movi	r2,-10
    ab98:	00003d06 	br	ac90 <pbuf_take+0x1a4>
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; total_copy_len != 0; p = p->next) {
    ab9c:	e0bffd17 	ldw	r2,-12(fp)
    aba0:	e0bffa15 	stw	r2,-24(fp)
    aba4:	00002906 	br	ac4c <pbuf_take+0x160>
    LWIP_ASSERT("pbuf_take: invalid pbuf", p != NULL);
    aba8:	e0bffa17 	ldw	r2,-24(fp)
    abac:	1000091e 	bne	r2,zero,abd4 <pbuf_take+0xe8>
    abb0:	010000f4 	movhi	r4,3
    abb4:	213ac604 	addi	r4,r4,-5352
    abb8:	014000f4 	movhi	r5,3
    abbc:	297bd304 	addi	r5,r5,-4276
    abc0:	0180dd44 	movi	r6,885
    abc4:	01c000f4 	movhi	r7,3
    abc8:	39fad704 	addi	r7,r7,-5284
    abcc:	00170680 	call	17068 <printf>
    abd0:	003fff06 	br	abd0 <pbuf_take+0xe4>
    buf_copy_len = total_copy_len;
    abd4:	e0bffb8b 	ldhu	r2,-18(fp)
    abd8:	e0bffb0d 	sth	r2,-20(fp)
    if (buf_copy_len > p->len) {
    abdc:	e0bffa17 	ldw	r2,-24(fp)
    abe0:	1080028b 	ldhu	r2,10(r2)
    abe4:	10ffffcc 	andi	r3,r2,65535
    abe8:	e0bffb0b 	ldhu	r2,-20(fp)
    abec:	1880032e 	bgeu	r3,r2,abfc <pbuf_take+0x110>
      /* this pbuf cannot hold all remaining data */
      buf_copy_len = p->len;
    abf0:	e0bffa17 	ldw	r2,-24(fp)
    abf4:	1080028b 	ldhu	r2,10(r2)
    abf8:	e0bffb0d 	sth	r2,-20(fp)
    }
    /* copy the necessary parts of the buffer */
    MEMCPY(p->payload, &((char*)dataptr)[copied_total], buf_copy_len);
    abfc:	e0bffa17 	ldw	r2,-24(fp)
    ac00:	11000117 	ldw	r4,4(r2)
    ac04:	e0bffc0b 	ldhu	r2,-16(fp)
    ac08:	e0fffe17 	ldw	r3,-8(fp)
    ac0c:	1887883a 	add	r3,r3,r2
    ac10:	e0bffb0b 	ldhu	r2,-20(fp)
    ac14:	180b883a 	mov	r5,r3
    ac18:	100d883a 	mov	r6,r2
    ac1c:	0016e680 	call	16e68 <memcpy>
    total_copy_len -= buf_copy_len;
    ac20:	e0fffb8b 	ldhu	r3,-18(fp)
    ac24:	e0bffb0b 	ldhu	r2,-20(fp)
    ac28:	1885c83a 	sub	r2,r3,r2
    ac2c:	e0bffb8d 	sth	r2,-18(fp)
    copied_total += buf_copy_len;
    ac30:	e0fffc0b 	ldhu	r3,-16(fp)
    ac34:	e0bffb0b 	ldhu	r2,-20(fp)
    ac38:	1885883a 	add	r2,r3,r2
    ac3c:	e0bffc0d 	sth	r2,-16(fp)
  if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
    return ERR_ARG;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; total_copy_len != 0; p = p->next) {
    ac40:	e0bffa17 	ldw	r2,-24(fp)
    ac44:	10800017 	ldw	r2,0(r2)
    ac48:	e0bffa15 	stw	r2,-24(fp)
    ac4c:	e0bffb8b 	ldhu	r2,-18(fp)
    ac50:	103fd51e 	bne	r2,zero,aba8 <pbuf_take+0xbc>
    /* copy the necessary parts of the buffer */
    MEMCPY(p->payload, &((char*)dataptr)[copied_total], buf_copy_len);
    total_copy_len -= buf_copy_len;
    copied_total += buf_copy_len;
  }
  LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
    ac54:	e0bffb8b 	ldhu	r2,-18(fp)
    ac58:	1000031e 	bne	r2,zero,ac68 <pbuf_take+0x17c>
    ac5c:	e0fffc0b 	ldhu	r3,-16(fp)
    ac60:	e0bfff0b 	ldhu	r2,-4(fp)
    ac64:	18800926 	beq	r3,r2,ac8c <pbuf_take+0x1a0>
    ac68:	010000f4 	movhi	r4,3
    ac6c:	213ac604 	addi	r4,r4,-5352
    ac70:	014000f4 	movhi	r5,3
    ac74:	297bd904 	addi	r5,r5,-4252
    ac78:	0180e004 	movi	r6,896
    ac7c:	01c000f4 	movhi	r7,3
    ac80:	39fad704 	addi	r7,r7,-5284
    ac84:	00170680 	call	17068 <printf>
    ac88:	003fff06 	br	ac88 <pbuf_take+0x19c>
  return ERR_OK;
    ac8c:	0005883a 	mov	r2,zero
}
    ac90:	e037883a 	mov	sp,fp
    ac94:	dfc00117 	ldw	ra,4(sp)
    ac98:	df000017 	ldw	fp,0(sp)
    ac9c:	dec00204 	addi	sp,sp,8
    aca0:	f800283a 	ret

0000aca4 <pbuf_coalesce>:
 * @return a new, single pbuf (p->next is NULL)
 *         or the old pbuf if allocation fails
 */
struct pbuf*
pbuf_coalesce(struct pbuf *p, pbuf_layer layer)
{
    aca4:	defffa04 	addi	sp,sp,-24
    aca8:	dfc00515 	stw	ra,20(sp)
    acac:	df000415 	stw	fp,16(sp)
    acb0:	df000404 	addi	fp,sp,16
    acb4:	e13ffe15 	stw	r4,-8(fp)
    acb8:	e17fff15 	stw	r5,-4(fp)
  struct pbuf *q;
  err_t err;
  if (p->next == NULL) {
    acbc:	e0bffe17 	ldw	r2,-8(fp)
    acc0:	10800017 	ldw	r2,0(r2)
    acc4:	1000021e 	bne	r2,zero,acd0 <pbuf_coalesce+0x2c>
    return p;
    acc8:	e0bffe17 	ldw	r2,-8(fp)
    accc:	00001e06 	br	ad48 <pbuf_coalesce+0xa4>
  }
  q = pbuf_alloc(layer, p->tot_len, PBUF_RAM);
    acd0:	e0bffe17 	ldw	r2,-8(fp)
    acd4:	1080020b 	ldhu	r2,8(r2)
    acd8:	10bfffcc 	andi	r2,r2,65535
    acdc:	e13fff17 	ldw	r4,-4(fp)
    ace0:	100b883a 	mov	r5,r2
    ace4:	000d883a 	mov	r6,zero
    ace8:	00097cc0 	call	97cc <pbuf_alloc>
    acec:	e0bffc15 	stw	r2,-16(fp)
  if (q == NULL) {
    acf0:	e0bffc17 	ldw	r2,-16(fp)
    acf4:	1000021e 	bne	r2,zero,ad00 <pbuf_coalesce+0x5c>
    /* @todo: what do we do now? */
    return p;
    acf8:	e0bffe17 	ldw	r2,-8(fp)
    acfc:	00001206 	br	ad48 <pbuf_coalesce+0xa4>
  }
  err = pbuf_copy(q, p);
    ad00:	e13ffc17 	ldw	r4,-16(fp)
    ad04:	e17ffe17 	ldw	r5,-8(fp)
    ad08:	000a68c0 	call	a68c <pbuf_copy>
    ad0c:	e0bffd05 	stb	r2,-12(fp)
  LWIP_ASSERT("pbuf_copy failed", err == ERR_OK);
    ad10:	e0bffd07 	ldb	r2,-12(fp)
    ad14:	10000926 	beq	r2,zero,ad3c <pbuf_coalesce+0x98>
    ad18:	010000f4 	movhi	r4,3
    ad1c:	213ac604 	addi	r4,r4,-5352
    ad20:	014000f4 	movhi	r5,3
    ad24:	297bdf04 	addi	r5,r5,-4228
    ad28:	0180e784 	movi	r6,926
    ad2c:	01c000f4 	movhi	r7,3
    ad30:	39fad704 	addi	r7,r7,-5284
    ad34:	00170680 	call	17068 <printf>
    ad38:	003fff06 	br	ad38 <pbuf_coalesce+0x94>
  pbuf_free(p);
    ad3c:	e13ffe17 	ldw	r4,-8(fp)
    ad40:	000a1880 	call	a188 <pbuf_free>
  return q;
    ad44:	e0bffc17 	ldw	r2,-16(fp)
}
    ad48:	e037883a 	mov	sp,fp
    ad4c:	dfc00117 	ldw	ra,4(sp)
    ad50:	df000017 	ldw	fp,0(sp)
    ad54:	dec00204 	addi	sp,sp,8
    ad58:	f800283a 	ret

0000ad5c <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
    ad5c:	defff704 	addi	sp,sp,-36
    ad60:	dfc00815 	stw	ra,32(sp)
    ad64:	df000715 	stw	fp,28(sp)
    ad68:	df000704 	addi	fp,sp,28
    ad6c:	e13ffe15 	stw	r4,-8(fp)
    ad70:	e17fff15 	stw	r5,-4(fp)
  struct raw_pcb *pcb, *prev;
  struct ip_hdr *iphdr;
  s16_t proto;
  u8_t eaten = 0;
    ad74:	e03ffb05 	stb	zero,-20(fp)

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
    ad78:	e0bffe17 	ldw	r2,-8(fp)
    ad7c:	10800117 	ldw	r2,4(r2)
    ad80:	e0bffc15 	stw	r2,-16(fp)
  proto = IPH_PROTO(iphdr);
    ad84:	e0bffc17 	ldw	r2,-16(fp)
    ad88:	1080020b 	ldhu	r2,8(r2)
    ad8c:	10bfffcc 	andi	r2,r2,65535
    ad90:	1004d23a 	srli	r2,r2,8
    ad94:	1007883a 	mov	r3,r2
    ad98:	e0bffc17 	ldw	r2,-16(fp)
    ad9c:	1080020b 	ldhu	r2,8(r2)
    ada0:	10bfffcc 	andi	r2,r2,65535
    ada4:	1004923a 	slli	r2,r2,8
    ada8:	1884b03a 	or	r2,r3,r2
    adac:	10803fcc 	andi	r2,r2,255
    adb0:	e0bffd0d 	sth	r2,-12(fp)

  prev = NULL;
    adb4:	e03ffa15 	stw	zero,-24(fp)
  pcb = raw_pcbs;
    adb8:	d0a8d417 	ldw	r2,-23728(gp)
    adbc:	e0bff915 	stw	r2,-28(fp)
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    adc0:	00002806 	br	ae64 <raw_input+0x108>
    if (pcb->protocol == proto) {
    adc4:	e0bff917 	ldw	r2,-28(fp)
    adc8:	10800403 	ldbu	r2,16(r2)
    adcc:	10c03fcc 	andi	r3,r2,255
    add0:	e0bffd0f 	ldh	r2,-12(fp)
    add4:	18801e1e 	bne	r3,r2,ae50 <raw_input+0xf4>
      /* broadcast filter? */
      if ((pcb->so_options & SOF_BROADCAST) || !ip_addr_isbroadcast(&(iphdr->dest), inp))
#endif /* IP_SOF_BROADCAST_RECV */
      {
        /* receive callback function available? */
        if (pcb->recv != NULL) {
    add8:	e0bff917 	ldw	r2,-28(fp)
    addc:	10800517 	ldw	r2,20(r2)
    ade0:	10001b26 	beq	r2,zero,ae50 <raw_input+0xf4>
          /* the receive callback function did not eat the packet? */
          if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0) {
    ade4:	e0bff917 	ldw	r2,-28(fp)
    ade8:	12000517 	ldw	r8,20(r2)
    adec:	e0bff917 	ldw	r2,-28(fp)
    adf0:	10c00617 	ldw	r3,24(r2)
    adf4:	e0bffc17 	ldw	r2,-16(fp)
    adf8:	10800304 	addi	r2,r2,12
    adfc:	1809883a 	mov	r4,r3
    ae00:	e17ff917 	ldw	r5,-28(fp)
    ae04:	e1bffe17 	ldw	r6,-8(fp)
    ae08:	100f883a 	mov	r7,r2
    ae0c:	403ee83a 	callr	r8
    ae10:	10803fcc 	andi	r2,r2,255
    ae14:	10000e26 	beq	r2,zero,ae50 <raw_input+0xf4>
            /* receive function ate the packet */
            p = NULL;
    ae18:	e03ffe15 	stw	zero,-8(fp)
            eaten = 1;
    ae1c:	00800044 	movi	r2,1
    ae20:	e0bffb05 	stb	r2,-20(fp)
            if (prev != NULL) {
    ae24:	e0bffa17 	ldw	r2,-24(fp)
    ae28:	10000926 	beq	r2,zero,ae50 <raw_input+0xf4>
            /* move the pcb to the front of raw_pcbs so that is
               found faster next time */
              prev->next = pcb->next;
    ae2c:	e0bff917 	ldw	r2,-28(fp)
    ae30:	10c00317 	ldw	r3,12(r2)
    ae34:	e0bffa17 	ldw	r2,-24(fp)
    ae38:	10c00315 	stw	r3,12(r2)
              pcb->next = raw_pcbs;
    ae3c:	d0e8d417 	ldw	r3,-23728(gp)
    ae40:	e0bff917 	ldw	r2,-28(fp)
    ae44:	10c00315 	stw	r3,12(r2)
              raw_pcbs = pcb;
    ae48:	e0bff917 	ldw	r2,-28(fp)
    ae4c:	d0a8d415 	stw	r2,-23728(gp)
        }
        /* no receive callback function was set for this raw PCB */
      }
      /* drop the packet */
    }
    prev = pcb;
    ae50:	e0bff917 	ldw	r2,-28(fp)
    ae54:	e0bffa15 	stw	r2,-24(fp)
    pcb = pcb->next;
    ae58:	e0bff917 	ldw	r2,-28(fp)
    ae5c:	10800317 	ldw	r2,12(r2)
    ae60:	e0bff915 	stw	r2,-28(fp)

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    ae64:	e0bffb03 	ldbu	r2,-20(fp)
    ae68:	1000021e 	bne	r2,zero,ae74 <raw_input+0x118>
    ae6c:	e0bff917 	ldw	r2,-28(fp)
    ae70:	103fd41e 	bne	r2,zero,adc4 <raw_input+0x68>
      /* drop the packet */
    }
    prev = pcb;
    pcb = pcb->next;
  }
  return eaten;
    ae74:	e0bffb03 	ldbu	r2,-20(fp)
}
    ae78:	e037883a 	mov	sp,fp
    ae7c:	dfc00117 	ldw	ra,4(sp)
    ae80:	df000017 	ldw	fp,0(sp)
    ae84:	dec00204 	addi	sp,sp,8
    ae88:	f800283a 	ret

0000ae8c <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
    ae8c:	defffd04 	addi	sp,sp,-12
    ae90:	df000215 	stw	fp,8(sp)
    ae94:	df000204 	addi	fp,sp,8
    ae98:	e13ffe15 	stw	r4,-8(fp)
    ae9c:	e17fff15 	stw	r5,-4(fp)
  ip_addr_set(&pcb->local_ip, ipaddr);
    aea0:	e0bfff17 	ldw	r2,-4(fp)
    aea4:	10000626 	beq	r2,zero,aec0 <raw_bind+0x34>
    aea8:	e0bfff17 	ldw	r2,-4(fp)
    aeac:	10c0000b 	ldhu	r3,0(r2)
    aeb0:	1080008b 	ldhu	r2,2(r2)
    aeb4:	1004943a 	slli	r2,r2,16
    aeb8:	10c4b03a 	or	r2,r2,r3
    aebc:	00000106 	br	aec4 <raw_bind+0x38>
    aec0:	0005883a 	mov	r2,zero
    aec4:	e0fffe17 	ldw	r3,-8(fp)
    aec8:	18800015 	stw	r2,0(r3)
  return ERR_OK;
    aecc:	0005883a 	mov	r2,zero
}
    aed0:	e037883a 	mov	sp,fp
    aed4:	df000017 	ldw	fp,0(sp)
    aed8:	dec00104 	addi	sp,sp,4
    aedc:	f800283a 	ret

0000aee0 <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
    aee0:	defffd04 	addi	sp,sp,-12
    aee4:	df000215 	stw	fp,8(sp)
    aee8:	df000204 	addi	fp,sp,8
    aeec:	e13ffe15 	stw	r4,-8(fp)
    aef0:	e17fff15 	stw	r5,-4(fp)
  ip_addr_set(&pcb->remote_ip, ipaddr);
    aef4:	e0bfff17 	ldw	r2,-4(fp)
    aef8:	10000626 	beq	r2,zero,af14 <raw_connect+0x34>
    aefc:	e0bfff17 	ldw	r2,-4(fp)
    af00:	10c0000b 	ldhu	r3,0(r2)
    af04:	1080008b 	ldhu	r2,2(r2)
    af08:	1004943a 	slli	r2,r2,16
    af0c:	10c4b03a 	or	r2,r2,r3
    af10:	00000106 	br	af18 <raw_connect+0x38>
    af14:	0005883a 	mov	r2,zero
    af18:	e0fffe17 	ldw	r3,-8(fp)
    af1c:	18800115 	stw	r2,4(r3)
  return ERR_OK;
    af20:	0005883a 	mov	r2,zero
}
    af24:	e037883a 	mov	sp,fp
    af28:	df000017 	ldw	fp,0(sp)
    af2c:	dec00104 	addi	sp,sp,4
    af30:	f800283a 	ret

0000af34 <raw_recv>:
void
raw_recv(struct raw_pcb *pcb,
         u8_t (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
                      struct ip_addr *addr),
         void *recv_arg)
{
    af34:	defffc04 	addi	sp,sp,-16
    af38:	df000315 	stw	fp,12(sp)
    af3c:	df000304 	addi	fp,sp,12
    af40:	e13ffd15 	stw	r4,-12(fp)
    af44:	e17ffe15 	stw	r5,-8(fp)
    af48:	e1bfff15 	stw	r6,-4(fp)
  /* remember recv() callback and user data */
  pcb->recv = recv;
    af4c:	e0bffd17 	ldw	r2,-12(fp)
    af50:	e0fffe17 	ldw	r3,-8(fp)
    af54:	10c00515 	stw	r3,20(r2)
  pcb->recv_arg = recv_arg;
    af58:	e0bffd17 	ldw	r2,-12(fp)
    af5c:	e0ffff17 	ldw	r3,-4(fp)
    af60:	10c00615 	stw	r3,24(r2)
}
    af64:	e037883a 	mov	sp,fp
    af68:	df000017 	ldw	fp,0(sp)
    af6c:	dec00104 	addi	sp,sp,4
    af70:	f800283a 	ret

0000af74 <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
    af74:	defff404 	addi	sp,sp,-48
    af78:	dfc00b15 	stw	ra,44(sp)
    af7c:	df000a15 	stw	fp,40(sp)
    af80:	df000a04 	addi	fp,sp,40
    af84:	e13ffd15 	stw	r4,-12(fp)
    af88:	e17ffe15 	stw	r5,-8(fp)
    af8c:	e1bfff15 	stw	r6,-4(fp)
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
    af90:	e13ffe17 	ldw	r4,-8(fp)
    af94:	01400504 	movi	r5,20
    af98:	0009f900 	call	9f90 <pbuf_header>
    af9c:	10803fcc 	andi	r2,r2,255
    afa0:	10000d26 	beq	r2,zero,afd8 <raw_sendto+0x64>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
    afa4:	01000044 	movi	r4,1
    afa8:	000b883a 	mov	r5,zero
    afac:	000d883a 	mov	r6,zero
    afb0:	00097cc0 	call	97cc <pbuf_alloc>
    afb4:	e0bffa15 	stw	r2,-24(fp)
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
    afb8:	e0bffa17 	ldw	r2,-24(fp)
    afbc:	1000021e 	bne	r2,zero,afc8 <raw_sendto+0x54>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
    afc0:	00bfffc4 	movi	r2,-1
    afc4:	00004406 	br	b0d8 <raw_sendto+0x164>
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
    afc8:	e13ffa17 	ldw	r4,-24(fp)
    afcc:	e17ffe17 	ldw	r5,-8(fp)
    afd0:	000a5200 	call	a520 <pbuf_chain>
    afd4:	00001006 	br	b018 <raw_sendto+0xa4>
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
    afd8:	e0bffe17 	ldw	r2,-8(fp)
    afdc:	e0bffa15 	stw	r2,-24(fp)
    if(pbuf_header(q, -IP_HLEN)) {
    afe0:	e13ffa17 	ldw	r4,-24(fp)
    afe4:	017ffb04 	movi	r5,-20
    afe8:	0009f900 	call	9f90 <pbuf_header>
    afec:	10803fcc 	andi	r2,r2,255
    aff0:	10000926 	beq	r2,zero,b018 <raw_sendto+0xa4>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
    aff4:	010000f4 	movhi	r4,3
    aff8:	213be404 	addi	r4,r4,-4208
    affc:	014000f4 	movhi	r5,3
    b000:	297bee04 	addi	r5,r5,-4168
    b004:	01803a04 	movi	r6,232
    b008:	01c000f4 	movhi	r7,3
    b00c:	39fbf804 	addi	r7,r7,-4128
    b010:	00170680 	call	17068 <printf>
    b014:	003fff06 	br	b014 <raw_sendto+0xa0>
      return ERR_MEM;
    }
  }

  if ((netif = ip_route(ipaddr)) == NULL) {
    b018:	e13fff17 	ldw	r4,-4(fp)
    b01c:	00061b00 	call	61b0 <ip_route>
    b020:	e0bffb15 	stw	r2,-20(fp)
    b024:	e0bffb17 	ldw	r2,-20(fp)
    b028:	1000071e 	bne	r2,zero,b048 <raw_sendto+0xd4>
    LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_LEVEL_WARNING, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
    b02c:	e0fffa17 	ldw	r3,-24(fp)
    b030:	e0bffe17 	ldw	r2,-8(fp)
    b034:	18800226 	beq	r3,r2,b040 <raw_sendto+0xcc>
      pbuf_free(q);
    b038:	e13ffa17 	ldw	r4,-24(fp)
    b03c:	000a1880 	call	a188 <pbuf_free>
    }
    return ERR_RTE;
    b040:	00bfff04 	movi	r2,-4
    b044:	00002406 	br	b0d8 <raw_sendto+0x164>
    }
    return ERR_VAL;
  }
#endif /* IP_SOF_BROADCAST */

  if (ip_addr_isany(&pcb->local_ip)) {
    b048:	e0bffd17 	ldw	r2,-12(fp)
    b04c:	10000326 	beq	r2,zero,b05c <raw_sendto+0xe8>
    b050:	e0bffd17 	ldw	r2,-12(fp)
    b054:	10800017 	ldw	r2,0(r2)
    b058:	1000041e 	bne	r2,zero,b06c <raw_sendto+0xf8>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
    b05c:	e0bffb17 	ldw	r2,-20(fp)
    b060:	10800104 	addi	r2,r2,4
    b064:	e0bff915 	stw	r2,-28(fp)
    b068:	00000206 	br	b074 <raw_sendto+0x100>
  } else {
    /* use RAW PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
    b06c:	e0bffd17 	ldw	r2,-12(fp)
    b070:	e0bff915 	stw	r2,-28(fp)
  }

#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
    b074:	e0bffd17 	ldw	r2,-12(fp)
    b078:	108002c3 	ldbu	r2,11(r2)
    b07c:	10803fcc 	andi	r2,r2,255
    b080:	e0fffd17 	ldw	r3,-12(fp)
    b084:	18c00283 	ldbu	r3,10(r3)
    b088:	19003fcc 	andi	r4,r3,255
    b08c:	e0fffd17 	ldw	r3,-12(fp)
    b090:	18c00403 	ldbu	r3,16(r3)
    b094:	18c03fcc 	andi	r3,r3,255
    b098:	d9000015 	stw	r4,0(sp)
    b09c:	d8c00115 	stw	r3,4(sp)
    b0a0:	e0fffb17 	ldw	r3,-20(fp)
    b0a4:	d8c00215 	stw	r3,8(sp)
    b0a8:	e13ffa17 	ldw	r4,-24(fp)
    b0ac:	e17ff917 	ldw	r5,-28(fp)
    b0b0:	e1bfff17 	ldw	r6,-4(fp)
    b0b4:	100f883a 	mov	r7,r2
    b0b8:	000687c0 	call	687c <ip_output_if>
    b0bc:	e0bffc05 	stb	r2,-16(fp)
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  /* did we chain a header earlier? */
  if (q != p) {
    b0c0:	e0fffa17 	ldw	r3,-24(fp)
    b0c4:	e0bffe17 	ldw	r2,-8(fp)
    b0c8:	18800226 	beq	r3,r2,b0d4 <raw_sendto+0x160>
    /* free the header */
    pbuf_free(q);
    b0cc:	e13ffa17 	ldw	r4,-24(fp)
    b0d0:	000a1880 	call	a188 <pbuf_free>
  }
  return err;
    b0d4:	e0bffc03 	ldbu	r2,-16(fp)
}
    b0d8:	e037883a 	mov	sp,fp
    b0dc:	dfc00117 	ldw	ra,4(sp)
    b0e0:	df000017 	ldw	fp,0(sp)
    b0e4:	dec00204 	addi	sp,sp,8
    b0e8:	f800283a 	ret

0000b0ec <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
    b0ec:	defffc04 	addi	sp,sp,-16
    b0f0:	dfc00315 	stw	ra,12(sp)
    b0f4:	df000215 	stw	fp,8(sp)
    b0f8:	df000204 	addi	fp,sp,8
    b0fc:	e13ffe15 	stw	r4,-8(fp)
    b100:	e17fff15 	stw	r5,-4(fp)
  return raw_sendto(pcb, p, &pcb->remote_ip);
    b104:	e0bffe17 	ldw	r2,-8(fp)
    b108:	10800104 	addi	r2,r2,4
    b10c:	e13ffe17 	ldw	r4,-8(fp)
    b110:	e17fff17 	ldw	r5,-4(fp)
    b114:	100d883a 	mov	r6,r2
    b118:	000af740 	call	af74 <raw_sendto>
}
    b11c:	e037883a 	mov	sp,fp
    b120:	dfc00117 	ldw	ra,4(sp)
    b124:	df000017 	ldw	fp,0(sp)
    b128:	dec00204 	addi	sp,sp,8
    b12c:	f800283a 	ret

0000b130 <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
    b130:	defffc04 	addi	sp,sp,-16
    b134:	dfc00315 	stw	ra,12(sp)
    b138:	df000215 	stw	fp,8(sp)
    b13c:	df000204 	addi	fp,sp,8
    b140:	e13fff15 	stw	r4,-4(fp)
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
    b144:	d0e8d417 	ldw	r3,-23728(gp)
    b148:	e0bfff17 	ldw	r2,-4(fp)
    b14c:	1880041e 	bne	r3,r2,b160 <raw_remove+0x30>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    b150:	d0a8d417 	ldw	r2,-23728(gp)
    b154:	10800317 	ldw	r2,12(r2)
    b158:	d0a8d415 	stw	r2,-23728(gp)
    b15c:	00001306 	br	b1ac <raw_remove+0x7c>
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
    b160:	d0a8d417 	ldw	r2,-23728(gp)
    b164:	e0bffe15 	stw	r2,-8(fp)
    b168:	00000e06 	br	b1a4 <raw_remove+0x74>
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
    b16c:	e0bffe17 	ldw	r2,-8(fp)
    b170:	10800317 	ldw	r2,12(r2)
    b174:	10000826 	beq	r2,zero,b198 <raw_remove+0x68>
    b178:	e0bffe17 	ldw	r2,-8(fp)
    b17c:	10c00317 	ldw	r3,12(r2)
    b180:	e0bfff17 	ldw	r2,-4(fp)
    b184:	1880041e 	bne	r3,r2,b198 <raw_remove+0x68>
        /* remove pcb from list */
        pcb2->next = pcb->next;
    b188:	e0bfff17 	ldw	r2,-4(fp)
    b18c:	10c00317 	ldw	r3,12(r2)
    b190:	e0bffe17 	ldw	r2,-8(fp)
    b194:	10c00315 	stw	r3,12(r2)
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
    b198:	e0bffe17 	ldw	r2,-8(fp)
    b19c:	10800317 	ldw	r2,12(r2)
    b1a0:	e0bffe15 	stw	r2,-8(fp)
    b1a4:	e0bffe17 	ldw	r2,-8(fp)
    b1a8:	103ff01e 	bne	r2,zero,b16c <raw_remove+0x3c>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
    b1ac:	0009883a 	mov	r4,zero
    b1b0:	e17fff17 	ldw	r5,-4(fp)
    b1b4:	00090e80 	call	90e8 <memp_free>
}
    b1b8:	e037883a 	mov	sp,fp
    b1bc:	dfc00117 	ldw	ra,4(sp)
    b1c0:	df000017 	ldw	fp,0(sp)
    b1c4:	dec00204 	addi	sp,sp,8
    b1c8:	f800283a 	ret

0000b1cc <raw_new>:
 * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto) {
    b1cc:	defffc04 	addi	sp,sp,-16
    b1d0:	dfc00315 	stw	ra,12(sp)
    b1d4:	df000215 	stw	fp,8(sp)
    b1d8:	df000204 	addi	fp,sp,8
    b1dc:	2005883a 	mov	r2,r4
    b1e0:	e0bfff05 	stb	r2,-4(fp)
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE, ("raw_new\n"));

  pcb = memp_malloc(MEMP_RAW_PCB);
    b1e4:	0009883a 	mov	r4,zero
    b1e8:	0008f0c0 	call	8f0c <memp_malloc>
    b1ec:	e0bffe15 	stw	r2,-8(fp)
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
    b1f0:	e0bffe17 	ldw	r2,-8(fp)
    b1f4:	10000f26 	beq	r2,zero,b234 <raw_new+0x68>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
    b1f8:	e13ffe17 	ldw	r4,-8(fp)
    b1fc:	000b883a 	mov	r5,zero
    b200:	01800704 	movi	r6,28
    b204:	0016f600 	call	16f60 <memset>
    pcb->protocol = proto;
    b208:	e0bffe17 	ldw	r2,-8(fp)
    b20c:	e0ffff03 	ldbu	r3,-4(fp)
    b210:	10c00405 	stb	r3,16(r2)
    pcb->ttl = RAW_TTL;
    b214:	e0bffe17 	ldw	r2,-8(fp)
    b218:	00ffffc4 	movi	r3,-1
    b21c:	10c002c5 	stb	r3,11(r2)
    pcb->next = raw_pcbs;
    b220:	d0e8d417 	ldw	r3,-23728(gp)
    b224:	e0bffe17 	ldw	r2,-8(fp)
    b228:	10c00315 	stw	r3,12(r2)
    raw_pcbs = pcb;
    b22c:	e0bffe17 	ldw	r2,-8(fp)
    b230:	d0a8d415 	stw	r2,-23728(gp)
  }
  return pcb;
    b234:	e0bffe17 	ldw	r2,-8(fp)
}
    b238:	e037883a 	mov	sp,fp
    b23c:	dfc00117 	ldw	ra,4(sp)
    b240:	df000017 	ldw	fp,0(sp)
    b244:	dec00204 	addi	sp,sp,8
    b248:	f800283a 	ret

0000b24c <tcp_tmr>:
 * Called periodically to dispatch TCP timers.
 *
 */
void
tcp_tmr(void)
{
    b24c:	defffe04 	addi	sp,sp,-8
    b250:	dfc00115 	stw	ra,4(sp)
    b254:	df000015 	stw	fp,0(sp)
    b258:	d839883a 	mov	fp,sp
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
    b25c:	000c91c0 	call	c91c <tcp_fasttmr>

  if (++tcp_timer & 1) {
    b260:	d0a8d503 	ldbu	r2,-23724(gp)
    b264:	10800044 	addi	r2,r2,1
    b268:	d0a8d505 	stb	r2,-23724(gp)
    b26c:	d0a8d503 	ldbu	r2,-23724(gp)
    b270:	10803fcc 	andi	r2,r2,255
    b274:	1080004c 	andi	r2,r2,1
    b278:	10000126 	beq	r2,zero,b280 <tcp_tmr+0x34>
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
    b27c:	000c0580 	call	c058 <tcp_slowtmr>
  }
}
    b280:	e037883a 	mov	sp,fp
    b284:	dfc00117 	ldw	ra,4(sp)
    b288:	df000017 	ldw	fp,0(sp)
    b28c:	dec00204 	addi	sp,sp,8
    b290:	f800283a 	ret

0000b294 <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
    b294:	defffc04 	addi	sp,sp,-16
    b298:	dfc00315 	stw	ra,12(sp)
    b29c:	df000215 	stw	fp,8(sp)
    b2a0:	df000204 	addi	fp,sp,8
    b2a4:	e13fff15 	stw	r4,-4(fp)
  err_t err;

#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
    b2a8:	010000f4 	movhi	r4,3
    b2ac:	213c1e04 	addi	r4,r4,-3976
    b2b0:	00170680 	call	17068 <printf>
  tcp_debug_print_state(pcb->state);
    b2b4:	e0bfff17 	ldw	r2,-4(fp)
    b2b8:	10800417 	ldw	r2,16(r2)
    b2bc:	1009883a 	mov	r4,r2
    b2c0:	000d7540 	call	d754 <tcp_debug_print_state>
#endif /* TCP_DEBUG */

  switch (pcb->state) {
    b2c4:	e0bfff17 	ldw	r2,-4(fp)
    b2c8:	10800417 	ldw	r2,16(r2)
    b2cc:	10c00228 	cmpgeui	r3,r2,8
    b2d0:	18005f1e 	bne	r3,zero,b450 <tcp_close+0x1bc>
    b2d4:	1085883a 	add	r2,r2,r2
    b2d8:	1087883a 	add	r3,r2,r2
    b2dc:	00800074 	movhi	r2,1
    b2e0:	10acbc04 	addi	r2,r2,-19728
    b2e4:	1885883a 	add	r2,r3,r2
    b2e8:	10800017 	ldw	r2,0(r2)
    b2ec:	1000683a 	jmp	r2
    b2f0:	0000b310 	cmplti	zero,zero,716
    b2f4:	0000b390 	cmplti	zero,zero,718
    b2f8:	0000b3b4 	movhi	zero,718
    b2fc:	0000b3d8 	cmpnei	zero,zero,719
    b300:	0000b400 	call	b40 <http_accept>
    b304:	0000b450 	cmplti	zero,zero,721
    b308:	0000b450 	cmplti	zero,zero,721
    b30c:	0000b428 	cmpgeui	zero,zero,720
     * and the user needs some way to free it should the need arise.
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
    b310:	e03ffe05 	stb	zero,-8(fp)
    TCP_RMV(&tcp_bound_pcbs, pcb);
    b314:	d0e8da17 	ldw	r3,-23704(gp)
    b318:	e0bfff17 	ldw	r2,-4(fp)
    b31c:	1880041e 	bne	r3,r2,b330 <tcp_close+0x9c>
    b320:	d0a8da17 	ldw	r2,-23704(gp)
    b324:	10800317 	ldw	r2,12(r2)
    b328:	d0a8da15 	stw	r2,-23704(gp)
    b32c:	00001106 	br	b374 <tcp_close+0xe0>
    b330:	d0a8da17 	ldw	r2,-23704(gp)
    b334:	d0a8d915 	stw	r2,-23708(gp)
    b338:	00000c06 	br	b36c <tcp_close+0xd8>
    b33c:	d0a8d917 	ldw	r2,-23708(gp)
    b340:	10c00317 	ldw	r3,12(r2)
    b344:	e0bfff17 	ldw	r2,-4(fp)
    b348:	1880051e 	bne	r3,r2,b360 <tcp_close+0xcc>
    b34c:	d0a8d917 	ldw	r2,-23708(gp)
    b350:	e0ffff17 	ldw	r3,-4(fp)
    b354:	18c00317 	ldw	r3,12(r3)
    b358:	10c00315 	stw	r3,12(r2)
    b35c:	00000506 	br	b374 <tcp_close+0xe0>
    b360:	d0a8d917 	ldw	r2,-23708(gp)
    b364:	10800317 	ldw	r2,12(r2)
    b368:	d0a8d915 	stw	r2,-23708(gp)
    b36c:	d0a8d917 	ldw	r2,-23708(gp)
    b370:	103ff21e 	bne	r2,zero,b33c <tcp_close+0xa8>
    b374:	e0bfff17 	ldw	r2,-4(fp)
    b378:	10000315 	stw	zero,12(r2)
    memp_free(MEMP_TCP_PCB, pcb);
    b37c:	01000084 	movi	r4,2
    b380:	e17fff17 	ldw	r5,-4(fp)
    b384:	00090e80 	call	90e8 <memp_free>
    pcb = NULL;
    b388:	e03fff15 	stw	zero,-4(fp)
    break;
    b38c:	00003806 	br	b470 <tcp_close+0x1dc>
  case LISTEN:
    err = ERR_OK;
    b390:	e03ffe05 	stb	zero,-8(fp)
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
    b394:	d128d804 	addi	r4,gp,-23712
    b398:	e17fff17 	ldw	r5,-4(fp)
    b39c:	000d2300 	call	d230 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
    b3a0:	010000c4 	movi	r4,3
    b3a4:	e17fff17 	ldw	r5,-4(fp)
    b3a8:	00090e80 	call	90e8 <memp_free>
    pcb = NULL;
    b3ac:	e03fff15 	stw	zero,-4(fp)
    break;
    b3b0:	00002f06 	br	b470 <tcp_close+0x1dc>
  case SYN_SENT:
    err = ERR_OK;
    b3b4:	e03ffe05 	stb	zero,-8(fp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
    b3b8:	d128d604 	addi	r4,gp,-23720
    b3bc:	e17fff17 	ldw	r5,-4(fp)
    b3c0:	000d2300 	call	d230 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
    b3c4:	01000084 	movi	r4,2
    b3c8:	e17fff17 	ldw	r5,-4(fp)
    b3cc:	00090e80 	call	90e8 <memp_free>
    pcb = NULL;
    b3d0:	e03fff15 	stw	zero,-4(fp)
    snmp_inc_tcpattemptfails();
    break;
    b3d4:	00002606 	br	b470 <tcp_close+0x1dc>
  case SYN_RCVD:
    err = tcp_send_ctrl(pcb, TCP_FIN);
    b3d8:	e13fff17 	ldw	r4,-4(fp)
    b3dc:	01400044 	movi	r5,1
    b3e0:	0011b440 	call	11b44 <tcp_send_ctrl>
    b3e4:	e0bffe05 	stb	r2,-8(fp)
    if (err == ERR_OK) {
    b3e8:	e0bffe07 	ldb	r2,-8(fp)
    b3ec:	10001b1e 	bne	r2,zero,b45c <tcp_close+0x1c8>
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
    b3f0:	e0bfff17 	ldw	r2,-4(fp)
    b3f4:	00c00144 	movi	r3,5
    b3f8:	10c00415 	stw	r3,16(r2)
    }
    break;
    b3fc:	00001706 	br	b45c <tcp_close+0x1c8>
  case ESTABLISHED:
    err = tcp_send_ctrl(pcb, TCP_FIN);
    b400:	e13fff17 	ldw	r4,-4(fp)
    b404:	01400044 	movi	r5,1
    b408:	0011b440 	call	11b44 <tcp_send_ctrl>
    b40c:	e0bffe05 	stb	r2,-8(fp)
    if (err == ERR_OK) {
    b410:	e0bffe07 	ldb	r2,-8(fp)
    b414:	1000131e 	bne	r2,zero,b464 <tcp_close+0x1d0>
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
    b418:	e0bfff17 	ldw	r2,-4(fp)
    b41c:	00c00144 	movi	r3,5
    b420:	10c00415 	stw	r3,16(r2)
    }
    break;
    b424:	00000f06 	br	b464 <tcp_close+0x1d0>
  case CLOSE_WAIT:
    err = tcp_send_ctrl(pcb, TCP_FIN);
    b428:	e13fff17 	ldw	r4,-4(fp)
    b42c:	01400044 	movi	r5,1
    b430:	0011b440 	call	11b44 <tcp_send_ctrl>
    b434:	e0bffe05 	stb	r2,-8(fp)
    if (err == ERR_OK) {
    b438:	e0bffe07 	ldb	r2,-8(fp)
    b43c:	10000b1e 	bne	r2,zero,b46c <tcp_close+0x1d8>
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
    b440:	e0bfff17 	ldw	r2,-4(fp)
    b444:	00c00244 	movi	r3,9
    b448:	10c00415 	stw	r3,16(r2)
    }
    break;
    b44c:	00000706 	br	b46c <tcp_close+0x1d8>
  default:
    /* Has already been closed, do nothing. */
    err = ERR_OK;
    b450:	e03ffe05 	stb	zero,-8(fp)
    pcb = NULL;
    b454:	e03fff15 	stw	zero,-4(fp)
    break;
    b458:	00000506 	br	b470 <tcp_close+0x1dc>
    err = tcp_send_ctrl(pcb, TCP_FIN);
    if (err == ERR_OK) {
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
    }
    break;
    b45c:	0001883a 	nop
    b460:	00000306 	br	b470 <tcp_close+0x1dc>
    err = tcp_send_ctrl(pcb, TCP_FIN);
    if (err == ERR_OK) {
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
    }
    break;
    b464:	0001883a 	nop
    b468:	00000106 	br	b470 <tcp_close+0x1dc>
    err = tcp_send_ctrl(pcb, TCP_FIN);
    if (err == ERR_OK) {
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
    }
    break;
    b46c:	0001883a 	nop
    err = ERR_OK;
    pcb = NULL;
    break;
  }

  if (pcb != NULL && err == ERR_OK) {
    b470:	e0bfff17 	ldw	r2,-4(fp)
    b474:	10000426 	beq	r2,zero,b488 <tcp_close+0x1f4>
    b478:	e0bffe07 	ldb	r2,-8(fp)
    b47c:	1000021e 	bne	r2,zero,b488 <tcp_close+0x1f4>
       Since we don't really have to ensure all data has been sent when tcp_close
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent when tcp_close returns. */
    tcp_output(pcb);
    b480:	e13fff17 	ldw	r4,-4(fp)
    b484:	0012b000 	call	12b00 <tcp_output>
  }
  return err;
    b488:	e0bffe03 	ldbu	r2,-8(fp)
}
    b48c:	e037883a 	mov	sp,fp
    b490:	dfc00117 	ldw	ra,4(sp)
    b494:	df000017 	ldw	fp,0(sp)
    b498:	dec00204 	addi	sp,sp,8
    b49c:	f800283a 	ret

0000b4a0 <tcp_abandon>:
 * @param pcb the tcp_pcb to abort
 * @param reset boolean to indicate whether a reset should be sent
 */
void
tcp_abandon(struct tcp_pcb *pcb, int reset)
{
    b4a0:	defff304 	addi	sp,sp,-52
    b4a4:	dfc00c15 	stw	ra,48(sp)
    b4a8:	df000b15 	stw	fp,44(sp)
    b4ac:	df000b04 	addi	fp,sp,44
    b4b0:	e13ffe15 	stw	r4,-8(fp)
    b4b4:	e17fff15 	stw	r5,-4(fp)

  
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
    b4b8:	e0bffe17 	ldw	r2,-8(fp)
    b4bc:	10800417 	ldw	r2,16(r2)
    b4c0:	10800298 	cmpnei	r2,r2,10
    b4c4:	1000071e 	bne	r2,zero,b4e4 <tcp_abandon+0x44>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
    b4c8:	d128db04 	addi	r4,gp,-23700
    b4cc:	e17ffe17 	ldw	r5,-8(fp)
    b4d0:	000d2300 	call	d230 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
    b4d4:	01000084 	movi	r4,2
    b4d8:	e17ffe17 	ldw	r5,-8(fp)
    b4dc:	00090e80 	call	90e8 <memp_free>
    b4e0:	00004f06 	br	b620 <tcp_abandon+0x180>
  } else {
    seqno = pcb->snd_nxt;
    b4e4:	e0bffe17 	ldw	r2,-8(fp)
    b4e8:	10801717 	ldw	r2,92(r2)
    b4ec:	e0bff715 	stw	r2,-36(fp)
    ackno = pcb->rcv_nxt;
    b4f0:	e0bffe17 	ldw	r2,-8(fp)
    b4f4:	10800a17 	ldw	r2,40(r2)
    b4f8:	e0bff815 	stw	r2,-32(fp)
    ip_addr_set(&local_ip, &(pcb->local_ip));
    b4fc:	e0bffe17 	ldw	r2,-8(fp)
    b500:	10000326 	beq	r2,zero,b510 <tcp_abandon+0x70>
    b504:	e0bffe17 	ldw	r2,-8(fp)
    b508:	10800017 	ldw	r2,0(r2)
    b50c:	00000106 	br	b514 <tcp_abandon+0x74>
    b510:	0005883a 	mov	r2,zero
    b514:	e0bffd15 	stw	r2,-12(fp)
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
    b518:	e0bffe17 	ldw	r2,-8(fp)
    b51c:	10800104 	addi	r2,r2,4
    b520:	10000326 	beq	r2,zero,b530 <tcp_abandon+0x90>
    b524:	e0bffe17 	ldw	r2,-8(fp)
    b528:	10800117 	ldw	r2,4(r2)
    b52c:	00000106 	br	b534 <tcp_abandon+0x94>
    b530:	0005883a 	mov	r2,zero
    b534:	e0bffc15 	stw	r2,-16(fp)
    local_port = pcb->local_port;
    b538:	e0bffe17 	ldw	r2,-8(fp)
    b53c:	1080070b 	ldhu	r2,28(r2)
    b540:	e0bff90d 	sth	r2,-28(fp)
    remote_port = pcb->remote_port;
    b544:	e0bffe17 	ldw	r2,-8(fp)
    b548:	1080090b 	ldhu	r2,36(r2)
    b54c:	e0bff98d 	sth	r2,-26(fp)
#if LWIP_CALLBACK_API
    errf = pcb->errf;
    b550:	e0bffe17 	ldw	r2,-8(fp)
    b554:	10802617 	ldw	r2,152(r2)
    b558:	e0bffa15 	stw	r2,-24(fp)
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
    b55c:	e0bffe17 	ldw	r2,-8(fp)
    b560:	10800617 	ldw	r2,24(r2)
    b564:	e0bffb15 	stw	r2,-20(fp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
    b568:	d128d604 	addi	r4,gp,-23720
    b56c:	e17ffe17 	ldw	r5,-8(fp)
    b570:	000d2300 	call	d230 <tcp_pcb_remove>
    if (pcb->unacked != NULL) {
    b574:	e0bffe17 	ldw	r2,-8(fp)
    b578:	10801f17 	ldw	r2,124(r2)
    b57c:	10000426 	beq	r2,zero,b590 <tcp_abandon+0xf0>
      tcp_segs_free(pcb->unacked);
    b580:	e0bffe17 	ldw	r2,-8(fp)
    b584:	10801f17 	ldw	r2,124(r2)
    b588:	1009883a 	mov	r4,r2
    b58c:	000ca380 	call	ca38 <tcp_segs_free>
    }
    if (pcb->unsent != NULL) {
    b590:	e0bffe17 	ldw	r2,-8(fp)
    b594:	10801e17 	ldw	r2,120(r2)
    b598:	10000426 	beq	r2,zero,b5ac <tcp_abandon+0x10c>
      tcp_segs_free(pcb->unsent);
    b59c:	e0bffe17 	ldw	r2,-8(fp)
    b5a0:	10801e17 	ldw	r2,120(r2)
    b5a4:	1009883a 	mov	r4,r2
    b5a8:	000ca380 	call	ca38 <tcp_segs_free>
    }
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
    b5ac:	e0bffe17 	ldw	r2,-8(fp)
    b5b0:	10802017 	ldw	r2,128(r2)
    b5b4:	10000426 	beq	r2,zero,b5c8 <tcp_abandon+0x128>
      tcp_segs_free(pcb->ooseq);
    b5b8:	e0bffe17 	ldw	r2,-8(fp)
    b5bc:	10802017 	ldw	r2,128(r2)
    b5c0:	1009883a 	mov	r4,r2
    b5c4:	000ca380 	call	ca38 <tcp_segs_free>
    }
#endif /* TCP_QUEUE_OOSEQ */
    memp_free(MEMP_TCP_PCB, pcb);
    b5c8:	01000084 	movi	r4,2
    b5cc:	e17ffe17 	ldw	r5,-8(fp)
    b5d0:	00090e80 	call	90e8 <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
    b5d4:	e0bffa17 	ldw	r2,-24(fp)
    b5d8:	10000426 	beq	r2,zero,b5ec <tcp_abandon+0x14c>
    b5dc:	e0bffa17 	ldw	r2,-24(fp)
    b5e0:	e13ffb17 	ldw	r4,-20(fp)
    b5e4:	017ffec4 	movi	r5,-5
    b5e8:	103ee83a 	callr	r2
    if (reset) {
    b5ec:	e0bfff17 	ldw	r2,-4(fp)
    b5f0:	10000b26 	beq	r2,zero,b620 <tcp_abandon+0x180>
      LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abandon: sending RST\n"));
      tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
    b5f4:	e17ff90b 	ldhu	r5,-28(fp)
    b5f8:	e13ff98b 	ldhu	r4,-26(fp)
    b5fc:	e0fffd04 	addi	r3,fp,-12
    b600:	e0bffc04 	addi	r2,fp,-16
    b604:	d9400015 	stw	r5,0(sp)
    b608:	d9000115 	stw	r4,4(sp)
    b60c:	e13ff717 	ldw	r4,-36(fp)
    b610:	e17ff817 	ldw	r5,-32(fp)
    b614:	180d883a 	mov	r6,r3
    b618:	100f883a 	mov	r7,r2
    b61c:	00137240 	call	13724 <tcp_rst>
    }
  }
}
    b620:	e037883a 	mov	sp,fp
    b624:	dfc00117 	ldw	ra,4(sp)
    b628:	df000017 	ldw	fp,0(sp)
    b62c:	dec00204 	addi	sp,sp,8
    b630:	f800283a 	ret

0000b634 <tcp_bind>:
 * @return ERR_USE if the port is already in use
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
    b634:	defffa04 	addi	sp,sp,-24
    b638:	dfc00515 	stw	ra,20(sp)
    b63c:	df000415 	stw	fp,16(sp)
    b640:	df000404 	addi	fp,sp,16
    b644:	e13ffd15 	stw	r4,-12(fp)
    b648:	e17ffe15 	stw	r5,-8(fp)
    b64c:	3005883a 	mov	r2,r6
    b650:	e0bfff0d 	sth	r2,-4(fp)
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
    b654:	e0bffd17 	ldw	r2,-12(fp)
    b658:	10800417 	ldw	r2,16(r2)
    b65c:	10000926 	beq	r2,zero,b684 <tcp_bind+0x50>
    b660:	010000f4 	movhi	r4,3
    b664:	213c2404 	addi	r4,r4,-3952
    b668:	014000f4 	movhi	r5,3
    b66c:	297c2e04 	addi	r5,r5,-3912
    b670:	01804604 	movi	r6,280
    b674:	01c000f4 	movhi	r7,3
    b678:	39fc3804 	addi	r7,r7,-3872
    b67c:	00170680 	call	17068 <printf>
    b680:	003fff06 	br	b680 <tcp_bind+0x4c>

  if (port == 0) {
    b684:	e0bfff0b 	ldhu	r2,-4(fp)
    b688:	1000021e 	bne	r2,zero,b694 <tcp_bind+0x60>
    port = tcp_new_port();
    b68c:	000bcfc0 	call	bcfc <tcp_new_port>
    b690:	e0bfff0d 	sth	r2,-4(fp)
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
    b694:	d0a8d817 	ldw	r2,-23712(gp)
    b698:	e0bffc15 	stw	r2,-16(fp)
    b69c:	00001f06 	br	b71c <tcp_bind+0xe8>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
    b6a0:	e0bffc17 	ldw	r2,-16(fp)
    b6a4:	1080070b 	ldhu	r2,28(r2)
    b6a8:	10ffffcc 	andi	r3,r2,65535
    b6ac:	e0bfff0b 	ldhu	r2,-4(fp)
    b6b0:	1880171e 	bne	r3,r2,b710 <tcp_bind+0xdc>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
    b6b4:	e0bffc17 	ldw	r2,-16(fp)
    b6b8:	10001326 	beq	r2,zero,b708 <tcp_bind+0xd4>
    b6bc:	e0bffc17 	ldw	r2,-16(fp)
    b6c0:	10800017 	ldw	r2,0(r2)
    b6c4:	10001026 	beq	r2,zero,b708 <tcp_bind+0xd4>
    b6c8:	e0bffe17 	ldw	r2,-8(fp)
    b6cc:	10000e26 	beq	r2,zero,b708 <tcp_bind+0xd4>
          ip_addr_isany(ipaddr) ||
    b6d0:	e0bffe17 	ldw	r2,-8(fp)
    b6d4:	10c0000b 	ldhu	r3,0(r2)
    b6d8:	1080008b 	ldhu	r2,2(r2)
    b6dc:	1004943a 	slli	r2,r2,16
    b6e0:	10c4b03a 	or	r2,r2,r3
    b6e4:	10000826 	beq	r2,zero,b708 <tcp_bind+0xd4>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
    b6e8:	e0bffc17 	ldw	r2,-16(fp)
    b6ec:	10c00017 	ldw	r3,0(r2)
    b6f0:	e0bffe17 	ldw	r2,-8(fp)
    b6f4:	1100000b 	ldhu	r4,0(r2)
    b6f8:	1080008b 	ldhu	r2,2(r2)
    b6fc:	1004943a 	slli	r2,r2,16
    b700:	1104b03a 	or	r2,r2,r4
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
    b704:	1880021e 	bne	r3,r2,b710 <tcp_bind+0xdc>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
    b708:	00bffd44 	movi	r2,-11
    b70c:	00007e06 	br	b908 <tcp_bind+0x2d4>
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    b710:	e0bffc17 	ldw	r2,-16(fp)
    b714:	10800317 	ldw	r2,12(r2)
    b718:	e0bffc15 	stw	r2,-16(fp)
  if (port == 0) {
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
    b71c:	e0bffc17 	ldw	r2,-16(fp)
    b720:	103fdf1e 	bne	r2,zero,b6a0 <tcp_bind+0x6c>
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
    b724:	d0a8d617 	ldw	r2,-23720(gp)
    b728:	e0bffc15 	stw	r2,-16(fp)
    b72c:	00001f06 	br	b7ac <tcp_bind+0x178>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
    b730:	e0bffc17 	ldw	r2,-16(fp)
    b734:	1080070b 	ldhu	r2,28(r2)
    b738:	10ffffcc 	andi	r3,r2,65535
    b73c:	e0bfff0b 	ldhu	r2,-4(fp)
    b740:	1880171e 	bne	r3,r2,b7a0 <tcp_bind+0x16c>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
    b744:	e0bffc17 	ldw	r2,-16(fp)
    b748:	10001326 	beq	r2,zero,b798 <tcp_bind+0x164>
    b74c:	e0bffc17 	ldw	r2,-16(fp)
    b750:	10800017 	ldw	r2,0(r2)
    b754:	10001026 	beq	r2,zero,b798 <tcp_bind+0x164>
    b758:	e0bffe17 	ldw	r2,-8(fp)
    b75c:	10000e26 	beq	r2,zero,b798 <tcp_bind+0x164>
          ip_addr_isany(ipaddr) ||
    b760:	e0bffe17 	ldw	r2,-8(fp)
    b764:	10c0000b 	ldhu	r3,0(r2)
    b768:	1080008b 	ldhu	r2,2(r2)
    b76c:	1004943a 	slli	r2,r2,16
    b770:	10c4b03a 	or	r2,r2,r3
    b774:	10000826 	beq	r2,zero,b798 <tcp_bind+0x164>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
    b778:	e0bffc17 	ldw	r2,-16(fp)
    b77c:	10c00017 	ldw	r3,0(r2)
    b780:	e0bffe17 	ldw	r2,-8(fp)
    b784:	1100000b 	ldhu	r4,0(r2)
    b788:	1080008b 	ldhu	r2,2(r2)
    b78c:	1004943a 	slli	r2,r2,16
    b790:	1104b03a 	or	r2,r2,r4
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
    b794:	1880021e 	bne	r3,r2,b7a0 <tcp_bind+0x16c>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
    b798:	00bffd44 	movi	r2,-11
    b79c:	00005a06 	br	b908 <tcp_bind+0x2d4>
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    b7a0:	e0bffc17 	ldw	r2,-16(fp)
    b7a4:	10800317 	ldw	r2,12(r2)
    b7a8:	e0bffc15 	stw	r2,-16(fp)
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
    b7ac:	e0bffc17 	ldw	r2,-16(fp)
    b7b0:	103fdf1e 	bne	r2,zero,b730 <tcp_bind+0xfc>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    b7b4:	d0a8da17 	ldw	r2,-23704(gp)
    b7b8:	e0bffc15 	stw	r2,-16(fp)
    b7bc:	00001f06 	br	b83c <tcp_bind+0x208>
    if (cpcb->local_port == port) {
    b7c0:	e0bffc17 	ldw	r2,-16(fp)
    b7c4:	1080070b 	ldhu	r2,28(r2)
    b7c8:	10ffffcc 	andi	r3,r2,65535
    b7cc:	e0bfff0b 	ldhu	r2,-4(fp)
    b7d0:	1880171e 	bne	r3,r2,b830 <tcp_bind+0x1fc>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
    b7d4:	e0bffc17 	ldw	r2,-16(fp)
    b7d8:	10001326 	beq	r2,zero,b828 <tcp_bind+0x1f4>
    b7dc:	e0bffc17 	ldw	r2,-16(fp)
    b7e0:	10800017 	ldw	r2,0(r2)
    b7e4:	10001026 	beq	r2,zero,b828 <tcp_bind+0x1f4>
    b7e8:	e0bffe17 	ldw	r2,-8(fp)
    b7ec:	10000e26 	beq	r2,zero,b828 <tcp_bind+0x1f4>
          ip_addr_isany(ipaddr) ||
    b7f0:	e0bffe17 	ldw	r2,-8(fp)
    b7f4:	10c0000b 	ldhu	r3,0(r2)
    b7f8:	1080008b 	ldhu	r2,2(r2)
    b7fc:	1004943a 	slli	r2,r2,16
    b800:	10c4b03a 	or	r2,r2,r3
    b804:	10000826 	beq	r2,zero,b828 <tcp_bind+0x1f4>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
    b808:	e0bffc17 	ldw	r2,-16(fp)
    b80c:	10c00017 	ldw	r3,0(r2)
    b810:	e0bffe17 	ldw	r2,-8(fp)
    b814:	1100000b 	ldhu	r4,0(r2)
    b818:	1080008b 	ldhu	r2,2(r2)
    b81c:	1004943a 	slli	r2,r2,16
    b820:	1104b03a 	or	r2,r2,r4
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
    b824:	1880021e 	bne	r3,r2,b830 <tcp_bind+0x1fc>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
    b828:	00bffd44 	movi	r2,-11
    b82c:	00003606 	br	b908 <tcp_bind+0x2d4>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    b830:	e0bffc17 	ldw	r2,-16(fp)
    b834:	10800317 	ldw	r2,12(r2)
    b838:	e0bffc15 	stw	r2,-16(fp)
    b83c:	e0bffc17 	ldw	r2,-16(fp)
    b840:	103fdf1e 	bne	r2,zero,b7c0 <tcp_bind+0x18c>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    b844:	d0a8db17 	ldw	r2,-23700(gp)
    b848:	e0bffc15 	stw	r2,-16(fp)
    b84c:	00001206 	br	b898 <tcp_bind+0x264>
    if (cpcb->local_port == port) {
    b850:	e0bffc17 	ldw	r2,-16(fp)
    b854:	1080070b 	ldhu	r2,28(r2)
    b858:	10ffffcc 	andi	r3,r2,65535
    b85c:	e0bfff0b 	ldhu	r2,-4(fp)
    b860:	18800a1e 	bne	r3,r2,b88c <tcp_bind+0x258>
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
    b864:	e0bffc17 	ldw	r2,-16(fp)
    b868:	10c00017 	ldw	r3,0(r2)
    b86c:	e0bffe17 	ldw	r2,-8(fp)
    b870:	1100000b 	ldhu	r4,0(r2)
    b874:	1080008b 	ldhu	r2,2(r2)
    b878:	1004943a 	slli	r2,r2,16
    b87c:	1104b03a 	or	r2,r2,r4
    b880:	1880021e 	bne	r3,r2,b88c <tcp_bind+0x258>
        return ERR_USE;
    b884:	00bffd44 	movi	r2,-11
    b888:	00001f06 	br	b908 <tcp_bind+0x2d4>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    b88c:	e0bffc17 	ldw	r2,-16(fp)
    b890:	10800317 	ldw	r2,12(r2)
    b894:	e0bffc15 	stw	r2,-16(fp)
    b898:	e0bffc17 	ldw	r2,-16(fp)
    b89c:	103fec1e 	bne	r2,zero,b850 <tcp_bind+0x21c>
        return ERR_USE;
      }
    }
  }

  if (!ip_addr_isany(ipaddr)) {
    b8a0:	e0bffe17 	ldw	r2,-8(fp)
    b8a4:	10000c26 	beq	r2,zero,b8d8 <tcp_bind+0x2a4>
    b8a8:	e0bffe17 	ldw	r2,-8(fp)
    b8ac:	10c0000b 	ldhu	r3,0(r2)
    b8b0:	1080008b 	ldhu	r2,2(r2)
    b8b4:	1004943a 	slli	r2,r2,16
    b8b8:	10c4b03a 	or	r2,r2,r3
    b8bc:	10000626 	beq	r2,zero,b8d8 <tcp_bind+0x2a4>
    pcb->local_ip = *ipaddr;
    b8c0:	e0bffd17 	ldw	r2,-12(fp)
    b8c4:	e0fffe17 	ldw	r3,-8(fp)
    b8c8:	1900000b 	ldhu	r4,0(r3)
    b8cc:	1100000d 	sth	r4,0(r2)
    b8d0:	18c0008b 	ldhu	r3,2(r3)
    b8d4:	10c0008d 	sth	r3,2(r2)
  }
  pcb->local_port = port;
    b8d8:	e0bffd17 	ldw	r2,-12(fp)
    b8dc:	e0ffff0b 	ldhu	r3,-4(fp)
    b8e0:	10c0070d 	sth	r3,28(r2)
  TCP_REG(&tcp_bound_pcbs, pcb);
    b8e4:	d0e8da17 	ldw	r3,-23704(gp)
    b8e8:	e0bffd17 	ldw	r2,-12(fp)
    b8ec:	10c00315 	stw	r3,12(r2)
    b8f0:	e0bffd17 	ldw	r2,-12(fp)
    b8f4:	d0a8da15 	stw	r2,-23704(gp)
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
    b8f8:	e0bfff0b 	ldhu	r2,-4(fp)
    b8fc:	1009883a 	mov	r4,r2
    b900:	00170680 	call	17068 <printf>
  return ERR_OK;
    b904:	0005883a 	mov	r2,zero
}
    b908:	e037883a 	mov	sp,fp
    b90c:	dfc00117 	ldw	ra,4(sp)
    b910:	df000017 	ldw	fp,0(sp)
    b914:	dec00204 	addi	sp,sp,8
    b918:	f800283a 	ret

0000b91c <tcp_accept_null>:
/**
 * Default accept callback if no accept callback is specified by the user.
 */
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
    b91c:	defffc04 	addi	sp,sp,-16
    b920:	df000315 	stw	fp,12(sp)
    b924:	df000304 	addi	fp,sp,12
    b928:	e13ffd15 	stw	r4,-12(fp)
    b92c:	e17ffe15 	stw	r5,-8(fp)
    b930:	3005883a 	mov	r2,r6
    b934:	e0bfff05 	stb	r2,-4(fp)
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
    b938:	00bffec4 	movi	r2,-5
}
    b93c:	e037883a 	mov	sp,fp
    b940:	df000017 	ldw	fp,0(sp)
    b944:	dec00104 	addi	sp,sp,4
    b948:	f800283a 	ret

0000b94c <tcp_listen_with_backlog>:
 *       called like this:
 *             tpcb = tcp_listen(tpcb);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
    b94c:	defffb04 	addi	sp,sp,-20
    b950:	dfc00415 	stw	ra,16(sp)
    b954:	df000315 	stw	fp,12(sp)
    b958:	df000304 	addi	fp,sp,12
    b95c:	e13ffe15 	stw	r4,-8(fp)
    b960:	2805883a 	mov	r2,r5
    b964:	e0bfff05 	stb	r2,-4(fp)
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
    b968:	e0bffe17 	ldw	r2,-8(fp)
    b96c:	10800417 	ldw	r2,16(r2)
    b970:	10000926 	beq	r2,zero,b998 <tcp_listen_with_backlog+0x4c>
    b974:	010000f4 	movhi	r4,3
    b978:	213c2404 	addi	r4,r4,-3952
    b97c:	014000f4 	movhi	r5,3
    b980:	297c3d04 	addi	r5,r5,-3852
    b984:	01805cc4 	movi	r6,371
    b988:	01c000f4 	movhi	r7,3
    b98c:	39fc3804 	addi	r7,r7,-3872
    b990:	00170680 	call	17068 <printf>
    b994:	003fff06 	br	b994 <tcp_listen_with_backlog+0x48>

  /* already listening? */
  if (pcb->state == LISTEN) {
    b998:	e0bffe17 	ldw	r2,-8(fp)
    b99c:	10800417 	ldw	r2,16(r2)
    b9a0:	10800058 	cmpnei	r2,r2,1
    b9a4:	1000021e 	bne	r2,zero,b9b0 <tcp_listen_with_backlog+0x64>
    return pcb;
    b9a8:	e0bffe17 	ldw	r2,-8(fp)
    b9ac:	00005306 	br	bafc <tcp_listen_with_backlog+0x1b0>
  }
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
    b9b0:	010000c4 	movi	r4,3
    b9b4:	0008f0c0 	call	8f0c <memp_malloc>
    b9b8:	e0bffd15 	stw	r2,-12(fp)
  if (lpcb == NULL) {
    b9bc:	e0bffd17 	ldw	r2,-12(fp)
    b9c0:	1000021e 	bne	r2,zero,b9cc <tcp_listen_with_backlog+0x80>
    return NULL;
    b9c4:	0005883a 	mov	r2,zero
    b9c8:	00004c06 	br	bafc <tcp_listen_with_backlog+0x1b0>
  }
  lpcb->callback_arg = pcb->callback_arg;
    b9cc:	e0bffe17 	ldw	r2,-8(fp)
    b9d0:	10c00617 	ldw	r3,24(r2)
    b9d4:	e0bffd17 	ldw	r2,-12(fp)
    b9d8:	10c00615 	stw	r3,24(r2)
  lpcb->local_port = pcb->local_port;
    b9dc:	e0bffe17 	ldw	r2,-8(fp)
    b9e0:	10c0070b 	ldhu	r3,28(r2)
    b9e4:	e0bffd17 	ldw	r2,-12(fp)
    b9e8:	10c0070d 	sth	r3,28(r2)
  lpcb->state = LISTEN;
    b9ec:	e0bffd17 	ldw	r2,-12(fp)
    b9f0:	00c00044 	movi	r3,1
    b9f4:	10c00415 	stw	r3,16(r2)
  lpcb->so_options = pcb->so_options;
    b9f8:	e0bffe17 	ldw	r2,-8(fp)
    b9fc:	10c0020b 	ldhu	r3,8(r2)
    ba00:	e0bffd17 	ldw	r2,-12(fp)
    ba04:	10c0020d 	sth	r3,8(r2)
  lpcb->so_options |= SOF_ACCEPTCONN;
    ba08:	e0bffd17 	ldw	r2,-12(fp)
    ba0c:	1080020b 	ldhu	r2,8(r2)
    ba10:	10800094 	ori	r2,r2,2
    ba14:	1007883a 	mov	r3,r2
    ba18:	e0bffd17 	ldw	r2,-12(fp)
    ba1c:	10c0020d 	sth	r3,8(r2)
  lpcb->ttl = pcb->ttl;
    ba20:	e0bffe17 	ldw	r2,-8(fp)
    ba24:	10c002c3 	ldbu	r3,11(r2)
    ba28:	e0bffd17 	ldw	r2,-12(fp)
    ba2c:	10c002c5 	stb	r3,11(r2)
  lpcb->tos = pcb->tos;
    ba30:	e0bffe17 	ldw	r2,-8(fp)
    ba34:	10c00283 	ldbu	r3,10(r2)
    ba38:	e0bffd17 	ldw	r2,-12(fp)
    ba3c:	10c00285 	stb	r3,10(r2)
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
    ba40:	e0bffe17 	ldw	r2,-8(fp)
    ba44:	10000326 	beq	r2,zero,ba54 <tcp_listen_with_backlog+0x108>
    ba48:	e0bffe17 	ldw	r2,-8(fp)
    ba4c:	10800017 	ldw	r2,0(r2)
    ba50:	00000106 	br	ba58 <tcp_listen_with_backlog+0x10c>
    ba54:	0005883a 	mov	r2,zero
    ba58:	e0fffd17 	ldw	r3,-12(fp)
    ba5c:	18800015 	stw	r2,0(r3)
  TCP_RMV(&tcp_bound_pcbs, pcb);
    ba60:	d0e8da17 	ldw	r3,-23704(gp)
    ba64:	e0bffe17 	ldw	r2,-8(fp)
    ba68:	1880041e 	bne	r3,r2,ba7c <tcp_listen_with_backlog+0x130>
    ba6c:	d0a8da17 	ldw	r2,-23704(gp)
    ba70:	10800317 	ldw	r2,12(r2)
    ba74:	d0a8da15 	stw	r2,-23704(gp)
    ba78:	00001106 	br	bac0 <tcp_listen_with_backlog+0x174>
    ba7c:	d0a8da17 	ldw	r2,-23704(gp)
    ba80:	d0a8d915 	stw	r2,-23708(gp)
    ba84:	00000c06 	br	bab8 <tcp_listen_with_backlog+0x16c>
    ba88:	d0a8d917 	ldw	r2,-23708(gp)
    ba8c:	10c00317 	ldw	r3,12(r2)
    ba90:	e0bffe17 	ldw	r2,-8(fp)
    ba94:	1880051e 	bne	r3,r2,baac <tcp_listen_with_backlog+0x160>
    ba98:	d0a8d917 	ldw	r2,-23708(gp)
    ba9c:	e0fffe17 	ldw	r3,-8(fp)
    baa0:	18c00317 	ldw	r3,12(r3)
    baa4:	10c00315 	stw	r3,12(r2)
    baa8:	00000506 	br	bac0 <tcp_listen_with_backlog+0x174>
    baac:	d0a8d917 	ldw	r2,-23708(gp)
    bab0:	10800317 	ldw	r2,12(r2)
    bab4:	d0a8d915 	stw	r2,-23708(gp)
    bab8:	d0a8d917 	ldw	r2,-23708(gp)
    babc:	103ff21e 	bne	r2,zero,ba88 <tcp_listen_with_backlog+0x13c>
    bac0:	e0bffe17 	ldw	r2,-8(fp)
    bac4:	10000315 	stw	zero,12(r2)
  memp_free(MEMP_TCP_PCB, pcb);
    bac8:	01000084 	movi	r4,2
    bacc:	e17ffe17 	ldw	r5,-8(fp)
    bad0:	00090e80 	call	90e8 <memp_free>
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
    bad4:	e0bffd17 	ldw	r2,-12(fp)
    bad8:	00c00074 	movhi	r3,1
    badc:	18ee4704 	addi	r3,r3,-18148
    bae0:	10c00815 	stw	r3,32(r2)
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
    bae4:	d0e8d817 	ldw	r3,-23712(gp)
    bae8:	e0bffd17 	ldw	r2,-12(fp)
    baec:	10c00315 	stw	r3,12(r2)
    baf0:	e0bffd17 	ldw	r2,-12(fp)
    baf4:	d0a8d815 	stw	r2,-23712(gp)
  return (struct tcp_pcb *)lpcb;
    baf8:	e0bffd17 	ldw	r2,-12(fp)
}
    bafc:	e037883a 	mov	sp,fp
    bb00:	dfc00117 	ldw	ra,4(sp)
    bb04:	df000017 	ldw	fp,0(sp)
    bb08:	dec00204 	addi	sp,sp,8
    bb0c:	f800283a 	ret

0000bb10 <tcp_update_rcv_ann_wnd>:
 *
 * Returns how much extra window would be advertised if we sent an
 * update now.
 */
u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
{
    bb10:	defffd04 	addi	sp,sp,-12
    bb14:	df000215 	stw	fp,8(sp)
    bb18:	df000204 	addi	fp,sp,8
    bb1c:	e13fff15 	stw	r4,-4(fp)
  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
    bb20:	e0bfff17 	ldw	r2,-4(fp)
    bb24:	10c00a17 	ldw	r3,40(r2)
    bb28:	e0bfff17 	ldw	r2,-4(fp)
    bb2c:	10800b0b 	ldhu	r2,44(r2)
    bb30:	10bfffcc 	andi	r2,r2,65535
    bb34:	1885883a 	add	r2,r3,r2
    bb38:	e0bffe15 	stw	r2,-8(fp)

  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
    bb3c:	e0bfff17 	ldw	r2,-4(fp)
    bb40:	10c00c17 	ldw	r3,48(r2)
    bb44:	e0bfff17 	ldw	r2,-4(fp)
    bb48:	10800f0b 	ldhu	r2,60(r2)
    bb4c:	10bfffcc 	andi	r2,r2,65535
    bb50:	10810068 	cmpgeui	r2,r2,1025
    bb54:	1000041e 	bne	r2,zero,bb68 <tcp_update_rcv_ann_wnd+0x58>
    bb58:	e0bfff17 	ldw	r2,-4(fp)
    bb5c:	10800f0b 	ldhu	r2,60(r2)
    bb60:	10bfffcc 	andi	r2,r2,65535
    bb64:	00000106 	br	bb6c <tcp_update_rcv_ann_wnd+0x5c>
    bb68:	00810004 	movi	r2,1024
    bb6c:	1885883a 	add	r2,r3,r2
    bb70:	e0fffe17 	ldw	r3,-8(fp)
    bb74:	1885c83a 	sub	r2,r3,r2
    bb78:	10000916 	blt	r2,zero,bba0 <tcp_update_rcv_ann_wnd+0x90>
    /* we can advertise more window */
    pcb->rcv_ann_wnd = pcb->rcv_wnd;
    bb7c:	e0bfff17 	ldw	r2,-4(fp)
    bb80:	10c00b0b 	ldhu	r3,44(r2)
    bb84:	e0bfff17 	ldw	r2,-4(fp)
    bb88:	10c00b8d 	sth	r3,46(r2)
    return new_right_edge - pcb->rcv_ann_right_edge;
    bb8c:	e0bfff17 	ldw	r2,-4(fp)
    bb90:	10800c17 	ldw	r2,48(r2)
    bb94:	e0fffe17 	ldw	r3,-8(fp)
    bb98:	1885c83a 	sub	r2,r3,r2
    bb9c:	00001306 	br	bbec <tcp_update_rcv_ann_wnd+0xdc>
  } else {
    if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
    bba0:	e0bfff17 	ldw	r2,-4(fp)
    bba4:	10c00a17 	ldw	r3,40(r2)
    bba8:	e0bfff17 	ldw	r2,-4(fp)
    bbac:	10800c17 	ldw	r2,48(r2)
    bbb0:	1885c83a 	sub	r2,r3,r2
    bbb4:	0080030e 	bge	zero,r2,bbc4 <tcp_update_rcv_ann_wnd+0xb4>
      /* Can happen due to other end sending out of advertised window,
       * but within actual available (but not yet advertised) window */
      pcb->rcv_ann_wnd = 0;
    bbb8:	e0bfff17 	ldw	r2,-4(fp)
    bbbc:	10000b8d 	sth	zero,46(r2)
    bbc0:	00000906 	br	bbe8 <tcp_update_rcv_ann_wnd+0xd8>
    } else {
      /* keep the right edge of window constant */
      pcb->rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
    bbc4:	e0bfff17 	ldw	r2,-4(fp)
    bbc8:	10800c17 	ldw	r2,48(r2)
    bbcc:	1007883a 	mov	r3,r2
    bbd0:	e0bfff17 	ldw	r2,-4(fp)
    bbd4:	10800a17 	ldw	r2,40(r2)
    bbd8:	1885c83a 	sub	r2,r3,r2
    bbdc:	1007883a 	mov	r3,r2
    bbe0:	e0bfff17 	ldw	r2,-4(fp)
    bbe4:	10c00b8d 	sth	r3,46(r2)
    }
    return 0;
    bbe8:	0005883a 	mov	r2,zero
  }
}
    bbec:	e037883a 	mov	sp,fp
    bbf0:	df000017 	ldw	fp,0(sp)
    bbf4:	dec00104 	addi	sp,sp,4
    bbf8:	f800283a 	ret

0000bbfc <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
    bbfc:	defffb04 	addi	sp,sp,-20
    bc00:	dfc00415 	stw	ra,16(sp)
    bc04:	df000315 	stw	fp,12(sp)
    bc08:	df000304 	addi	fp,sp,12
    bc0c:	e13ffe15 	stw	r4,-8(fp)
    bc10:	2805883a 	mov	r2,r5
    bc14:	e0bfff0d 	sth	r2,-4(fp)
  int wnd_inflation;

  LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
    bc18:	e0bfff0b 	ldhu	r2,-4(fp)
    bc1c:	e0fffe17 	ldw	r3,-8(fp)
    bc20:	18c00b0b 	ldhu	r3,44(r3)
    bc24:	18ffffcc 	andi	r3,r3,65535
    bc28:	013fffd4 	movui	r4,65535
    bc2c:	20c7c83a 	sub	r3,r4,r3
    bc30:	1880090e 	bge	r3,r2,bc58 <tcp_recved+0x5c>
    bc34:	010000f4 	movhi	r4,3
    bc38:	213c2404 	addi	r4,r4,-3952
    bc3c:	014000f4 	movhi	r5,3
    bc40:	297c4604 	addi	r5,r5,-3816
    bc44:	01806ec4 	movi	r6,443
    bc48:	01c000f4 	movhi	r7,3
    bc4c:	39fc3804 	addi	r7,r7,-3872
    bc50:	00170680 	call	17068 <printf>
    bc54:	003fff06 	br	bc54 <tcp_recved+0x58>
              len <= 0xffff - pcb->rcv_wnd );

  pcb->rcv_wnd += len;
    bc58:	e0bffe17 	ldw	r2,-8(fp)
    bc5c:	10c00b0b 	ldhu	r3,44(r2)
    bc60:	e0bfff0b 	ldhu	r2,-4(fp)
    bc64:	1885883a 	add	r2,r3,r2
    bc68:	1007883a 	mov	r3,r2
    bc6c:	e0bffe17 	ldw	r2,-8(fp)
    bc70:	10c00b0d 	sth	r3,44(r2)
  if (pcb->rcv_wnd > TCP_WND)
    bc74:	e0bffe17 	ldw	r2,-8(fp)
    bc78:	10800b0b 	ldhu	r2,44(r2)
    bc7c:	10bfffcc 	andi	r2,r2,65535
    bc80:	10820070 	cmpltui	r2,r2,2049
    bc84:	1000031e 	bne	r2,zero,bc94 <tcp_recved+0x98>
    pcb->rcv_wnd = TCP_WND;
    bc88:	e0bffe17 	ldw	r2,-8(fp)
    bc8c:	00c20004 	movi	r3,2048
    bc90:	10c00b0d 	sth	r3,44(r2)

  wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
    bc94:	e13ffe17 	ldw	r4,-8(fp)
    bc98:	000bb100 	call	bb10 <tcp_update_rcv_ann_wnd>
    bc9c:	e0bffd15 	stw	r2,-12(fp)

  /* If the change in the right edge of window is significant (default
   * watermark is TCP_WND/2), then send an explicit update now.
   * Otherwise wait for a packet to be sent in the normal course of
   * events (or more window to be available later) */
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) 
    bca0:	e0bffd17 	ldw	r2,-12(fp)
    bca4:	10808010 	cmplti	r2,r2,512
    bca8:	1000081e 	bne	r2,zero,bccc <tcp_recved+0xd0>
    tcp_ack_now(pcb);
    bcac:	e0bffe17 	ldw	r2,-8(fp)
    bcb0:	10800983 	ldbu	r2,38(r2)
    bcb4:	10800094 	ori	r2,r2,2
    bcb8:	1007883a 	mov	r3,r2
    bcbc:	e0bffe17 	ldw	r2,-8(fp)
    bcc0:	10c00985 	stb	r3,38(r2)
    bcc4:	e13ffe17 	ldw	r4,-8(fp)
    bcc8:	0012b000 	call	12b00 <tcp_output>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
    bccc:	e0bffe17 	ldw	r2,-8(fp)
    bcd0:	10800b0b 	ldhu	r2,44(r2)
    bcd4:	10bfffcc 	andi	r2,r2,65535
    bcd8:	00c20004 	movi	r3,2048
    bcdc:	1885c83a 	sub	r2,r3,r2
    bce0:	1009883a 	mov	r4,r2
    bce4:	00170680 	call	17068 <printf>
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
    bce8:	e037883a 	mov	sp,fp
    bcec:	dfc00117 	ldw	ra,4(sp)
    bcf0:	df000017 	ldw	fp,0(sp)
    bcf4:	dec00204 	addi	sp,sp,8
    bcf8:	f800283a 	ret

0000bcfc <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
    bcfc:	defffe04 	addi	sp,sp,-8
    bd00:	df000115 	stw	fp,4(sp)
    bd04:	df000104 	addi	fp,sp,4
    bd08:	00000506 	br	bd20 <tcp_new_port+0x24>
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    bd0c:	0001883a 	nop
    bd10:	00000306 	br	bd20 <tcp_new_port+0x24>
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    bd14:	0001883a 	nop
    bd18:	00000106 	br	bd20 <tcp_new_port+0x24>
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    bd1c:	0001883a 	nop
#define TCP_LOCAL_PORT_RANGE_END   0x7fff
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    bd20:	d0a0060b 	ldhu	r2,-32744(gp)
    bd24:	10800044 	addi	r2,r2,1
    bd28:	d0a0060d 	sth	r2,-32744(gp)
    bd2c:	d0a0060b 	ldhu	r2,-32744(gp)
    bd30:	10bfffcc 	andi	r2,r2,65535
    bd34:	10a0001c 	xori	r2,r2,32768
    bd38:	10a00004 	addi	r2,r2,-32768
    bd3c:	1000020e 	bge	r2,zero,bd48 <tcp_new_port+0x4c>
    port = TCP_LOCAL_PORT_RANGE_START;
    bd40:	00840004 	movi	r2,4096
    bd44:	d0a0060d 	sth	r2,-32744(gp)
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    bd48:	d0a8d617 	ldw	r2,-23720(gp)
    bd4c:	e0bfff15 	stw	r2,-4(fp)
    bd50:	00000906 	br	bd78 <tcp_new_port+0x7c>
    if (pcb->local_port == port) {
    bd54:	e0bfff17 	ldw	r2,-4(fp)
    bd58:	10c0070b 	ldhu	r3,28(r2)
    bd5c:	d0a0060b 	ldhu	r2,-32744(gp)
    bd60:	18ffffcc 	andi	r3,r3,65535
    bd64:	10bfffcc 	andi	r2,r2,65535
    bd68:	18bfe826 	beq	r3,r2,bd0c <tcp_new_port+0x10>
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    bd6c:	e0bfff17 	ldw	r2,-4(fp)
    bd70:	10800317 	ldw	r2,12(r2)
    bd74:	e0bfff15 	stw	r2,-4(fp)
    bd78:	e0bfff17 	ldw	r2,-4(fp)
    bd7c:	103ff51e 	bne	r2,zero,bd54 <tcp_new_port+0x58>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    bd80:	d0a8db17 	ldw	r2,-23700(gp)
    bd84:	e0bfff15 	stw	r2,-4(fp)
    bd88:	00000906 	br	bdb0 <tcp_new_port+0xb4>
    if (pcb->local_port == port) {
    bd8c:	e0bfff17 	ldw	r2,-4(fp)
    bd90:	10c0070b 	ldhu	r3,28(r2)
    bd94:	d0a0060b 	ldhu	r2,-32744(gp)
    bd98:	18ffffcc 	andi	r3,r3,65535
    bd9c:	10bfffcc 	andi	r2,r2,65535
    bda0:	18bfdc26 	beq	r3,r2,bd14 <tcp_new_port+0x18>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    bda4:	e0bfff17 	ldw	r2,-4(fp)
    bda8:	10800317 	ldw	r2,12(r2)
    bdac:	e0bfff15 	stw	r2,-4(fp)
    bdb0:	e0bfff17 	ldw	r2,-4(fp)
    bdb4:	103ff51e 	bne	r2,zero,bd8c <tcp_new_port+0x90>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
    bdb8:	d0a8d817 	ldw	r2,-23712(gp)
    bdbc:	e0bfff15 	stw	r2,-4(fp)
    bdc0:	00000906 	br	bde8 <tcp_new_port+0xec>
    if (pcb->local_port == port) {
    bdc4:	e0bfff17 	ldw	r2,-4(fp)
    bdc8:	10c0070b 	ldhu	r3,28(r2)
    bdcc:	d0a0060b 	ldhu	r2,-32744(gp)
    bdd0:	18ffffcc 	andi	r3,r3,65535
    bdd4:	10bfffcc 	andi	r2,r2,65535
    bdd8:	18bfd026 	beq	r3,r2,bd1c <tcp_new_port+0x20>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
    bddc:	e0bfff17 	ldw	r2,-4(fp)
    bde0:	10800317 	ldw	r2,12(r2)
    bde4:	e0bfff15 	stw	r2,-4(fp)
    bde8:	e0bfff17 	ldw	r2,-4(fp)
    bdec:	103ff51e 	bne	r2,zero,bdc4 <tcp_new_port+0xc8>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  return port;
    bdf0:	d0a0060b 	ldhu	r2,-32744(gp)
}
    bdf4:	e037883a 	mov	sp,fp
    bdf8:	df000017 	ldw	fp,0(sp)
    bdfc:	dec00104 	addi	sp,sp,4
    be00:	f800283a 	ret

0000be04 <tcp_connect>:
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port,
      err_t (* connected)(void *arg, struct tcp_pcb *tpcb, err_t err))
{
    be04:	defff604 	addi	sp,sp,-40
    be08:	dfc00915 	stw	ra,36(sp)
    be0c:	df000815 	stw	fp,32(sp)
    be10:	df000804 	addi	fp,sp,32
    be14:	e13ffc15 	stw	r4,-16(fp)
    be18:	e17ffd15 	stw	r5,-12(fp)
    be1c:	3005883a 	mov	r2,r6
    be20:	e1ffff15 	stw	r7,-4(fp)
    be24:	e0bffe0d 	sth	r2,-8(fp)
  err_t ret;
  u32_t iss;

  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
    be28:	e0bffc17 	ldw	r2,-16(fp)
    be2c:	10800417 	ldw	r2,16(r2)
    be30:	10000926 	beq	r2,zero,be58 <tcp_connect+0x54>
    be34:	010000f4 	movhi	r4,3
    be38:	213c2404 	addi	r4,r4,-3952
    be3c:	014000f4 	movhi	r5,3
    be40:	297c4f04 	addi	r5,r5,-3780
    be44:	01808204 	movi	r6,520
    be48:	01c000f4 	movhi	r7,3
    be4c:	39fc3804 	addi	r7,r7,-3872
    be50:	00170680 	call	17068 <printf>
    be54:	003fff06 	br	be54 <tcp_connect+0x50>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
    be58:	e0bffe0b 	ldhu	r2,-8(fp)
    be5c:	1009883a 	mov	r4,r2
    be60:	00170680 	call	17068 <printf>
  if (ipaddr != NULL) {
    be64:	e0bffd17 	ldw	r2,-12(fp)
    be68:	10000e26 	beq	r2,zero,bea4 <tcp_connect+0xa0>
    pcb->remote_ip = *ipaddr;
    be6c:	e0bffc17 	ldw	r2,-16(fp)
    be70:	e0fffd17 	ldw	r3,-12(fp)
    be74:	1900000b 	ldhu	r4,0(r3)
    be78:	1100010d 	sth	r4,4(r2)
    be7c:	18c0008b 	ldhu	r3,2(r3)
    be80:	10c0018d 	sth	r3,6(r2)
  } else {
    return ERR_VAL;
  }
  pcb->remote_port = port;
    be84:	e0bffc17 	ldw	r2,-16(fp)
    be88:	e0fffe0b 	ldhu	r3,-8(fp)
    be8c:	10c0090d 	sth	r3,36(r2)
  if (pcb->local_port == 0) {
    be90:	e0bffc17 	ldw	r2,-16(fp)
    be94:	1080070b 	ldhu	r2,28(r2)
    be98:	10bfffcc 	andi	r2,r2,65535
    be9c:	10000326 	beq	r2,zero,beac <tcp_connect+0xa8>
    bea0:	00000506 	br	beb8 <tcp_connect+0xb4>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
    pcb->remote_ip = *ipaddr;
  } else {
    return ERR_VAL;
    bea4:	00bffdc4 	movi	r2,-9
    bea8:	00006606 	br	c044 <tcp_connect+0x240>
  }
  pcb->remote_port = port;
  if (pcb->local_port == 0) {
    pcb->local_port = tcp_new_port();
    beac:	000bcfc0 	call	bcfc <tcp_new_port>
    beb0:	e0fffc17 	ldw	r3,-16(fp)
    beb4:	1880070d 	sth	r2,28(r3)
  }
  iss = tcp_next_iss();
    beb8:	000d4100 	call	d410 <tcp_next_iss>
    bebc:	e0bffa15 	stw	r2,-24(fp)
  pcb->rcv_nxt = 0;
    bec0:	e0bffc17 	ldw	r2,-16(fp)
    bec4:	10000a15 	stw	zero,40(r2)
  pcb->snd_nxt = iss;
    bec8:	e0bffc17 	ldw	r2,-16(fp)
    becc:	e0fffa17 	ldw	r3,-24(fp)
    bed0:	10c01715 	stw	r3,92(r2)
  pcb->lastack = iss - 1;
    bed4:	e0bffa17 	ldw	r2,-24(fp)
    bed8:	10ffffc4 	addi	r3,r2,-1
    bedc:	e0bffc17 	ldw	r2,-16(fp)
    bee0:	10c01415 	stw	r3,80(r2)
  pcb->snd_lbb = iss - 1;
    bee4:	e0bffa17 	ldw	r2,-24(fp)
    bee8:	10ffffc4 	addi	r3,r2,-1
    beec:	e0bffc17 	ldw	r2,-16(fp)
    bef0:	10c01b15 	stw	r3,108(r2)
  pcb->rcv_wnd = TCP_WND;
    bef4:	e0bffc17 	ldw	r2,-16(fp)
    bef8:	00c20004 	movi	r3,2048
    befc:	10c00b0d 	sth	r3,44(r2)
  pcb->rcv_ann_wnd = TCP_WND;
    bf00:	e0bffc17 	ldw	r2,-16(fp)
    bf04:	00c20004 	movi	r3,2048
    bf08:	10c00b8d 	sth	r3,46(r2)
  pcb->rcv_ann_right_edge = pcb->rcv_nxt;
    bf0c:	e0bffc17 	ldw	r2,-16(fp)
    bf10:	10c00a17 	ldw	r3,40(r2)
    bf14:	e0bffc17 	ldw	r2,-16(fp)
    bf18:	10c00c15 	stw	r3,48(r2)
  pcb->snd_wnd = TCP_WND;
    bf1c:	e0bffc17 	ldw	r2,-16(fp)
    bf20:	00c20004 	movi	r3,2048
    bf24:	10c0180d 	sth	r3,96(r2)
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
    bf28:	e0bffc17 	ldw	r2,-16(fp)
    bf2c:	00c08604 	movi	r3,536
    bf30:	10c00f0d 	sth	r3,60(r2)
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
    bf34:	e0bffc17 	ldw	r2,-16(fp)
    bf38:	10800f0b 	ldhu	r2,60(r2)
    bf3c:	10bfffcc 	andi	r2,r2,65535
    bf40:	1009883a 	mov	r4,r2
    bf44:	e17ffd17 	ldw	r5,-12(fp)
    bf48:	000d4400 	call	d440 <tcp_eff_send_mss>
    bf4c:	e0fffc17 	ldw	r3,-16(fp)
    bf50:	18800f0d 	sth	r2,60(r3)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
    bf54:	e0bffc17 	ldw	r2,-16(fp)
    bf58:	00c00044 	movi	r3,1
    bf5c:	10c0158d 	sth	r3,86(r2)
  pcb->ssthresh = pcb->mss * 10;
    bf60:	e0bffc17 	ldw	r2,-16(fp)
    bf64:	10800f0b 	ldhu	r2,60(r2)
    bf68:	108002a4 	muli	r2,r2,10
    bf6c:	1007883a 	mov	r3,r2
    bf70:	e0bffc17 	ldw	r2,-16(fp)
    bf74:	10c0160d 	sth	r3,88(r2)
  pcb->state = SYN_SENT;
    bf78:	e0bffc17 	ldw	r2,-16(fp)
    bf7c:	00c00084 	movi	r3,2
    bf80:	10c00415 	stw	r3,16(r2)
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
    bf84:	e0bffc17 	ldw	r2,-16(fp)
    bf88:	e0ffff17 	ldw	r3,-4(fp)
    bf8c:	10c02415 	stw	r3,144(r2)
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
    bf90:	d0e8da17 	ldw	r3,-23704(gp)
    bf94:	e0bffc17 	ldw	r2,-16(fp)
    bf98:	1880041e 	bne	r3,r2,bfac <tcp_connect+0x1a8>
    bf9c:	d0a8da17 	ldw	r2,-23704(gp)
    bfa0:	10800317 	ldw	r2,12(r2)
    bfa4:	d0a8da15 	stw	r2,-23704(gp)
    bfa8:	00001106 	br	bff0 <tcp_connect+0x1ec>
    bfac:	d0a8da17 	ldw	r2,-23704(gp)
    bfb0:	d0a8d915 	stw	r2,-23708(gp)
    bfb4:	00000c06 	br	bfe8 <tcp_connect+0x1e4>
    bfb8:	d0a8d917 	ldw	r2,-23708(gp)
    bfbc:	10c00317 	ldw	r3,12(r2)
    bfc0:	e0bffc17 	ldw	r2,-16(fp)
    bfc4:	1880051e 	bne	r3,r2,bfdc <tcp_connect+0x1d8>
    bfc8:	d0a8d917 	ldw	r2,-23708(gp)
    bfcc:	e0fffc17 	ldw	r3,-16(fp)
    bfd0:	18c00317 	ldw	r3,12(r3)
    bfd4:	10c00315 	stw	r3,12(r2)
    bfd8:	00000506 	br	bff0 <tcp_connect+0x1ec>
    bfdc:	d0a8d917 	ldw	r2,-23708(gp)
    bfe0:	10800317 	ldw	r2,12(r2)
    bfe4:	d0a8d915 	stw	r2,-23708(gp)
    bfe8:	d0a8d917 	ldw	r2,-23708(gp)
    bfec:	103ff21e 	bne	r2,zero,bfb8 <tcp_connect+0x1b4>
    bff0:	e0bffc17 	ldw	r2,-16(fp)
    bff4:	10000315 	stw	zero,12(r2)
  TCP_REG(&tcp_active_pcbs, pcb);
    bff8:	d0e8d617 	ldw	r3,-23720(gp)
    bffc:	e0bffc17 	ldw	r2,-16(fp)
    c000:	10c00315 	stw	r3,12(r2)
    c004:	e0bffc17 	ldw	r2,-16(fp)
    c008:	d0a8d615 	stw	r2,-23720(gp)

  snmp_inc_tcpactiveopens();
  
  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, TF_SEG_OPTS_MSS
    c00c:	d8000015 	stw	zero,0(sp)
    c010:	00800044 	movi	r2,1
    c014:	d8800115 	stw	r2,4(sp)
    c018:	e13ffc17 	ldw	r4,-16(fp)
    c01c:	000b883a 	mov	r5,zero
    c020:	000d883a 	mov	r6,zero
    c024:	01c00084 	movi	r7,2
    c028:	0011c500 	call	11c50 <tcp_enqueue>
    c02c:	e0bffb05 	stb	r2,-20(fp)
#if LWIP_TCP_TIMESTAMPS
                    | TF_SEG_OPTS_TS
#endif
                    );
  if (ret == ERR_OK) { 
    c030:	e0bffb07 	ldb	r2,-20(fp)
    c034:	1000021e 	bne	r2,zero,c040 <tcp_connect+0x23c>
    tcp_output(pcb);
    c038:	e13ffc17 	ldw	r4,-16(fp)
    c03c:	0012b000 	call	12b00 <tcp_output>
  }
  return ret;
    c040:	e0bffb03 	ldbu	r2,-20(fp)
} 
    c044:	e037883a 	mov	sp,fp
    c048:	dfc00117 	ldw	ra,4(sp)
    c04c:	df000017 	ldw	fp,0(sp)
    c050:	dec00204 	addi	sp,sp,8
    c054:	f800283a 	ret

0000c058 <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
    c058:	defff704 	addi	sp,sp,-36
    c05c:	dfc00815 	stw	ra,32(sp)
    c060:	df000715 	stw	fp,28(sp)
    c064:	df000704 	addi	fp,sp,28
  u16_t eff_wnd;
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  u8_t pcb_reset;       /* flag if a RST should be sent when removing */
  err_t err;

  err = ERR_OK;
    c068:	e03ffd85 	stb	zero,-10(fp)

  ++tcp_ticks;
    c06c:	d0a8d717 	ldw	r2,-23716(gp)
    c070:	10800044 	addi	r2,r2,1
    c074:	d0a8d715 	stw	r2,-23716(gp)

  /* Steps through all of the active PCBs. */
  prev = NULL;
    c078:	e03ffc15 	stw	zero,-16(fp)
  pcb = tcp_active_pcbs;
    c07c:	d0a8d617 	ldw	r2,-23720(gp)
    c080:	e0bffb15 	stw	r2,-20(fp)
  if (pcb == NULL) {
    c084:	e0bffb17 	ldw	r2,-20(fp)
    c088:	1001cc1e 	bne	r2,zero,c7bc <tcp_slowtmr+0x764>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
    c08c:	010000f4 	movhi	r4,3
    c090:	213c5c04 	addi	r4,r4,-3728
    c094:	00172f80 	call	172f8 <puts>
  }
  while (pcb != NULL) {
    c098:	0001c806 	br	c7bc <tcp_slowtmr+0x764>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    c09c:	010000f4 	movhi	r4,3
    c0a0:	213c6304 	addi	r4,r4,-3700
    c0a4:	00172f80 	call	172f8 <puts>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    c0a8:	e0bffb17 	ldw	r2,-20(fp)
    c0ac:	10800417 	ldw	r2,16(r2)
    c0b0:	1000091e 	bne	r2,zero,c0d8 <tcp_slowtmr+0x80>
    c0b4:	010000f4 	movhi	r4,3
    c0b8:	213c2404 	addi	r4,r4,-3952
    c0bc:	014000f4 	movhi	r5,3
    c0c0:	297c6c04 	addi	r5,r5,-3664
    c0c4:	01809544 	movi	r6,597
    c0c8:	01c000f4 	movhi	r7,3
    c0cc:	39fc3804 	addi	r7,r7,-3872
    c0d0:	00170680 	call	17068 <printf>
    c0d4:	003fff06 	br	c0d4 <tcp_slowtmr+0x7c>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    c0d8:	e0bffb17 	ldw	r2,-20(fp)
    c0dc:	10800417 	ldw	r2,16(r2)
    c0e0:	10800058 	cmpnei	r2,r2,1
    c0e4:	1000091e 	bne	r2,zero,c10c <tcp_slowtmr+0xb4>
    c0e8:	010000f4 	movhi	r4,3
    c0ec:	213c2404 	addi	r4,r4,-3952
    c0f0:	014000f4 	movhi	r5,3
    c0f4:	297c7704 	addi	r5,r5,-3620
    c0f8:	01809584 	movi	r6,598
    c0fc:	01c000f4 	movhi	r7,3
    c100:	39fc3804 	addi	r7,r7,-3872
    c104:	00170680 	call	17068 <printf>
    c108:	003fff06 	br	c108 <tcp_slowtmr+0xb0>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
    c10c:	e0bffb17 	ldw	r2,-20(fp)
    c110:	10800417 	ldw	r2,16(r2)
    c114:	10800298 	cmpnei	r2,r2,10
    c118:	1000091e 	bne	r2,zero,c140 <tcp_slowtmr+0xe8>
    c11c:	010000f4 	movhi	r4,3
    c120:	213c2404 	addi	r4,r4,-3952
    c124:	014000f4 	movhi	r5,3
    c128:	297c8204 	addi	r5,r5,-3576
    c12c:	018095c4 	movi	r6,599
    c130:	01c000f4 	movhi	r7,3
    c134:	39fc3804 	addi	r7,r7,-3872
    c138:	00170680 	call	17068 <printf>
    c13c:	003fff06 	br	c13c <tcp_slowtmr+0xe4>

    pcb_remove = 0;
    c140:	e03ffd05 	stb	zero,-12(fp)
    pcb_reset = 0;
    c144:	e03ffd45 	stb	zero,-11(fp)

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
    c148:	e0bffb17 	ldw	r2,-20(fp)
    c14c:	10800417 	ldw	r2,16(r2)
    c150:	10800098 	cmpnei	r2,r2,2
    c154:	10000c1e 	bne	r2,zero,c188 <tcp_slowtmr+0x130>
    c158:	e0bffb17 	ldw	r2,-20(fp)
    c15c:	10801383 	ldbu	r2,78(r2)
    c160:	10803fcc 	andi	r2,r2,255
    c164:	10800198 	cmpnei	r2,r2,6
    c168:	1000071e 	bne	r2,zero,c188 <tcp_slowtmr+0x130>
      ++pcb_remove;
    c16c:	e0bffd03 	ldbu	r2,-12(fp)
    c170:	10800044 	addi	r2,r2,1
    c174:	e0bffd05 	stb	r2,-12(fp)
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    c178:	010000f4 	movhi	r4,3
    c17c:	213c8e04 	addi	r4,r4,-3528
    c180:	00172f80 	call	172f8 <puts>
    c184:	00008c06 	br	c3b8 <tcp_slowtmr+0x360>
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
    c188:	e0bffb17 	ldw	r2,-20(fp)
    c18c:	10801383 	ldbu	r2,78(r2)
    c190:	10803fcc 	andi	r2,r2,255
    c194:	10800318 	cmpnei	r2,r2,12
    c198:	1000071e 	bne	r2,zero,c1b8 <tcp_slowtmr+0x160>
      ++pcb_remove;
    c19c:	e0bffd03 	ldbu	r2,-12(fp)
    c1a0:	10800044 	addi	r2,r2,1
    c1a4:	e0bffd05 	stb	r2,-12(fp)
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    c1a8:	010000f4 	movhi	r4,3
    c1ac:	213c9804 	addi	r4,r4,-3488
    c1b0:	00172f80 	call	172f8 <puts>
    c1b4:	00008006 	br	c3b8 <tcp_slowtmr+0x360>
    } else {
      if (pcb->persist_backoff > 0) {
    c1b8:	e0bffb17 	ldw	r2,-20(fp)
    c1bc:	10802903 	ldbu	r2,164(r2)
    c1c0:	10803fcc 	andi	r2,r2,255
    c1c4:	10002026 	beq	r2,zero,c248 <tcp_slowtmr+0x1f0>
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
    c1c8:	e0bffb17 	ldw	r2,-20(fp)
    c1cc:	10802817 	ldw	r2,160(r2)
    c1d0:	10c00044 	addi	r3,r2,1
    c1d4:	e0bffb17 	ldw	r2,-20(fp)
    c1d8:	10c02815 	stw	r3,160(r2)
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
    c1dc:	e0bffb17 	ldw	r2,-20(fp)
    c1e0:	10c02817 	ldw	r3,160(r2)
    c1e4:	e0bffb17 	ldw	r2,-20(fp)
    c1e8:	10802903 	ldbu	r2,164(r2)
    c1ec:	10803fcc 	andi	r2,r2,255
    c1f0:	113fffc4 	addi	r4,r2,-1
    c1f4:	d0a00304 	addi	r2,gp,-32756
    c1f8:	2085883a 	add	r2,r4,r2
    c1fc:	10800003 	ldbu	r2,0(r2)
    c200:	10803fcc 	andi	r2,r2,255
    c204:	18806c36 	bltu	r3,r2,c3b8 <tcp_slowtmr+0x360>
          pcb->persist_cnt = 0;
    c208:	e0bffb17 	ldw	r2,-20(fp)
    c20c:	10002815 	stw	zero,160(r2)
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
    c210:	e0bffb17 	ldw	r2,-20(fp)
    c214:	10802903 	ldbu	r2,164(r2)
    c218:	10803fcc 	andi	r2,r2,255
    c21c:	108001e8 	cmpgeui	r2,r2,7
    c220:	1000061e 	bne	r2,zero,c23c <tcp_slowtmr+0x1e4>
            pcb->persist_backoff++;
    c224:	e0bffb17 	ldw	r2,-20(fp)
    c228:	10802903 	ldbu	r2,164(r2)
    c22c:	10800044 	addi	r2,r2,1
    c230:	1007883a 	mov	r3,r2
    c234:	e0bffb17 	ldw	r2,-20(fp)
    c238:	10c02905 	stb	r3,164(r2)
          }
          tcp_zero_window_probe(pcb);
    c23c:	e13ffb17 	ldw	r4,-20(fp)
    c240:	0013f6c0 	call	13f6c <tcp_zero_window_probe>
    c244:	00005c06 	br	c3b8 <tcp_slowtmr+0x360>
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0)
    c248:	e0bffb17 	ldw	r2,-20(fp)
    c24c:	10800e8b 	ldhu	r2,58(r2)
    c250:	10bfffcc 	andi	r2,r2,65535
    c254:	10a0001c 	xori	r2,r2,32768
    c258:	10a00004 	addi	r2,r2,-32768
    c25c:	10000616 	blt	r2,zero,c278 <tcp_slowtmr+0x220>
          ++pcb->rtime;
    c260:	e0bffb17 	ldw	r2,-20(fp)
    c264:	10800e8b 	ldhu	r2,58(r2)
    c268:	10800044 	addi	r2,r2,1
    c26c:	1007883a 	mov	r3,r2
    c270:	e0bffb17 	ldw	r2,-20(fp)
    c274:	10c00e8d 	sth	r3,58(r2)

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
    c278:	e0bffb17 	ldw	r2,-20(fp)
    c27c:	10801f17 	ldw	r2,124(r2)
    c280:	10004d26 	beq	r2,zero,c3b8 <tcp_slowtmr+0x360>
    c284:	e0bffb17 	ldw	r2,-20(fp)
    c288:	10c00e8b 	ldhu	r3,58(r2)
    c28c:	e0bffb17 	ldw	r2,-20(fp)
    c290:	1080130b 	ldhu	r2,76(r2)
    c294:	18ffffcc 	andi	r3,r3,65535
    c298:	18e0001c 	xori	r3,r3,32768
    c29c:	18e00004 	addi	r3,r3,-32768
    c2a0:	10bfffcc 	andi	r2,r2,65535
    c2a4:	10a0001c 	xori	r2,r2,32768
    c2a8:	10a00004 	addi	r2,r2,-32768
    c2ac:	18804216 	blt	r3,r2,c3b8 <tcp_slowtmr+0x360>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
    c2b0:	e0bffb17 	ldw	r2,-20(fp)
    c2b4:	10800417 	ldw	r2,16(r2)
    c2b8:	108000a0 	cmpeqi	r2,r2,2
    c2bc:	10001b1e 	bne	r2,zero,c32c <tcp_slowtmr+0x2d4>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
    c2c0:	e0bffb17 	ldw	r2,-20(fp)
    c2c4:	1080120b 	ldhu	r2,72(r2)
    c2c8:	10bfffcc 	andi	r2,r2,65535
    c2cc:	10a0001c 	xori	r2,r2,32768
    c2d0:	10a00004 	addi	r2,r2,-32768
    c2d4:	1005d0fa 	srai	r2,r2,3
    c2d8:	10ffffcc 	andi	r3,r2,65535
    c2dc:	18e0001c 	xori	r3,r3,32768
    c2e0:	18e00004 	addi	r3,r3,-32768
    c2e4:	e0bffb17 	ldw	r2,-20(fp)
    c2e8:	1080128b 	ldhu	r2,74(r2)
    c2ec:	10bfffcc 	andi	r2,r2,65535
    c2f0:	10a0001c 	xori	r2,r2,32768
    c2f4:	10a00004 	addi	r2,r2,-32768
    c2f8:	1887883a 	add	r3,r3,r2
    c2fc:	e0bffb17 	ldw	r2,-20(fp)
    c300:	10801383 	ldbu	r2,78(r2)
    c304:	10803fcc 	andi	r2,r2,255
    c308:	010000f4 	movhi	r4,3
    c30c:	213c1a84 	addi	r4,r4,-3990
    c310:	2085883a 	add	r2,r4,r2
    c314:	10800003 	ldbu	r2,0(r2)
    c318:	10803fcc 	andi	r2,r2,255
    c31c:	1884983a 	sll	r2,r3,r2
    c320:	1007883a 	mov	r3,r2
    c324:	e0bffb17 	ldw	r2,-20(fp)
    c328:	10c0130d 	sth	r3,76(r2)
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
    c32c:	e0bffb17 	ldw	r2,-20(fp)
    c330:	10000e8d 	sth	zero,58(r2)

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
    c334:	e0bffb17 	ldw	r2,-20(fp)
    c338:	1080180b 	ldhu	r2,96(r2)
    c33c:	e0fffb17 	ldw	r3,-20(fp)
    c340:	18c0158b 	ldhu	r3,86(r3)
    c344:	113fffcc 	andi	r4,r2,65535
    c348:	197fffcc 	andi	r5,r3,65535
    c34c:	2900012e 	bgeu	r5,r4,c354 <tcp_slowtmr+0x2fc>
    c350:	1805883a 	mov	r2,r3
    c354:	e0bffe0d 	sth	r2,-8(fp)
          pcb->ssthresh = eff_wnd >> 1;
    c358:	e0bffe0b 	ldhu	r2,-8(fp)
    c35c:	1004d07a 	srli	r2,r2,1
    c360:	1007883a 	mov	r3,r2
    c364:	e0bffb17 	ldw	r2,-20(fp)
    c368:	10c0160d 	sth	r3,88(r2)
          if (pcb->ssthresh < pcb->mss) {
    c36c:	e0bffb17 	ldw	r2,-20(fp)
    c370:	10c0160b 	ldhu	r3,88(r2)
    c374:	e0bffb17 	ldw	r2,-20(fp)
    c378:	10800f0b 	ldhu	r2,60(r2)
    c37c:	18ffffcc 	andi	r3,r3,65535
    c380:	10bfffcc 	andi	r2,r2,65535
    c384:	1880062e 	bgeu	r3,r2,c3a0 <tcp_slowtmr+0x348>
            pcb->ssthresh = pcb->mss * 2;
    c388:	e0bffb17 	ldw	r2,-20(fp)
    c38c:	10800f0b 	ldhu	r2,60(r2)
    c390:	1085883a 	add	r2,r2,r2
    c394:	1007883a 	mov	r3,r2
    c398:	e0bffb17 	ldw	r2,-20(fp)
    c39c:	10c0160d 	sth	r3,88(r2)
          }
          pcb->cwnd = pcb->mss;
    c3a0:	e0bffb17 	ldw	r2,-20(fp)
    c3a4:	10c00f0b 	ldhu	r3,60(r2)
    c3a8:	e0bffb17 	ldw	r2,-20(fp)
    c3ac:	10c0158d 	sth	r3,86(r2)
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
    c3b0:	e13ffb17 	ldw	r4,-20(fp)
    c3b4:	00139d00 	call	139d0 <tcp_rexmit_rto>
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
    c3b8:	e0bffb17 	ldw	r2,-20(fp)
    c3bc:	10800417 	ldw	r2,16(r2)
    c3c0:	10800198 	cmpnei	r2,r2,6
    c3c4:	10000c1e 	bne	r2,zero,c3f8 <tcp_slowtmr+0x3a0>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
    c3c8:	d0e8d717 	ldw	r3,-23716(gp)
    c3cc:	e0bffb17 	ldw	r2,-20(fp)
    c3d0:	10800d17 	ldw	r2,52(r2)
    c3d4:	1885c83a 	sub	r2,r3,r2
    c3d8:	10800a70 	cmpltui	r2,r2,41
    c3dc:	1000061e 	bne	r2,zero,c3f8 <tcp_slowtmr+0x3a0>
          TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
    c3e0:	e0bffd03 	ldbu	r2,-12(fp)
    c3e4:	10800044 	addi	r2,r2,1
    c3e8:	e0bffd05 	stb	r2,-12(fp)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
    c3ec:	010000f4 	movhi	r4,3
    c3f0:	213ca204 	addi	r4,r4,-3448
    c3f4:	00172f80 	call	172f8 <puts>
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
    c3f8:	e0bffb17 	ldw	r2,-20(fp)
    c3fc:	1080020b 	ldhu	r2,8(r2)
    c400:	10bfffcc 	andi	r2,r2,65535
    c404:	1080020c 	andi	r2,r2,8
    c408:	10004326 	beq	r2,zero,c518 <tcp_slowtmr+0x4c0>
       ((pcb->state == ESTABLISHED) || 
    c40c:	e0bffb17 	ldw	r2,-20(fp)
    c410:	10800417 	ldw	r2,16(r2)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
    c414:	10800120 	cmpeqi	r2,r2,4
    c418:	1000041e 	bne	r2,zero,c42c <tcp_slowtmr+0x3d4>
       ((pcb->state == ESTABLISHED) || 
        (pcb->state == CLOSE_WAIT))) {
    c41c:	e0bffb17 	ldw	r2,-20(fp)
    c420:	10800417 	ldw	r2,16(r2)
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
       ((pcb->state == ESTABLISHED) || 
    c424:	108001d8 	cmpnei	r2,r2,7
    c428:	10003b1e 	bne	r2,zero,c518 <tcp_slowtmr+0x4c0>
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
    c42c:	d0e8d717 	ldw	r3,-23716(gp)
    c430:	e0bffb17 	ldw	r2,-20(fp)
    c434:	10800d17 	ldw	r2,52(r2)
    c438:	1885c83a 	sub	r2,r3,r2
         (pcb->keep_idle + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)
    c43c:	e0fffb17 	ldw	r3,-20(fp)
    c440:	19002717 	ldw	r4,156(r3)
    c444:	00c002b4 	movhi	r3,10
    c448:	18d32e04 	addi	r3,r3,19640
    c44c:	20c9883a 	add	r4,r4,r3
    c450:	00c07d04 	movi	r3,500
    c454:	20c7203a 	divu	r3,r4,r3
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
    c458:	1880172e 	bgeu	r3,r2,c4b8 <tcp_slowtmr+0x460>
         (pcb->keep_idle + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)
#endif /* LWIP_TCP_KEEPALIVE */
      {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
    c45c:	e0bffb17 	ldw	r2,-20(fp)
    c460:	10800117 	ldw	r2,4(r2)
    c464:	1004d63a 	srli	r2,r2,24
    c468:	10803fcc 	andi	r2,r2,255
    c46c:	1007883a 	mov	r3,r2
    c470:	e0bffb17 	ldw	r2,-20(fp)
    c474:	10800117 	ldw	r2,4(r2)
    c478:	1004d23a 	srli	r2,r2,8
    c47c:	1009883a 	mov	r4,r2
    c480:	00bfc004 	movi	r2,-256
    c484:	2084703a 	and	r2,r4,r2
    c488:	1884b03a 	or	r2,r3,r2
    c48c:	10bfffcc 	andi	r2,r2,65535
    c490:	10803fcc 	andi	r2,r2,255
    c494:	1009883a 	mov	r4,r2
    c498:	00170680 	call	17068 <printf>
                                ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                                ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));
        
        ++pcb_remove;
    c49c:	e0bffd03 	ldbu	r2,-12(fp)
    c4a0:	10800044 	addi	r2,r2,1
    c4a4:	e0bffd05 	stb	r2,-12(fp)
        ++pcb_reset;
    c4a8:	e0bffd43 	ldbu	r2,-11(fp)
    c4ac:	10800044 	addi	r2,r2,1
    c4b0:	e0bffd45 	stb	r2,-11(fp)
    c4b4:	00001806 	br	c518 <tcp_slowtmr+0x4c0>
#if LWIP_TCP_KEEPALIVE
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
    c4b8:	d0e8d717 	ldw	r3,-23716(gp)
    c4bc:	e0bffb17 	ldw	r2,-20(fp)
    c4c0:	10800d17 	ldw	r2,52(r2)
    c4c4:	1885c83a 	sub	r2,r3,r2
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
    c4c8:	e0fffb17 	ldw	r3,-20(fp)
    c4cc:	19002717 	ldw	r4,156(r3)
    c4d0:	e0fffb17 	ldw	r3,-20(fp)
    c4d4:	18c02943 	ldbu	r3,165(r3)
    c4d8:	19403fcc 	andi	r5,r3,255
    c4dc:	00c00074 	movhi	r3,1
    c4e0:	18c93e04 	addi	r3,r3,9464
    c4e4:	28c7383a 	mul	r3,r5,r3
    c4e8:	20c9883a 	add	r4,r4,r3
              / TCP_SLOW_INTERVAL)
    c4ec:	00c07d04 	movi	r3,500
    c4f0:	20c7203a 	divu	r3,r4,r3
#if LWIP_TCP_KEEPALIVE
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
    c4f4:	1880082e 	bgeu	r3,r2,c518 <tcp_slowtmr+0x4c0>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
              / TCP_SLOW_INTERVAL)
#endif /* LWIP_TCP_KEEPALIVE */
      {
        tcp_keepalive(pcb);
    c4f8:	e13ffb17 	ldw	r4,-20(fp)
    c4fc:	0013d7c0 	call	13d7c <tcp_keepalive>
        pcb->keep_cnt_sent++;
    c500:	e0bffb17 	ldw	r2,-20(fp)
    c504:	10802943 	ldbu	r2,165(r2)
    c508:	10800044 	addi	r2,r2,1
    c50c:	1007883a 	mov	r3,r2
    c510:	e0bffb17 	ldw	r2,-20(fp)
    c514:	10c02945 	stb	r3,165(r2)

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
    c518:	e0bffb17 	ldw	r2,-20(fp)
    c51c:	10802017 	ldw	r2,128(r2)
    c520:	10001126 	beq	r2,zero,c568 <tcp_slowtmr+0x510>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
    c524:	d0e8d717 	ldw	r3,-23716(gp)
    c528:	e0bffb17 	ldw	r2,-20(fp)
    c52c:	10800d17 	ldw	r2,52(r2)
    c530:	1887c83a 	sub	r3,r3,r2
    c534:	e0bffb17 	ldw	r2,-20(fp)
    c538:	1080130b 	ldhu	r2,76(r2)
    c53c:	10bfffcc 	andi	r2,r2,65535
    c540:	10a0001c 	xori	r2,r2,32768
    c544:	10a00004 	addi	r2,r2,-32768
    c548:	108001a4 	muli	r2,r2,6

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
    c54c:	18800636 	bltu	r3,r2,c568 <tcp_slowtmr+0x510>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
      tcp_segs_free(pcb->ooseq);
    c550:	e0bffb17 	ldw	r2,-20(fp)
    c554:	10802017 	ldw	r2,128(r2)
    c558:	1009883a 	mov	r4,r2
    c55c:	000ca380 	call	ca38 <tcp_segs_free>
      pcb->ooseq = NULL;
    c560:	e0bffb17 	ldw	r2,-20(fp)
    c564:	10002015 	stw	zero,128(r2)
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
    c568:	e0bffb17 	ldw	r2,-20(fp)
    c56c:	10800417 	ldw	r2,16(r2)
    c570:	108000d8 	cmpnei	r2,r2,3
    c574:	10000c1e 	bne	r2,zero,c5a8 <tcp_slowtmr+0x550>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
    c578:	d0e8d717 	ldw	r3,-23716(gp)
    c57c:	e0bffb17 	ldw	r2,-20(fp)
    c580:	10800d17 	ldw	r2,52(r2)
    c584:	1885c83a 	sub	r2,r3,r2
    c588:	10800a70 	cmpltui	r2,r2,41
    c58c:	1000061e 	bne	r2,zero,c5a8 <tcp_slowtmr+0x550>
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
    c590:	e0bffd03 	ldbu	r2,-12(fp)
    c594:	10800044 	addi	r2,r2,1
    c598:	e0bffd05 	stb	r2,-12(fp)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
    c59c:	010000f4 	movhi	r4,3
    c5a0:	213cae04 	addi	r4,r4,-3400
    c5a4:	00172f80 	call	172f8 <puts>
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
    c5a8:	e0bffb17 	ldw	r2,-20(fp)
    c5ac:	10800417 	ldw	r2,16(r2)
    c5b0:	10800258 	cmpnei	r2,r2,9
    c5b4:	10000c1e 	bne	r2,zero,c5e8 <tcp_slowtmr+0x590>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
    c5b8:	d0e8d717 	ldw	r3,-23716(gp)
    c5bc:	e0bffb17 	ldw	r2,-20(fp)
    c5c0:	10800d17 	ldw	r2,52(r2)
    c5c4:	1885c83a 	sub	r2,r3,r2
    c5c8:	10803c70 	cmpltui	r2,r2,241
    c5cc:	1000061e 	bne	r2,zero,c5e8 <tcp_slowtmr+0x590>
        ++pcb_remove;
    c5d0:	e0bffd03 	ldbu	r2,-12(fp)
    c5d4:	10800044 	addi	r2,r2,1
    c5d8:	e0bffd05 	stb	r2,-12(fp)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
    c5dc:	010000f4 	movhi	r4,3
    c5e0:	213cb904 	addi	r4,r4,-3356
    c5e4:	00172f80 	call	172f8 <puts>
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
    c5e8:	e0bffd03 	ldbu	r2,-12(fp)
    c5ec:	10004b26 	beq	r2,zero,c71c <tcp_slowtmr+0x6c4>
      tcp_pcb_purge(pcb);      
    c5f0:	e13ffb17 	ldw	r4,-20(fp)
    c5f4:	000d0fc0 	call	d0fc <tcp_pcb_purge>
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
    c5f8:	e0bffc17 	ldw	r2,-16(fp)
    c5fc:	10001126 	beq	r2,zero,c644 <tcp_slowtmr+0x5ec>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
    c600:	d0a8d617 	ldw	r2,-23720(gp)
    c604:	e0fffb17 	ldw	r3,-20(fp)
    c608:	1880091e 	bne	r3,r2,c630 <tcp_slowtmr+0x5d8>
    c60c:	010000f4 	movhi	r4,3
    c610:	213c2404 	addi	r4,r4,-3952
    c614:	014000f4 	movhi	r5,3
    c618:	297cc404 	addi	r5,r5,-3312
    c61c:	0180b884 	movi	r6,738
    c620:	01c000f4 	movhi	r7,3
    c624:	39fc3804 	addi	r7,r7,-3872
    c628:	00170680 	call	17068 <printf>
    c62c:	003fff06 	br	c62c <tcp_slowtmr+0x5d4>
        prev->next = pcb->next;
    c630:	e0bffb17 	ldw	r2,-20(fp)
    c634:	10c00317 	ldw	r3,12(r2)
    c638:	e0bffc17 	ldw	r2,-16(fp)
    c63c:	10c00315 	stw	r3,12(r2)
    c640:	00000f06 	br	c680 <tcp_slowtmr+0x628>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
    c644:	d0e8d617 	ldw	r3,-23720(gp)
    c648:	e0bffb17 	ldw	r2,-20(fp)
    c64c:	18800926 	beq	r3,r2,c674 <tcp_slowtmr+0x61c>
    c650:	010000f4 	movhi	r4,3
    c654:	213c2404 	addi	r4,r4,-3952
    c658:	014000f4 	movhi	r5,3
    c65c:	297ccf04 	addi	r5,r5,-3268
    c660:	0180b984 	movi	r6,742
    c664:	01c000f4 	movhi	r7,3
    c668:	39fc3804 	addi	r7,r7,-3872
    c66c:	00170680 	call	17068 <printf>
    c670:	003fff06 	br	c670 <tcp_slowtmr+0x618>
        tcp_active_pcbs = pcb->next;
    c674:	e0bffb17 	ldw	r2,-20(fp)
    c678:	10800317 	ldw	r2,12(r2)
    c67c:	d0a8d615 	stw	r2,-23720(gp)
      }

      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
    c680:	e0bffb17 	ldw	r2,-20(fp)
    c684:	10802617 	ldw	r2,152(r2)
    c688:	10000726 	beq	r2,zero,c6a8 <tcp_slowtmr+0x650>
    c68c:	e0bffb17 	ldw	r2,-20(fp)
    c690:	10c02617 	ldw	r3,152(r2)
    c694:	e0bffb17 	ldw	r2,-20(fp)
    c698:	10800617 	ldw	r2,24(r2)
    c69c:	1009883a 	mov	r4,r2
    c6a0:	017ffec4 	movi	r5,-5
    c6a4:	183ee83a 	callr	r3
      if (pcb_reset) {
    c6a8:	e0bffd43 	ldbu	r2,-11(fp)
    c6ac:	10001226 	beq	r2,zero,c6f8 <tcp_slowtmr+0x6a0>
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
    c6b0:	e0bffb17 	ldw	r2,-20(fp)
    c6b4:	11001717 	ldw	r4,92(r2)
    c6b8:	e0bffb17 	ldw	r2,-20(fp)
    c6bc:	11400a17 	ldw	r5,40(r2)
    c6c0:	e0fffb17 	ldw	r3,-20(fp)
    c6c4:	e0bffb17 	ldw	r2,-20(fp)
    c6c8:	10800104 	addi	r2,r2,4
          pcb->local_port, pcb->remote_port);
    c6cc:	e1bffb17 	ldw	r6,-20(fp)
    c6d0:	3180070b 	ldhu	r6,28(r6)
        tcp_active_pcbs = pcb->next;
      }

      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
      if (pcb_reset) {
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
    c6d4:	31ffffcc 	andi	r7,r6,65535
          pcb->local_port, pcb->remote_port);
    c6d8:	e1bffb17 	ldw	r6,-20(fp)
    c6dc:	3180090b 	ldhu	r6,36(r6)
        tcp_active_pcbs = pcb->next;
      }

      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
      if (pcb_reset) {
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
    c6e0:	31bfffcc 	andi	r6,r6,65535
    c6e4:	d9c00015 	stw	r7,0(sp)
    c6e8:	d9800115 	stw	r6,4(sp)
    c6ec:	180d883a 	mov	r6,r3
    c6f0:	100f883a 	mov	r7,r2
    c6f4:	00137240 	call	13724 <tcp_rst>
          pcb->local_port, pcb->remote_port);
      }

      pcb2 = pcb->next;
    c6f8:	e0bffb17 	ldw	r2,-20(fp)
    c6fc:	10800317 	ldw	r2,12(r2)
    c700:	e0bfff15 	stw	r2,-4(fp)
      memp_free(MEMP_TCP_PCB, pcb);
    c704:	01000084 	movi	r4,2
    c708:	e17ffb17 	ldw	r5,-20(fp)
    c70c:	00090e80 	call	90e8 <memp_free>
      pcb = pcb2;
    c710:	e0bfff17 	ldw	r2,-4(fp)
    c714:	e0bffb15 	stw	r2,-20(fp)
    c718:	00002806 	br	c7bc <tcp_slowtmr+0x764>
    } else {

      /* We check if we should poll the connection. */
      ++pcb->polltmr;
    c71c:	e0bffb17 	ldw	r2,-20(fp)
    c720:	10800e03 	ldbu	r2,56(r2)
    c724:	10800044 	addi	r2,r2,1
    c728:	1007883a 	mov	r3,r2
    c72c:	e0bffb17 	ldw	r2,-20(fp)
    c730:	10c00e05 	stb	r3,56(r2)
      if (pcb->polltmr >= pcb->pollinterval) {
    c734:	e0bffb17 	ldw	r2,-20(fp)
    c738:	10c00e03 	ldbu	r3,56(r2)
    c73c:	e0bffb17 	ldw	r2,-20(fp)
    c740:	10800e43 	ldbu	r2,57(r2)
    c744:	18c03fcc 	andi	r3,r3,255
    c748:	10803fcc 	andi	r2,r2,255
    c74c:	18801636 	bltu	r3,r2,c7a8 <tcp_slowtmr+0x750>
        pcb->polltmr = 0;
    c750:	e0bffb17 	ldw	r2,-20(fp)
    c754:	10000e05 	stb	zero,56(r2)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
    c758:	010000f4 	movhi	r4,3
    c75c:	213cda04 	addi	r4,r4,-3224
    c760:	00172f80 	call	172f8 <puts>
        TCP_EVENT_POLL(pcb, err);
    c764:	e0bffb17 	ldw	r2,-20(fp)
    c768:	10802517 	ldw	r2,148(r2)
    c76c:	10000926 	beq	r2,zero,c794 <tcp_slowtmr+0x73c>
    c770:	e0bffb17 	ldw	r2,-20(fp)
    c774:	10c02517 	ldw	r3,148(r2)
    c778:	e0bffb17 	ldw	r2,-20(fp)
    c77c:	10800617 	ldw	r2,24(r2)
    c780:	1009883a 	mov	r4,r2
    c784:	e17ffb17 	ldw	r5,-20(fp)
    c788:	183ee83a 	callr	r3
    c78c:	e0bffd85 	stb	r2,-10(fp)
    c790:	00000106 	br	c798 <tcp_slowtmr+0x740>
    c794:	e03ffd85 	stb	zero,-10(fp)
        if (err == ERR_OK) {
    c798:	e0bffd87 	ldb	r2,-10(fp)
    c79c:	1000021e 	bne	r2,zero,c7a8 <tcp_slowtmr+0x750>
          tcp_output(pcb);
    c7a0:	e13ffb17 	ldw	r4,-20(fp)
    c7a4:	0012b000 	call	12b00 <tcp_output>
        }
      }
      
      prev = pcb;
    c7a8:	e0bffb17 	ldw	r2,-20(fp)
    c7ac:	e0bffc15 	stw	r2,-16(fp)
      pcb = pcb->next;
    c7b0:	e0bffb17 	ldw	r2,-20(fp)
    c7b4:	10800317 	ldw	r2,12(r2)
    c7b8:	e0bffb15 	stw	r2,-20(fp)
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
    c7bc:	e0bffb17 	ldw	r2,-20(fp)
    c7c0:	103e361e 	bne	r2,zero,c09c <tcp_slowtmr+0x44>
    }
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
    c7c4:	e03ffc15 	stw	zero,-16(fp)
  pcb = tcp_tw_pcbs;
    c7c8:	d0a8db17 	ldw	r2,-23700(gp)
    c7cc:	e0bffb15 	stw	r2,-20(fp)
  while (pcb != NULL) {
    c7d0:	00004b06 	br	c900 <tcp_slowtmr+0x8a8>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
    c7d4:	e0bffb17 	ldw	r2,-20(fp)
    c7d8:	10800417 	ldw	r2,16(r2)
    c7dc:	108002a0 	cmpeqi	r2,r2,10
    c7e0:	1000091e 	bne	r2,zero,c808 <tcp_slowtmr+0x7b0>
    c7e4:	010000f4 	movhi	r4,3
    c7e8:	213c2404 	addi	r4,r4,-3952
    c7ec:	014000f4 	movhi	r5,3
    c7f0:	297ce304 	addi	r5,r5,-3188
    c7f4:	0180c284 	movi	r6,778
    c7f8:	01c000f4 	movhi	r7,3
    c7fc:	39fc3804 	addi	r7,r7,-3872
    c800:	00170680 	call	17068 <printf>
    c804:	003fff06 	br	c804 <tcp_slowtmr+0x7ac>
    pcb_remove = 0;
    c808:	e03ffd05 	stb	zero,-12(fp)

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
    c80c:	d0e8d717 	ldw	r3,-23716(gp)
    c810:	e0bffb17 	ldw	r2,-20(fp)
    c814:	10800d17 	ldw	r2,52(r2)
    c818:	1885c83a 	sub	r2,r3,r2
    c81c:	10803c70 	cmpltui	r2,r2,241
    c820:	1000031e 	bne	r2,zero,c830 <tcp_slowtmr+0x7d8>
      ++pcb_remove;
    c824:	e0bffd03 	ldbu	r2,-12(fp)
    c828:	10800044 	addi	r2,r2,1
    c82c:	e0bffd05 	stb	r2,-12(fp)
    }
    


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
    c830:	e0bffd03 	ldbu	r2,-12(fp)
    c834:	10002d26 	beq	r2,zero,c8ec <tcp_slowtmr+0x894>
      tcp_pcb_purge(pcb);      
    c838:	e13ffb17 	ldw	r4,-20(fp)
    c83c:	000d0fc0 	call	d0fc <tcp_pcb_purge>
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
    c840:	e0bffc17 	ldw	r2,-16(fp)
    c844:	10001126 	beq	r2,zero,c88c <tcp_slowtmr+0x834>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
    c848:	d0a8db17 	ldw	r2,-23700(gp)
    c84c:	e0fffb17 	ldw	r3,-20(fp)
    c850:	1880091e 	bne	r3,r2,c878 <tcp_slowtmr+0x820>
    c854:	010000f4 	movhi	r4,3
    c858:	213c2404 	addi	r4,r4,-3952
    c85c:	014000f4 	movhi	r5,3
    c860:	297cef04 	addi	r5,r5,-3140
    c864:	0180c644 	movi	r6,793
    c868:	01c000f4 	movhi	r7,3
    c86c:	39fc3804 	addi	r7,r7,-3872
    c870:	00170680 	call	17068 <printf>
    c874:	003fff06 	br	c874 <tcp_slowtmr+0x81c>
        prev->next = pcb->next;
    c878:	e0bffb17 	ldw	r2,-20(fp)
    c87c:	10c00317 	ldw	r3,12(r2)
    c880:	e0bffc17 	ldw	r2,-16(fp)
    c884:	10c00315 	stw	r3,12(r2)
    c888:	00000f06 	br	c8c8 <tcp_slowtmr+0x870>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
    c88c:	d0e8db17 	ldw	r3,-23700(gp)
    c890:	e0bffb17 	ldw	r2,-20(fp)
    c894:	18800926 	beq	r3,r2,c8bc <tcp_slowtmr+0x864>
    c898:	010000f4 	movhi	r4,3
    c89c:	213c2404 	addi	r4,r4,-3952
    c8a0:	014000f4 	movhi	r5,3
    c8a4:	297cf904 	addi	r5,r5,-3100
    c8a8:	0180c744 	movi	r6,797
    c8ac:	01c000f4 	movhi	r7,3
    c8b0:	39fc3804 	addi	r7,r7,-3872
    c8b4:	00170680 	call	17068 <printf>
    c8b8:	003fff06 	br	c8b8 <tcp_slowtmr+0x860>
        tcp_tw_pcbs = pcb->next;
    c8bc:	e0bffb17 	ldw	r2,-20(fp)
    c8c0:	10800317 	ldw	r2,12(r2)
    c8c4:	d0a8db15 	stw	r2,-23700(gp)
      }
      pcb2 = pcb->next;
    c8c8:	e0bffb17 	ldw	r2,-20(fp)
    c8cc:	10800317 	ldw	r2,12(r2)
    c8d0:	e0bfff15 	stw	r2,-4(fp)
      memp_free(MEMP_TCP_PCB, pcb);
    c8d4:	01000084 	movi	r4,2
    c8d8:	e17ffb17 	ldw	r5,-20(fp)
    c8dc:	00090e80 	call	90e8 <memp_free>
      pcb = pcb2;
    c8e0:	e0bfff17 	ldw	r2,-4(fp)
    c8e4:	e0bffb15 	stw	r2,-20(fp)
    c8e8:	00000506 	br	c900 <tcp_slowtmr+0x8a8>
    } else {
      prev = pcb;
    c8ec:	e0bffb17 	ldw	r2,-20(fp)
    c8f0:	e0bffc15 	stw	r2,-16(fp)
      pcb = pcb->next;
    c8f4:	e0bffb17 	ldw	r2,-20(fp)
    c8f8:	10800317 	ldw	r2,12(r2)
    c8fc:	e0bffb15 	stw	r2,-20(fp)

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
    c900:	e0bffb17 	ldw	r2,-20(fp)
    c904:	103fb31e 	bne	r2,zero,c7d4 <tcp_slowtmr+0x77c>
    } else {
      prev = pcb;
      pcb = pcb->next;
    }
  }
}
    c908:	e037883a 	mov	sp,fp
    c90c:	dfc00117 	ldw	ra,4(sp)
    c910:	df000017 	ldw	fp,0(sp)
    c914:	dec00204 	addi	sp,sp,8
    c918:	f800283a 	ret

0000c91c <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
    c91c:	defffc04 	addi	sp,sp,-16
    c920:	dfc00315 	stw	ra,12(sp)
    c924:	df000215 	stw	fp,8(sp)
    c928:	df000204 	addi	fp,sp,8
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    c92c:	d0a8d617 	ldw	r2,-23720(gp)
    c930:	e0bffe15 	stw	r2,-8(fp)
    c934:	00003906 	br	ca1c <tcp_fasttmr+0x100>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
    c938:	e0bffe17 	ldw	r2,-8(fp)
    c93c:	10802117 	ldw	r2,132(r2)
    c940:	10001c26 	beq	r2,zero,c9b4 <tcp_fasttmr+0x98>
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
    c944:	e0bffe17 	ldw	r2,-8(fp)
    c948:	10802317 	ldw	r2,140(r2)
    c94c:	10000d26 	beq	r2,zero,c984 <tcp_fasttmr+0x68>
    c950:	e0bffe17 	ldw	r2,-8(fp)
    c954:	12002317 	ldw	r8,140(r2)
    c958:	e0bffe17 	ldw	r2,-8(fp)
    c95c:	10c00617 	ldw	r3,24(r2)
    c960:	e0bffe17 	ldw	r2,-8(fp)
    c964:	10802117 	ldw	r2,132(r2)
    c968:	1809883a 	mov	r4,r3
    c96c:	e17ffe17 	ldw	r5,-8(fp)
    c970:	100d883a 	mov	r6,r2
    c974:	000f883a 	mov	r7,zero
    c978:	403ee83a 	callr	r8
    c97c:	e0bfff05 	stb	r2,-4(fp)
    c980:	00000806 	br	c9a4 <tcp_fasttmr+0x88>
    c984:	e0bffe17 	ldw	r2,-8(fp)
    c988:	10802117 	ldw	r2,132(r2)
    c98c:	0009883a 	mov	r4,zero
    c990:	e17ffe17 	ldw	r5,-8(fp)
    c994:	100d883a 	mov	r6,r2
    c998:	000f883a 	mov	r7,zero
    c99c:	000cba40 	call	cba4 <tcp_recv_null>
    c9a0:	e0bfff05 	stb	r2,-4(fp)
      if (err == ERR_OK) {
    c9a4:	e0bfff07 	ldb	r2,-4(fp)
    c9a8:	1000021e 	bne	r2,zero,c9b4 <tcp_fasttmr+0x98>
        pcb->refused_data = NULL;
    c9ac:	e0bffe17 	ldw	r2,-8(fp)
    c9b0:	10002115 	stw	zero,132(r2)
      }
    }

    /* send delayed ACKs */  
    if (pcb->flags & TF_ACK_DELAY) {
    c9b4:	e0bffe17 	ldw	r2,-8(fp)
    c9b8:	10800983 	ldbu	r2,38(r2)
    c9bc:	10803fcc 	andi	r2,r2,255
    c9c0:	1080004c 	andi	r2,r2,1
    c9c4:	10001226 	beq	r2,zero,ca10 <tcp_fasttmr+0xf4>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
    c9c8:	010000f4 	movhi	r4,3
    c9cc:	213d0304 	addi	r4,r4,-3060
    c9d0:	00172f80 	call	172f8 <puts>
      tcp_ack_now(pcb);
    c9d4:	e0bffe17 	ldw	r2,-8(fp)
    c9d8:	10800983 	ldbu	r2,38(r2)
    c9dc:	10800094 	ori	r2,r2,2
    c9e0:	1007883a 	mov	r3,r2
    c9e4:	e0bffe17 	ldw	r2,-8(fp)
    c9e8:	10c00985 	stb	r3,38(r2)
    c9ec:	e13ffe17 	ldw	r4,-8(fp)
    c9f0:	0012b000 	call	12b00 <tcp_output>
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    c9f4:	e0bffe17 	ldw	r2,-8(fp)
    c9f8:	10c00983 	ldbu	r3,38(r2)
    c9fc:	00bfff04 	movi	r2,-4
    ca00:	1884703a 	and	r2,r3,r2
    ca04:	1007883a 	mov	r3,r2
    ca08:	e0bffe17 	ldw	r2,-8(fp)
    ca0c:	10c00985 	stb	r3,38(r2)
void
tcp_fasttmr(void)
{
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    ca10:	e0bffe17 	ldw	r2,-8(fp)
    ca14:	10800317 	ldw	r2,12(r2)
    ca18:	e0bffe15 	stw	r2,-8(fp)
    ca1c:	e0bffe17 	ldw	r2,-8(fp)
    ca20:	103fc51e 	bne	r2,zero,c938 <tcp_fasttmr+0x1c>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }
  }
}
    ca24:	e037883a 	mov	sp,fp
    ca28:	dfc00117 	ldw	ra,4(sp)
    ca2c:	df000017 	ldw	fp,0(sp)
    ca30:	dec00204 	addi	sp,sp,8
    ca34:	f800283a 	ret

0000ca38 <tcp_segs_free>:
 * @param seg tcp_seg list of TCP segments to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
    ca38:	defffb04 	addi	sp,sp,-20
    ca3c:	dfc00415 	stw	ra,16(sp)
    ca40:	df000315 	stw	fp,12(sp)
    ca44:	df000304 	addi	fp,sp,12
    ca48:	e13fff15 	stw	r4,-4(fp)
  u8_t count = 0;
    ca4c:	e03ffd05 	stb	zero,-12(fp)
  struct tcp_seg *next;
  while (seg != NULL) {
    ca50:	00000a06 	br	ca7c <tcp_segs_free+0x44>
    next = seg->next;
    ca54:	e0bfff17 	ldw	r2,-4(fp)
    ca58:	10800017 	ldw	r2,0(r2)
    ca5c:	e0bffe15 	stw	r2,-8(fp)
    count += tcp_seg_free(seg);
    ca60:	e13fff17 	ldw	r4,-4(fp)
    ca64:	000ca9c0 	call	ca9c <tcp_seg_free>
    ca68:	e0fffd03 	ldbu	r3,-12(fp)
    ca6c:	10c5883a 	add	r2,r2,r3
    ca70:	e0bffd05 	stb	r2,-12(fp)
    seg = next;
    ca74:	e0bffe17 	ldw	r2,-8(fp)
    ca78:	e0bfff15 	stw	r2,-4(fp)
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  struct tcp_seg *next;
  while (seg != NULL) {
    ca7c:	e0bfff17 	ldw	r2,-4(fp)
    ca80:	103ff41e 	bne	r2,zero,ca54 <tcp_segs_free+0x1c>
    next = seg->next;
    count += tcp_seg_free(seg);
    seg = next;
  }
  return count;
    ca84:	e0bffd03 	ldbu	r2,-12(fp)
}
    ca88:	e037883a 	mov	sp,fp
    ca8c:	dfc00117 	ldw	ra,4(sp)
    ca90:	df000017 	ldw	fp,0(sp)
    ca94:	dec00204 	addi	sp,sp,8
    ca98:	f800283a 	ret

0000ca9c <tcp_seg_free>:
 * @param seg single tcp_seg to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
    ca9c:	defffc04 	addi	sp,sp,-16
    caa0:	dfc00315 	stw	ra,12(sp)
    caa4:	df000215 	stw	fp,8(sp)
    caa8:	df000204 	addi	fp,sp,8
    caac:	e13fff15 	stw	r4,-4(fp)
  u8_t count = 0;
    cab0:	e03ffe05 	stb	zero,-8(fp)
  
  if (seg != NULL) {
    cab4:	e0bfff17 	ldw	r2,-4(fp)
    cab8:	10000d26 	beq	r2,zero,caf0 <tcp_seg_free+0x54>
    if (seg->p != NULL) {
    cabc:	e0bfff17 	ldw	r2,-4(fp)
    cac0:	10800117 	ldw	r2,4(r2)
    cac4:	10000726 	beq	r2,zero,cae4 <tcp_seg_free+0x48>
      count = pbuf_free(seg->p);
    cac8:	e0bfff17 	ldw	r2,-4(fp)
    cacc:	10800117 	ldw	r2,4(r2)
    cad0:	1009883a 	mov	r4,r2
    cad4:	000a1880 	call	a188 <pbuf_free>
    cad8:	e0bffe05 	stb	r2,-8(fp)
#if TCP_DEBUG
      seg->p = NULL;
    cadc:	e0bfff17 	ldw	r2,-4(fp)
    cae0:	10000115 	stw	zero,4(r2)
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
    cae4:	01000104 	movi	r4,4
    cae8:	e17fff17 	ldw	r5,-4(fp)
    caec:	00090e80 	call	90e8 <memp_free>
  }
  return count;
    caf0:	e0bffe03 	ldbu	r2,-8(fp)
}
    caf4:	e037883a 	mov	sp,fp
    caf8:	dfc00117 	ldw	ra,4(sp)
    cafc:	df000017 	ldw	fp,0(sp)
    cb00:	dec00204 	addi	sp,sp,8
    cb04:	f800283a 	ret

0000cb08 <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
    cb08:	defffd04 	addi	sp,sp,-12
    cb0c:	df000215 	stw	fp,8(sp)
    cb10:	df000204 	addi	fp,sp,8
    cb14:	e13ffe15 	stw	r4,-8(fp)
    cb18:	2805883a 	mov	r2,r5
    cb1c:	e0bfff05 	stb	r2,-4(fp)
  pcb->prio = prio;
    cb20:	e0bffe17 	ldw	r2,-8(fp)
    cb24:	e0ffff03 	ldbu	r3,-4(fp)
    cb28:	10c00505 	stb	r3,20(r2)
}
    cb2c:	e037883a 	mov	sp,fp
    cb30:	df000017 	ldw	fp,0(sp)
    cb34:	dec00104 	addi	sp,sp,4
    cb38:	f800283a 	ret

0000cb3c <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
    cb3c:	defffc04 	addi	sp,sp,-16
    cb40:	dfc00315 	stw	ra,12(sp)
    cb44:	df000215 	stw	fp,8(sp)
    cb48:	df000204 	addi	fp,sp,8
    cb4c:	e13fff15 	stw	r4,-4(fp)
  struct tcp_seg *cseg;

  cseg = memp_malloc(MEMP_TCP_SEG);
    cb50:	01000104 	movi	r4,4
    cb54:	0008f0c0 	call	8f0c <memp_malloc>
    cb58:	e0bffe15 	stw	r2,-8(fp)
  if (cseg == NULL) {
    cb5c:	e0bffe17 	ldw	r2,-8(fp)
    cb60:	1000021e 	bne	r2,zero,cb6c <tcp_seg_copy+0x30>
    return NULL;
    cb64:	0005883a 	mov	r2,zero
    cb68:	00000906 	br	cb90 <tcp_seg_copy+0x54>
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
    cb6c:	e13ffe17 	ldw	r4,-8(fp)
    cb70:	e17fff17 	ldw	r5,-4(fp)
    cb74:	01800504 	movi	r6,20
    cb78:	0016e680 	call	16e68 <memcpy>
  pbuf_ref(cseg->p);
    cb7c:	e0bffe17 	ldw	r2,-8(fp)
    cb80:	10800117 	ldw	r2,4(r2)
    cb84:	1009883a 	mov	r4,r2
    cb88:	000a3a00 	call	a3a0 <pbuf_ref>
  return cseg;
    cb8c:	e0bffe17 	ldw	r2,-8(fp)
}
    cb90:	e037883a 	mov	sp,fp
    cb94:	dfc00117 	ldw	ra,4(sp)
    cb98:	df000017 	ldw	fp,0(sp)
    cb9c:	dec00204 	addi	sp,sp,8
    cba0:	f800283a 	ret

0000cba4 <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
    cba4:	defffa04 	addi	sp,sp,-24
    cba8:	dfc00515 	stw	ra,20(sp)
    cbac:	df000415 	stw	fp,16(sp)
    cbb0:	df000404 	addi	fp,sp,16
    cbb4:	e13ffc15 	stw	r4,-16(fp)
    cbb8:	e17ffd15 	stw	r5,-12(fp)
    cbbc:	e1bffe15 	stw	r6,-8(fp)
    cbc0:	3805883a 	mov	r2,r7
    cbc4:	e0bfff05 	stb	r2,-4(fp)
  LWIP_UNUSED_ARG(arg);
  if (p != NULL) {
    cbc8:	e0bffe17 	ldw	r2,-8(fp)
    cbcc:	10000926 	beq	r2,zero,cbf4 <tcp_recv_null+0x50>
    tcp_recved(pcb, p->tot_len);
    cbd0:	e0bffe17 	ldw	r2,-8(fp)
    cbd4:	1080020b 	ldhu	r2,8(r2)
    cbd8:	10bfffcc 	andi	r2,r2,65535
    cbdc:	e13ffd17 	ldw	r4,-12(fp)
    cbe0:	100b883a 	mov	r5,r2
    cbe4:	000bbfc0 	call	bbfc <tcp_recved>
    pbuf_free(p);
    cbe8:	e13ffe17 	ldw	r4,-8(fp)
    cbec:	000a1880 	call	a188 <pbuf_free>
    cbf0:	00000506 	br	cc08 <tcp_recv_null+0x64>
  } else if (err == ERR_OK) {
    cbf4:	e0bfff07 	ldb	r2,-4(fp)
    cbf8:	1000031e 	bne	r2,zero,cc08 <tcp_recv_null+0x64>
    return tcp_close(pcb);
    cbfc:	e13ffd17 	ldw	r4,-12(fp)
    cc00:	000b2940 	call	b294 <tcp_close>
    cc04:	00000106 	br	cc0c <tcp_recv_null+0x68>
  }
  return ERR_OK;
    cc08:	0005883a 	mov	r2,zero
}
    cc0c:	e037883a 	mov	sp,fp
    cc10:	dfc00117 	ldw	ra,4(sp)
    cc14:	df000017 	ldw	fp,0(sp)
    cc18:	dec00204 	addi	sp,sp,8
    cc1c:	f800283a 	ret

0000cc20 <tcp_kill_prio>:
 *
 * @param prio minimum priority
 */
static void
tcp_kill_prio(u8_t prio)
{
    cc20:	defff904 	addi	sp,sp,-28
    cc24:	dfc00615 	stw	ra,24(sp)
    cc28:	df000515 	stw	fp,20(sp)
    cc2c:	df000504 	addi	fp,sp,20
    cc30:	2005883a 	mov	r2,r4
    cc34:	e0bfff05 	stb	r2,-4(fp)
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;
  u8_t mprio;


  mprio = TCP_PRIO_MAX;
    cc38:	00801fc4 	movi	r2,127
    cc3c:	e0bffe05 	stb	r2,-8(fp)
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
    cc40:	e03ffd15 	stw	zero,-12(fp)
  inactive = NULL;
    cc44:	e03ffc15 	stw	zero,-16(fp)
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    cc48:	d0a8d617 	ldw	r2,-23720(gp)
    cc4c:	e0bffb15 	stw	r2,-20(fp)
    cc50:	00001d06 	br	ccc8 <tcp_kill_prio+0xa8>
    if (pcb->prio <= prio &&
    cc54:	e0bffb17 	ldw	r2,-20(fp)
    cc58:	10800503 	ldbu	r2,20(r2)
    cc5c:	10803fcc 	andi	r2,r2,255
    cc60:	e0ffff03 	ldbu	r3,-4(fp)
    cc64:	18801536 	bltu	r3,r2,ccbc <tcp_kill_prio+0x9c>
       pcb->prio <= mprio &&
    cc68:	e0bffb17 	ldw	r2,-20(fp)
    cc6c:	10800503 	ldbu	r2,20(r2)
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
    cc70:	10803fcc 	andi	r2,r2,255
    cc74:	e0fffe03 	ldbu	r3,-8(fp)
    cc78:	18801036 	bltu	r3,r2,ccbc <tcp_kill_prio+0x9c>
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
    cc7c:	d0e8d717 	ldw	r3,-23716(gp)
    cc80:	e0bffb17 	ldw	r2,-20(fp)
    cc84:	10800d17 	ldw	r2,52(r2)
    cc88:	1887c83a 	sub	r3,r3,r2
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
    cc8c:	e0bffd17 	ldw	r2,-12(fp)
    cc90:	18800a36 	bltu	r3,r2,ccbc <tcp_kill_prio+0x9c>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
    cc94:	d0e8d717 	ldw	r3,-23716(gp)
    cc98:	e0bffb17 	ldw	r2,-20(fp)
    cc9c:	10800d17 	ldw	r2,52(r2)
    cca0:	1885c83a 	sub	r2,r3,r2
    cca4:	e0bffd15 	stw	r2,-12(fp)
      inactive = pcb;
    cca8:	e0bffb17 	ldw	r2,-20(fp)
    ccac:	e0bffc15 	stw	r2,-16(fp)
      mprio = pcb->prio;
    ccb0:	e0bffb17 	ldw	r2,-20(fp)
    ccb4:	10800503 	ldbu	r2,20(r2)
    ccb8:	e0bffe05 	stb	r2,-8(fp)
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    ccbc:	e0bffb17 	ldw	r2,-20(fp)
    ccc0:	10800317 	ldw	r2,12(r2)
    ccc4:	e0bffb15 	stw	r2,-20(fp)
    ccc8:	e0bffb17 	ldw	r2,-20(fp)
    cccc:	103fe11e 	bne	r2,zero,cc54 <tcp_kill_prio+0x34>
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
    }
  }
  if (inactive != NULL) {
    ccd0:	e0bffc17 	ldw	r2,-16(fp)
    ccd4:	10000626 	beq	r2,zero,ccf0 <tcp_kill_prio+0xd0>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
    ccd8:	e0bffd17 	ldw	r2,-12(fp)
    ccdc:	1009883a 	mov	r4,r2
    cce0:	00170680 	call	17068 <printf>
           (void *)inactive, inactivity));
    tcp_abort(inactive);
    cce4:	e13ffc17 	ldw	r4,-16(fp)
    cce8:	01400044 	movi	r5,1
    ccec:	000b4a00 	call	b4a0 <tcp_abandon>
  }      
}
    ccf0:	e037883a 	mov	sp,fp
    ccf4:	dfc00117 	ldw	ra,4(sp)
    ccf8:	df000017 	ldw	fp,0(sp)
    ccfc:	dec00204 	addi	sp,sp,8
    cd00:	f800283a 	ret

0000cd04 <tcp_kill_timewait>:
 * Kills the oldest connection that is in TIME_WAIT state.
 * Called from tcp_alloc() if no more connections are available.
 */
static void
tcp_kill_timewait(void)
{
    cd04:	defffb04 	addi	sp,sp,-20
    cd08:	dfc00415 	stw	ra,16(sp)
    cd0c:	df000315 	stw	fp,12(sp)
    cd10:	df000304 	addi	fp,sp,12
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  inactivity = 0;
    cd14:	e03fff15 	stw	zero,-4(fp)
  inactive = NULL;
    cd18:	e03ffe15 	stw	zero,-8(fp)
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    cd1c:	d0a8db17 	ldw	r2,-23700(gp)
    cd20:	e0bffd15 	stw	r2,-12(fp)
    cd24:	00001006 	br	cd68 <tcp_kill_timewait+0x64>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
    cd28:	d0e8d717 	ldw	r3,-23716(gp)
    cd2c:	e0bffd17 	ldw	r2,-12(fp)
    cd30:	10800d17 	ldw	r2,52(r2)
    cd34:	1887c83a 	sub	r3,r3,r2
    cd38:	e0bfff17 	ldw	r2,-4(fp)
    cd3c:	18800736 	bltu	r3,r2,cd5c <tcp_kill_timewait+0x58>
      inactivity = tcp_ticks - pcb->tmr;
    cd40:	d0e8d717 	ldw	r3,-23716(gp)
    cd44:	e0bffd17 	ldw	r2,-12(fp)
    cd48:	10800d17 	ldw	r2,52(r2)
    cd4c:	1885c83a 	sub	r2,r3,r2
    cd50:	e0bfff15 	stw	r2,-4(fp)
      inactive = pcb;
    cd54:	e0bffd17 	ldw	r2,-12(fp)
    cd58:	e0bffe15 	stw	r2,-8(fp)
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    cd5c:	e0bffd17 	ldw	r2,-12(fp)
    cd60:	10800317 	ldw	r2,12(r2)
    cd64:	e0bffd15 	stw	r2,-12(fp)
    cd68:	e0bffd17 	ldw	r2,-12(fp)
    cd6c:	103fee1e 	bne	r2,zero,cd28 <tcp_kill_timewait+0x24>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
    }
  }
  if (inactive != NULL) {
    cd70:	e0bffe17 	ldw	r2,-8(fp)
    cd74:	10000626 	beq	r2,zero,cd90 <tcp_kill_timewait+0x8c>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
    cd78:	e0bfff17 	ldw	r2,-4(fp)
    cd7c:	1009883a 	mov	r4,r2
    cd80:	00170680 	call	17068 <printf>
           (void *)inactive, inactivity));
    tcp_abort(inactive);
    cd84:	e13ffe17 	ldw	r4,-8(fp)
    cd88:	01400044 	movi	r5,1
    cd8c:	000b4a00 	call	b4a0 <tcp_abandon>
  }      
}
    cd90:	e037883a 	mov	sp,fp
    cd94:	dfc00117 	ldw	ra,4(sp)
    cd98:	df000017 	ldw	fp,0(sp)
    cd9c:	dec00204 	addi	sp,sp,8
    cda0:	f800283a 	ret

0000cda4 <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
    cda4:	defffb04 	addi	sp,sp,-20
    cda8:	dfc00415 	stw	ra,16(sp)
    cdac:	df000315 	stw	fp,12(sp)
    cdb0:	df000304 	addi	fp,sp,12
    cdb4:	2005883a 	mov	r2,r4
    cdb8:	e0bfff05 	stb	r2,-4(fp)
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = memp_malloc(MEMP_TCP_PCB);
    cdbc:	01000084 	movi	r4,2
    cdc0:	0008f0c0 	call	8f0c <memp_malloc>
    cdc4:	e0bffd15 	stw	r2,-12(fp)
  if (pcb == NULL) {
    cdc8:	e0bffd17 	ldw	r2,-12(fp)
    cdcc:	1000261e 	bne	r2,zero,ce68 <tcp_alloc+0xc4>
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    cdd0:	010000f4 	movhi	r4,3
    cdd4:	213d0a04 	addi	r4,r4,-3032
    cdd8:	00172f80 	call	172f8 <puts>
    tcp_kill_timewait();
    cddc:	000cd040 	call	cd04 <tcp_kill_timewait>
    /* Try to allocate a tcp_pcb again. */
    pcb = memp_malloc(MEMP_TCP_PCB);
    cde0:	01000084 	movi	r4,2
    cde4:	0008f0c0 	call	8f0c <memp_malloc>
    cde8:	e0bffd15 	stw	r2,-12(fp)
    if (pcb == NULL) {
    cdec:	e0bffd17 	ldw	r2,-12(fp)
    cdf0:	1000131e 	bne	r2,zero,ce40 <tcp_alloc+0x9c>
      /* Try killing active connections with lower priority than the new one. */
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing connection with prio lower than %d\n", prio));
    cdf4:	e0bfff03 	ldbu	r2,-4(fp)
    cdf8:	1009883a 	mov	r4,r2
    cdfc:	00170680 	call	17068 <printf>
      tcp_kill_prio(prio);
    ce00:	e0bfff03 	ldbu	r2,-4(fp)
    ce04:	1009883a 	mov	r4,r2
    ce08:	000cc200 	call	cc20 <tcp_kill_prio>
      /* Try to allocate a tcp_pcb again. */
      pcb = memp_malloc(MEMP_TCP_PCB);
    ce0c:	01000084 	movi	r4,2
    ce10:	0008f0c0 	call	8f0c <memp_malloc>
    ce14:	e0bffd15 	stw	r2,-12(fp)
      if (pcb != NULL) {
    ce18:	e0bffd17 	ldw	r2,-12(fp)
    ce1c:	10000826 	beq	r2,zero,ce40 <tcp_alloc+0x9c>
        /* adjust err stats: memp_malloc failed twice before */
        MEMP_STATS_DEC(err, MEMP_TCP_PCB);
    ce20:	00800134 	movhi	r2,4
    ce24:	10916104 	addi	r2,r2,17796
    ce28:	1080330b 	ldhu	r2,204(r2)
    ce2c:	10bfffc4 	addi	r2,r2,-1
    ce30:	1007883a 	mov	r3,r2
    ce34:	00800134 	movhi	r2,4
    ce38:	10916104 	addi	r2,r2,17796
    ce3c:	10c0330d 	sth	r3,204(r2)
      }
    }
    if (pcb != NULL) {
    ce40:	e0bffd17 	ldw	r2,-12(fp)
    ce44:	10000826 	beq	r2,zero,ce68 <tcp_alloc+0xc4>
      /* adjust err stats: timewait PCB was freed above */
      MEMP_STATS_DEC(err, MEMP_TCP_PCB);
    ce48:	00800134 	movhi	r2,4
    ce4c:	10916104 	addi	r2,r2,17796
    ce50:	1080330b 	ldhu	r2,204(r2)
    ce54:	10bfffc4 	addi	r2,r2,-1
    ce58:	1007883a 	mov	r3,r2
    ce5c:	00800134 	movhi	r2,4
    ce60:	10916104 	addi	r2,r2,17796
    ce64:	10c0330d 	sth	r3,204(r2)
    }
  }
  if (pcb != NULL) {
    ce68:	e0bffd17 	ldw	r2,-12(fp)
    ce6c:	10004526 	beq	r2,zero,cf84 <tcp_alloc+0x1e0>
    memset(pcb, 0, sizeof(struct tcp_pcb));
    ce70:	e13ffd17 	ldw	r4,-12(fp)
    ce74:	000b883a 	mov	r5,zero
    ce78:	01802a04 	movi	r6,168
    ce7c:	0016f600 	call	16f60 <memset>
    pcb->prio = TCP_PRIO_NORMAL;
    ce80:	e0bffd17 	ldw	r2,-12(fp)
    ce84:	00c01004 	movi	r3,64
    ce88:	10c00505 	stb	r3,20(r2)
    pcb->snd_buf = TCP_SND_BUF;
    ce8c:	e0bffd17 	ldw	r2,-12(fp)
    ce90:	00d00004 	movi	r3,16384
    ce94:	10c01c8d 	sth	r3,114(r2)
    pcb->snd_queuelen = 0;
    ce98:	e0bffd17 	ldw	r2,-12(fp)
    ce9c:	10001d0d 	sth	zero,116(r2)
    pcb->rcv_wnd = TCP_WND;
    cea0:	e0bffd17 	ldw	r2,-12(fp)
    cea4:	00c20004 	movi	r3,2048
    cea8:	10c00b0d 	sth	r3,44(r2)
    pcb->rcv_ann_wnd = TCP_WND;
    ceac:	e0bffd17 	ldw	r2,-12(fp)
    ceb0:	00c20004 	movi	r3,2048
    ceb4:	10c00b8d 	sth	r3,46(r2)
    pcb->tos = 0;
    ceb8:	e0bffd17 	ldw	r2,-12(fp)
    cebc:	10000285 	stb	zero,10(r2)
    pcb->ttl = TCP_TTL;
    cec0:	e0bffd17 	ldw	r2,-12(fp)
    cec4:	00ffffc4 	movi	r3,-1
    cec8:	10c002c5 	stb	r3,11(r2)
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
    cecc:	e0bffd17 	ldw	r2,-12(fp)
    ced0:	00c08604 	movi	r3,536
    ced4:	10c00f0d 	sth	r3,60(r2)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
    ced8:	e0bffd17 	ldw	r2,-12(fp)
    cedc:	00c00184 	movi	r3,6
    cee0:	10c0130d 	sth	r3,76(r2)
    pcb->sa = 0;
    cee4:	e0bffd17 	ldw	r2,-12(fp)
    cee8:	1000120d 	sth	zero,72(r2)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
    ceec:	e0bffd17 	ldw	r2,-12(fp)
    cef0:	00c00184 	movi	r3,6
    cef4:	10c0128d 	sth	r3,74(r2)
    pcb->rtime = -1;
    cef8:	e0bffd17 	ldw	r2,-12(fp)
    cefc:	00ffffc4 	movi	r3,-1
    cf00:	10c00e8d 	sth	r3,58(r2)
    pcb->cwnd = 1;
    cf04:	e0bffd17 	ldw	r2,-12(fp)
    cf08:	00c00044 	movi	r3,1
    cf0c:	10c0158d 	sth	r3,86(r2)
    iss = tcp_next_iss();
    cf10:	000d4100 	call	d410 <tcp_next_iss>
    cf14:	e0bffe15 	stw	r2,-8(fp)
    pcb->snd_wl2 = iss;
    cf18:	e0bffd17 	ldw	r2,-12(fp)
    cf1c:	e0fffe17 	ldw	r3,-8(fp)
    cf20:	10c01a15 	stw	r3,104(r2)
    pcb->snd_nxt = iss;
    cf24:	e0bffd17 	ldw	r2,-12(fp)
    cf28:	e0fffe17 	ldw	r3,-8(fp)
    cf2c:	10c01715 	stw	r3,92(r2)
    pcb->lastack = iss;
    cf30:	e0bffd17 	ldw	r2,-12(fp)
    cf34:	e0fffe17 	ldw	r3,-8(fp)
    cf38:	10c01415 	stw	r3,80(r2)
    pcb->snd_lbb = iss;   
    cf3c:	e0bffd17 	ldw	r2,-12(fp)
    cf40:	e0fffe17 	ldw	r3,-8(fp)
    cf44:	10c01b15 	stw	r3,108(r2)
    pcb->tmr = tcp_ticks;
    cf48:	d0e8d717 	ldw	r3,-23716(gp)
    cf4c:	e0bffd17 	ldw	r2,-12(fp)
    cf50:	10c00d15 	stw	r3,52(r2)

    pcb->polltmr = 0;
    cf54:	e0bffd17 	ldw	r2,-12(fp)
    cf58:	10000e05 	stb	zero,56(r2)

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
    cf5c:	e0bffd17 	ldw	r2,-12(fp)
    cf60:	00c00074 	movhi	r3,1
    cf64:	18f2e904 	addi	r3,r3,-13404
    cf68:	10c02315 	stw	r3,140(r2)
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
    cf6c:	e0bffd17 	ldw	r2,-12(fp)
    cf70:	00c01bb4 	movhi	r3,110
    cf74:	18f74004 	addi	r3,r3,-8960
    cf78:	10c02715 	stw	r3,156(r2)
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
    cf7c:	e0bffd17 	ldw	r2,-12(fp)
    cf80:	10002945 	stb	zero,165(r2)
  }
  return pcb;
    cf84:	e0bffd17 	ldw	r2,-12(fp)
}
    cf88:	e037883a 	mov	sp,fp
    cf8c:	dfc00117 	ldw	ra,4(sp)
    cf90:	df000017 	ldw	fp,0(sp)
    cf94:	dec00204 	addi	sp,sp,8
    cf98:	f800283a 	ret

0000cf9c <tcp_new>:
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
    cf9c:	defffe04 	addi	sp,sp,-8
    cfa0:	dfc00115 	stw	ra,4(sp)
    cfa4:	df000015 	stw	fp,0(sp)
    cfa8:	d839883a 	mov	fp,sp
  return tcp_alloc(TCP_PRIO_NORMAL);
    cfac:	01001004 	movi	r4,64
    cfb0:	000cda40 	call	cda4 <tcp_alloc>
}
    cfb4:	e037883a 	mov	sp,fp
    cfb8:	dfc00117 	ldw	ra,4(sp)
    cfbc:	df000017 	ldw	fp,0(sp)
    cfc0:	dec00204 	addi	sp,sp,8
    cfc4:	f800283a 	ret

0000cfc8 <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
    cfc8:	defffd04 	addi	sp,sp,-12
    cfcc:	df000215 	stw	fp,8(sp)
    cfd0:	df000204 	addi	fp,sp,8
    cfd4:	e13ffe15 	stw	r4,-8(fp)
    cfd8:	e17fff15 	stw	r5,-4(fp)
  pcb->callback_arg = arg;
    cfdc:	e0bffe17 	ldw	r2,-8(fp)
    cfe0:	e0ffff17 	ldw	r3,-4(fp)
    cfe4:	10c00615 	stw	r3,24(r2)
}
    cfe8:	e037883a 	mov	sp,fp
    cfec:	df000017 	ldw	fp,0(sp)
    cff0:	dec00104 	addi	sp,sp,4
    cff4:	f800283a 	ret

0000cff8 <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
    cff8:	defffd04 	addi	sp,sp,-12
    cffc:	df000215 	stw	fp,8(sp)
    d000:	df000204 	addi	fp,sp,8
    d004:	e13ffe15 	stw	r4,-8(fp)
    d008:	e17fff15 	stw	r5,-4(fp)
  pcb->recv = recv;
    d00c:	e0bffe17 	ldw	r2,-8(fp)
    d010:	e0ffff17 	ldw	r3,-4(fp)
    d014:	10c02315 	stw	r3,140(r2)
}
    d018:	e037883a 	mov	sp,fp
    d01c:	df000017 	ldw	fp,0(sp)
    d020:	dec00104 	addi	sp,sp,4
    d024:	f800283a 	ret

0000d028 <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
    d028:	defffd04 	addi	sp,sp,-12
    d02c:	df000215 	stw	fp,8(sp)
    d030:	df000204 	addi	fp,sp,8
    d034:	e13ffe15 	stw	r4,-8(fp)
    d038:	e17fff15 	stw	r5,-4(fp)
  pcb->sent = sent;
    d03c:	e0bffe17 	ldw	r2,-8(fp)
    d040:	e0ffff17 	ldw	r3,-4(fp)
    d044:	10c02215 	stw	r3,136(r2)
}
    d048:	e037883a 	mov	sp,fp
    d04c:	df000017 	ldw	fp,0(sp)
    d050:	dec00104 	addi	sp,sp,4
    d054:	f800283a 	ret

0000d058 <tcp_err>:
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
    d058:	defffd04 	addi	sp,sp,-12
    d05c:	df000215 	stw	fp,8(sp)
    d060:	df000204 	addi	fp,sp,8
    d064:	e13ffe15 	stw	r4,-8(fp)
    d068:	e17fff15 	stw	r5,-4(fp)
  pcb->errf = errf;
    d06c:	e0bffe17 	ldw	r2,-8(fp)
    d070:	e0ffff17 	ldw	r3,-4(fp)
    d074:	10c02615 	stw	r3,152(r2)
}
    d078:	e037883a 	mov	sp,fp
    d07c:	df000017 	ldw	fp,0(sp)
    d080:	dec00104 	addi	sp,sp,4
    d084:	f800283a 	ret

0000d088 <tcp_accept>:
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
    d088:	defffd04 	addi	sp,sp,-12
    d08c:	df000215 	stw	fp,8(sp)
    d090:	df000204 	addi	fp,sp,8
    d094:	e13ffe15 	stw	r4,-8(fp)
    d098:	e17fff15 	stw	r5,-4(fp)
  pcb->accept = accept;
    d09c:	e0bffe17 	ldw	r2,-8(fp)
    d0a0:	e0ffff17 	ldw	r3,-4(fp)
    d0a4:	10c00815 	stw	r3,32(r2)
}
    d0a8:	e037883a 	mov	sp,fp
    d0ac:	df000017 	ldw	fp,0(sp)
    d0b0:	dec00104 	addi	sp,sp,4
    d0b4:	f800283a 	ret

0000d0b8 <tcp_poll>:
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
    d0b8:	defffc04 	addi	sp,sp,-16
    d0bc:	df000315 	stw	fp,12(sp)
    d0c0:	df000304 	addi	fp,sp,12
    d0c4:	e13ffd15 	stw	r4,-12(fp)
    d0c8:	e17ffe15 	stw	r5,-8(fp)
    d0cc:	3005883a 	mov	r2,r6
    d0d0:	e0bfff05 	stb	r2,-4(fp)
#if LWIP_CALLBACK_API
  pcb->poll = poll;
    d0d4:	e0bffd17 	ldw	r2,-12(fp)
    d0d8:	e0fffe17 	ldw	r3,-8(fp)
    d0dc:	10c02515 	stw	r3,148(r2)
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
    d0e0:	e0bffd17 	ldw	r2,-12(fp)
    d0e4:	e0ffff03 	ldbu	r3,-4(fp)
    d0e8:	10c00e45 	stb	r3,57(r2)
}
    d0ec:	e037883a 	mov	sp,fp
    d0f0:	df000017 	ldw	fp,0(sp)
    d0f4:	dec00104 	addi	sp,sp,4
    d0f8:	f800283a 	ret

0000d0fc <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
    d0fc:	defffd04 	addi	sp,sp,-12
    d100:	dfc00215 	stw	ra,8(sp)
    d104:	df000115 	stw	fp,4(sp)
    d108:	df000104 	addi	fp,sp,4
    d10c:	e13fff15 	stw	r4,-4(fp)
  if (pcb->state != CLOSED &&
    d110:	e0bfff17 	ldw	r2,-4(fp)
    d114:	10800417 	ldw	r2,16(r2)
    d118:	10004026 	beq	r2,zero,d21c <tcp_pcb_purge+0x120>
     pcb->state != TIME_WAIT &&
    d11c:	e0bfff17 	ldw	r2,-4(fp)
    d120:	10800417 	ldw	r2,16(r2)
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
    d124:	108002a0 	cmpeqi	r2,r2,10
    d128:	10003c1e 	bne	r2,zero,d21c <tcp_pcb_purge+0x120>
     pcb->state != TIME_WAIT &&
     pcb->state != LISTEN) {
    d12c:	e0bfff17 	ldw	r2,-4(fp)
    d130:	10800417 	ldw	r2,16(r2)
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
     pcb->state != TIME_WAIT &&
    d134:	10800060 	cmpeqi	r2,r2,1
    d138:	1000381e 	bne	r2,zero,d21c <tcp_pcb_purge+0x120>
     pcb->state != LISTEN) {

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));
    d13c:	010000f4 	movhi	r4,3
    d140:	213d1704 	addi	r4,r4,-2980
    d144:	00172f80 	call	172f8 <puts>
      }
    }
#endif /* TCP_LISTEN_BACKLOG */


    if (pcb->refused_data != NULL) {
    d148:	e0bfff17 	ldw	r2,-4(fp)
    d14c:	10802117 	ldw	r2,132(r2)
    d150:	10000926 	beq	r2,zero,d178 <tcp_pcb_purge+0x7c>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
    d154:	010000f4 	movhi	r4,3
    d158:	213d1b04 	addi	r4,r4,-2964
    d15c:	00172f80 	call	172f8 <puts>
      pbuf_free(pcb->refused_data);
    d160:	e0bfff17 	ldw	r2,-4(fp)
    d164:	10802117 	ldw	r2,132(r2)
    d168:	1009883a 	mov	r4,r2
    d16c:	000a1880 	call	a188 <pbuf_free>
      pcb->refused_data = NULL;
    d170:	e0bfff17 	ldw	r2,-4(fp)
    d174:	10002115 	stw	zero,132(r2)
    }
    if (pcb->unsent != NULL) {
    d178:	e0bfff17 	ldw	r2,-4(fp)
    d17c:	10801e17 	ldw	r2,120(r2)
    d180:	10000326 	beq	r2,zero,d190 <tcp_pcb_purge+0x94>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: not all data sent\n"));
    d184:	010000f4 	movhi	r4,3
    d188:	213d2604 	addi	r4,r4,-2920
    d18c:	00172f80 	call	172f8 <puts>
    }
    if (pcb->unacked != NULL) {
    d190:	e0bfff17 	ldw	r2,-4(fp)
    d194:	10801f17 	ldw	r2,124(r2)
    d198:	10000326 	beq	r2,zero,d1a8 <tcp_pcb_purge+0xac>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->unacked\n"));
    d19c:	010000f4 	movhi	r4,3
    d1a0:	213d2f04 	addi	r4,r4,-2884
    d1a4:	00172f80 	call	172f8 <puts>
    }
#if TCP_QUEUE_OOSEQ /* LW */
    if (pcb->ooseq != NULL) {
    d1a8:	e0bfff17 	ldw	r2,-4(fp)
    d1ac:	10802017 	ldw	r2,128(r2)
    d1b0:	10000326 	beq	r2,zero,d1c0 <tcp_pcb_purge+0xc4>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    d1b4:	010000f4 	movhi	r4,3
    d1b8:	213d3904 	addi	r4,r4,-2844
    d1bc:	00172f80 	call	172f8 <puts>
    }

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
    d1c0:	e0bfff17 	ldw	r2,-4(fp)
    d1c4:	00ffffc4 	movi	r3,-1
    d1c8:	10c00e8d 	sth	r3,58(r2)

    tcp_segs_free(pcb->ooseq);
    d1cc:	e0bfff17 	ldw	r2,-4(fp)
    d1d0:	10802017 	ldw	r2,128(r2)
    d1d4:	1009883a 	mov	r4,r2
    d1d8:	000ca380 	call	ca38 <tcp_segs_free>
    pcb->ooseq = NULL;
    d1dc:	e0bfff17 	ldw	r2,-4(fp)
    d1e0:	10002015 	stw	zero,128(r2)
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
    d1e4:	e0bfff17 	ldw	r2,-4(fp)
    d1e8:	10801e17 	ldw	r2,120(r2)
    d1ec:	1009883a 	mov	r4,r2
    d1f0:	000ca380 	call	ca38 <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
    d1f4:	e0bfff17 	ldw	r2,-4(fp)
    d1f8:	10801f17 	ldw	r2,124(r2)
    d1fc:	1009883a 	mov	r4,r2
    d200:	000ca380 	call	ca38 <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
    d204:	e0bfff17 	ldw	r2,-4(fp)
    d208:	10001e15 	stw	zero,120(r2)
    d20c:	e0bfff17 	ldw	r2,-4(fp)
    d210:	10c01e17 	ldw	r3,120(r2)
    d214:	e0bfff17 	ldw	r2,-4(fp)
    d218:	10c01f15 	stw	r3,124(r2)
  }
}
    d21c:	e037883a 	mov	sp,fp
    d220:	dfc00117 	ldw	ra,4(sp)
    d224:	df000017 	ldw	fp,0(sp)
    d228:	dec00204 	addi	sp,sp,8
    d22c:	f800283a 	ret

0000d230 <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
    d230:	defffc04 	addi	sp,sp,-16
    d234:	dfc00315 	stw	ra,12(sp)
    d238:	df000215 	stw	fp,8(sp)
    d23c:	df000204 	addi	fp,sp,8
    d240:	e13ffe15 	stw	r4,-8(fp)
    d244:	e17fff15 	stw	r5,-4(fp)
  TCP_RMV(pcblist, pcb);
    d248:	e0bffe17 	ldw	r2,-8(fp)
    d24c:	10c00017 	ldw	r3,0(r2)
    d250:	e0bfff17 	ldw	r2,-4(fp)
    d254:	1880061e 	bne	r3,r2,d270 <tcp_pcb_remove+0x40>
    d258:	e0bffe17 	ldw	r2,-8(fp)
    d25c:	10800017 	ldw	r2,0(r2)
    d260:	10c00317 	ldw	r3,12(r2)
    d264:	e0bffe17 	ldw	r2,-8(fp)
    d268:	10c00015 	stw	r3,0(r2)
    d26c:	00001206 	br	d2b8 <tcp_pcb_remove+0x88>
    d270:	e0bffe17 	ldw	r2,-8(fp)
    d274:	10800017 	ldw	r2,0(r2)
    d278:	d0a8d915 	stw	r2,-23708(gp)
    d27c:	00000c06 	br	d2b0 <tcp_pcb_remove+0x80>
    d280:	d0a8d917 	ldw	r2,-23708(gp)
    d284:	10c00317 	ldw	r3,12(r2)
    d288:	e0bfff17 	ldw	r2,-4(fp)
    d28c:	1880051e 	bne	r3,r2,d2a4 <tcp_pcb_remove+0x74>
    d290:	d0a8d917 	ldw	r2,-23708(gp)
    d294:	e0ffff17 	ldw	r3,-4(fp)
    d298:	18c00317 	ldw	r3,12(r3)
    d29c:	10c00315 	stw	r3,12(r2)
    d2a0:	00000506 	br	d2b8 <tcp_pcb_remove+0x88>
    d2a4:	d0a8d917 	ldw	r2,-23708(gp)
    d2a8:	10800317 	ldw	r2,12(r2)
    d2ac:	d0a8d915 	stw	r2,-23708(gp)
    d2b0:	d0a8d917 	ldw	r2,-23708(gp)
    d2b4:	103ff21e 	bne	r2,zero,d280 <tcp_pcb_remove+0x50>
    d2b8:	e0bfff17 	ldw	r2,-4(fp)
    d2bc:	10000315 	stw	zero,12(r2)

  tcp_pcb_purge(pcb);
    d2c0:	e13fff17 	ldw	r4,-4(fp)
    d2c4:	000d0fc0 	call	d0fc <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
    d2c8:	e0bfff17 	ldw	r2,-4(fp)
    d2cc:	10800417 	ldw	r2,16(r2)
    d2d0:	108002a0 	cmpeqi	r2,r2,10
    d2d4:	1000111e 	bne	r2,zero,d31c <tcp_pcb_remove+0xec>
     pcb->state != LISTEN &&
    d2d8:	e0bfff17 	ldw	r2,-4(fp)
    d2dc:	10800417 	ldw	r2,16(r2)
  TCP_RMV(pcblist, pcb);

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
    d2e0:	10800060 	cmpeqi	r2,r2,1
    d2e4:	10000d1e 	bne	r2,zero,d31c <tcp_pcb_remove+0xec>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
    d2e8:	e0bfff17 	ldw	r2,-4(fp)
    d2ec:	10800983 	ldbu	r2,38(r2)
    d2f0:	10803fcc 	andi	r2,r2,255
    d2f4:	1080004c 	andi	r2,r2,1

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
     pcb->state != LISTEN &&
    d2f8:	10000826 	beq	r2,zero,d31c <tcp_pcb_remove+0xec>
     pcb->flags & TF_ACK_DELAY) {
    pcb->flags |= TF_ACK_NOW;
    d2fc:	e0bfff17 	ldw	r2,-4(fp)
    d300:	10800983 	ldbu	r2,38(r2)
    d304:	10800094 	ori	r2,r2,2
    d308:	1007883a 	mov	r3,r2
    d30c:	e0bfff17 	ldw	r2,-4(fp)
    d310:	10c00985 	stb	r3,38(r2)
    tcp_output(pcb);
    d314:	e13fff17 	ldw	r4,-4(fp)
    d318:	0012b000 	call	12b00 <tcp_output>
  }

  if (pcb->state != LISTEN) {
    d31c:	e0bfff17 	ldw	r2,-4(fp)
    d320:	10800417 	ldw	r2,16(r2)
    d324:	10800060 	cmpeqi	r2,r2,1
    d328:	1000241e 	bne	r2,zero,d3bc <tcp_pcb_remove+0x18c>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
    d32c:	e0bfff17 	ldw	r2,-4(fp)
    d330:	10801e17 	ldw	r2,120(r2)
    d334:	10000926 	beq	r2,zero,d35c <tcp_pcb_remove+0x12c>
    d338:	010000f4 	movhi	r4,3
    d33c:	213c2404 	addi	r4,r4,-3952
    d340:	014000f4 	movhi	r5,3
    d344:	297d4204 	addi	r5,r5,-2808
    d348:	01813dc4 	movi	r6,1271
    d34c:	01c000f4 	movhi	r7,3
    d350:	39fc3804 	addi	r7,r7,-3872
    d354:	00170680 	call	17068 <printf>
    d358:	003fff06 	br	d358 <tcp_pcb_remove+0x128>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
    d35c:	e0bfff17 	ldw	r2,-4(fp)
    d360:	10801f17 	ldw	r2,124(r2)
    d364:	10000926 	beq	r2,zero,d38c <tcp_pcb_remove+0x15c>
    d368:	010000f4 	movhi	r4,3
    d36c:	213c2404 	addi	r4,r4,-3952
    d370:	014000f4 	movhi	r5,3
    d374:	297d4804 	addi	r5,r5,-2784
    d378:	01813e04 	movi	r6,1272
    d37c:	01c000f4 	movhi	r7,3
    d380:	39fc3804 	addi	r7,r7,-3872
    d384:	00170680 	call	17068 <printf>
    d388:	003fff06 	br	d388 <tcp_pcb_remove+0x158>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
    d38c:	e0bfff17 	ldw	r2,-4(fp)
    d390:	10802017 	ldw	r2,128(r2)
    d394:	10000926 	beq	r2,zero,d3bc <tcp_pcb_remove+0x18c>
    d398:	010000f4 	movhi	r4,3
    d39c:	213c2404 	addi	r4,r4,-3952
    d3a0:	014000f4 	movhi	r5,3
    d3a4:	297d4f04 	addi	r5,r5,-2756
    d3a8:	01813e84 	movi	r6,1274
    d3ac:	01c000f4 	movhi	r7,3
    d3b0:	39fc3804 	addi	r7,r7,-3872
    d3b4:	00170680 	call	17068 <printf>
    d3b8:	003fff06 	br	d3b8 <tcp_pcb_remove+0x188>
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
    d3bc:	e0bfff17 	ldw	r2,-4(fp)
    d3c0:	10000415 	stw	zero,16(r2)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
    d3c4:	000d9a40 	call	d9a4 <tcp_pcbs_sane>
    d3c8:	10bfffcc 	andi	r2,r2,65535
    d3cc:	10a0001c 	xori	r2,r2,32768
    d3d0:	10a00004 	addi	r2,r2,-32768
    d3d4:	1000091e 	bne	r2,zero,d3fc <tcp_pcb_remove+0x1cc>
    d3d8:	010000f4 	movhi	r4,3
    d3dc:	213c2404 	addi	r4,r4,-3952
    d3e0:	014000f4 	movhi	r5,3
    d3e4:	297d5504 	addi	r5,r5,-2732
    d3e8:	01814004 	movi	r6,1280
    d3ec:	01c000f4 	movhi	r7,3
    d3f0:	39fc3804 	addi	r7,r7,-3872
    d3f4:	00170680 	call	17068 <printf>
    d3f8:	003fff06 	br	d3f8 <tcp_pcb_remove+0x1c8>
}
    d3fc:	e037883a 	mov	sp,fp
    d400:	dfc00117 	ldw	ra,4(sp)
    d404:	df000017 	ldw	fp,0(sp)
    d408:	dec00204 	addi	sp,sp,8
    d40c:	f800283a 	ret

0000d410 <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(void)
{
    d410:	deffff04 	addi	sp,sp,-4
    d414:	df000015 	stw	fp,0(sp)
    d418:	d839883a 	mov	fp,sp
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
    d41c:	d0e00517 	ldw	r3,-32748(gp)
    d420:	d0a8d717 	ldw	r2,-23716(gp)
    d424:	1885883a 	add	r2,r3,r2
    d428:	d0a00515 	stw	r2,-32748(gp)
  return iss;
    d42c:	d0a00517 	ldw	r2,-32748(gp)
}
    d430:	e037883a 	mov	sp,fp
    d434:	df000017 	ldw	fp,0(sp)
    d438:	dec00104 	addi	sp,sp,4
    d43c:	f800283a 	ret

0000d440 <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
{
    d440:	defffa04 	addi	sp,sp,-24
    d444:	dfc00515 	stw	ra,20(sp)
    d448:	df000415 	stw	fp,16(sp)
    d44c:	df000404 	addi	fp,sp,16
    d450:	2005883a 	mov	r2,r4
    d454:	e17fff15 	stw	r5,-4(fp)
    d458:	e0bffe0d 	sth	r2,-8(fp)
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
    d45c:	e13fff17 	ldw	r4,-4(fp)
    d460:	00061b00 	call	61b0 <ip_route>
    d464:	e0bffc15 	stw	r2,-16(fp)
  if ((outif != NULL) && (outif->mtu != 0)) {
    d468:	e0bffc17 	ldw	r2,-16(fp)
    d46c:	10000f26 	beq	r2,zero,d4ac <tcp_eff_send_mss+0x6c>
    d470:	e0bffc17 	ldw	r2,-16(fp)
    d474:	1080090b 	ldhu	r2,36(r2)
    d478:	10bfffcc 	andi	r2,r2,65535
    d47c:	10000b26 	beq	r2,zero,d4ac <tcp_eff_send_mss+0x6c>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
    d480:	e0bffc17 	ldw	r2,-16(fp)
    d484:	1080090b 	ldhu	r2,36(r2)
    d488:	10bff604 	addi	r2,r2,-40
    d48c:	e0bffd0d 	sth	r2,-12(fp)
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * We correct for TCP options in tcp_enqueue(), and don't support
     * IP options
     */
    sendmss = LWIP_MIN(sendmss, mss_s);
    d490:	e0fffe0b 	ldhu	r3,-8(fp)
    d494:	e0bffd0b 	ldhu	r2,-12(fp)
    d498:	113fffcc 	andi	r4,r2,65535
    d49c:	197fffcc 	andi	r5,r3,65535
    d4a0:	2900012e 	bgeu	r5,r4,d4a8 <tcp_eff_send_mss+0x68>
    d4a4:	1805883a 	mov	r2,r3
    d4a8:	e0bffe0d 	sth	r2,-8(fp)
  }
  return sendmss;
    d4ac:	e0bffe0b 	ldhu	r2,-8(fp)
}
    d4b0:	e037883a 	mov	sp,fp
    d4b4:	dfc00117 	ldw	ra,4(sp)
    d4b8:	df000017 	ldw	fp,0(sp)
    d4bc:	dec00204 	addi	sp,sp,8
    d4c0:	f800283a 	ret

0000d4c4 <tcp_debug_state_str>:
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

const char*
tcp_debug_state_str(enum tcp_state s)
{
    d4c4:	defffe04 	addi	sp,sp,-8
    d4c8:	df000115 	stw	fp,4(sp)
    d4cc:	df000104 	addi	fp,sp,4
    d4d0:	e13fff15 	stw	r4,-4(fp)
  return tcp_state_str[s];
    d4d4:	00c000f4 	movhi	r3,3
    d4d8:	18c90a04 	addi	r3,r3,9256
    d4dc:	e0bfff17 	ldw	r2,-4(fp)
    d4e0:	1085883a 	add	r2,r2,r2
    d4e4:	1085883a 	add	r2,r2,r2
    d4e8:	1885883a 	add	r2,r3,r2
    d4ec:	10800017 	ldw	r2,0(r2)
}
    d4f0:	e037883a 	mov	sp,fp
    d4f4:	df000017 	ldw	fp,0(sp)
    d4f8:	dec00104 	addi	sp,sp,4
    d4fc:	f800283a 	ret

0000d500 <tcp_debug_print>:
 *
 * @param tcphdr pointer to a struct tcp_hdr
 */
void
tcp_debug_print(struct tcp_hdr *tcphdr)
{
    d500:	defffd04 	addi	sp,sp,-12
    d504:	dfc00215 	stw	ra,8(sp)
    d508:	df000115 	stw	fp,4(sp)
    d50c:	df000104 	addi	fp,sp,4
    d510:	e13fff15 	stw	r4,-4(fp)
  LWIP_DEBUGF(TCP_DEBUG, ("TCP header:\n"));
    d514:	010000f4 	movhi	r4,3
    d518:	213d5d04 	addi	r4,r4,-2700
    d51c:	00172f80 	call	172f8 <puts>
  LWIP_DEBUGF(TCP_DEBUG, ("+-------------------------------+\n"));
    d520:	010000f4 	movhi	r4,3
    d524:	213d6004 	addi	r4,r4,-2688
    d528:	00172f80 	call	172f8 <puts>
  LWIP_DEBUGF(TCP_DEBUG, ("|    %5"U16_F"      |    %5"U16_F"      | (src port, dest port)\n",
    d52c:	e0bfff17 	ldw	r2,-4(fp)
    d530:	1080008b 	ldhu	r2,2(r2)
    d534:	10bfffcc 	andi	r2,r2,65535
    d538:	1004d23a 	srli	r2,r2,8
    d53c:	10ffffcc 	andi	r3,r2,65535
    d540:	e0bfff17 	ldw	r2,-4(fp)
    d544:	1080008b 	ldhu	r2,2(r2)
    d548:	10bfffcc 	andi	r2,r2,65535
    d54c:	1004923a 	slli	r2,r2,8
    d550:	10bfffcc 	andi	r2,r2,65535
    d554:	1884b03a 	or	r2,r3,r2
    d558:	1009883a 	mov	r4,r2
    d55c:	00170680 	call	17068 <printf>
         ntohs(tcphdr->src), ntohs(tcphdr->dest)));
  LWIP_DEBUGF(TCP_DEBUG, ("+-------------------------------+\n"));
    d560:	010000f4 	movhi	r4,3
    d564:	213d6004 	addi	r4,r4,-2688
    d568:	00172f80 	call	172f8 <puts>
  LWIP_DEBUGF(TCP_DEBUG, ("|           %010"U32_F"          | (seq no)\n",
    d56c:	e0bfff17 	ldw	r2,-4(fp)
    d570:	10c0010b 	ldhu	r3,4(r2)
    d574:	1080018b 	ldhu	r2,6(r2)
    d578:	1004943a 	slli	r2,r2,16
    d57c:	10c4b03a 	or	r2,r2,r3
    d580:	1006d63a 	srli	r3,r2,24
    d584:	e0bfff17 	ldw	r2,-4(fp)
    d588:	1100010b 	ldhu	r4,4(r2)
    d58c:	1080018b 	ldhu	r2,6(r2)
    d590:	1004943a 	slli	r2,r2,16
    d594:	1104b03a 	or	r2,r2,r4
    d598:	1004d23a 	srli	r2,r2,8
    d59c:	10bfc00c 	andi	r2,r2,65280
    d5a0:	1886b03a 	or	r3,r3,r2
    d5a4:	e0bfff17 	ldw	r2,-4(fp)
    d5a8:	1100010b 	ldhu	r4,4(r2)
    d5ac:	1080018b 	ldhu	r2,6(r2)
    d5b0:	1004943a 	slli	r2,r2,16
    d5b4:	1104b03a 	or	r2,r2,r4
    d5b8:	10bfc00c 	andi	r2,r2,65280
    d5bc:	1004923a 	slli	r2,r2,8
    d5c0:	1886b03a 	or	r3,r3,r2
    d5c4:	e0bfff17 	ldw	r2,-4(fp)
    d5c8:	1100010b 	ldhu	r4,4(r2)
    d5cc:	1080018b 	ldhu	r2,6(r2)
    d5d0:	1004943a 	slli	r2,r2,16
    d5d4:	1104b03a 	or	r2,r2,r4
    d5d8:	1004963a 	slli	r2,r2,24
    d5dc:	1884b03a 	or	r2,r3,r2
    d5e0:	1009883a 	mov	r4,r2
    d5e4:	00170680 	call	17068 <printf>
          ntohl(tcphdr->seqno)));
  LWIP_DEBUGF(TCP_DEBUG, ("+-------------------------------+\n"));
    d5e8:	010000f4 	movhi	r4,3
    d5ec:	213d6004 	addi	r4,r4,-2688
    d5f0:	00172f80 	call	172f8 <puts>
  LWIP_DEBUGF(TCP_DEBUG, ("|           %010"U32_F"          | (ack no)\n",
    d5f4:	e0bfff17 	ldw	r2,-4(fp)
    d5f8:	10c0020b 	ldhu	r3,8(r2)
    d5fc:	1080028b 	ldhu	r2,10(r2)
    d600:	1004943a 	slli	r2,r2,16
    d604:	10c4b03a 	or	r2,r2,r3
    d608:	1006d63a 	srli	r3,r2,24
    d60c:	e0bfff17 	ldw	r2,-4(fp)
    d610:	1100020b 	ldhu	r4,8(r2)
    d614:	1080028b 	ldhu	r2,10(r2)
    d618:	1004943a 	slli	r2,r2,16
    d61c:	1104b03a 	or	r2,r2,r4
    d620:	1004d23a 	srli	r2,r2,8
    d624:	10bfc00c 	andi	r2,r2,65280
    d628:	1886b03a 	or	r3,r3,r2
    d62c:	e0bfff17 	ldw	r2,-4(fp)
    d630:	1100020b 	ldhu	r4,8(r2)
    d634:	1080028b 	ldhu	r2,10(r2)
    d638:	1004943a 	slli	r2,r2,16
    d63c:	1104b03a 	or	r2,r2,r4
    d640:	10bfc00c 	andi	r2,r2,65280
    d644:	1004923a 	slli	r2,r2,8
    d648:	1886b03a 	or	r3,r3,r2
    d64c:	e0bfff17 	ldw	r2,-4(fp)
    d650:	1100020b 	ldhu	r4,8(r2)
    d654:	1080028b 	ldhu	r2,10(r2)
    d658:	1004943a 	slli	r2,r2,16
    d65c:	1104b03a 	or	r2,r2,r4
    d660:	1004963a 	slli	r2,r2,24
    d664:	1884b03a 	or	r2,r3,r2
    d668:	1009883a 	mov	r4,r2
    d66c:	00170680 	call	17068 <printf>
         ntohl(tcphdr->ackno)));
  LWIP_DEBUGF(TCP_DEBUG, ("+-------------------------------+\n"));
    d670:	010000f4 	movhi	r4,3
    d674:	213d6004 	addi	r4,r4,-2688
    d678:	00172f80 	call	172f8 <puts>
  LWIP_DEBUGF(TCP_DEBUG, ("| %2"U16_F" |   |%"U16_F"%"U16_F"%"U16_F"%"U16_F"%"U16_F"%"U16_F"|     %5"U16_F"     | (hdrlen, flags (",
    d67c:	e0bfff17 	ldw	r2,-4(fp)
    d680:	1080038b 	ldhu	r2,14(r2)
    d684:	10bfffcc 	andi	r2,r2,65535
    d688:	1004d23a 	srli	r2,r2,8
    d68c:	10ffffcc 	andi	r3,r2,65535
    d690:	e0bfff17 	ldw	r2,-4(fp)
    d694:	1080038b 	ldhu	r2,14(r2)
    d698:	10bfffcc 	andi	r2,r2,65535
    d69c:	1004923a 	slli	r2,r2,8
    d6a0:	10bfffcc 	andi	r2,r2,65535
    d6a4:	1884b03a 	or	r2,r3,r2
    d6a8:	1009883a 	mov	r4,r2
    d6ac:	00170680 	call	17068 <printf>
         TCPH_FLAGS(tcphdr) >> 3 & 1,
         TCPH_FLAGS(tcphdr) >> 2 & 1,
         TCPH_FLAGS(tcphdr) >> 1 & 1,
         TCPH_FLAGS(tcphdr) & 1,
         ntohs(tcphdr->wnd)));
  tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
    d6b0:	e0bfff17 	ldw	r2,-4(fp)
    d6b4:	1080030b 	ldhu	r2,12(r2)
    d6b8:	10bfffcc 	andi	r2,r2,65535
    d6bc:	1004d23a 	srli	r2,r2,8
    d6c0:	1007883a 	mov	r3,r2
    d6c4:	e0bfff17 	ldw	r2,-4(fp)
    d6c8:	1080030b 	ldhu	r2,12(r2)
    d6cc:	10bfffcc 	andi	r2,r2,65535
    d6d0:	1004923a 	slli	r2,r2,8
    d6d4:	1884b03a 	or	r2,r3,r2
    d6d8:	10803fcc 	andi	r2,r2,255
    d6dc:	10800fcc 	andi	r2,r2,63
    d6e0:	1009883a 	mov	r4,r2
    d6e4:	000d7a00 	call	d7a0 <tcp_debug_print_flags>
  LWIP_DEBUGF(TCP_DEBUG, ("), win)\n"));
    d6e8:	010000f4 	movhi	r4,3
    d6ec:	213d6904 	addi	r4,r4,-2652
    d6f0:	00172f80 	call	172f8 <puts>
  LWIP_DEBUGF(TCP_DEBUG, ("+-------------------------------+\n"));
    d6f4:	010000f4 	movhi	r4,3
    d6f8:	213d6004 	addi	r4,r4,-2688
    d6fc:	00172f80 	call	172f8 <puts>
  LWIP_DEBUGF(TCP_DEBUG, ("|    0x%04"X16_F"     |     %5"U16_F"     | (chksum, urgp)\n",
    d700:	e0bfff17 	ldw	r2,-4(fp)
    d704:	1080048b 	ldhu	r2,18(r2)
    d708:	10bfffcc 	andi	r2,r2,65535
    d70c:	1004d23a 	srli	r2,r2,8
    d710:	10ffffcc 	andi	r3,r2,65535
    d714:	e0bfff17 	ldw	r2,-4(fp)
    d718:	1080048b 	ldhu	r2,18(r2)
    d71c:	10bfffcc 	andi	r2,r2,65535
    d720:	1004923a 	slli	r2,r2,8
    d724:	10bfffcc 	andi	r2,r2,65535
    d728:	1884b03a 	or	r2,r3,r2
    d72c:	1009883a 	mov	r4,r2
    d730:	00170680 	call	17068 <printf>
         ntohs(tcphdr->chksum), ntohs(tcphdr->urgp)));
  LWIP_DEBUGF(TCP_DEBUG, ("+-------------------------------+\n"));
    d734:	010000f4 	movhi	r4,3
    d738:	213d6004 	addi	r4,r4,-2688
    d73c:	00172f80 	call	172f8 <puts>
}
    d740:	e037883a 	mov	sp,fp
    d744:	dfc00117 	ldw	ra,4(sp)
    d748:	df000017 	ldw	fp,0(sp)
    d74c:	dec00204 	addi	sp,sp,8
    d750:	f800283a 	ret

0000d754 <tcp_debug_print_state>:
 *
 * @param s enum tcp_state to print
 */
void
tcp_debug_print_state(enum tcp_state s)
{
    d754:	defffd04 	addi	sp,sp,-12
    d758:	dfc00215 	stw	ra,8(sp)
    d75c:	df000115 	stw	fp,4(sp)
    d760:	df000104 	addi	fp,sp,4
    d764:	e13fff15 	stw	r4,-4(fp)
  LWIP_DEBUGF(TCP_DEBUG, ("State: %s\n", tcp_state_str[s]));
    d768:	00c000f4 	movhi	r3,3
    d76c:	18c90a04 	addi	r3,r3,9256
    d770:	e0bfff17 	ldw	r2,-4(fp)
    d774:	1085883a 	add	r2,r2,r2
    d778:	1085883a 	add	r2,r2,r2
    d77c:	1885883a 	add	r2,r3,r2
    d780:	10800017 	ldw	r2,0(r2)
    d784:	1009883a 	mov	r4,r2
    d788:	00170680 	call	17068 <printf>
}
    d78c:	e037883a 	mov	sp,fp
    d790:	dfc00117 	ldw	ra,4(sp)
    d794:	df000017 	ldw	fp,0(sp)
    d798:	dec00204 	addi	sp,sp,8
    d79c:	f800283a 	ret

0000d7a0 <tcp_debug_print_flags>:
 *
 * @param flags tcp flags, all active flags are printed
 */
void
tcp_debug_print_flags(u8_t flags)
{
    d7a0:	defffd04 	addi	sp,sp,-12
    d7a4:	dfc00215 	stw	ra,8(sp)
    d7a8:	df000115 	stw	fp,4(sp)
    d7ac:	df000104 	addi	fp,sp,4
    d7b0:	2005883a 	mov	r2,r4
    d7b4:	e0bfff05 	stb	r2,-4(fp)
  if (flags & TCP_FIN) {
    d7b8:	e0bfff03 	ldbu	r2,-4(fp)
    d7bc:	1080004c 	andi	r2,r2,1
    d7c0:	10000326 	beq	r2,zero,d7d0 <tcp_debug_print_flags+0x30>
    LWIP_DEBUGF(TCP_DEBUG, ("FIN "));
    d7c4:	010000f4 	movhi	r4,3
    d7c8:	213d6b04 	addi	r4,r4,-2644
    d7cc:	00170680 	call	17068 <printf>
  }
  if (flags & TCP_SYN) {
    d7d0:	e0bfff03 	ldbu	r2,-4(fp)
    d7d4:	1080008c 	andi	r2,r2,2
    d7d8:	10000326 	beq	r2,zero,d7e8 <tcp_debug_print_flags+0x48>
    LWIP_DEBUGF(TCP_DEBUG, ("SYN "));
    d7dc:	010000f4 	movhi	r4,3
    d7e0:	213d6d04 	addi	r4,r4,-2636
    d7e4:	00170680 	call	17068 <printf>
  }
  if (flags & TCP_RST) {
    d7e8:	e0bfff03 	ldbu	r2,-4(fp)
    d7ec:	1080010c 	andi	r2,r2,4
    d7f0:	10000326 	beq	r2,zero,d800 <tcp_debug_print_flags+0x60>
    LWIP_DEBUGF(TCP_DEBUG, ("RST "));
    d7f4:	010000f4 	movhi	r4,3
    d7f8:	213d6f04 	addi	r4,r4,-2628
    d7fc:	00170680 	call	17068 <printf>
  }
  if (flags & TCP_PSH) {
    d800:	e0bfff03 	ldbu	r2,-4(fp)
    d804:	1080020c 	andi	r2,r2,8
    d808:	10000326 	beq	r2,zero,d818 <tcp_debug_print_flags+0x78>
    LWIP_DEBUGF(TCP_DEBUG, ("PSH "));
    d80c:	010000f4 	movhi	r4,3
    d810:	213d7104 	addi	r4,r4,-2620
    d814:	00170680 	call	17068 <printf>
  }
  if (flags & TCP_ACK) {
    d818:	e0bfff03 	ldbu	r2,-4(fp)
    d81c:	1080040c 	andi	r2,r2,16
    d820:	10000326 	beq	r2,zero,d830 <tcp_debug_print_flags+0x90>
    LWIP_DEBUGF(TCP_DEBUG, ("ACK "));
    d824:	010000f4 	movhi	r4,3
    d828:	213d7304 	addi	r4,r4,-2612
    d82c:	00170680 	call	17068 <printf>
  }
  if (flags & TCP_URG) {
    d830:	e0bfff03 	ldbu	r2,-4(fp)
    d834:	1080080c 	andi	r2,r2,32
    d838:	10000326 	beq	r2,zero,d848 <tcp_debug_print_flags+0xa8>
    LWIP_DEBUGF(TCP_DEBUG, ("URG "));
    d83c:	010000f4 	movhi	r4,3
    d840:	213d7504 	addi	r4,r4,-2604
    d844:	00170680 	call	17068 <printf>
  }
  if (flags & TCP_ECE) {
    d848:	e0bfff03 	ldbu	r2,-4(fp)
    d84c:	1080100c 	andi	r2,r2,64
    d850:	10000326 	beq	r2,zero,d860 <tcp_debug_print_flags+0xc0>
    LWIP_DEBUGF(TCP_DEBUG, ("ECE "));
    d854:	010000f4 	movhi	r4,3
    d858:	213d7704 	addi	r4,r4,-2596
    d85c:	00170680 	call	17068 <printf>
  }
  if (flags & TCP_CWR) {
    d860:	e0bfff03 	ldbu	r2,-4(fp)
    d864:	10803fcc 	andi	r2,r2,255
    d868:	1080201c 	xori	r2,r2,128
    d86c:	10bfe004 	addi	r2,r2,-128
    d870:	1000030e 	bge	r2,zero,d880 <tcp_debug_print_flags+0xe0>
    LWIP_DEBUGF(TCP_DEBUG, ("CWR "));
    d874:	010000f4 	movhi	r4,3
    d878:	213d7904 	addi	r4,r4,-2588
    d87c:	00170680 	call	17068 <printf>
  }
  LWIP_DEBUGF(TCP_DEBUG, ("\n"));
    d880:	01000284 	movi	r4,10
    d884:	00172580 	call	17258 <putchar>
}
    d888:	e037883a 	mov	sp,fp
    d88c:	dfc00117 	ldw	ra,4(sp)
    d890:	df000017 	ldw	fp,0(sp)
    d894:	dec00204 	addi	sp,sp,8
    d898:	f800283a 	ret

0000d89c <tcp_debug_print_pcbs>:
/**
 * Print all tcp_pcbs in every list for debugging purposes.
 */
void
tcp_debug_print_pcbs(void)
{
    d89c:	defffd04 	addi	sp,sp,-12
    d8a0:	dfc00215 	stw	ra,8(sp)
    d8a4:	df000115 	stw	fp,4(sp)
    d8a8:	df000104 	addi	fp,sp,4
  struct tcp_pcb *pcb;
  LWIP_DEBUGF(TCP_DEBUG, ("Active PCB states:\n"));
    d8ac:	010000f4 	movhi	r4,3
    d8b0:	213d7b04 	addi	r4,r4,-2580
    d8b4:	00172f80 	call	172f8 <puts>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    d8b8:	d0a8d617 	ldw	r2,-23720(gp)
    d8bc:	e0bfff15 	stw	r2,-4(fp)
    d8c0:	00000b06 	br	d8f0 <tcp_debug_print_pcbs+0x54>
    LWIP_DEBUGF(TCP_DEBUG, ("Local port %"U16_F", foreign port %"U16_F" snd_nxt %"U32_F" rcv_nxt %"U32_F" ",
    d8c4:	e0bfff17 	ldw	r2,-4(fp)
    d8c8:	10800a17 	ldw	r2,40(r2)
    d8cc:	1009883a 	mov	r4,r2
    d8d0:	00170680 	call	17068 <printf>
                       pcb->local_port, pcb->remote_port,
                       pcb->snd_nxt, pcb->rcv_nxt));
    tcp_debug_print_state(pcb->state);
    d8d4:	e0bfff17 	ldw	r2,-4(fp)
    d8d8:	10800417 	ldw	r2,16(r2)
    d8dc:	1009883a 	mov	r4,r2
    d8e0:	000d7540 	call	d754 <tcp_debug_print_state>
void
tcp_debug_print_pcbs(void)
{
  struct tcp_pcb *pcb;
  LWIP_DEBUGF(TCP_DEBUG, ("Active PCB states:\n"));
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    d8e4:	e0bfff17 	ldw	r2,-4(fp)
    d8e8:	10800317 	ldw	r2,12(r2)
    d8ec:	e0bfff15 	stw	r2,-4(fp)
    d8f0:	e0bfff17 	ldw	r2,-4(fp)
    d8f4:	103ff31e 	bne	r2,zero,d8c4 <tcp_debug_print_pcbs+0x28>
    LWIP_DEBUGF(TCP_DEBUG, ("Local port %"U16_F", foreign port %"U16_F" snd_nxt %"U32_F" rcv_nxt %"U32_F" ",
                       pcb->local_port, pcb->remote_port,
                       pcb->snd_nxt, pcb->rcv_nxt));
    tcp_debug_print_state(pcb->state);
  }    
  LWIP_DEBUGF(TCP_DEBUG, ("Listen PCB states:\n"));
    d8f8:	010000f4 	movhi	r4,3
    d8fc:	213d8004 	addi	r4,r4,-2560
    d900:	00172f80 	call	172f8 <puts>
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
    d904:	d0a8d817 	ldw	r2,-23712(gp)
    d908:	e0bfff15 	stw	r2,-4(fp)
    d90c:	00000b06 	br	d93c <tcp_debug_print_pcbs+0xa0>
    LWIP_DEBUGF(TCP_DEBUG, ("Local port %"U16_F", foreign port %"U16_F" snd_nxt %"U32_F" rcv_nxt %"U32_F" ",
    d910:	e0bfff17 	ldw	r2,-4(fp)
    d914:	10800a17 	ldw	r2,40(r2)
    d918:	1009883a 	mov	r4,r2
    d91c:	00170680 	call	17068 <printf>
                       pcb->local_port, pcb->remote_port,
                       pcb->snd_nxt, pcb->rcv_nxt));
    tcp_debug_print_state(pcb->state);
    d920:	e0bfff17 	ldw	r2,-4(fp)
    d924:	10800417 	ldw	r2,16(r2)
    d928:	1009883a 	mov	r4,r2
    d92c:	000d7540 	call	d754 <tcp_debug_print_state>
                       pcb->local_port, pcb->remote_port,
                       pcb->snd_nxt, pcb->rcv_nxt));
    tcp_debug_print_state(pcb->state);
  }    
  LWIP_DEBUGF(TCP_DEBUG, ("Listen PCB states:\n"));
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
    d930:	e0bfff17 	ldw	r2,-4(fp)
    d934:	10800317 	ldw	r2,12(r2)
    d938:	e0bfff15 	stw	r2,-4(fp)
    d93c:	e0bfff17 	ldw	r2,-4(fp)
    d940:	103ff31e 	bne	r2,zero,d910 <tcp_debug_print_pcbs+0x74>
    LWIP_DEBUGF(TCP_DEBUG, ("Local port %"U16_F", foreign port %"U16_F" snd_nxt %"U32_F" rcv_nxt %"U32_F" ",
                       pcb->local_port, pcb->remote_port,
                       pcb->snd_nxt, pcb->rcv_nxt));
    tcp_debug_print_state(pcb->state);
  }    
  LWIP_DEBUGF(TCP_DEBUG, ("TIME-WAIT PCB states:\n"));
    d944:	010000f4 	movhi	r4,3
    d948:	213d8504 	addi	r4,r4,-2540
    d94c:	00172f80 	call	172f8 <puts>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    d950:	d0a8db17 	ldw	r2,-23700(gp)
    d954:	e0bfff15 	stw	r2,-4(fp)
    d958:	00000b06 	br	d988 <tcp_debug_print_pcbs+0xec>
    LWIP_DEBUGF(TCP_DEBUG, ("Local port %"U16_F", foreign port %"U16_F" snd_nxt %"U32_F" rcv_nxt %"U32_F" ",
    d95c:	e0bfff17 	ldw	r2,-4(fp)
    d960:	10800a17 	ldw	r2,40(r2)
    d964:	1009883a 	mov	r4,r2
    d968:	00170680 	call	17068 <printf>
                       pcb->local_port, pcb->remote_port,
                       pcb->snd_nxt, pcb->rcv_nxt));
    tcp_debug_print_state(pcb->state);
    d96c:	e0bfff17 	ldw	r2,-4(fp)
    d970:	10800417 	ldw	r2,16(r2)
    d974:	1009883a 	mov	r4,r2
    d978:	000d7540 	call	d754 <tcp_debug_print_state>
                       pcb->local_port, pcb->remote_port,
                       pcb->snd_nxt, pcb->rcv_nxt));
    tcp_debug_print_state(pcb->state);
  }    
  LWIP_DEBUGF(TCP_DEBUG, ("TIME-WAIT PCB states:\n"));
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    d97c:	e0bfff17 	ldw	r2,-4(fp)
    d980:	10800317 	ldw	r2,12(r2)
    d984:	e0bfff15 	stw	r2,-4(fp)
    d988:	e0bfff17 	ldw	r2,-4(fp)
    d98c:	103ff31e 	bne	r2,zero,d95c <tcp_debug_print_pcbs+0xc0>
    LWIP_DEBUGF(TCP_DEBUG, ("Local port %"U16_F", foreign port %"U16_F" snd_nxt %"U32_F" rcv_nxt %"U32_F" ",
                       pcb->local_port, pcb->remote_port,
                       pcb->snd_nxt, pcb->rcv_nxt));
    tcp_debug_print_state(pcb->state);
  }    
}
    d990:	e037883a 	mov	sp,fp
    d994:	dfc00117 	ldw	ra,4(sp)
    d998:	df000017 	ldw	fp,0(sp)
    d99c:	dec00204 	addi	sp,sp,8
    d9a0:	f800283a 	ret

0000d9a4 <tcp_pcbs_sane>:
/**
 * Check state consistency of the tcp_pcb lists.
 */
s16_t
tcp_pcbs_sane(void)
{
    d9a4:	defffd04 	addi	sp,sp,-12
    d9a8:	dfc00215 	stw	ra,8(sp)
    d9ac:	df000115 	stw	fp,4(sp)
    d9b0:	df000104 	addi	fp,sp,4
  struct tcp_pcb *pcb;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    d9b4:	d0a8d617 	ldw	r2,-23720(gp)
    d9b8:	e0bfff15 	stw	r2,-4(fp)
    d9bc:	00002906 	br	da64 <tcp_pcbs_sane+0xc0>
    LWIP_ASSERT("tcp_pcbs_sane: active pcb->state != CLOSED", pcb->state != CLOSED);
    d9c0:	e0bfff17 	ldw	r2,-4(fp)
    d9c4:	10800417 	ldw	r2,16(r2)
    d9c8:	1000091e 	bne	r2,zero,d9f0 <tcp_pcbs_sane+0x4c>
    d9cc:	010000f4 	movhi	r4,3
    d9d0:	213c2404 	addi	r4,r4,-3952
    d9d4:	014000f4 	movhi	r5,3
    d9d8:	297d8b04 	addi	r5,r5,-2516
    d9dc:	01816a84 	movi	r6,1450
    d9e0:	01c000f4 	movhi	r7,3
    d9e4:	39fc3804 	addi	r7,r7,-3872
    d9e8:	00170680 	call	17068 <printf>
    d9ec:	003fff06 	br	d9ec <tcp_pcbs_sane+0x48>
    LWIP_ASSERT("tcp_pcbs_sane: active pcb->state != LISTEN", pcb->state != LISTEN);
    d9f0:	e0bfff17 	ldw	r2,-4(fp)
    d9f4:	10800417 	ldw	r2,16(r2)
    d9f8:	10800058 	cmpnei	r2,r2,1
    d9fc:	1000091e 	bne	r2,zero,da24 <tcp_pcbs_sane+0x80>
    da00:	010000f4 	movhi	r4,3
    da04:	213c2404 	addi	r4,r4,-3952
    da08:	014000f4 	movhi	r5,3
    da0c:	297d9604 	addi	r5,r5,-2472
    da10:	01816ac4 	movi	r6,1451
    da14:	01c000f4 	movhi	r7,3
    da18:	39fc3804 	addi	r7,r7,-3872
    da1c:	00170680 	call	17068 <printf>
    da20:	003fff06 	br	da20 <tcp_pcbs_sane+0x7c>
    LWIP_ASSERT("tcp_pcbs_sane: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    da24:	e0bfff17 	ldw	r2,-4(fp)
    da28:	10800417 	ldw	r2,16(r2)
    da2c:	10800298 	cmpnei	r2,r2,10
    da30:	1000091e 	bne	r2,zero,da58 <tcp_pcbs_sane+0xb4>
    da34:	010000f4 	movhi	r4,3
    da38:	213c2404 	addi	r4,r4,-3952
    da3c:	014000f4 	movhi	r5,3
    da40:	297da104 	addi	r5,r5,-2428
    da44:	01816b04 	movi	r6,1452
    da48:	01c000f4 	movhi	r7,3
    da4c:	39fc3804 	addi	r7,r7,-3872
    da50:	00170680 	call	17068 <printf>
    da54:	003fff06 	br	da54 <tcp_pcbs_sane+0xb0>
 */
s16_t
tcp_pcbs_sane(void)
{
  struct tcp_pcb *pcb;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    da58:	e0bfff17 	ldw	r2,-4(fp)
    da5c:	10800317 	ldw	r2,12(r2)
    da60:	e0bfff15 	stw	r2,-4(fp)
    da64:	e0bfff17 	ldw	r2,-4(fp)
    da68:	103fd51e 	bne	r2,zero,d9c0 <tcp_pcbs_sane+0x1c>
    LWIP_ASSERT("tcp_pcbs_sane: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_pcbs_sane: active pcb->state != LISTEN", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_pcbs_sane: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    da6c:	d0a8db17 	ldw	r2,-23700(gp)
    da70:	e0bfff15 	stw	r2,-4(fp)
    da74:	00001006 	br	dab8 <tcp_pcbs_sane+0x114>
    LWIP_ASSERT("tcp_pcbs_sane: tw pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
    da78:	e0bfff17 	ldw	r2,-4(fp)
    da7c:	10800417 	ldw	r2,16(r2)
    da80:	108002a0 	cmpeqi	r2,r2,10
    da84:	1000091e 	bne	r2,zero,daac <tcp_pcbs_sane+0x108>
    da88:	010000f4 	movhi	r4,3
    da8c:	213c2404 	addi	r4,r4,-3952
    da90:	014000f4 	movhi	r5,3
    da94:	297dad04 	addi	r5,r5,-2380
    da98:	01816bc4 	movi	r6,1455
    da9c:	01c000f4 	movhi	r7,3
    daa0:	39fc3804 	addi	r7,r7,-3872
    daa4:	00170680 	call	17068 <printf>
    daa8:	003fff06 	br	daa8 <tcp_pcbs_sane+0x104>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_pcbs_sane: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_pcbs_sane: active pcb->state != LISTEN", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_pcbs_sane: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    daac:	e0bfff17 	ldw	r2,-4(fp)
    dab0:	10800317 	ldw	r2,12(r2)
    dab4:	e0bfff15 	stw	r2,-4(fp)
    dab8:	e0bfff17 	ldw	r2,-4(fp)
    dabc:	103fee1e 	bne	r2,zero,da78 <tcp_pcbs_sane+0xd4>
    LWIP_ASSERT("tcp_pcbs_sane: tw pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  }
  return 1;
    dac0:	00800044 	movi	r2,1
}
    dac4:	e037883a 	mov	sp,fp
    dac8:	dfc00117 	ldw	ra,4(sp)
    dacc:	df000017 	ldw	fp,0(sp)
    dad0:	dec00204 	addi	sp,sp,8
    dad4:	f800283a 	ret

0000dad8 <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
    dad8:	defff604 	addi	sp,sp,-40
    dadc:	dfc00915 	stw	ra,36(sp)
    dae0:	df000815 	stw	fp,32(sp)
    dae4:	df000804 	addi	fp,sp,32
    dae8:	e13ffe15 	stw	r4,-8(fp)
    daec:	e17fff15 	stw	r5,-4(fp)
  u8_t hdrlen;
  err_t err;

  PERF_START;

  TCP_STATS_INC(tcp.recv);
    daf0:	00800134 	movhi	r2,4
    daf4:	10916104 	addi	r2,r2,17796
    daf8:	1080248b 	ldhu	r2,146(r2)
    dafc:	10800044 	addi	r2,r2,1
    db00:	1007883a 	mov	r3,r2
    db04:	00800134 	movhi	r2,4
    db08:	10916104 	addi	r2,r2,17796
    db0c:	10c0248d 	sth	r3,146(r2)
  snmp_inc_tcpinsegs();

  iphdr = p->payload;
    db10:	e0bffe17 	ldw	r2,-8(fp)
    db14:	10800117 	ldw	r2,4(r2)
    db18:	d0a8dd15 	stw	r2,-23692(gp)
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
    db1c:	e0bffe17 	ldw	r2,-8(fp)
    db20:	10c00117 	ldw	r3,4(r2)
    db24:	d0a8dd17 	ldw	r2,-23692(gp)
    db28:	1080000b 	ldhu	r2,0(r2)
    db2c:	10bfffcc 	andi	r2,r2,65535
    db30:	1004d23a 	srli	r2,r2,8
    db34:	113fffcc 	andi	r4,r2,65535
    db38:	d0a8dd17 	ldw	r2,-23692(gp)
    db3c:	1080000b 	ldhu	r2,0(r2)
    db40:	10bfffcc 	andi	r2,r2,65535
    db44:	1004923a 	slli	r2,r2,8
    db48:	10bfffcc 	andi	r2,r2,65535
    db4c:	2084b03a 	or	r2,r4,r2
    db50:	1005d23a 	srai	r2,r2,8
    db54:	108003cc 	andi	r2,r2,15
    db58:	1085883a 	add	r2,r2,r2
    db5c:	1085883a 	add	r2,r2,r2
    db60:	1885883a 	add	r2,r3,r2
    db64:	d0a8dc15 	stw	r2,-23696(gp)
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
    db68:	d0a8dd17 	ldw	r2,-23692(gp)
    db6c:	1080000b 	ldhu	r2,0(r2)
    db70:	10bfffcc 	andi	r2,r2,65535
    db74:	1004d23a 	srli	r2,r2,8
    db78:	10ffffcc 	andi	r3,r2,65535
    db7c:	d0a8dd17 	ldw	r2,-23692(gp)
    db80:	1080000b 	ldhu	r2,0(r2)
    db84:	10bfffcc 	andi	r2,r2,65535
    db88:	1004923a 	slli	r2,r2,8
    db8c:	10bfffcc 	andi	r2,r2,65535
    db90:	1884b03a 	or	r2,r3,r2
    db94:	1005d23a 	srai	r2,r2,8
    db98:	108003cc 	andi	r2,r2,15
    db9c:	1085883a 	add	r2,r2,r2
    dba0:	1085883a 	add	r2,r2,r2
    dba4:	0085c83a 	sub	r2,zero,r2
    dba8:	10bfffcc 	andi	r2,r2,65535
    dbac:	10a0001c 	xori	r2,r2,32768
    dbb0:	10a00004 	addi	r2,r2,-32768
    dbb4:	e13ffe17 	ldw	r4,-8(fp)
    dbb8:	100b883a 	mov	r5,r2
    dbbc:	0009f900 	call	9f90 <pbuf_header>
    dbc0:	10803fcc 	andi	r2,r2,255
    dbc4:	1000051e 	bne	r2,zero,dbdc <tcp_input+0x104>
    dbc8:	e0bffe17 	ldw	r2,-8(fp)
    dbcc:	1080020b 	ldhu	r2,8(r2)
    dbd0:	10bfffcc 	andi	r2,r2,65535
    dbd4:	10800528 	cmpgeui	r2,r2,20
    dbd8:	1000131e 	bne	r2,zero,dc28 <tcp_input+0x150>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
    TCP_STATS_INC(tcp.lenerr);
    dbdc:	00800134 	movhi	r2,4
    dbe0:	10916104 	addi	r2,r2,17796
    dbe4:	1080268b 	ldhu	r2,154(r2)
    dbe8:	10800044 	addi	r2,r2,1
    dbec:	1007883a 	mov	r3,r2
    dbf0:	00800134 	movhi	r2,4
    dbf4:	10916104 	addi	r2,r2,17796
    dbf8:	10c0268d 	sth	r3,154(r2)
    TCP_STATS_INC(tcp.drop);
    dbfc:	00800134 	movhi	r2,4
    dc00:	10916104 	addi	r2,r2,17796
    dc04:	1080258b 	ldhu	r2,150(r2)
    dc08:	10800044 	addi	r2,r2,1
    dc0c:	1007883a 	mov	r3,r2
    dc10:	00800134 	movhi	r2,4
    dc14:	10916104 	addi	r2,r2,17796
    dc18:	10c0258d 	sth	r3,150(r2)
    snmp_inc_tcpinerrs();
    pbuf_free(p);
    dc1c:	e13ffe17 	ldw	r4,-8(fp)
    dc20:	000a1880 	call	a188 <pbuf_free>
    return;
    dc24:	00030506 	br	e83c <tcp_input+0xd64>
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
    dc28:	d0a8dd17 	ldw	r2,-23692(gp)
    dc2c:	10800404 	addi	r2,r2,16
    dc30:	1009883a 	mov	r4,r2
    dc34:	e17fff17 	ldw	r5,-4(fp)
    dc38:	0006dcc0 	call	6dcc <ip_addr_isbroadcast>
    dc3c:	10803fcc 	andi	r2,r2,255
    dc40:	1000081e 	bne	r2,zero,dc64 <tcp_input+0x18c>
      ip_addr_ismulticast(&(iphdr->dest))) {
    dc44:	d0a8dd17 	ldw	r2,-23692(gp)
    dc48:	10c0040b 	ldhu	r3,16(r2)
    dc4c:	1080048b 	ldhu	r2,18(r2)
    dc50:	1004943a 	slli	r2,r2,16
    dc54:	10c4b03a 	or	r2,r2,r3
    dc58:	10803c0c 	andi	r2,r2,240
    pbuf_free(p);
    return;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
    dc5c:	10803818 	cmpnei	r2,r2,224
    dc60:	1000131e 	bne	r2,zero,dcb0 <tcp_input+0x1d8>
      ip_addr_ismulticast(&(iphdr->dest))) {
    TCP_STATS_INC(tcp.proterr);
    dc64:	00800134 	movhi	r2,4
    dc68:	10916104 	addi	r2,r2,17796
    dc6c:	1080280b 	ldhu	r2,160(r2)
    dc70:	10800044 	addi	r2,r2,1
    dc74:	1007883a 	mov	r3,r2
    dc78:	00800134 	movhi	r2,4
    dc7c:	10916104 	addi	r2,r2,17796
    dc80:	10c0280d 	sth	r3,160(r2)
    TCP_STATS_INC(tcp.drop);
    dc84:	00800134 	movhi	r2,4
    dc88:	10916104 	addi	r2,r2,17796
    dc8c:	1080258b 	ldhu	r2,150(r2)
    dc90:	10800044 	addi	r2,r2,1
    dc94:	1007883a 	mov	r3,r2
    dc98:	00800134 	movhi	r2,4
    dc9c:	10916104 	addi	r2,r2,17796
    dca0:	10c0258d 	sth	r3,150(r2)
    snmp_inc_tcpinerrs();
    pbuf_free(p);
    dca4:	e13ffe17 	ldw	r4,-8(fp)
    dca8:	000a1880 	call	a188 <pbuf_free>
    return;
    dcac:	0002e306 	br	e83c <tcp_input+0xd64>
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
    dcb0:	d0a8dd17 	ldw	r2,-23692(gp)
    dcb4:	10c00304 	addi	r3,r2,12
      (struct ip_addr *)&(iphdr->dest),
    dcb8:	d0a8dd17 	ldw	r2,-23692(gp)
    return;
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
    dcbc:	10800404 	addi	r2,r2,16
      (struct ip_addr *)&(iphdr->dest),
      IP_PROTO_TCP, p->tot_len) != 0) {
    dcc0:	e13ffe17 	ldw	r4,-8(fp)
    dcc4:	2100020b 	ldhu	r4,8(r4)
    return;
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
    dcc8:	213fffcc 	andi	r4,r4,65535
    dccc:	d9000015 	stw	r4,0(sp)
    dcd0:	e13ffe17 	ldw	r4,-8(fp)
    dcd4:	180b883a 	mov	r5,r3
    dcd8:	100d883a 	mov	r6,r2
    dcdc:	01c00184 	movi	r7,6
    dce0:	0005e400 	call	5e40 <inet_chksum_pseudo>
    dce4:	10bfffcc 	andi	r2,r2,65535
    dce8:	10001626 	beq	r2,zero,dd44 <tcp_input+0x26c>
      IP_PROTO_TCP, p->tot_len) != 0) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packet discarded due to failing checksum 0x%04"X16_F"\n",
        inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src), (struct ip_addr *)&(iphdr->dest),
      IP_PROTO_TCP, p->tot_len)));
#if TCP_DEBUG
    tcp_debug_print(tcphdr);
    dcec:	d0a8dc17 	ldw	r2,-23696(gp)
    dcf0:	1009883a 	mov	r4,r2
    dcf4:	000d5000 	call	d500 <tcp_debug_print>
#endif /* TCP_DEBUG */
    TCP_STATS_INC(tcp.chkerr);
    dcf8:	00800134 	movhi	r2,4
    dcfc:	10916104 	addi	r2,r2,17796
    dd00:	1080260b 	ldhu	r2,152(r2)
    dd04:	10800044 	addi	r2,r2,1
    dd08:	1007883a 	mov	r3,r2
    dd0c:	00800134 	movhi	r2,4
    dd10:	10916104 	addi	r2,r2,17796
    dd14:	10c0260d 	sth	r3,152(r2)
    TCP_STATS_INC(tcp.drop);
    dd18:	00800134 	movhi	r2,4
    dd1c:	10916104 	addi	r2,r2,17796
    dd20:	1080258b 	ldhu	r2,150(r2)
    dd24:	10800044 	addi	r2,r2,1
    dd28:	1007883a 	mov	r3,r2
    dd2c:	00800134 	movhi	r2,4
    dd30:	10916104 	addi	r2,r2,17796
    dd34:	10c0258d 	sth	r3,150(r2)
    snmp_inc_tcpinerrs();
    pbuf_free(p);
    dd38:	e13ffe17 	ldw	r4,-8(fp)
    dd3c:	000a1880 	call	a188 <pbuf_free>
    return;
    dd40:	0002be06 	br	e83c <tcp_input+0xd64>
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
    dd44:	d0a8dc17 	ldw	r2,-23696(gp)
    dd48:	1080030b 	ldhu	r2,12(r2)
    dd4c:	10bfffcc 	andi	r2,r2,65535
    dd50:	1004d23a 	srli	r2,r2,8
    dd54:	10ffffcc 	andi	r3,r2,65535
    dd58:	d0a8dc17 	ldw	r2,-23696(gp)
    dd5c:	1080030b 	ldhu	r2,12(r2)
    dd60:	10bfffcc 	andi	r2,r2,65535
    dd64:	1004923a 	slli	r2,r2,8
    dd68:	10bfffcc 	andi	r2,r2,65535
    dd6c:	1884b03a 	or	r2,r3,r2
    dd70:	1005d33a 	srai	r2,r2,12
    dd74:	e0bffd45 	stb	r2,-11(fp)
  if(pbuf_header(p, -(hdrlen * 4))){
    dd78:	e0bffd43 	ldbu	r2,-11(fp)
    dd7c:	10bfff24 	muli	r2,r2,-4
    dd80:	10bfffcc 	andi	r2,r2,65535
    dd84:	10a0001c 	xori	r2,r2,32768
    dd88:	10a00004 	addi	r2,r2,-32768
    dd8c:	e13ffe17 	ldw	r4,-8(fp)
    dd90:	100b883a 	mov	r5,r2
    dd94:	0009f900 	call	9f90 <pbuf_header>
    dd98:	10803fcc 	andi	r2,r2,255
    dd9c:	10001326 	beq	r2,zero,ddec <tcp_input+0x314>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
    TCP_STATS_INC(tcp.lenerr);
    dda0:	00800134 	movhi	r2,4
    dda4:	10916104 	addi	r2,r2,17796
    dda8:	1080268b 	ldhu	r2,154(r2)
    ddac:	10800044 	addi	r2,r2,1
    ddb0:	1007883a 	mov	r3,r2
    ddb4:	00800134 	movhi	r2,4
    ddb8:	10916104 	addi	r2,r2,17796
    ddbc:	10c0268d 	sth	r3,154(r2)
    TCP_STATS_INC(tcp.drop);
    ddc0:	00800134 	movhi	r2,4
    ddc4:	10916104 	addi	r2,r2,17796
    ddc8:	1080258b 	ldhu	r2,150(r2)
    ddcc:	10800044 	addi	r2,r2,1
    ddd0:	1007883a 	mov	r3,r2
    ddd4:	00800134 	movhi	r2,4
    ddd8:	10916104 	addi	r2,r2,17796
    dddc:	10c0258d 	sth	r3,150(r2)
    snmp_inc_tcpinerrs();
    pbuf_free(p);
    dde0:	e13ffe17 	ldw	r4,-8(fp)
    dde4:	000a1880 	call	a188 <pbuf_free>
    return;
    dde8:	00029406 	br	e83c <tcp_input+0xd64>
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
    ddec:	d0a8dc17 	ldw	r2,-23696(gp)
    ddf0:	d0e8dc17 	ldw	r3,-23696(gp)
    ddf4:	18c0000b 	ldhu	r3,0(r3)
    ddf8:	18ffffcc 	andi	r3,r3,65535
    ddfc:	1806d23a 	srli	r3,r3,8
    de00:	1809883a 	mov	r4,r3
    de04:	d0e8dc17 	ldw	r3,-23696(gp)
    de08:	18c0000b 	ldhu	r3,0(r3)
    de0c:	18ffffcc 	andi	r3,r3,65535
    de10:	1806923a 	slli	r3,r3,8
    de14:	20c6b03a 	or	r3,r4,r3
    de18:	10c0000d 	sth	r3,0(r2)
  tcphdr->dest = ntohs(tcphdr->dest);
    de1c:	d0a8dc17 	ldw	r2,-23696(gp)
    de20:	d0e8dc17 	ldw	r3,-23696(gp)
    de24:	18c0008b 	ldhu	r3,2(r3)
    de28:	18ffffcc 	andi	r3,r3,65535
    de2c:	1806d23a 	srli	r3,r3,8
    de30:	1809883a 	mov	r4,r3
    de34:	d0e8dc17 	ldw	r3,-23696(gp)
    de38:	18c0008b 	ldhu	r3,2(r3)
    de3c:	18ffffcc 	andi	r3,r3,65535
    de40:	1806923a 	slli	r3,r3,8
    de44:	20c6b03a 	or	r3,r4,r3
    de48:	10c0008d 	sth	r3,2(r2)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
    de4c:	d0a8dc17 	ldw	r2,-23696(gp)
    de50:	d0e8dc17 	ldw	r3,-23696(gp)
    de54:	1900010b 	ldhu	r4,4(r3)
    de58:	18c0018b 	ldhu	r3,6(r3)
    de5c:	1806943a 	slli	r3,r3,16
    de60:	1906b03a 	or	r3,r3,r4
    de64:	1808d63a 	srli	r4,r3,24
    de68:	d0e8dc17 	ldw	r3,-23696(gp)
    de6c:	1940010b 	ldhu	r5,4(r3)
    de70:	18c0018b 	ldhu	r3,6(r3)
    de74:	1806943a 	slli	r3,r3,16
    de78:	1946b03a 	or	r3,r3,r5
    de7c:	1806d23a 	srli	r3,r3,8
    de80:	18ffc00c 	andi	r3,r3,65280
    de84:	20c8b03a 	or	r4,r4,r3
    de88:	d0e8dc17 	ldw	r3,-23696(gp)
    de8c:	1940010b 	ldhu	r5,4(r3)
    de90:	18c0018b 	ldhu	r3,6(r3)
    de94:	1806943a 	slli	r3,r3,16
    de98:	1946b03a 	or	r3,r3,r5
    de9c:	18ffc00c 	andi	r3,r3,65280
    dea0:	1806923a 	slli	r3,r3,8
    dea4:	20c8b03a 	or	r4,r4,r3
    dea8:	d0e8dc17 	ldw	r3,-23696(gp)
    deac:	1940010b 	ldhu	r5,4(r3)
    deb0:	18c0018b 	ldhu	r3,6(r3)
    deb4:	1806943a 	slli	r3,r3,16
    deb8:	1946b03a 	or	r3,r3,r5
    debc:	1806963a 	slli	r3,r3,24
    dec0:	20c6b03a 	or	r3,r4,r3
    dec4:	193fffcc 	andi	r4,r3,65535
    dec8:	1140010b 	ldhu	r5,4(r2)
    decc:	280a703a 	and	r5,r5,zero
    ded0:	2908b03a 	or	r4,r5,r4
    ded4:	1100010d 	sth	r4,4(r2)
    ded8:	1806d43a 	srli	r3,r3,16
    dedc:	1100018b 	ldhu	r4,6(r2)
    dee0:	2008703a 	and	r4,r4,zero
    dee4:	20c6b03a 	or	r3,r4,r3
    dee8:	10c0018d 	sth	r3,6(r2)
    deec:	10c0010b 	ldhu	r3,4(r2)
    def0:	1080018b 	ldhu	r2,6(r2)
    def4:	1004943a 	slli	r2,r2,16
    def8:	10c4b03a 	or	r2,r2,r3
    defc:	d0a8de15 	stw	r2,-23688(gp)
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
    df00:	d0a8dc17 	ldw	r2,-23696(gp)
    df04:	d0e8dc17 	ldw	r3,-23696(gp)
    df08:	1900020b 	ldhu	r4,8(r3)
    df0c:	18c0028b 	ldhu	r3,10(r3)
    df10:	1806943a 	slli	r3,r3,16
    df14:	1906b03a 	or	r3,r3,r4
    df18:	1808d63a 	srli	r4,r3,24
    df1c:	d0e8dc17 	ldw	r3,-23696(gp)
    df20:	1940020b 	ldhu	r5,8(r3)
    df24:	18c0028b 	ldhu	r3,10(r3)
    df28:	1806943a 	slli	r3,r3,16
    df2c:	1946b03a 	or	r3,r3,r5
    df30:	1806d23a 	srli	r3,r3,8
    df34:	18ffc00c 	andi	r3,r3,65280
    df38:	20c8b03a 	or	r4,r4,r3
    df3c:	d0e8dc17 	ldw	r3,-23696(gp)
    df40:	1940020b 	ldhu	r5,8(r3)
    df44:	18c0028b 	ldhu	r3,10(r3)
    df48:	1806943a 	slli	r3,r3,16
    df4c:	1946b03a 	or	r3,r3,r5
    df50:	18ffc00c 	andi	r3,r3,65280
    df54:	1806923a 	slli	r3,r3,8
    df58:	20c8b03a 	or	r4,r4,r3
    df5c:	d0e8dc17 	ldw	r3,-23696(gp)
    df60:	1940020b 	ldhu	r5,8(r3)
    df64:	18c0028b 	ldhu	r3,10(r3)
    df68:	1806943a 	slli	r3,r3,16
    df6c:	1946b03a 	or	r3,r3,r5
    df70:	1806963a 	slli	r3,r3,24
    df74:	20c6b03a 	or	r3,r4,r3
    df78:	193fffcc 	andi	r4,r3,65535
    df7c:	1140020b 	ldhu	r5,8(r2)
    df80:	280a703a 	and	r5,r5,zero
    df84:	2908b03a 	or	r4,r5,r4
    df88:	1100020d 	sth	r4,8(r2)
    df8c:	1806d43a 	srli	r3,r3,16
    df90:	1100028b 	ldhu	r4,10(r2)
    df94:	2008703a 	and	r4,r4,zero
    df98:	20c6b03a 	or	r3,r4,r3
    df9c:	10c0028d 	sth	r3,10(r2)
    dfa0:	10c0020b 	ldhu	r3,8(r2)
    dfa4:	1080028b 	ldhu	r2,10(r2)
    dfa8:	1004943a 	slli	r2,r2,16
    dfac:	10c4b03a 	or	r2,r2,r3
    dfb0:	d0a8df15 	stw	r2,-23684(gp)
  tcphdr->wnd = ntohs(tcphdr->wnd);
    dfb4:	d0a8dc17 	ldw	r2,-23696(gp)
    dfb8:	d0e8dc17 	ldw	r3,-23696(gp)
    dfbc:	18c0038b 	ldhu	r3,14(r3)
    dfc0:	18ffffcc 	andi	r3,r3,65535
    dfc4:	1806d23a 	srli	r3,r3,8
    dfc8:	1809883a 	mov	r4,r3
    dfcc:	d0e8dc17 	ldw	r3,-23696(gp)
    dfd0:	18c0038b 	ldhu	r3,14(r3)
    dfd4:	18ffffcc 	andi	r3,r3,65535
    dfd8:	1806923a 	slli	r3,r3,8
    dfdc:	20c6b03a 	or	r3,r4,r3
    dfe0:	10c0038d 	sth	r3,14(r2)

  flags = TCPH_FLAGS(tcphdr);
    dfe4:	d0a8dc17 	ldw	r2,-23696(gp)
    dfe8:	1080030b 	ldhu	r2,12(r2)
    dfec:	10bfffcc 	andi	r2,r2,65535
    dff0:	1004d23a 	srli	r2,r2,8
    dff4:	1007883a 	mov	r3,r2
    dff8:	d0a8dc17 	ldw	r2,-23696(gp)
    dffc:	1080030b 	ldhu	r2,12(r2)
    e000:	10bfffcc 	andi	r2,r2,65535
    e004:	1004923a 	slli	r2,r2,8
    e008:	1884b03a 	or	r2,r3,r2
    e00c:	10800fcc 	andi	r2,r2,63
    e010:	d0a8e005 	stb	r2,-23680(gp)
  tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
    e014:	e0bffe17 	ldw	r2,-8(fp)
    e018:	10c0020b 	ldhu	r3,8(r2)
    e01c:	d0a8e003 	ldbu	r2,-23680(gp)
    e020:	10803fcc 	andi	r2,r2,255
    e024:	108000cc 	andi	r2,r2,3
    e028:	1004c03a 	cmpne	r2,r2,zero
    e02c:	10803fcc 	andi	r2,r2,255
    e030:	1885883a 	add	r2,r3,r2
    e034:	d0a8e08d 	sth	r2,-23678(gp)

  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;
    e038:	e03ffb15 	stw	zero,-20(fp)

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    e03c:	008000f4 	movhi	r2,3
    e040:	1099c204 	addi	r2,r2,26376
    e044:	10800017 	ldw	r2,0(r2)
    e048:	e0bffa15 	stw	r2,-24(fp)
    e04c:	00007206 	br	e218 <tcp_input+0x740>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    e050:	e0bffa17 	ldw	r2,-24(fp)
    e054:	10800417 	ldw	r2,16(r2)
    e058:	1000091e 	bne	r2,zero,e080 <tcp_input+0x5a8>
    e05c:	010000f4 	movhi	r4,3
    e060:	213db804 	addi	r4,r4,-2336
    e064:	014000f4 	movhi	r5,3
    e068:	297dc204 	addi	r5,r5,-2296
    e06c:	01802d44 	movi	r6,181
    e070:	01c000f4 	movhi	r7,3
    e074:	39fdcc04 	addi	r7,r7,-2256
    e078:	00170680 	call	17068 <printf>
    e07c:	003fff06 	br	e07c <tcp_input+0x5a4>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    e080:	e0bffa17 	ldw	r2,-24(fp)
    e084:	10800417 	ldw	r2,16(r2)
    e088:	10800298 	cmpnei	r2,r2,10
    e08c:	1000091e 	bne	r2,zero,e0b4 <tcp_input+0x5dc>
    e090:	010000f4 	movhi	r4,3
    e094:	213db804 	addi	r4,r4,-2336
    e098:	014000f4 	movhi	r5,3
    e09c:	297dd204 	addi	r5,r5,-2232
    e0a0:	01802d84 	movi	r6,182
    e0a4:	01c000f4 	movhi	r7,3
    e0a8:	39fdcc04 	addi	r7,r7,-2256
    e0ac:	00170680 	call	17068 <printf>
    e0b0:	003fff06 	br	e0b0 <tcp_input+0x5d8>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    e0b4:	e0bffa17 	ldw	r2,-24(fp)
    e0b8:	10800417 	ldw	r2,16(r2)
    e0bc:	10800058 	cmpnei	r2,r2,1
    e0c0:	1000091e 	bne	r2,zero,e0e8 <tcp_input+0x610>
    e0c4:	010000f4 	movhi	r4,3
    e0c8:	213db804 	addi	r4,r4,-2336
    e0cc:	014000f4 	movhi	r5,3
    e0d0:	297ddd04 	addi	r5,r5,-2188
    e0d4:	01802dc4 	movi	r6,183
    e0d8:	01c000f4 	movhi	r7,3
    e0dc:	39fdcc04 	addi	r7,r7,-2256
    e0e0:	00170680 	call	17068 <printf>
    e0e4:	003fff06 	br	e0e4 <tcp_input+0x60c>
    if (pcb->remote_port == tcphdr->src &&
    e0e8:	e0bffa17 	ldw	r2,-24(fp)
    e0ec:	10c0090b 	ldhu	r3,36(r2)
    e0f0:	d0a8dc17 	ldw	r2,-23696(gp)
    e0f4:	1080000b 	ldhu	r2,0(r2)
    e0f8:	18ffffcc 	andi	r3,r3,65535
    e0fc:	10bfffcc 	andi	r2,r2,65535
    e100:	1880401e 	bne	r3,r2,e204 <tcp_input+0x72c>
       pcb->local_port == tcphdr->dest &&
    e104:	e0bffa17 	ldw	r2,-24(fp)
    e108:	10c0070b 	ldhu	r3,28(r2)
    e10c:	d0a8dc17 	ldw	r2,-23696(gp)
    e110:	1080008b 	ldhu	r2,2(r2)
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
    e114:	18ffffcc 	andi	r3,r3,65535
    e118:	10bfffcc 	andi	r2,r2,65535
    e11c:	1880391e 	bne	r3,r2,e204 <tcp_input+0x72c>
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
    e120:	e0bffa17 	ldw	r2,-24(fp)
    e124:	10c00117 	ldw	r3,4(r2)
    e128:	d0a8dd17 	ldw	r2,-23692(gp)
    e12c:	1100030b 	ldhu	r4,12(r2)
    e130:	1080038b 	ldhu	r2,14(r2)
    e134:	1004943a 	slli	r2,r2,16
    e138:	1104b03a 	or	r2,r2,r4
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
       pcb->local_port == tcphdr->dest &&
    e13c:	1880311e 	bne	r3,r2,e204 <tcp_input+0x72c>
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
       ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
    e140:	e0bffa17 	ldw	r2,-24(fp)
    e144:	10c00017 	ldw	r3,0(r2)
    e148:	d0a8dd17 	ldw	r2,-23692(gp)
    e14c:	1100040b 	ldhu	r4,16(r2)
    e150:	1080048b 	ldhu	r2,18(r2)
    e154:	1004943a 	slli	r2,r2,16
    e158:	1104b03a 	or	r2,r2,r4
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
    e15c:	1880291e 	bne	r3,r2,e204 <tcp_input+0x72c>
       ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
    e160:	e0bffa17 	ldw	r2,-24(fp)
    e164:	10c00317 	ldw	r3,12(r2)
    e168:	e0bffa17 	ldw	r2,-24(fp)
    e16c:	1880091e 	bne	r3,r2,e194 <tcp_input+0x6bc>
    e170:	010000f4 	movhi	r4,3
    e174:	213db804 	addi	r4,r4,-2336
    e178:	014000f4 	movhi	r5,3
    e17c:	297de704 	addi	r5,r5,-2148
    e180:	01803004 	movi	r6,192
    e184:	01c000f4 	movhi	r7,3
    e188:	39fdcc04 	addi	r7,r7,-2256
    e18c:	00170680 	call	17068 <printf>
    e190:	003fff06 	br	e190 <tcp_input+0x6b8>
      if (prev != NULL) {
    e194:	e0bffb17 	ldw	r2,-20(fp)
    e198:	10000d26 	beq	r2,zero,e1d0 <tcp_input+0x6f8>
        prev->next = pcb->next;
    e19c:	e0bffa17 	ldw	r2,-24(fp)
    e1a0:	10c00317 	ldw	r3,12(r2)
    e1a4:	e0bffb17 	ldw	r2,-20(fp)
    e1a8:	10c00315 	stw	r3,12(r2)
        pcb->next = tcp_active_pcbs;
    e1ac:	008000f4 	movhi	r2,3
    e1b0:	1099c204 	addi	r2,r2,26376
    e1b4:	10c00017 	ldw	r3,0(r2)
    e1b8:	e0bffa17 	ldw	r2,-24(fp)
    e1bc:	10c00315 	stw	r3,12(r2)
        tcp_active_pcbs = pcb;
    e1c0:	008000f4 	movhi	r2,3
    e1c4:	1099c204 	addi	r2,r2,26376
    e1c8:	e0fffa17 	ldw	r3,-24(fp)
    e1cc:	10c00015 	stw	r3,0(r2)
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
    e1d0:	e0bffa17 	ldw	r2,-24(fp)
    e1d4:	10c00317 	ldw	r3,12(r2)
    e1d8:	e0bffa17 	ldw	r2,-24(fp)
    e1dc:	1880111e 	bne	r3,r2,e224 <tcp_input+0x74c>
    e1e0:	010000f4 	movhi	r4,3
    e1e4:	213db804 	addi	r4,r4,-2336
    e1e8:	014000f4 	movhi	r5,3
    e1ec:	297df204 	addi	r5,r5,-2104
    e1f0:	01803184 	movi	r6,198
    e1f4:	01c000f4 	movhi	r7,3
    e1f8:	39fdcc04 	addi	r7,r7,-2256
    e1fc:	00170680 	call	17068 <printf>
    e200:	003fff06 	br	e200 <tcp_input+0x728>
      break;
    }
    prev = pcb;
    e204:	e0bffa17 	ldw	r2,-24(fp)
    e208:	e0bffb15 	stw	r2,-20(fp)
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    e20c:	e0bffa17 	ldw	r2,-24(fp)
    e210:	10800317 	ldw	r2,12(r2)
    e214:	e0bffa15 	stw	r2,-24(fp)
    e218:	e0bffa17 	ldw	r2,-24(fp)
    e21c:	103f8c1e 	bne	r2,zero,e050 <tcp_input+0x578>
    e220:	00000106 	br	e228 <tcp_input+0x750>
        prev->next = pcb->next;
        pcb->next = tcp_active_pcbs;
        tcp_active_pcbs = pcb;
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
      break;
    e224:	0001883a 	nop
    }
    prev = pcb;
  }

  if (pcb == NULL) {
    e228:	e0bffa17 	ldw	r2,-24(fp)
    e22c:	10006f1e 	bne	r2,zero,e3ec <tcp_input+0x914>
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    e230:	008000f4 	movhi	r2,3
    e234:	1099c704 	addi	r2,r2,26396
    e238:	10800017 	ldw	r2,0(r2)
    e23c:	e0bffa15 	stw	r2,-24(fp)
    e240:	00003306 	br	e310 <tcp_input+0x838>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
    e244:	e0bffa17 	ldw	r2,-24(fp)
    e248:	10800417 	ldw	r2,16(r2)
    e24c:	108002a0 	cmpeqi	r2,r2,10
    e250:	1000091e 	bne	r2,zero,e278 <tcp_input+0x7a0>
    e254:	010000f4 	movhi	r4,3
    e258:	213db804 	addi	r4,r4,-2336
    e25c:	014000f4 	movhi	r5,3
    e260:	297dfd04 	addi	r5,r5,-2060
    e264:	01803404 	movi	r6,208
    e268:	01c000f4 	movhi	r7,3
    e26c:	39fdcc04 	addi	r7,r7,-2256
    e270:	00170680 	call	17068 <printf>
    e274:	003fff06 	br	e274 <tcp_input+0x79c>
      if (pcb->remote_port == tcphdr->src &&
    e278:	e0bffa17 	ldw	r2,-24(fp)
    e27c:	10c0090b 	ldhu	r3,36(r2)
    e280:	d0a8dc17 	ldw	r2,-23696(gp)
    e284:	1080000b 	ldhu	r2,0(r2)
    e288:	18ffffcc 	andi	r3,r3,65535
    e28c:	10bfffcc 	andi	r2,r2,65535
    e290:	18801c1e 	bne	r3,r2,e304 <tcp_input+0x82c>
         pcb->local_port == tcphdr->dest &&
    e294:	e0bffa17 	ldw	r2,-24(fp)
    e298:	10c0070b 	ldhu	r3,28(r2)
    e29c:	d0a8dc17 	ldw	r2,-23696(gp)
    e2a0:	1080008b 	ldhu	r2,2(r2)
  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
    e2a4:	18ffffcc 	andi	r3,r3,65535
    e2a8:	10bfffcc 	andi	r2,r2,65535
    e2ac:	1880151e 	bne	r3,r2,e304 <tcp_input+0x82c>
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
    e2b0:	e0bffa17 	ldw	r2,-24(fp)
    e2b4:	10c00117 	ldw	r3,4(r2)
    e2b8:	d0a8dd17 	ldw	r2,-23692(gp)
    e2bc:	1100030b 	ldhu	r4,12(r2)
    e2c0:	1080038b 	ldhu	r2,14(r2)
    e2c4:	1004943a 	slli	r2,r2,16
    e2c8:	1104b03a 	or	r2,r2,r4
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
         pcb->local_port == tcphdr->dest &&
    e2cc:	18800d1e 	bne	r3,r2,e304 <tcp_input+0x82c>
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
         ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
    e2d0:	e0bffa17 	ldw	r2,-24(fp)
    e2d4:	10c00017 	ldw	r3,0(r2)
    e2d8:	d0a8dd17 	ldw	r2,-23692(gp)
    e2dc:	1100040b 	ldhu	r4,16(r2)
    e2e0:	1080048b 	ldhu	r2,18(r2)
    e2e4:	1004943a 	slli	r2,r2,16
    e2e8:	1104b03a 	or	r2,r2,r4
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
    e2ec:	1880051e 	bne	r3,r2,e304 <tcp_input+0x82c>
         ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
    e2f0:	e13ffa17 	ldw	r4,-24(fp)
    e2f4:	000eb100 	call	eb10 <tcp_timewait_input>
        pbuf_free(p);
    e2f8:	e13ffe17 	ldw	r4,-8(fp)
    e2fc:	000a1880 	call	a188 <pbuf_free>
        return;
    e300:	00014e06 	br	e83c <tcp_input+0xd64>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    e304:	e0bffa17 	ldw	r2,-24(fp)
    e308:	10800317 	ldw	r2,12(r2)
    e30c:	e0bffa15 	stw	r2,-24(fp)
    e310:	e0bffa17 	ldw	r2,-24(fp)
    e314:	103fcb1e 	bne	r2,zero,e244 <tcp_input+0x76c>
      }
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    e318:	e03ffb15 	stw	zero,-20(fp)
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    e31c:	008000f4 	movhi	r2,3
    e320:	1099c404 	addi	r2,r2,26384
    e324:	10800017 	ldw	r2,0(r2)
    e328:	e0bffc15 	stw	r2,-16(fp)
    e32c:	00002d06 	br	e3e4 <tcp_input+0x90c>
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
    e330:	e0bffc17 	ldw	r2,-16(fp)
    e334:	10000b26 	beq	r2,zero,e364 <tcp_input+0x88c>
    e338:	e0bffc17 	ldw	r2,-16(fp)
    e33c:	10800017 	ldw	r2,0(r2)
    e340:	10000826 	beq	r2,zero,e364 <tcp_input+0x88c>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
    e344:	e0bffc17 	ldw	r2,-16(fp)
    e348:	10c00017 	ldw	r3,0(r2)
    e34c:	d0a8dd17 	ldw	r2,-23692(gp)
    e350:	1100040b 	ldhu	r4,16(r2)
    e354:	1080048b 	ldhu	r2,18(r2)
    e358:	1004943a 	slli	r2,r2,16
    e35c:	1104b03a 	or	r2,r2,r4

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
    e360:	18801b1e 	bne	r3,r2,e3d0 <tcp_input+0x8f8>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
        lpcb->local_port == tcphdr->dest) {
    e364:	e0bffc17 	ldw	r2,-16(fp)
    e368:	10c0070b 	ldhu	r3,28(r2)
    e36c:	d0a8dc17 	ldw	r2,-23696(gp)
    e370:	1080008b 	ldhu	r2,2(r2)
  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
    e374:	18ffffcc 	andi	r3,r3,65535
    e378:	10bfffcc 	andi	r2,r2,65535
    e37c:	1880141e 	bne	r3,r2,e3d0 <tcp_input+0x8f8>
        lpcb->local_port == tcphdr->dest) {
        /* Move this PCB to the front of the list so that subsequent
           lookups will be faster (we exploit locality in TCP segment
           arrivals). */
        if (prev != NULL) {
    e380:	e0bffb17 	ldw	r2,-20(fp)
    e384:	10000d26 	beq	r2,zero,e3bc <tcp_input+0x8e4>
          ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
    e388:	e0bffc17 	ldw	r2,-16(fp)
    e38c:	10c00317 	ldw	r3,12(r2)
    e390:	e0bffb17 	ldw	r2,-20(fp)
    e394:	10c00315 	stw	r3,12(r2)
                /* our successor is the remainder of the listening list */
          lpcb->next = tcp_listen_pcbs.listen_pcbs;
    e398:	008000f4 	movhi	r2,3
    e39c:	1099c404 	addi	r2,r2,26384
    e3a0:	10c00017 	ldw	r3,0(r2)
    e3a4:	e0bffc17 	ldw	r2,-16(fp)
    e3a8:	10c00315 	stw	r3,12(r2)
                /* put this listening pcb at the head of the listening list */
          tcp_listen_pcbs.listen_pcbs = lpcb;
    e3ac:	008000f4 	movhi	r2,3
    e3b0:	1099c404 	addi	r2,r2,26384
    e3b4:	e0fffc17 	ldw	r3,-16(fp)
    e3b8:	10c00015 	stw	r3,0(r2)
        }
      
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
        tcp_listen_input(lpcb);
    e3bc:	e13ffc17 	ldw	r4,-16(fp)
    e3c0:	000e8500 	call	e850 <tcp_listen_input>
        pbuf_free(p);
    e3c4:	e13ffe17 	ldw	r4,-8(fp)
    e3c8:	000a1880 	call	a188 <pbuf_free>
        return;
    e3cc:	00011b06 	br	e83c <tcp_input+0xd64>
      }
      prev = (struct tcp_pcb *)lpcb;
    e3d0:	e0bffc17 	ldw	r2,-16(fp)
    e3d4:	e0bffb15 	stw	r2,-20(fp)
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    e3d8:	e0bffc17 	ldw	r2,-16(fp)
    e3dc:	10800317 	ldw	r2,12(r2)
    e3e0:	e0bffc15 	stw	r2,-16(fp)
    e3e4:	e0bffc17 	ldw	r2,-16(fp)
    e3e8:	103fd11e 	bne	r2,zero,e330 <tcp_input+0x858>
  tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"));
#endif /* TCP_INPUT_DEBUG */


  if (pcb != NULL) {
    e3ec:	e0bffa17 	ldw	r2,-24(fp)
    e3f0:	1000d126 	beq	r2,zero,e738 <tcp_input+0xc60>
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
    e3f4:	00800134 	movhi	r2,4
    e3f8:	1090c604 	addi	r2,r2,17176
    e3fc:	10000015 	stw	zero,0(r2)
    inseg.len = p->tot_len;
    e400:	e0bffe17 	ldw	r2,-8(fp)
    e404:	10c0020b 	ldhu	r3,8(r2)
    e408:	00800134 	movhi	r2,4
    e40c:	1090c604 	addi	r2,r2,17176
    e410:	10c0030d 	sth	r3,12(r2)
    inseg.dataptr = p->payload;
    e414:	e0bffe17 	ldw	r2,-8(fp)
    e418:	10c00117 	ldw	r3,4(r2)
    e41c:	00800134 	movhi	r2,4
    e420:	1090c604 	addi	r2,r2,17176
    e424:	10c00215 	stw	r3,8(r2)
    inseg.p = p;
    e428:	00800134 	movhi	r2,4
    e42c:	1090c604 	addi	r2,r2,17176
    e430:	e0fffe17 	ldw	r3,-8(fp)
    e434:	10c00115 	stw	r3,4(r2)
    inseg.tcphdr = tcphdr;
    e438:	d0e8dc17 	ldw	r3,-23696(gp)
    e43c:	00800134 	movhi	r2,4
    e440:	1090c604 	addi	r2,r2,17176
    e444:	10c00415 	stw	r3,16(r2)

    recv_data = NULL;
    e448:	d028e215 	stw	zero,-23672(gp)
    recv_flags = 0;
    e44c:	d028e105 	stb	zero,-23676(gp)

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
    e450:	e0bffa17 	ldw	r2,-24(fp)
    e454:	10802117 	ldw	r2,132(r2)
    e458:	10002826 	beq	r2,zero,e4fc <tcp_input+0xa24>
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
    e45c:	e0bffa17 	ldw	r2,-24(fp)
    e460:	10802317 	ldw	r2,140(r2)
    e464:	10000d26 	beq	r2,zero,e49c <tcp_input+0x9c4>
    e468:	e0bffa17 	ldw	r2,-24(fp)
    e46c:	12002317 	ldw	r8,140(r2)
    e470:	e0bffa17 	ldw	r2,-24(fp)
    e474:	10c00617 	ldw	r3,24(r2)
    e478:	e0bffa17 	ldw	r2,-24(fp)
    e47c:	10802117 	ldw	r2,132(r2)
    e480:	1809883a 	mov	r4,r3
    e484:	e17ffa17 	ldw	r5,-24(fp)
    e488:	100d883a 	mov	r6,r2
    e48c:	000f883a 	mov	r7,zero
    e490:	403ee83a 	callr	r8
    e494:	e0bffd05 	stb	r2,-12(fp)
    e498:	00000806 	br	e4bc <tcp_input+0x9e4>
    e49c:	e0bffa17 	ldw	r2,-24(fp)
    e4a0:	10802117 	ldw	r2,132(r2)
    e4a4:	0009883a 	mov	r4,zero
    e4a8:	e17ffa17 	ldw	r5,-24(fp)
    e4ac:	100d883a 	mov	r6,r2
    e4b0:	000f883a 	mov	r7,zero
    e4b4:	000cba40 	call	cba4 <tcp_recv_null>
    e4b8:	e0bffd05 	stb	r2,-12(fp)
      if (err == ERR_OK) {
    e4bc:	e0bffd07 	ldb	r2,-12(fp)
    e4c0:	1000031e 	bne	r2,zero,e4d0 <tcp_input+0x9f8>
        pcb->refused_data = NULL;
    e4c4:	e0bffa17 	ldw	r2,-24(fp)
    e4c8:	10002115 	stw	zero,132(r2)
    e4cc:	00000b06 	br	e4fc <tcp_input+0xa24>
      } else {
        /* drop incoming packets, because pcb is "full" */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
        TCP_STATS_INC(tcp.drop);
    e4d0:	00800134 	movhi	r2,4
    e4d4:	10916104 	addi	r2,r2,17796
    e4d8:	1080258b 	ldhu	r2,150(r2)
    e4dc:	10800044 	addi	r2,r2,1
    e4e0:	1007883a 	mov	r3,r2
    e4e4:	00800134 	movhi	r2,4
    e4e8:	10916104 	addi	r2,r2,17796
    e4ec:	10c0258d 	sth	r3,150(r2)
        snmp_inc_tcpinerrs();
        pbuf_free(p);
    e4f0:	e13ffe17 	ldw	r4,-8(fp)
    e4f4:	000a1880 	call	a188 <pbuf_free>
        return;
    e4f8:	0000d006 	br	e83c <tcp_input+0xd64>
      }
    }
    tcp_input_pcb = pcb;
    e4fc:	e0bffa17 	ldw	r2,-24(fp)
    e500:	d0a8e315 	stw	r2,-23668(gp)
    err = tcp_process(pcb);
    e504:	e13ffa17 	ldw	r4,-24(fp)
    e508:	000ec480 	call	ec48 <tcp_process>
    e50c:	e0bffd05 	stb	r2,-12(fp)
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
    e510:	e0bffd07 	ldb	r2,-12(fp)
    e514:	10bffee0 	cmpeqi	r2,r2,-5
    e518:	1000791e 	bne	r2,zero,e700 <tcp_input+0xc28>
      if (recv_flags & TF_RESET) {
    e51c:	d0a8e103 	ldbu	r2,-23676(gp)
    e520:	10803fcc 	andi	r2,r2,255
    e524:	1080020c 	andi	r2,r2,8
    e528:	10001226 	beq	r2,zero,e574 <tcp_input+0xa9c>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
    e52c:	e0bffa17 	ldw	r2,-24(fp)
    e530:	10802617 	ldw	r2,152(r2)
    e534:	10000726 	beq	r2,zero,e554 <tcp_input+0xa7c>
    e538:	e0bffa17 	ldw	r2,-24(fp)
    e53c:	10c02617 	ldw	r3,152(r2)
    e540:	e0bffa17 	ldw	r2,-24(fp)
    e544:	10800617 	ldw	r2,24(r2)
    e548:	1009883a 	mov	r4,r2
    e54c:	017ffe84 	movi	r5,-6
    e550:	183ee83a 	callr	r3
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
    e554:	010000f4 	movhi	r4,3
    e558:	2119c204 	addi	r4,r4,26376
    e55c:	e17ffa17 	ldw	r5,-24(fp)
    e560:	000d2300 	call	d230 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
    e564:	01000084 	movi	r4,2
    e568:	e17ffa17 	ldw	r5,-24(fp)
    e56c:	00090e80 	call	90e8 <memp_free>
    e570:	00006306 	br	e700 <tcp_input+0xc28>
      } else if (recv_flags & TF_CLOSED) {
    e574:	d0a8e103 	ldbu	r2,-23676(gp)
    e578:	10803fcc 	andi	r2,r2,255
    e57c:	1080040c 	andi	r2,r2,16
    e580:	10000826 	beq	r2,zero,e5a4 <tcp_input+0xacc>
        /* The connection has been closed and we will deallocate the
           PCB. */
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
    e584:	010000f4 	movhi	r4,3
    e588:	2119c204 	addi	r4,r4,26376
    e58c:	e17ffa17 	ldw	r5,-24(fp)
    e590:	000d2300 	call	d230 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
    e594:	01000084 	movi	r4,2
    e598:	e17ffa17 	ldw	r5,-24(fp)
    e59c:	00090e80 	call	90e8 <memp_free>
    e5a0:	00005706 	br	e700 <tcp_input+0xc28>
      } else {
        err = ERR_OK;
    e5a4:	e03ffd05 	stb	zero,-12(fp)
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
    e5a8:	e0bffa17 	ldw	r2,-24(fp)
    e5ac:	10801c0b 	ldhu	r2,112(r2)
    e5b0:	10bfffcc 	andi	r2,r2,65535
    e5b4:	10001126 	beq	r2,zero,e5fc <tcp_input+0xb24>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
    e5b8:	e0bffa17 	ldw	r2,-24(fp)
    e5bc:	10802217 	ldw	r2,136(r2)
    e5c0:	10000d26 	beq	r2,zero,e5f8 <tcp_input+0xb20>
    e5c4:	e0bffa17 	ldw	r2,-24(fp)
    e5c8:	11c02217 	ldw	r7,136(r2)
    e5cc:	e0bffa17 	ldw	r2,-24(fp)
    e5d0:	10c00617 	ldw	r3,24(r2)
    e5d4:	e0bffa17 	ldw	r2,-24(fp)
    e5d8:	10801c0b 	ldhu	r2,112(r2)
    e5dc:	10bfffcc 	andi	r2,r2,65535
    e5e0:	1809883a 	mov	r4,r3
    e5e4:	e17ffa17 	ldw	r5,-24(fp)
    e5e8:	100d883a 	mov	r6,r2
    e5ec:	383ee83a 	callr	r7
    e5f0:	e0bffd05 	stb	r2,-12(fp)
    e5f4:	00000106 	br	e5fc <tcp_input+0xb24>
    e5f8:	e03ffd05 	stb	zero,-12(fp)
        }
      
        if (recv_data != NULL) {
    e5fc:	d0a8e217 	ldw	r2,-23672(gp)
    e600:	10002426 	beq	r2,zero,e694 <tcp_input+0xbbc>
          if(flags & TCP_PSH) {
    e604:	d0a8e003 	ldbu	r2,-23680(gp)
    e608:	10803fcc 	andi	r2,r2,255
    e60c:	1080020c 	andi	r2,r2,8
    e610:	10000526 	beq	r2,zero,e628 <tcp_input+0xb50>
            recv_data->flags |= PBUF_FLAG_PUSH;
    e614:	d0a8e217 	ldw	r2,-23672(gp)
    e618:	d0e8e217 	ldw	r3,-23672(gp)
    e61c:	18c00343 	ldbu	r3,13(r3)
    e620:	18c00054 	ori	r3,r3,1
    e624:	10c00345 	stb	r3,13(r2)
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
    e628:	e0bffa17 	ldw	r2,-24(fp)
    e62c:	10802317 	ldw	r2,140(r2)
    e630:	10000c26 	beq	r2,zero,e664 <tcp_input+0xb8c>
    e634:	e0bffa17 	ldw	r2,-24(fp)
    e638:	12002317 	ldw	r8,140(r2)
    e63c:	e0bffa17 	ldw	r2,-24(fp)
    e640:	10c00617 	ldw	r3,24(r2)
    e644:	d0a8e217 	ldw	r2,-23672(gp)
    e648:	1809883a 	mov	r4,r3
    e64c:	e17ffa17 	ldw	r5,-24(fp)
    e650:	100d883a 	mov	r6,r2
    e654:	000f883a 	mov	r7,zero
    e658:	403ee83a 	callr	r8
    e65c:	e0bffd05 	stb	r2,-12(fp)
    e660:	00000706 	br	e680 <tcp_input+0xba8>
    e664:	d0a8e217 	ldw	r2,-23672(gp)
    e668:	0009883a 	mov	r4,zero
    e66c:	e17ffa17 	ldw	r5,-24(fp)
    e670:	100d883a 	mov	r6,r2
    e674:	000f883a 	mov	r7,zero
    e678:	000cba40 	call	cba4 <tcp_recv_null>
    e67c:	e0bffd05 	stb	r2,-12(fp)

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
    e680:	e0bffd07 	ldb	r2,-12(fp)
    e684:	10000326 	beq	r2,zero,e694 <tcp_input+0xbbc>
            pcb->refused_data = recv_data;
    e688:	d0e8e217 	ldw	r3,-23672(gp)
    e68c:	e0bffa17 	ldw	r2,-24(fp)
    e690:	10c02115 	stw	r3,132(r2)
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
    e694:	d0a8e103 	ldbu	r2,-23676(gp)
    e698:	10803fcc 	andi	r2,r2,255
    e69c:	1080080c 	andi	r2,r2,32
    e6a0:	10001426 	beq	r2,zero,e6f4 <tcp_input+0xc1c>
          TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
    e6a4:	e0bffa17 	ldw	r2,-24(fp)
    e6a8:	10802317 	ldw	r2,140(r2)
    e6ac:	10000b26 	beq	r2,zero,e6dc <tcp_input+0xc04>
    e6b0:	e0bffa17 	ldw	r2,-24(fp)
    e6b4:	10c02317 	ldw	r3,140(r2)
    e6b8:	e0bffa17 	ldw	r2,-24(fp)
    e6bc:	10800617 	ldw	r2,24(r2)
    e6c0:	1009883a 	mov	r4,r2
    e6c4:	e17ffa17 	ldw	r5,-24(fp)
    e6c8:	000d883a 	mov	r6,zero
    e6cc:	000f883a 	mov	r7,zero
    e6d0:	183ee83a 	callr	r3
    e6d4:	e0bffd05 	stb	r2,-12(fp)
    e6d8:	00000606 	br	e6f4 <tcp_input+0xc1c>
    e6dc:	0009883a 	mov	r4,zero
    e6e0:	e17ffa17 	ldw	r5,-24(fp)
    e6e4:	000d883a 	mov	r6,zero
    e6e8:	000f883a 	mov	r7,zero
    e6ec:	000cba40 	call	cba4 <tcp_recv_null>
    e6f0:	e0bffd05 	stb	r2,-12(fp)
        }

        tcp_input_pcb = NULL;
    e6f4:	d028e315 	stw	zero,-23668(gp)
        /* Try to send something out. */
        tcp_output(pcb);
    e6f8:	e13ffa17 	ldw	r4,-24(fp)
    e6fc:	0012b000 	call	12b00 <tcp_output>
        tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */
      }
    }
    tcp_input_pcb = NULL;
    e700:	d028e315 	stw	zero,-23668(gp)


    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
    e704:	00800134 	movhi	r2,4
    e708:	1090c604 	addi	r2,r2,17176
    e70c:	10800117 	ldw	r2,4(r2)
    e710:	10003c26 	beq	r2,zero,e804 <tcp_input+0xd2c>
    {
      pbuf_free(inseg.p);
    e714:	00800134 	movhi	r2,4
    e718:	1090c604 	addi	r2,r2,17176
    e71c:	10800117 	ldw	r2,4(r2)
    e720:	1009883a 	mov	r4,r2
    e724:	000a1880 	call	a188 <pbuf_free>
      inseg.p = NULL;
    e728:	00800134 	movhi	r2,4
    e72c:	1090c604 	addi	r2,r2,17176
    e730:	10000115 	stw	zero,4(r2)
    e734:	00003306 	br	e804 <tcp_input+0xd2c>
  } else {

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
    e738:	d0a8dc17 	ldw	r2,-23696(gp)
    e73c:	1080030b 	ldhu	r2,12(r2)
    e740:	10bfffcc 	andi	r2,r2,65535
    e744:	1004d23a 	srli	r2,r2,8
    e748:	10ffffcc 	andi	r3,r2,65535
    e74c:	d0a8dc17 	ldw	r2,-23696(gp)
    e750:	1080030b 	ldhu	r2,12(r2)
    e754:	10bfffcc 	andi	r2,r2,65535
    e758:	1004923a 	slli	r2,r2,8
    e75c:	10bfffcc 	andi	r2,r2,65535
    e760:	1884b03a 	or	r2,r3,r2
    e764:	1080010c 	andi	r2,r2,4
    e768:	1000241e 	bne	r2,zero,e7fc <tcp_input+0xd24>
      TCP_STATS_INC(tcp.proterr);
    e76c:	00800134 	movhi	r2,4
    e770:	10916104 	addi	r2,r2,17796
    e774:	1080280b 	ldhu	r2,160(r2)
    e778:	10800044 	addi	r2,r2,1
    e77c:	1007883a 	mov	r3,r2
    e780:	00800134 	movhi	r2,4
    e784:	10916104 	addi	r2,r2,17796
    e788:	10c0280d 	sth	r3,160(r2)
      TCP_STATS_INC(tcp.drop);
    e78c:	00800134 	movhi	r2,4
    e790:	10916104 	addi	r2,r2,17796
    e794:	1080258b 	ldhu	r2,150(r2)
    e798:	10800044 	addi	r2,r2,1
    e79c:	1007883a 	mov	r3,r2
    e7a0:	00800134 	movhi	r2,4
    e7a4:	10916104 	addi	r2,r2,17796
    e7a8:	10c0258d 	sth	r3,150(r2)
      tcp_rst(ackno, seqno + tcplen,
    e7ac:	d128df17 	ldw	r4,-23684(gp)
    e7b0:	d0a8e08b 	ldhu	r2,-23678(gp)
    e7b4:	10ffffcc 	andi	r3,r2,65535
    e7b8:	d0a8de17 	ldw	r2,-23688(gp)
    e7bc:	188b883a 	add	r5,r3,r2
        &(iphdr->dest), &(iphdr->src),
    e7c0:	d0a8dd17 	ldw	r2,-23692(gp)
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
    e7c4:	10c00404 	addi	r3,r2,16
        &(iphdr->dest), &(iphdr->src),
    e7c8:	d0a8dd17 	ldw	r2,-23692(gp)
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
    e7cc:	10800304 	addi	r2,r2,12
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    e7d0:	d1a8dc17 	ldw	r6,-23696(gp)
    e7d4:	3180008b 	ldhu	r6,2(r6)
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
    e7d8:	31ffffcc 	andi	r7,r6,65535
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    e7dc:	d1a8dc17 	ldw	r6,-23696(gp)
    e7e0:	3180000b 	ldhu	r6,0(r6)
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
    e7e4:	31bfffcc 	andi	r6,r6,65535
    e7e8:	d9c00015 	stw	r7,0(sp)
    e7ec:	d9800115 	stw	r6,4(sp)
    e7f0:	180d883a 	mov	r6,r3
    e7f4:	100f883a 	mov	r7,r2
    e7f8:	00137240 	call	13724 <tcp_rst>
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    pbuf_free(p);
    e7fc:	e13ffe17 	ldw	r4,-8(fp)
    e800:	000a1880 	call	a188 <pbuf_free>
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
    e804:	000d9a40 	call	d9a4 <tcp_pcbs_sane>
    e808:	10bfffcc 	andi	r2,r2,65535
    e80c:	10a0001c 	xori	r2,r2,32768
    e810:	10a00004 	addi	r2,r2,-32768
    e814:	1000091e 	bne	r2,zero,e83c <tcp_input+0xd64>
    e818:	010000f4 	movhi	r4,3
    e81c:	213db804 	addi	r4,r4,-2336
    e820:	014000f4 	movhi	r5,3
    e824:	297e0904 	addi	r5,r5,-2012
    e828:	01805d44 	movi	r6,373
    e82c:	01c000f4 	movhi	r7,3
    e830:	39fdcc04 	addi	r7,r7,-2256
    e834:	00170680 	call	17068 <printf>
    e838:	003fff06 	br	e838 <tcp_input+0xd60>
  PERF_STOP("tcp_input");
}
    e83c:	e037883a 	mov	sp,fp
    e840:	dfc00117 	ldw	ra,4(sp)
    e844:	df000017 	ldw	fp,0(sp)
    e848:	dec00204 	addi	sp,sp,8
    e84c:	f800283a 	ret

0000e850 <tcp_listen_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_listen_input(struct tcp_pcb_listen *pcb)
{
    e850:	defff904 	addi	sp,sp,-28
    e854:	dfc00615 	stw	ra,24(sp)
    e858:	df000515 	stw	fp,20(sp)
    e85c:	df000504 	addi	fp,sp,20
    e860:	e13fff15 	stw	r4,-4(fp)
  struct tcp_pcb *npcb;
  err_t rc;

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    e864:	d0a8e003 	ldbu	r2,-23680(gp)
    e868:	10803fcc 	andi	r2,r2,255
    e86c:	1080040c 	andi	r2,r2,16
    e870:	10001626 	beq	r2,zero,e8cc <tcp_listen_input+0x7c>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
    e874:	d0a8df17 	ldw	r2,-23684(gp)
    e878:	11000044 	addi	r4,r2,1
    e87c:	d0a8e08b 	ldhu	r2,-23678(gp)
    e880:	10ffffcc 	andi	r3,r2,65535
    e884:	d0a8de17 	ldw	r2,-23688(gp)
    e888:	188b883a 	add	r5,r3,r2
      &(iphdr->dest), &(iphdr->src),
    e88c:	d0a8dd17 	ldw	r2,-23692(gp)
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
    e890:	10c00404 	addi	r3,r2,16
      &(iphdr->dest), &(iphdr->src),
    e894:	d0a8dd17 	ldw	r2,-23692(gp)
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
    e898:	10800304 	addi	r2,r2,12
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
    e89c:	d1a8dc17 	ldw	r6,-23696(gp)
    e8a0:	3180008b 	ldhu	r6,2(r6)
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
    e8a4:	31ffffcc 	andi	r7,r6,65535
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
    e8a8:	d1a8dc17 	ldw	r6,-23696(gp)
    e8ac:	3180000b 	ldhu	r6,0(r6)
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
    e8b0:	31bfffcc 	andi	r6,r6,65535
    e8b4:	d9c00015 	stw	r7,0(sp)
    e8b8:	d9800115 	stw	r6,4(sp)
    e8bc:	180d883a 	mov	r6,r3
    e8c0:	100f883a 	mov	r7,r2
    e8c4:	00137240 	call	13724 <tcp_rst>
    e8c8:	00008b06 	br	eaf8 <tcp_listen_input+0x2a8>
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  } else if (flags & TCP_SYN) {
    e8cc:	d0a8e003 	ldbu	r2,-23680(gp)
    e8d0:	10803fcc 	andi	r2,r2,255
    e8d4:	1080008c 	andi	r2,r2,2
    e8d8:	10008726 	beq	r2,zero,eaf8 <tcp_listen_input+0x2a8>
    LWIP_DEBUGF(TCP_DEBUG, ("TCP connection request %"U16_F" -> %"U16_F".\n", tcphdr->src, tcphdr->dest));
    e8dc:	d0a8dc17 	ldw	r2,-23696(gp)
    e8e0:	1080008b 	ldhu	r2,2(r2)
    e8e4:	10bfffcc 	andi	r2,r2,65535
    e8e8:	1009883a 	mov	r4,r2
    e8ec:	00170680 	call	17068 <printf>
    if (pcb->accepts_pending >= pcb->backlog) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: listen backlog exceeded for port %"U16_F"\n", tcphdr->dest));
      return ERR_ABRT;
    }
#endif /* TCP_LISTEN_BACKLOG */
    npcb = tcp_alloc(pcb->prio);
    e8f0:	e0bfff17 	ldw	r2,-4(fp)
    e8f4:	10800503 	ldbu	r2,20(r2)
    e8f8:	10803fcc 	andi	r2,r2,255
    e8fc:	1009883a 	mov	r4,r2
    e900:	000cda40 	call	cda4 <tcp_alloc>
    e904:	e0bffd15 	stw	r2,-12(fp)
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
    e908:	e0bffd17 	ldw	r2,-12(fp)
    e90c:	10000d1e 	bne	r2,zero,e944 <tcp_listen_input+0xf4>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: could not allocate PCB\n"));
    e910:	010000f4 	movhi	r4,3
    e914:	213e1004 	addi	r4,r4,-1984
    e918:	00172f80 	call	172f8 <puts>
      TCP_STATS_INC(tcp.memerr);
    e91c:	00800134 	movhi	r2,4
    e920:	10916104 	addi	r2,r2,17796
    e924:	1080270b 	ldhu	r2,156(r2)
    e928:	10800044 	addi	r2,r2,1
    e92c:	1007883a 	mov	r3,r2
    e930:	00800134 	movhi	r2,4
    e934:	10916104 	addi	r2,r2,17796
    e938:	10c0270d 	sth	r3,156(r2)
      return ERR_MEM;
    e93c:	00bfffc4 	movi	r2,-1
    e940:	00006e06 	br	eafc <tcp_listen_input+0x2ac>
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
    e944:	d0a8dd17 	ldw	r2,-23692(gp)
    e948:	10800404 	addi	r2,r2,16
    e94c:	10000626 	beq	r2,zero,e968 <tcp_listen_input+0x118>
    e950:	d0a8dd17 	ldw	r2,-23692(gp)
    e954:	10c0040b 	ldhu	r3,16(r2)
    e958:	1080048b 	ldhu	r2,18(r2)
    e95c:	1004943a 	slli	r2,r2,16
    e960:	10c4b03a 	or	r2,r2,r3
    e964:	00000106 	br	e96c <tcp_listen_input+0x11c>
    e968:	0005883a 	mov	r2,zero
    e96c:	e0fffd17 	ldw	r3,-12(fp)
    e970:	18800015 	stw	r2,0(r3)
    npcb->local_port = pcb->local_port;
    e974:	e0bfff17 	ldw	r2,-4(fp)
    e978:	10c0070b 	ldhu	r3,28(r2)
    e97c:	e0bffd17 	ldw	r2,-12(fp)
    e980:	10c0070d 	sth	r3,28(r2)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
    e984:	d0a8dd17 	ldw	r2,-23692(gp)
    e988:	10800304 	addi	r2,r2,12
    e98c:	10000626 	beq	r2,zero,e9a8 <tcp_listen_input+0x158>
    e990:	d0a8dd17 	ldw	r2,-23692(gp)
    e994:	10c0030b 	ldhu	r3,12(r2)
    e998:	1080038b 	ldhu	r2,14(r2)
    e99c:	1004943a 	slli	r2,r2,16
    e9a0:	10c4b03a 	or	r2,r2,r3
    e9a4:	00000106 	br	e9ac <tcp_listen_input+0x15c>
    e9a8:	0005883a 	mov	r2,zero
    e9ac:	e0fffd17 	ldw	r3,-12(fp)
    e9b0:	18800115 	stw	r2,4(r3)
    npcb->remote_port = tcphdr->src;
    e9b4:	d0a8dc17 	ldw	r2,-23696(gp)
    e9b8:	10c0000b 	ldhu	r3,0(r2)
    e9bc:	e0bffd17 	ldw	r2,-12(fp)
    e9c0:	10c0090d 	sth	r3,36(r2)
    npcb->state = SYN_RCVD;
    e9c4:	e0bffd17 	ldw	r2,-12(fp)
    e9c8:	00c000c4 	movi	r3,3
    e9cc:	10c00415 	stw	r3,16(r2)
    npcb->rcv_nxt = seqno + 1;
    e9d0:	d0a8de17 	ldw	r2,-23688(gp)
    e9d4:	10c00044 	addi	r3,r2,1
    e9d8:	e0bffd17 	ldw	r2,-12(fp)
    e9dc:	10c00a15 	stw	r3,40(r2)
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
    e9e0:	e0bffd17 	ldw	r2,-12(fp)
    e9e4:	10c00a17 	ldw	r3,40(r2)
    e9e8:	e0bffd17 	ldw	r2,-12(fp)
    e9ec:	10c00c15 	stw	r3,48(r2)
    npcb->snd_wnd = tcphdr->wnd;
    e9f0:	d0a8dc17 	ldw	r2,-23696(gp)
    e9f4:	10c0038b 	ldhu	r3,14(r2)
    e9f8:	e0bffd17 	ldw	r2,-12(fp)
    e9fc:	10c0180d 	sth	r3,96(r2)
    npcb->ssthresh = npcb->snd_wnd;
    ea00:	e0bffd17 	ldw	r2,-12(fp)
    ea04:	10c0180b 	ldhu	r3,96(r2)
    ea08:	e0bffd17 	ldw	r2,-12(fp)
    ea0c:	10c0160d 	sth	r3,88(r2)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
    ea10:	d0a8de17 	ldw	r2,-23688(gp)
    ea14:	10ffffc4 	addi	r3,r2,-1
    ea18:	e0bffd17 	ldw	r2,-12(fp)
    ea1c:	10c01915 	stw	r3,100(r2)
    npcb->callback_arg = pcb->callback_arg;
    ea20:	e0bfff17 	ldw	r2,-4(fp)
    ea24:	10c00617 	ldw	r3,24(r2)
    ea28:	e0bffd17 	ldw	r2,-12(fp)
    ea2c:	10c00615 	stw	r3,24(r2)
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
    ea30:	e0bfff17 	ldw	r2,-4(fp)
    ea34:	10c00817 	ldw	r3,32(r2)
    ea38:	e0bffd17 	ldw	r2,-12(fp)
    ea3c:	10c00815 	stw	r3,32(r2)
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
    ea40:	e0bfff17 	ldw	r2,-4(fp)
    ea44:	1080020b 	ldhu	r2,8(r2)
    ea48:	1080664c 	andi	r2,r2,409
    ea4c:	1007883a 	mov	r3,r2
    ea50:	e0bffd17 	ldw	r2,-12(fp)
    ea54:	10c0020d 	sth	r3,8(r2)
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG(&tcp_active_pcbs, npcb);
    ea58:	008000f4 	movhi	r2,3
    ea5c:	1099c204 	addi	r2,r2,26376
    ea60:	10c00017 	ldw	r3,0(r2)
    ea64:	e0bffd17 	ldw	r2,-12(fp)
    ea68:	10c00315 	stw	r3,12(r2)
    ea6c:	008000f4 	movhi	r2,3
    ea70:	1099c204 	addi	r2,r2,26376
    ea74:	e0fffd17 	ldw	r3,-12(fp)
    ea78:	10c00015 	stw	r3,0(r2)

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
    ea7c:	e13ffd17 	ldw	r4,-12(fp)
    ea80:	00116c40 	call	116c4 <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
    ea84:	e0bffd17 	ldw	r2,-12(fp)
    ea88:	10800f0b 	ldhu	r2,60(r2)
    ea8c:	10ffffcc 	andi	r3,r2,65535
    ea90:	e0bffd17 	ldw	r2,-12(fp)
    ea94:	10800104 	addi	r2,r2,4
    ea98:	1809883a 	mov	r4,r3
    ea9c:	100b883a 	mov	r5,r2
    eaa0:	000d4400 	call	d440 <tcp_eff_send_mss>
    eaa4:	e0fffd17 	ldw	r3,-12(fp)
    eaa8:	18800f0d 	sth	r2,60(r3)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Send a SYN|ACK together with the MSS option. */
    rc = tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, TF_SEG_OPTS_MSS
    eaac:	d8000015 	stw	zero,0(sp)
    eab0:	00800044 	movi	r2,1
    eab4:	d8800115 	stw	r2,4(sp)
    eab8:	e13ffd17 	ldw	r4,-12(fp)
    eabc:	000b883a 	mov	r5,zero
    eac0:	000d883a 	mov	r6,zero
    eac4:	01c00484 	movi	r7,18
    eac8:	0011c500 	call	11c50 <tcp_enqueue>
    eacc:	e0bffe05 	stb	r2,-8(fp)
#if LWIP_TCP_TIMESTAMPS
      /* and maybe include the TIMESTAMP option */
     | (npcb->flags & TF_TIMESTAMP ? TF_SEG_OPTS_TS : 0)
#endif
      );
    if (rc != ERR_OK) {
    ead0:	e0bffe07 	ldb	r2,-8(fp)
    ead4:	10000526 	beq	r2,zero,eaec <tcp_listen_input+0x29c>
      tcp_abandon(npcb, 0);
    ead8:	e13ffd17 	ldw	r4,-12(fp)
    eadc:	000b883a 	mov	r5,zero
    eae0:	000b4a00 	call	b4a0 <tcp_abandon>
      return rc;
    eae4:	e0bffe03 	ldbu	r2,-8(fp)
    eae8:	00000406 	br	eafc <tcp_listen_input+0x2ac>
    }
    return tcp_output(npcb);
    eaec:	e13ffd17 	ldw	r4,-12(fp)
    eaf0:	0012b000 	call	12b00 <tcp_output>
    eaf4:	00000106 	br	eafc <tcp_listen_input+0x2ac>
  }
  return ERR_OK;
    eaf8:	0005883a 	mov	r2,zero
}
    eafc:	e037883a 	mov	sp,fp
    eb00:	dfc00117 	ldw	ra,4(sp)
    eb04:	df000017 	ldw	fp,0(sp)
    eb08:	dec00204 	addi	sp,sp,8
    eb0c:	f800283a 	ret

0000eb10 <tcp_timewait_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_timewait_input(struct tcp_pcb *pcb)
{
    eb10:	defffb04 	addi	sp,sp,-20
    eb14:	dfc00415 	stw	ra,16(sp)
    eb18:	df000315 	stw	fp,12(sp)
    eb1c:	df000304 	addi	fp,sp,12
    eb20:	e13fff15 	stw	r4,-4(fp)
  /* RFC 1337: in TIME_WAIT, ignore RST and ACK FINs + any 'acceptable' segments */
  /* RFC 793 3.9 Event Processing - Segment Arrives:
   * - first check sequence number - we skip that one in TIME_WAIT (always
   *   acceptable since we only send ACKs)
   * - second check the RST bit (... return) */
  if (flags & TCP_RST)  {
    eb24:	d0a8e003 	ldbu	r2,-23680(gp)
    eb28:	10803fcc 	andi	r2,r2,255
    eb2c:	1080010c 	andi	r2,r2,4
    eb30:	10000226 	beq	r2,zero,eb3c <tcp_timewait_input+0x2c>
    return ERR_OK;
    eb34:	0005883a 	mov	r2,zero
    eb38:	00003e06 	br	ec34 <tcp_timewait_input+0x124>
  }
  /* - fourth, check the SYN bit, */
  if (flags & TCP_SYN) {
    eb3c:	d0a8e003 	ldbu	r2,-23680(gp)
    eb40:	10803fcc 	andi	r2,r2,255
    eb44:	1080008c 	andi	r2,r2,2
    eb48:	10002426 	beq	r2,zero,ebdc <tcp_timewait_input+0xcc>
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
    eb4c:	d0e8de17 	ldw	r3,-23688(gp)
    eb50:	e0bfff17 	ldw	r2,-4(fp)
    eb54:	10800a17 	ldw	r2,40(r2)
    eb58:	1885c83a 	sub	r2,r3,r2
    eb5c:	10002816 	blt	r2,zero,ec00 <tcp_timewait_input+0xf0>
    eb60:	d0e8de17 	ldw	r3,-23688(gp)
    eb64:	e0bfff17 	ldw	r2,-4(fp)
    eb68:	11000a17 	ldw	r4,40(r2)
    eb6c:	e0bfff17 	ldw	r2,-4(fp)
    eb70:	10800b0b 	ldhu	r2,44(r2)
    eb74:	10bfffcc 	andi	r2,r2,65535
    eb78:	2085883a 	add	r2,r4,r2
    eb7c:	1885c83a 	sub	r2,r3,r2
    eb80:	00801f16 	blt	zero,r2,ec00 <tcp_timewait_input+0xf0>
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
    eb84:	d128df17 	ldw	r4,-23684(gp)
    eb88:	d0a8e08b 	ldhu	r2,-23678(gp)
    eb8c:	10ffffcc 	andi	r3,r2,65535
    eb90:	d0a8de17 	ldw	r2,-23688(gp)
    eb94:	188b883a 	add	r5,r3,r2
    eb98:	d0a8dd17 	ldw	r2,-23692(gp)
    eb9c:	10c00404 	addi	r3,r2,16
    eba0:	d0a8dd17 	ldw	r2,-23692(gp)
    eba4:	10800304 	addi	r2,r2,12
        tcphdr->dest, tcphdr->src);
    eba8:	d1a8dc17 	ldw	r6,-23696(gp)
    ebac:	3180008b 	ldhu	r6,2(r6)
  if (flags & TCP_SYN) {
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
    ebb0:	31ffffcc 	andi	r7,r6,65535
        tcphdr->dest, tcphdr->src);
    ebb4:	d1a8dc17 	ldw	r6,-23696(gp)
    ebb8:	3180000b 	ldhu	r6,0(r6)
  if (flags & TCP_SYN) {
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
    ebbc:	31bfffcc 	andi	r6,r6,65535
    ebc0:	d9c00015 	stw	r7,0(sp)
    ebc4:	d9800115 	stw	r6,4(sp)
    ebc8:	180d883a 	mov	r6,r3
    ebcc:	100f883a 	mov	r7,r2
    ebd0:	00137240 	call	13724 <tcp_rst>
        tcphdr->dest, tcphdr->src);
      return ERR_OK;
    ebd4:	0005883a 	mov	r2,zero
    ebd8:	00001606 	br	ec34 <tcp_timewait_input+0x124>
    }
  } else if (flags & TCP_FIN) {
    ebdc:	d0a8e003 	ldbu	r2,-23680(gp)
    ebe0:	10803fcc 	andi	r2,r2,255
    ebe4:	1080004c 	andi	r2,r2,1
    ebe8:	10000526 	beq	r2,zero,ec00 <tcp_timewait_input+0xf0>
    /* - eighth, check the FIN bit: Remain in the TIME-WAIT state.
         Restart the 2 MSL time-wait timeout.*/
    pcb->tmr = tcp_ticks;
    ebec:	008000f4 	movhi	r2,3
    ebf0:	1099c304 	addi	r2,r2,26380
    ebf4:	10c00017 	ldw	r3,0(r2)
    ebf8:	e0bfff17 	ldw	r2,-4(fp)
    ebfc:	10c00d15 	stw	r3,52(r2)
  }

  if ((tcplen > 0))  {
    ec00:	d0a8e08b 	ldhu	r2,-23678(gp)
    ec04:	10bfffcc 	andi	r2,r2,65535
    ec08:	10000926 	beq	r2,zero,ec30 <tcp_timewait_input+0x120>
    /* Acknowledge data, FIN or out-of-window SYN */
    pcb->flags |= TF_ACK_NOW;
    ec0c:	e0bfff17 	ldw	r2,-4(fp)
    ec10:	10800983 	ldbu	r2,38(r2)
    ec14:	10800094 	ori	r2,r2,2
    ec18:	1007883a 	mov	r3,r2
    ec1c:	e0bfff17 	ldw	r2,-4(fp)
    ec20:	10c00985 	stb	r3,38(r2)
    return tcp_output(pcb);
    ec24:	e13fff17 	ldw	r4,-4(fp)
    ec28:	0012b000 	call	12b00 <tcp_output>
    ec2c:	00000106 	br	ec34 <tcp_timewait_input+0x124>
  }
  return ERR_OK;
    ec30:	0005883a 	mov	r2,zero
}
    ec34:	e037883a 	mov	sp,fp
    ec38:	dfc00117 	ldw	ra,4(sp)
    ec3c:	df000017 	ldw	fp,0(sp)
    ec40:	dec00204 	addi	sp,sp,8
    ec44:	f800283a 	ret

0000ec48 <tcp_process>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_process(struct tcp_pcb *pcb)
{
    ec48:	defff804 	addi	sp,sp,-32
    ec4c:	dfc00715 	stw	ra,28(sp)
    ec50:	df000615 	stw	fp,24(sp)
    ec54:	df000604 	addi	fp,sp,24
    ec58:	e13fff15 	stw	r4,-4(fp)
  struct tcp_seg *rseg;
  u8_t acceptable = 0;
    ec5c:	e03ffc05 	stb	zero,-16(fp)
  err_t err;

  err = ERR_OK;
    ec60:	e03ffc45 	stb	zero,-15(fp)

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
    ec64:	d0a8e003 	ldbu	r2,-23680(gp)
    ec68:	10803fcc 	andi	r2,r2,255
    ec6c:	1080010c 	andi	r2,r2,4
    ec70:	10003b26 	beq	r2,zero,ed60 <tcp_process+0x118>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
    ec74:	e0bfff17 	ldw	r2,-4(fp)
    ec78:	10800417 	ldw	r2,16(r2)
    ec7c:	10800098 	cmpnei	r2,r2,2
    ec80:	1000071e 	bne	r2,zero,eca0 <tcp_process+0x58>
      if (ackno == pcb->snd_nxt) {
    ec84:	e0bfff17 	ldw	r2,-4(fp)
    ec88:	10c01717 	ldw	r3,92(r2)
    ec8c:	d0a8df17 	ldw	r2,-23684(gp)
    ec90:	1880131e 	bne	r3,r2,ece0 <tcp_process+0x98>
        acceptable = 1;
    ec94:	00800044 	movi	r2,1
    ec98:	e0bffc05 	stb	r2,-16(fp)
    ec9c:	00001006 	br	ece0 <tcp_process+0x98>
      }
    } else {
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
    eca0:	d0e8de17 	ldw	r3,-23688(gp)
    eca4:	e0bfff17 	ldw	r2,-4(fp)
    eca8:	10800a17 	ldw	r2,40(r2)
    ecac:	1885c83a 	sub	r2,r3,r2
    ecb0:	10000b16 	blt	r2,zero,ece0 <tcp_process+0x98>
    ecb4:	d0e8de17 	ldw	r3,-23688(gp)
    ecb8:	e0bfff17 	ldw	r2,-4(fp)
    ecbc:	11000a17 	ldw	r4,40(r2)
    ecc0:	e0bfff17 	ldw	r2,-4(fp)
    ecc4:	10800b0b 	ldhu	r2,44(r2)
    ecc8:	10bfffcc 	andi	r2,r2,65535
    eccc:	2085883a 	add	r2,r4,r2
    ecd0:	1885c83a 	sub	r2,r3,r2
    ecd4:	00800216 	blt	zero,r2,ece0 <tcp_process+0x98>
                          pcb->rcv_nxt+pcb->rcv_wnd)) {
        acceptable = 1;
    ecd8:	00800044 	movi	r2,1
    ecdc:	e0bffc05 	stb	r2,-16(fp)
      }
    }

    if (acceptable) {
    ece0:	e0bffc03 	ldbu	r2,-16(fp)
    ece4:	10001826 	beq	r2,zero,ed48 <tcp_process+0x100>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
    ece8:	e0bfff17 	ldw	r2,-4(fp)
    ecec:	10800417 	ldw	r2,16(r2)
    ecf0:	1000091e 	bne	r2,zero,ed18 <tcp_process+0xd0>
    ecf4:	010000f4 	movhi	r4,3
    ecf8:	213db804 	addi	r4,r4,-2336
    ecfc:	014000f4 	movhi	r5,3
    ed00:	297e1b04 	addi	r5,r5,-1940
    ed04:	01808944 	movi	r6,549
    ed08:	01c000f4 	movhi	r7,3
    ed0c:	39fdcc04 	addi	r7,r7,-2256
    ed10:	00170680 	call	17068 <printf>
    ed14:	003fff06 	br	ed14 <tcp_process+0xcc>
      recv_flags |= TF_RESET;
    ed18:	d0a8e103 	ldbu	r2,-23676(gp)
    ed1c:	10800214 	ori	r2,r2,8
    ed20:	d0a8e105 	stb	r2,-23676(gp)
      pcb->flags &= ~TF_ACK_DELAY;
    ed24:	e0bfff17 	ldw	r2,-4(fp)
    ed28:	10c00983 	ldbu	r3,38(r2)
    ed2c:	00bfff84 	movi	r2,-2
    ed30:	1884703a 	and	r2,r3,r2
    ed34:	1007883a 	mov	r3,r2
    ed38:	e0bfff17 	ldw	r2,-4(fp)
    ed3c:	10c00985 	stb	r3,38(r2)
      return ERR_RST;
    ed40:	00bffe84 	movi	r2,-6
    ed44:	0002ca06 	br	f870 <tcp_process+0xc28>
    } else {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
       seqno, pcb->rcv_nxt));
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
    ed48:	e0bfff17 	ldw	r2,-4(fp)
    ed4c:	10800a17 	ldw	r2,40(r2)
    ed50:	1009883a 	mov	r4,r2
    ed54:	00170680 	call	17068 <printf>
       seqno, pcb->rcv_nxt));
      return ERR_OK;
    ed58:	0005883a 	mov	r2,zero
    ed5c:	0002c406 	br	f870 <tcp_process+0xc28>
    }
  }

  if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) { 
    ed60:	d0a8e003 	ldbu	r2,-23680(gp)
    ed64:	10803fcc 	andi	r2,r2,255
    ed68:	1080008c 	andi	r2,r2,2
    ed6c:	10001226 	beq	r2,zero,edb8 <tcp_process+0x170>
    ed70:	e0bfff17 	ldw	r2,-4(fp)
    ed74:	10800417 	ldw	r2,16(r2)
    ed78:	108000a0 	cmpeqi	r2,r2,2
    ed7c:	10000e1e 	bne	r2,zero,edb8 <tcp_process+0x170>
    ed80:	e0bfff17 	ldw	r2,-4(fp)
    ed84:	10800417 	ldw	r2,16(r2)
    ed88:	108000e0 	cmpeqi	r2,r2,3
    ed8c:	10000a1e 	bne	r2,zero,edb8 <tcp_process+0x170>
    /* Cope with new connection attempt after remote end crashed */
    tcp_ack_now(pcb);
    ed90:	e0bfff17 	ldw	r2,-4(fp)
    ed94:	10800983 	ldbu	r2,38(r2)
    ed98:	10800094 	ori	r2,r2,2
    ed9c:	1007883a 	mov	r3,r2
    eda0:	e0bfff17 	ldw	r2,-4(fp)
    eda4:	10c00985 	stb	r3,38(r2)
    eda8:	e13fff17 	ldw	r4,-4(fp)
    edac:	0012b000 	call	12b00 <tcp_output>
    return ERR_OK;
    edb0:	0005883a 	mov	r2,zero
    edb4:	0002ae06 	br	f870 <tcp_process+0xc28>
  }
  
  /* Update the PCB (in)activity timer. */
  pcb->tmr = tcp_ticks;
    edb8:	008000f4 	movhi	r2,3
    edbc:	1099c304 	addi	r2,r2,26380
    edc0:	10c00017 	ldw	r3,0(r2)
    edc4:	e0bfff17 	ldw	r2,-4(fp)
    edc8:	10c00d15 	stw	r3,52(r2)
  pcb->keep_cnt_sent = 0;
    edcc:	e0bfff17 	ldw	r2,-4(fp)
    edd0:	10002945 	stb	zero,165(r2)

  tcp_parseopt(pcb);
    edd4:	e13fff17 	ldw	r4,-4(fp)
    edd8:	00116c40 	call	116c4 <tcp_parseopt>

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
    eddc:	e0bfff17 	ldw	r2,-4(fp)
    ede0:	10800417 	ldw	r2,16(r2)
    ede4:	10c002a8 	cmpgeui	r3,r2,10
    ede8:	1802911e 	bne	r3,zero,f830 <tcp_process+0xbe8>
    edec:	1085883a 	add	r2,r2,r2
    edf0:	1087883a 	add	r3,r2,r2
    edf4:	00800074 	movhi	r2,1
    edf8:	10bb8204 	addi	r2,r2,-4600
    edfc:	1885883a 	add	r2,r3,r2
    ee00:	10800017 	ldw	r2,0(r2)
    ee04:	1000683a 	jmp	r2
    ee08:	0000f830 	cmpltui	zero,zero,992
    ee0c:	0000f830 	cmpltui	zero,zero,992
    ee10:	0000ee30 	cmpltui	zero,zero,952
    ee14:	0000f130 	cmpltui	zero,zero,964
    ee18:	0000f34c 	andi	zero,zero,973
    ee1c:	0000f394 	movui	zero,974
    ee20:	0000f55c 	xori	zero,zero,981
    ee24:	0000f34c 	andi	zero,zero,973
    ee28:	0000f6a4 	muli	zero,zero,986
    ee2c:	0000f7dc 	xori	zero,zero,991
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
    ee30:	d0a8e003 	ldbu	r2,-23680(gp)
    ee34:	10803fcc 	andi	r2,r2,255
    ee38:	1080040c 	andi	r2,r2,16
    ee3c:	1000a326 	beq	r2,zero,f0cc <tcp_process+0x484>
    ee40:	d0a8e003 	ldbu	r2,-23680(gp)
    ee44:	10803fcc 	andi	r2,r2,255
    ee48:	1080008c 	andi	r2,r2,2
    ee4c:	10009f26 	beq	r2,zero,f0cc <tcp_process+0x484>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
    ee50:	e0bfff17 	ldw	r2,-4(fp)
    ee54:	10801f17 	ldw	r2,124(r2)
    ee58:	10800417 	ldw	r2,16(r2)
    ee5c:	10c0010b 	ldhu	r3,4(r2)
    ee60:	1080018b 	ldhu	r2,6(r2)
    ee64:	1004943a 	slli	r2,r2,16
    ee68:	10c4b03a 	or	r2,r2,r3
    ee6c:	1006d63a 	srli	r3,r2,24
    ee70:	e0bfff17 	ldw	r2,-4(fp)
    ee74:	10801f17 	ldw	r2,124(r2)
    ee78:	10800417 	ldw	r2,16(r2)
    ee7c:	1100010b 	ldhu	r4,4(r2)
    ee80:	1080018b 	ldhu	r2,6(r2)
    ee84:	1004943a 	slli	r2,r2,16
    ee88:	1104b03a 	or	r2,r2,r4
    ee8c:	1004d23a 	srli	r2,r2,8
    ee90:	10bfc00c 	andi	r2,r2,65280
    ee94:	1886b03a 	or	r3,r3,r2
    ee98:	e0bfff17 	ldw	r2,-4(fp)
    ee9c:	10801f17 	ldw	r2,124(r2)
    eea0:	10800417 	ldw	r2,16(r2)
    eea4:	1100010b 	ldhu	r4,4(r2)
    eea8:	1080018b 	ldhu	r2,6(r2)
    eeac:	1004943a 	slli	r2,r2,16
    eeb0:	1104b03a 	or	r2,r2,r4
    eeb4:	10bfc00c 	andi	r2,r2,65280
    eeb8:	1004923a 	slli	r2,r2,8
    eebc:	1886b03a 	or	r3,r3,r2
    eec0:	e0bfff17 	ldw	r2,-4(fp)
    eec4:	10801f17 	ldw	r2,124(r2)
    eec8:	10800417 	ldw	r2,16(r2)
    eecc:	1100010b 	ldhu	r4,4(r2)
    eed0:	1080018b 	ldhu	r2,6(r2)
    eed4:	1004943a 	slli	r2,r2,16
    eed8:	1104b03a 	or	r2,r2,r4
    eedc:	1004963a 	slli	r2,r2,24
    eee0:	1884b03a 	or	r2,r3,r2
    eee4:	10c00044 	addi	r3,r2,1
    eee8:	d0a8df17 	ldw	r2,-23684(gp)
    eeec:	1880771e 	bne	r3,r2,f0cc <tcp_process+0x484>
      pcb->snd_buf++;
    eef0:	e0bfff17 	ldw	r2,-4(fp)
    eef4:	10801c8b 	ldhu	r2,114(r2)
    eef8:	10800044 	addi	r2,r2,1
    eefc:	1007883a 	mov	r3,r2
    ef00:	e0bfff17 	ldw	r2,-4(fp)
    ef04:	10c01c8d 	sth	r3,114(r2)
      pcb->rcv_nxt = seqno + 1;
    ef08:	d0a8de17 	ldw	r2,-23688(gp)
    ef0c:	10c00044 	addi	r3,r2,1
    ef10:	e0bfff17 	ldw	r2,-4(fp)
    ef14:	10c00a15 	stw	r3,40(r2)
      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
    ef18:	e0bfff17 	ldw	r2,-4(fp)
    ef1c:	10c00a17 	ldw	r3,40(r2)
    ef20:	e0bfff17 	ldw	r2,-4(fp)
    ef24:	10c00c15 	stw	r3,48(r2)
      pcb->lastack = ackno;
    ef28:	d0e8df17 	ldw	r3,-23684(gp)
    ef2c:	e0bfff17 	ldw	r2,-4(fp)
    ef30:	10c01415 	stw	r3,80(r2)
      pcb->snd_wnd = tcphdr->wnd;
    ef34:	d0a8dc17 	ldw	r2,-23696(gp)
    ef38:	10c0038b 	ldhu	r3,14(r2)
    ef3c:	e0bfff17 	ldw	r2,-4(fp)
    ef40:	10c0180d 	sth	r3,96(r2)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
    ef44:	d0a8de17 	ldw	r2,-23688(gp)
    ef48:	10ffffc4 	addi	r3,r2,-1
    ef4c:	e0bfff17 	ldw	r2,-4(fp)
    ef50:	10c01915 	stw	r3,100(r2)
      pcb->state = ESTABLISHED;
    ef54:	e0bfff17 	ldw	r2,-4(fp)
    ef58:	00c00104 	movi	r3,4
    ef5c:	10c00415 	stw	r3,16(r2)

#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
    ef60:	e0bfff17 	ldw	r2,-4(fp)
    ef64:	10800f0b 	ldhu	r2,60(r2)
    ef68:	10ffffcc 	andi	r3,r2,65535
    ef6c:	e0bfff17 	ldw	r2,-4(fp)
    ef70:	10800104 	addi	r2,r2,4
    ef74:	1809883a 	mov	r4,r3
    ef78:	100b883a 	mov	r5,r2
    ef7c:	000d4400 	call	d440 <tcp_eff_send_mss>
    ef80:	e0ffff17 	ldw	r3,-4(fp)
    ef84:	18800f0d 	sth	r2,60(r3)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
    ef88:	e0bfff17 	ldw	r2,-4(fp)
    ef8c:	10800f0b 	ldhu	r2,60(r2)
    ef90:	108002a4 	muli	r2,r2,10
    ef94:	1007883a 	mov	r3,r2
    ef98:	e0bfff17 	ldw	r2,-4(fp)
    ef9c:	10c0160d 	sth	r3,88(r2)

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
    efa0:	e0bfff17 	ldw	r2,-4(fp)
    efa4:	1080158b 	ldhu	r2,86(r2)
    efa8:	10bfffcc 	andi	r2,r2,65535
    efac:	10800058 	cmpnei	r2,r2,1
    efb0:	1000041e 	bne	r2,zero,efc4 <tcp_process+0x37c>
    efb4:	e0bfff17 	ldw	r2,-4(fp)
    efb8:	10800f0b 	ldhu	r2,60(r2)
    efbc:	1085883a 	add	r2,r2,r2
    efc0:	00000206 	br	efcc <tcp_process+0x384>
    efc4:	e0bfff17 	ldw	r2,-4(fp)
    efc8:	10800f0b 	ldhu	r2,60(r2)
    efcc:	e0ffff17 	ldw	r3,-4(fp)
    efd0:	1880158d 	sth	r2,86(r3)
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
    efd4:	e0bfff17 	ldw	r2,-4(fp)
    efd8:	10801d0b 	ldhu	r2,116(r2)
    efdc:	10bfffcc 	andi	r2,r2,65535
    efe0:	1000091e 	bne	r2,zero,f008 <tcp_process+0x3c0>
    efe4:	010000f4 	movhi	r4,3
    efe8:	213db804 	addi	r4,r4,-2336
    efec:	014000f4 	movhi	r5,3
    eff0:	297e2304 	addi	r5,r5,-1908
    eff4:	018095c4 	movi	r6,599
    eff8:	01c000f4 	movhi	r7,3
    effc:	39fdcc04 	addi	r7,r7,-2256
    f000:	00170680 	call	17068 <printf>
    f004:	003fff06 	br	f004 <tcp_process+0x3bc>
      --pcb->snd_queuelen;
    f008:	e0bfff17 	ldw	r2,-4(fp)
    f00c:	10801d0b 	ldhu	r2,116(r2)
    f010:	10bfffc4 	addi	r2,r2,-1
    f014:	1007883a 	mov	r3,r2
    f018:	e0bfff17 	ldw	r2,-4(fp)
    f01c:	10c01d0d 	sth	r3,116(r2)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
    f020:	e0bfff17 	ldw	r2,-4(fp)
    f024:	10801f17 	ldw	r2,124(r2)
    f028:	e0bffd15 	stw	r2,-12(fp)
      pcb->unacked = rseg->next;
    f02c:	e0bffd17 	ldw	r2,-12(fp)
    f030:	10c00017 	ldw	r3,0(r2)
    f034:	e0bfff17 	ldw	r2,-4(fp)
    f038:	10c01f15 	stw	r3,124(r2)

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
    f03c:	e0bfff17 	ldw	r2,-4(fp)
    f040:	10801f17 	ldw	r2,124(r2)
    f044:	1000041e 	bne	r2,zero,f058 <tcp_process+0x410>
        pcb->rtime = -1;
    f048:	e0bfff17 	ldw	r2,-4(fp)
    f04c:	00ffffc4 	movi	r3,-1
    f050:	10c00e8d 	sth	r3,58(r2)
    f054:	00000406 	br	f068 <tcp_process+0x420>
      else {
        pcb->rtime = 0;
    f058:	e0bfff17 	ldw	r2,-4(fp)
    f05c:	10000e8d 	sth	zero,58(r2)
        pcb->nrtx = 0;
    f060:	e0bfff17 	ldw	r2,-4(fp)
    f064:	10001385 	stb	zero,78(r2)
      }

      tcp_seg_free(rseg);
    f068:	e13ffd17 	ldw	r4,-12(fp)
    f06c:	000ca9c0 	call	ca9c <tcp_seg_free>

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
    f070:	e0bfff17 	ldw	r2,-4(fp)
    f074:	10802417 	ldw	r2,144(r2)
    f078:	10000a26 	beq	r2,zero,f0a4 <tcp_process+0x45c>
    f07c:	e0bfff17 	ldw	r2,-4(fp)
    f080:	10c02417 	ldw	r3,144(r2)
    f084:	e0bfff17 	ldw	r2,-4(fp)
    f088:	10800617 	ldw	r2,24(r2)
    f08c:	1009883a 	mov	r4,r2
    f090:	e17fff17 	ldw	r5,-4(fp)
    f094:	000d883a 	mov	r6,zero
    f098:	183ee83a 	callr	r3
    f09c:	e0bffc45 	stb	r2,-15(fp)
    f0a0:	00000106 	br	f0a8 <tcp_process+0x460>
    f0a4:	e03ffc45 	stb	zero,-15(fp)
      tcp_ack_now(pcb);
    f0a8:	e0bfff17 	ldw	r2,-4(fp)
    f0ac:	10800983 	ldbu	r2,38(r2)
    f0b0:	10800094 	ori	r2,r2,2
    f0b4:	1007883a 	mov	r3,r2
    f0b8:	e0bfff17 	ldw	r2,-4(fp)
    f0bc:	10c00985 	stb	r3,38(r2)
    f0c0:	e13fff17 	ldw	r4,-4(fp)
    f0c4:	0012b000 	call	12b00 <tcp_output>
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    break;
    f0c8:	0001db06 	br	f838 <tcp_process+0xbf0>
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
    f0cc:	d0a8e003 	ldbu	r2,-23680(gp)
    f0d0:	10803fcc 	andi	r2,r2,255
    f0d4:	1080040c 	andi	r2,r2,16
    f0d8:	1001d726 	beq	r2,zero,f838 <tcp_process+0xbf0>
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
    f0dc:	d128df17 	ldw	r4,-23684(gp)
    f0e0:	d0a8e08b 	ldhu	r2,-23678(gp)
    f0e4:	10ffffcc 	andi	r3,r2,65535
    f0e8:	d0a8de17 	ldw	r2,-23688(gp)
    f0ec:	188b883a 	add	r5,r3,r2
    f0f0:	d0a8dd17 	ldw	r2,-23692(gp)
    f0f4:	10c00404 	addi	r3,r2,16
    f0f8:	d0a8dd17 	ldw	r2,-23692(gp)
    f0fc:	10800304 	addi	r2,r2,12
        tcphdr->dest, tcphdr->src);
    f100:	d1a8dc17 	ldw	r6,-23696(gp)
    f104:	3180008b 	ldhu	r6,2(r6)
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
    f108:	31ffffcc 	andi	r7,r6,65535
        tcphdr->dest, tcphdr->src);
    f10c:	d1a8dc17 	ldw	r6,-23696(gp)
    f110:	3180000b 	ldhu	r6,0(r6)
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
    f114:	31bfffcc 	andi	r6,r6,65535
    f118:	d9c00015 	stw	r7,0(sp)
    f11c:	d9800115 	stw	r6,4(sp)
    f120:	180d883a 	mov	r6,r3
    f124:	100f883a 	mov	r7,r2
    f128:	00137240 	call	13724 <tcp_rst>
        tcphdr->dest, tcphdr->src);
    }
    break;
    f12c:	0001c206 	br	f838 <tcp_process+0xbf0>
  case SYN_RCVD:
    if (flags & TCP_ACK) {
    f130:	d0a8e003 	ldbu	r2,-23680(gp)
    f134:	10803fcc 	andi	r2,r2,255
    f138:	1080040c 	andi	r2,r2,16
    f13c:	10007726 	beq	r2,zero,f31c <tcp_process+0x6d4>
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
    f140:	e0bfff17 	ldw	r2,-4(fp)
    f144:	10801417 	ldw	r2,80(r2)
    f148:	0086303a 	nor	r3,zero,r2
    f14c:	d0a8df17 	ldw	r2,-23684(gp)
    f150:	1885883a 	add	r2,r3,r2
    f154:	10005a16 	blt	r2,zero,f2c0 <tcp_process+0x678>
    f158:	d0e8df17 	ldw	r3,-23684(gp)
    f15c:	e0bfff17 	ldw	r2,-4(fp)
    f160:	10801717 	ldw	r2,92(r2)
    f164:	1885c83a 	sub	r2,r3,r2
    f168:	00805516 	blt	zero,r2,f2c0 <tcp_process+0x678>
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
    f16c:	e0bfff17 	ldw	r2,-4(fp)
    f170:	00c00104 	movi	r3,4
    f174:	10c00415 	stw	r3,16(r2)
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
    f178:	00800134 	movhi	r2,4
    f17c:	1090c604 	addi	r2,r2,17176
    f180:	10800417 	ldw	r2,16(r2)
    f184:	1080008b 	ldhu	r2,2(r2)
    f188:	10bfffcc 	andi	r2,r2,65535
    f18c:	1009883a 	mov	r4,r2
    f190:	00170680 	call	17068 <printf>
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
    f194:	e0bfff17 	ldw	r2,-4(fp)
    f198:	10800817 	ldw	r2,32(r2)
    f19c:	1000091e 	bne	r2,zero,f1c4 <tcp_process+0x57c>
    f1a0:	010000f4 	movhi	r4,3
    f1a4:	213db804 	addi	r4,r4,-2336
    f1a8:	014000f4 	movhi	r5,3
    f1ac:	297e2904 	addi	r5,r5,-1884
    f1b0:	01809f04 	movi	r6,636
    f1b4:	01c000f4 	movhi	r7,3
    f1b8:	39fdcc04 	addi	r7,r7,-2256
    f1bc:	00170680 	call	17068 <printf>
    f1c0:	003fff06 	br	f1c0 <tcp_process+0x578>
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
    f1c4:	e0bfff17 	ldw	r2,-4(fp)
    f1c8:	10800817 	ldw	r2,32(r2)
    f1cc:	10000a26 	beq	r2,zero,f1f8 <tcp_process+0x5b0>
    f1d0:	e0bfff17 	ldw	r2,-4(fp)
    f1d4:	10c00817 	ldw	r3,32(r2)
    f1d8:	e0bfff17 	ldw	r2,-4(fp)
    f1dc:	10800617 	ldw	r2,24(r2)
    f1e0:	1009883a 	mov	r4,r2
    f1e4:	e17fff17 	ldw	r5,-4(fp)
    f1e8:	000d883a 	mov	r6,zero
    f1ec:	183ee83a 	callr	r3
    f1f0:	e0bffc45 	stb	r2,-15(fp)
    f1f4:	00000106 	br	f1fc <tcp_process+0x5b4>
    f1f8:	e03ffc45 	stb	zero,-15(fp)
        if (err != ERR_OK) {
    f1fc:	e0bffc47 	ldb	r2,-15(fp)
    f200:	10000526 	beq	r2,zero,f218 <tcp_process+0x5d0>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
    f204:	e13fff17 	ldw	r4,-4(fp)
    f208:	01400044 	movi	r5,1
    f20c:	000b4a00 	call	b4a0 <tcp_abandon>
          return ERR_ABRT;
    f210:	00bffec4 	movi	r2,-5
    f214:	00019606 	br	f870 <tcp_process+0xc28>
        }
        old_cwnd = pcb->cwnd;
    f218:	e0bfff17 	ldw	r2,-4(fp)
    f21c:	1080158b 	ldhu	r2,86(r2)
    f220:	e0bffe0d 	sth	r2,-8(fp)
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        tcp_receive(pcb);
    f224:	e13fff17 	ldw	r4,-4(fp)
    f228:	000faa00 	call	faa0 <tcp_receive>

        /* Prevent ACK for SYN to generate a sent event */
        if (pcb->acked != 0) {
    f22c:	e0bfff17 	ldw	r2,-4(fp)
    f230:	10801c0b 	ldhu	r2,112(r2)
    f234:	10bfffcc 	andi	r2,r2,65535
    f238:	10000626 	beq	r2,zero,f254 <tcp_process+0x60c>
          pcb->acked--;
    f23c:	e0bfff17 	ldw	r2,-4(fp)
    f240:	10801c0b 	ldhu	r2,112(r2)
    f244:	10bfffc4 	addi	r2,r2,-1
    f248:	1007883a 	mov	r3,r2
    f24c:	e0bfff17 	ldw	r2,-4(fp)
    f250:	10c01c0d 	sth	r3,112(r2)
        }

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
    f254:	e0bffe0b 	ldhu	r2,-8(fp)
    f258:	10800058 	cmpnei	r2,r2,1
    f25c:	1000041e 	bne	r2,zero,f270 <tcp_process+0x628>
    f260:	e0bfff17 	ldw	r2,-4(fp)
    f264:	10800f0b 	ldhu	r2,60(r2)
    f268:	1085883a 	add	r2,r2,r2
    f26c:	00000206 	br	f278 <tcp_process+0x630>
    f270:	e0bfff17 	ldw	r2,-4(fp)
    f274:	10800f0b 	ldhu	r2,60(r2)
    f278:	e0ffff17 	ldw	r3,-4(fp)
    f27c:	1880158d 	sth	r2,86(r3)

        if (recv_flags & TF_GOT_FIN) {
    f280:	d0a8e103 	ldbu	r2,-23676(gp)
    f284:	10803fcc 	andi	r2,r2,255
    f288:	1080080c 	andi	r2,r2,32
    f28c:	10002126 	beq	r2,zero,f314 <tcp_process+0x6cc>
          tcp_ack_now(pcb);
    f290:	e0bfff17 	ldw	r2,-4(fp)
    f294:	10800983 	ldbu	r2,38(r2)
    f298:	10800094 	ori	r2,r2,2
    f29c:	1007883a 	mov	r3,r2
    f2a0:	e0bfff17 	ldw	r2,-4(fp)
    f2a4:	10c00985 	stb	r3,38(r2)
    f2a8:	e13fff17 	ldw	r4,-4(fp)
    f2ac:	0012b000 	call	12b00 <tcp_output>
          pcb->state = CLOSE_WAIT;
    f2b0:	e0bfff17 	ldw	r2,-4(fp)
    f2b4:	00c001c4 	movi	r3,7
    f2b8:	10c00415 	stw	r3,16(r2)
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
    f2bc:	00001506 	br	f314 <tcp_process+0x6cc>
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
    f2c0:	d128df17 	ldw	r4,-23684(gp)
    f2c4:	d0a8e08b 	ldhu	r2,-23678(gp)
    f2c8:	10ffffcc 	andi	r3,r2,65535
    f2cc:	d0a8de17 	ldw	r2,-23688(gp)
    f2d0:	188b883a 	add	r5,r3,r2
    f2d4:	d0a8dd17 	ldw	r2,-23692(gp)
    f2d8:	10c00404 	addi	r3,r2,16
    f2dc:	d0a8dd17 	ldw	r2,-23692(gp)
    f2e0:	10800304 	addi	r2,r2,12
                tcphdr->dest, tcphdr->src);
    f2e4:	d1a8dc17 	ldw	r6,-23696(gp)
    f2e8:	3180008b 	ldhu	r6,2(r6)
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
    f2ec:	31ffffcc 	andi	r7,r6,65535
                tcphdr->dest, tcphdr->src);
    f2f0:	d1a8dc17 	ldw	r6,-23696(gp)
    f2f4:	3180000b 	ldhu	r6,0(r6)
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
    f2f8:	31bfffcc 	andi	r6,r6,65535
    f2fc:	d9c00015 	stw	r7,0(sp)
    f300:	d9800115 	stw	r6,4(sp)
    f304:	180d883a 	mov	r6,r3
    f308:	100f883a 	mov	r7,r2
    f30c:	00137240 	call	13724 <tcp_rst>
      }
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
      /* Looks like another copy of the SYN - retransmit our SYN-ACK */
      tcp_rexmit(pcb);
    }
    break;
    f310:	00014b06 	br	f840 <tcp_process+0xbf8>
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
    f314:	0001883a 	nop
      }
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
      /* Looks like another copy of the SYN - retransmit our SYN-ACK */
      tcp_rexmit(pcb);
    }
    break;
    f318:	00014906 	br	f840 <tcp_process+0xbf8>
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
                tcphdr->dest, tcphdr->src);
      }
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
    f31c:	d0a8e003 	ldbu	r2,-23680(gp)
    f320:	10803fcc 	andi	r2,r2,255
    f324:	1080008c 	andi	r2,r2,2
    f328:	10014526 	beq	r2,zero,f840 <tcp_process+0xbf8>
    f32c:	e0bfff17 	ldw	r2,-4(fp)
    f330:	10800a17 	ldw	r2,40(r2)
    f334:	10ffffc4 	addi	r3,r2,-1
    f338:	d0a8de17 	ldw	r2,-23688(gp)
    f33c:	1881401e 	bne	r3,r2,f840 <tcp_process+0xbf8>
      /* Looks like another copy of the SYN - retransmit our SYN-ACK */
      tcp_rexmit(pcb);
    f340:	e13fff17 	ldw	r4,-4(fp)
    f344:	0013a840 	call	13a84 <tcp_rexmit>
    }
    break;
    f348:	00013d06 	br	f840 <tcp_process+0xbf8>
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    tcp_receive(pcb);
    f34c:	e13fff17 	ldw	r4,-4(fp)
    f350:	000faa00 	call	faa0 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) { /* passive close */
    f354:	d0a8e103 	ldbu	r2,-23676(gp)
    f358:	10803fcc 	andi	r2,r2,255
    f35c:	1080080c 	andi	r2,r2,32
    f360:	10013926 	beq	r2,zero,f848 <tcp_process+0xc00>
      tcp_ack_now(pcb);
    f364:	e0bfff17 	ldw	r2,-4(fp)
    f368:	10800983 	ldbu	r2,38(r2)
    f36c:	10800094 	ori	r2,r2,2
    f370:	1007883a 	mov	r3,r2
    f374:	e0bfff17 	ldw	r2,-4(fp)
    f378:	10c00985 	stb	r3,38(r2)
    f37c:	e13fff17 	ldw	r4,-4(fp)
    f380:	0012b000 	call	12b00 <tcp_output>
      pcb->state = CLOSE_WAIT;
    f384:	e0bfff17 	ldw	r2,-4(fp)
    f388:	00c001c4 	movi	r3,7
    f38c:	10c00415 	stw	r3,16(r2)
    }
    break;
    f390:	00012d06 	br	f848 <tcp_process+0xc00>
  case FIN_WAIT_1:
    tcp_receive(pcb);
    f394:	e13fff17 	ldw	r4,-4(fp)
    f398:	000faa00 	call	faa0 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) {
    f39c:	d0a8e103 	ldbu	r2,-23676(gp)
    f3a0:	10803fcc 	andi	r2,r2,255
    f3a4:	1080080c 	andi	r2,r2,32
    f3a8:	10006026 	beq	r2,zero,f52c <tcp_process+0x8e4>
      if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
    f3ac:	d0a8e003 	ldbu	r2,-23680(gp)
    f3b0:	10803fcc 	andi	r2,r2,255
    f3b4:	1080040c 	andi	r2,r2,16
    f3b8:	10005026 	beq	r2,zero,f4fc <tcp_process+0x8b4>
    f3bc:	e0bfff17 	ldw	r2,-4(fp)
    f3c0:	10c01717 	ldw	r3,92(r2)
    f3c4:	d0a8df17 	ldw	r2,-23684(gp)
    f3c8:	18804c1e 	bne	r3,r2,f4fc <tcp_process+0x8b4>
        LWIP_DEBUGF(TCP_DEBUG,
    f3cc:	00800134 	movhi	r2,4
    f3d0:	1090c604 	addi	r2,r2,17176
    f3d4:	10800417 	ldw	r2,16(r2)
    f3d8:	1080008b 	ldhu	r2,2(r2)
    f3dc:	10bfffcc 	andi	r2,r2,65535
    f3e0:	1009883a 	mov	r4,r2
    f3e4:	00170680 	call	17068 <printf>
          ("TCP connection closed: FIN_WAIT_1 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
    f3e8:	e0bfff17 	ldw	r2,-4(fp)
    f3ec:	10800983 	ldbu	r2,38(r2)
    f3f0:	10800094 	ori	r2,r2,2
    f3f4:	1007883a 	mov	r3,r2
    f3f8:	e0bfff17 	ldw	r2,-4(fp)
    f3fc:	10c00985 	stb	r3,38(r2)
    f400:	e13fff17 	ldw	r4,-4(fp)
    f404:	0012b000 	call	12b00 <tcp_output>
        tcp_pcb_purge(pcb);
    f408:	e13fff17 	ldw	r4,-4(fp)
    f40c:	000d0fc0 	call	d0fc <tcp_pcb_purge>
        TCP_RMV(&tcp_active_pcbs, pcb);
    f410:	008000f4 	movhi	r2,3
    f414:	1099c204 	addi	r2,r2,26376
    f418:	10c00017 	ldw	r3,0(r2)
    f41c:	e0bfff17 	ldw	r2,-4(fp)
    f420:	1880081e 	bne	r3,r2,f444 <tcp_process+0x7fc>
    f424:	008000f4 	movhi	r2,3
    f428:	1099c204 	addi	r2,r2,26376
    f42c:	10800017 	ldw	r2,0(r2)
    f430:	10c00317 	ldw	r3,12(r2)
    f434:	008000f4 	movhi	r2,3
    f438:	1099c204 	addi	r2,r2,26376
    f43c:	10c00015 	stw	r3,0(r2)
    f440:	00001f06 	br	f4c0 <tcp_process+0x878>
    f444:	008000f4 	movhi	r2,3
    f448:	1099c204 	addi	r2,r2,26376
    f44c:	10c00017 	ldw	r3,0(r2)
    f450:	008000f4 	movhi	r2,3
    f454:	1099c504 	addi	r2,r2,26388
    f458:	10c00015 	stw	r3,0(r2)
    f45c:	00001406 	br	f4b0 <tcp_process+0x868>
    f460:	008000f4 	movhi	r2,3
    f464:	1099c504 	addi	r2,r2,26388
    f468:	10800017 	ldw	r2,0(r2)
    f46c:	10c00317 	ldw	r3,12(r2)
    f470:	e0bfff17 	ldw	r2,-4(fp)
    f474:	1880071e 	bne	r3,r2,f494 <tcp_process+0x84c>
    f478:	008000f4 	movhi	r2,3
    f47c:	1099c504 	addi	r2,r2,26388
    f480:	10800017 	ldw	r2,0(r2)
    f484:	e0ffff17 	ldw	r3,-4(fp)
    f488:	18c00317 	ldw	r3,12(r3)
    f48c:	10c00315 	stw	r3,12(r2)
    f490:	00000b06 	br	f4c0 <tcp_process+0x878>
    f494:	008000f4 	movhi	r2,3
    f498:	1099c504 	addi	r2,r2,26388
    f49c:	10800017 	ldw	r2,0(r2)
    f4a0:	10c00317 	ldw	r3,12(r2)
    f4a4:	008000f4 	movhi	r2,3
    f4a8:	1099c504 	addi	r2,r2,26388
    f4ac:	10c00015 	stw	r3,0(r2)
    f4b0:	008000f4 	movhi	r2,3
    f4b4:	1099c504 	addi	r2,r2,26388
    f4b8:	10800017 	ldw	r2,0(r2)
    f4bc:	103fe81e 	bne	r2,zero,f460 <tcp_process+0x818>
    f4c0:	e0bfff17 	ldw	r2,-4(fp)
    f4c4:	10000315 	stw	zero,12(r2)
        pcb->state = TIME_WAIT;
    f4c8:	e0bfff17 	ldw	r2,-4(fp)
    f4cc:	00c00284 	movi	r3,10
    f4d0:	10c00415 	stw	r3,16(r2)
        TCP_REG(&tcp_tw_pcbs, pcb);
    f4d4:	008000f4 	movhi	r2,3
    f4d8:	1099c704 	addi	r2,r2,26396
    f4dc:	10c00017 	ldw	r3,0(r2)
    f4e0:	e0bfff17 	ldw	r2,-4(fp)
    f4e4:	10c00315 	stw	r3,12(r2)
    f4e8:	008000f4 	movhi	r2,3
    f4ec:	1099c704 	addi	r2,r2,26396
    f4f0:	e0ffff17 	ldw	r3,-4(fp)
    f4f4:	10c00015 	stw	r3,0(r2)
        pcb->state = CLOSING;
      }
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
      pcb->state = FIN_WAIT_2;
    }
    break;
    f4f8:	0000d506 	br	f850 <tcp_process+0xc08>
        tcp_pcb_purge(pcb);
        TCP_RMV(&tcp_active_pcbs, pcb);
        pcb->state = TIME_WAIT;
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        tcp_ack_now(pcb);
    f4fc:	e0bfff17 	ldw	r2,-4(fp)
    f500:	10800983 	ldbu	r2,38(r2)
    f504:	10800094 	ori	r2,r2,2
    f508:	1007883a 	mov	r3,r2
    f50c:	e0bfff17 	ldw	r2,-4(fp)
    f510:	10c00985 	stb	r3,38(r2)
    f514:	e13fff17 	ldw	r4,-4(fp)
    f518:	0012b000 	call	12b00 <tcp_output>
        pcb->state = CLOSING;
    f51c:	e0bfff17 	ldw	r2,-4(fp)
    f520:	00c00204 	movi	r3,8
    f524:	10c00415 	stw	r3,16(r2)
      }
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
      pcb->state = FIN_WAIT_2;
    }
    break;
    f528:	0000c906 	br	f850 <tcp_process+0xc08>
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        tcp_ack_now(pcb);
        pcb->state = CLOSING;
      }
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
    f52c:	d0a8e003 	ldbu	r2,-23680(gp)
    f530:	10803fcc 	andi	r2,r2,255
    f534:	1080040c 	andi	r2,r2,16
    f538:	1000c526 	beq	r2,zero,f850 <tcp_process+0xc08>
    f53c:	e0bfff17 	ldw	r2,-4(fp)
    f540:	10c01717 	ldw	r3,92(r2)
    f544:	d0a8df17 	ldw	r2,-23684(gp)
    f548:	1880c11e 	bne	r3,r2,f850 <tcp_process+0xc08>
      pcb->state = FIN_WAIT_2;
    f54c:	e0bfff17 	ldw	r2,-4(fp)
    f550:	00c00184 	movi	r3,6
    f554:	10c00415 	stw	r3,16(r2)
    }
    break;
    f558:	0000bd06 	br	f850 <tcp_process+0xc08>
  case FIN_WAIT_2:
    tcp_receive(pcb);
    f55c:	e13fff17 	ldw	r4,-4(fp)
    f560:	000faa00 	call	faa0 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) {
    f564:	d0a8e103 	ldbu	r2,-23676(gp)
    f568:	10803fcc 	andi	r2,r2,255
    f56c:	1080080c 	andi	r2,r2,32
    f570:	1000b926 	beq	r2,zero,f858 <tcp_process+0xc10>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: FIN_WAIT_2 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
    f574:	00800134 	movhi	r2,4
    f578:	1090c604 	addi	r2,r2,17176
    f57c:	10800417 	ldw	r2,16(r2)
    f580:	1080008b 	ldhu	r2,2(r2)
    f584:	10bfffcc 	andi	r2,r2,65535
    f588:	1009883a 	mov	r4,r2
    f58c:	00170680 	call	17068 <printf>
      tcp_ack_now(pcb);
    f590:	e0bfff17 	ldw	r2,-4(fp)
    f594:	10800983 	ldbu	r2,38(r2)
    f598:	10800094 	ori	r2,r2,2
    f59c:	1007883a 	mov	r3,r2
    f5a0:	e0bfff17 	ldw	r2,-4(fp)
    f5a4:	10c00985 	stb	r3,38(r2)
    f5a8:	e13fff17 	ldw	r4,-4(fp)
    f5ac:	0012b000 	call	12b00 <tcp_output>
      tcp_pcb_purge(pcb);
    f5b0:	e13fff17 	ldw	r4,-4(fp)
    f5b4:	000d0fc0 	call	d0fc <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
    f5b8:	008000f4 	movhi	r2,3
    f5bc:	1099c204 	addi	r2,r2,26376
    f5c0:	10c00017 	ldw	r3,0(r2)
    f5c4:	e0bfff17 	ldw	r2,-4(fp)
    f5c8:	1880081e 	bne	r3,r2,f5ec <tcp_process+0x9a4>
    f5cc:	008000f4 	movhi	r2,3
    f5d0:	1099c204 	addi	r2,r2,26376
    f5d4:	10800017 	ldw	r2,0(r2)
    f5d8:	10c00317 	ldw	r3,12(r2)
    f5dc:	008000f4 	movhi	r2,3
    f5e0:	1099c204 	addi	r2,r2,26376
    f5e4:	10c00015 	stw	r3,0(r2)
    f5e8:	00001f06 	br	f668 <tcp_process+0xa20>
    f5ec:	008000f4 	movhi	r2,3
    f5f0:	1099c204 	addi	r2,r2,26376
    f5f4:	10c00017 	ldw	r3,0(r2)
    f5f8:	008000f4 	movhi	r2,3
    f5fc:	1099c504 	addi	r2,r2,26388
    f600:	10c00015 	stw	r3,0(r2)
    f604:	00001406 	br	f658 <tcp_process+0xa10>
    f608:	008000f4 	movhi	r2,3
    f60c:	1099c504 	addi	r2,r2,26388
    f610:	10800017 	ldw	r2,0(r2)
    f614:	10c00317 	ldw	r3,12(r2)
    f618:	e0bfff17 	ldw	r2,-4(fp)
    f61c:	1880071e 	bne	r3,r2,f63c <tcp_process+0x9f4>
    f620:	008000f4 	movhi	r2,3
    f624:	1099c504 	addi	r2,r2,26388
    f628:	10800017 	ldw	r2,0(r2)
    f62c:	e0ffff17 	ldw	r3,-4(fp)
    f630:	18c00317 	ldw	r3,12(r3)
    f634:	10c00315 	stw	r3,12(r2)
    f638:	00000b06 	br	f668 <tcp_process+0xa20>
    f63c:	008000f4 	movhi	r2,3
    f640:	1099c504 	addi	r2,r2,26388
    f644:	10800017 	ldw	r2,0(r2)
    f648:	10c00317 	ldw	r3,12(r2)
    f64c:	008000f4 	movhi	r2,3
    f650:	1099c504 	addi	r2,r2,26388
    f654:	10c00015 	stw	r3,0(r2)
    f658:	008000f4 	movhi	r2,3
    f65c:	1099c504 	addi	r2,r2,26388
    f660:	10800017 	ldw	r2,0(r2)
    f664:	103fe81e 	bne	r2,zero,f608 <tcp_process+0x9c0>
    f668:	e0bfff17 	ldw	r2,-4(fp)
    f66c:	10000315 	stw	zero,12(r2)
      pcb->state = TIME_WAIT;
    f670:	e0bfff17 	ldw	r2,-4(fp)
    f674:	00c00284 	movi	r3,10
    f678:	10c00415 	stw	r3,16(r2)
      TCP_REG(&tcp_tw_pcbs, pcb);
    f67c:	008000f4 	movhi	r2,3
    f680:	1099c704 	addi	r2,r2,26396
    f684:	10c00017 	ldw	r3,0(r2)
    f688:	e0bfff17 	ldw	r2,-4(fp)
    f68c:	10c00315 	stw	r3,12(r2)
    f690:	008000f4 	movhi	r2,3
    f694:	1099c704 	addi	r2,r2,26396
    f698:	e0ffff17 	ldw	r3,-4(fp)
    f69c:	10c00015 	stw	r3,0(r2)
    }
    break;
    f6a0:	00006d06 	br	f858 <tcp_process+0xc10>
  case CLOSING:
    tcp_receive(pcb);
    f6a4:	e13fff17 	ldw	r4,-4(fp)
    f6a8:	000faa00 	call	faa0 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
    f6ac:	d0a8e003 	ldbu	r2,-23680(gp)
    f6b0:	10803fcc 	andi	r2,r2,255
    f6b4:	1080040c 	andi	r2,r2,16
    f6b8:	10006926 	beq	r2,zero,f860 <tcp_process+0xc18>
    f6bc:	e0bfff17 	ldw	r2,-4(fp)
    f6c0:	10c01717 	ldw	r3,92(r2)
    f6c4:	d0a8df17 	ldw	r2,-23684(gp)
    f6c8:	1880651e 	bne	r3,r2,f860 <tcp_process+0xc18>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
    f6cc:	00800134 	movhi	r2,4
    f6d0:	1090c604 	addi	r2,r2,17176
    f6d4:	10800417 	ldw	r2,16(r2)
    f6d8:	1080008b 	ldhu	r2,2(r2)
    f6dc:	10bfffcc 	andi	r2,r2,65535
    f6e0:	1009883a 	mov	r4,r2
    f6e4:	00170680 	call	17068 <printf>
      tcp_pcb_purge(pcb);
    f6e8:	e13fff17 	ldw	r4,-4(fp)
    f6ec:	000d0fc0 	call	d0fc <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
    f6f0:	008000f4 	movhi	r2,3
    f6f4:	1099c204 	addi	r2,r2,26376
    f6f8:	10c00017 	ldw	r3,0(r2)
    f6fc:	e0bfff17 	ldw	r2,-4(fp)
    f700:	1880081e 	bne	r3,r2,f724 <tcp_process+0xadc>
    f704:	008000f4 	movhi	r2,3
    f708:	1099c204 	addi	r2,r2,26376
    f70c:	10800017 	ldw	r2,0(r2)
    f710:	10c00317 	ldw	r3,12(r2)
    f714:	008000f4 	movhi	r2,3
    f718:	1099c204 	addi	r2,r2,26376
    f71c:	10c00015 	stw	r3,0(r2)
    f720:	00001f06 	br	f7a0 <tcp_process+0xb58>
    f724:	008000f4 	movhi	r2,3
    f728:	1099c204 	addi	r2,r2,26376
    f72c:	10c00017 	ldw	r3,0(r2)
    f730:	008000f4 	movhi	r2,3
    f734:	1099c504 	addi	r2,r2,26388
    f738:	10c00015 	stw	r3,0(r2)
    f73c:	00001406 	br	f790 <tcp_process+0xb48>
    f740:	008000f4 	movhi	r2,3
    f744:	1099c504 	addi	r2,r2,26388
    f748:	10800017 	ldw	r2,0(r2)
    f74c:	10c00317 	ldw	r3,12(r2)
    f750:	e0bfff17 	ldw	r2,-4(fp)
    f754:	1880071e 	bne	r3,r2,f774 <tcp_process+0xb2c>
    f758:	008000f4 	movhi	r2,3
    f75c:	1099c504 	addi	r2,r2,26388
    f760:	10800017 	ldw	r2,0(r2)
    f764:	e0ffff17 	ldw	r3,-4(fp)
    f768:	18c00317 	ldw	r3,12(r3)
    f76c:	10c00315 	stw	r3,12(r2)
    f770:	00000b06 	br	f7a0 <tcp_process+0xb58>
    f774:	008000f4 	movhi	r2,3
    f778:	1099c504 	addi	r2,r2,26388
    f77c:	10800017 	ldw	r2,0(r2)
    f780:	10c00317 	ldw	r3,12(r2)
    f784:	008000f4 	movhi	r2,3
    f788:	1099c504 	addi	r2,r2,26388
    f78c:	10c00015 	stw	r3,0(r2)
    f790:	008000f4 	movhi	r2,3
    f794:	1099c504 	addi	r2,r2,26388
    f798:	10800017 	ldw	r2,0(r2)
    f79c:	103fe81e 	bne	r2,zero,f740 <tcp_process+0xaf8>
    f7a0:	e0bfff17 	ldw	r2,-4(fp)
    f7a4:	10000315 	stw	zero,12(r2)
      pcb->state = TIME_WAIT;
    f7a8:	e0bfff17 	ldw	r2,-4(fp)
    f7ac:	00c00284 	movi	r3,10
    f7b0:	10c00415 	stw	r3,16(r2)
      TCP_REG(&tcp_tw_pcbs, pcb);
    f7b4:	008000f4 	movhi	r2,3
    f7b8:	1099c704 	addi	r2,r2,26396
    f7bc:	10c00017 	ldw	r3,0(r2)
    f7c0:	e0bfff17 	ldw	r2,-4(fp)
    f7c4:	10c00315 	stw	r3,12(r2)
    f7c8:	008000f4 	movhi	r2,3
    f7cc:	1099c704 	addi	r2,r2,26396
    f7d0:	e0ffff17 	ldw	r3,-4(fp)
    f7d4:	10c00015 	stw	r3,0(r2)
    }
    break;
    f7d8:	00002106 	br	f860 <tcp_process+0xc18>
  case LAST_ACK:
    tcp_receive(pcb);
    f7dc:	e13fff17 	ldw	r4,-4(fp)
    f7e0:	000faa00 	call	faa0 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
    f7e4:	d0a8e003 	ldbu	r2,-23680(gp)
    f7e8:	10803fcc 	andi	r2,r2,255
    f7ec:	1080040c 	andi	r2,r2,16
    f7f0:	10001d26 	beq	r2,zero,f868 <tcp_process+0xc20>
    f7f4:	e0bfff17 	ldw	r2,-4(fp)
    f7f8:	10c01717 	ldw	r3,92(r2)
    f7fc:	d0a8df17 	ldw	r2,-23684(gp)
    f800:	1880191e 	bne	r3,r2,f868 <tcp_process+0xc20>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
    f804:	00800134 	movhi	r2,4
    f808:	1090c604 	addi	r2,r2,17176
    f80c:	10800417 	ldw	r2,16(r2)
    f810:	1080008b 	ldhu	r2,2(r2)
    f814:	10bfffcc 	andi	r2,r2,65535
    f818:	1009883a 	mov	r4,r2
    f81c:	00170680 	call	17068 <printf>
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags |= TF_CLOSED;
    f820:	d0a8e103 	ldbu	r2,-23676(gp)
    f824:	10800414 	ori	r2,r2,16
    f828:	d0a8e105 	stb	r2,-23676(gp)
    }
    break;
    f82c:	00000e06 	br	f868 <tcp_process+0xc20>
  default:
    break;
    f830:	0001883a 	nop
    f834:	00000d06 	br	f86c <tcp_process+0xc24>
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    break;
    f838:	0001883a 	nop
    f83c:	00000b06 	br	f86c <tcp_process+0xc24>
      }
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
      /* Looks like another copy of the SYN - retransmit our SYN-ACK */
      tcp_rexmit(pcb);
    }
    break;
    f840:	0001883a 	nop
    f844:	00000906 	br	f86c <tcp_process+0xc24>
    tcp_receive(pcb);
    if (recv_flags & TF_GOT_FIN) { /* passive close */
      tcp_ack_now(pcb);
      pcb->state = CLOSE_WAIT;
    }
    break;
    f848:	0001883a 	nop
    f84c:	00000706 	br	f86c <tcp_process+0xc24>
        pcb->state = CLOSING;
      }
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
      pcb->state = FIN_WAIT_2;
    }
    break;
    f850:	0001883a 	nop
    f854:	00000506 	br	f86c <tcp_process+0xc24>
      tcp_pcb_purge(pcb);
      TCP_RMV(&tcp_active_pcbs, pcb);
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
    }
    break;
    f858:	0001883a 	nop
    f85c:	00000306 	br	f86c <tcp_process+0xc24>
      tcp_pcb_purge(pcb);
      TCP_RMV(&tcp_active_pcbs, pcb);
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
    }
    break;
    f860:	0001883a 	nop
    f864:	00000106 	br	f86c <tcp_process+0xc24>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags |= TF_CLOSED;
    }
    break;
    f868:	0001883a 	nop
  default:
    break;
  }
  return ERR_OK;
    f86c:	0005883a 	mov	r2,zero
}
    f870:	e037883a 	mov	sp,fp
    f874:	dfc00117 	ldw	ra,4(sp)
    f878:	df000017 	ldw	fp,0(sp)
    f87c:	dec00204 	addi	sp,sp,8
    f880:	f800283a 	ret

0000f884 <tcp_oos_insert_segment>:
 *
 * Called from tcp_receive()
 */
static void
tcp_oos_insert_segment(struct tcp_seg *cseg, struct tcp_seg *next)
{
    f884:	defffb04 	addi	sp,sp,-20
    f888:	dfc00415 	stw	ra,16(sp)
    f88c:	df000315 	stw	fp,12(sp)
    f890:	df000304 	addi	fp,sp,12
    f894:	e13ffe15 	stw	r4,-8(fp)
    f898:	e17fff15 	stw	r5,-4(fp)
  struct tcp_seg *old_seg;

  if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
    f89c:	e0bffe17 	ldw	r2,-8(fp)
    f8a0:	10800417 	ldw	r2,16(r2)
    f8a4:	1080030b 	ldhu	r2,12(r2)
    f8a8:	10bfffcc 	andi	r2,r2,65535
    f8ac:	1004d23a 	srli	r2,r2,8
    f8b0:	10ffffcc 	andi	r3,r2,65535
    f8b4:	e0bffe17 	ldw	r2,-8(fp)
    f8b8:	10800417 	ldw	r2,16(r2)
    f8bc:	1080030b 	ldhu	r2,12(r2)
    f8c0:	10bfffcc 	andi	r2,r2,65535
    f8c4:	1004923a 	slli	r2,r2,8
    f8c8:	10bfffcc 	andi	r2,r2,65535
    f8cc:	1884b03a 	or	r2,r3,r2
    f8d0:	1080004c 	andi	r2,r2,1
    f8d4:	10003326 	beq	r2,zero,f9a4 <tcp_oos_insert_segment+0x120>
    /* received segment overlaps all following segments */
    tcp_segs_free(next);
    f8d8:	e13fff17 	ldw	r4,-4(fp)
    f8dc:	000ca380 	call	ca38 <tcp_segs_free>
    next = NULL;
    f8e0:	e03fff15 	stw	zero,-4(fp)
    f8e4:	00006606 	br	fa80 <tcp_oos_insert_segment+0x1fc>
       oos queue may have segments with FIN flag */
    while (next &&
           TCP_SEQ_GEQ((seqno + cseg->len),
                      (next->tcphdr->seqno + next->len))) {
      /* cseg with FIN already processed */
      if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
    f8e8:	e0bfff17 	ldw	r2,-4(fp)
    f8ec:	10800417 	ldw	r2,16(r2)
    f8f0:	1080030b 	ldhu	r2,12(r2)
    f8f4:	10bfffcc 	andi	r2,r2,65535
    f8f8:	1004d23a 	srli	r2,r2,8
    f8fc:	10ffffcc 	andi	r3,r2,65535
    f900:	e0bfff17 	ldw	r2,-4(fp)
    f904:	10800417 	ldw	r2,16(r2)
    f908:	1080030b 	ldhu	r2,12(r2)
    f90c:	10bfffcc 	andi	r2,r2,65535
    f910:	1004923a 	slli	r2,r2,8
    f914:	10bfffcc 	andi	r2,r2,65535
    f918:	1884b03a 	or	r2,r3,r2
    f91c:	1080004c 	andi	r2,r2,1
    f920:	10001926 	beq	r2,zero,f988 <tcp_oos_insert_segment+0x104>
        TCPH_FLAGS_SET(cseg->tcphdr, TCPH_FLAGS(cseg->tcphdr) | TCP_FIN);
    f924:	e0bffe17 	ldw	r2,-8(fp)
    f928:	10800417 	ldw	r2,16(r2)
    f92c:	e0fffe17 	ldw	r3,-8(fp)
    f930:	18c00417 	ldw	r3,16(r3)
    f934:	1900030b 	ldhu	r4,12(r3)
    f938:	00f03fc4 	movi	r3,-16129
    f93c:	20c6703a 	and	r3,r4,r3
    f940:	1809883a 	mov	r4,r3
    f944:	e0fffe17 	ldw	r3,-8(fp)
    f948:	18c00417 	ldw	r3,16(r3)
    f94c:	18c0030b 	ldhu	r3,12(r3)
    f950:	18ffffcc 	andi	r3,r3,65535
    f954:	1806d23a 	srli	r3,r3,8
    f958:	180b883a 	mov	r5,r3
    f95c:	e0fffe17 	ldw	r3,-8(fp)
    f960:	18c00417 	ldw	r3,16(r3)
    f964:	18c0030b 	ldhu	r3,12(r3)
    f968:	18ffffcc 	andi	r3,r3,65535
    f96c:	1806923a 	slli	r3,r3,8
    f970:	28c6b03a 	or	r3,r5,r3
    f974:	18c00f8c 	andi	r3,r3,62
    f978:	18c00054 	ori	r3,r3,1
    f97c:	1806923a 	slli	r3,r3,8
    f980:	20c6b03a 	or	r3,r4,r3
    f984:	10c0030d 	sth	r3,12(r2)
      }
      old_seg = next;
    f988:	e0bfff17 	ldw	r2,-4(fp)
    f98c:	e0bffd15 	stw	r2,-12(fp)
      next = next->next;
    f990:	e0bfff17 	ldw	r2,-4(fp)
    f994:	10800017 	ldw	r2,0(r2)
    f998:	e0bfff15 	stw	r2,-4(fp)
      tcp_seg_free(old_seg);
    f99c:	e13ffd17 	ldw	r4,-12(fp)
    f9a0:	000ca9c0 	call	ca9c <tcp_seg_free>
    next = NULL;
  }
  else {
    /* delete some following segments
       oos queue may have segments with FIN flag */
    while (next &&
    f9a4:	e0bfff17 	ldw	r2,-4(fp)
    f9a8:	10001226 	beq	r2,zero,f9f4 <tcp_oos_insert_segment+0x170>
           TCP_SEQ_GEQ((seqno + cseg->len),
    f9ac:	e0bffe17 	ldw	r2,-8(fp)
    f9b0:	1080030b 	ldhu	r2,12(r2)
    f9b4:	10ffffcc 	andi	r3,r2,65535
    f9b8:	d0a8de17 	ldw	r2,-23688(gp)
    f9bc:	1887883a 	add	r3,r3,r2
    f9c0:	e0bfff17 	ldw	r2,-4(fp)
    f9c4:	10800417 	ldw	r2,16(r2)
    f9c8:	1100010b 	ldhu	r4,4(r2)
    f9cc:	1080018b 	ldhu	r2,6(r2)
    f9d0:	1004943a 	slli	r2,r2,16
    f9d4:	1104b03a 	or	r2,r2,r4
    f9d8:	1009883a 	mov	r4,r2
    f9dc:	e0bfff17 	ldw	r2,-4(fp)
    f9e0:	1080030b 	ldhu	r2,12(r2)
    f9e4:	10bfffcc 	andi	r2,r2,65535
    f9e8:	2085883a 	add	r2,r4,r2
    f9ec:	1885c83a 	sub	r2,r3,r2
    next = NULL;
  }
  else {
    /* delete some following segments
       oos queue may have segments with FIN flag */
    while (next &&
    f9f0:	103fbd0e 	bge	r2,zero,f8e8 <tcp_oos_insert_segment+0x64>
      }
      old_seg = next;
      next = next->next;
      tcp_seg_free(old_seg);
    }
    if (next &&
    f9f4:	e0bfff17 	ldw	r2,-4(fp)
    f9f8:	10002126 	beq	r2,zero,fa80 <tcp_oos_insert_segment+0x1fc>
        TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
    f9fc:	e0bffe17 	ldw	r2,-8(fp)
    fa00:	1080030b 	ldhu	r2,12(r2)
    fa04:	10ffffcc 	andi	r3,r2,65535
    fa08:	d0a8de17 	ldw	r2,-23688(gp)
    fa0c:	1887883a 	add	r3,r3,r2
    fa10:	e0bfff17 	ldw	r2,-4(fp)
    fa14:	10800417 	ldw	r2,16(r2)
    fa18:	1100010b 	ldhu	r4,4(r2)
    fa1c:	1080018b 	ldhu	r2,6(r2)
    fa20:	1004943a 	slli	r2,r2,16
    fa24:	1104b03a 	or	r2,r2,r4
    fa28:	1885c83a 	sub	r2,r3,r2
      }
      old_seg = next;
      next = next->next;
      tcp_seg_free(old_seg);
    }
    if (next &&
    fa2c:	0080140e 	bge	zero,r2,fa80 <tcp_oos_insert_segment+0x1fc>
        TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
      /* We need to trim the incoming segment. */
      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
    fa30:	e0bfff17 	ldw	r2,-4(fp)
    fa34:	10800417 	ldw	r2,16(r2)
    fa38:	10c0010b 	ldhu	r3,4(r2)
    fa3c:	1080018b 	ldhu	r2,6(r2)
    fa40:	1004943a 	slli	r2,r2,16
    fa44:	10c4b03a 	or	r2,r2,r3
    fa48:	1007883a 	mov	r3,r2
    fa4c:	d0a8de17 	ldw	r2,-23688(gp)
    fa50:	1885c83a 	sub	r2,r3,r2
    fa54:	1007883a 	mov	r3,r2
    fa58:	e0bffe17 	ldw	r2,-8(fp)
    fa5c:	10c0030d 	sth	r3,12(r2)
      pbuf_realloc(cseg->p, cseg->len);
    fa60:	e0bffe17 	ldw	r2,-8(fp)
    fa64:	10c00117 	ldw	r3,4(r2)
    fa68:	e0bffe17 	ldw	r2,-8(fp)
    fa6c:	1080030b 	ldhu	r2,12(r2)
    fa70:	10bfffcc 	andi	r2,r2,65535
    fa74:	1809883a 	mov	r4,r3
    fa78:	100b883a 	mov	r5,r2
    fa7c:	0009d0c0 	call	9d0c <pbuf_realloc>
    }
  }
  cseg->next = next;
    fa80:	e0bffe17 	ldw	r2,-8(fp)
    fa84:	e0ffff17 	ldw	r3,-4(fp)
    fa88:	10c00015 	stw	r3,0(r2)
}
    fa8c:	e037883a 	mov	sp,fp
    fa90:	dfc00117 	ldw	ra,4(sp)
    fa94:	df000017 	ldw	fp,0(sp)
    fa98:	dec00204 	addi	sp,sp,8
    fa9c:	f800283a 	ret

0000faa0 <tcp_receive>:
 *
 * Called from tcp_process().
 */
static void
tcp_receive(struct tcp_pcb *pcb)
{
    faa0:	defff004 	addi	sp,sp,-64
    faa4:	dfc00f15 	stw	ra,60(sp)
    faa8:	df000e15 	stw	fp,56(sp)
    faac:	dc000d15 	stw	r16,52(sp)
    fab0:	df000d04 	addi	fp,sp,52
    fab4:	e13fff15 	stw	r4,-4(fp)
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  int found_dupack = 0;
    fab8:	e03ff815 	stw	zero,-32(fp)

  if (flags & TCP_ACK) {
    fabc:	d0a8e003 	ldbu	r2,-23680(gp)
    fac0:	10803fcc 	andi	r2,r2,255
    fac4:	1080040c 	andi	r2,r2,16
    fac8:	10028326 	beq	r2,zero,104d8 <tcp_receive+0xa38>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
    facc:	e0bfff17 	ldw	r2,-4(fp)
    fad0:	1080180b 	ldhu	r2,96(r2)
    fad4:	10ffffcc 	andi	r3,r2,65535
    fad8:	e0bfff17 	ldw	r2,-4(fp)
    fadc:	10801a17 	ldw	r2,104(r2)
    fae0:	1885883a 	add	r2,r3,r2
    fae4:	e0bffa15 	stw	r2,-24(fp)

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
    fae8:	e0bfff17 	ldw	r2,-4(fp)
    faec:	10c01917 	ldw	r3,100(r2)
    faf0:	d0a8de17 	ldw	r2,-23688(gp)
    faf4:	1885c83a 	sub	r2,r3,r2
    faf8:	10001416 	blt	r2,zero,fb4c <tcp_receive+0xac>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
    fafc:	e0bfff17 	ldw	r2,-4(fp)
    fb00:	10c01917 	ldw	r3,100(r2)
    fb04:	d0a8de17 	ldw	r2,-23688(gp)

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
    fb08:	1880051e 	bne	r3,r2,fb20 <tcp_receive+0x80>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
    fb0c:	e0bfff17 	ldw	r2,-4(fp)
    fb10:	10c01a17 	ldw	r3,104(r2)
    fb14:	d0a8df17 	ldw	r2,-23684(gp)
    fb18:	1885c83a 	sub	r2,r3,r2
    fb1c:	10000b16 	blt	r2,zero,fb4c <tcp_receive+0xac>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
    fb20:	e0bfff17 	ldw	r2,-4(fp)
    fb24:	10c01a17 	ldw	r3,104(r2)
    fb28:	d0a8df17 	ldw	r2,-23684(gp)
  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
    fb2c:	18801b1e 	bne	r3,r2,fb9c <tcp_receive+0xfc>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
    fb30:	d0a8dc17 	ldw	r2,-23696(gp)
    fb34:	1080038b 	ldhu	r2,14(r2)
    fb38:	e0ffff17 	ldw	r3,-4(fp)
    fb3c:	18c0180b 	ldhu	r3,96(r3)
    fb40:	10bfffcc 	andi	r2,r2,65535
    fb44:	18ffffcc 	andi	r3,r3,65535
    fb48:	1880142e 	bgeu	r3,r2,fb9c <tcp_receive+0xfc>
      pcb->snd_wnd = tcphdr->wnd;
    fb4c:	d0a8dc17 	ldw	r2,-23696(gp)
    fb50:	10c0038b 	ldhu	r3,14(r2)
    fb54:	e0bfff17 	ldw	r2,-4(fp)
    fb58:	10c0180d 	sth	r3,96(r2)
      pcb->snd_wl1 = seqno;
    fb5c:	d0e8de17 	ldw	r3,-23688(gp)
    fb60:	e0bfff17 	ldw	r2,-4(fp)
    fb64:	10c01915 	stw	r3,100(r2)
      pcb->snd_wl2 = ackno;
    fb68:	d0e8df17 	ldw	r3,-23684(gp)
    fb6c:	e0bfff17 	ldw	r2,-4(fp)
    fb70:	10c01a15 	stw	r3,104(r2)
      if (pcb->snd_wnd > 0 && pcb->persist_backoff > 0) {
    fb74:	e0bfff17 	ldw	r2,-4(fp)
    fb78:	1080180b 	ldhu	r2,96(r2)
    fb7c:	10bfffcc 	andi	r2,r2,65535
    fb80:	10000626 	beq	r2,zero,fb9c <tcp_receive+0xfc>
    fb84:	e0bfff17 	ldw	r2,-4(fp)
    fb88:	10802903 	ldbu	r2,164(r2)
    fb8c:	10803fcc 	andi	r2,r2,255
    fb90:	10000226 	beq	r2,zero,fb9c <tcp_receive+0xfc>
          pcb->persist_backoff = 0;
    fb94:	e0bfff17 	ldw	r2,-4(fp)
    fb98:	10002905 	stb	zero,164(r2)
     * If it only passes 1, should reset dupack counter
     *
     */

    /* Clause 1 */
    if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
    fb9c:	d0e8df17 	ldw	r3,-23684(gp)
    fba0:	e0bfff17 	ldw	r2,-4(fp)
    fba4:	10801417 	ldw	r2,80(r2)
    fba8:	1885c83a 	sub	r2,r3,r2
    fbac:	00804b16 	blt	zero,r2,fcdc <tcp_receive+0x23c>
      pcb->acked = 0;
    fbb0:	e0bfff17 	ldw	r2,-4(fp)
    fbb4:	10001c0d 	sth	zero,112(r2)
      /* Clause 2 */
      if (tcplen == 0) {
    fbb8:	d0a8e08b 	ldhu	r2,-23678(gp)
    fbbc:	10bfffcc 	andi	r2,r2,65535
    fbc0:	1000411e 	bne	r2,zero,fcc8 <tcp_receive+0x228>
        /* Clause 3 */
        if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge){
    fbc4:	e0bfff17 	ldw	r2,-4(fp)
    fbc8:	10c01a17 	ldw	r3,104(r2)
    fbcc:	e0bfff17 	ldw	r2,-4(fp)
    fbd0:	1080180b 	ldhu	r2,96(r2)
    fbd4:	10bfffcc 	andi	r2,r2,65535
    fbd8:	1887883a 	add	r3,r3,r2
    fbdc:	e0bffa17 	ldw	r2,-24(fp)
    fbe0:	1880391e 	bne	r3,r2,fcc8 <tcp_receive+0x228>
          /* Clause 4 */
          if (pcb->rtime >= 0) {
    fbe4:	e0bfff17 	ldw	r2,-4(fp)
    fbe8:	10800e8b 	ldhu	r2,58(r2)
    fbec:	10bfffcc 	andi	r2,r2,65535
    fbf0:	10a0001c 	xori	r2,r2,32768
    fbf4:	10a00004 	addi	r2,r2,-32768
    fbf8:	10003316 	blt	r2,zero,fcc8 <tcp_receive+0x228>
            /* Clause 5 */
            if (pcb->lastack == ackno) {
    fbfc:	e0bfff17 	ldw	r2,-4(fp)
    fc00:	10c01417 	ldw	r3,80(r2)
    fc04:	d0a8df17 	ldw	r2,-23684(gp)
    fc08:	18802f1e 	bne	r3,r2,fcc8 <tcp_receive+0x228>
              found_dupack = 1;
    fc0c:	00800044 	movi	r2,1
    fc10:	e0bff815 	stw	r2,-32(fp)
              if (pcb->dupacks + 1 > pcb->dupacks)
    fc14:	e0bfff17 	ldw	r2,-4(fp)
    fc18:	10801503 	ldbu	r2,84(r2)
    fc1c:	10803fcc 	andi	r2,r2,255
    fc20:	10800044 	addi	r2,r2,1
    fc24:	e0ffff17 	ldw	r3,-4(fp)
    fc28:	18c01503 	ldbu	r3,84(r3)
    fc2c:	18c03fcc 	andi	r3,r3,255
    fc30:	1880060e 	bge	r3,r2,fc4c <tcp_receive+0x1ac>
                ++pcb->dupacks;
    fc34:	e0bfff17 	ldw	r2,-4(fp)
    fc38:	10801503 	ldbu	r2,84(r2)
    fc3c:	10800044 	addi	r2,r2,1
    fc40:	1007883a 	mov	r3,r2
    fc44:	e0bfff17 	ldw	r2,-4(fp)
    fc48:	10c01505 	stb	r3,84(r2)
              if (pcb->dupacks > 3) {
    fc4c:	e0bfff17 	ldw	r2,-4(fp)
    fc50:	10801503 	ldbu	r2,84(r2)
    fc54:	10803fcc 	andi	r2,r2,255
    fc58:	10800130 	cmpltui	r2,r2,4
    fc5c:	1000131e 	bne	r2,zero,fcac <tcp_receive+0x20c>
                /* Inflate the congestion window, but not if it means that
                   the value overflows. */
                if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
    fc60:	e0bfff17 	ldw	r2,-4(fp)
    fc64:	10c0158b 	ldhu	r3,86(r2)
    fc68:	e0bfff17 	ldw	r2,-4(fp)
    fc6c:	10800f0b 	ldhu	r2,60(r2)
    fc70:	1885883a 	add	r2,r3,r2
    fc74:	e0ffff17 	ldw	r3,-4(fp)
    fc78:	18c0158b 	ldhu	r3,86(r3)
    fc7c:	10bfffcc 	andi	r2,r2,65535
    fc80:	18ffffcc 	andi	r3,r3,65535
    fc84:	1880102e 	bgeu	r3,r2,fcc8 <tcp_receive+0x228>
                  pcb->cwnd += pcb->mss;
    fc88:	e0bfff17 	ldw	r2,-4(fp)
    fc8c:	10c0158b 	ldhu	r3,86(r2)
    fc90:	e0bfff17 	ldw	r2,-4(fp)
    fc94:	10800f0b 	ldhu	r2,60(r2)
    fc98:	1885883a 	add	r2,r3,r2
    fc9c:	1007883a 	mov	r3,r2
    fca0:	e0bfff17 	ldw	r2,-4(fp)
    fca4:	10c0158d 	sth	r3,86(r2)
    fca8:	00000706 	br	fcc8 <tcp_receive+0x228>
                }
              } else if (pcb->dupacks == 3) {
    fcac:	e0bfff17 	ldw	r2,-4(fp)
    fcb0:	10801503 	ldbu	r2,84(r2)
    fcb4:	10803fcc 	andi	r2,r2,255
    fcb8:	108000d8 	cmpnei	r2,r2,3
    fcbc:	1000021e 	bne	r2,zero,fcc8 <tcp_receive+0x228>
                /* Do fast retransmit */
                tcp_rexmit_fast(pcb);
    fcc0:	e13fff17 	ldw	r4,-4(fp)
    fcc4:	0013c580 	call	13c58 <tcp_rexmit_fast>
          }
        }
      }
      /* If Clause (1) or more is true, but not a duplicate ack, reset
       * count of consecutive duplicate acks */
      if (!found_dupack) {
    fcc8:	e0bff817 	ldw	r2,-32(fp)
    fccc:	1001731e 	bne	r2,zero,1029c <tcp_receive+0x7fc>
        pcb->dupacks = 0;
    fcd0:	e0bfff17 	ldw	r2,-4(fp)
    fcd4:	10001505 	stb	zero,84(r2)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
    fcd8:	00017006 	br	1029c <tcp_receive+0x7fc>
      /* If Clause (1) or more is true, but not a duplicate ack, reset
       * count of consecutive duplicate acks */
      if (!found_dupack) {
        pcb->dupacks = 0;
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)){
    fcdc:	e0bfff17 	ldw	r2,-4(fp)
    fce0:	10801417 	ldw	r2,80(r2)
    fce4:	0086303a 	nor	r3,zero,r2
    fce8:	d0a8df17 	ldw	r2,-23684(gp)
    fcec:	1885883a 	add	r2,r3,r2
    fcf0:	10011316 	blt	r2,zero,10140 <tcp_receive+0x6a0>
    fcf4:	d0e8df17 	ldw	r3,-23684(gp)
    fcf8:	e0bfff17 	ldw	r2,-4(fp)
    fcfc:	10801717 	ldw	r2,92(r2)
    fd00:	1885c83a 	sub	r2,r3,r2
    fd04:	00810e16 	blt	zero,r2,10140 <tcp_receive+0x6a0>
      /* We come here when the ACK acknowledges new data. */

      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
    fd08:	e0bfff17 	ldw	r2,-4(fp)
    fd0c:	10800983 	ldbu	r2,38(r2)
    fd10:	10803fcc 	andi	r2,r2,255
    fd14:	1080010c 	andi	r2,r2,4
    fd18:	10000b26 	beq	r2,zero,fd48 <tcp_receive+0x2a8>
        pcb->flags &= ~TF_INFR;
    fd1c:	e0bfff17 	ldw	r2,-4(fp)
    fd20:	10c00983 	ldbu	r3,38(r2)
    fd24:	00bffec4 	movi	r2,-5
    fd28:	1884703a 	and	r2,r3,r2
    fd2c:	1007883a 	mov	r3,r2
    fd30:	e0bfff17 	ldw	r2,-4(fp)
    fd34:	10c00985 	stb	r3,38(r2)
        pcb->cwnd = pcb->ssthresh;
    fd38:	e0bfff17 	ldw	r2,-4(fp)
    fd3c:	10c0160b 	ldhu	r3,88(r2)
    fd40:	e0bfff17 	ldw	r2,-4(fp)
    fd44:	10c0158d 	sth	r3,86(r2)
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
    fd48:	e0bfff17 	ldw	r2,-4(fp)
    fd4c:	10001385 	stb	zero,78(r2)

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
    fd50:	e0bfff17 	ldw	r2,-4(fp)
    fd54:	1080120b 	ldhu	r2,72(r2)
    fd58:	10bfffcc 	andi	r2,r2,65535
    fd5c:	10a0001c 	xori	r2,r2,32768
    fd60:	10a00004 	addi	r2,r2,-32768
    fd64:	1005d0fa 	srai	r2,r2,3
    fd68:	1007883a 	mov	r3,r2
    fd6c:	e0bfff17 	ldw	r2,-4(fp)
    fd70:	1080128b 	ldhu	r2,74(r2)
    fd74:	1885883a 	add	r2,r3,r2
    fd78:	1007883a 	mov	r3,r2
    fd7c:	e0bfff17 	ldw	r2,-4(fp)
    fd80:	10c0130d 	sth	r3,76(r2)

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
    fd84:	d0a8df17 	ldw	r2,-23684(gp)
    fd88:	1007883a 	mov	r3,r2
    fd8c:	e0bfff17 	ldw	r2,-4(fp)
    fd90:	10801417 	ldw	r2,80(r2)
    fd94:	1885c83a 	sub	r2,r3,r2
    fd98:	1007883a 	mov	r3,r2
    fd9c:	e0bfff17 	ldw	r2,-4(fp)
    fda0:	10c01c0d 	sth	r3,112(r2)

      pcb->snd_buf += pcb->acked;
    fda4:	e0bfff17 	ldw	r2,-4(fp)
    fda8:	10c01c8b 	ldhu	r3,114(r2)
    fdac:	e0bfff17 	ldw	r2,-4(fp)
    fdb0:	10801c0b 	ldhu	r2,112(r2)
    fdb4:	1885883a 	add	r2,r3,r2
    fdb8:	1007883a 	mov	r3,r2
    fdbc:	e0bfff17 	ldw	r2,-4(fp)
    fdc0:	10c01c8d 	sth	r3,114(r2)

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
    fdc4:	e0bfff17 	ldw	r2,-4(fp)
    fdc8:	10001505 	stb	zero,84(r2)
      pcb->lastack = ackno;
    fdcc:	d0e8df17 	ldw	r3,-23684(gp)
    fdd0:	e0bfff17 	ldw	r2,-4(fp)
    fdd4:	10c01415 	stw	r3,80(r2)

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
    fdd8:	e0bfff17 	ldw	r2,-4(fp)
    fddc:	10800417 	ldw	r2,16(r2)
    fde0:	10800130 	cmpltui	r2,r2,4
    fde4:	1000861e 	bne	r2,zero,10000 <tcp_receive+0x560>
        if (pcb->cwnd < pcb->ssthresh) {
    fde8:	e0bfff17 	ldw	r2,-4(fp)
    fdec:	10c0158b 	ldhu	r3,86(r2)
    fdf0:	e0bfff17 	ldw	r2,-4(fp)
    fdf4:	1080160b 	ldhu	r2,88(r2)
    fdf8:	18ffffcc 	andi	r3,r3,65535
    fdfc:	10bfffcc 	andi	r2,r2,65535
    fe00:	1880132e 	bgeu	r3,r2,fe50 <tcp_receive+0x3b0>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
    fe04:	e0bfff17 	ldw	r2,-4(fp)
    fe08:	10c0158b 	ldhu	r3,86(r2)
    fe0c:	e0bfff17 	ldw	r2,-4(fp)
    fe10:	10800f0b 	ldhu	r2,60(r2)
    fe14:	1885883a 	add	r2,r3,r2
    fe18:	e0ffff17 	ldw	r3,-4(fp)
    fe1c:	18c0158b 	ldhu	r3,86(r3)
    fe20:	10bfffcc 	andi	r2,r2,65535
    fe24:	18ffffcc 	andi	r3,r3,65535
    fe28:	1880752e 	bgeu	r3,r2,10000 <tcp_receive+0x560>
            pcb->cwnd += pcb->mss;
    fe2c:	e0bfff17 	ldw	r2,-4(fp)
    fe30:	10c0158b 	ldhu	r3,86(r2)
    fe34:	e0bfff17 	ldw	r2,-4(fp)
    fe38:	10800f0b 	ldhu	r2,60(r2)
    fe3c:	1885883a 	add	r2,r3,r2
    fe40:	1007883a 	mov	r3,r2
    fe44:	e0bfff17 	ldw	r2,-4(fp)
    fe48:	10c0158d 	sth	r3,86(r2)
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
    fe4c:	00006c06 	br	10000 <tcp_receive+0x560>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
            pcb->cwnd += pcb->mss;
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
        } else {
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
    fe50:	e0bfff17 	ldw	r2,-4(fp)
    fe54:	10c0158b 	ldhu	r3,86(r2)
    fe58:	e0bfff17 	ldw	r2,-4(fp)
    fe5c:	10800f0b 	ldhu	r2,60(r2)
    fe60:	113fffcc 	andi	r4,r2,65535
    fe64:	e0bfff17 	ldw	r2,-4(fp)
    fe68:	10800f0b 	ldhu	r2,60(r2)
    fe6c:	10bfffcc 	andi	r2,r2,65535
    fe70:	2089383a 	mul	r4,r4,r2
    fe74:	e0bfff17 	ldw	r2,-4(fp)
    fe78:	1080158b 	ldhu	r2,86(r2)
    fe7c:	10bfffcc 	andi	r2,r2,65535
    fe80:	2085283a 	div	r2,r4,r2
    fe84:	1885883a 	add	r2,r3,r2
    fe88:	e0bffb0d 	sth	r2,-20(fp)
          if (new_cwnd > pcb->cwnd) {
    fe8c:	e0bfff17 	ldw	r2,-4(fp)
    fe90:	1080158b 	ldhu	r2,86(r2)
    fe94:	10ffffcc 	andi	r3,r2,65535
    fe98:	e0bffb0b 	ldhu	r2,-20(fp)
    fe9c:	1880582e 	bgeu	r3,r2,10000 <tcp_receive+0x560>
            pcb->cwnd = new_cwnd;
    fea0:	e0bfff17 	ldw	r2,-4(fp)
    fea4:	e0fffb0b 	ldhu	r3,-20(fp)
    fea8:	10c0158d 	sth	r3,86(r2)
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
    feac:	00005406 	br	10000 <tcp_receive+0x560>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
    feb0:	e0bfff17 	ldw	r2,-4(fp)
    feb4:	10801f17 	ldw	r2,124(r2)
    feb8:	e0bff315 	stw	r2,-52(fp)
        pcb->unacked = pcb->unacked->next;
    febc:	e0bfff17 	ldw	r2,-4(fp)
    fec0:	10801f17 	ldw	r2,124(r2)
    fec4:	10c00017 	ldw	r3,0(r2)
    fec8:	e0bfff17 	ldw	r2,-4(fp)
    fecc:	10c01f15 	stw	r3,124(r2)

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
    fed0:	e0bfff17 	ldw	r2,-4(fp)
    fed4:	14001d0b 	ldhu	r16,116(r2)
    fed8:	e0bff317 	ldw	r2,-52(fp)
    fedc:	10800117 	ldw	r2,4(r2)
    fee0:	1009883a 	mov	r4,r2
    fee4:	000a3540 	call	a354 <pbuf_clen>
    fee8:	10803fcc 	andi	r2,r2,255
    feec:	80ffffcc 	andi	r3,r16,65535
    fef0:	10bfffcc 	andi	r2,r2,65535
    fef4:	1880092e 	bgeu	r3,r2,ff1c <tcp_receive+0x47c>
    fef8:	010000f4 	movhi	r4,3
    fefc:	213db804 	addi	r4,r4,-2336
    ff00:	014000f4 	movhi	r5,3
    ff04:	297e2e04 	addi	r5,r5,-1864
    ff08:	0180ec44 	movi	r6,945
    ff0c:	01c000f4 	movhi	r7,3
    ff10:	39fdcc04 	addi	r7,r7,-2256
    ff14:	00170680 	call	17068 <printf>
    ff18:	003fff06 	br	ff18 <tcp_receive+0x478>
        /* Prevent ACK for FIN to generate a sent event */
        if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
    ff1c:	e0bfff17 	ldw	r2,-4(fp)
    ff20:	10801c0b 	ldhu	r2,112(r2)
    ff24:	10bfffcc 	andi	r2,r2,65535
    ff28:	10001526 	beq	r2,zero,ff80 <tcp_receive+0x4e0>
    ff2c:	e0bff317 	ldw	r2,-52(fp)
    ff30:	10800417 	ldw	r2,16(r2)
    ff34:	1080030b 	ldhu	r2,12(r2)
    ff38:	10bfffcc 	andi	r2,r2,65535
    ff3c:	1004d23a 	srli	r2,r2,8
    ff40:	10ffffcc 	andi	r3,r2,65535
    ff44:	e0bff317 	ldw	r2,-52(fp)
    ff48:	10800417 	ldw	r2,16(r2)
    ff4c:	1080030b 	ldhu	r2,12(r2)
    ff50:	10bfffcc 	andi	r2,r2,65535
    ff54:	1004923a 	slli	r2,r2,8
    ff58:	10bfffcc 	andi	r2,r2,65535
    ff5c:	1884b03a 	or	r2,r3,r2
    ff60:	1080004c 	andi	r2,r2,1
    ff64:	10000626 	beq	r2,zero,ff80 <tcp_receive+0x4e0>
          pcb->acked--;
    ff68:	e0bfff17 	ldw	r2,-4(fp)
    ff6c:	10801c0b 	ldhu	r2,112(r2)
    ff70:	10bfffc4 	addi	r2,r2,-1
    ff74:	1007883a 	mov	r3,r2
    ff78:	e0bfff17 	ldw	r2,-4(fp)
    ff7c:	10c01c0d 	sth	r3,112(r2)
        }

        pcb->snd_queuelen -= pbuf_clen(next->p);
    ff80:	e0bfff17 	ldw	r2,-4(fp)
    ff84:	14001d0b 	ldhu	r16,116(r2)
    ff88:	e0bff317 	ldw	r2,-52(fp)
    ff8c:	10800117 	ldw	r2,4(r2)
    ff90:	1009883a 	mov	r4,r2
    ff94:	000a3540 	call	a354 <pbuf_clen>
    ff98:	10803fcc 	andi	r2,r2,255
    ff9c:	8085c83a 	sub	r2,r16,r2
    ffa0:	1007883a 	mov	r3,r2
    ffa4:	e0bfff17 	ldw	r2,-4(fp)
    ffa8:	10c01d0d 	sth	r3,116(r2)
        tcp_seg_free(next);
    ffac:	e13ff317 	ldw	r4,-52(fp)
    ffb0:	000ca9c0 	call	ca9c <tcp_seg_free>

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
        if (pcb->snd_queuelen != 0) {
    ffb4:	e0bfff17 	ldw	r2,-4(fp)
    ffb8:	10801d0b 	ldhu	r2,116(r2)
    ffbc:	10bfffcc 	andi	r2,r2,65535
    ffc0:	10001026 	beq	r2,zero,10004 <tcp_receive+0x564>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
    ffc4:	e0bfff17 	ldw	r2,-4(fp)
    ffc8:	10801f17 	ldw	r2,124(r2)
    ffcc:	10000d1e 	bne	r2,zero,10004 <tcp_receive+0x564>
    ffd0:	e0bfff17 	ldw	r2,-4(fp)
    ffd4:	10801e17 	ldw	r2,120(r2)
    ffd8:	10000a1e 	bne	r2,zero,10004 <tcp_receive+0x564>
    ffdc:	010000f4 	movhi	r4,3
    ffe0:	213db804 	addi	r4,r4,-2336
    ffe4:	014000f4 	movhi	r5,3
    ffe8:	297e3804 	addi	r5,r5,-1824
    ffec:	0180ef44 	movi	r6,957
    fff0:	01c000f4 	movhi	r7,3
    fff4:	39fdcc04 	addi	r7,r7,-2256
    fff8:	00170680 	call	17068 <printf>
    fffc:	003fff06 	br	fffc <tcp_receive+0x55c>
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
   10000:	0001883a 	nop
   10004:	e0bfff17 	ldw	r2,-4(fp)
   10008:	10801f17 	ldw	r2,124(r2)
   1000c:	10004026 	beq	r2,zero,10110 <tcp_receive+0x670>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
   10010:	e0bfff17 	ldw	r2,-4(fp)
   10014:	10801f17 	ldw	r2,124(r2)
   10018:	10800417 	ldw	r2,16(r2)
   1001c:	10c0010b 	ldhu	r3,4(r2)
   10020:	1080018b 	ldhu	r2,6(r2)
   10024:	1004943a 	slli	r2,r2,16
   10028:	10c4b03a 	or	r2,r2,r3
   1002c:	1006d63a 	srli	r3,r2,24
   10030:	e0bfff17 	ldw	r2,-4(fp)
   10034:	10801f17 	ldw	r2,124(r2)
   10038:	10800417 	ldw	r2,16(r2)
   1003c:	1100010b 	ldhu	r4,4(r2)
   10040:	1080018b 	ldhu	r2,6(r2)
   10044:	1004943a 	slli	r2,r2,16
   10048:	1104b03a 	or	r2,r2,r4
   1004c:	1004d23a 	srli	r2,r2,8
   10050:	10bfc00c 	andi	r2,r2,65280
   10054:	1886b03a 	or	r3,r3,r2
   10058:	e0bfff17 	ldw	r2,-4(fp)
   1005c:	10801f17 	ldw	r2,124(r2)
   10060:	10800417 	ldw	r2,16(r2)
   10064:	1100010b 	ldhu	r4,4(r2)
   10068:	1080018b 	ldhu	r2,6(r2)
   1006c:	1004943a 	slli	r2,r2,16
   10070:	1104b03a 	or	r2,r2,r4
   10074:	10bfc00c 	andi	r2,r2,65280
   10078:	1004923a 	slli	r2,r2,8
   1007c:	1886b03a 	or	r3,r3,r2
   10080:	e0bfff17 	ldw	r2,-4(fp)
   10084:	10801f17 	ldw	r2,124(r2)
   10088:	10800417 	ldw	r2,16(r2)
   1008c:	1100010b 	ldhu	r4,4(r2)
   10090:	1080018b 	ldhu	r2,6(r2)
   10094:	1004943a 	slli	r2,r2,16
   10098:	1104b03a 	or	r2,r2,r4
   1009c:	1004963a 	slli	r2,r2,24
   100a0:	1886b03a 	or	r3,r3,r2
   100a4:	e0bfff17 	ldw	r2,-4(fp)
   100a8:	10801f17 	ldw	r2,124(r2)
   100ac:	1080030b 	ldhu	r2,12(r2)
   100b0:	113fffcc 	andi	r4,r2,65535
   100b4:	e0bfff17 	ldw	r2,-4(fp)
   100b8:	10801f17 	ldw	r2,124(r2)
   100bc:	10800417 	ldw	r2,16(r2)
   100c0:	1080030b 	ldhu	r2,12(r2)
   100c4:	10bfffcc 	andi	r2,r2,65535
   100c8:	1004d23a 	srli	r2,r2,8
   100cc:	117fffcc 	andi	r5,r2,65535
   100d0:	e0bfff17 	ldw	r2,-4(fp)
   100d4:	10801f17 	ldw	r2,124(r2)
   100d8:	10800417 	ldw	r2,16(r2)
   100dc:	1080030b 	ldhu	r2,12(r2)
   100e0:	10bfffcc 	andi	r2,r2,65535
   100e4:	1004923a 	slli	r2,r2,8
   100e8:	10bfffcc 	andi	r2,r2,65535
   100ec:	2884b03a 	or	r2,r5,r2
   100f0:	108000cc 	andi	r2,r2,3
   100f4:	1004c03a 	cmpne	r2,r2,zero
   100f8:	10803fcc 	andi	r2,r2,255
   100fc:	2085883a 	add	r2,r4,r2
   10100:	1887883a 	add	r3,r3,r2
   10104:	d0a8df17 	ldw	r2,-23684(gp)
   10108:	1885c83a 	sub	r2,r3,r2
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
   1010c:	00bf680e 	bge	zero,r2,feb0 <tcp_receive+0x410>
        }
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
   10110:	e0bfff17 	ldw	r2,-4(fp)
   10114:	10801f17 	ldw	r2,124(r2)
   10118:	1000041e 	bne	r2,zero,1012c <tcp_receive+0x68c>
        pcb->rtime = -1;
   1011c:	e0bfff17 	ldw	r2,-4(fp)
   10120:	00ffffc4 	movi	r3,-1
   10124:	10c00e8d 	sth	r3,58(r2)
   10128:	00000206 	br	10134 <tcp_receive+0x694>
      else
        pcb->rtime = 0;
   1012c:	e0bfff17 	ldw	r2,-4(fp)
   10130:	10000e8d 	sth	zero,58(r2)

      pcb->polltmr = 0;
   10134:	e0bfff17 	ldw	r2,-4(fp)
   10138:	10000e05 	stb	zero,56(r2)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
   1013c:	00005706 	br	1029c <tcp_receive+0x7fc>
        pcb->rtime = 0;

      pcb->polltmr = 0;
    } else {
      /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
      pcb->acked = 0;
   10140:	e0bfff17 	ldw	r2,-4(fp)
   10144:	10001c0d 	sth	zero,112(r2)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
   10148:	00005406 	br	1029c <tcp_receive+0x7fc>
                           TCP_TCPLEN(pcb->unsent), pcb->snd_nxt)) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
   1014c:	e0bfff17 	ldw	r2,-4(fp)
   10150:	10801e17 	ldw	r2,120(r2)
   10154:	e0bff315 	stw	r2,-52(fp)
      pcb->unsent = pcb->unsent->next;
   10158:	e0bfff17 	ldw	r2,-4(fp)
   1015c:	10801e17 	ldw	r2,120(r2)
   10160:	10c00017 	ldw	r3,0(r2)
   10164:	e0bfff17 	ldw	r2,-4(fp)
   10168:	10c01e15 	stw	r3,120(r2)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
   1016c:	e0bfff17 	ldw	r2,-4(fp)
   10170:	14001d0b 	ldhu	r16,116(r2)
   10174:	e0bff317 	ldw	r2,-52(fp)
   10178:	10800117 	ldw	r2,4(r2)
   1017c:	1009883a 	mov	r4,r2
   10180:	000a3540 	call	a354 <pbuf_clen>
   10184:	10803fcc 	andi	r2,r2,255
   10188:	80ffffcc 	andi	r3,r16,65535
   1018c:	10bfffcc 	andi	r2,r2,65535
   10190:	1880092e 	bgeu	r3,r2,101b8 <tcp_receive+0x718>
   10194:	010000f4 	movhi	r4,3
   10198:	213db804 	addi	r4,r4,-2336
   1019c:	014000f4 	movhi	r5,3
   101a0:	297e2e04 	addi	r5,r5,-1864
   101a4:	0180f784 	movi	r6,990
   101a8:	01c000f4 	movhi	r7,3
   101ac:	39fdcc04 	addi	r7,r7,-2256
   101b0:	00170680 	call	17068 <printf>
   101b4:	003fff06 	br	101b4 <tcp_receive+0x714>
      /* Prevent ACK for FIN to generate a sent event */
      if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
   101b8:	e0bfff17 	ldw	r2,-4(fp)
   101bc:	10801c0b 	ldhu	r2,112(r2)
   101c0:	10bfffcc 	andi	r2,r2,65535
   101c4:	10001526 	beq	r2,zero,1021c <tcp_receive+0x77c>
   101c8:	e0bff317 	ldw	r2,-52(fp)
   101cc:	10800417 	ldw	r2,16(r2)
   101d0:	1080030b 	ldhu	r2,12(r2)
   101d4:	10bfffcc 	andi	r2,r2,65535
   101d8:	1004d23a 	srli	r2,r2,8
   101dc:	10ffffcc 	andi	r3,r2,65535
   101e0:	e0bff317 	ldw	r2,-52(fp)
   101e4:	10800417 	ldw	r2,16(r2)
   101e8:	1080030b 	ldhu	r2,12(r2)
   101ec:	10bfffcc 	andi	r2,r2,65535
   101f0:	1004923a 	slli	r2,r2,8
   101f4:	10bfffcc 	andi	r2,r2,65535
   101f8:	1884b03a 	or	r2,r3,r2
   101fc:	1080004c 	andi	r2,r2,1
   10200:	10000626 	beq	r2,zero,1021c <tcp_receive+0x77c>
        pcb->acked--;
   10204:	e0bfff17 	ldw	r2,-4(fp)
   10208:	10801c0b 	ldhu	r2,112(r2)
   1020c:	10bfffc4 	addi	r2,r2,-1
   10210:	1007883a 	mov	r3,r2
   10214:	e0bfff17 	ldw	r2,-4(fp)
   10218:	10c01c0d 	sth	r3,112(r2)
      }
      pcb->snd_queuelen -= pbuf_clen(next->p);
   1021c:	e0bfff17 	ldw	r2,-4(fp)
   10220:	14001d0b 	ldhu	r16,116(r2)
   10224:	e0bff317 	ldw	r2,-52(fp)
   10228:	10800117 	ldw	r2,4(r2)
   1022c:	1009883a 	mov	r4,r2
   10230:	000a3540 	call	a354 <pbuf_clen>
   10234:	10803fcc 	andi	r2,r2,255
   10238:	8085c83a 	sub	r2,r16,r2
   1023c:	1007883a 	mov	r3,r2
   10240:	e0bfff17 	ldw	r2,-4(fp)
   10244:	10c01d0d 	sth	r3,116(r2)
      tcp_seg_free(next);
   10248:	e13ff317 	ldw	r4,-52(fp)
   1024c:	000ca9c0 	call	ca9c <tcp_seg_free>
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
      if (pcb->snd_queuelen != 0) {
   10250:	e0bfff17 	ldw	r2,-4(fp)
   10254:	10801d0b 	ldhu	r2,116(r2)
   10258:	10bfffcc 	andi	r2,r2,65535
   1025c:	10001026 	beq	r2,zero,102a0 <tcp_receive+0x800>
        LWIP_ASSERT("tcp_receive: valid queue length",
   10260:	e0bfff17 	ldw	r2,-4(fp)
   10264:	10801f17 	ldw	r2,124(r2)
   10268:	10000d1e 	bne	r2,zero,102a0 <tcp_receive+0x800>
   1026c:	e0bfff17 	ldw	r2,-4(fp)
   10270:	10801e17 	ldw	r2,120(r2)
   10274:	10000a1e 	bne	r2,zero,102a0 <tcp_receive+0x800>
   10278:	010000f4 	movhi	r4,3
   1027c:	213db804 	addi	r4,r4,-2336
   10280:	014000f4 	movhi	r5,3
   10284:	297e3804 	addi	r5,r5,-1824
   10288:	0180fa04 	movi	r6,1000
   1028c:	01c000f4 	movhi	r7,3
   10290:	39fdcc04 	addi	r7,r7,-2256
   10294:	00170680 	call	17068 <printf>
   10298:	003fff06 	br	10298 <tcp_receive+0x7f8>
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
   1029c:	0001883a 	nop
   102a0:	e0bfff17 	ldw	r2,-4(fp)
   102a4:	10801e17 	ldw	r2,120(r2)
   102a8:	10004526 	beq	r2,zero,103c0 <tcp_receive+0x920>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
   102ac:	d0e8df17 	ldw	r3,-23684(gp)
   102b0:	e0bfff17 	ldw	r2,-4(fp)
   102b4:	10801e17 	ldw	r2,120(r2)
   102b8:	10800417 	ldw	r2,16(r2)
   102bc:	1100010b 	ldhu	r4,4(r2)
   102c0:	1080018b 	ldhu	r2,6(r2)
   102c4:	1004943a 	slli	r2,r2,16
   102c8:	1104b03a 	or	r2,r2,r4
   102cc:	1008d63a 	srli	r4,r2,24
   102d0:	e0bfff17 	ldw	r2,-4(fp)
   102d4:	10801e17 	ldw	r2,120(r2)
   102d8:	10800417 	ldw	r2,16(r2)
   102dc:	1140010b 	ldhu	r5,4(r2)
   102e0:	1080018b 	ldhu	r2,6(r2)
   102e4:	1004943a 	slli	r2,r2,16
   102e8:	1144b03a 	or	r2,r2,r5
   102ec:	1004d23a 	srli	r2,r2,8
   102f0:	10bfc00c 	andi	r2,r2,65280
   102f4:	2088b03a 	or	r4,r4,r2
   102f8:	e0bfff17 	ldw	r2,-4(fp)
   102fc:	10801e17 	ldw	r2,120(r2)
   10300:	10800417 	ldw	r2,16(r2)
   10304:	1140010b 	ldhu	r5,4(r2)
   10308:	1080018b 	ldhu	r2,6(r2)
   1030c:	1004943a 	slli	r2,r2,16
   10310:	1144b03a 	or	r2,r2,r5
   10314:	10bfc00c 	andi	r2,r2,65280
   10318:	1004923a 	slli	r2,r2,8
   1031c:	2088b03a 	or	r4,r4,r2
   10320:	e0bfff17 	ldw	r2,-4(fp)
   10324:	10801e17 	ldw	r2,120(r2)
   10328:	10800417 	ldw	r2,16(r2)
   1032c:	1140010b 	ldhu	r5,4(r2)
   10330:	1080018b 	ldhu	r2,6(r2)
   10334:	1004943a 	slli	r2,r2,16
   10338:	1144b03a 	or	r2,r2,r5
   1033c:	1004963a 	slli	r2,r2,24
   10340:	2088b03a 	or	r4,r4,r2
   10344:	e0bfff17 	ldw	r2,-4(fp)
   10348:	10801e17 	ldw	r2,120(r2)
   1034c:	1080030b 	ldhu	r2,12(r2)
   10350:	117fffcc 	andi	r5,r2,65535
   10354:	e0bfff17 	ldw	r2,-4(fp)
   10358:	10801e17 	ldw	r2,120(r2)
   1035c:	10800417 	ldw	r2,16(r2)
   10360:	1080030b 	ldhu	r2,12(r2)
   10364:	10bfffcc 	andi	r2,r2,65535
   10368:	1004d23a 	srli	r2,r2,8
   1036c:	11bfffcc 	andi	r6,r2,65535
   10370:	e0bfff17 	ldw	r2,-4(fp)
   10374:	10801e17 	ldw	r2,120(r2)
   10378:	10800417 	ldw	r2,16(r2)
   1037c:	1080030b 	ldhu	r2,12(r2)
   10380:	10bfffcc 	andi	r2,r2,65535
   10384:	1004923a 	slli	r2,r2,8
   10388:	10bfffcc 	andi	r2,r2,65535
   1038c:	3084b03a 	or	r2,r6,r2
   10390:	108000cc 	andi	r2,r2,3
   10394:	1004c03a 	cmpne	r2,r2,zero
   10398:	10803fcc 	andi	r2,r2,255
   1039c:	2885883a 	add	r2,r5,r2
   103a0:	2085883a 	add	r2,r4,r2
   103a4:	1885c83a 	sub	r2,r3,r2
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
   103a8:	10000516 	blt	r2,zero,103c0 <tcp_receive+0x920>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
   103ac:	d0e8df17 	ldw	r3,-23684(gp)
   103b0:	e0bfff17 	ldw	r2,-4(fp)
   103b4:	10801717 	ldw	r2,92(r2)
   103b8:	1885c83a 	sub	r2,r3,r2
   103bc:	00bf630e 	bge	zero,r2,1014c <tcp_receive+0x6ac>
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
   103c0:	e0bfff17 	ldw	r2,-4(fp)
   103c4:	10801017 	ldw	r2,64(r2)
   103c8:	10004326 	beq	r2,zero,104d8 <tcp_receive+0xa38>
   103cc:	e0bfff17 	ldw	r2,-4(fp)
   103d0:	10c01117 	ldw	r3,68(r2)
   103d4:	d0a8df17 	ldw	r2,-23684(gp)
   103d8:	1885c83a 	sub	r2,r3,r2
   103dc:	10003e0e 	bge	r2,zero,104d8 <tcp_receive+0xa38>
      /* diff between this shouldn't exceed 32K since this are tcp timer ticks
         and a round-trip shouldn't be that long... */
      m = (s16_t)(tcp_ticks - pcb->rttest);
   103e0:	008000f4 	movhi	r2,3
   103e4:	1099c304 	addi	r2,r2,26380
   103e8:	10800017 	ldw	r2,0(r2)
   103ec:	1007883a 	mov	r3,r2
   103f0:	e0bfff17 	ldw	r2,-4(fp)
   103f4:	10801017 	ldw	r2,64(r2)
   103f8:	1885c83a 	sub	r2,r3,r2
   103fc:	e0bff70d 	sth	r2,-36(fp)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
   10400:	e0fff70b 	ldhu	r3,-36(fp)
   10404:	e0bfff17 	ldw	r2,-4(fp)
   10408:	1080120b 	ldhu	r2,72(r2)
   1040c:	10bfffcc 	andi	r2,r2,65535
   10410:	10a0001c 	xori	r2,r2,32768
   10414:	10a00004 	addi	r2,r2,-32768
   10418:	1005d0fa 	srai	r2,r2,3
   1041c:	1885c83a 	sub	r2,r3,r2
   10420:	e0bff70d 	sth	r2,-36(fp)
      pcb->sa += m;
   10424:	e0bfff17 	ldw	r2,-4(fp)
   10428:	1080120b 	ldhu	r2,72(r2)
   1042c:	1007883a 	mov	r3,r2
   10430:	e0bff70b 	ldhu	r2,-36(fp)
   10434:	1885883a 	add	r2,r3,r2
   10438:	1007883a 	mov	r3,r2
   1043c:	e0bfff17 	ldw	r2,-4(fp)
   10440:	10c0120d 	sth	r3,72(r2)
      if (m < 0) {
   10444:	e0bff70f 	ldh	r2,-36(fp)
   10448:	1000030e 	bge	r2,zero,10458 <tcp_receive+0x9b8>
        m = -m;
   1044c:	e0bff70b 	ldhu	r2,-36(fp)
   10450:	0085c83a 	sub	r2,zero,r2
   10454:	e0bff70d 	sth	r2,-36(fp)
      }
      m = m - (pcb->sv >> 2);
   10458:	e0fff70b 	ldhu	r3,-36(fp)
   1045c:	e0bfff17 	ldw	r2,-4(fp)
   10460:	1080128b 	ldhu	r2,74(r2)
   10464:	10bfffcc 	andi	r2,r2,65535
   10468:	10a0001c 	xori	r2,r2,32768
   1046c:	10a00004 	addi	r2,r2,-32768
   10470:	1005d0ba 	srai	r2,r2,2
   10474:	1885c83a 	sub	r2,r3,r2
   10478:	e0bff70d 	sth	r2,-36(fp)
      pcb->sv += m;
   1047c:	e0bfff17 	ldw	r2,-4(fp)
   10480:	1080128b 	ldhu	r2,74(r2)
   10484:	1007883a 	mov	r3,r2
   10488:	e0bff70b 	ldhu	r2,-36(fp)
   1048c:	1885883a 	add	r2,r3,r2
   10490:	1007883a 	mov	r3,r2
   10494:	e0bfff17 	ldw	r2,-4(fp)
   10498:	10c0128d 	sth	r3,74(r2)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
   1049c:	e0bfff17 	ldw	r2,-4(fp)
   104a0:	1080120b 	ldhu	r2,72(r2)
   104a4:	10bfffcc 	andi	r2,r2,65535
   104a8:	10a0001c 	xori	r2,r2,32768
   104ac:	10a00004 	addi	r2,r2,-32768
   104b0:	1005d0fa 	srai	r2,r2,3
   104b4:	1007883a 	mov	r3,r2
   104b8:	e0bfff17 	ldw	r2,-4(fp)
   104bc:	1080128b 	ldhu	r2,74(r2)
   104c0:	1885883a 	add	r2,r3,r2
   104c4:	1007883a 	mov	r3,r2
   104c8:	e0bfff17 	ldw	r2,-4(fp)
   104cc:	10c0130d 	sth	r3,76(r2)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
   104d0:	e0bfff17 	ldw	r2,-4(fp)
   104d4:	10001015 	stw	zero,64(r2)
    }
  }

  /* If the incoming segment contains data, we must process it
     further. */
  if (tcplen > 0) {
   104d8:	d0a8e08b 	ldhu	r2,-23678(gp)
   104dc:	10bfffcc 	andi	r2,r2,65535
   104e0:	10045b26 	beq	r2,zero,11650 <tcp_receive+0x1bb0>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
   104e4:	e0bfff17 	ldw	r2,-4(fp)
   104e8:	10c00a17 	ldw	r3,40(r2)
   104ec:	d0a8de17 	ldw	r2,-23688(gp)
   104f0:	0084303a 	nor	r2,zero,r2
   104f4:	1885883a 	add	r2,r3,r2
   104f8:	1000aa16 	blt	r2,zero,107a4 <tcp_receive+0xd04>
   104fc:	e0bfff17 	ldw	r2,-4(fp)
   10500:	10c00a17 	ldw	r3,40(r2)
   10504:	d0a8e08b 	ldhu	r2,-23678(gp)
   10508:	113fffcc 	andi	r4,r2,65535
   1050c:	d0a8de17 	ldw	r2,-23688(gp)
   10510:	2085883a 	add	r2,r4,r2
   10514:	1885c83a 	sub	r2,r3,r2
   10518:	10800044 	addi	r2,r2,1
   1051c:	0080a116 	blt	zero,r2,107a4 <tcp_receive+0xd04>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
   10520:	e0bfff17 	ldw	r2,-4(fp)
   10524:	10c00a17 	ldw	r3,40(r2)
   10528:	d0a8de17 	ldw	r2,-23688(gp)
   1052c:	1885c83a 	sub	r2,r3,r2
   10530:	e0bff615 	stw	r2,-40(fp)
      p = inseg.p;
   10534:	00800134 	movhi	r2,4
   10538:	1090c604 	addi	r2,r2,17176
   1053c:	10800117 	ldw	r2,4(r2)
   10540:	e0bff515 	stw	r2,-44(fp)
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
   10544:	00800134 	movhi	r2,4
   10548:	1090c604 	addi	r2,r2,17176
   1054c:	10800117 	ldw	r2,4(r2)
   10550:	1000091e 	bne	r2,zero,10578 <tcp_receive+0xad8>
   10554:	010000f4 	movhi	r4,3
   10558:	213db804 	addi	r4,r4,-2336
   1055c:	014000f4 	movhi	r5,3
   10560:	297e4004 	addi	r5,r5,-1792
   10564:	01811104 	movi	r6,1092
   10568:	01c000f4 	movhi	r7,3
   1056c:	39fdcc04 	addi	r7,r7,-2256
   10570:	00170680 	call	17068 <printf>
   10574:	003fff06 	br	10574 <tcp_receive+0xad4>
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
   10578:	e0bff617 	ldw	r2,-40(fp)
   1057c:	109fffd0 	cmplti	r2,r2,32767
   10580:	1000091e 	bne	r2,zero,105a8 <tcp_receive+0xb08>
   10584:	010000f4 	movhi	r4,3
   10588:	213db804 	addi	r4,r4,-2336
   1058c:	014000f4 	movhi	r5,3
   10590:	297e4404 	addi	r5,r5,-1776
   10594:	01811144 	movi	r6,1093
   10598:	01c000f4 	movhi	r7,3
   1059c:	39fdcc04 	addi	r7,r7,-2256
   105a0:	00170680 	call	17068 <printf>
   105a4:	003fff06 	br	105a4 <tcp_receive+0xb04>
      if (inseg.p->len < off) {
   105a8:	00800134 	movhi	r2,4
   105ac:	1090c604 	addi	r2,r2,17176
   105b0:	10800117 	ldw	r2,4(r2)
   105b4:	1080028b 	ldhu	r2,10(r2)
   105b8:	10ffffcc 	andi	r3,r2,65535
   105bc:	e0bff617 	ldw	r2,-40(fp)
   105c0:	18803e0e 	bge	r3,r2,106bc <tcp_receive+0xc1c>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
   105c4:	00800134 	movhi	r2,4
   105c8:	1090c604 	addi	r2,r2,17176
   105cc:	10800117 	ldw	r2,4(r2)
   105d0:	1080020b 	ldhu	r2,8(r2)
   105d4:	10ffffcc 	andi	r3,r2,65535
   105d8:	e0bff617 	ldw	r2,-40(fp)
   105dc:	1880090e 	bge	r3,r2,10604 <tcp_receive+0xb64>
   105e0:	010000f4 	movhi	r4,3
   105e4:	213db804 	addi	r4,r4,-2336
   105e8:	014000f4 	movhi	r5,3
   105ec:	297e4804 	addi	r5,r5,-1760
   105f0:	018111c4 	movi	r6,1095
   105f4:	01c000f4 	movhi	r7,3
   105f8:	39fdcc04 	addi	r7,r7,-2256
   105fc:	00170680 	call	17068 <printf>
   10600:	003fff06 	br	10600 <tcp_receive+0xb60>
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
   10604:	00800134 	movhi	r2,4
   10608:	1090c604 	addi	r2,r2,17176
   1060c:	10800117 	ldw	r2,4(r2)
   10610:	10c0020b 	ldhu	r3,8(r2)
   10614:	e0bff617 	ldw	r2,-40(fp)
   10618:	1885c83a 	sub	r2,r3,r2
   1061c:	e0bffb8d 	sth	r2,-18(fp)
        while (p->len < off) {
   10620:	00000e06 	br	1065c <tcp_receive+0xbbc>
          off -= p->len;
   10624:	e0bff517 	ldw	r2,-44(fp)
   10628:	1080028b 	ldhu	r2,10(r2)
   1062c:	10bfffcc 	andi	r2,r2,65535
   10630:	e0fff617 	ldw	r3,-40(fp)
   10634:	1885c83a 	sub	r2,r3,r2
   10638:	e0bff615 	stw	r2,-40(fp)
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
   1063c:	e0bff517 	ldw	r2,-44(fp)
   10640:	e0fffb8b 	ldhu	r3,-18(fp)
   10644:	10c0020d 	sth	r3,8(r2)
          p->len = 0;
   10648:	e0bff517 	ldw	r2,-44(fp)
   1064c:	1000028d 	sth	zero,10(r2)
          p = p->next;
   10650:	e0bff517 	ldw	r2,-44(fp)
   10654:	10800017 	ldw	r2,0(r2)
   10658:	e0bff515 	stw	r2,-44(fp)
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
   1065c:	e0bff517 	ldw	r2,-44(fp)
   10660:	1080028b 	ldhu	r2,10(r2)
   10664:	10ffffcc 	andi	r3,r2,65535
   10668:	e0bff617 	ldw	r2,-40(fp)
   1066c:	18bfed16 	blt	r3,r2,10624 <tcp_receive+0xb84>
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
          p = p->next;
        }
        if(pbuf_header(p, (s16_t)-off)) {
   10670:	e0bff617 	ldw	r2,-40(fp)
   10674:	0085c83a 	sub	r2,zero,r2
   10678:	10bfffcc 	andi	r2,r2,65535
   1067c:	10a0001c 	xori	r2,r2,32768
   10680:	10a00004 	addi	r2,r2,-32768
   10684:	e13ff517 	ldw	r4,-44(fp)
   10688:	100b883a 	mov	r5,r2
   1068c:	0009f900 	call	9f90 <pbuf_header>
   10690:	10803fcc 	andi	r2,r2,255
   10694:	10001f26 	beq	r2,zero,10714 <tcp_receive+0xc74>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
   10698:	010000f4 	movhi	r4,3
   1069c:	213db804 	addi	r4,r4,-2336
   106a0:	014000f4 	movhi	r5,3
   106a4:	297e4c04 	addi	r5,r5,-1744
   106a8:	01811504 	movi	r6,1108
   106ac:	01c000f4 	movhi	r7,3
   106b0:	39fdcc04 	addi	r7,r7,-2256
   106b4:	00170680 	call	17068 <printf>
   106b8:	003fff06 	br	106b8 <tcp_receive+0xc18>
        }
      } else {
        if(pbuf_header(inseg.p, (s16_t)-off)) {
   106bc:	00800134 	movhi	r2,4
   106c0:	1090c604 	addi	r2,r2,17176
   106c4:	10c00117 	ldw	r3,4(r2)
   106c8:	e0bff617 	ldw	r2,-40(fp)
   106cc:	0085c83a 	sub	r2,zero,r2
   106d0:	10bfffcc 	andi	r2,r2,65535
   106d4:	10a0001c 	xori	r2,r2,32768
   106d8:	10a00004 	addi	r2,r2,-32768
   106dc:	1809883a 	mov	r4,r3
   106e0:	100b883a 	mov	r5,r2
   106e4:	0009f900 	call	9f90 <pbuf_header>
   106e8:	10803fcc 	andi	r2,r2,255
   106ec:	10000926 	beq	r2,zero,10714 <tcp_receive+0xc74>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
   106f0:	010000f4 	movhi	r4,3
   106f4:	213db804 	addi	r4,r4,-2336
   106f8:	014000f4 	movhi	r5,3
   106fc:	297e4c04 	addi	r5,r5,-1744
   10700:	01811644 	movi	r6,1113
   10704:	01c000f4 	movhi	r7,3
   10708:	39fdcc04 	addi	r7,r7,-2256
   1070c:	00170680 	call	17068 <printf>
   10710:	003fff06 	br	10710 <tcp_receive+0xc70>
        }
      }
      /* KJM following line changed to use p->payload rather than inseg->p->payload
         to fix bug #9076 */
      inseg.dataptr = p->payload;
   10714:	e0bff517 	ldw	r2,-44(fp)
   10718:	10c00117 	ldw	r3,4(r2)
   1071c:	00800134 	movhi	r2,4
   10720:	1090c604 	addi	r2,r2,17176
   10724:	10c00215 	stw	r3,8(r2)
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
   10728:	00800134 	movhi	r2,4
   1072c:	1090c604 	addi	r2,r2,17176
   10730:	10c0030b 	ldhu	r3,12(r2)
   10734:	d0a8de17 	ldw	r2,-23688(gp)
   10738:	1009883a 	mov	r4,r2
   1073c:	e0bfff17 	ldw	r2,-4(fp)
   10740:	10800a17 	ldw	r2,40(r2)
   10744:	2085c83a 	sub	r2,r4,r2
   10748:	1885883a 	add	r2,r3,r2
   1074c:	1007883a 	mov	r3,r2
   10750:	00800134 	movhi	r2,4
   10754:	1090c604 	addi	r2,r2,17176
   10758:	10c0030d 	sth	r3,12(r2)
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
   1075c:	00800134 	movhi	r2,4
   10760:	1090c604 	addi	r2,r2,17176
   10764:	10800417 	ldw	r2,16(r2)
   10768:	e0ffff17 	ldw	r3,-4(fp)
   1076c:	18c00a17 	ldw	r3,40(r3)
   10770:	d0e8de15 	stw	r3,-23688(gp)
   10774:	d0e8de17 	ldw	r3,-23688(gp)
   10778:	193fffcc 	andi	r4,r3,65535
   1077c:	1140010b 	ldhu	r5,4(r2)
   10780:	280a703a 	and	r5,r5,zero
   10784:	2908b03a 	or	r4,r5,r4
   10788:	1100010d 	sth	r4,4(r2)
   1078c:	1806d43a 	srli	r3,r3,16
   10790:	1100018b 	ldhu	r4,6(r2)
   10794:	2008703a 	and	r4,r4,zero
   10798:	20c6b03a 	or	r3,r4,r3
   1079c:	10c0018d 	sth	r3,6(r2)
   107a0:	00000d06 	br	107d8 <tcp_receive+0xd38>
    }
    else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
   107a4:	d0e8de17 	ldw	r3,-23688(gp)
   107a8:	e0bfff17 	ldw	r2,-4(fp)
   107ac:	10800a17 	ldw	r2,40(r2)
   107b0:	1885c83a 	sub	r2,r3,r2
   107b4:	1000080e 	bge	r2,zero,107d8 <tcp_receive+0xd38>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
   107b8:	e0bfff17 	ldw	r2,-4(fp)
   107bc:	10800983 	ldbu	r2,38(r2)
   107c0:	10800094 	ori	r2,r2,2
   107c4:	1007883a 	mov	r3,r2
   107c8:	e0bfff17 	ldw	r2,-4(fp)
   107cc:	10c00985 	stb	r3,38(r2)
   107d0:	e13fff17 	ldw	r4,-4(fp)
   107d4:	0012b000 	call	12b00 <tcp_output>
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
   107d8:	d0e8de17 	ldw	r3,-23688(gp)
   107dc:	e0bfff17 	ldw	r2,-4(fp)
   107e0:	10800a17 	ldw	r2,40(r2)
   107e4:	1885c83a 	sub	r2,r3,r2
   107e8:	10039616 	blt	r2,zero,11644 <tcp_receive+0x1ba4>
   107ec:	d0e8de17 	ldw	r3,-23688(gp)
   107f0:	e0bfff17 	ldw	r2,-4(fp)
   107f4:	11000a17 	ldw	r4,40(r2)
   107f8:	e0bfff17 	ldw	r2,-4(fp)
   107fc:	10800b0b 	ldhu	r2,44(r2)
   10800:	10bfffcc 	andi	r2,r2,65535
   10804:	2085883a 	add	r2,r4,r2
   10808:	1885c83a 	sub	r2,r3,r2
   1080c:	10800044 	addi	r2,r2,1
   10810:	00838c16 	blt	zero,r2,11644 <tcp_receive+0x1ba4>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
   10814:	e0bfff17 	ldw	r2,-4(fp)
   10818:	10c00a17 	ldw	r3,40(r2)
   1081c:	d0a8de17 	ldw	r2,-23688(gp)
   10820:	18829e1e 	bne	r3,r2,1129c <tcp_receive+0x17fc>
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
        tcplen = TCP_TCPLEN(&inseg);
   10824:	00800134 	movhi	r2,4
   10828:	1090c604 	addi	r2,r2,17176
   1082c:	10c0030b 	ldhu	r3,12(r2)
   10830:	00800134 	movhi	r2,4
   10834:	1090c604 	addi	r2,r2,17176
   10838:	10800417 	ldw	r2,16(r2)
   1083c:	1080030b 	ldhu	r2,12(r2)
   10840:	10bfffcc 	andi	r2,r2,65535
   10844:	1004d23a 	srli	r2,r2,8
   10848:	113fffcc 	andi	r4,r2,65535
   1084c:	00800134 	movhi	r2,4
   10850:	1090c604 	addi	r2,r2,17176
   10854:	10800417 	ldw	r2,16(r2)
   10858:	1080030b 	ldhu	r2,12(r2)
   1085c:	10bfffcc 	andi	r2,r2,65535
   10860:	1004923a 	slli	r2,r2,8
   10864:	10bfffcc 	andi	r2,r2,65535
   10868:	2084b03a 	or	r2,r4,r2
   1086c:	108000cc 	andi	r2,r2,3
   10870:	1004c03a 	cmpne	r2,r2,zero
   10874:	10803fcc 	andi	r2,r2,255
   10878:	1885883a 	add	r2,r3,r2
   1087c:	d0a8e08d 	sth	r2,-23678(gp)

        if (tcplen > pcb->rcv_wnd) {
   10880:	e0bfff17 	ldw	r2,-4(fp)
   10884:	10c00b0b 	ldhu	r3,44(r2)
   10888:	d0a8e08b 	ldhu	r2,-23678(gp)
   1088c:	18ffffcc 	andi	r3,r3,65535
   10890:	10bfffcc 	andi	r2,r2,65535
   10894:	1880802e 	bgeu	r3,r2,10a98 <tcp_receive+0xff8>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, 
                      ("tcp_receive: other end overran receive window"
                       "seqno %"U32_F" len %"U32_F" right edge %"U32_F"\n",
                       seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
   10898:	00800134 	movhi	r2,4
   1089c:	1090c604 	addi	r2,r2,17176
   108a0:	10800417 	ldw	r2,16(r2)
   108a4:	1080030b 	ldhu	r2,12(r2)
   108a8:	10bfffcc 	andi	r2,r2,65535
   108ac:	1004d23a 	srli	r2,r2,8
   108b0:	10ffffcc 	andi	r3,r2,65535
   108b4:	00800134 	movhi	r2,4
   108b8:	1090c604 	addi	r2,r2,17176
   108bc:	10800417 	ldw	r2,16(r2)
   108c0:	1080030b 	ldhu	r2,12(r2)
   108c4:	10bfffcc 	andi	r2,r2,65535
   108c8:	1004923a 	slli	r2,r2,8
   108cc:	10bfffcc 	andi	r2,r2,65535
   108d0:	1884b03a 	or	r2,r3,r2
   108d4:	1080004c 	andi	r2,r2,1
   108d8:	10001c26 	beq	r2,zero,1094c <tcp_receive+0xeac>
            /* Must remove the FIN from the header as we're trimming 
             * that byte of sequence-space from the packet */
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) &~ TCP_FIN);
   108dc:	00800134 	movhi	r2,4
   108e0:	1090c604 	addi	r2,r2,17176
   108e4:	10800417 	ldw	r2,16(r2)
   108e8:	00c00134 	movhi	r3,4
   108ec:	18d0c604 	addi	r3,r3,17176
   108f0:	18c00417 	ldw	r3,16(r3)
   108f4:	1900030b 	ldhu	r4,12(r3)
   108f8:	00f03fc4 	movi	r3,-16129
   108fc:	20c6703a 	and	r3,r4,r3
   10900:	1809883a 	mov	r4,r3
   10904:	00c00134 	movhi	r3,4
   10908:	18d0c604 	addi	r3,r3,17176
   1090c:	18c00417 	ldw	r3,16(r3)
   10910:	18c0030b 	ldhu	r3,12(r3)
   10914:	18ffffcc 	andi	r3,r3,65535
   10918:	1806d23a 	srli	r3,r3,8
   1091c:	180b883a 	mov	r5,r3
   10920:	00c00134 	movhi	r3,4
   10924:	18d0c604 	addi	r3,r3,17176
   10928:	18c00417 	ldw	r3,16(r3)
   1092c:	18c0030b 	ldhu	r3,12(r3)
   10930:	18ffffcc 	andi	r3,r3,65535
   10934:	1806923a 	slli	r3,r3,8
   10938:	28c6b03a 	or	r3,r5,r3
   1093c:	18c00f8c 	andi	r3,r3,62
   10940:	1806923a 	slli	r3,r3,8
   10944:	20c6b03a 	or	r3,r4,r3
   10948:	10c0030d 	sth	r3,12(r2)
          }
          /* Adjust length of segment to fit in the window. */
          inseg.len = pcb->rcv_wnd;
   1094c:	e0bfff17 	ldw	r2,-4(fp)
   10950:	10c00b0b 	ldhu	r3,44(r2)
   10954:	00800134 	movhi	r2,4
   10958:	1090c604 	addi	r2,r2,17176
   1095c:	10c0030d 	sth	r3,12(r2)
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
   10960:	00800134 	movhi	r2,4
   10964:	1090c604 	addi	r2,r2,17176
   10968:	10800417 	ldw	r2,16(r2)
   1096c:	1080030b 	ldhu	r2,12(r2)
   10970:	10bfffcc 	andi	r2,r2,65535
   10974:	1004d23a 	srli	r2,r2,8
   10978:	10ffffcc 	andi	r3,r2,65535
   1097c:	00800134 	movhi	r2,4
   10980:	1090c604 	addi	r2,r2,17176
   10984:	10800417 	ldw	r2,16(r2)
   10988:	1080030b 	ldhu	r2,12(r2)
   1098c:	10bfffcc 	andi	r2,r2,65535
   10990:	1004923a 	slli	r2,r2,8
   10994:	10bfffcc 	andi	r2,r2,65535
   10998:	1884b03a 	or	r2,r3,r2
   1099c:	1080008c 	andi	r2,r2,2
   109a0:	10000826 	beq	r2,zero,109c4 <tcp_receive+0xf24>
            inseg.len -= 1;
   109a4:	00800134 	movhi	r2,4
   109a8:	1090c604 	addi	r2,r2,17176
   109ac:	1080030b 	ldhu	r2,12(r2)
   109b0:	10bfffc4 	addi	r2,r2,-1
   109b4:	1007883a 	mov	r3,r2
   109b8:	00800134 	movhi	r2,4
   109bc:	1090c604 	addi	r2,r2,17176
   109c0:	10c0030d 	sth	r3,12(r2)
          }
          pbuf_realloc(inseg.p, inseg.len);
   109c4:	00800134 	movhi	r2,4
   109c8:	1090c604 	addi	r2,r2,17176
   109cc:	10c00117 	ldw	r3,4(r2)
   109d0:	00800134 	movhi	r2,4
   109d4:	1090c604 	addi	r2,r2,17176
   109d8:	1080030b 	ldhu	r2,12(r2)
   109dc:	10bfffcc 	andi	r2,r2,65535
   109e0:	1809883a 	mov	r4,r3
   109e4:	100b883a 	mov	r5,r2
   109e8:	0009d0c0 	call	9d0c <pbuf_realloc>
          tcplen = TCP_TCPLEN(&inseg);
   109ec:	00800134 	movhi	r2,4
   109f0:	1090c604 	addi	r2,r2,17176
   109f4:	10c0030b 	ldhu	r3,12(r2)
   109f8:	00800134 	movhi	r2,4
   109fc:	1090c604 	addi	r2,r2,17176
   10a00:	10800417 	ldw	r2,16(r2)
   10a04:	1080030b 	ldhu	r2,12(r2)
   10a08:	10bfffcc 	andi	r2,r2,65535
   10a0c:	1004d23a 	srli	r2,r2,8
   10a10:	113fffcc 	andi	r4,r2,65535
   10a14:	00800134 	movhi	r2,4
   10a18:	1090c604 	addi	r2,r2,17176
   10a1c:	10800417 	ldw	r2,16(r2)
   10a20:	1080030b 	ldhu	r2,12(r2)
   10a24:	10bfffcc 	andi	r2,r2,65535
   10a28:	1004923a 	slli	r2,r2,8
   10a2c:	10bfffcc 	andi	r2,r2,65535
   10a30:	2084b03a 	or	r2,r4,r2
   10a34:	108000cc 	andi	r2,r2,3
   10a38:	1004c03a 	cmpne	r2,r2,zero
   10a3c:	10803fcc 	andi	r2,r2,255
   10a40:	1885883a 	add	r2,r3,r2
   10a44:	d0a8e08d 	sth	r2,-23678(gp)
          LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
   10a48:	d0a8e08b 	ldhu	r2,-23678(gp)
   10a4c:	10ffffcc 	andi	r3,r2,65535
   10a50:	d0a8de17 	ldw	r2,-23688(gp)
   10a54:	1887883a 	add	r3,r3,r2
   10a58:	e0bfff17 	ldw	r2,-4(fp)
   10a5c:	11000a17 	ldw	r4,40(r2)
   10a60:	e0bfff17 	ldw	r2,-4(fp)
   10a64:	10800b0b 	ldhu	r2,44(r2)
   10a68:	10bfffcc 	andi	r2,r2,65535
   10a6c:	2085883a 	add	r2,r4,r2
   10a70:	18800926 	beq	r3,r2,10a98 <tcp_receive+0xff8>
   10a74:	010000f4 	movhi	r4,3
   10a78:	213db804 	addi	r4,r4,-2336
   10a7c:	014000f4 	movhi	r5,3
   10a80:	297e5104 	addi	r5,r5,-1724
   10a84:	01812244 	movi	r6,1161
   10a88:	01c000f4 	movhi	r7,3
   10a8c:	39fdcc04 	addi	r7,r7,-2256
   10a90:	00170680 	call	17068 <printf>
   10a94:	003fff06 	br	10a94 <tcp_receive+0xff4>
                      (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
        }
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL) {
   10a98:	e0bfff17 	ldw	r2,-4(fp)
   10a9c:	10802017 	ldw	r2,128(r2)
   10aa0:	10010026 	beq	r2,zero,10ea4 <tcp_receive+0x1404>
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
   10aa4:	00800134 	movhi	r2,4
   10aa8:	1090c604 	addi	r2,r2,17176
   10aac:	10800417 	ldw	r2,16(r2)
   10ab0:	1080030b 	ldhu	r2,12(r2)
   10ab4:	10bfffcc 	andi	r2,r2,65535
   10ab8:	1004d23a 	srli	r2,r2,8
   10abc:	10ffffcc 	andi	r3,r2,65535
   10ac0:	00800134 	movhi	r2,4
   10ac4:	1090c604 	addi	r2,r2,17176
   10ac8:	10800417 	ldw	r2,16(r2)
   10acc:	1080030b 	ldhu	r2,12(r2)
   10ad0:	10bfffcc 	andi	r2,r2,65535
   10ad4:	1004923a 	slli	r2,r2,8
   10ad8:	10bfffcc 	andi	r2,r2,65535
   10adc:	1884b03a 	or	r2,r3,r2
   10ae0:	1080004c 	andi	r2,r2,1
   10ae4:	10000f26 	beq	r2,zero,10b24 <tcp_receive+0x1084>
             * bin the ooseq queue
             * rcv_nxt
             * .    |--ooseq--|
             * .==seg============|FIN
             */
            while (pcb->ooseq != NULL) {
   10ae8:	00000a06 	br	10b14 <tcp_receive+0x1074>
              struct tcp_seg *old_ooseq = pcb->ooseq;
   10aec:	e0bfff17 	ldw	r2,-4(fp)
   10af0:	10802017 	ldw	r2,128(r2)
   10af4:	e0bffc15 	stw	r2,-16(fp)
              pcb->ooseq = pcb->ooseq->next;
   10af8:	e0bfff17 	ldw	r2,-4(fp)
   10afc:	10802017 	ldw	r2,128(r2)
   10b00:	10c00017 	ldw	r3,0(r2)
   10b04:	e0bfff17 	ldw	r2,-4(fp)
   10b08:	10c02015 	stw	r3,128(r2)
              tcp_seg_free(old_ooseq);
   10b0c:	e13ffc17 	ldw	r4,-16(fp)
   10b10:	000ca9c0 	call	ca9c <tcp_seg_free>
             * bin the ooseq queue
             * rcv_nxt
             * .    |--ooseq--|
             * .==seg============|FIN
             */
            while (pcb->ooseq != NULL) {
   10b14:	e0bfff17 	ldw	r2,-4(fp)
   10b18:	10802017 	ldw	r2,128(r2)
   10b1c:	103ff31e 	bne	r2,zero,10aec <tcp_receive+0x104c>
   10b20:	0000e006 	br	10ea4 <tcp_receive+0x1404>
              pcb->ooseq = pcb->ooseq->next;
              tcp_seg_free(old_ooseq);
            }               
          } 
          else {
            struct tcp_seg* next = pcb->ooseq;
   10b24:	e0bfff17 	ldw	r2,-4(fp)
   10b28:	10802017 	ldw	r2,128(r2)
   10b2c:	e0bff915 	stw	r2,-28(fp)
            struct tcp_seg *old_seg;
            /* rcv_nxt
             * .    |--ooseq--|
             * .==seg============|
             */
            while (next &&
   10b30:	00005b06 	br	10ca0 <tcp_receive+0x1200>
                   TCP_SEQ_GEQ(seqno + tcplen,
                               next->tcphdr->seqno + next->len)) {
              /* inseg doesn't have FIN (already processed) */
              if (TCPH_FLAGS(next->tcphdr) & TCP_FIN &&
   10b34:	e0bff917 	ldw	r2,-28(fp)
   10b38:	10800417 	ldw	r2,16(r2)
   10b3c:	1080030b 	ldhu	r2,12(r2)
   10b40:	10bfffcc 	andi	r2,r2,65535
   10b44:	1004d23a 	srli	r2,r2,8
   10b48:	10ffffcc 	andi	r3,r2,65535
   10b4c:	e0bff917 	ldw	r2,-28(fp)
   10b50:	10800417 	ldw	r2,16(r2)
   10b54:	1080030b 	ldhu	r2,12(r2)
   10b58:	10bfffcc 	andi	r2,r2,65535
   10b5c:	1004923a 	slli	r2,r2,8
   10b60:	10bfffcc 	andi	r2,r2,65535
   10b64:	1884b03a 	or	r2,r3,r2
   10b68:	1080004c 	andi	r2,r2,1
   10b6c:	10004526 	beq	r2,zero,10c84 <tcp_receive+0x11e4>
                  (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
   10b70:	00800134 	movhi	r2,4
   10b74:	1090c604 	addi	r2,r2,17176
   10b78:	10800417 	ldw	r2,16(r2)
   10b7c:	1080030b 	ldhu	r2,12(r2)
   10b80:	10bfffcc 	andi	r2,r2,65535
   10b84:	1004d23a 	srli	r2,r2,8
   10b88:	10ffffcc 	andi	r3,r2,65535
   10b8c:	00800134 	movhi	r2,4
   10b90:	1090c604 	addi	r2,r2,17176
   10b94:	10800417 	ldw	r2,16(r2)
   10b98:	1080030b 	ldhu	r2,12(r2)
   10b9c:	10bfffcc 	andi	r2,r2,65535
   10ba0:	1004923a 	slli	r2,r2,8
   10ba4:	10bfffcc 	andi	r2,r2,65535
   10ba8:	1884b03a 	or	r2,r3,r2
   10bac:	1080008c 	andi	r2,r2,2
             */
            while (next &&
                   TCP_SEQ_GEQ(seqno + tcplen,
                               next->tcphdr->seqno + next->len)) {
              /* inseg doesn't have FIN (already processed) */
              if (TCPH_FLAGS(next->tcphdr) & TCP_FIN &&
   10bb0:	1000341e 	bne	r2,zero,10c84 <tcp_receive+0x11e4>
                  (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
                TCPH_FLAGS_SET(inseg.tcphdr, 
   10bb4:	00800134 	movhi	r2,4
   10bb8:	1090c604 	addi	r2,r2,17176
   10bbc:	10800417 	ldw	r2,16(r2)
   10bc0:	00c00134 	movhi	r3,4
   10bc4:	18d0c604 	addi	r3,r3,17176
   10bc8:	18c00417 	ldw	r3,16(r3)
   10bcc:	1900030b 	ldhu	r4,12(r3)
   10bd0:	00f03fc4 	movi	r3,-16129
   10bd4:	20c6703a 	and	r3,r4,r3
   10bd8:	1809883a 	mov	r4,r3
   10bdc:	00c00134 	movhi	r3,4
   10be0:	18d0c604 	addi	r3,r3,17176
   10be4:	18c00417 	ldw	r3,16(r3)
   10be8:	18c0030b 	ldhu	r3,12(r3)
   10bec:	18ffffcc 	andi	r3,r3,65535
   10bf0:	1806d23a 	srli	r3,r3,8
   10bf4:	180b883a 	mov	r5,r3
   10bf8:	00c00134 	movhi	r3,4
   10bfc:	18d0c604 	addi	r3,r3,17176
   10c00:	18c00417 	ldw	r3,16(r3)
   10c04:	18c0030b 	ldhu	r3,12(r3)
   10c08:	18ffffcc 	andi	r3,r3,65535
   10c0c:	1806923a 	slli	r3,r3,8
   10c10:	28c6b03a 	or	r3,r5,r3
   10c14:	18c00f8c 	andi	r3,r3,62
   10c18:	18c00054 	ori	r3,r3,1
   10c1c:	1806923a 	slli	r3,r3,8
   10c20:	20c6b03a 	or	r3,r4,r3
   10c24:	10c0030d 	sth	r3,12(r2)
                               TCPH_FLAGS(inseg.tcphdr) | TCP_FIN);
                tcplen = TCP_TCPLEN(&inseg);
   10c28:	00800134 	movhi	r2,4
   10c2c:	1090c604 	addi	r2,r2,17176
   10c30:	10c0030b 	ldhu	r3,12(r2)
   10c34:	00800134 	movhi	r2,4
   10c38:	1090c604 	addi	r2,r2,17176
   10c3c:	10800417 	ldw	r2,16(r2)
   10c40:	1080030b 	ldhu	r2,12(r2)
   10c44:	10bfffcc 	andi	r2,r2,65535
   10c48:	1004d23a 	srli	r2,r2,8
   10c4c:	113fffcc 	andi	r4,r2,65535
   10c50:	00800134 	movhi	r2,4
   10c54:	1090c604 	addi	r2,r2,17176
   10c58:	10800417 	ldw	r2,16(r2)
   10c5c:	1080030b 	ldhu	r2,12(r2)
   10c60:	10bfffcc 	andi	r2,r2,65535
   10c64:	1004923a 	slli	r2,r2,8
   10c68:	10bfffcc 	andi	r2,r2,65535
   10c6c:	2084b03a 	or	r2,r4,r2
   10c70:	108000cc 	andi	r2,r2,3
   10c74:	1004c03a 	cmpne	r2,r2,zero
   10c78:	10803fcc 	andi	r2,r2,255
   10c7c:	1885883a 	add	r2,r3,r2
   10c80:	d0a8e08d 	sth	r2,-23678(gp)
              }
              old_seg = next;
   10c84:	e0bff917 	ldw	r2,-28(fp)
   10c88:	e0bffd15 	stw	r2,-12(fp)
              next = next->next;
   10c8c:	e0bff917 	ldw	r2,-28(fp)
   10c90:	10800017 	ldw	r2,0(r2)
   10c94:	e0bff915 	stw	r2,-28(fp)
              tcp_seg_free(old_seg);
   10c98:	e13ffd17 	ldw	r4,-12(fp)
   10c9c:	000ca9c0 	call	ca9c <tcp_seg_free>
            struct tcp_seg *old_seg;
            /* rcv_nxt
             * .    |--ooseq--|
             * .==seg============|
             */
            while (next &&
   10ca0:	e0bff917 	ldw	r2,-28(fp)
   10ca4:	10001126 	beq	r2,zero,10cec <tcp_receive+0x124c>
                   TCP_SEQ_GEQ(seqno + tcplen,
   10ca8:	d0a8e08b 	ldhu	r2,-23678(gp)
   10cac:	10ffffcc 	andi	r3,r2,65535
   10cb0:	d0a8de17 	ldw	r2,-23688(gp)
   10cb4:	1887883a 	add	r3,r3,r2
   10cb8:	e0bff917 	ldw	r2,-28(fp)
   10cbc:	10800417 	ldw	r2,16(r2)
   10cc0:	1100010b 	ldhu	r4,4(r2)
   10cc4:	1080018b 	ldhu	r2,6(r2)
   10cc8:	1004943a 	slli	r2,r2,16
   10ccc:	1104b03a 	or	r2,r2,r4
   10cd0:	1009883a 	mov	r4,r2
   10cd4:	e0bff917 	ldw	r2,-28(fp)
   10cd8:	1080030b 	ldhu	r2,12(r2)
   10cdc:	10bfffcc 	andi	r2,r2,65535
   10ce0:	2085883a 	add	r2,r4,r2
   10ce4:	1885c83a 	sub	r2,r3,r2
            struct tcp_seg *old_seg;
            /* rcv_nxt
             * .    |--ooseq--|
             * .==seg============|
             */
            while (next &&
   10ce8:	103f920e 	bge	r2,zero,10b34 <tcp_receive+0x1094>
            }
            /* rcv_nxt
             * .             |--ooseq--|
             * .==seg============|
             */
            if (next &&
   10cec:	e0bff917 	ldw	r2,-28(fp)
   10cf0:	10006926 	beq	r2,zero,10e98 <tcp_receive+0x13f8>
                TCP_SEQ_GT(seqno + tcplen,
   10cf4:	d0a8e08b 	ldhu	r2,-23678(gp)
   10cf8:	10ffffcc 	andi	r3,r2,65535
   10cfc:	d0a8de17 	ldw	r2,-23688(gp)
   10d00:	1887883a 	add	r3,r3,r2
   10d04:	e0bff917 	ldw	r2,-28(fp)
   10d08:	10800417 	ldw	r2,16(r2)
   10d0c:	1100010b 	ldhu	r4,4(r2)
   10d10:	1080018b 	ldhu	r2,6(r2)
   10d14:	1004943a 	slli	r2,r2,16
   10d18:	1104b03a 	or	r2,r2,r4
   10d1c:	1885c83a 	sub	r2,r3,r2
            }
            /* rcv_nxt
             * .             |--ooseq--|
             * .==seg============|
             */
            if (next &&
   10d20:	00805d0e 	bge	zero,r2,10e98 <tcp_receive+0x13f8>
                TCP_SEQ_GT(seqno + tcplen,
                           next->tcphdr->seqno)) {
              /* FIN in inseg already handled by dropping whole ooseq queue */
              inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
   10d24:	e0bfff17 	ldw	r2,-4(fp)
   10d28:	10802017 	ldw	r2,128(r2)
   10d2c:	10800417 	ldw	r2,16(r2)
   10d30:	10c0010b 	ldhu	r3,4(r2)
   10d34:	1080018b 	ldhu	r2,6(r2)
   10d38:	1004943a 	slli	r2,r2,16
   10d3c:	10c4b03a 	or	r2,r2,r3
   10d40:	1007883a 	mov	r3,r2
   10d44:	d0a8de17 	ldw	r2,-23688(gp)
   10d48:	1885c83a 	sub	r2,r3,r2
   10d4c:	1007883a 	mov	r3,r2
   10d50:	00800134 	movhi	r2,4
   10d54:	1090c604 	addi	r2,r2,17176
   10d58:	10c0030d 	sth	r3,12(r2)
              if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
   10d5c:	00800134 	movhi	r2,4
   10d60:	1090c604 	addi	r2,r2,17176
   10d64:	10800417 	ldw	r2,16(r2)
   10d68:	1080030b 	ldhu	r2,12(r2)
   10d6c:	10bfffcc 	andi	r2,r2,65535
   10d70:	1004d23a 	srli	r2,r2,8
   10d74:	10ffffcc 	andi	r3,r2,65535
   10d78:	00800134 	movhi	r2,4
   10d7c:	1090c604 	addi	r2,r2,17176
   10d80:	10800417 	ldw	r2,16(r2)
   10d84:	1080030b 	ldhu	r2,12(r2)
   10d88:	10bfffcc 	andi	r2,r2,65535
   10d8c:	1004923a 	slli	r2,r2,8
   10d90:	10bfffcc 	andi	r2,r2,65535
   10d94:	1884b03a 	or	r2,r3,r2
   10d98:	1080008c 	andi	r2,r2,2
   10d9c:	10000826 	beq	r2,zero,10dc0 <tcp_receive+0x1320>
                inseg.len -= 1;
   10da0:	00800134 	movhi	r2,4
   10da4:	1090c604 	addi	r2,r2,17176
   10da8:	1080030b 	ldhu	r2,12(r2)
   10dac:	10bfffc4 	addi	r2,r2,-1
   10db0:	1007883a 	mov	r3,r2
   10db4:	00800134 	movhi	r2,4
   10db8:	1090c604 	addi	r2,r2,17176
   10dbc:	10c0030d 	sth	r3,12(r2)
              }
              pbuf_realloc(inseg.p, inseg.len);
   10dc0:	00800134 	movhi	r2,4
   10dc4:	1090c604 	addi	r2,r2,17176
   10dc8:	10c00117 	ldw	r3,4(r2)
   10dcc:	00800134 	movhi	r2,4
   10dd0:	1090c604 	addi	r2,r2,17176
   10dd4:	1080030b 	ldhu	r2,12(r2)
   10dd8:	10bfffcc 	andi	r2,r2,65535
   10ddc:	1809883a 	mov	r4,r3
   10de0:	100b883a 	mov	r5,r2
   10de4:	0009d0c0 	call	9d0c <pbuf_realloc>
              tcplen = TCP_TCPLEN(&inseg);
   10de8:	00800134 	movhi	r2,4
   10dec:	1090c604 	addi	r2,r2,17176
   10df0:	10c0030b 	ldhu	r3,12(r2)
   10df4:	00800134 	movhi	r2,4
   10df8:	1090c604 	addi	r2,r2,17176
   10dfc:	10800417 	ldw	r2,16(r2)
   10e00:	1080030b 	ldhu	r2,12(r2)
   10e04:	10bfffcc 	andi	r2,r2,65535
   10e08:	1004d23a 	srli	r2,r2,8
   10e0c:	113fffcc 	andi	r4,r2,65535
   10e10:	00800134 	movhi	r2,4
   10e14:	1090c604 	addi	r2,r2,17176
   10e18:	10800417 	ldw	r2,16(r2)
   10e1c:	1080030b 	ldhu	r2,12(r2)
   10e20:	10bfffcc 	andi	r2,r2,65535
   10e24:	1004923a 	slli	r2,r2,8
   10e28:	10bfffcc 	andi	r2,r2,65535
   10e2c:	2084b03a 	or	r2,r4,r2
   10e30:	108000cc 	andi	r2,r2,3
   10e34:	1004c03a 	cmpne	r2,r2,zero
   10e38:	10803fcc 	andi	r2,r2,255
   10e3c:	1885883a 	add	r2,r3,r2
   10e40:	d0a8e08d 	sth	r2,-23678(gp)
              LWIP_ASSERT("tcp_receive: segment not trimmed correctly to ooseq queue\n",
   10e44:	d0a8e08b 	ldhu	r2,-23678(gp)
   10e48:	10ffffcc 	andi	r3,r2,65535
   10e4c:	d0a8de17 	ldw	r2,-23688(gp)
   10e50:	1887883a 	add	r3,r3,r2
   10e54:	e0bfff17 	ldw	r2,-4(fp)
   10e58:	10802017 	ldw	r2,128(r2)
   10e5c:	10800417 	ldw	r2,16(r2)
   10e60:	1100010b 	ldhu	r4,4(r2)
   10e64:	1080018b 	ldhu	r2,6(r2)
   10e68:	1004943a 	slli	r2,r2,16
   10e6c:	1104b03a 	or	r2,r2,r4
   10e70:	18800926 	beq	r3,r2,10e98 <tcp_receive+0x13f8>
   10e74:	010000f4 	movhi	r4,3
   10e78:	213db804 	addi	r4,r4,-2336
   10e7c:	014000f4 	movhi	r5,3
   10e80:	297e5f04 	addi	r5,r5,-1668
   10e84:	01813044 	movi	r6,1217
   10e88:	01c000f4 	movhi	r7,3
   10e8c:	39fdcc04 	addi	r7,r7,-2256
   10e90:	00170680 	call	17068 <printf>
   10e94:	003fff06 	br	10e94 <tcp_receive+0x13f4>
                          (seqno + tcplen) == pcb->ooseq->tcphdr->seqno);
            }
            pcb->ooseq = next;
   10e98:	e0bfff17 	ldw	r2,-4(fp)
   10e9c:	e0fff917 	ldw	r3,-28(fp)
   10ea0:	10c02015 	stw	r3,128(r2)
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        pcb->rcv_nxt = seqno + tcplen;
   10ea4:	d0a8e08b 	ldhu	r2,-23678(gp)
   10ea8:	10ffffcc 	andi	r3,r2,65535
   10eac:	d0a8de17 	ldw	r2,-23688(gp)
   10eb0:	1887883a 	add	r3,r3,r2
   10eb4:	e0bfff17 	ldw	r2,-4(fp)
   10eb8:	10c00a15 	stw	r3,40(r2)

        /* Update the receiver's (our) window. */
        LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
   10ebc:	e0bfff17 	ldw	r2,-4(fp)
   10ec0:	10c00b0b 	ldhu	r3,44(r2)
   10ec4:	d0a8e08b 	ldhu	r2,-23678(gp)
   10ec8:	18ffffcc 	andi	r3,r3,65535
   10ecc:	10bfffcc 	andi	r2,r2,65535
   10ed0:	1880092e 	bgeu	r3,r2,10ef8 <tcp_receive+0x1458>
   10ed4:	010000f4 	movhi	r4,3
   10ed8:	213db804 	addi	r4,r4,-2336
   10edc:	014000f4 	movhi	r5,3
   10ee0:	297e6e04 	addi	r5,r5,-1608
   10ee4:	018132c4 	movi	r6,1227
   10ee8:	01c000f4 	movhi	r7,3
   10eec:	39fdcc04 	addi	r7,r7,-2256
   10ef0:	00170680 	call	17068 <printf>
   10ef4:	003fff06 	br	10ef4 <tcp_receive+0x1454>
        pcb->rcv_wnd -= tcplen;
   10ef8:	e0bfff17 	ldw	r2,-4(fp)
   10efc:	10c00b0b 	ldhu	r3,44(r2)
   10f00:	d0a8e08b 	ldhu	r2,-23678(gp)
   10f04:	1885c83a 	sub	r2,r3,r2
   10f08:	1007883a 	mov	r3,r2
   10f0c:	e0bfff17 	ldw	r2,-4(fp)
   10f10:	10c00b0d 	sth	r3,44(r2)

        tcp_update_rcv_ann_wnd(pcb);
   10f14:	e13fff17 	ldw	r4,-4(fp)
   10f18:	000bb100 	call	bb10 <tcp_update_rcv_ann_wnd>
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
   10f1c:	00800134 	movhi	r2,4
   10f20:	1090c604 	addi	r2,r2,17176
   10f24:	10800117 	ldw	r2,4(r2)
   10f28:	1080020b 	ldhu	r2,8(r2)
   10f2c:	10bfffcc 	andi	r2,r2,65535
   10f30:	10000726 	beq	r2,zero,10f50 <tcp_receive+0x14b0>
          recv_data = inseg.p;
   10f34:	00800134 	movhi	r2,4
   10f38:	1090c604 	addi	r2,r2,17176
   10f3c:	10800117 	ldw	r2,4(r2)
   10f40:	d0a8e215 	stw	r2,-23672(gp)
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
   10f44:	00800134 	movhi	r2,4
   10f48:	1090c604 	addi	r2,r2,17176
   10f4c:	10000115 	stw	zero,4(r2)
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
   10f50:	00800134 	movhi	r2,4
   10f54:	1090c604 	addi	r2,r2,17176
   10f58:	10800417 	ldw	r2,16(r2)
   10f5c:	1080030b 	ldhu	r2,12(r2)
   10f60:	10bfffcc 	andi	r2,r2,65535
   10f64:	1004d23a 	srli	r2,r2,8
   10f68:	10ffffcc 	andi	r3,r2,65535
   10f6c:	00800134 	movhi	r2,4
   10f70:	1090c604 	addi	r2,r2,17176
   10f74:	10800417 	ldw	r2,16(r2)
   10f78:	1080030b 	ldhu	r2,12(r2)
   10f7c:	10bfffcc 	andi	r2,r2,65535
   10f80:	1004923a 	slli	r2,r2,8
   10f84:	10bfffcc 	andi	r2,r2,65535
   10f88:	1884b03a 	or	r2,r3,r2
   10f8c:	1080004c 	andi	r2,r2,1
   10f90:	10009726 	beq	r2,zero,111f0 <tcp_receive+0x1750>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags |= TF_GOT_FIN;
   10f94:	d0a8e103 	ldbu	r2,-23676(gp)
   10f98:	10800814 	ori	r2,r2,32
   10f9c:	d0a8e105 	stb	r2,-23676(gp)
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
   10fa0:	00009306 	br	111f0 <tcp_receive+0x1750>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          cseg = pcb->ooseq;
   10fa4:	e0bfff17 	ldw	r2,-4(fp)
   10fa8:	10802017 	ldw	r2,128(r2)
   10fac:	e0bffe15 	stw	r2,-8(fp)
          seqno = pcb->ooseq->tcphdr->seqno;
   10fb0:	e0bfff17 	ldw	r2,-4(fp)
   10fb4:	10802017 	ldw	r2,128(r2)
   10fb8:	10800417 	ldw	r2,16(r2)
   10fbc:	10c0010b 	ldhu	r3,4(r2)
   10fc0:	1080018b 	ldhu	r2,6(r2)
   10fc4:	1004943a 	slli	r2,r2,16
   10fc8:	10c4b03a 	or	r2,r2,r3
   10fcc:	d0a8de15 	stw	r2,-23688(gp)

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
   10fd0:	e0bfff17 	ldw	r2,-4(fp)
   10fd4:	10c00a17 	ldw	r3,40(r2)
   10fd8:	e0bffe17 	ldw	r2,-8(fp)
   10fdc:	1080030b 	ldhu	r2,12(r2)
   10fe0:	113fffcc 	andi	r4,r2,65535
   10fe4:	e0bffe17 	ldw	r2,-8(fp)
   10fe8:	10800417 	ldw	r2,16(r2)
   10fec:	1080030b 	ldhu	r2,12(r2)
   10ff0:	10bfffcc 	andi	r2,r2,65535
   10ff4:	1004d23a 	srli	r2,r2,8
   10ff8:	117fffcc 	andi	r5,r2,65535
   10ffc:	e0bffe17 	ldw	r2,-8(fp)
   11000:	10800417 	ldw	r2,16(r2)
   11004:	1080030b 	ldhu	r2,12(r2)
   11008:	10bfffcc 	andi	r2,r2,65535
   1100c:	1004923a 	slli	r2,r2,8
   11010:	10bfffcc 	andi	r2,r2,65535
   11014:	2884b03a 	or	r2,r5,r2
   11018:	108000cc 	andi	r2,r2,3
   1101c:	1004c03a 	cmpne	r2,r2,zero
   11020:	10803fcc 	andi	r2,r2,255
   11024:	2085883a 	add	r2,r4,r2
   11028:	1887883a 	add	r3,r3,r2
   1102c:	e0bfff17 	ldw	r2,-4(fp)
   11030:	10c00a15 	stw	r3,40(r2)
          LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
   11034:	e0bfff17 	ldw	r2,-4(fp)
   11038:	10800b0b 	ldhu	r2,44(r2)
   1103c:	10ffffcc 	andi	r3,r2,65535
   11040:	e0bffe17 	ldw	r2,-8(fp)
   11044:	1080030b 	ldhu	r2,12(r2)
   11048:	113fffcc 	andi	r4,r2,65535
   1104c:	e0bffe17 	ldw	r2,-8(fp)
   11050:	10800417 	ldw	r2,16(r2)
   11054:	1080030b 	ldhu	r2,12(r2)
   11058:	10bfffcc 	andi	r2,r2,65535
   1105c:	1004d23a 	srli	r2,r2,8
   11060:	117fffcc 	andi	r5,r2,65535
   11064:	e0bffe17 	ldw	r2,-8(fp)
   11068:	10800417 	ldw	r2,16(r2)
   1106c:	1080030b 	ldhu	r2,12(r2)
   11070:	10bfffcc 	andi	r2,r2,65535
   11074:	1004923a 	slli	r2,r2,8
   11078:	10bfffcc 	andi	r2,r2,65535
   1107c:	2884b03a 	or	r2,r5,r2
   11080:	108000cc 	andi	r2,r2,3
   11084:	1004c03a 	cmpne	r2,r2,zero
   11088:	10803fcc 	andi	r2,r2,255
   1108c:	2085883a 	add	r2,r4,r2
   11090:	1880090e 	bge	r3,r2,110b8 <tcp_receive+0x1618>
   11094:	010000f4 	movhi	r4,3
   11098:	213db804 	addi	r4,r4,-2336
   1109c:	014000f4 	movhi	r5,3
   110a0:	297e7604 	addi	r5,r5,-1576
   110a4:	01813c04 	movi	r6,1264
   110a8:	01c000f4 	movhi	r7,3
   110ac:	39fdcc04 	addi	r7,r7,-2256
   110b0:	00170680 	call	17068 <printf>
   110b4:	003fff06 	br	110b4 <tcp_receive+0x1614>
                      pcb->rcv_wnd >= TCP_TCPLEN(cseg));
          pcb->rcv_wnd -= TCP_TCPLEN(cseg);
   110b8:	e0bfff17 	ldw	r2,-4(fp)
   110bc:	10c00b0b 	ldhu	r3,44(r2)
   110c0:	e0bffe17 	ldw	r2,-8(fp)
   110c4:	1100030b 	ldhu	r4,12(r2)
   110c8:	e0bffe17 	ldw	r2,-8(fp)
   110cc:	10800417 	ldw	r2,16(r2)
   110d0:	1080030b 	ldhu	r2,12(r2)
   110d4:	10bfffcc 	andi	r2,r2,65535
   110d8:	1004d23a 	srli	r2,r2,8
   110dc:	117fffcc 	andi	r5,r2,65535
   110e0:	e0bffe17 	ldw	r2,-8(fp)
   110e4:	10800417 	ldw	r2,16(r2)
   110e8:	1080030b 	ldhu	r2,12(r2)
   110ec:	10bfffcc 	andi	r2,r2,65535
   110f0:	1004923a 	slli	r2,r2,8
   110f4:	10bfffcc 	andi	r2,r2,65535
   110f8:	2884b03a 	or	r2,r5,r2
   110fc:	108000cc 	andi	r2,r2,3
   11100:	1004c03a 	cmpne	r2,r2,zero
   11104:	10803fcc 	andi	r2,r2,255
   11108:	2085883a 	add	r2,r4,r2
   1110c:	1885c83a 	sub	r2,r3,r2
   11110:	1007883a 	mov	r3,r2
   11114:	e0bfff17 	ldw	r2,-4(fp)
   11118:	10c00b0d 	sth	r3,44(r2)

          tcp_update_rcv_ann_wnd(pcb);
   1111c:	e13fff17 	ldw	r4,-4(fp)
   11120:	000bb100 	call	bb10 <tcp_update_rcv_ann_wnd>

          if (cseg->p->tot_len > 0) {
   11124:	e0bffe17 	ldw	r2,-8(fp)
   11128:	10800117 	ldw	r2,4(r2)
   1112c:	1080020b 	ldhu	r2,8(r2)
   11130:	10bfffcc 	andi	r2,r2,65535
   11134:	10000e26 	beq	r2,zero,11170 <tcp_receive+0x16d0>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            if (recv_data) {
   11138:	d0a8e217 	ldw	r2,-23672(gp)
   1113c:	10000726 	beq	r2,zero,1115c <tcp_receive+0x16bc>
              pbuf_cat(recv_data, cseg->p);
   11140:	d0e8e217 	ldw	r3,-23672(gp)
   11144:	e0bffe17 	ldw	r2,-8(fp)
   11148:	10800117 	ldw	r2,4(r2)
   1114c:	1809883a 	mov	r4,r3
   11150:	100b883a 	mov	r5,r2
   11154:	000a3e00 	call	a3e0 <pbuf_cat>
   11158:	00000306 	br	11168 <tcp_receive+0x16c8>
            } else {
              recv_data = cseg->p;
   1115c:	e0bffe17 	ldw	r2,-8(fp)
   11160:	10800117 	ldw	r2,4(r2)
   11164:	d0a8e215 	stw	r2,-23672(gp)
            }
            cseg->p = NULL;
   11168:	e0bffe17 	ldw	r2,-8(fp)
   1116c:	10000115 	stw	zero,4(r2)
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
   11170:	e0bffe17 	ldw	r2,-8(fp)
   11174:	10800417 	ldw	r2,16(r2)
   11178:	1080030b 	ldhu	r2,12(r2)
   1117c:	10bfffcc 	andi	r2,r2,65535
   11180:	1004d23a 	srli	r2,r2,8
   11184:	10ffffcc 	andi	r3,r2,65535
   11188:	e0bffe17 	ldw	r2,-8(fp)
   1118c:	10800417 	ldw	r2,16(r2)
   11190:	1080030b 	ldhu	r2,12(r2)
   11194:	10bfffcc 	andi	r2,r2,65535
   11198:	1004923a 	slli	r2,r2,8
   1119c:	10bfffcc 	andi	r2,r2,65535
   111a0:	1884b03a 	or	r2,r3,r2
   111a4:	1080004c 	andi	r2,r2,1
   111a8:	10000a26 	beq	r2,zero,111d4 <tcp_receive+0x1734>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags |= TF_GOT_FIN;
   111ac:	d0a8e103 	ldbu	r2,-23676(gp)
   111b0:	10800814 	ori	r2,r2,32
   111b4:	d0a8e105 	stb	r2,-23676(gp)
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
   111b8:	e0bfff17 	ldw	r2,-4(fp)
   111bc:	10800417 	ldw	r2,16(r2)
   111c0:	10800118 	cmpnei	r2,r2,4
   111c4:	1000031e 	bne	r2,zero,111d4 <tcp_receive+0x1734>
              pcb->state = CLOSE_WAIT;
   111c8:	e0bfff17 	ldw	r2,-4(fp)
   111cc:	00c001c4 	movi	r3,7
   111d0:	10c00415 	stw	r3,16(r2)
            } 
          }

          pcb->ooseq = cseg->next;
   111d4:	e0bffe17 	ldw	r2,-8(fp)
   111d8:	10c00017 	ldw	r3,0(r2)
   111dc:	e0bfff17 	ldw	r2,-4(fp)
   111e0:	10c02015 	stw	r3,128(r2)
          tcp_seg_free(cseg);
   111e4:	e13ffe17 	ldw	r4,-8(fp)
   111e8:	000ca9c0 	call	ca9c <tcp_seg_free>
   111ec:	00000106 	br	111f4 <tcp_receive+0x1754>
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
   111f0:	0001883a 	nop
   111f4:	e0bfff17 	ldw	r2,-4(fp)
   111f8:	10802017 	ldw	r2,128(r2)
   111fc:	10000b26 	beq	r2,zero,1122c <tcp_receive+0x178c>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
   11200:	e0bfff17 	ldw	r2,-4(fp)
   11204:	10802017 	ldw	r2,128(r2)
   11208:	10800417 	ldw	r2,16(r2)
   1120c:	10c0010b 	ldhu	r3,4(r2)
   11210:	1080018b 	ldhu	r2,6(r2)
   11214:	1004943a 	slli	r2,r2,16
   11218:	10c4b03a 	or	r2,r2,r3
   1121c:	1007883a 	mov	r3,r2
   11220:	e0bfff17 	ldw	r2,-4(fp)
   11224:	10800a17 	ldw	r2,40(r2)
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
   11228:	18bf5e26 	beq	r3,r2,10fa4 <tcp_receive+0x1504>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
   1122c:	e0bfff17 	ldw	r2,-4(fp)
   11230:	10800983 	ldbu	r2,38(r2)
   11234:	10803fcc 	andi	r2,r2,255
   11238:	1080004c 	andi	r2,r2,1
   1123c:	10001026 	beq	r2,zero,11280 <tcp_receive+0x17e0>
   11240:	e0bfff17 	ldw	r2,-4(fp)
   11244:	10c00983 	ldbu	r3,38(r2)
   11248:	00bfff84 	movi	r2,-2
   1124c:	1884703a 	and	r2,r3,r2
   11250:	1007883a 	mov	r3,r2
   11254:	e0bfff17 	ldw	r2,-4(fp)
   11258:	10c00985 	stb	r3,38(r2)
   1125c:	e0bfff17 	ldw	r2,-4(fp)
   11260:	10800983 	ldbu	r2,38(r2)
   11264:	10800094 	ori	r2,r2,2
   11268:	1007883a 	mov	r3,r2
   1126c:	e0bfff17 	ldw	r2,-4(fp)
   11270:	10c00985 	stb	r3,38(r2)
   11274:	e13fff17 	ldw	r4,-4(fp)
   11278:	0012b000 	call	12b00 <tcp_output>
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
   1127c:	00010b06 	br	116ac <tcp_receive+0x1c0c>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
   11280:	e0bfff17 	ldw	r2,-4(fp)
   11284:	10800983 	ldbu	r2,38(r2)
   11288:	10800054 	ori	r2,r2,1
   1128c:	1007883a 	mov	r3,r2
   11290:	e0bfff17 	ldw	r2,-4(fp)
   11294:	10c00985 	stb	r3,38(r2)
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
   11298:	00010406 	br	116ac <tcp_receive+0x1c0c>
        /* Acknowledge the segment(s). */
        tcp_ack(pcb);

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_send_empty_ack(pcb);
   1129c:	e13fff17 	ldw	r4,-4(fp)
   112a0:	00129a40 	call	129a4 <tcp_send_empty_ack>
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
   112a4:	e0bfff17 	ldw	r2,-4(fp)
   112a8:	10802017 	ldw	r2,128(r2)
   112ac:	1000061e 	bne	r2,zero,112c8 <tcp_receive+0x1828>
          pcb->ooseq = tcp_seg_copy(&inseg);
   112b0:	01000134 	movhi	r4,4
   112b4:	2110c604 	addi	r4,r4,17176
   112b8:	000cb3c0 	call	cb3c <tcp_seg_copy>
   112bc:	e0ffff17 	ldw	r3,-4(fp)
   112c0:	18802015 	stw	r2,128(r3)
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
   112c4:	0000f906 	br	116ac <tcp_receive+0x1c0c>

             If the incoming segment has the same sequence number as a
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
   112c8:	e03ff415 	stw	zero,-48(fp)
          for(next = pcb->ooseq; next != NULL; next = next->next) {
   112cc:	e0bfff17 	ldw	r2,-4(fp)
   112d0:	10802017 	ldw	r2,128(r2)
   112d4:	e0bff315 	stw	r2,-52(fp)
   112d8:	0000ca06 	br	11604 <tcp_receive+0x1b64>
            if (seqno == next->tcphdr->seqno) {
   112dc:	e0bff317 	ldw	r2,-52(fp)
   112e0:	10800417 	ldw	r2,16(r2)
   112e4:	10c0010b 	ldhu	r3,4(r2)
   112e8:	1080018b 	ldhu	r2,6(r2)
   112ec:	1004943a 	slli	r2,r2,16
   112f0:	10c4b03a 	or	r2,r2,r3
   112f4:	1007883a 	mov	r3,r2
   112f8:	d0a8de17 	ldw	r2,-23688(gp)
   112fc:	18801b1e 	bne	r3,r2,1136c <tcp_receive+0x18cc>
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
   11300:	00800134 	movhi	r2,4
   11304:	1090c604 	addi	r2,r2,17176
   11308:	1080030b 	ldhu	r2,12(r2)
   1130c:	e0fff317 	ldw	r3,-52(fp)
   11310:	18c0030b 	ldhu	r3,12(r3)
   11314:	10bfffcc 	andi	r2,r2,65535
   11318:	18ffffcc 	andi	r3,r3,65535
   1131c:	1880bc2e 	bgeu	r3,r2,11610 <tcp_receive+0x1b70>
                /* The incoming segment is larger than the old
                   segment. We replace some segments with the new
                   one. */
                cseg = tcp_seg_copy(&inseg);
   11320:	01000134 	movhi	r4,4
   11324:	2110c604 	addi	r4,r4,17176
   11328:	000cb3c0 	call	cb3c <tcp_seg_copy>
   1132c:	e0bffe15 	stw	r2,-8(fp)
                if (cseg != NULL) {
   11330:	e0bffe17 	ldw	r2,-8(fp)
   11334:	1000b826 	beq	r2,zero,11618 <tcp_receive+0x1b78>
                  if (prev != NULL) {
   11338:	e0bff417 	ldw	r2,-48(fp)
   1133c:	10000426 	beq	r2,zero,11350 <tcp_receive+0x18b0>
                    prev->next = cseg;
   11340:	e0bff417 	ldw	r2,-48(fp)
   11344:	e0fffe17 	ldw	r3,-8(fp)
   11348:	10c00015 	stw	r3,0(r2)
   1134c:	00000306 	br	1135c <tcp_receive+0x18bc>
                  } else {
                    pcb->ooseq = cseg;
   11350:	e0bfff17 	ldw	r2,-4(fp)
   11354:	e0fffe17 	ldw	r3,-8(fp)
   11358:	10c02015 	stw	r3,128(r2)
                  }
                  tcp_oos_insert_segment(cseg, next);
   1135c:	e13ffe17 	ldw	r4,-8(fp)
   11360:	e17ff317 	ldw	r5,-52(fp)
   11364:	000f8840 	call	f884 <tcp_oos_insert_segment>
                }
                break;
   11368:	0000ab06 	br	11618 <tcp_receive+0x1b78>
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
              }
            } else {
              if (prev == NULL) {
   1136c:	e0bff417 	ldw	r2,-48(fp)
   11370:	1000161e 	bne	r2,zero,113cc <tcp_receive+0x192c>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
   11374:	d0e8de17 	ldw	r3,-23688(gp)
   11378:	e0bff317 	ldw	r2,-52(fp)
   1137c:	10800417 	ldw	r2,16(r2)
   11380:	1100010b 	ldhu	r4,4(r2)
   11384:	1080018b 	ldhu	r2,6(r2)
   11388:	1004943a 	slli	r2,r2,16
   1138c:	1104b03a 	or	r2,r2,r4
   11390:	1885c83a 	sub	r2,r3,r2
   11394:	1000500e 	bge	r2,zero,114d8 <tcp_receive+0x1a38>
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */
                  cseg = tcp_seg_copy(&inseg);
   11398:	01000134 	movhi	r4,4
   1139c:	2110c604 	addi	r4,r4,17176
   113a0:	000cb3c0 	call	cb3c <tcp_seg_copy>
   113a4:	e0bffe15 	stw	r2,-8(fp)
                  if (cseg != NULL) {
   113a8:	e0bffe17 	ldw	r2,-8(fp)
   113ac:	10009c26 	beq	r2,zero,11620 <tcp_receive+0x1b80>
                    pcb->ooseq = cseg;
   113b0:	e0bfff17 	ldw	r2,-4(fp)
   113b4:	e0fffe17 	ldw	r3,-8(fp)
   113b8:	10c02015 	stw	r3,128(r2)
                    tcp_oos_insert_segment(cseg, next);
   113bc:	e13ffe17 	ldw	r4,-8(fp)
   113c0:	e17ff317 	ldw	r5,-52(fp)
   113c4:	000f8840 	call	f884 <tcp_oos_insert_segment>
                  }
                  break;
   113c8:	00009506 	br	11620 <tcp_receive+0x1b80>
                }
              } else {
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)) {
   113cc:	e0bff417 	ldw	r2,-48(fp)
   113d0:	10800417 	ldw	r2,16(r2)
   113d4:	10c0010b 	ldhu	r3,4(r2)
   113d8:	1080018b 	ldhu	r2,6(r2)
   113dc:	1004943a 	slli	r2,r2,16
   113e0:	10c4b03a 	or	r2,r2,r3
   113e4:	0086303a 	nor	r3,zero,r2
   113e8:	d0a8de17 	ldw	r2,-23688(gp)
   113ec:	1885883a 	add	r2,r3,r2
   113f0:	10003916 	blt	r2,zero,114d8 <tcp_receive+0x1a38>
   113f4:	d0e8de17 	ldw	r3,-23688(gp)
   113f8:	e0bff317 	ldw	r2,-52(fp)
   113fc:	10800417 	ldw	r2,16(r2)
   11400:	1100010b 	ldhu	r4,4(r2)
   11404:	1080018b 	ldhu	r2,6(r2)
   11408:	1004943a 	slli	r2,r2,16
   1140c:	1104b03a 	or	r2,r2,r4
   11410:	1885c83a 	sub	r2,r3,r2
   11414:	10800044 	addi	r2,r2,1
   11418:	00802f16 	blt	zero,r2,114d8 <tcp_receive+0x1a38>
                  /* The sequence number of the incoming segment is in
                     between the sequence numbers of the previous and
                     the next segment on ->ooseq. We trim trim the previous
                     segment, delete next segments that included in received segment
                     and trim received, if needed. */
                  cseg = tcp_seg_copy(&inseg);
   1141c:	01000134 	movhi	r4,4
   11420:	2110c604 	addi	r4,r4,17176
   11424:	000cb3c0 	call	cb3c <tcp_seg_copy>
   11428:	e0bffe15 	stw	r2,-8(fp)
                  if (cseg != NULL) {
   1142c:	e0bffe17 	ldw	r2,-8(fp)
   11430:	10007d26 	beq	r2,zero,11628 <tcp_receive+0x1b88>
                    if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
   11434:	e0bff417 	ldw	r2,-48(fp)
   11438:	10800417 	ldw	r2,16(r2)
   1143c:	10c0010b 	ldhu	r3,4(r2)
   11440:	1080018b 	ldhu	r2,6(r2)
   11444:	1004943a 	slli	r2,r2,16
   11448:	10c4b03a 	or	r2,r2,r3
   1144c:	1007883a 	mov	r3,r2
   11450:	e0bff417 	ldw	r2,-48(fp)
   11454:	1080030b 	ldhu	r2,12(r2)
   11458:	10bfffcc 	andi	r2,r2,65535
   1145c:	1887883a 	add	r3,r3,r2
   11460:	d0a8de17 	ldw	r2,-23688(gp)
   11464:	1885c83a 	sub	r2,r3,r2
   11468:	0080140e 	bge	zero,r2,114bc <tcp_receive+0x1a1c>
                      /* We need to trim the prev segment. */
                      prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
   1146c:	d0a8de17 	ldw	r2,-23688(gp)
   11470:	1007883a 	mov	r3,r2
   11474:	e0bff417 	ldw	r2,-48(fp)
   11478:	10800417 	ldw	r2,16(r2)
   1147c:	1100010b 	ldhu	r4,4(r2)
   11480:	1080018b 	ldhu	r2,6(r2)
   11484:	1004943a 	slli	r2,r2,16
   11488:	1104b03a 	or	r2,r2,r4
   1148c:	1885c83a 	sub	r2,r3,r2
   11490:	1007883a 	mov	r3,r2
   11494:	e0bff417 	ldw	r2,-48(fp)
   11498:	10c0030d 	sth	r3,12(r2)
                      pbuf_realloc(prev->p, prev->len);
   1149c:	e0bff417 	ldw	r2,-48(fp)
   114a0:	10c00117 	ldw	r3,4(r2)
   114a4:	e0bff417 	ldw	r2,-48(fp)
   114a8:	1080030b 	ldhu	r2,12(r2)
   114ac:	10bfffcc 	andi	r2,r2,65535
   114b0:	1809883a 	mov	r4,r3
   114b4:	100b883a 	mov	r5,r2
   114b8:	0009d0c0 	call	9d0c <pbuf_realloc>
                    }
                    prev->next = cseg;
   114bc:	e0bff417 	ldw	r2,-48(fp)
   114c0:	e0fffe17 	ldw	r3,-8(fp)
   114c4:	10c00015 	stw	r3,0(r2)
                    tcp_oos_insert_segment(cseg, next);
   114c8:	e13ffe17 	ldw	r4,-8(fp)
   114cc:	e17ff317 	ldw	r5,-52(fp)
   114d0:	000f8840 	call	f884 <tcp_oos_insert_segment>
                  }
                  break;
   114d4:	00005406 	br	11628 <tcp_receive+0x1b88>
                }
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
   114d8:	e0bff317 	ldw	r2,-52(fp)
   114dc:	10800017 	ldw	r2,0(r2)
   114e0:	1000431e 	bne	r2,zero,115f0 <tcp_receive+0x1b50>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
   114e4:	d0e8de17 	ldw	r3,-23688(gp)
   114e8:	e0bff317 	ldw	r2,-52(fp)
   114ec:	10800417 	ldw	r2,16(r2)
   114f0:	1100010b 	ldhu	r4,4(r2)
   114f4:	1080018b 	ldhu	r2,6(r2)
   114f8:	1004943a 	slli	r2,r2,16
   114fc:	1104b03a 	or	r2,r2,r4
   11500:	1885c83a 	sub	r2,r3,r2
                }
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
   11504:	00803a0e 	bge	zero,r2,115f0 <tcp_receive+0x1b50>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
   11508:	e0bff317 	ldw	r2,-52(fp)
   1150c:	10800417 	ldw	r2,16(r2)
   11510:	1080030b 	ldhu	r2,12(r2)
   11514:	10bfffcc 	andi	r2,r2,65535
   11518:	1004d23a 	srli	r2,r2,8
   1151c:	10ffffcc 	andi	r3,r2,65535
   11520:	e0bff317 	ldw	r2,-52(fp)
   11524:	10800417 	ldw	r2,16(r2)
   11528:	1080030b 	ldhu	r2,12(r2)
   1152c:	10bfffcc 	andi	r2,r2,65535
   11530:	1004923a 	slli	r2,r2,8
   11534:	10bfffcc 	andi	r2,r2,65535
   11538:	1884b03a 	or	r2,r3,r2
   1153c:	1080004c 	andi	r2,r2,1
   11540:	10003b1e 	bne	r2,zero,11630 <tcp_receive+0x1b90>
                  /* segment "next" already contains all data */
                  break;
                }
                next->next = tcp_seg_copy(&inseg);
   11544:	01000134 	movhi	r4,4
   11548:	2110c604 	addi	r4,r4,17176
   1154c:	000cb3c0 	call	cb3c <tcp_seg_copy>
   11550:	e0fff317 	ldw	r3,-52(fp)
   11554:	18800015 	stw	r2,0(r3)
                if (next->next != NULL) {
   11558:	e0bff317 	ldw	r2,-52(fp)
   1155c:	10800017 	ldw	r2,0(r2)
   11560:	10003526 	beq	r2,zero,11638 <tcp_receive+0x1b98>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
   11564:	e0bff317 	ldw	r2,-52(fp)
   11568:	10800417 	ldw	r2,16(r2)
   1156c:	10c0010b 	ldhu	r3,4(r2)
   11570:	1080018b 	ldhu	r2,6(r2)
   11574:	1004943a 	slli	r2,r2,16
   11578:	10c4b03a 	or	r2,r2,r3
   1157c:	1007883a 	mov	r3,r2
   11580:	e0bff317 	ldw	r2,-52(fp)
   11584:	1080030b 	ldhu	r2,12(r2)
   11588:	10bfffcc 	andi	r2,r2,65535
   1158c:	1887883a 	add	r3,r3,r2
   11590:	d0a8de17 	ldw	r2,-23688(gp)
   11594:	1885c83a 	sub	r2,r3,r2
   11598:	0080270e 	bge	zero,r2,11638 <tcp_receive+0x1b98>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
   1159c:	d0a8de17 	ldw	r2,-23688(gp)
   115a0:	1007883a 	mov	r3,r2
   115a4:	e0bff317 	ldw	r2,-52(fp)
   115a8:	10800417 	ldw	r2,16(r2)
   115ac:	1100010b 	ldhu	r4,4(r2)
   115b0:	1080018b 	ldhu	r2,6(r2)
   115b4:	1004943a 	slli	r2,r2,16
   115b8:	1104b03a 	or	r2,r2,r4
   115bc:	1885c83a 	sub	r2,r3,r2
   115c0:	1007883a 	mov	r3,r2
   115c4:	e0bff317 	ldw	r2,-52(fp)
   115c8:	10c0030d 	sth	r3,12(r2)
                    pbuf_realloc(next->p, next->len);
   115cc:	e0bff317 	ldw	r2,-52(fp)
   115d0:	10c00117 	ldw	r3,4(r2)
   115d4:	e0bff317 	ldw	r2,-52(fp)
   115d8:	1080030b 	ldhu	r2,12(r2)
   115dc:	10bfffcc 	andi	r2,r2,65535
   115e0:	1809883a 	mov	r4,r3
   115e4:	100b883a 	mov	r5,r2
   115e8:	0009d0c0 	call	9d0c <pbuf_realloc>
                  }
                }
                break;
   115ec:	00001206 	br	11638 <tcp_receive+0x1b98>
              }
            }
            prev = next;
   115f0:	e0bff317 	ldw	r2,-52(fp)
   115f4:	e0bff415 	stw	r2,-48(fp)
             If the incoming segment has the same sequence number as a
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
   115f8:	e0bff317 	ldw	r2,-52(fp)
   115fc:	10800017 	ldw	r2,0(r2)
   11600:	e0bff315 	stw	r2,-52(fp)
   11604:	e0bff317 	ldw	r2,-52(fp)
   11608:	103f341e 	bne	r2,zero,112dc <tcp_receive+0x183c>
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
   1160c:	00002706 	br	116ac <tcp_receive+0x1c0c>
                break;
              } else {
                /* Either the lenghts are the same or the incoming
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
   11610:	0001883a 	nop
   11614:	00000906 	br	1163c <tcp_receive+0x1b9c>
                  } else {
                    pcb->ooseq = cseg;
                  }
                  tcp_oos_insert_segment(cseg, next);
                }
                break;
   11618:	0001883a 	nop
   1161c:	00000706 	br	1163c <tcp_receive+0x1b9c>
                  cseg = tcp_seg_copy(&inseg);
                  if (cseg != NULL) {
                    pcb->ooseq = cseg;
                    tcp_oos_insert_segment(cseg, next);
                  }
                  break;
   11620:	0001883a 	nop
   11624:	00000506 	br	1163c <tcp_receive+0x1b9c>
                      pbuf_realloc(prev->p, prev->len);
                    }
                    prev->next = cseg;
                    tcp_oos_insert_segment(cseg, next);
                  }
                  break;
   11628:	0001883a 	nop
   1162c:	00000306 	br	1163c <tcp_receive+0x1b9c>
                 of the list. */
              if (next->next == NULL &&
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
                  /* segment "next" already contains all data */
                  break;
   11630:	0001883a 	nop
   11634:	00000106 	br	1163c <tcp_receive+0x1b9c>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
                    pbuf_realloc(next->p, next->len);
                  }
                }
                break;
   11638:	0001883a 	nop
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
   1163c:	0001883a 	nop
   11640:	00001a06 	br	116ac <tcp_receive+0x1c0c>
#endif /* TCP_QUEUE_OOSEQ */

      }
    } else {
      /* The incoming segment is not withing the window. */
      tcp_send_empty_ack(pcb);
   11644:	e13fff17 	ldw	r4,-4(fp)
   11648:	00129a40 	call	129a4 <tcp_send_empty_ack>
   1164c:	00001706 	br	116ac <tcp_receive+0x1c0c>
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
   11650:	d0e8de17 	ldw	r3,-23688(gp)
   11654:	e0bfff17 	ldw	r2,-4(fp)
   11658:	10800a17 	ldw	r2,40(r2)
   1165c:	1885c83a 	sub	r2,r3,r2
   11660:	10000a16 	blt	r2,zero,1168c <tcp_receive+0x1bec>
   11664:	d0e8de17 	ldw	r3,-23688(gp)
   11668:	e0bfff17 	ldw	r2,-4(fp)
   1166c:	11000a17 	ldw	r4,40(r2)
   11670:	e0bfff17 	ldw	r2,-4(fp)
   11674:	10800b0b 	ldhu	r2,44(r2)
   11678:	10bfffcc 	andi	r2,r2,65535
   1167c:	2085883a 	add	r2,r4,r2
   11680:	1885c83a 	sub	r2,r3,r2
   11684:	10800044 	addi	r2,r2,1
   11688:	0080080e 	bge	zero,r2,116ac <tcp_receive+0x1c0c>
      tcp_ack_now(pcb);
   1168c:	e0bfff17 	ldw	r2,-4(fp)
   11690:	10800983 	ldbu	r2,38(r2)
   11694:	10800094 	ori	r2,r2,2
   11698:	1007883a 	mov	r3,r2
   1169c:	e0bfff17 	ldw	r2,-4(fp)
   116a0:	10c00985 	stb	r3,38(r2)
   116a4:	e13fff17 	ldw	r4,-4(fp)
   116a8:	0012b000 	call	12b00 <tcp_output>
    }
  }
}
   116ac:	e037883a 	mov	sp,fp
   116b0:	dfc00217 	ldw	ra,8(sp)
   116b4:	df000117 	ldw	fp,4(sp)
   116b8:	dc000017 	ldw	r16,0(sp)
   116bc:	dec00304 	addi	sp,sp,12
   116c0:	f800283a 	ret

000116c4 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
   116c4:	defffa04 	addi	sp,sp,-24
   116c8:	df000515 	stw	fp,20(sp)
   116cc:	df000504 	addi	fp,sp,20
   116d0:	e13fff15 	stw	r4,-4(fp)
  u8_t *opts, opt;
#if LWIP_TCP_TIMESTAMPS
  u32_t tsval;
#endif

  opts = (u8_t *)tcphdr + TCP_HLEN;
   116d4:	d0a8dc17 	ldw	r2,-23696(gp)
   116d8:	10800504 	addi	r2,r2,20
   116dc:	e0bffc15 	stw	r2,-16(fp)

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
   116e0:	d0a8dc17 	ldw	r2,-23696(gp)
   116e4:	1080030b 	ldhu	r2,12(r2)
   116e8:	10bfffcc 	andi	r2,r2,65535
   116ec:	1004d23a 	srli	r2,r2,8
   116f0:	10ffffcc 	andi	r3,r2,65535
   116f4:	d0a8dc17 	ldw	r2,-23696(gp)
   116f8:	1080030b 	ldhu	r2,12(r2)
   116fc:	10bfffcc 	andi	r2,r2,65535
   11700:	1004923a 	slli	r2,r2,8
   11704:	10bfffcc 	andi	r2,r2,65535
   11708:	1884b03a 	or	r2,r3,r2
   1170c:	1005d33a 	srai	r2,r2,12
   11710:	10800190 	cmplti	r2,r2,6
   11714:	1000651e 	bne	r2,zero,118ac <tcp_parseopt+0x1e8>
    max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
   11718:	d0a8dc17 	ldw	r2,-23696(gp)
   1171c:	1080030b 	ldhu	r2,12(r2)
   11720:	10bfffcc 	andi	r2,r2,65535
   11724:	1004d23a 	srli	r2,r2,8
   11728:	10ffffcc 	andi	r3,r2,65535
   1172c:	d0a8dc17 	ldw	r2,-23696(gp)
   11730:	1080030b 	ldhu	r2,12(r2)
   11734:	10bfffcc 	andi	r2,r2,65535
   11738:	1004923a 	slli	r2,r2,8
   1173c:	10bfffcc 	andi	r2,r2,65535
   11740:	1884b03a 	or	r2,r3,r2
   11744:	1005d33a 	srai	r2,r2,12
   11748:	10bffec4 	addi	r2,r2,-5
   1174c:	1085883a 	add	r2,r2,r2
   11750:	1085883a 	add	r2,r2,r2
   11754:	e0bffd0d 	sth	r2,-12(fp)
    for (c = 0; c < max_c; ) {
   11758:	e03ffb0d 	sth	zero,-20(fp)
   1175c:	00004a06 	br	11888 <tcp_parseopt+0x1c4>
      opt = opts[c];
   11760:	e0bffb0b 	ldhu	r2,-20(fp)
   11764:	e0fffc17 	ldw	r3,-16(fp)
   11768:	1885883a 	add	r2,r3,r2
   1176c:	10800003 	ldbu	r2,0(r2)
   11770:	e0bffd85 	stb	r2,-10(fp)
      switch (opt) {
   11774:	e0bffd83 	ldbu	r2,-10(fp)
   11778:	10c00060 	cmpeqi	r3,r2,1
   1177c:	1800041e 	bne	r3,zero,11790 <tcp_parseopt+0xcc>
   11780:	10c000a0 	cmpeqi	r3,r2,2
   11784:	1800061e 	bne	r3,zero,117a0 <tcp_parseopt+0xdc>
   11788:	10004326 	beq	r2,zero,11898 <tcp_parseopt+0x1d4>
   1178c:	00002e06 	br	11848 <tcp_parseopt+0x184>
        /* End of options. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: EOL\n"));
        return;
      case 0x01:
        /* NOP option. */
        ++c;
   11790:	e0bffb0b 	ldhu	r2,-20(fp)
   11794:	10800044 	addi	r2,r2,1
   11798:	e0bffb0d 	sth	r2,-20(fp)
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: NOP\n"));
        break;
   1179c:	00003a06 	br	11888 <tcp_parseopt+0x1c4>
      case 0x02:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
        if (opts[c + 1] != 0x04 || c + 0x04 > max_c) {
   117a0:	e0bffb0b 	ldhu	r2,-20(fp)
   117a4:	10800044 	addi	r2,r2,1
   117a8:	e0fffc17 	ldw	r3,-16(fp)
   117ac:	1885883a 	add	r2,r3,r2
   117b0:	10800003 	ldbu	r2,0(r2)
   117b4:	10803fcc 	andi	r2,r2,255
   117b8:	10800118 	cmpnei	r2,r2,4
   117bc:	1000381e 	bne	r2,zero,118a0 <tcp_parseopt+0x1dc>
   117c0:	e0bffb0b 	ldhu	r2,-20(fp)
   117c4:	10800104 	addi	r2,r2,4
   117c8:	e0fffd0b 	ldhu	r3,-12(fp)
   117cc:	18803416 	blt	r3,r2,118a0 <tcp_parseopt+0x1dc>
          /* Bad length */
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
          return;
        }
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
   117d0:	e0bffb0b 	ldhu	r2,-20(fp)
   117d4:	10800084 	addi	r2,r2,2
   117d8:	e0fffc17 	ldw	r3,-16(fp)
   117dc:	1885883a 	add	r2,r3,r2
   117e0:	10800003 	ldbu	r2,0(r2)
   117e4:	10803fcc 	andi	r2,r2,255
   117e8:	1004923a 	slli	r2,r2,8
   117ec:	1007883a 	mov	r3,r2
   117f0:	e0bffb0b 	ldhu	r2,-20(fp)
   117f4:	108000c4 	addi	r2,r2,3
   117f8:	e13ffc17 	ldw	r4,-16(fp)
   117fc:	2085883a 	add	r2,r4,r2
   11800:	10800003 	ldbu	r2,0(r2)
   11804:	10803fcc 	andi	r2,r2,255
   11808:	1884b03a 	or	r2,r3,r2
   1180c:	e0bffe0d 	sth	r2,-8(fp)
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
   11810:	e0bffe0b 	ldhu	r2,-8(fp)
   11814:	10816d68 	cmpgeui	r2,r2,1461
   11818:	1000041e 	bne	r2,zero,1182c <tcp_parseopt+0x168>
   1181c:	e0bffe0b 	ldhu	r2,-8(fp)
   11820:	10000226 	beq	r2,zero,1182c <tcp_parseopt+0x168>
   11824:	e0bffe0b 	ldhu	r2,-8(fp)
   11828:	00000106 	br	11830 <tcp_parseopt+0x16c>
   1182c:	00816d04 	movi	r2,1460
   11830:	e0ffff17 	ldw	r3,-4(fp)
   11834:	18800f0d 	sth	r2,60(r3)
        /* Advance to next option */
        c += 0x04;
   11838:	e0bffb0b 	ldhu	r2,-20(fp)
   1183c:	10800104 	addi	r2,r2,4
   11840:	e0bffb0d 	sth	r2,-20(fp)
        break;
   11844:	00001006 	br	11888 <tcp_parseopt+0x1c4>
        c += 0x0A;
        break;
#endif
      default:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
        if (opts[c + 1] == 0) {
   11848:	e0bffb0b 	ldhu	r2,-20(fp)
   1184c:	10800044 	addi	r2,r2,1
   11850:	e0fffc17 	ldw	r3,-16(fp)
   11854:	1885883a 	add	r2,r3,r2
   11858:	10800003 	ldbu	r2,0(r2)
   1185c:	10803fcc 	andi	r2,r2,255
   11860:	10001126 	beq	r2,zero,118a8 <tcp_parseopt+0x1e4>
             and we don't process them further. */
          return;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
   11864:	e0bffb0b 	ldhu	r2,-20(fp)
   11868:	10800044 	addi	r2,r2,1
   1186c:	e0fffc17 	ldw	r3,-16(fp)
   11870:	1885883a 	add	r2,r3,r2
   11874:	10800003 	ldbu	r2,0(r2)
   11878:	10c03fcc 	andi	r3,r2,255
   1187c:	e0bffb0b 	ldhu	r2,-20(fp)
   11880:	1885883a 	add	r2,r3,r2
   11884:	e0bffb0d 	sth	r2,-20(fp)
  opts = (u8_t *)tcphdr + TCP_HLEN;

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
    for (c = 0; c < max_c; ) {
   11888:	e0fffb0b 	ldhu	r3,-20(fp)
   1188c:	e0bffd0b 	ldhu	r2,-12(fp)
   11890:	18bfb336 	bltu	r3,r2,11760 <tcp_parseopt+0x9c>
   11894:	00000506 	br	118ac <tcp_parseopt+0x1e8>
      opt = opts[c];
      switch (opt) {
      case 0x00:
        /* End of options. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: EOL\n"));
        return;
   11898:	0001883a 	nop
   1189c:	00000306 	br	118ac <tcp_parseopt+0x1e8>
      case 0x02:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
        if (opts[c + 1] != 0x04 || c + 0x04 > max_c) {
          /* Bad length */
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
          return;
   118a0:	0001883a 	nop
   118a4:	00000106 	br	118ac <tcp_parseopt+0x1e8>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
        if (opts[c + 1] == 0) {
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
          /* If the length field is zero, the options are malformed
             and we don't process them further. */
          return;
   118a8:	0001883a 	nop
           can skip past them. */
        c += opts[c + 1];
      }
    }
  }
}
   118ac:	e037883a 	mov	sp,fp
   118b0:	df000017 	ldw	fp,0(sp)
   118b4:	dec00104 	addi	sp,sp,4
   118b8:	f800283a 	ret

000118bc <tcp_output_set_header>:
static void tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb);

static struct tcp_hdr *
tcp_output_set_header(struct tcp_pcb *pcb, struct pbuf *p, int optlen,
                      u32_t seqno_be /* already in network byte order */)
{
   118bc:	defffa04 	addi	sp,sp,-24
   118c0:	df000515 	stw	fp,20(sp)
   118c4:	df000504 	addi	fp,sp,20
   118c8:	e13ffc15 	stw	r4,-16(fp)
   118cc:	e17ffd15 	stw	r5,-12(fp)
   118d0:	e1bffe15 	stw	r6,-8(fp)
   118d4:	e1ffff15 	stw	r7,-4(fp)
  struct tcp_hdr *tcphdr = p->payload;
   118d8:	e0bffd17 	ldw	r2,-12(fp)
   118dc:	10800117 	ldw	r2,4(r2)
   118e0:	e0bffb15 	stw	r2,-20(fp)
  tcphdr->src = htons(pcb->local_port);
   118e4:	e0bffc17 	ldw	r2,-16(fp)
   118e8:	1080070b 	ldhu	r2,28(r2)
   118ec:	10bfffcc 	andi	r2,r2,65535
   118f0:	1004d23a 	srli	r2,r2,8
   118f4:	1007883a 	mov	r3,r2
   118f8:	e0bffc17 	ldw	r2,-16(fp)
   118fc:	1080070b 	ldhu	r2,28(r2)
   11900:	10bfffcc 	andi	r2,r2,65535
   11904:	1004923a 	slli	r2,r2,8
   11908:	1884b03a 	or	r2,r3,r2
   1190c:	1007883a 	mov	r3,r2
   11910:	e0bffb17 	ldw	r2,-20(fp)
   11914:	10c0000d 	sth	r3,0(r2)
  tcphdr->dest = htons(pcb->remote_port);
   11918:	e0bffc17 	ldw	r2,-16(fp)
   1191c:	1080090b 	ldhu	r2,36(r2)
   11920:	10bfffcc 	andi	r2,r2,65535
   11924:	1004d23a 	srli	r2,r2,8
   11928:	1007883a 	mov	r3,r2
   1192c:	e0bffc17 	ldw	r2,-16(fp)
   11930:	1080090b 	ldhu	r2,36(r2)
   11934:	10bfffcc 	andi	r2,r2,65535
   11938:	1004923a 	slli	r2,r2,8
   1193c:	1884b03a 	or	r2,r3,r2
   11940:	1007883a 	mov	r3,r2
   11944:	e0bffb17 	ldw	r2,-20(fp)
   11948:	10c0008d 	sth	r3,2(r2)
  tcphdr->seqno = seqno_be;
   1194c:	e0bffb17 	ldw	r2,-20(fp)
   11950:	e0ffff17 	ldw	r3,-4(fp)
   11954:	18ffffcc 	andi	r3,r3,65535
   11958:	1100010b 	ldhu	r4,4(r2)
   1195c:	2008703a 	and	r4,r4,zero
   11960:	20c6b03a 	or	r3,r4,r3
   11964:	10c0010d 	sth	r3,4(r2)
   11968:	e0ffff17 	ldw	r3,-4(fp)
   1196c:	1806d43a 	srli	r3,r3,16
   11970:	1100018b 	ldhu	r4,6(r2)
   11974:	2008703a 	and	r4,r4,zero
   11978:	20c6b03a 	or	r3,r4,r3
   1197c:	10c0018d 	sth	r3,6(r2)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
   11980:	e0bffc17 	ldw	r2,-16(fp)
   11984:	10800a17 	ldw	r2,40(r2)
   11988:	1006d63a 	srli	r3,r2,24
   1198c:	e0bffc17 	ldw	r2,-16(fp)
   11990:	10800a17 	ldw	r2,40(r2)
   11994:	1004d23a 	srli	r2,r2,8
   11998:	10bfc00c 	andi	r2,r2,65280
   1199c:	1886b03a 	or	r3,r3,r2
   119a0:	e0bffc17 	ldw	r2,-16(fp)
   119a4:	10800a17 	ldw	r2,40(r2)
   119a8:	10bfc00c 	andi	r2,r2,65280
   119ac:	1004923a 	slli	r2,r2,8
   119b0:	1886b03a 	or	r3,r3,r2
   119b4:	e0bffc17 	ldw	r2,-16(fp)
   119b8:	10800a17 	ldw	r2,40(r2)
   119bc:	1004963a 	slli	r2,r2,24
   119c0:	1886b03a 	or	r3,r3,r2
   119c4:	e0bffb17 	ldw	r2,-20(fp)
   119c8:	193fffcc 	andi	r4,r3,65535
   119cc:	1140020b 	ldhu	r5,8(r2)
   119d0:	280a703a 	and	r5,r5,zero
   119d4:	2908b03a 	or	r4,r5,r4
   119d8:	1100020d 	sth	r4,8(r2)
   119dc:	1806d43a 	srli	r3,r3,16
   119e0:	1100028b 	ldhu	r4,10(r2)
   119e4:	2008703a 	and	r4,r4,zero
   119e8:	20c6b03a 	or	r3,r4,r3
   119ec:	10c0028d 	sth	r3,10(r2)
  TCPH_FLAGS_SET(tcphdr, TCP_ACK);
   119f0:	e0bffb17 	ldw	r2,-20(fp)
   119f4:	10c0030b 	ldhu	r3,12(r2)
   119f8:	00b03fc4 	movi	r2,-16129
   119fc:	1884703a 	and	r2,r3,r2
   11a00:	10840014 	ori	r2,r2,4096
   11a04:	1007883a 	mov	r3,r2
   11a08:	e0bffb17 	ldw	r2,-20(fp)
   11a0c:	10c0030d 	sth	r3,12(r2)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
   11a10:	e0bffc17 	ldw	r2,-16(fp)
   11a14:	10800b8b 	ldhu	r2,46(r2)
   11a18:	10bfffcc 	andi	r2,r2,65535
   11a1c:	1004d23a 	srli	r2,r2,8
   11a20:	1007883a 	mov	r3,r2
   11a24:	e0bffc17 	ldw	r2,-16(fp)
   11a28:	10800b8b 	ldhu	r2,46(r2)
   11a2c:	10bfffcc 	andi	r2,r2,65535
   11a30:	1004923a 	slli	r2,r2,8
   11a34:	1884b03a 	or	r2,r3,r2
   11a38:	1007883a 	mov	r3,r2
   11a3c:	e0bffb17 	ldw	r2,-20(fp)
   11a40:	10c0038d 	sth	r3,14(r2)
  tcphdr->urgp = 0;
   11a44:	e0bffb17 	ldw	r2,-20(fp)
   11a48:	1000048d 	sth	zero,18(r2)
  TCPH_HDRLEN_SET(tcphdr, (5 + optlen / 4));
   11a4c:	e0bffe17 	ldw	r2,-8(fp)
   11a50:	1000010e 	bge	r2,zero,11a58 <tcp_output_set_header+0x19c>
   11a54:	108000c4 	addi	r2,r2,3
   11a58:	1005d0ba 	srai	r2,r2,2
   11a5c:	10800144 	addi	r2,r2,5
   11a60:	1004933a 	slli	r2,r2,12
   11a64:	1007883a 	mov	r3,r2
   11a68:	e0bffb17 	ldw	r2,-20(fp)
   11a6c:	1080030b 	ldhu	r2,12(r2)
   11a70:	10bfffcc 	andi	r2,r2,65535
   11a74:	1004d23a 	srli	r2,r2,8
   11a78:	113fffcc 	andi	r4,r2,65535
   11a7c:	e0bffb17 	ldw	r2,-20(fp)
   11a80:	1080030b 	ldhu	r2,12(r2)
   11a84:	10bfffcc 	andi	r2,r2,65535
   11a88:	1004923a 	slli	r2,r2,8
   11a8c:	10bfffcc 	andi	r2,r2,65535
   11a90:	2084b03a 	or	r2,r4,r2
   11a94:	10800fcc 	andi	r2,r2,63
   11a98:	1884b03a 	or	r2,r3,r2
   11a9c:	10bfc00c 	andi	r2,r2,65280
   11aa0:	1004d23a 	srli	r2,r2,8
   11aa4:	1007883a 	mov	r3,r2
   11aa8:	e0bffe17 	ldw	r2,-8(fp)
   11aac:	1000010e 	bge	r2,zero,11ab4 <tcp_output_set_header+0x1f8>
   11ab0:	108000c4 	addi	r2,r2,3
   11ab4:	1005d0ba 	srai	r2,r2,2
   11ab8:	10800144 	addi	r2,r2,5
   11abc:	1004933a 	slli	r2,r2,12
   11ac0:	1009883a 	mov	r4,r2
   11ac4:	e0bffb17 	ldw	r2,-20(fp)
   11ac8:	1080030b 	ldhu	r2,12(r2)
   11acc:	10bfffcc 	andi	r2,r2,65535
   11ad0:	1004d23a 	srli	r2,r2,8
   11ad4:	100b883a 	mov	r5,r2
   11ad8:	e0bffb17 	ldw	r2,-20(fp)
   11adc:	1080030b 	ldhu	r2,12(r2)
   11ae0:	10bfffcc 	andi	r2,r2,65535
   11ae4:	1004923a 	slli	r2,r2,8
   11ae8:	2884b03a 	or	r2,r5,r2
   11aec:	10800fcc 	andi	r2,r2,63
   11af0:	2084b03a 	or	r2,r4,r2
   11af4:	1004923a 	slli	r2,r2,8
   11af8:	1884b03a 	or	r2,r3,r2
   11afc:	1007883a 	mov	r3,r2
   11b00:	e0bffb17 	ldw	r2,-20(fp)
   11b04:	10c0030d 	sth	r3,12(r2)
  tcphdr->chksum = 0;
   11b08:	e0bffb17 	ldw	r2,-20(fp)
   11b0c:	1000040d 	sth	zero,16(r2)

  /* If we're sending a packet, update the announced right window edge */
  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
   11b10:	e0bffc17 	ldw	r2,-16(fp)
   11b14:	10c00a17 	ldw	r3,40(r2)
   11b18:	e0bffc17 	ldw	r2,-16(fp)
   11b1c:	10800b8b 	ldhu	r2,46(r2)
   11b20:	10bfffcc 	andi	r2,r2,65535
   11b24:	1887883a 	add	r3,r3,r2
   11b28:	e0bffc17 	ldw	r2,-16(fp)
   11b2c:	10c00c15 	stw	r3,48(r2)

  return tcphdr;
   11b30:	e0bffb17 	ldw	r2,-20(fp)
}
   11b34:	e037883a 	mov	sp,fp
   11b38:	df000017 	ldw	fp,0(sp)
   11b3c:	dec00104 	addi	sp,sp,4
   11b40:	f800283a 	ret

00011b44 <tcp_send_ctrl>:
 * @param flags the flags to set in the segment header
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_ctrl(struct tcp_pcb *pcb, u8_t flags)
{
   11b44:	defffa04 	addi	sp,sp,-24
   11b48:	dfc00515 	stw	ra,20(sp)
   11b4c:	df000415 	stw	fp,16(sp)
   11b50:	df000404 	addi	fp,sp,16
   11b54:	e13ffe15 	stw	r4,-8(fp)
   11b58:	2805883a 	mov	r2,r5
   11b5c:	e0bfff05 	stb	r2,-4(fp)
  /* no data, no length, flags, copy=1, no optdata */
  return tcp_enqueue(pcb, NULL, 0, flags, TCP_WRITE_FLAG_COPY, 0);
   11b60:	e0bfff03 	ldbu	r2,-4(fp)
   11b64:	00c00044 	movi	r3,1
   11b68:	d8c00015 	stw	r3,0(sp)
   11b6c:	d8000115 	stw	zero,4(sp)
   11b70:	e13ffe17 	ldw	r4,-8(fp)
   11b74:	000b883a 	mov	r5,zero
   11b78:	000d883a 	mov	r6,zero
   11b7c:	100f883a 	mov	r7,r2
   11b80:	0011c500 	call	11c50 <tcp_enqueue>
}
   11b84:	e037883a 	mov	sp,fp
   11b88:	dfc00117 	ldw	ra,4(sp)
   11b8c:	df000017 	ldw	fp,0(sp)
   11b90:	dec00204 	addi	sp,sp,8
   11b94:	f800283a 	ret

00011b98 <tcp_write>:
 * 
 * @see tcp_write()
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
   11b98:	defff804 	addi	sp,sp,-32
   11b9c:	dfc00715 	stw	ra,28(sp)
   11ba0:	df000615 	stw	fp,24(sp)
   11ba4:	df000604 	addi	fp,sp,24
   11ba8:	e13ffc15 	stw	r4,-16(fp)
   11bac:	e17ffd15 	stw	r5,-12(fp)
   11bb0:	3007883a 	mov	r3,r6
   11bb4:	3805883a 	mov	r2,r7
   11bb8:	e0fffe0d 	sth	r3,-8(fp)
   11bbc:	e0bfff05 	stb	r2,-4(fp)
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
   11bc0:	e0bffc17 	ldw	r2,-16(fp)
   11bc4:	10800417 	ldw	r2,16(r2)
   11bc8:	10800120 	cmpeqi	r2,r2,4
   11bcc:	10000c1e 	bne	r2,zero,11c00 <tcp_write+0x68>
     pcb->state == CLOSE_WAIT ||
   11bd0:	e0bffc17 	ldw	r2,-16(fp)
   11bd4:	10800417 	ldw	r2,16(r2)
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
   11bd8:	108001e0 	cmpeqi	r2,r2,7
   11bdc:	1000081e 	bne	r2,zero,11c00 <tcp_write+0x68>
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
   11be0:	e0bffc17 	ldw	r2,-16(fp)
   11be4:	10800417 	ldw	r2,16(r2)
{
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
     pcb->state == CLOSE_WAIT ||
   11be8:	108000a0 	cmpeqi	r2,r2,2
   11bec:	1000041e 	bne	r2,zero,11c00 <tcp_write+0x68>
     pcb->state == SYN_SENT ||
     pcb->state == SYN_RCVD) {
   11bf0:	e0bffc17 	ldw	r2,-16(fp)
   11bf4:	10800417 	ldw	r2,16(r2)
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
   11bf8:	108000d8 	cmpnei	r2,r2,3
   11bfc:	10000e1e 	bne	r2,zero,11c38 <tcp_write+0xa0>
     pcb->state == SYN_RCVD) {
    if (len > 0) {
   11c00:	e0bffe0b 	ldhu	r2,-8(fp)
   11c04:	10000a26 	beq	r2,zero,11c30 <tcp_write+0x98>
#if LWIP_TCP_TIMESTAMPS
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, 
                         pcb->flags & TF_TIMESTAMP ? TF_SEG_OPTS_TS : 0);
#else
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, 0);
   11c08:	e0bffe0b 	ldhu	r2,-8(fp)
   11c0c:	e0ffff03 	ldbu	r3,-4(fp)
   11c10:	d8c00015 	stw	r3,0(sp)
   11c14:	d8000115 	stw	zero,4(sp)
   11c18:	e13ffc17 	ldw	r4,-16(fp)
   11c1c:	e17ffd17 	ldw	r5,-12(fp)
   11c20:	100d883a 	mov	r6,r2
   11c24:	000f883a 	mov	r7,zero
   11c28:	0011c500 	call	11c50 <tcp_enqueue>
   11c2c:	00000306 	br	11c3c <tcp_write+0xa4>
#endif
    }
    return ERR_OK;
   11c30:	0005883a 	mov	r2,zero
   11c34:	00000106 	br	11c3c <tcp_write+0xa4>
  } else {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
   11c38:	00bffe04 	movi	r2,-8
  }
}
   11c3c:	e037883a 	mov	sp,fp
   11c40:	dfc00117 	ldw	ra,4(sp)
   11c44:	df000017 	ldw	fp,0(sp)
   11c48:	dec00204 	addi	sp,sp,8
   11c4c:	f800283a 	ret

00011c50 <tcp_enqueue>:
 * @param optflags options to include in segment later on (see definition of struct tcp_seg)
 */
err_t
tcp_enqueue(struct tcp_pcb *pcb, void *arg, u16_t len,
            u8_t flags, u8_t apiflags, u8_t optflags)
{
   11c50:	deffef04 	addi	sp,sp,-68
   11c54:	dfc01015 	stw	ra,64(sp)
   11c58:	df000f15 	stw	fp,60(sp)
   11c5c:	df000f04 	addi	fp,sp,60
   11c60:	e13ffa15 	stw	r4,-24(fp)
   11c64:	e17ffb15 	stw	r5,-20(fp)
   11c68:	3007883a 	mov	r3,r6
   11c6c:	3805883a 	mov	r2,r7
   11c70:	e1400217 	ldw	r5,8(fp)
   11c74:	e1000317 	ldw	r4,12(fp)
   11c78:	e0fffc0d 	sth	r3,-16(fp)
   11c7c:	e0bffd05 	stb	r2,-12(fp)
   11c80:	e17ffe05 	stb	r5,-8(fp)
   11c84:	e13fff05 	stb	r4,-4(fp)
  u8_t optlen;

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, 
              ("tcp_enqueue(pcb=%p, arg=%p, len=%"U16_F", flags=%"X16_F", apiflags=%"U16_F")\n",
               (void *)pcb, arg, len, (u16_t)flags, (u16_t)apiflags));
  LWIP_ERROR("tcp_enqueue: packet needs payload, options, or SYN/FIN (programmer violates API)",
   11c88:	e0bffc0b 	ldhu	r2,-16(fp)
   11c8c:	10000e1e 	bne	r2,zero,11cc8 <tcp_enqueue+0x78>
   11c90:	e0bfff03 	ldbu	r2,-4(fp)
   11c94:	10000c1e 	bne	r2,zero,11cc8 <tcp_enqueue+0x78>
   11c98:	e0bffd03 	ldbu	r2,-12(fp)
   11c9c:	108000cc 	andi	r2,r2,3
   11ca0:	1000091e 	bne	r2,zero,11cc8 <tcp_enqueue+0x78>
   11ca4:	010000f4 	movhi	r4,3
   11ca8:	213e8004 	addi	r4,r4,-1536
   11cac:	014000f4 	movhi	r5,3
   11cb0:	297e8a04 	addi	r5,r5,-1496
   11cb4:	01802ac4 	movi	r6,171
   11cb8:	01c000f4 	movhi	r7,3
   11cbc:	39fe9f04 	addi	r7,r7,-1412
   11cc0:	00170680 	call	17068 <printf>
   11cc4:	003fff06 	br	11cc4 <tcp_enqueue+0x74>
             ((len != 0) || (optflags != 0) || ((flags & (TCP_SYN | TCP_FIN)) != 0)),
             return ERR_ARG;);
  LWIP_ERROR("tcp_enqueue: len != 0 || arg == NULL (programmer violates API)", 
   11cc8:	e0bffc0b 	ldhu	r2,-16(fp)
   11ccc:	10000b1e 	bne	r2,zero,11cfc <tcp_enqueue+0xac>
   11cd0:	e0bffb17 	ldw	r2,-20(fp)
   11cd4:	10000926 	beq	r2,zero,11cfc <tcp_enqueue+0xac>
   11cd8:	010000f4 	movhi	r4,3
   11cdc:	213e8004 	addi	r4,r4,-1536
   11ce0:	014000f4 	movhi	r5,3
   11ce4:	297ea504 	addi	r5,r5,-1388
   11ce8:	01802b44 	movi	r6,173
   11cec:	01c000f4 	movhi	r7,3
   11cf0:	39fe9f04 	addi	r7,r7,-1412
   11cf4:	00170680 	call	17068 <printf>
   11cf8:	003fff06 	br	11cf8 <tcp_enqueue+0xa8>
             ((len != 0) || (arg == NULL)), return ERR_ARG;);

  /* fail on too much data */
  if (len > pcb->snd_buf) {
   11cfc:	e0bffa17 	ldw	r2,-24(fp)
   11d00:	10801c8b 	ldhu	r2,114(r2)
   11d04:	10ffffcc 	andi	r3,r2,65535
   11d08:	e0bffc0b 	ldhu	r2,-16(fp)
   11d0c:	1880092e 	bgeu	r3,r2,11d34 <tcp_enqueue+0xe4>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_WARNING,
      ("tcp_enqueue: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n", len, pcb->snd_buf));
    pcb->flags |= TF_NAGLEMEMERR;
   11d10:	e0bffa17 	ldw	r2,-24(fp)
   11d14:	10c00983 	ldbu	r3,38(r2)
   11d18:	00bfe004 	movi	r2,-128
   11d1c:	1884b03a 	or	r2,r3,r2
   11d20:	1007883a 	mov	r3,r2
   11d24:	e0bffa17 	ldw	r2,-24(fp)
   11d28:	10c00985 	stb	r3,38(r2)
    return ERR_MEM;
   11d2c:	00bfffc4 	movi	r2,-1
   11d30:	00031706 	br	12990 <tcp_enqueue+0xd40>
  }
  left = len;
   11d34:	e0bffc0b 	ldhu	r2,-16(fp)
   11d38:	e0bff50d 	sth	r2,-44(fp)
  ptr = arg;
   11d3c:	e0bffb17 	ldw	r2,-20(fp)
   11d40:	e0bff615 	stw	r2,-40(fp)

  optlen = LWIP_TCP_OPT_LENGTH(optflags);
   11d44:	e0bfff03 	ldbu	r2,-4(fp)
   11d48:	1080004c 	andi	r2,r2,1
   11d4c:	10000226 	beq	r2,zero,11d58 <tcp_enqueue+0x108>
   11d50:	00c00104 	movi	r3,4
   11d54:	00000106 	br	11d5c <tcp_enqueue+0x10c>
   11d58:	0007883a 	mov	r3,zero
   11d5c:	e0bfff03 	ldbu	r2,-4(fp)
   11d60:	1080008c 	andi	r2,r2,2
   11d64:	10000226 	beq	r2,zero,11d70 <tcp_enqueue+0x120>
   11d68:	00800304 	movi	r2,12
   11d6c:	00000106 	br	11d74 <tcp_enqueue+0x124>
   11d70:	0005883a 	mov	r2,zero
   11d74:	1885883a 	add	r2,r3,r2
   11d78:	e0bff785 	stb	r2,-34(fp)

  /* seqno will be the sequence number of the first segment enqueued
   * by the call to this function. */
  seqno = pcb->snd_lbb;
   11d7c:	e0bffa17 	ldw	r2,-24(fp)
   11d80:	10801b17 	ldw	r2,108(r2)
   11d84:	e0bff415 	stw	r2,-48(fp)

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  queuelen = pcb->snd_queuelen;
   11d88:	e0bffa17 	ldw	r2,-24(fp)
   11d8c:	10801d0b 	ldhu	r2,116(r2)
   11d90:	e0bff70d 	sth	r2,-36(fp)
  /* check for configured max queuelen and possible overflow */
  if ((queuelen >= TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
   11d94:	e0bff70b 	ldhu	r2,-36(fp)
   11d98:	10800b28 	cmpgeui	r2,r2,44
   11d9c:	1000031e 	bne	r2,zero,11dac <tcp_enqueue+0x15c>
   11da0:	e0bff70b 	ldhu	r2,-36(fp)
   11da4:	10bfff70 	cmpltui	r2,r2,65533
   11da8:	1000111e 	bne	r2,zero,11df0 <tcp_enqueue+0x1a0>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_WARNING,
      ("tcp_enqueue: too long queue %"U16_F" (max %"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
   11dac:	00800134 	movhi	r2,4
   11db0:	10916104 	addi	r2,r2,17796
   11db4:	1080270b 	ldhu	r2,156(r2)
   11db8:	10800044 	addi	r2,r2,1
   11dbc:	1007883a 	mov	r3,r2
   11dc0:	00800134 	movhi	r2,4
   11dc4:	10916104 	addi	r2,r2,17796
   11dc8:	10c0270d 	sth	r3,156(r2)
    pcb->flags |= TF_NAGLEMEMERR;
   11dcc:	e0bffa17 	ldw	r2,-24(fp)
   11dd0:	10c00983 	ldbu	r3,38(r2)
   11dd4:	00bfe004 	movi	r2,-128
   11dd8:	1884b03a 	or	r2,r3,r2
   11ddc:	1007883a 	mov	r3,r2
   11de0:	e0bffa17 	ldw	r2,-24(fp)
   11de4:	10c00985 	stb	r3,38(r2)
    return ERR_MEM;
   11de8:	00bfffc4 	movi	r2,-1
   11dec:	0002e806 	br	12990 <tcp_enqueue+0xd40>
  }
  if (queuelen != 0) {
   11df0:	e0bff70b 	ldhu	r2,-36(fp)
   11df4:	10000f26 	beq	r2,zero,11e34 <tcp_enqueue+0x1e4>
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
   11df8:	e0bffa17 	ldw	r2,-24(fp)
   11dfc:	10801f17 	ldw	r2,124(r2)
   11e00:	10001b1e 	bne	r2,zero,11e70 <tcp_enqueue+0x220>
   11e04:	e0bffa17 	ldw	r2,-24(fp)
   11e08:	10801e17 	ldw	r2,120(r2)
   11e0c:	1000181e 	bne	r2,zero,11e70 <tcp_enqueue+0x220>
   11e10:	010000f4 	movhi	r4,3
   11e14:	213e8004 	addi	r4,r4,-1536
   11e18:	014000f4 	movhi	r5,3
   11e1c:	297eb504 	addi	r5,r5,-1324
   11e20:	01803384 	movi	r6,206
   11e24:	01c000f4 	movhi	r7,3
   11e28:	39fe9f04 	addi	r7,r7,-1412
   11e2c:	00170680 	call	17068 <printf>
   11e30:	003fff06 	br	11e30 <tcp_enqueue+0x1e0>
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
   11e34:	e0bffa17 	ldw	r2,-24(fp)
   11e38:	10801f17 	ldw	r2,124(r2)
   11e3c:	1000031e 	bne	r2,zero,11e4c <tcp_enqueue+0x1fc>
   11e40:	e0bffa17 	ldw	r2,-24(fp)
   11e44:	10801e17 	ldw	r2,120(r2)
   11e48:	10000926 	beq	r2,zero,11e70 <tcp_enqueue+0x220>
   11e4c:	010000f4 	movhi	r4,3
   11e50:	213e8004 	addi	r4,r4,-1536
   11e54:	014000f4 	movhi	r5,3
   11e58:	297ec404 	addi	r5,r5,-1264
   11e5c:	01803444 	movi	r6,209
   11e60:	01c000f4 	movhi	r7,3
   11e64:	39fe9f04 	addi	r7,r7,-1412
   11e68:	00170680 	call	17068 <printf>
   11e6c:	003fff06 	br	11e6c <tcp_enqueue+0x21c>
      pcb->unacked == NULL && pcb->unsent == NULL);
  }

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
   11e70:	e03ff115 	stw	zero,-60(fp)
   11e74:	e0bff117 	ldw	r2,-60(fp)
   11e78:	e0bff315 	stw	r2,-52(fp)
   11e7c:	e0bff317 	ldw	r2,-52(fp)
   11e80:	e0bff215 	stw	r2,-56(fp)
  seglen = 0;
   11e84:	e03ff58d 	sth	zero,-42(fp)
  while (queue == NULL || left > 0) {
   11e88:	00013506 	br	12360 <tcp_enqueue+0x710>
    /* The segment length (including options) should be at most the MSS */
    seglen = left > (pcb->mss - optlen) ? (pcb->mss - optlen) : left;
   11e8c:	e0bff50b 	ldhu	r2,-44(fp)
   11e90:	e0fffa17 	ldw	r3,-24(fp)
   11e94:	18c00f0b 	ldhu	r3,60(r3)
   11e98:	193fffcc 	andi	r4,r3,65535
   11e9c:	e0fff783 	ldbu	r3,-34(fp)
   11ea0:	20c7c83a 	sub	r3,r4,r3
   11ea4:	1880010e 	bge	r3,r2,11eac <tcp_enqueue+0x25c>
   11ea8:	1805883a 	mov	r2,r3
   11eac:	e0bff58d 	sth	r2,-42(fp)

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
   11eb0:	01000104 	movi	r4,4
   11eb4:	0008f0c0 	call	8f0c <memp_malloc>
   11eb8:	e0bff115 	stw	r2,-60(fp)
    if (seg == NULL) {
   11ebc:	e0bff117 	ldw	r2,-60(fp)
   11ec0:	10028526 	beq	r2,zero,128d8 <tcp_enqueue+0xc88>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, 
                  ("tcp_enqueue: could not allocate memory for tcp_seg\n"));
      goto memerr;
    }
    seg->next = NULL;
   11ec4:	e0bff117 	ldw	r2,-60(fp)
   11ec8:	10000015 	stw	zero,0(r2)
    seg->p = NULL;
   11ecc:	e0bff117 	ldw	r2,-60(fp)
   11ed0:	10000115 	stw	zero,4(r2)

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
   11ed4:	e0bff317 	ldw	r2,-52(fp)
   11ed8:	1000031e 	bne	r2,zero,11ee8 <tcp_enqueue+0x298>
      queue = seg;
   11edc:	e0bff117 	ldw	r2,-60(fp)
   11ee0:	e0bff315 	stw	r2,-52(fp)
   11ee4:	00000e06 	br	11f20 <tcp_enqueue+0x2d0>
    }
    /* subsequent segments of to-be-queued data */
    else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("useg != NULL", useg != NULL);
   11ee8:	e0bff217 	ldw	r2,-56(fp)
   11eec:	1000091e 	bne	r2,zero,11f14 <tcp_enqueue+0x2c4>
   11ef0:	010000f4 	movhi	r4,3
   11ef4:	213e8004 	addi	r4,r4,-1536
   11ef8:	014000f4 	movhi	r5,3
   11efc:	297ed104 	addi	r5,r5,-1212
   11f00:	01803b44 	movi	r6,237
   11f04:	01c000f4 	movhi	r7,3
   11f08:	39fe9f04 	addi	r7,r7,-1412
   11f0c:	00170680 	call	17068 <printf>
   11f10:	003fff06 	br	11f10 <tcp_enqueue+0x2c0>
      useg->next = seg;
   11f14:	e0bff217 	ldw	r2,-56(fp)
   11f18:	e0fff117 	ldw	r3,-60(fp)
   11f1c:	10c00015 	stw	r3,0(r2)
    }
    /* remember last segment of to-be-queued data for next iteration */
    useg = seg;
   11f20:	e0bff117 	ldw	r2,-60(fp)
   11f24:	e0bff215 	stw	r2,-56(fp)

    /* If copy is set, memory should be allocated
     * and data copied into pbuf, otherwise data comes from
     * ROM or other static memory, and need not be copied.  */
    if (apiflags & TCP_WRITE_FLAG_COPY) {
   11f28:	e0bffe03 	ldbu	r2,-8(fp)
   11f2c:	1080004c 	andi	r2,r2,1
   11f30:	10003826 	beq	r2,zero,12014 <tcp_enqueue+0x3c4>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen + optlen, PBUF_RAM)) == NULL) {
   11f34:	e0fff783 	ldbu	r3,-34(fp)
   11f38:	e0bff58b 	ldhu	r2,-42(fp)
   11f3c:	1885883a 	add	r2,r3,r2
   11f40:	10bfffcc 	andi	r2,r2,65535
   11f44:	0009883a 	mov	r4,zero
   11f48:	100b883a 	mov	r5,r2
   11f4c:	000d883a 	mov	r6,zero
   11f50:	00097cc0 	call	97cc <pbuf_alloc>
   11f54:	e0fff117 	ldw	r3,-60(fp)
   11f58:	18800115 	stw	r2,4(r3)
   11f5c:	e0bff117 	ldw	r2,-60(fp)
   11f60:	10800117 	ldw	r2,4(r2)
   11f64:	10025e26 	beq	r2,zero,128e0 <tcp_enqueue+0xc90>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, 
                    ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
   11f68:	e0bff117 	ldw	r2,-60(fp)
   11f6c:	10800117 	ldw	r2,4(r2)
   11f70:	1080028b 	ldhu	r2,10(r2)
   11f74:	10ffffcc 	andi	r3,r2,65535
   11f78:	e13ff58b 	ldhu	r4,-42(fp)
   11f7c:	e0bff783 	ldbu	r2,-34(fp)
   11f80:	2085883a 	add	r2,r4,r2
   11f84:	1880090e 	bge	r3,r2,11fac <tcp_enqueue+0x35c>
   11f88:	010000f4 	movhi	r4,3
   11f8c:	213e8004 	addi	r4,r4,-1536
   11f90:	014000f4 	movhi	r5,3
   11f94:	297ed504 	addi	r5,r5,-1196
   11f98:	01803f44 	movi	r6,253
   11f9c:	01c000f4 	movhi	r7,3
   11fa0:	39fe9f04 	addi	r7,r7,-1412
   11fa4:	00170680 	call	17068 <printf>
   11fa8:	003fff06 	br	11fa8 <tcp_enqueue+0x358>
                  (seg->p->len >= seglen + optlen));
      queuelen += pbuf_clen(seg->p);
   11fac:	e0bff117 	ldw	r2,-60(fp)
   11fb0:	10800117 	ldw	r2,4(r2)
   11fb4:	1009883a 	mov	r4,r2
   11fb8:	000a3540 	call	a354 <pbuf_clen>
   11fbc:	10c03fcc 	andi	r3,r2,255
   11fc0:	e0bff70b 	ldhu	r2,-36(fp)
   11fc4:	1885883a 	add	r2,r3,r2
   11fc8:	e0bff70d 	sth	r2,-36(fp)
      if (arg != NULL) {
   11fcc:	e0bffb17 	ldw	r2,-20(fp)
   11fd0:	10000a26 	beq	r2,zero,11ffc <tcp_enqueue+0x3ac>
        MEMCPY((char *)seg->p->payload + optlen, ptr, seglen);
   11fd4:	e0bff117 	ldw	r2,-60(fp)
   11fd8:	10800117 	ldw	r2,4(r2)
   11fdc:	10c00117 	ldw	r3,4(r2)
   11fe0:	e0bff783 	ldbu	r2,-34(fp)
   11fe4:	1887883a 	add	r3,r3,r2
   11fe8:	e0bff58b 	ldhu	r2,-42(fp)
   11fec:	1809883a 	mov	r4,r3
   11ff0:	e17ff617 	ldw	r5,-40(fp)
   11ff4:	100d883a 	mov	r6,r2
   11ff8:	0016e680 	call	16e68 <memcpy>
      }
      seg->dataptr = seg->p->payload;
   11ffc:	e0bff117 	ldw	r2,-60(fp)
   12000:	10800117 	ldw	r2,4(r2)
   12004:	10c00117 	ldw	r3,4(r2)
   12008:	e0bff117 	ldw	r2,-60(fp)
   1200c:	10c00215 	stw	r3,8(r2)
   12010:	00003206 	br	120dc <tcp_enqueue+0x48c>
    }
    /* do not copy data */
    else {
      /* First, allocate a pbuf for the headers. */
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
   12014:	e0bff783 	ldbu	r2,-34(fp)
   12018:	0009883a 	mov	r4,zero
   1201c:	100b883a 	mov	r5,r2
   12020:	000d883a 	mov	r6,zero
   12024:	00097cc0 	call	97cc <pbuf_alloc>
   12028:	e0fff117 	ldw	r3,-60(fp)
   1202c:	18800115 	stw	r2,4(r3)
   12030:	e0bff117 	ldw	r2,-60(fp)
   12034:	10800117 	ldw	r2,4(r2)
   12038:	10022b26 	beq	r2,zero,128e8 <tcp_enqueue+0xc98>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, 
                    ("tcp_enqueue: could not allocate memory for header pbuf\n"));
        goto memerr;
      }
      queuelen += pbuf_clen(seg->p);
   1203c:	e0bff117 	ldw	r2,-60(fp)
   12040:	10800117 	ldw	r2,4(r2)
   12044:	1009883a 	mov	r4,r2
   12048:	000a3540 	call	a354 <pbuf_clen>
   1204c:	10c03fcc 	andi	r3,r2,255
   12050:	e0bff70b 	ldhu	r2,-36(fp)
   12054:	1885883a 	add	r2,r3,r2
   12058:	e0bff70d 	sth	r2,-36(fp)
      /* Second, allocate a pbuf for holding the data.
       * since the referenced data is available at least until it is sent out on the
       * link (as it has to be ACKed by the remote party) we can safely use PBUF_ROM
       * instead of PBUF_REF here.
       */
      if (left > 0) {
   1205c:	e0bff50b 	ldhu	r2,-44(fp)
   12060:	10001e26 	beq	r2,zero,120dc <tcp_enqueue+0x48c>
        if ((p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
   12064:	e0bff58b 	ldhu	r2,-42(fp)
   12068:	010000c4 	movi	r4,3
   1206c:	100b883a 	mov	r5,r2
   12070:	01800044 	movi	r6,1
   12074:	00097cc0 	call	97cc <pbuf_alloc>
   12078:	e0bff915 	stw	r2,-28(fp)
   1207c:	e0bff917 	ldw	r2,-28(fp)
   12080:	1000071e 	bne	r2,zero,120a0 <tcp_enqueue+0x450>
          /* If allocation fails, we have to deallocate the header pbuf as well. */
          pbuf_free(seg->p);
   12084:	e0bff117 	ldw	r2,-60(fp)
   12088:	10800117 	ldw	r2,4(r2)
   1208c:	1009883a 	mov	r4,r2
   12090:	000a1880 	call	a188 <pbuf_free>
          seg->p = NULL;
   12094:	e0bff117 	ldw	r2,-60(fp)
   12098:	10000115 	stw	zero,4(r2)
          LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, 
                      ("tcp_enqueue: could not allocate memory for zero-copy pbuf\n"));
          goto memerr;
   1209c:	00021506 	br	128f4 <tcp_enqueue+0xca4>
        }
        ++queuelen;
   120a0:	e0bff70b 	ldhu	r2,-36(fp)
   120a4:	10800044 	addi	r2,r2,1
   120a8:	e0bff70d 	sth	r2,-36(fp)
        /* reference the non-volatile payload data */
        p->payload = ptr;
   120ac:	e0bff917 	ldw	r2,-28(fp)
   120b0:	e0fff617 	ldw	r3,-40(fp)
   120b4:	10c00115 	stw	r3,4(r2)
        seg->dataptr = ptr;
   120b8:	e0bff117 	ldw	r2,-60(fp)
   120bc:	e0fff617 	ldw	r3,-40(fp)
   120c0:	10c00215 	stw	r3,8(r2)

        /* Concatenate the headers and data pbufs together. */
        pbuf_cat(seg->p/*header*/, p/*data*/);
   120c4:	e0bff117 	ldw	r2,-60(fp)
   120c8:	10800117 	ldw	r2,4(r2)
   120cc:	1009883a 	mov	r4,r2
   120d0:	e17ff917 	ldw	r5,-28(fp)
   120d4:	000a3e00 	call	a3e0 <pbuf_cat>
        p = NULL;
   120d8:	e03ff915 	stw	zero,-28(fp)
      }
    }

    /* Now that there are more segments queued, we check again if the
    length of the queue exceeds the configured maximum or overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
   120dc:	e0bff70b 	ldhu	r2,-36(fp)
   120e0:	10800b68 	cmpgeui	r2,r2,45
   120e4:	1002021e 	bne	r2,zero,128f0 <tcp_enqueue+0xca0>
   120e8:	e0bff70b 	ldhu	r2,-36(fp)
   120ec:	10bfff70 	cmpltui	r2,r2,65533
   120f0:	1001ff26 	beq	r2,zero,128f0 <tcp_enqueue+0xca0>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
        ("tcp_enqueue: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      goto memerr;
    }

    seg->len = seglen;
   120f4:	e0bff117 	ldw	r2,-60(fp)
   120f8:	e0fff58b 	ldhu	r3,-42(fp)
   120fc:	10c0030d 	sth	r3,12(r2)

    /* build TCP header */
    if (pbuf_header(seg->p, TCP_HLEN)) {
   12100:	e0bff117 	ldw	r2,-60(fp)
   12104:	10800117 	ldw	r2,4(r2)
   12108:	1009883a 	mov	r4,r2
   1210c:	01400504 	movi	r5,20
   12110:	0009f900 	call	9f90 <pbuf_header>
   12114:	10803fcc 	andi	r2,r2,255
   12118:	10000926 	beq	r2,zero,12140 <tcp_enqueue+0x4f0>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_enqueue: no room for TCP header in pbuf.\n"));
      TCP_STATS_INC(tcp.err);
   1211c:	00800134 	movhi	r2,4
   12120:	10916104 	addi	r2,r2,17796
   12124:	1080290b 	ldhu	r2,164(r2)
   12128:	10800044 	addi	r2,r2,1
   1212c:	1007883a 	mov	r3,r2
   12130:	00800134 	movhi	r2,4
   12134:	10916104 	addi	r2,r2,17796
   12138:	10c0290d 	sth	r3,164(r2)
      goto memerr;
   1213c:	0001ed06 	br	128f4 <tcp_enqueue+0xca4>
    }
    seg->tcphdr = seg->p->payload;
   12140:	e0bff117 	ldw	r2,-60(fp)
   12144:	10800117 	ldw	r2,4(r2)
   12148:	10c00117 	ldw	r3,4(r2)
   1214c:	e0bff117 	ldw	r2,-60(fp)
   12150:	10c00415 	stw	r3,16(r2)
    seg->tcphdr->src = htons(pcb->local_port);
   12154:	e0bff117 	ldw	r2,-60(fp)
   12158:	10800417 	ldw	r2,16(r2)
   1215c:	e0fffa17 	ldw	r3,-24(fp)
   12160:	18c0070b 	ldhu	r3,28(r3)
   12164:	18ffffcc 	andi	r3,r3,65535
   12168:	1806d23a 	srli	r3,r3,8
   1216c:	1809883a 	mov	r4,r3
   12170:	e0fffa17 	ldw	r3,-24(fp)
   12174:	18c0070b 	ldhu	r3,28(r3)
   12178:	18ffffcc 	andi	r3,r3,65535
   1217c:	1806923a 	slli	r3,r3,8
   12180:	20c6b03a 	or	r3,r4,r3
   12184:	10c0000d 	sth	r3,0(r2)
    seg->tcphdr->dest = htons(pcb->remote_port);
   12188:	e0bff117 	ldw	r2,-60(fp)
   1218c:	10800417 	ldw	r2,16(r2)
   12190:	e0fffa17 	ldw	r3,-24(fp)
   12194:	18c0090b 	ldhu	r3,36(r3)
   12198:	18ffffcc 	andi	r3,r3,65535
   1219c:	1806d23a 	srli	r3,r3,8
   121a0:	1809883a 	mov	r4,r3
   121a4:	e0fffa17 	ldw	r3,-24(fp)
   121a8:	18c0090b 	ldhu	r3,36(r3)
   121ac:	18ffffcc 	andi	r3,r3,65535
   121b0:	1806923a 	slli	r3,r3,8
   121b4:	20c6b03a 	or	r3,r4,r3
   121b8:	10c0008d 	sth	r3,2(r2)
    seg->tcphdr->seqno = htonl(seqno);
   121bc:	e0bff117 	ldw	r2,-60(fp)
   121c0:	10800417 	ldw	r2,16(r2)
   121c4:	e0fff417 	ldw	r3,-48(fp)
   121c8:	1808d63a 	srli	r4,r3,24
   121cc:	e0fff417 	ldw	r3,-48(fp)
   121d0:	1806d23a 	srli	r3,r3,8
   121d4:	18ffc00c 	andi	r3,r3,65280
   121d8:	20c8b03a 	or	r4,r4,r3
   121dc:	e0fff417 	ldw	r3,-48(fp)
   121e0:	18ffc00c 	andi	r3,r3,65280
   121e4:	1806923a 	slli	r3,r3,8
   121e8:	20c8b03a 	or	r4,r4,r3
   121ec:	e0fff417 	ldw	r3,-48(fp)
   121f0:	1806963a 	slli	r3,r3,24
   121f4:	20c6b03a 	or	r3,r4,r3
   121f8:	193fffcc 	andi	r4,r3,65535
   121fc:	1140010b 	ldhu	r5,4(r2)
   12200:	280a703a 	and	r5,r5,zero
   12204:	2908b03a 	or	r4,r5,r4
   12208:	1100010d 	sth	r4,4(r2)
   1220c:	1806d43a 	srli	r3,r3,16
   12210:	1100018b 	ldhu	r4,6(r2)
   12214:	2008703a 	and	r4,r4,zero
   12218:	20c6b03a 	or	r3,r4,r3
   1221c:	10c0018d 	sth	r3,6(r2)
    seg->tcphdr->urgp = 0;
   12220:	e0bff117 	ldw	r2,-60(fp)
   12224:	10800417 	ldw	r2,16(r2)
   12228:	1000048d 	sth	zero,18(r2)
    TCPH_FLAGS_SET(seg->tcphdr, flags);
   1222c:	e0bff117 	ldw	r2,-60(fp)
   12230:	10800417 	ldw	r2,16(r2)
   12234:	e0fff117 	ldw	r3,-60(fp)
   12238:	18c00417 	ldw	r3,16(r3)
   1223c:	18c0030b 	ldhu	r3,12(r3)
   12240:	1809883a 	mov	r4,r3
   12244:	00f03fc4 	movi	r3,-16129
   12248:	20c6703a 	and	r3,r4,r3
   1224c:	1809883a 	mov	r4,r3
   12250:	e0fffd03 	ldbu	r3,-12(fp)
   12254:	1806923a 	slli	r3,r3,8
   12258:	20c6b03a 	or	r3,r4,r3
   1225c:	10c0030d 	sth	r3,12(r2)
    /* don't fill in tcphdr->ackno and tcphdr->wnd until later */

    seg->flags = optflags;
   12260:	e0bff117 	ldw	r2,-60(fp)
   12264:	e0ffff03 	ldbu	r3,-4(fp)
   12268:	10c00385 	stb	r3,14(r2)

    /* Set the length of the header */
    TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
   1226c:	e0bff117 	ldw	r2,-60(fp)
   12270:	10800417 	ldw	r2,16(r2)
   12274:	e0fff783 	ldbu	r3,-34(fp)
   12278:	1806d0ba 	srli	r3,r3,2
   1227c:	18c03fcc 	andi	r3,r3,255
   12280:	18c00144 	addi	r3,r3,5
   12284:	1806933a 	slli	r3,r3,12
   12288:	1809883a 	mov	r4,r3
   1228c:	e0fff117 	ldw	r3,-60(fp)
   12290:	18c00417 	ldw	r3,16(r3)
   12294:	18c0030b 	ldhu	r3,12(r3)
   12298:	18ffffcc 	andi	r3,r3,65535
   1229c:	1806d23a 	srli	r3,r3,8
   122a0:	197fffcc 	andi	r5,r3,65535
   122a4:	e0fff117 	ldw	r3,-60(fp)
   122a8:	18c00417 	ldw	r3,16(r3)
   122ac:	18c0030b 	ldhu	r3,12(r3)
   122b0:	18ffffcc 	andi	r3,r3,65535
   122b4:	1806923a 	slli	r3,r3,8
   122b8:	18ffffcc 	andi	r3,r3,65535
   122bc:	28c6b03a 	or	r3,r5,r3
   122c0:	18c00fcc 	andi	r3,r3,63
   122c4:	20c6b03a 	or	r3,r4,r3
   122c8:	18ffc00c 	andi	r3,r3,65280
   122cc:	1806d23a 	srli	r3,r3,8
   122d0:	1809883a 	mov	r4,r3
   122d4:	e0fff783 	ldbu	r3,-34(fp)
   122d8:	1806d0ba 	srli	r3,r3,2
   122dc:	18c03fcc 	andi	r3,r3,255
   122e0:	18c00144 	addi	r3,r3,5
   122e4:	1806933a 	slli	r3,r3,12
   122e8:	180b883a 	mov	r5,r3
   122ec:	e0fff117 	ldw	r3,-60(fp)
   122f0:	18c00417 	ldw	r3,16(r3)
   122f4:	18c0030b 	ldhu	r3,12(r3)
   122f8:	18ffffcc 	andi	r3,r3,65535
   122fc:	1806d23a 	srli	r3,r3,8
   12300:	180d883a 	mov	r6,r3
   12304:	e0fff117 	ldw	r3,-60(fp)
   12308:	18c00417 	ldw	r3,16(r3)
   1230c:	18c0030b 	ldhu	r3,12(r3)
   12310:	18ffffcc 	andi	r3,r3,65535
   12314:	1806923a 	slli	r3,r3,8
   12318:	30c6b03a 	or	r3,r6,r3
   1231c:	18c00fcc 	andi	r3,r3,63
   12320:	28c6b03a 	or	r3,r5,r3
   12324:	1806923a 	slli	r3,r3,8
   12328:	20c6b03a 	or	r3,r4,r3
   1232c:	10c0030d 	sth	r3,12(r2)
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_enqueue: queueing %"U32_F":%"U32_F" (0x%"X16_F")\n",
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
   12330:	e0fff50b 	ldhu	r3,-44(fp)
   12334:	e0bff58b 	ldhu	r2,-42(fp)
   12338:	1885c83a 	sub	r2,r3,r2
   1233c:	e0bff50d 	sth	r2,-44(fp)
    seqno += seglen;
   12340:	e0bff58b 	ldhu	r2,-42(fp)
   12344:	e0fff417 	ldw	r3,-48(fp)
   12348:	1885883a 	add	r2,r3,r2
   1234c:	e0bff415 	stw	r2,-48(fp)
    ptr = (void *)((u8_t *)ptr + seglen);
   12350:	e0bff58b 	ldhu	r2,-42(fp)
   12354:	e0fff617 	ldw	r3,-40(fp)
   12358:	1885883a 	add	r2,r3,r2
   1235c:	e0bff615 	stw	r2,-40(fp)

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  seglen = 0;
  while (queue == NULL || left > 0) {
   12360:	e0bff317 	ldw	r2,-52(fp)
   12364:	103ec926 	beq	r2,zero,11e8c <tcp_enqueue+0x23c>
   12368:	e0bff50b 	ldhu	r2,-44(fp)
   1236c:	103ec71e 	bne	r2,zero,11e8c <tcp_enqueue+0x23c>
  }

  /* Now that the data to be enqueued has been broken up into TCP
  segments in the queue variable, we add them to the end of the
  pcb->unsent queue. */
  if (pcb->unsent == NULL) {
   12370:	e0bffa17 	ldw	r2,-24(fp)
   12374:	10801e17 	ldw	r2,120(r2)
   12378:	1000021e 	bne	r2,zero,12384 <tcp_enqueue+0x734>
    useg = NULL;
   1237c:	e03ff215 	stw	zero,-56(fp)
   12380:	00000a06 	br	123ac <tcp_enqueue+0x75c>
  }
  else {
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
   12384:	e0bffa17 	ldw	r2,-24(fp)
   12388:	10801e17 	ldw	r2,120(r2)
   1238c:	e0bff215 	stw	r2,-56(fp)
   12390:	00000306 	br	123a0 <tcp_enqueue+0x750>
   12394:	e0bff217 	ldw	r2,-56(fp)
   12398:	10800017 	ldw	r2,0(r2)
   1239c:	e0bff215 	stw	r2,-56(fp)
   123a0:	e0bff217 	ldw	r2,-56(fp)
   123a4:	10800017 	ldw	r2,0(r2)
   123a8:	103ffa1e 	bne	r2,zero,12394 <tcp_enqueue+0x744>
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
   123ac:	e0bff217 	ldw	r2,-56(fp)
   123b0:	1000f826 	beq	r2,zero,12794 <tcp_enqueue+0xb44>
    TCP_TCPLEN(useg) != 0 &&
   123b4:	e0bff217 	ldw	r2,-56(fp)
   123b8:	1080030b 	ldhu	r2,12(r2)
   123bc:	10ffffcc 	andi	r3,r2,65535
   123c0:	e0bff217 	ldw	r2,-56(fp)
   123c4:	10800417 	ldw	r2,16(r2)
   123c8:	1080030b 	ldhu	r2,12(r2)
   123cc:	10bfffcc 	andi	r2,r2,65535
   123d0:	1004d23a 	srli	r2,r2,8
   123d4:	113fffcc 	andi	r4,r2,65535
   123d8:	e0bff217 	ldw	r2,-56(fp)
   123dc:	10800417 	ldw	r2,16(r2)
   123e0:	1080030b 	ldhu	r2,12(r2)
   123e4:	10bfffcc 	andi	r2,r2,65535
   123e8:	1004923a 	slli	r2,r2,8
   123ec:	10bfffcc 	andi	r2,r2,65535
   123f0:	2084b03a 	or	r2,r4,r2
   123f4:	108000cc 	andi	r2,r2,3
   123f8:	1004c03a 	cmpne	r2,r2,zero
   123fc:	10803fcc 	andi	r2,r2,255
   12400:	1885883a 	add	r2,r3,r2
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
   12404:	1000e326 	beq	r2,zero,12794 <tcp_enqueue+0xb44>
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
   12408:	e0bff217 	ldw	r2,-56(fp)
   1240c:	10800417 	ldw	r2,16(r2)
   12410:	1080030b 	ldhu	r2,12(r2)
   12414:	10bfffcc 	andi	r2,r2,65535
   12418:	1004d23a 	srli	r2,r2,8
   1241c:	10ffffcc 	andi	r3,r2,65535
   12420:	e0bff217 	ldw	r2,-56(fp)
   12424:	10800417 	ldw	r2,16(r2)
   12428:	1080030b 	ldhu	r2,12(r2)
   1242c:	10bfffcc 	andi	r2,r2,65535
   12430:	1004923a 	slli	r2,r2,8
   12434:	10bfffcc 	andi	r2,r2,65535
   12438:	1884b03a 	or	r2,r3,r2
   1243c:	108000cc 	andi	r2,r2,3
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
   12440:	1000d41e 	bne	r2,zero,12794 <tcp_enqueue+0xb44>
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
    (!(flags & (TCP_SYN | TCP_FIN)) || (flags == TCP_FIN)) &&
   12444:	e0bffd03 	ldbu	r2,-12(fp)
   12448:	108000cc 	andi	r2,r2,3

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
   1244c:	10000326 	beq	r2,zero,1245c <tcp_enqueue+0x80c>
    (!(flags & (TCP_SYN | TCP_FIN)) || (flags == TCP_FIN)) &&
   12450:	e0bffd03 	ldbu	r2,-12(fp)
   12454:	10800058 	cmpnei	r2,r2,1
   12458:	1000ce1e 	bne	r2,zero,12794 <tcp_enqueue+0xb44>
    /* fit within max seg size */
    (useg->len + queue->len <= pcb->mss) &&
   1245c:	e0bff217 	ldw	r2,-56(fp)
   12460:	1080030b 	ldhu	r2,12(r2)
   12464:	10ffffcc 	andi	r3,r2,65535
   12468:	e0bff317 	ldw	r2,-52(fp)
   1246c:	1080030b 	ldhu	r2,12(r2)
   12470:	10bfffcc 	andi	r2,r2,65535
   12474:	1885883a 	add	r2,r3,r2
   12478:	e0fffa17 	ldw	r3,-24(fp)
   1247c:	18c00f0b 	ldhu	r3,60(r3)
   12480:	18ffffcc 	andi	r3,r3,65535
  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
    (!(flags & (TCP_SYN | TCP_FIN)) || (flags == TCP_FIN)) &&
   12484:	1880c316 	blt	r3,r2,12794 <tcp_enqueue+0xb44>
    /* fit within max seg size */
    (useg->len + queue->len <= pcb->mss) &&
    /* only concatenate segments with the same options */
    (useg->flags == queue->flags) &&
   12488:	e0bff217 	ldw	r2,-56(fp)
   1248c:	10c00383 	ldbu	r3,14(r2)
   12490:	e0bff317 	ldw	r2,-52(fp)
   12494:	10800383 	ldbu	r2,14(r2)
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
    (!(flags & (TCP_SYN | TCP_FIN)) || (flags == TCP_FIN)) &&
    /* fit within max seg size */
    (useg->len + queue->len <= pcb->mss) &&
   12498:	18c03fcc 	andi	r3,r3,255
   1249c:	10803fcc 	andi	r2,r2,255
   124a0:	1880bc1e 	bne	r3,r2,12794 <tcp_enqueue+0xb44>
    /* only concatenate segments with the same options */
    (useg->flags == queue->flags) &&
    /* segments are consecutive */
    (ntohl(useg->tcphdr->seqno) + useg->len == ntohl(queue->tcphdr->seqno)) ) {
   124a4:	e0bff217 	ldw	r2,-56(fp)
   124a8:	10800417 	ldw	r2,16(r2)
   124ac:	10c0010b 	ldhu	r3,4(r2)
   124b0:	1080018b 	ldhu	r2,6(r2)
   124b4:	1004943a 	slli	r2,r2,16
   124b8:	10c4b03a 	or	r2,r2,r3
   124bc:	1006d63a 	srli	r3,r2,24
   124c0:	e0bff217 	ldw	r2,-56(fp)
   124c4:	10800417 	ldw	r2,16(r2)
   124c8:	1100010b 	ldhu	r4,4(r2)
   124cc:	1080018b 	ldhu	r2,6(r2)
   124d0:	1004943a 	slli	r2,r2,16
   124d4:	1104b03a 	or	r2,r2,r4
   124d8:	1004d23a 	srli	r2,r2,8
   124dc:	10bfc00c 	andi	r2,r2,65280
   124e0:	1886b03a 	or	r3,r3,r2
   124e4:	e0bff217 	ldw	r2,-56(fp)
   124e8:	10800417 	ldw	r2,16(r2)
   124ec:	1100010b 	ldhu	r4,4(r2)
   124f0:	1080018b 	ldhu	r2,6(r2)
   124f4:	1004943a 	slli	r2,r2,16
   124f8:	1104b03a 	or	r2,r2,r4
   124fc:	10bfc00c 	andi	r2,r2,65280
   12500:	1004923a 	slli	r2,r2,8
   12504:	1886b03a 	or	r3,r3,r2
   12508:	e0bff217 	ldw	r2,-56(fp)
   1250c:	10800417 	ldw	r2,16(r2)
   12510:	1100010b 	ldhu	r4,4(r2)
   12514:	1080018b 	ldhu	r2,6(r2)
   12518:	1004943a 	slli	r2,r2,16
   1251c:	1104b03a 	or	r2,r2,r4
   12520:	1004963a 	slli	r2,r2,24
   12524:	1886b03a 	or	r3,r3,r2
   12528:	e0bff217 	ldw	r2,-56(fp)
   1252c:	1080030b 	ldhu	r2,12(r2)
   12530:	10bfffcc 	andi	r2,r2,65535
   12534:	1887883a 	add	r3,r3,r2
   12538:	e0bff317 	ldw	r2,-52(fp)
   1253c:	10800417 	ldw	r2,16(r2)
   12540:	1100010b 	ldhu	r4,4(r2)
   12544:	1080018b 	ldhu	r2,6(r2)
   12548:	1004943a 	slli	r2,r2,16
   1254c:	1104b03a 	or	r2,r2,r4
   12550:	1008d63a 	srli	r4,r2,24
   12554:	e0bff317 	ldw	r2,-52(fp)
   12558:	10800417 	ldw	r2,16(r2)
   1255c:	1140010b 	ldhu	r5,4(r2)
   12560:	1080018b 	ldhu	r2,6(r2)
   12564:	1004943a 	slli	r2,r2,16
   12568:	1144b03a 	or	r2,r2,r5
   1256c:	1004d23a 	srli	r2,r2,8
   12570:	10bfc00c 	andi	r2,r2,65280
   12574:	2088b03a 	or	r4,r4,r2
   12578:	e0bff317 	ldw	r2,-52(fp)
   1257c:	10800417 	ldw	r2,16(r2)
   12580:	1140010b 	ldhu	r5,4(r2)
   12584:	1080018b 	ldhu	r2,6(r2)
   12588:	1004943a 	slli	r2,r2,16
   1258c:	1144b03a 	or	r2,r2,r5
   12590:	10bfc00c 	andi	r2,r2,65280
   12594:	1004923a 	slli	r2,r2,8
   12598:	2088b03a 	or	r4,r4,r2
   1259c:	e0bff317 	ldw	r2,-52(fp)
   125a0:	10800417 	ldw	r2,16(r2)
   125a4:	1140010b 	ldhu	r5,4(r2)
   125a8:	1080018b 	ldhu	r2,6(r2)
   125ac:	1004943a 	slli	r2,r2,16
   125b0:	1144b03a 	or	r2,r2,r5
   125b4:	1004963a 	slli	r2,r2,24
   125b8:	2084b03a 	or	r2,r4,r2
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
    (!(flags & (TCP_SYN | TCP_FIN)) || (flags == TCP_FIN)) &&
    /* fit within max seg size */
    (useg->len + queue->len <= pcb->mss) &&
    /* only concatenate segments with the same options */
    (useg->flags == queue->flags) &&
   125bc:	1880751e 	bne	r3,r2,12794 <tcp_enqueue+0xb44>
    /* segments are consecutive */
    (ntohl(useg->tcphdr->seqno) + useg->len == ntohl(queue->tcphdr->seqno)) ) {
    /* Remove TCP header from first segment of our to-be-queued list */
    if(pbuf_header(queue->p, -(TCP_HLEN + optlen))) {
   125c0:	e0bff317 	ldw	r2,-52(fp)
   125c4:	10c00117 	ldw	r3,4(r2)
   125c8:	e0bff783 	ldbu	r2,-34(fp)
   125cc:	013ffb04 	movi	r4,-20
   125d0:	2085c83a 	sub	r2,r4,r2
   125d4:	10bfffcc 	andi	r2,r2,65535
   125d8:	10a0001c 	xori	r2,r2,32768
   125dc:	10a00004 	addi	r2,r2,-32768
   125e0:	1809883a 	mov	r4,r3
   125e4:	100b883a 	mov	r5,r2
   125e8:	0009f900 	call	9f90 <pbuf_header>
   125ec:	10803fcc 	andi	r2,r2,255
   125f0:	10000926 	beq	r2,zero,12618 <tcp_enqueue+0x9c8>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
   125f4:	010000f4 	movhi	r4,3
   125f8:	213e8004 	addi	r4,r4,-1536
   125fc:	014000f4 	movhi	r5,3
   12600:	297ee204 	addi	r5,r5,-1144
   12604:	018059c4 	movi	r6,359
   12608:	01c000f4 	movhi	r7,3
   1260c:	39fe9f04 	addi	r7,r7,-1412
   12610:	00170680 	call	17068 <printf>
   12614:	003fff06 	br	12614 <tcp_enqueue+0x9c4>
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    if (queue->p->len == 0) {
   12618:	e0bff317 	ldw	r2,-52(fp)
   1261c:	10800117 	ldw	r2,4(r2)
   12620:	1080028b 	ldhu	r2,10(r2)
   12624:	10bfffcc 	andi	r2,r2,65535
   12628:	10000f1e 	bne	r2,zero,12668 <tcp_enqueue+0xa18>
      /* free the first (header-only) pbuf if it is now empty (contained only headers) */
      struct pbuf *old_q = queue->p;
   1262c:	e0bff317 	ldw	r2,-52(fp)
   12630:	10800117 	ldw	r2,4(r2)
   12634:	e0bff815 	stw	r2,-32(fp)
      queue->p = queue->p->next;
   12638:	e0bff317 	ldw	r2,-52(fp)
   1263c:	10800117 	ldw	r2,4(r2)
   12640:	10c00017 	ldw	r3,0(r2)
   12644:	e0bff317 	ldw	r2,-52(fp)
   12648:	10c00115 	stw	r3,4(r2)
      old_q->next = NULL;
   1264c:	e0bff817 	ldw	r2,-32(fp)
   12650:	10000015 	stw	zero,0(r2)
      queuelen--;
   12654:	e0bff70b 	ldhu	r2,-36(fp)
   12658:	10bfffc4 	addi	r2,r2,-1
   1265c:	e0bff70d 	sth	r2,-36(fp)
      pbuf_free(old_q);
   12660:	e13ff817 	ldw	r4,-32(fp)
   12664:	000a1880 	call	a188 <pbuf_free>
    }
    if (flags & TCP_FIN) {
   12668:	e0bffd03 	ldbu	r2,-12(fp)
   1266c:	1080004c 	andi	r2,r2,1
   12670:	10001826 	beq	r2,zero,126d4 <tcp_enqueue+0xa84>
      /* the new segment contains only FIN, no data -> put the FIN into the last segment */
      LWIP_ASSERT("FIN enqueued together with data", queue->p == NULL && queue->len == 0);
   12674:	e0bff317 	ldw	r2,-52(fp)
   12678:	10800117 	ldw	r2,4(r2)
   1267c:	1000041e 	bne	r2,zero,12690 <tcp_enqueue+0xa40>
   12680:	e0bff317 	ldw	r2,-52(fp)
   12684:	1080030b 	ldhu	r2,12(r2)
   12688:	10bfffcc 	andi	r2,r2,65535
   1268c:	10000926 	beq	r2,zero,126b4 <tcp_enqueue+0xa64>
   12690:	010000f4 	movhi	r4,3
   12694:	213e8004 	addi	r4,r4,-1536
   12698:	014000f4 	movhi	r5,3
   1269c:	297ee704 	addi	r5,r5,-1124
   126a0:	01805d44 	movi	r6,373
   126a4:	01c000f4 	movhi	r7,3
   126a8:	39fe9f04 	addi	r7,r7,-1412
   126ac:	00170680 	call	17068 <printf>
   126b0:	003fff06 	br	126b0 <tcp_enqueue+0xa60>
      TCPH_SET_FLAG(useg->tcphdr, TCP_FIN);
   126b4:	e0bff217 	ldw	r2,-56(fp)
   126b8:	10800417 	ldw	r2,16(r2)
   126bc:	e0fff217 	ldw	r3,-56(fp)
   126c0:	18c00417 	ldw	r3,16(r3)
   126c4:	18c0030b 	ldhu	r3,12(r3)
   126c8:	18c04014 	ori	r3,r3,256
   126cc:	10c0030d 	sth	r3,12(r2)
   126d0:	00002406 	br	12764 <tcp_enqueue+0xb14>
    } else {
      LWIP_ASSERT("zero-length pbuf", (queue->p != NULL) && (queue->p->len > 0));
   126d4:	e0bff317 	ldw	r2,-52(fp)
   126d8:	10800117 	ldw	r2,4(r2)
   126dc:	10000526 	beq	r2,zero,126f4 <tcp_enqueue+0xaa4>
   126e0:	e0bff317 	ldw	r2,-52(fp)
   126e4:	10800117 	ldw	r2,4(r2)
   126e8:	1080028b 	ldhu	r2,10(r2)
   126ec:	10bfffcc 	andi	r2,r2,65535
   126f0:	1000091e 	bne	r2,zero,12718 <tcp_enqueue+0xac8>
   126f4:	010000f4 	movhi	r4,3
   126f8:	213e8004 	addi	r4,r4,-1536
   126fc:	014000f4 	movhi	r5,3
   12700:	297eef04 	addi	r5,r5,-1092
   12704:	01805e04 	movi	r6,376
   12708:	01c000f4 	movhi	r7,3
   1270c:	39fe9f04 	addi	r7,r7,-1412
   12710:	00170680 	call	17068 <printf>
   12714:	003fff06 	br	12714 <tcp_enqueue+0xac4>
      pbuf_cat(useg->p, queue->p);
   12718:	e0bff217 	ldw	r2,-56(fp)
   1271c:	10c00117 	ldw	r3,4(r2)
   12720:	e0bff317 	ldw	r2,-52(fp)
   12724:	10800117 	ldw	r2,4(r2)
   12728:	1809883a 	mov	r4,r3
   1272c:	100b883a 	mov	r5,r2
   12730:	000a3e00 	call	a3e0 <pbuf_cat>
      useg->len += queue->len;
   12734:	e0bff217 	ldw	r2,-56(fp)
   12738:	10c0030b 	ldhu	r3,12(r2)
   1273c:	e0bff317 	ldw	r2,-52(fp)
   12740:	1080030b 	ldhu	r2,12(r2)
   12744:	1885883a 	add	r2,r3,r2
   12748:	1007883a 	mov	r3,r2
   1274c:	e0bff217 	ldw	r2,-56(fp)
   12750:	10c0030d 	sth	r3,12(r2)
      useg->next = queue->next;
   12754:	e0bff317 	ldw	r2,-52(fp)
   12758:	10c00017 	ldw	r3,0(r2)
   1275c:	e0bff217 	ldw	r2,-56(fp)
   12760:	10c00015 	stw	r3,0(r2)
    }

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("tcp_enqueue: chaining segments, new len %"U16_F"\n", useg->len));
    if (seg == queue) {
   12764:	e0fff117 	ldw	r3,-60(fp)
   12768:	e0bff317 	ldw	r2,-52(fp)
   1276c:	1880051e 	bne	r3,r2,12784 <tcp_enqueue+0xb34>
      seg = useg;
   12770:	e0bff217 	ldw	r2,-56(fp)
   12774:	e0bff115 	stw	r2,-60(fp)
      seglen = useg->len;
   12778:	e0bff217 	ldw	r2,-56(fp)
   1277c:	1080030b 	ldhu	r2,12(r2)
   12780:	e0bff58d 	sth	r2,-42(fp)
    }
    memp_free(MEMP_TCP_SEG, queue);
   12784:	01000104 	movi	r4,4
   12788:	e17ff317 	ldw	r5,-52(fp)
   1278c:	00090e80 	call	90e8 <memp_free>
   12790:	00000906 	br	127b8 <tcp_enqueue+0xb68>
  }
  else {
    /* empty list */
    if (useg == NULL) {
   12794:	e0bff217 	ldw	r2,-56(fp)
   12798:	1000041e 	bne	r2,zero,127ac <tcp_enqueue+0xb5c>
      /* initialize list with this segment */
      pcb->unsent = queue;
   1279c:	e0bffa17 	ldw	r2,-24(fp)
   127a0:	e0fff317 	ldw	r3,-52(fp)
   127a4:	10c01e15 	stw	r3,120(r2)
   127a8:	00000306 	br	127b8 <tcp_enqueue+0xb68>
    }
    /* enqueue segment */
    else {
      useg->next = queue;
   127ac:	e0bff217 	ldw	r2,-56(fp)
   127b0:	e0fff317 	ldw	r3,-52(fp)
   127b4:	10c00015 	stw	r3,0(r2)
    }
  }
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
   127b8:	e0bffd03 	ldbu	r2,-12(fp)
   127bc:	1080008c 	andi	r2,r2,2
   127c0:	1000031e 	bne	r2,zero,127d0 <tcp_enqueue+0xb80>
   127c4:	e0bffd03 	ldbu	r2,-12(fp)
   127c8:	1080004c 	andi	r2,r2,1
   127cc:	10000326 	beq	r2,zero,127dc <tcp_enqueue+0xb8c>
    ++len;
   127d0:	e0bffc0b 	ldhu	r2,-16(fp)
   127d4:	10800044 	addi	r2,r2,1
   127d8:	e0bffc0d 	sth	r2,-16(fp)
  }
  if (flags & TCP_FIN) {
   127dc:	e0bffd03 	ldbu	r2,-12(fp)
   127e0:	1080004c 	andi	r2,r2,1
   127e4:	10000626 	beq	r2,zero,12800 <tcp_enqueue+0xbb0>
    pcb->flags |= TF_FIN;
   127e8:	e0bffa17 	ldw	r2,-24(fp)
   127ec:	10800983 	ldbu	r2,38(r2)
   127f0:	10800814 	ori	r2,r2,32
   127f4:	1007883a 	mov	r3,r2
   127f8:	e0bffa17 	ldw	r2,-24(fp)
   127fc:	10c00985 	stb	r3,38(r2)
  }
  pcb->snd_lbb += len;
   12800:	e0bffa17 	ldw	r2,-24(fp)
   12804:	10c01b17 	ldw	r3,108(r2)
   12808:	e0bffc0b 	ldhu	r2,-16(fp)
   1280c:	1887883a 	add	r3,r3,r2
   12810:	e0bffa17 	ldw	r2,-24(fp)
   12814:	10c01b15 	stw	r3,108(r2)

  pcb->snd_buf -= len;
   12818:	e0bffa17 	ldw	r2,-24(fp)
   1281c:	10c01c8b 	ldhu	r3,114(r2)
   12820:	e0bffc0b 	ldhu	r2,-16(fp)
   12824:	1885c83a 	sub	r2,r3,r2
   12828:	1007883a 	mov	r3,r2
   1282c:	e0bffa17 	ldw	r2,-24(fp)
   12830:	10c01c8d 	sth	r3,114(r2)

  /* update number of segments on the queues */
  pcb->snd_queuelen = queuelen;
   12834:	e0bffa17 	ldw	r2,-24(fp)
   12838:	e0fff70b 	ldhu	r3,-36(fp)
   1283c:	10c01d0d 	sth	r3,116(r2)
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
   12840:	e0bffa17 	ldw	r2,-24(fp)
   12844:	10801d0b 	ldhu	r2,116(r2)
   12848:	10bfffcc 	andi	r2,r2,65535
   1284c:	10000f26 	beq	r2,zero,1288c <tcp_enqueue+0xc3c>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
   12850:	e0bffa17 	ldw	r2,-24(fp)
   12854:	10801f17 	ldw	r2,124(r2)
   12858:	10000c1e 	bne	r2,zero,1288c <tcp_enqueue+0xc3c>
   1285c:	e0bffa17 	ldw	r2,-24(fp)
   12860:	10801e17 	ldw	r2,120(r2)
   12864:	1000091e 	bne	r2,zero,1288c <tcp_enqueue+0xc3c>
   12868:	010000f4 	movhi	r4,3
   1286c:	213e8004 	addi	r4,r4,-1536
   12870:	014000f4 	movhi	r5,3
   12874:	297ef404 	addi	r5,r5,-1072
   12878:	018067c4 	movi	r6,415
   1287c:	01c000f4 	movhi	r7,3
   12880:	39fe9f04 	addi	r7,r7,-1412
   12884:	00170680 	call	17068 <printf>
   12888:	003fff06 	br	12888 <tcp_enqueue+0xc38>
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued, but only
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
   1288c:	e0bff117 	ldw	r2,-60(fp)
   12890:	10000f26 	beq	r2,zero,128d0 <tcp_enqueue+0xc80>
   12894:	e0bff58b 	ldhu	r2,-42(fp)
   12898:	10000d26 	beq	r2,zero,128d0 <tcp_enqueue+0xc80>
   1289c:	e0bff117 	ldw	r2,-60(fp)
   128a0:	10800417 	ldw	r2,16(r2)
   128a4:	10000a26 	beq	r2,zero,128d0 <tcp_enqueue+0xc80>
   128a8:	e0bffe03 	ldbu	r2,-8(fp)
   128ac:	1080008c 	andi	r2,r2,2
   128b0:	1000071e 	bne	r2,zero,128d0 <tcp_enqueue+0xc80>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
   128b4:	e0bff117 	ldw	r2,-60(fp)
   128b8:	10800417 	ldw	r2,16(r2)
   128bc:	e0fff117 	ldw	r3,-60(fp)
   128c0:	18c00417 	ldw	r3,16(r3)
   128c4:	18c0030b 	ldhu	r3,12(r3)
   128c8:	18c20014 	ori	r3,r3,2048
   128cc:	10c0030d 	sth	r3,12(r2)
  }

  return ERR_OK;
   128d0:	0005883a 	mov	r2,zero
   128d4:	00002e06 	br	12990 <tcp_enqueue+0xd40>
    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
    if (seg == NULL) {
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, 
                  ("tcp_enqueue: could not allocate memory for tcp_seg\n"));
      goto memerr;
   128d8:	0001883a 	nop
   128dc:	00000506 	br	128f4 <tcp_enqueue+0xca4>
     * ROM or other static memory, and need not be copied.  */
    if (apiflags & TCP_WRITE_FLAG_COPY) {
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen + optlen, PBUF_RAM)) == NULL) {
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, 
                    ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
   128e0:	0001883a 	nop
   128e4:	00000306 	br	128f4 <tcp_enqueue+0xca4>
    else {
      /* First, allocate a pbuf for the headers. */
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, 
                    ("tcp_enqueue: could not allocate memory for header pbuf\n"));
        goto memerr;
   128e8:	0001883a 	nop
   128ec:	00000106 	br	128f4 <tcp_enqueue+0xca4>
    /* Now that there are more segments queued, we check again if the
    length of the queue exceeds the configured maximum or overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
        ("tcp_enqueue: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      goto memerr;
   128f0:	0001883a 	nop
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
   128f4:	e0bffa17 	ldw	r2,-24(fp)
   128f8:	10c00983 	ldbu	r3,38(r2)
   128fc:	00bfe004 	movi	r2,-128
   12900:	1884b03a 	or	r2,r3,r2
   12904:	1007883a 	mov	r3,r2
   12908:	e0bffa17 	ldw	r2,-24(fp)
   1290c:	10c00985 	stb	r3,38(r2)
  TCP_STATS_INC(tcp.memerr);
   12910:	00800134 	movhi	r2,4
   12914:	10916104 	addi	r2,r2,17796
   12918:	1080270b 	ldhu	r2,156(r2)
   1291c:	10800044 	addi	r2,r2,1
   12920:	1007883a 	mov	r3,r2
   12924:	00800134 	movhi	r2,4
   12928:	10916104 	addi	r2,r2,17796
   1292c:	10c0270d 	sth	r3,156(r2)

  if (queue != NULL) {
   12930:	e0bff317 	ldw	r2,-52(fp)
   12934:	10000226 	beq	r2,zero,12940 <tcp_enqueue+0xcf0>
    tcp_segs_free(queue);
   12938:	e13ff317 	ldw	r4,-52(fp)
   1293c:	000ca380 	call	ca38 <tcp_segs_free>
  }
  if (pcb->snd_queuelen != 0) {
   12940:	e0bffa17 	ldw	r2,-24(fp)
   12944:	10801d0b 	ldhu	r2,116(r2)
   12948:	10bfffcc 	andi	r2,r2,65535
   1294c:	10000f26 	beq	r2,zero,1298c <tcp_enqueue+0xd3c>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
   12950:	e0bffa17 	ldw	r2,-24(fp)
   12954:	10801f17 	ldw	r2,124(r2)
   12958:	10000c1e 	bne	r2,zero,1298c <tcp_enqueue+0xd3c>
   1295c:	e0bffa17 	ldw	r2,-24(fp)
   12960:	10801e17 	ldw	r2,120(r2)
   12964:	1000091e 	bne	r2,zero,1298c <tcp_enqueue+0xd3c>
   12968:	010000f4 	movhi	r4,3
   1296c:	213e8004 	addi	r4,r4,-1536
   12970:	014000f4 	movhi	r5,3
   12974:	297ef404 	addi	r5,r5,-1072
   12978:	01806c84 	movi	r6,434
   1297c:	01c000f4 	movhi	r7,3
   12980:	39fe9f04 	addi	r7,r7,-1412
   12984:	00170680 	call	17068 <printf>
   12988:	003fff06 	br	12988 <tcp_enqueue+0xd38>
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
   1298c:	00bfffc4 	movi	r2,-1
}
   12990:	e037883a 	mov	sp,fp
   12994:	dfc00117 	ldw	ra,4(sp)
   12998:	df000017 	ldw	fp,0(sp)
   1299c:	dec00204 	addi	sp,sp,8
   129a0:	f800283a 	ret

000129a4 <tcp_send_empty_ack>:
 *
 * @param pcb Protocol control block for the TCP connection to send the ACK
 */
err_t
tcp_send_empty_ack(struct tcp_pcb *pcb)
{
   129a4:	defff804 	addi	sp,sp,-32
   129a8:	dfc00715 	stw	ra,28(sp)
   129ac:	df000615 	stw	fp,24(sp)
   129b0:	df000604 	addi	fp,sp,24
   129b4:	e13fff15 	stw	r4,-4(fp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  u8_t optlen = 0;
   129b8:	e03ffc05 	stb	zero,-16(fp)
#if LWIP_TCP_TIMESTAMPS
  if (pcb->flags & TF_TIMESTAMP) {
    optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
  }
#endif
  p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen, PBUF_RAM);
   129bc:	e0bffc03 	ldbu	r2,-16(fp)
   129c0:	10800504 	addi	r2,r2,20
   129c4:	10bfffcc 	andi	r2,r2,65535
   129c8:	01000044 	movi	r4,1
   129cc:	100b883a 	mov	r5,r2
   129d0:	000d883a 	mov	r6,zero
   129d4:	00097cc0 	call	97cc <pbuf_alloc>
   129d8:	e0bffd15 	stw	r2,-12(fp)
  if (p == NULL) {
   129dc:	e0bffd17 	ldw	r2,-12(fp)
   129e0:	1000021e 	bne	r2,zero,129ec <tcp_send_empty_ack+0x48>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
    return ERR_BUF;
   129e4:	00bfff84 	movi	r2,-2
   129e8:	00004006 	br	12aec <tcp_send_empty_ack+0x148>
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, 
              ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
  /* remove ACK flags from the PCB, as we send an empty ACK now */
  pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
   129ec:	e0bfff17 	ldw	r2,-4(fp)
   129f0:	10c00983 	ldbu	r3,38(r2)
   129f4:	00bfff04 	movi	r2,-4
   129f8:	1884703a 	and	r2,r3,r2
   129fc:	1007883a 	mov	r3,r2
   12a00:	e0bfff17 	ldw	r2,-4(fp)
   12a04:	10c00985 	stb	r3,38(r2)

  tcphdr = tcp_output_set_header(pcb, p, optlen, htonl(pcb->snd_nxt));
   12a08:	e0fffc03 	ldbu	r3,-16(fp)
   12a0c:	e0bfff17 	ldw	r2,-4(fp)
   12a10:	10801717 	ldw	r2,92(r2)
   12a14:	1008d63a 	srli	r4,r2,24
   12a18:	e0bfff17 	ldw	r2,-4(fp)
   12a1c:	10801717 	ldw	r2,92(r2)
   12a20:	1004d23a 	srli	r2,r2,8
   12a24:	10bfc00c 	andi	r2,r2,65280
   12a28:	2088b03a 	or	r4,r4,r2
   12a2c:	e0bfff17 	ldw	r2,-4(fp)
   12a30:	10801717 	ldw	r2,92(r2)
   12a34:	10bfc00c 	andi	r2,r2,65280
   12a38:	1004923a 	slli	r2,r2,8
   12a3c:	2088b03a 	or	r4,r4,r2
   12a40:	e0bfff17 	ldw	r2,-4(fp)
   12a44:	10801717 	ldw	r2,92(r2)
   12a48:	1004963a 	slli	r2,r2,24
   12a4c:	2084b03a 	or	r2,r4,r2
   12a50:	e13fff17 	ldw	r4,-4(fp)
   12a54:	e17ffd17 	ldw	r5,-12(fp)
   12a58:	180d883a 	mov	r6,r3
   12a5c:	100f883a 	mov	r7,r2
   12a60:	00118bc0 	call	118bc <tcp_output_set_header>
   12a64:	e0bffe15 	stw	r2,-8(fp)
    tcp_build_timestamp_option(pcb, (u32_t *)(tcphdr + 1));
  }
#endif 

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
   12a68:	e0ffff17 	ldw	r3,-4(fp)
   12a6c:	e0bfff17 	ldw	r2,-4(fp)
   12a70:	10800104 	addi	r2,r2,4
        IP_PROTO_TCP, p->tot_len);
   12a74:	e13ffd17 	ldw	r4,-12(fp)
   12a78:	2100020b 	ldhu	r4,8(r4)
    tcp_build_timestamp_option(pcb, (u32_t *)(tcphdr + 1));
  }
#endif 

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
   12a7c:	213fffcc 	andi	r4,r4,65535
   12a80:	d9000015 	stw	r4,0(sp)
   12a84:	e13ffd17 	ldw	r4,-12(fp)
   12a88:	180b883a 	mov	r5,r3
   12a8c:	100d883a 	mov	r6,r2
   12a90:	01c00184 	movi	r7,6
   12a94:	0005e400 	call	5e40 <inet_chksum_pseudo>
   12a98:	e0fffe17 	ldw	r3,-8(fp)
   12a9c:	1880040d 	sth	r2,16(r3)
#endif
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
   12aa0:	e17fff17 	ldw	r5,-4(fp)
   12aa4:	e0bfff17 	ldw	r2,-4(fp)
   12aa8:	10c00104 	addi	r3,r2,4
   12aac:	e0bfff17 	ldw	r2,-4(fp)
   12ab0:	108002c3 	ldbu	r2,11(r2)
   12ab4:	10803fcc 	andi	r2,r2,255
   12ab8:	e13fff17 	ldw	r4,-4(fp)
   12abc:	21000283 	ldbu	r4,10(r4)
   12ac0:	21003fcc 	andi	r4,r4,255
   12ac4:	d9000015 	stw	r4,0(sp)
   12ac8:	01000184 	movi	r4,6
   12acc:	d9000115 	stw	r4,4(sp)
   12ad0:	e13ffd17 	ldw	r4,-12(fp)
   12ad4:	180d883a 	mov	r6,r3
   12ad8:	100f883a 	mov	r7,r2
   12adc:	0006d180 	call	6d18 <ip_output>
      IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
  pbuf_free(p);
   12ae0:	e13ffd17 	ldw	r4,-12(fp)
   12ae4:	000a1880 	call	a188 <pbuf_free>

  return ERR_OK;
   12ae8:	0005883a 	mov	r2,zero
}
   12aec:	e037883a 	mov	sp,fp
   12af0:	dfc00117 	ldw	ra,4(sp)
   12af4:	df000017 	ldw	fp,0(sp)
   12af8:	dec00204 	addi	sp,sp,8
   12afc:	f800283a 	ret

00012b00 <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
   12b00:	defff804 	addi	sp,sp,-32
   12b04:	dfc00715 	stw	ra,28(sp)
   12b08:	df000615 	stw	fp,24(sp)
   12b0c:	df000604 	addi	fp,sp,24
   12b10:	e13fff15 	stw	r4,-4(fp)

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
   12b14:	008000f4 	movhi	r2,3
   12b18:	1099cf04 	addi	r2,r2,26428
   12b1c:	10c00017 	ldw	r3,0(r2)
   12b20:	e0bfff17 	ldw	r2,-4(fp)
   12b24:	1880021e 	bne	r3,r2,12b30 <tcp_output+0x30>
    return ERR_OK;
   12b28:	0005883a 	mov	r2,zero
   12b2c:	00021406 	br	13380 <tcp_output+0x880>
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
   12b30:	e0bfff17 	ldw	r2,-4(fp)
   12b34:	1080158b 	ldhu	r2,86(r2)
   12b38:	e0ffff17 	ldw	r3,-4(fp)
   12b3c:	18c0180b 	ldhu	r3,96(r3)
   12b40:	113fffcc 	andi	r4,r2,65535
   12b44:	197fffcc 	andi	r5,r3,65535
   12b48:	2900012e 	bgeu	r5,r4,12b50 <tcp_output+0x50>
   12b4c:	1805883a 	mov	r2,r3
   12b50:	10bfffcc 	andi	r2,r2,65535
   12b54:	e0bffd15 	stw	r2,-12(fp)

  seg = pcb->unsent;
   12b58:	e0bfff17 	ldw	r2,-4(fp)
   12b5c:	10801e17 	ldw	r2,120(r2)
   12b60:	e0bffa15 	stw	r2,-24(fp)
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
   12b64:	e0bfff17 	ldw	r2,-4(fp)
   12b68:	10800983 	ldbu	r2,38(r2)
   12b6c:	10803fcc 	andi	r2,r2,255
   12b70:	1080008c 	andi	r2,r2,2
   12b74:	10002f26 	beq	r2,zero,12c34 <tcp_output+0x134>
   12b78:	e0bffa17 	ldw	r2,-24(fp)
   12b7c:	10002a26 	beq	r2,zero,12c28 <tcp_output+0x128>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
   12b80:	e0bffa17 	ldw	r2,-24(fp)
   12b84:	10800417 	ldw	r2,16(r2)
   12b88:	10c0010b 	ldhu	r3,4(r2)
   12b8c:	1080018b 	ldhu	r2,6(r2)
   12b90:	1004943a 	slli	r2,r2,16
   12b94:	10c4b03a 	or	r2,r2,r3
   12b98:	1006d63a 	srli	r3,r2,24
   12b9c:	e0bffa17 	ldw	r2,-24(fp)
   12ba0:	10800417 	ldw	r2,16(r2)
   12ba4:	1100010b 	ldhu	r4,4(r2)
   12ba8:	1080018b 	ldhu	r2,6(r2)
   12bac:	1004943a 	slli	r2,r2,16
   12bb0:	1104b03a 	or	r2,r2,r4
   12bb4:	1004d23a 	srli	r2,r2,8
   12bb8:	10bfc00c 	andi	r2,r2,65280
   12bbc:	1886b03a 	or	r3,r3,r2
   12bc0:	e0bffa17 	ldw	r2,-24(fp)
   12bc4:	10800417 	ldw	r2,16(r2)
   12bc8:	1100010b 	ldhu	r4,4(r2)
   12bcc:	1080018b 	ldhu	r2,6(r2)
   12bd0:	1004943a 	slli	r2,r2,16
   12bd4:	1104b03a 	or	r2,r2,r4
   12bd8:	10bfc00c 	andi	r2,r2,65280
   12bdc:	1004923a 	slli	r2,r2,8
   12be0:	1886b03a 	or	r3,r3,r2
   12be4:	e0bffa17 	ldw	r2,-24(fp)
   12be8:	10800417 	ldw	r2,16(r2)
   12bec:	1100010b 	ldhu	r4,4(r2)
   12bf0:	1080018b 	ldhu	r2,6(r2)
   12bf4:	1004943a 	slli	r2,r2,16
   12bf8:	1104b03a 	or	r2,r2,r4
   12bfc:	1004963a 	slli	r2,r2,24
   12c00:	1886b03a 	or	r3,r3,r2
   12c04:	e0bfff17 	ldw	r2,-4(fp)
   12c08:	10801417 	ldw	r2,80(r2)
   12c0c:	1887c83a 	sub	r3,r3,r2
   12c10:	e0bffa17 	ldw	r2,-24(fp)
   12c14:	1080030b 	ldhu	r2,12(r2)
   12c18:	10bfffcc 	andi	r2,r2,65535
   12c1c:	1885883a 	add	r2,r3,r2
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
   12c20:	e0fffd17 	ldw	r3,-12(fp)
   12c24:	1880032e 	bgeu	r3,r2,12c34 <tcp_output+0x134>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
     return tcp_send_empty_ack(pcb);
   12c28:	e13fff17 	ldw	r4,-4(fp)
   12c2c:	00129a40 	call	129a4 <tcp_send_empty_ack>
   12c30:	0001d306 	br	13380 <tcp_output+0x880>
  }

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
   12c34:	e0bfff17 	ldw	r2,-4(fp)
   12c38:	10801f17 	ldw	r2,124(r2)
   12c3c:	e0bffb15 	stw	r2,-20(fp)
  if (useg != NULL) {
   12c40:	e0bffb17 	ldw	r2,-20(fp)
   12c44:	10016226 	beq	r2,zero,131d0 <tcp_output+0x6d0>
    for (; useg->next != NULL; useg = useg->next);
   12c48:	00000306 	br	12c58 <tcp_output+0x158>
   12c4c:	e0bffb17 	ldw	r2,-20(fp)
   12c50:	10800017 	ldw	r2,0(r2)
   12c54:	e0bffb15 	stw	r2,-20(fp)
   12c58:	e0bffb17 	ldw	r2,-20(fp)
   12c5c:	10800017 	ldw	r2,0(r2)
   12c60:	103ffa1e 	bne	r2,zero,12c4c <tcp_output+0x14c>
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
   12c64:	00015a06 	br	131d0 <tcp_output+0x6d0>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
   12c68:	e0bffa17 	ldw	r2,-24(fp)
   12c6c:	10800417 	ldw	r2,16(r2)
   12c70:	1080030b 	ldhu	r2,12(r2)
   12c74:	10bfffcc 	andi	r2,r2,65535
   12c78:	1004d23a 	srli	r2,r2,8
   12c7c:	10ffffcc 	andi	r3,r2,65535
   12c80:	e0bffa17 	ldw	r2,-24(fp)
   12c84:	10800417 	ldw	r2,16(r2)
   12c88:	1080030b 	ldhu	r2,12(r2)
   12c8c:	10bfffcc 	andi	r2,r2,65535
   12c90:	1004923a 	slli	r2,r2,8
   12c94:	10bfffcc 	andi	r2,r2,65535
   12c98:	1884b03a 	or	r2,r3,r2
   12c9c:	1080010c 	andi	r2,r2,4
   12ca0:	10000926 	beq	r2,zero,12cc8 <tcp_output+0x1c8>
   12ca4:	010000f4 	movhi	r4,3
   12ca8:	213e8004 	addi	r4,r4,-1536
   12cac:	014000f4 	movhi	r5,3
   12cb0:	297efc04 	addi	r5,r5,-1040
   12cb4:	01809144 	movi	r6,581
   12cb8:	01c000f4 	movhi	r7,3
   12cbc:	39fe9f04 	addi	r7,r7,-1412
   12cc0:	00170680 	call	17068 <printf>
   12cc4:	003fff06 	br	12cc4 <tcp_output+0x1c4>
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
   12cc8:	e0bfff17 	ldw	r2,-4(fp)
   12ccc:	10801f17 	ldw	r2,124(r2)
   12cd0:	10001426 	beq	r2,zero,12d24 <tcp_output+0x224>
   12cd4:	e0bfff17 	ldw	r2,-4(fp)
   12cd8:	10800983 	ldbu	r2,38(r2)
   12cdc:	10803fcc 	andi	r2,r2,255
   12ce0:	1080110c 	andi	r2,r2,68
   12ce4:	10000f1e 	bne	r2,zero,12d24 <tcp_output+0x224>
   12ce8:	e0bfff17 	ldw	r2,-4(fp)
   12cec:	10801e17 	ldw	r2,120(r2)
   12cf0:	10000e26 	beq	r2,zero,12d2c <tcp_output+0x22c>
   12cf4:	e0bfff17 	ldw	r2,-4(fp)
   12cf8:	10801e17 	ldw	r2,120(r2)
   12cfc:	10800017 	ldw	r2,0(r2)
   12d00:	1000081e 	bne	r2,zero,12d24 <tcp_output+0x224>
   12d04:	e0bfff17 	ldw	r2,-4(fp)
   12d08:	10801e17 	ldw	r2,120(r2)
   12d0c:	10c0030b 	ldhu	r3,12(r2)
   12d10:	e0bfff17 	ldw	r2,-4(fp)
   12d14:	10800f0b 	ldhu	r2,60(r2)
   12d18:	18ffffcc 	andi	r3,r3,65535
   12d1c:	10bfffcc 	andi	r2,r2,65535
   12d20:	18800236 	bltu	r3,r2,12d2c <tcp_output+0x22c>
   12d24:	00800044 	movi	r2,1
   12d28:	00000106 	br	12d30 <tcp_output+0x230>
   12d2c:	0005883a 	mov	r2,zero
   12d30:	1000051e 	bne	r2,zero,12d48 <tcp_output+0x248>
      ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
   12d34:	e0bfff17 	ldw	r2,-4(fp)
   12d38:	10800983 	ldbu	r2,38(r2)
   12d3c:	10803fcc 	andi	r2,r2,255
   12d40:	1080280c 	andi	r2,r2,160
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
   12d44:	10014f26 	beq	r2,zero,13284 <tcp_output+0x784>
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
   12d48:	e0bffa17 	ldw	r2,-24(fp)
   12d4c:	10c00017 	ldw	r3,0(r2)
   12d50:	e0bfff17 	ldw	r2,-4(fp)
   12d54:	10c01e15 	stw	r3,120(r2)

    if (pcb->state != SYN_SENT) {
   12d58:	e0bfff17 	ldw	r2,-4(fp)
   12d5c:	10800417 	ldw	r2,16(r2)
   12d60:	108000a0 	cmpeqi	r2,r2,2
   12d64:	10000e1e 	bne	r2,zero,12da0 <tcp_output+0x2a0>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
   12d68:	e0bffa17 	ldw	r2,-24(fp)
   12d6c:	10800417 	ldw	r2,16(r2)
   12d70:	e0fffa17 	ldw	r3,-24(fp)
   12d74:	18c00417 	ldw	r3,16(r3)
   12d78:	18c0030b 	ldhu	r3,12(r3)
   12d7c:	18c40014 	ori	r3,r3,4096
   12d80:	10c0030d 	sth	r3,12(r2)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
   12d84:	e0bfff17 	ldw	r2,-4(fp)
   12d88:	10c00983 	ldbu	r3,38(r2)
   12d8c:	00bfff04 	movi	r2,-4
   12d90:	1884703a 	and	r2,r3,r2
   12d94:	1007883a 	mov	r3,r2
   12d98:	e0bfff17 	ldw	r2,-4(fp)
   12d9c:	10c00985 	stb	r3,38(r2)
    }

    tcp_output_segment(seg, pcb);
   12da0:	e13ffa17 	ldw	r4,-24(fp)
   12da4:	e17fff17 	ldw	r5,-4(fp)
   12da8:	00133940 	call	13394 <tcp_output_segment>
    snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
   12dac:	e0bffa17 	ldw	r2,-24(fp)
   12db0:	10800417 	ldw	r2,16(r2)
   12db4:	10c0010b 	ldhu	r3,4(r2)
   12db8:	1080018b 	ldhu	r2,6(r2)
   12dbc:	1004943a 	slli	r2,r2,16
   12dc0:	10c4b03a 	or	r2,r2,r3
   12dc4:	1006d63a 	srli	r3,r2,24
   12dc8:	e0bffa17 	ldw	r2,-24(fp)
   12dcc:	10800417 	ldw	r2,16(r2)
   12dd0:	1100010b 	ldhu	r4,4(r2)
   12dd4:	1080018b 	ldhu	r2,6(r2)
   12dd8:	1004943a 	slli	r2,r2,16
   12ddc:	1104b03a 	or	r2,r2,r4
   12de0:	1004d23a 	srli	r2,r2,8
   12de4:	10bfc00c 	andi	r2,r2,65280
   12de8:	1886b03a 	or	r3,r3,r2
   12dec:	e0bffa17 	ldw	r2,-24(fp)
   12df0:	10800417 	ldw	r2,16(r2)
   12df4:	1100010b 	ldhu	r4,4(r2)
   12df8:	1080018b 	ldhu	r2,6(r2)
   12dfc:	1004943a 	slli	r2,r2,16
   12e00:	1104b03a 	or	r2,r2,r4
   12e04:	10bfc00c 	andi	r2,r2,65280
   12e08:	1004923a 	slli	r2,r2,8
   12e0c:	1886b03a 	or	r3,r3,r2
   12e10:	e0bffa17 	ldw	r2,-24(fp)
   12e14:	10800417 	ldw	r2,16(r2)
   12e18:	1100010b 	ldhu	r4,4(r2)
   12e1c:	1080018b 	ldhu	r2,6(r2)
   12e20:	1004943a 	slli	r2,r2,16
   12e24:	1104b03a 	or	r2,r2,r4
   12e28:	1004963a 	slli	r2,r2,24
   12e2c:	1886b03a 	or	r3,r3,r2
   12e30:	e0bffa17 	ldw	r2,-24(fp)
   12e34:	1080030b 	ldhu	r2,12(r2)
   12e38:	113fffcc 	andi	r4,r2,65535
   12e3c:	e0bffa17 	ldw	r2,-24(fp)
   12e40:	10800417 	ldw	r2,16(r2)
   12e44:	1080030b 	ldhu	r2,12(r2)
   12e48:	10bfffcc 	andi	r2,r2,65535
   12e4c:	1004d23a 	srli	r2,r2,8
   12e50:	117fffcc 	andi	r5,r2,65535
   12e54:	e0bffa17 	ldw	r2,-24(fp)
   12e58:	10800417 	ldw	r2,16(r2)
   12e5c:	1080030b 	ldhu	r2,12(r2)
   12e60:	10bfffcc 	andi	r2,r2,65535
   12e64:	1004923a 	slli	r2,r2,8
   12e68:	10bfffcc 	andi	r2,r2,65535
   12e6c:	2884b03a 	or	r2,r5,r2
   12e70:	108000cc 	andi	r2,r2,3
   12e74:	1004c03a 	cmpne	r2,r2,zero
   12e78:	10803fcc 	andi	r2,r2,255
   12e7c:	2085883a 	add	r2,r4,r2
   12e80:	1885883a 	add	r2,r3,r2
   12e84:	e0bffe15 	stw	r2,-8(fp)
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
   12e88:	e0bfff17 	ldw	r2,-4(fp)
   12e8c:	10c01717 	ldw	r3,92(r2)
   12e90:	e0bffe17 	ldw	r2,-8(fp)
   12e94:	1885c83a 	sub	r2,r3,r2
   12e98:	1000030e 	bge	r2,zero,12ea8 <tcp_output+0x3a8>
      pcb->snd_nxt = snd_nxt;
   12e9c:	e0bfff17 	ldw	r2,-4(fp)
   12ea0:	e0fffe17 	ldw	r3,-8(fp)
   12ea4:	10c01715 	stw	r3,92(r2)
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
   12ea8:	e0bffa17 	ldw	r2,-24(fp)
   12eac:	1080030b 	ldhu	r2,12(r2)
   12eb0:	10ffffcc 	andi	r3,r2,65535
   12eb4:	e0bffa17 	ldw	r2,-24(fp)
   12eb8:	10800417 	ldw	r2,16(r2)
   12ebc:	1080030b 	ldhu	r2,12(r2)
   12ec0:	10bfffcc 	andi	r2,r2,65535
   12ec4:	1004d23a 	srli	r2,r2,8
   12ec8:	113fffcc 	andi	r4,r2,65535
   12ecc:	e0bffa17 	ldw	r2,-24(fp)
   12ed0:	10800417 	ldw	r2,16(r2)
   12ed4:	1080030b 	ldhu	r2,12(r2)
   12ed8:	10bfffcc 	andi	r2,r2,65535
   12edc:	1004923a 	slli	r2,r2,8
   12ee0:	10bfffcc 	andi	r2,r2,65535
   12ee4:	2084b03a 	or	r2,r4,r2
   12ee8:	108000cc 	andi	r2,r2,3
   12eec:	1004c03a 	cmpne	r2,r2,zero
   12ef0:	10803fcc 	andi	r2,r2,255
   12ef4:	1885883a 	add	r2,r3,r2
   12ef8:	0080b00e 	bge	zero,r2,131bc <tcp_output+0x6bc>
      seg->next = NULL;
   12efc:	e0bffa17 	ldw	r2,-24(fp)
   12f00:	10000015 	stw	zero,0(r2)
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
   12f04:	e0bfff17 	ldw	r2,-4(fp)
   12f08:	10801f17 	ldw	r2,124(r2)
   12f0c:	1000061e 	bne	r2,zero,12f28 <tcp_output+0x428>
        pcb->unacked = seg;
   12f10:	e0bfff17 	ldw	r2,-4(fp)
   12f14:	e0fffa17 	ldw	r3,-24(fp)
   12f18:	10c01f15 	stw	r3,124(r2)
        useg = seg;
   12f1c:	e0bffa17 	ldw	r2,-24(fp)
   12f20:	e0bffb15 	stw	r2,-20(fp)
   12f24:	0000a706 	br	131c4 <tcp_output+0x6c4>
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
   12f28:	e0bffa17 	ldw	r2,-24(fp)
   12f2c:	10800417 	ldw	r2,16(r2)
   12f30:	10c0010b 	ldhu	r3,4(r2)
   12f34:	1080018b 	ldhu	r2,6(r2)
   12f38:	1004943a 	slli	r2,r2,16
   12f3c:	10c4b03a 	or	r2,r2,r3
   12f40:	1006d63a 	srli	r3,r2,24
   12f44:	e0bffa17 	ldw	r2,-24(fp)
   12f48:	10800417 	ldw	r2,16(r2)
   12f4c:	1100010b 	ldhu	r4,4(r2)
   12f50:	1080018b 	ldhu	r2,6(r2)
   12f54:	1004943a 	slli	r2,r2,16
   12f58:	1104b03a 	or	r2,r2,r4
   12f5c:	1004d23a 	srli	r2,r2,8
   12f60:	10bfc00c 	andi	r2,r2,65280
   12f64:	1886b03a 	or	r3,r3,r2
   12f68:	e0bffa17 	ldw	r2,-24(fp)
   12f6c:	10800417 	ldw	r2,16(r2)
   12f70:	1100010b 	ldhu	r4,4(r2)
   12f74:	1080018b 	ldhu	r2,6(r2)
   12f78:	1004943a 	slli	r2,r2,16
   12f7c:	1104b03a 	or	r2,r2,r4
   12f80:	10bfc00c 	andi	r2,r2,65280
   12f84:	1004923a 	slli	r2,r2,8
   12f88:	1886b03a 	or	r3,r3,r2
   12f8c:	e0bffa17 	ldw	r2,-24(fp)
   12f90:	10800417 	ldw	r2,16(r2)
   12f94:	1100010b 	ldhu	r4,4(r2)
   12f98:	1080018b 	ldhu	r2,6(r2)
   12f9c:	1004943a 	slli	r2,r2,16
   12fa0:	1104b03a 	or	r2,r2,r4
   12fa4:	1004963a 	slli	r2,r2,24
   12fa8:	1886b03a 	or	r3,r3,r2
   12fac:	e0bffb17 	ldw	r2,-20(fp)
   12fb0:	10800417 	ldw	r2,16(r2)
   12fb4:	1100010b 	ldhu	r4,4(r2)
   12fb8:	1080018b 	ldhu	r2,6(r2)
   12fbc:	1004943a 	slli	r2,r2,16
   12fc0:	1104b03a 	or	r2,r2,r4
   12fc4:	1008d63a 	srli	r4,r2,24
   12fc8:	e0bffb17 	ldw	r2,-20(fp)
   12fcc:	10800417 	ldw	r2,16(r2)
   12fd0:	1140010b 	ldhu	r5,4(r2)
   12fd4:	1080018b 	ldhu	r2,6(r2)
   12fd8:	1004943a 	slli	r2,r2,16
   12fdc:	1144b03a 	or	r2,r2,r5
   12fe0:	1004d23a 	srli	r2,r2,8
   12fe4:	10bfc00c 	andi	r2,r2,65280
   12fe8:	2088b03a 	or	r4,r4,r2
   12fec:	e0bffb17 	ldw	r2,-20(fp)
   12ff0:	10800417 	ldw	r2,16(r2)
   12ff4:	1140010b 	ldhu	r5,4(r2)
   12ff8:	1080018b 	ldhu	r2,6(r2)
   12ffc:	1004943a 	slli	r2,r2,16
   13000:	1144b03a 	or	r2,r2,r5
   13004:	10bfc00c 	andi	r2,r2,65280
   13008:	1004923a 	slli	r2,r2,8
   1300c:	2088b03a 	or	r4,r4,r2
   13010:	e0bffb17 	ldw	r2,-20(fp)
   13014:	10800417 	ldw	r2,16(r2)
   13018:	1140010b 	ldhu	r5,4(r2)
   1301c:	1080018b 	ldhu	r2,6(r2)
   13020:	1004943a 	slli	r2,r2,16
   13024:	1144b03a 	or	r2,r2,r5
   13028:	1004963a 	slli	r2,r2,24
   1302c:	2084b03a 	or	r2,r4,r2
   13030:	1885c83a 	sub	r2,r3,r2
   13034:	10005a0e 	bge	r2,zero,131a0 <tcp_output+0x6a0>
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
   13038:	e0bfff17 	ldw	r2,-4(fp)
   1303c:	10801f04 	addi	r2,r2,124
   13040:	e0bffc15 	stw	r2,-16(fp)
          while (*cur_seg &&
   13044:	00000306 	br	13054 <tcp_output+0x554>
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
              cur_seg = &((*cur_seg)->next );
   13048:	e0bffc17 	ldw	r2,-16(fp)
   1304c:	10800017 	ldw	r2,0(r2)
   13050:	e0bffc15 	stw	r2,-16(fp)
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
          while (*cur_seg &&
   13054:	e0bffc17 	ldw	r2,-16(fp)
   13058:	10800017 	ldw	r2,0(r2)
   1305c:	10004826 	beq	r2,zero,13180 <tcp_output+0x680>
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
   13060:	e0bffc17 	ldw	r2,-16(fp)
   13064:	10800017 	ldw	r2,0(r2)
   13068:	10800417 	ldw	r2,16(r2)
   1306c:	10c0010b 	ldhu	r3,4(r2)
   13070:	1080018b 	ldhu	r2,6(r2)
   13074:	1004943a 	slli	r2,r2,16
   13078:	10c4b03a 	or	r2,r2,r3
   1307c:	1006d63a 	srli	r3,r2,24
   13080:	e0bffc17 	ldw	r2,-16(fp)
   13084:	10800017 	ldw	r2,0(r2)
   13088:	10800417 	ldw	r2,16(r2)
   1308c:	1100010b 	ldhu	r4,4(r2)
   13090:	1080018b 	ldhu	r2,6(r2)
   13094:	1004943a 	slli	r2,r2,16
   13098:	1104b03a 	or	r2,r2,r4
   1309c:	1004d23a 	srli	r2,r2,8
   130a0:	10bfc00c 	andi	r2,r2,65280
   130a4:	1886b03a 	or	r3,r3,r2
   130a8:	e0bffc17 	ldw	r2,-16(fp)
   130ac:	10800017 	ldw	r2,0(r2)
   130b0:	10800417 	ldw	r2,16(r2)
   130b4:	1100010b 	ldhu	r4,4(r2)
   130b8:	1080018b 	ldhu	r2,6(r2)
   130bc:	1004943a 	slli	r2,r2,16
   130c0:	1104b03a 	or	r2,r2,r4
   130c4:	10bfc00c 	andi	r2,r2,65280
   130c8:	1004923a 	slli	r2,r2,8
   130cc:	1886b03a 	or	r3,r3,r2
   130d0:	e0bffc17 	ldw	r2,-16(fp)
   130d4:	10800017 	ldw	r2,0(r2)
   130d8:	10800417 	ldw	r2,16(r2)
   130dc:	1100010b 	ldhu	r4,4(r2)
   130e0:	1080018b 	ldhu	r2,6(r2)
   130e4:	1004943a 	slli	r2,r2,16
   130e8:	1104b03a 	or	r2,r2,r4
   130ec:	1004963a 	slli	r2,r2,24
   130f0:	1886b03a 	or	r3,r3,r2
   130f4:	e0bffa17 	ldw	r2,-24(fp)
   130f8:	10800417 	ldw	r2,16(r2)
   130fc:	1100010b 	ldhu	r4,4(r2)
   13100:	1080018b 	ldhu	r2,6(r2)
   13104:	1004943a 	slli	r2,r2,16
   13108:	1104b03a 	or	r2,r2,r4
   1310c:	1008d63a 	srli	r4,r2,24
   13110:	e0bffa17 	ldw	r2,-24(fp)
   13114:	10800417 	ldw	r2,16(r2)
   13118:	1140010b 	ldhu	r5,4(r2)
   1311c:	1080018b 	ldhu	r2,6(r2)
   13120:	1004943a 	slli	r2,r2,16
   13124:	1144b03a 	or	r2,r2,r5
   13128:	1004d23a 	srli	r2,r2,8
   1312c:	10bfc00c 	andi	r2,r2,65280
   13130:	2088b03a 	or	r4,r4,r2
   13134:	e0bffa17 	ldw	r2,-24(fp)
   13138:	10800417 	ldw	r2,16(r2)
   1313c:	1140010b 	ldhu	r5,4(r2)
   13140:	1080018b 	ldhu	r2,6(r2)
   13144:	1004943a 	slli	r2,r2,16
   13148:	1144b03a 	or	r2,r2,r5
   1314c:	10bfc00c 	andi	r2,r2,65280
   13150:	1004923a 	slli	r2,r2,8
   13154:	2088b03a 	or	r4,r4,r2
   13158:	e0bffa17 	ldw	r2,-24(fp)
   1315c:	10800417 	ldw	r2,16(r2)
   13160:	1140010b 	ldhu	r5,4(r2)
   13164:	1080018b 	ldhu	r2,6(r2)
   13168:	1004943a 	slli	r2,r2,16
   1316c:	1144b03a 	or	r2,r2,r5
   13170:	1004963a 	slli	r2,r2,24
   13174:	2084b03a 	or	r2,r4,r2
   13178:	1885c83a 	sub	r2,r3,r2
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
          while (*cur_seg &&
   1317c:	103fb216 	blt	r2,zero,13048 <tcp_output+0x548>
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
              cur_seg = &((*cur_seg)->next );
          }
          seg->next = (*cur_seg);
   13180:	e0bffc17 	ldw	r2,-16(fp)
   13184:	10c00017 	ldw	r3,0(r2)
   13188:	e0bffa17 	ldw	r2,-24(fp)
   1318c:	10c00015 	stw	r3,0(r2)
          (*cur_seg) = seg;
   13190:	e0bffc17 	ldw	r2,-16(fp)
   13194:	e0fffa17 	ldw	r3,-24(fp)
   13198:	10c00015 	stw	r3,0(r2)
   1319c:	00000906 	br	131c4 <tcp_output+0x6c4>
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
   131a0:	e0bffb17 	ldw	r2,-20(fp)
   131a4:	e0fffa17 	ldw	r3,-24(fp)
   131a8:	10c00015 	stw	r3,0(r2)
          useg = useg->next;
   131ac:	e0bffb17 	ldw	r2,-20(fp)
   131b0:	10800017 	ldw	r2,0(r2)
   131b4:	e0bffb15 	stw	r2,-20(fp)
   131b8:	00000206 	br	131c4 <tcp_output+0x6c4>
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
   131bc:	e13ffa17 	ldw	r4,-24(fp)
   131c0:	000ca9c0 	call	ca9c <tcp_seg_free>
    }
    seg = pcb->unsent;
   131c4:	e0bfff17 	ldw	r2,-4(fp)
   131c8:	10801e17 	ldw	r2,120(r2)
   131cc:	e0bffa15 	stw	r2,-24(fp)
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
   131d0:	e0bffa17 	ldw	r2,-24(fp)
   131d4:	10002c26 	beq	r2,zero,13288 <tcp_output+0x788>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
   131d8:	e0bffa17 	ldw	r2,-24(fp)
   131dc:	10800417 	ldw	r2,16(r2)
   131e0:	10c0010b 	ldhu	r3,4(r2)
   131e4:	1080018b 	ldhu	r2,6(r2)
   131e8:	1004943a 	slli	r2,r2,16
   131ec:	10c4b03a 	or	r2,r2,r3
   131f0:	1006d63a 	srli	r3,r2,24
   131f4:	e0bffa17 	ldw	r2,-24(fp)
   131f8:	10800417 	ldw	r2,16(r2)
   131fc:	1100010b 	ldhu	r4,4(r2)
   13200:	1080018b 	ldhu	r2,6(r2)
   13204:	1004943a 	slli	r2,r2,16
   13208:	1104b03a 	or	r2,r2,r4
   1320c:	1004d23a 	srli	r2,r2,8
   13210:	10bfc00c 	andi	r2,r2,65280
   13214:	1886b03a 	or	r3,r3,r2
   13218:	e0bffa17 	ldw	r2,-24(fp)
   1321c:	10800417 	ldw	r2,16(r2)
   13220:	1100010b 	ldhu	r4,4(r2)
   13224:	1080018b 	ldhu	r2,6(r2)
   13228:	1004943a 	slli	r2,r2,16
   1322c:	1104b03a 	or	r2,r2,r4
   13230:	10bfc00c 	andi	r2,r2,65280
   13234:	1004923a 	slli	r2,r2,8
   13238:	1886b03a 	or	r3,r3,r2
   1323c:	e0bffa17 	ldw	r2,-24(fp)
   13240:	10800417 	ldw	r2,16(r2)
   13244:	1100010b 	ldhu	r4,4(r2)
   13248:	1080018b 	ldhu	r2,6(r2)
   1324c:	1004943a 	slli	r2,r2,16
   13250:	1104b03a 	or	r2,r2,r4
   13254:	1004963a 	slli	r2,r2,24
   13258:	1886b03a 	or	r3,r3,r2
   1325c:	e0bfff17 	ldw	r2,-4(fp)
   13260:	10801417 	ldw	r2,80(r2)
   13264:	1887c83a 	sub	r3,r3,r2
   13268:	e0bffa17 	ldw	r2,-24(fp)
   1326c:	1080030b 	ldhu	r2,12(r2)
   13270:	10bfffcc 	andi	r2,r2,65535
   13274:	1885883a 	add	r2,r3,r2
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
   13278:	e0fffd17 	ldw	r3,-12(fp)
   1327c:	18be7a2e 	bgeu	r3,r2,12c68 <tcp_output+0x168>
   13280:	00000106 	br	13288 <tcp_output+0x788>
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
      ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
      break;
   13284:	0001883a 	nop
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
   13288:	e0bffa17 	ldw	r2,-24(fp)
   1328c:	10003526 	beq	r2,zero,13364 <tcp_output+0x864>
   13290:	e0bfff17 	ldw	r2,-4(fp)
   13294:	10802903 	ldbu	r2,164(r2)
   13298:	10803fcc 	andi	r2,r2,255
   1329c:	1000311e 	bne	r2,zero,13364 <tcp_output+0x864>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
   132a0:	e0bffa17 	ldw	r2,-24(fp)
   132a4:	10800417 	ldw	r2,16(r2)
   132a8:	10c0010b 	ldhu	r3,4(r2)
   132ac:	1080018b 	ldhu	r2,6(r2)
   132b0:	1004943a 	slli	r2,r2,16
   132b4:	10c4b03a 	or	r2,r2,r3
   132b8:	1006d63a 	srli	r3,r2,24
   132bc:	e0bffa17 	ldw	r2,-24(fp)
   132c0:	10800417 	ldw	r2,16(r2)
   132c4:	1100010b 	ldhu	r4,4(r2)
   132c8:	1080018b 	ldhu	r2,6(r2)
   132cc:	1004943a 	slli	r2,r2,16
   132d0:	1104b03a 	or	r2,r2,r4
   132d4:	1004d23a 	srli	r2,r2,8
   132d8:	10bfc00c 	andi	r2,r2,65280
   132dc:	1886b03a 	or	r3,r3,r2
   132e0:	e0bffa17 	ldw	r2,-24(fp)
   132e4:	10800417 	ldw	r2,16(r2)
   132e8:	1100010b 	ldhu	r4,4(r2)
   132ec:	1080018b 	ldhu	r2,6(r2)
   132f0:	1004943a 	slli	r2,r2,16
   132f4:	1104b03a 	or	r2,r2,r4
   132f8:	10bfc00c 	andi	r2,r2,65280
   132fc:	1004923a 	slli	r2,r2,8
   13300:	1886b03a 	or	r3,r3,r2
   13304:	e0bffa17 	ldw	r2,-24(fp)
   13308:	10800417 	ldw	r2,16(r2)
   1330c:	1100010b 	ldhu	r4,4(r2)
   13310:	1080018b 	ldhu	r2,6(r2)
   13314:	1004943a 	slli	r2,r2,16
   13318:	1104b03a 	or	r2,r2,r4
   1331c:	1004963a 	slli	r2,r2,24
   13320:	1886b03a 	or	r3,r3,r2
   13324:	e0bfff17 	ldw	r2,-4(fp)
   13328:	10801417 	ldw	r2,80(r2)
   1332c:	1887c83a 	sub	r3,r3,r2
   13330:	e0bffa17 	ldw	r2,-24(fp)
   13334:	1080030b 	ldhu	r2,12(r2)
   13338:	10bfffcc 	andi	r2,r2,65535
   1333c:	1885883a 	add	r2,r3,r2
   13340:	e0ffff17 	ldw	r3,-4(fp)
   13344:	18c0180b 	ldhu	r3,96(r3)
   13348:	18ffffcc 	andi	r3,r3,65535
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
   1334c:	1880052e 	bgeu	r3,r2,13364 <tcp_output+0x864>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
    /* prepare for persist timer */
    pcb->persist_cnt = 0;
   13350:	e0bfff17 	ldw	r2,-4(fp)
   13354:	10002815 	stw	zero,160(r2)
    pcb->persist_backoff = 1;
   13358:	e0bfff17 	ldw	r2,-4(fp)
   1335c:	00c00044 	movi	r3,1
   13360:	10c02905 	stb	r3,164(r2)
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
   13364:	e0bfff17 	ldw	r2,-4(fp)
   13368:	10800983 	ldbu	r2,38(r2)
   1336c:	10801fcc 	andi	r2,r2,127
   13370:	1007883a 	mov	r3,r2
   13374:	e0bfff17 	ldw	r2,-4(fp)
   13378:	10c00985 	stb	r3,38(r2)
  return ERR_OK;
   1337c:	0005883a 	mov	r2,zero
}
   13380:	e037883a 	mov	sp,fp
   13384:	dfc00117 	ldw	ra,4(sp)
   13388:	df000017 	ldw	fp,0(sp)
   1338c:	dec00204 	addi	sp,sp,8
   13390:	f800283a 	ret

00013394 <tcp_output_segment>:
 * @param seg the tcp_seg to send
 * @param pcb the tcp_pcb for the TCP connection used to send the segment
 */
static void
tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb)
{
   13394:	defff604 	addi	sp,sp,-40
   13398:	dfc00915 	stw	ra,36(sp)
   1339c:	df000815 	stw	fp,32(sp)
   133a0:	dc000715 	stw	r16,28(sp)
   133a4:	df000704 	addi	fp,sp,28
   133a8:	e13ffe15 	stw	r4,-8(fp)
   133ac:	e17fff15 	stw	r5,-4(fp)
  /** @bug Exclude retransmitted segments from this count. */
  snmp_inc_tcpoutsegs();

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
   133b0:	e0bffe17 	ldw	r2,-8(fp)
   133b4:	10800417 	ldw	r2,16(r2)
   133b8:	e0ffff17 	ldw	r3,-4(fp)
   133bc:	18c00a17 	ldw	r3,40(r3)
   133c0:	1808d63a 	srli	r4,r3,24
   133c4:	e0ffff17 	ldw	r3,-4(fp)
   133c8:	18c00a17 	ldw	r3,40(r3)
   133cc:	1806d23a 	srli	r3,r3,8
   133d0:	18ffc00c 	andi	r3,r3,65280
   133d4:	20c8b03a 	or	r4,r4,r3
   133d8:	e0ffff17 	ldw	r3,-4(fp)
   133dc:	18c00a17 	ldw	r3,40(r3)
   133e0:	18ffc00c 	andi	r3,r3,65280
   133e4:	1806923a 	slli	r3,r3,8
   133e8:	20c8b03a 	or	r4,r4,r3
   133ec:	e0ffff17 	ldw	r3,-4(fp)
   133f0:	18c00a17 	ldw	r3,40(r3)
   133f4:	1806963a 	slli	r3,r3,24
   133f8:	20c6b03a 	or	r3,r4,r3
   133fc:	193fffcc 	andi	r4,r3,65535
   13400:	1140020b 	ldhu	r5,8(r2)
   13404:	280a703a 	and	r5,r5,zero
   13408:	2908b03a 	or	r4,r5,r4
   1340c:	1100020d 	sth	r4,8(r2)
   13410:	1806d43a 	srli	r3,r3,16
   13414:	1100028b 	ldhu	r4,10(r2)
   13418:	2008703a 	and	r4,r4,zero
   1341c:	20c6b03a 	or	r3,r4,r3
   13420:	10c0028d 	sth	r3,10(r2)

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
   13424:	e0bffe17 	ldw	r2,-8(fp)
   13428:	10800417 	ldw	r2,16(r2)
   1342c:	e0ffff17 	ldw	r3,-4(fp)
   13430:	18c00b8b 	ldhu	r3,46(r3)
   13434:	18ffffcc 	andi	r3,r3,65535
   13438:	1806d23a 	srli	r3,r3,8
   1343c:	1809883a 	mov	r4,r3
   13440:	e0ffff17 	ldw	r3,-4(fp)
   13444:	18c00b8b 	ldhu	r3,46(r3)
   13448:	18ffffcc 	andi	r3,r3,65535
   1344c:	1806923a 	slli	r3,r3,8
   13450:	20c6b03a 	or	r3,r4,r3
   13454:	10c0038d 	sth	r3,14(r2)

  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
   13458:	e0bfff17 	ldw	r2,-4(fp)
   1345c:	10c00a17 	ldw	r3,40(r2)
   13460:	e0bfff17 	ldw	r2,-4(fp)
   13464:	10800b8b 	ldhu	r2,46(r2)
   13468:	10bfffcc 	andi	r2,r2,65535
   1346c:	1887883a 	add	r3,r3,r2
   13470:	e0bfff17 	ldw	r2,-4(fp)
   13474:	10c00c15 	stw	r3,48(r2)

  /* Add any requested options.  NB MSS option is only set on SYN
     packets, so ignore it here */
  opts = (u32_t *)(seg->tcphdr + 1);
   13478:	e0bffe17 	ldw	r2,-8(fp)
   1347c:	10800417 	ldw	r2,16(r2)
   13480:	10800504 	addi	r2,r2,20
   13484:	e0bffb15 	stw	r2,-20(fp)
  if (seg->flags & TF_SEG_OPTS_MSS) {
   13488:	e0bffe17 	ldw	r2,-8(fp)
   1348c:	10800383 	ldbu	r2,14(r2)
   13490:	10803fcc 	andi	r2,r2,255
   13494:	1080004c 	andi	r2,r2,1
   13498:	10000726 	beq	r2,zero,134b8 <tcp_output_segment+0x124>
    TCP_BUILD_MSS_OPTION(*opts);
   1349c:	e0bffb17 	ldw	r2,-20(fp)
   134a0:	00ed0174 	movhi	r3,46085
   134a4:	18c10084 	addi	r3,r3,1026
   134a8:	10c00015 	stw	r3,0(r2)
    opts += 1;
   134ac:	e0bffb17 	ldw	r2,-20(fp)
   134b0:	10800104 	addi	r2,r2,4
   134b4:	e0bffb15 	stw	r2,-20(fp)
  }
#endif

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
   134b8:	e0bfff17 	ldw	r2,-4(fp)
   134bc:	10000326 	beq	r2,zero,134cc <tcp_output_segment+0x138>
   134c0:	e0bfff17 	ldw	r2,-4(fp)
   134c4:	10800017 	ldw	r2,0(r2)
   134c8:	1000101e 	bne	r2,zero,1350c <tcp_output_segment+0x178>
    netif = ip_route(&(pcb->remote_ip));
   134cc:	e0bfff17 	ldw	r2,-4(fp)
   134d0:	10800104 	addi	r2,r2,4
   134d4:	1009883a 	mov	r4,r2
   134d8:	00061b00 	call	61b0 <ip_route>
   134dc:	e0bffc15 	stw	r2,-16(fp)
    if (netif == NULL) {
   134e0:	e0bffc17 	ldw	r2,-16(fp)
   134e4:	10008826 	beq	r2,zero,13708 <tcp_output_segment+0x374>
      return;
    }
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
   134e8:	e0bffc17 	ldw	r2,-16(fp)
   134ec:	10800104 	addi	r2,r2,4
   134f0:	10000326 	beq	r2,zero,13500 <tcp_output_segment+0x16c>
   134f4:	e0bffc17 	ldw	r2,-16(fp)
   134f8:	10800117 	ldw	r2,4(r2)
   134fc:	00000106 	br	13504 <tcp_output_segment+0x170>
   13500:	0005883a 	mov	r2,zero
   13504:	e0ffff17 	ldw	r3,-4(fp)
   13508:	18800015 	stw	r2,0(r3)
  }

  /* Set retransmission timer running if it is not currently enabled */
  if(pcb->rtime == -1)
   1350c:	e0bfff17 	ldw	r2,-4(fp)
   13510:	10800e8b 	ldhu	r2,58(r2)
   13514:	10bfffcc 	andi	r2,r2,65535
   13518:	10a0001c 	xori	r2,r2,32768
   1351c:	10a00004 	addi	r2,r2,-32768
   13520:	10bfffd8 	cmpnei	r2,r2,-1
   13524:	1000021e 	bne	r2,zero,13530 <tcp_output_segment+0x19c>
    pcb->rtime = 0;
   13528:	e0bfff17 	ldw	r2,-4(fp)
   1352c:	10000e8d 	sth	zero,58(r2)

  if (pcb->rttest == 0) {
   13530:	e0bfff17 	ldw	r2,-4(fp)
   13534:	10801017 	ldw	r2,64(r2)
   13538:	1000281e 	bne	r2,zero,135dc <tcp_output_segment+0x248>
    pcb->rttest = tcp_ticks;
   1353c:	008000f4 	movhi	r2,3
   13540:	1099c304 	addi	r2,r2,26380
   13544:	10c00017 	ldw	r3,0(r2)
   13548:	e0bfff17 	ldw	r2,-4(fp)
   1354c:	10c01015 	stw	r3,64(r2)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
   13550:	e0bffe17 	ldw	r2,-8(fp)
   13554:	10800417 	ldw	r2,16(r2)
   13558:	10c0010b 	ldhu	r3,4(r2)
   1355c:	1080018b 	ldhu	r2,6(r2)
   13560:	1004943a 	slli	r2,r2,16
   13564:	10c4b03a 	or	r2,r2,r3
   13568:	1006d63a 	srli	r3,r2,24
   1356c:	e0bffe17 	ldw	r2,-8(fp)
   13570:	10800417 	ldw	r2,16(r2)
   13574:	1100010b 	ldhu	r4,4(r2)
   13578:	1080018b 	ldhu	r2,6(r2)
   1357c:	1004943a 	slli	r2,r2,16
   13580:	1104b03a 	or	r2,r2,r4
   13584:	1004d23a 	srli	r2,r2,8
   13588:	10bfc00c 	andi	r2,r2,65280
   1358c:	1886b03a 	or	r3,r3,r2
   13590:	e0bffe17 	ldw	r2,-8(fp)
   13594:	10800417 	ldw	r2,16(r2)
   13598:	1100010b 	ldhu	r4,4(r2)
   1359c:	1080018b 	ldhu	r2,6(r2)
   135a0:	1004943a 	slli	r2,r2,16
   135a4:	1104b03a 	or	r2,r2,r4
   135a8:	10bfc00c 	andi	r2,r2,65280
   135ac:	1004923a 	slli	r2,r2,8
   135b0:	1886b03a 	or	r3,r3,r2
   135b4:	e0bffe17 	ldw	r2,-8(fp)
   135b8:	10800417 	ldw	r2,16(r2)
   135bc:	1100010b 	ldhu	r4,4(r2)
   135c0:	1080018b 	ldhu	r2,6(r2)
   135c4:	1004943a 	slli	r2,r2,16
   135c8:	1104b03a 	or	r2,r2,r4
   135cc:	1004963a 	slli	r2,r2,24
   135d0:	1886b03a 	or	r3,r3,r2
   135d4:	e0bfff17 	ldw	r2,-4(fp)
   135d8:	10c01115 	stw	r3,68(r2)
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
   135dc:	e0bffe17 	ldw	r2,-8(fp)
   135e0:	10800417 	ldw	r2,16(r2)
   135e4:	1007883a 	mov	r3,r2
   135e8:	e0bffe17 	ldw	r2,-8(fp)
   135ec:	10800117 	ldw	r2,4(r2)
   135f0:	10800117 	ldw	r2,4(r2)
   135f4:	1885c83a 	sub	r2,r3,r2
   135f8:	e0bffd0d 	sth	r2,-12(fp)

  seg->p->len -= len;
   135fc:	e0bffe17 	ldw	r2,-8(fp)
   13600:	10800117 	ldw	r2,4(r2)
   13604:	e0fffe17 	ldw	r3,-8(fp)
   13608:	18c00117 	ldw	r3,4(r3)
   1360c:	1900028b 	ldhu	r4,10(r3)
   13610:	e0fffd0b 	ldhu	r3,-12(fp)
   13614:	20c7c83a 	sub	r3,r4,r3
   13618:	10c0028d 	sth	r3,10(r2)
  seg->p->tot_len -= len;
   1361c:	e0bffe17 	ldw	r2,-8(fp)
   13620:	10800117 	ldw	r2,4(r2)
   13624:	e0fffe17 	ldw	r3,-8(fp)
   13628:	18c00117 	ldw	r3,4(r3)
   1362c:	1900020b 	ldhu	r4,8(r3)
   13630:	e0fffd0b 	ldhu	r3,-12(fp)
   13634:	20c7c83a 	sub	r3,r4,r3
   13638:	10c0020d 	sth	r3,8(r2)

  seg->p->payload = seg->tcphdr;
   1363c:	e0bffe17 	ldw	r2,-8(fp)
   13640:	10800117 	ldw	r2,4(r2)
   13644:	e0fffe17 	ldw	r3,-8(fp)
   13648:	18c00417 	ldw	r3,16(r3)
   1364c:	10c00115 	stw	r3,4(r2)

  seg->tcphdr->chksum = 0;
   13650:	e0bffe17 	ldw	r2,-8(fp)
   13654:	10800417 	ldw	r2,16(r2)
   13658:	1000040d 	sth	zero,16(r2)
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
   1365c:	e0bffe17 	ldw	r2,-8(fp)
   13660:	14000417 	ldw	r16,16(r2)
   13664:	e0bffe17 	ldw	r2,-8(fp)
   13668:	11000117 	ldw	r4,4(r2)
   1366c:	e0ffff17 	ldw	r3,-4(fp)
   13670:	e0bfff17 	ldw	r2,-4(fp)
   13674:	10800104 	addi	r2,r2,4
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
   13678:	e17ffe17 	ldw	r5,-8(fp)
   1367c:	29400117 	ldw	r5,4(r5)
   13680:	2940020b 	ldhu	r5,8(r5)

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
   13684:	297fffcc 	andi	r5,r5,65535
   13688:	d9400015 	stw	r5,0(sp)
   1368c:	180b883a 	mov	r5,r3
   13690:	100d883a 	mov	r6,r2
   13694:	01c00184 	movi	r7,6
   13698:	0005e400 	call	5e40 <inet_chksum_pseudo>
   1369c:	8080040d 	sth	r2,16(r16)
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
   136a0:	00800134 	movhi	r2,4
   136a4:	10916104 	addi	r2,r2,17796
   136a8:	1080240b 	ldhu	r2,144(r2)
   136ac:	10800044 	addi	r2,r2,1
   136b0:	1007883a 	mov	r3,r2
   136b4:	00800134 	movhi	r2,4
   136b8:	10916104 	addi	r2,r2,17796
   136bc:	10c0240d 	sth	r3,144(r2)

#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
   136c0:	e0bffe17 	ldw	r2,-8(fp)
   136c4:	11000117 	ldw	r4,4(r2)
   136c8:	e17fff17 	ldw	r5,-4(fp)
   136cc:	e0bfff17 	ldw	r2,-4(fp)
   136d0:	10c00104 	addi	r3,r2,4
   136d4:	e0bfff17 	ldw	r2,-4(fp)
   136d8:	108002c3 	ldbu	r2,11(r2)
   136dc:	10803fcc 	andi	r2,r2,255
   136e0:	e1bfff17 	ldw	r6,-4(fp)
   136e4:	31800283 	ldbu	r6,10(r6)
   136e8:	31803fcc 	andi	r6,r6,255
   136ec:	d9800015 	stw	r6,0(sp)
   136f0:	01800184 	movi	r6,6
   136f4:	d9800115 	stw	r6,4(sp)
   136f8:	180d883a 	mov	r6,r3
   136fc:	100f883a 	mov	r7,r2
   13700:	0006d180 	call	6d18 <ip_output>
   13704:	00000106 	br	1370c <tcp_output_segment+0x378>
  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
    netif = ip_route(&(pcb->remote_ip));
    if (netif == NULL) {
      return;
   13708:	0001883a 	nop
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
}
   1370c:	e037883a 	mov	sp,fp
   13710:	dfc00217 	ldw	ra,8(sp)
   13714:	df000117 	ldw	fp,4(sp)
   13718:	dc000017 	ldw	r16,0(sp)
   1371c:	dec00304 	addi	sp,sp,12
   13720:	f800283a 	ret

00013724 <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  struct ip_addr *local_ip, struct ip_addr *remote_ip,
  u16_t local_port, u16_t remote_port)
{
   13724:	defff404 	addi	sp,sp,-48
   13728:	dfc00b15 	stw	ra,44(sp)
   1372c:	df000a15 	stw	fp,40(sp)
   13730:	df000a04 	addi	fp,sp,40
   13734:	e13ffa15 	stw	r4,-24(fp)
   13738:	e17ffb15 	stw	r5,-20(fp)
   1373c:	e1bffc15 	stw	r6,-16(fp)
   13740:	e1fffd15 	stw	r7,-12(fp)
   13744:	e0c00217 	ldw	r3,8(fp)
   13748:	e0800317 	ldw	r2,12(fp)
   1374c:	e0fffe0d 	sth	r3,-8(fp)
   13750:	e0bfff0d 	sth	r2,-4(fp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
   13754:	01000044 	movi	r4,1
   13758:	01400504 	movi	r5,20
   1375c:	000d883a 	mov	r6,zero
   13760:	00097cc0 	call	97cc <pbuf_alloc>
   13764:	e0bff815 	stw	r2,-32(fp)
  if (p == NULL) {
   13768:	e0bff817 	ldw	r2,-32(fp)
   1376c:	1000041e 	bne	r2,zero,13780 <tcp_rst+0x5c>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
   13770:	010000f4 	movhi	r4,3
   13774:	213f0204 	addi	r4,r4,-1016
   13778:	00172f80 	call	172f8 <puts>
      return;
   1377c:	00008f06 	br	139bc <tcp_rst+0x298>
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
   13780:	e0bff817 	ldw	r2,-32(fp)
   13784:	1080028b 	ldhu	r2,10(r2)
   13788:	10bfffcc 	andi	r2,r2,65535
   1378c:	10800528 	cmpgeui	r2,r2,20
   13790:	1000091e 	bne	r2,zero,137b8 <tcp_rst+0x94>
   13794:	010000f4 	movhi	r4,3
   13798:	213e8004 	addi	r4,r4,-1536
   1379c:	014000f4 	movhi	r5,3
   137a0:	297f0d04 	addi	r5,r5,-972
   137a4:	0180c384 	movi	r6,782
   137a8:	01c000f4 	movhi	r7,3
   137ac:	39fe9f04 	addi	r7,r7,-1412
   137b0:	00170680 	call	17068 <printf>
   137b4:	003fff06 	br	137b4 <tcp_rst+0x90>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
   137b8:	e0bff817 	ldw	r2,-32(fp)
   137bc:	10800117 	ldw	r2,4(r2)
   137c0:	e0bff915 	stw	r2,-28(fp)
  tcphdr->src = htons(local_port);
   137c4:	e0bffe0b 	ldhu	r2,-8(fp)
   137c8:	1004d23a 	srli	r2,r2,8
   137cc:	1007883a 	mov	r3,r2
   137d0:	e0bffe0b 	ldhu	r2,-8(fp)
   137d4:	1004923a 	slli	r2,r2,8
   137d8:	1884b03a 	or	r2,r3,r2
   137dc:	1007883a 	mov	r3,r2
   137e0:	e0bff917 	ldw	r2,-28(fp)
   137e4:	10c0000d 	sth	r3,0(r2)
  tcphdr->dest = htons(remote_port);
   137e8:	e0bfff0b 	ldhu	r2,-4(fp)
   137ec:	1004d23a 	srli	r2,r2,8
   137f0:	1007883a 	mov	r3,r2
   137f4:	e0bfff0b 	ldhu	r2,-4(fp)
   137f8:	1004923a 	slli	r2,r2,8
   137fc:	1884b03a 	or	r2,r3,r2
   13800:	1007883a 	mov	r3,r2
   13804:	e0bff917 	ldw	r2,-28(fp)
   13808:	10c0008d 	sth	r3,2(r2)
  tcphdr->seqno = htonl(seqno);
   1380c:	e0bffa17 	ldw	r2,-24(fp)
   13810:	1006d63a 	srli	r3,r2,24
   13814:	e0bffa17 	ldw	r2,-24(fp)
   13818:	1004d23a 	srli	r2,r2,8
   1381c:	10bfc00c 	andi	r2,r2,65280
   13820:	1886b03a 	or	r3,r3,r2
   13824:	e0bffa17 	ldw	r2,-24(fp)
   13828:	10bfc00c 	andi	r2,r2,65280
   1382c:	1004923a 	slli	r2,r2,8
   13830:	1886b03a 	or	r3,r3,r2
   13834:	e0bffa17 	ldw	r2,-24(fp)
   13838:	1004963a 	slli	r2,r2,24
   1383c:	1886b03a 	or	r3,r3,r2
   13840:	e0bff917 	ldw	r2,-28(fp)
   13844:	193fffcc 	andi	r4,r3,65535
   13848:	1140010b 	ldhu	r5,4(r2)
   1384c:	280a703a 	and	r5,r5,zero
   13850:	2908b03a 	or	r4,r5,r4
   13854:	1100010d 	sth	r4,4(r2)
   13858:	1806d43a 	srli	r3,r3,16
   1385c:	1100018b 	ldhu	r4,6(r2)
   13860:	2008703a 	and	r4,r4,zero
   13864:	20c6b03a 	or	r3,r4,r3
   13868:	10c0018d 	sth	r3,6(r2)
  tcphdr->ackno = htonl(ackno);
   1386c:	e0bffb17 	ldw	r2,-20(fp)
   13870:	1006d63a 	srli	r3,r2,24
   13874:	e0bffb17 	ldw	r2,-20(fp)
   13878:	1004d23a 	srli	r2,r2,8
   1387c:	10bfc00c 	andi	r2,r2,65280
   13880:	1886b03a 	or	r3,r3,r2
   13884:	e0bffb17 	ldw	r2,-20(fp)
   13888:	10bfc00c 	andi	r2,r2,65280
   1388c:	1004923a 	slli	r2,r2,8
   13890:	1886b03a 	or	r3,r3,r2
   13894:	e0bffb17 	ldw	r2,-20(fp)
   13898:	1004963a 	slli	r2,r2,24
   1389c:	1886b03a 	or	r3,r3,r2
   138a0:	e0bff917 	ldw	r2,-28(fp)
   138a4:	193fffcc 	andi	r4,r3,65535
   138a8:	1140020b 	ldhu	r5,8(r2)
   138ac:	280a703a 	and	r5,r5,zero
   138b0:	2908b03a 	or	r4,r5,r4
   138b4:	1100020d 	sth	r4,8(r2)
   138b8:	1806d43a 	srli	r3,r3,16
   138bc:	1100028b 	ldhu	r4,10(r2)
   138c0:	2008703a 	and	r4,r4,zero
   138c4:	20c6b03a 	or	r3,r4,r3
   138c8:	10c0028d 	sth	r3,10(r2)
  TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
   138cc:	e0bff917 	ldw	r2,-28(fp)
   138d0:	10c0030b 	ldhu	r3,12(r2)
   138d4:	00b03fc4 	movi	r2,-16129
   138d8:	1884703a 	and	r2,r3,r2
   138dc:	10850014 	ori	r2,r2,5120
   138e0:	1007883a 	mov	r3,r2
   138e4:	e0bff917 	ldw	r2,-28(fp)
   138e8:	10c0030d 	sth	r3,12(r2)
  tcphdr->wnd = htons(TCP_WND);
   138ec:	e0bff917 	ldw	r2,-28(fp)
   138f0:	00c00204 	movi	r3,8
   138f4:	10c0038d 	sth	r3,14(r2)
  tcphdr->urgp = 0;
   138f8:	e0bff917 	ldw	r2,-28(fp)
   138fc:	1000048d 	sth	zero,18(r2)
  TCPH_HDRLEN_SET(tcphdr, 5);
   13900:	e0bff917 	ldw	r2,-28(fp)
   13904:	1080030b 	ldhu	r2,12(r2)
   13908:	10bfffcc 	andi	r2,r2,65535
   1390c:	1004d23a 	srli	r2,r2,8
   13910:	1007883a 	mov	r3,r2
   13914:	e0bff917 	ldw	r2,-28(fp)
   13918:	1080030b 	ldhu	r2,12(r2)
   1391c:	10bfffcc 	andi	r2,r2,65535
   13920:	1004923a 	slli	r2,r2,8
   13924:	1884b03a 	or	r2,r3,r2
   13928:	10800fcc 	andi	r2,r2,63
   1392c:	1004923a 	slli	r2,r2,8
   13930:	10801414 	ori	r2,r2,80
   13934:	1007883a 	mov	r3,r2
   13938:	e0bff917 	ldw	r2,-28(fp)
   1393c:	10c0030d 	sth	r3,12(r2)

  tcphdr->chksum = 0;
   13940:	e0bff917 	ldw	r2,-28(fp)
   13944:	1000040d 	sth	zero,16(r2)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
              IP_PROTO_TCP, p->tot_len);
   13948:	e0bff817 	ldw	r2,-32(fp)
   1394c:	1080020b 	ldhu	r2,8(r2)
  tcphdr->urgp = 0;
  TCPH_HDRLEN_SET(tcphdr, 5);

  tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
   13950:	10bfffcc 	andi	r2,r2,65535
   13954:	d8800015 	stw	r2,0(sp)
   13958:	e13ff817 	ldw	r4,-32(fp)
   1395c:	e17ffc17 	ldw	r5,-16(fp)
   13960:	e1bffd17 	ldw	r6,-12(fp)
   13964:	01c00184 	movi	r7,6
   13968:	0005e400 	call	5e40 <inet_chksum_pseudo>
   1396c:	e0fff917 	ldw	r3,-28(fp)
   13970:	1880040d 	sth	r2,16(r3)
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
   13974:	00800134 	movhi	r2,4
   13978:	10916104 	addi	r2,r2,17796
   1397c:	1080240b 	ldhu	r2,144(r2)
   13980:	10800044 	addi	r2,r2,1
   13984:	1007883a 	mov	r3,r2
   13988:	00800134 	movhi	r2,4
   1398c:	10916104 	addi	r2,r2,17796
   13990:	10c0240d 	sth	r3,144(r2)
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
   13994:	d8000015 	stw	zero,0(sp)
   13998:	00800184 	movi	r2,6
   1399c:	d8800115 	stw	r2,4(sp)
   139a0:	e13ff817 	ldw	r4,-32(fp)
   139a4:	e17ffc17 	ldw	r5,-16(fp)
   139a8:	e1bffd17 	ldw	r6,-12(fp)
   139ac:	01c03fc4 	movi	r7,255
   139b0:	0006d180 	call	6d18 <ip_output>
  pbuf_free(p);
   139b4:	e13ff817 	ldw	r4,-32(fp)
   139b8:	000a1880 	call	a188 <pbuf_free>
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
   139bc:	e037883a 	mov	sp,fp
   139c0:	dfc00117 	ldw	ra,4(sp)
   139c4:	df000017 	ldw	fp,0(sp)
   139c8:	dec00204 	addi	sp,sp,8
   139cc:	f800283a 	ret

000139d0 <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
   139d0:	defffc04 	addi	sp,sp,-16
   139d4:	dfc00315 	stw	ra,12(sp)
   139d8:	df000215 	stw	fp,8(sp)
   139dc:	df000204 	addi	fp,sp,8
   139e0:	e13fff15 	stw	r4,-4(fp)
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
   139e4:	e0bfff17 	ldw	r2,-4(fp)
   139e8:	10801f17 	ldw	r2,124(r2)
   139ec:	10001f26 	beq	r2,zero,13a6c <tcp_rexmit_rto+0x9c>
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
   139f0:	e0bfff17 	ldw	r2,-4(fp)
   139f4:	10801f17 	ldw	r2,124(r2)
   139f8:	e0bffe15 	stw	r2,-8(fp)
   139fc:	00000306 	br	13a0c <tcp_rexmit_rto+0x3c>
   13a00:	e0bffe17 	ldw	r2,-8(fp)
   13a04:	10800017 	ldw	r2,0(r2)
   13a08:	e0bffe15 	stw	r2,-8(fp)
   13a0c:	e0bffe17 	ldw	r2,-8(fp)
   13a10:	10800017 	ldw	r2,0(r2)
   13a14:	103ffa1e 	bne	r2,zero,13a00 <tcp_rexmit_rto+0x30>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
   13a18:	e0bfff17 	ldw	r2,-4(fp)
   13a1c:	10c01e17 	ldw	r3,120(r2)
   13a20:	e0bffe17 	ldw	r2,-8(fp)
   13a24:	10c00015 	stw	r3,0(r2)
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
   13a28:	e0bfff17 	ldw	r2,-4(fp)
   13a2c:	10c01f17 	ldw	r3,124(r2)
   13a30:	e0bfff17 	ldw	r2,-4(fp)
   13a34:	10c01e15 	stw	r3,120(r2)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
   13a38:	e0bfff17 	ldw	r2,-4(fp)
   13a3c:	10001f15 	stw	zero,124(r2)

  /* increment number of retransmissions */
  ++pcb->nrtx;
   13a40:	e0bfff17 	ldw	r2,-4(fp)
   13a44:	10801383 	ldbu	r2,78(r2)
   13a48:	10800044 	addi	r2,r2,1
   13a4c:	1007883a 	mov	r3,r2
   13a50:	e0bfff17 	ldw	r2,-4(fp)
   13a54:	10c01385 	stb	r3,78(r2)

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
   13a58:	e0bfff17 	ldw	r2,-4(fp)
   13a5c:	10001015 	stw	zero,64(r2)

  /* Do the actual retransmission */
  tcp_output(pcb);
   13a60:	e13fff17 	ldw	r4,-4(fp)
   13a64:	0012b000 	call	12b00 <tcp_output>
   13a68:	00000106 	br	13a70 <tcp_rexmit_rto+0xa0>
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
    return;
   13a6c:	0001883a 	nop
  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;

  /* Do the actual retransmission */
  tcp_output(pcb);
}
   13a70:	e037883a 	mov	sp,fp
   13a74:	dfc00117 	ldw	ra,4(sp)
   13a78:	df000017 	ldw	fp,0(sp)
   13a7c:	dec00204 	addi	sp,sp,8
   13a80:	f800283a 	ret

00013a84 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
   13a84:	defffc04 	addi	sp,sp,-16
   13a88:	df000315 	stw	fp,12(sp)
   13a8c:	df000304 	addi	fp,sp,12
   13a90:	e13fff15 	stw	r4,-4(fp)
  struct tcp_seg *seg;
  struct tcp_seg **cur_seg;

  if (pcb->unacked == NULL) {
   13a94:	e0bfff17 	ldw	r2,-4(fp)
   13a98:	10801f17 	ldw	r2,124(r2)
   13a9c:	10006926 	beq	r2,zero,13c44 <tcp_rexmit+0x1c0>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
   13aa0:	e0bfff17 	ldw	r2,-4(fp)
   13aa4:	10801f17 	ldw	r2,124(r2)
   13aa8:	e0bffe15 	stw	r2,-8(fp)
  pcb->unacked = seg->next;
   13aac:	e0bffe17 	ldw	r2,-8(fp)
   13ab0:	10c00017 	ldw	r3,0(r2)
   13ab4:	e0bfff17 	ldw	r2,-4(fp)
   13ab8:	10c01f15 	stw	r3,124(r2)

  cur_seg = &(pcb->unsent);
   13abc:	e0bfff17 	ldw	r2,-4(fp)
   13ac0:	10801e04 	addi	r2,r2,120
   13ac4:	e0bffd15 	stw	r2,-12(fp)
  while (*cur_seg &&
   13ac8:	00000306 	br	13ad8 <tcp_rexmit+0x54>
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
      cur_seg = &((*cur_seg)->next );
   13acc:	e0bffd17 	ldw	r2,-12(fp)
   13ad0:	10800017 	ldw	r2,0(r2)
   13ad4:	e0bffd15 	stw	r2,-12(fp)
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;

  cur_seg = &(pcb->unsent);
  while (*cur_seg &&
   13ad8:	e0bffd17 	ldw	r2,-12(fp)
   13adc:	10800017 	ldw	r2,0(r2)
   13ae0:	10004826 	beq	r2,zero,13c04 <tcp_rexmit+0x180>
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
   13ae4:	e0bffd17 	ldw	r2,-12(fp)
   13ae8:	10800017 	ldw	r2,0(r2)
   13aec:	10800417 	ldw	r2,16(r2)
   13af0:	10c0010b 	ldhu	r3,4(r2)
   13af4:	1080018b 	ldhu	r2,6(r2)
   13af8:	1004943a 	slli	r2,r2,16
   13afc:	10c4b03a 	or	r2,r2,r3
   13b00:	1006d63a 	srli	r3,r2,24
   13b04:	e0bffd17 	ldw	r2,-12(fp)
   13b08:	10800017 	ldw	r2,0(r2)
   13b0c:	10800417 	ldw	r2,16(r2)
   13b10:	1100010b 	ldhu	r4,4(r2)
   13b14:	1080018b 	ldhu	r2,6(r2)
   13b18:	1004943a 	slli	r2,r2,16
   13b1c:	1104b03a 	or	r2,r2,r4
   13b20:	1004d23a 	srli	r2,r2,8
   13b24:	10bfc00c 	andi	r2,r2,65280
   13b28:	1886b03a 	or	r3,r3,r2
   13b2c:	e0bffd17 	ldw	r2,-12(fp)
   13b30:	10800017 	ldw	r2,0(r2)
   13b34:	10800417 	ldw	r2,16(r2)
   13b38:	1100010b 	ldhu	r4,4(r2)
   13b3c:	1080018b 	ldhu	r2,6(r2)
   13b40:	1004943a 	slli	r2,r2,16
   13b44:	1104b03a 	or	r2,r2,r4
   13b48:	10bfc00c 	andi	r2,r2,65280
   13b4c:	1004923a 	slli	r2,r2,8
   13b50:	1886b03a 	or	r3,r3,r2
   13b54:	e0bffd17 	ldw	r2,-12(fp)
   13b58:	10800017 	ldw	r2,0(r2)
   13b5c:	10800417 	ldw	r2,16(r2)
   13b60:	1100010b 	ldhu	r4,4(r2)
   13b64:	1080018b 	ldhu	r2,6(r2)
   13b68:	1004943a 	slli	r2,r2,16
   13b6c:	1104b03a 	or	r2,r2,r4
   13b70:	1004963a 	slli	r2,r2,24
   13b74:	1886b03a 	or	r3,r3,r2
   13b78:	e0bffe17 	ldw	r2,-8(fp)
   13b7c:	10800417 	ldw	r2,16(r2)
   13b80:	1100010b 	ldhu	r4,4(r2)
   13b84:	1080018b 	ldhu	r2,6(r2)
   13b88:	1004943a 	slli	r2,r2,16
   13b8c:	1104b03a 	or	r2,r2,r4
   13b90:	1008d63a 	srli	r4,r2,24
   13b94:	e0bffe17 	ldw	r2,-8(fp)
   13b98:	10800417 	ldw	r2,16(r2)
   13b9c:	1140010b 	ldhu	r5,4(r2)
   13ba0:	1080018b 	ldhu	r2,6(r2)
   13ba4:	1004943a 	slli	r2,r2,16
   13ba8:	1144b03a 	or	r2,r2,r5
   13bac:	1004d23a 	srli	r2,r2,8
   13bb0:	10bfc00c 	andi	r2,r2,65280
   13bb4:	2088b03a 	or	r4,r4,r2
   13bb8:	e0bffe17 	ldw	r2,-8(fp)
   13bbc:	10800417 	ldw	r2,16(r2)
   13bc0:	1140010b 	ldhu	r5,4(r2)
   13bc4:	1080018b 	ldhu	r2,6(r2)
   13bc8:	1004943a 	slli	r2,r2,16
   13bcc:	1144b03a 	or	r2,r2,r5
   13bd0:	10bfc00c 	andi	r2,r2,65280
   13bd4:	1004923a 	slli	r2,r2,8
   13bd8:	2088b03a 	or	r4,r4,r2
   13bdc:	e0bffe17 	ldw	r2,-8(fp)
   13be0:	10800417 	ldw	r2,16(r2)
   13be4:	1140010b 	ldhu	r5,4(r2)
   13be8:	1080018b 	ldhu	r2,6(r2)
   13bec:	1004943a 	slli	r2,r2,16
   13bf0:	1144b03a 	or	r2,r2,r5
   13bf4:	1004963a 	slli	r2,r2,24
   13bf8:	2084b03a 	or	r2,r4,r2
   13bfc:	1885c83a 	sub	r2,r3,r2
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;

  cur_seg = &(pcb->unsent);
  while (*cur_seg &&
   13c00:	103fb216 	blt	r2,zero,13acc <tcp_rexmit+0x48>
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
      cur_seg = &((*cur_seg)->next );
  }
  seg->next = *cur_seg;
   13c04:	e0bffd17 	ldw	r2,-12(fp)
   13c08:	10c00017 	ldw	r3,0(r2)
   13c0c:	e0bffe17 	ldw	r2,-8(fp)
   13c10:	10c00015 	stw	r3,0(r2)
  *cur_seg = seg;
   13c14:	e0bffd17 	ldw	r2,-12(fp)
   13c18:	e0fffe17 	ldw	r3,-8(fp)
   13c1c:	10c00015 	stw	r3,0(r2)

  ++pcb->nrtx;
   13c20:	e0bfff17 	ldw	r2,-4(fp)
   13c24:	10801383 	ldbu	r2,78(r2)
   13c28:	10800044 	addi	r2,r2,1
   13c2c:	1007883a 	mov	r3,r2
   13c30:	e0bfff17 	ldw	r2,-4(fp)
   13c34:	10c01385 	stb	r3,78(r2)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
   13c38:	e0bfff17 	ldw	r2,-4(fp)
   13c3c:	10001015 	stw	zero,64(r2)
   13c40:	00000106 	br	13c48 <tcp_rexmit+0x1c4>
{
  struct tcp_seg *seg;
  struct tcp_seg **cur_seg;

  if (pcb->unacked == NULL) {
    return;
   13c44:	0001883a 	nop

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  /* No need to call tcp_output: we are always called from tcp_input()
     and thus tcp_output directly returns. */
}
   13c48:	e037883a 	mov	sp,fp
   13c4c:	df000017 	ldw	fp,0(sp)
   13c50:	dec00104 	addi	sp,sp,4
   13c54:	f800283a 	ret

00013c58 <tcp_rexmit_fast>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void 
tcp_rexmit_fast(struct tcp_pcb *pcb)
{
   13c58:	defffd04 	addi	sp,sp,-12
   13c5c:	dfc00215 	stw	ra,8(sp)
   13c60:	df000115 	stw	fp,4(sp)
   13c64:	df000104 	addi	fp,sp,4
   13c68:	e13fff15 	stw	r4,-4(fp)
  if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
   13c6c:	e0bfff17 	ldw	r2,-4(fp)
   13c70:	10801f17 	ldw	r2,124(r2)
   13c74:	10003c26 	beq	r2,zero,13d68 <tcp_rexmit_fast+0x110>
   13c78:	e0bfff17 	ldw	r2,-4(fp)
   13c7c:	10800983 	ldbu	r2,38(r2)
   13c80:	10803fcc 	andi	r2,r2,255
   13c84:	1080010c 	andi	r2,r2,4
   13c88:	1000371e 	bne	r2,zero,13d68 <tcp_rexmit_fast+0x110>
    LWIP_DEBUGF(TCP_FR_DEBUG, 
                ("tcp_receive: dupacks %"U16_F" (%"U32_F
                 "), fast retransmit %"U32_F"\n",
                 (u16_t)pcb->dupacks, pcb->lastack,
                 ntohl(pcb->unacked->tcphdr->seqno)));
    tcp_rexmit(pcb);
   13c8c:	e13fff17 	ldw	r4,-4(fp)
   13c90:	0013a840 	call	13a84 <tcp_rexmit>

    /* Set ssthresh to half of the minimum of the current
     * cwnd and the advertised window */
    if (pcb->cwnd > pcb->snd_wnd)
   13c94:	e0bfff17 	ldw	r2,-4(fp)
   13c98:	1080158b 	ldhu	r2,86(r2)
   13c9c:	e0ffff17 	ldw	r3,-4(fp)
   13ca0:	18c0180b 	ldhu	r3,96(r3)
   13ca4:	10bfffcc 	andi	r2,r2,65535
   13ca8:	18ffffcc 	andi	r3,r3,65535
   13cac:	1880082e 	bgeu	r3,r2,13cd0 <tcp_rexmit_fast+0x78>
      pcb->ssthresh = pcb->snd_wnd / 2;
   13cb0:	e0bfff17 	ldw	r2,-4(fp)
   13cb4:	1080180b 	ldhu	r2,96(r2)
   13cb8:	10bfffcc 	andi	r2,r2,65535
   13cbc:	1004d07a 	srli	r2,r2,1
   13cc0:	1007883a 	mov	r3,r2
   13cc4:	e0bfff17 	ldw	r2,-4(fp)
   13cc8:	10c0160d 	sth	r3,88(r2)
   13ccc:	00000706 	br	13cec <tcp_rexmit_fast+0x94>
    else
      pcb->ssthresh = pcb->cwnd / 2;
   13cd0:	e0bfff17 	ldw	r2,-4(fp)
   13cd4:	1080158b 	ldhu	r2,86(r2)
   13cd8:	10bfffcc 	andi	r2,r2,65535
   13cdc:	1004d07a 	srli	r2,r2,1
   13ce0:	1007883a 	mov	r3,r2
   13ce4:	e0bfff17 	ldw	r2,-4(fp)
   13ce8:	10c0160d 	sth	r3,88(r2)
    
    /* The minimum value for ssthresh should be 2 MSS */
    if (pcb->ssthresh < 2*pcb->mss) {
   13cec:	e0bfff17 	ldw	r2,-4(fp)
   13cf0:	1080160b 	ldhu	r2,88(r2)
   13cf4:	10ffffcc 	andi	r3,r2,65535
   13cf8:	e0bfff17 	ldw	r2,-4(fp)
   13cfc:	10800f0b 	ldhu	r2,60(r2)
   13d00:	10bfffcc 	andi	r2,r2,65535
   13d04:	1085883a 	add	r2,r2,r2
   13d08:	1880060e 	bge	r3,r2,13d24 <tcp_rexmit_fast+0xcc>
      LWIP_DEBUGF(TCP_FR_DEBUG, 
                  ("tcp_receive: The minimum value for ssthresh %"U16_F
                   " should be min 2 mss %"U16_F"...\n",
                   pcb->ssthresh, 2*pcb->mss));
      pcb->ssthresh = 2*pcb->mss;
   13d0c:	e0bfff17 	ldw	r2,-4(fp)
   13d10:	10800f0b 	ldhu	r2,60(r2)
   13d14:	1085883a 	add	r2,r2,r2
   13d18:	1007883a 	mov	r3,r2
   13d1c:	e0bfff17 	ldw	r2,-4(fp)
   13d20:	10c0160d 	sth	r3,88(r2)
    }
    
    pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
   13d24:	e0bfff17 	ldw	r2,-4(fp)
   13d28:	1100160b 	ldhu	r4,88(r2)
   13d2c:	e0bfff17 	ldw	r2,-4(fp)
   13d30:	10c00f0b 	ldhu	r3,60(r2)
   13d34:	1805883a 	mov	r2,r3
   13d38:	1085883a 	add	r2,r2,r2
   13d3c:	10c5883a 	add	r2,r2,r3
   13d40:	2085883a 	add	r2,r4,r2
   13d44:	1007883a 	mov	r3,r2
   13d48:	e0bfff17 	ldw	r2,-4(fp)
   13d4c:	10c0158d 	sth	r3,86(r2)
    pcb->flags |= TF_INFR;
   13d50:	e0bfff17 	ldw	r2,-4(fp)
   13d54:	10800983 	ldbu	r2,38(r2)
   13d58:	10800114 	ori	r2,r2,4
   13d5c:	1007883a 	mov	r3,r2
   13d60:	e0bfff17 	ldw	r2,-4(fp)
   13d64:	10c00985 	stb	r3,38(r2)
  } 
}
   13d68:	e037883a 	mov	sp,fp
   13d6c:	dfc00117 	ldw	ra,4(sp)
   13d70:	df000017 	ldw	fp,0(sp)
   13d74:	dec00204 	addi	sp,sp,8
   13d78:	f800283a 	ret

00013d7c <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
   13d7c:	defff904 	addi	sp,sp,-28
   13d80:	dfc00615 	stw	ra,24(sp)
   13d84:	df000515 	stw	fp,20(sp)
   13d88:	df000504 	addi	fp,sp,20
   13d8c:	e13fff15 	stw	r4,-4(fp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: sending KEEPALIVE probe to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
   13d90:	e0bfff17 	ldw	r2,-4(fp)
   13d94:	10800117 	ldw	r2,4(r2)
   13d98:	1004d63a 	srli	r2,r2,24
   13d9c:	10803fcc 	andi	r2,r2,255
   13da0:	1007883a 	mov	r3,r2
   13da4:	e0bfff17 	ldw	r2,-4(fp)
   13da8:	10800117 	ldw	r2,4(r2)
   13dac:	1004d23a 	srli	r2,r2,8
   13db0:	1009883a 	mov	r4,r2
   13db4:	00bfc004 	movi	r2,-256
   13db8:	2084703a 	and	r2,r4,r2
   13dbc:	1884b03a 	or	r2,r3,r2
   13dc0:	10bfffcc 	andi	r2,r2,65535
   13dc4:	10803fcc 	andi	r2,r2,255
   13dc8:	1009883a 	mov	r4,r2
   13dcc:	00170680 	call	17068 <printf>
                          ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                          ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
   13dd0:	e0bfff17 	ldw	r2,-4(fp)
   13dd4:	10802943 	ldbu	r2,165(r2)
   13dd8:	10803fcc 	andi	r2,r2,255
   13ddc:	1009883a 	mov	r4,r2
   13de0:	00170680 	call	17068 <printf>
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
   13de4:	01000044 	movi	r4,1
   13de8:	01400504 	movi	r5,20
   13dec:	000d883a 	mov	r6,zero
   13df0:	00097cc0 	call	97cc <pbuf_alloc>
   13df4:	e0bffd15 	stw	r2,-12(fp)
   
  if(p == NULL) {
   13df8:	e0bffd17 	ldw	r2,-12(fp)
   13dfc:	1000041e 	bne	r2,zero,13e10 <tcp_keepalive+0x94>
    LWIP_DEBUGF(TCP_DEBUG, 
   13e00:	010000f4 	movhi	r4,3
   13e04:	213f1904 	addi	r4,r4,-924
   13e08:	00172f80 	call	172f8 <puts>
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
   13e0c:	00005206 	br	13f58 <tcp_keepalive+0x1dc>
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
   13e10:	e0bffd17 	ldw	r2,-12(fp)
   13e14:	1080028b 	ldhu	r2,10(r2)
   13e18:	10bfffcc 	andi	r2,r2,65535
   13e1c:	10800528 	cmpgeui	r2,r2,20
   13e20:	1000091e 	bne	r2,zero,13e48 <tcp_keepalive+0xcc>
   13e24:	010000f4 	movhi	r4,3
   13e28:	213e8004 	addi	r4,r4,-1536
   13e2c:	014000f4 	movhi	r5,3
   13e30:	297f0d04 	addi	r5,r5,-972
   13e34:	0180ee04 	movi	r6,952
   13e38:	01c000f4 	movhi	r7,3
   13e3c:	39fe9f04 	addi	r7,r7,-1412
   13e40:	00170680 	call	17068 <printf>
   13e44:	003fff06 	br	13e44 <tcp_keepalive+0xc8>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = tcp_output_set_header(pcb, p, 0, htonl(pcb->snd_nxt - 1));
   13e48:	e0bfff17 	ldw	r2,-4(fp)
   13e4c:	10801717 	ldw	r2,92(r2)
   13e50:	10bfffc4 	addi	r2,r2,-1
   13e54:	1006d63a 	srli	r3,r2,24
   13e58:	e0bfff17 	ldw	r2,-4(fp)
   13e5c:	10801717 	ldw	r2,92(r2)
   13e60:	10bfffc4 	addi	r2,r2,-1
   13e64:	1004d23a 	srli	r2,r2,8
   13e68:	10bfc00c 	andi	r2,r2,65280
   13e6c:	1886b03a 	or	r3,r3,r2
   13e70:	e0bfff17 	ldw	r2,-4(fp)
   13e74:	10801717 	ldw	r2,92(r2)
   13e78:	10bfffc4 	addi	r2,r2,-1
   13e7c:	10bfc00c 	andi	r2,r2,65280
   13e80:	1004923a 	slli	r2,r2,8
   13e84:	1886b03a 	or	r3,r3,r2
   13e88:	e0bfff17 	ldw	r2,-4(fp)
   13e8c:	10801717 	ldw	r2,92(r2)
   13e90:	10bfffc4 	addi	r2,r2,-1
   13e94:	1004963a 	slli	r2,r2,24
   13e98:	1884b03a 	or	r2,r3,r2
   13e9c:	e13fff17 	ldw	r4,-4(fp)
   13ea0:	e17ffd17 	ldw	r5,-12(fp)
   13ea4:	000d883a 	mov	r6,zero
   13ea8:	100f883a 	mov	r7,r2
   13eac:	00118bc0 	call	118bc <tcp_output_set_header>
   13eb0:	e0bffe15 	stw	r2,-8(fp)

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
   13eb4:	e0ffff17 	ldw	r3,-4(fp)
   13eb8:	e0bfff17 	ldw	r2,-4(fp)
   13ebc:	10800104 	addi	r2,r2,4
                                      IP_PROTO_TCP, p->tot_len);
   13ec0:	e13ffd17 	ldw	r4,-12(fp)
   13ec4:	2100020b 	ldhu	r4,8(r4)
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = tcp_output_set_header(pcb, p, 0, htonl(pcb->snd_nxt - 1));

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
   13ec8:	213fffcc 	andi	r4,r4,65535
   13ecc:	d9000015 	stw	r4,0(sp)
   13ed0:	e13ffd17 	ldw	r4,-12(fp)
   13ed4:	180b883a 	mov	r5,r3
   13ed8:	100d883a 	mov	r6,r2
   13edc:	01c00184 	movi	r7,6
   13ee0:	0005e400 	call	5e40 <inet_chksum_pseudo>
   13ee4:	e0fffe17 	ldw	r3,-8(fp)
   13ee8:	1880040d 	sth	r2,16(r3)
                                      IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
   13eec:	00800134 	movhi	r2,4
   13ef0:	10916104 	addi	r2,r2,17796
   13ef4:	1080240b 	ldhu	r2,144(r2)
   13ef8:	10800044 	addi	r2,r2,1
   13efc:	1007883a 	mov	r3,r2
   13f00:	00800134 	movhi	r2,4
   13f04:	10916104 	addi	r2,r2,17796
   13f08:	10c0240d 	sth	r3,144(r2)
  /* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
   13f0c:	e17fff17 	ldw	r5,-4(fp)
   13f10:	e0bfff17 	ldw	r2,-4(fp)
   13f14:	10c00104 	addi	r3,r2,4
   13f18:	e0bfff17 	ldw	r2,-4(fp)
   13f1c:	108002c3 	ldbu	r2,11(r2)
   13f20:	10803fcc 	andi	r2,r2,255
   13f24:	d8000015 	stw	zero,0(sp)
   13f28:	01000184 	movi	r4,6
   13f2c:	d9000115 	stw	r4,4(sp)
   13f30:	e13ffd17 	ldw	r4,-12(fp)
   13f34:	180d883a 	mov	r6,r3
   13f38:	100f883a 	mov	r7,r2
   13f3c:	0006d180 	call	6d18 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
   13f40:	e13ffd17 	ldw	r4,-12(fp)
   13f44:	000a1880 	call	a188 <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
   13f48:	e0bfff17 	ldw	r2,-4(fp)
   13f4c:	10800a17 	ldw	r2,40(r2)
   13f50:	1009883a 	mov	r4,r2
   13f54:	00170680 	call	17068 <printf>
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
   13f58:	e037883a 	mov	sp,fp
   13f5c:	dfc00117 	ldw	ra,4(sp)
   13f60:	df000017 	ldw	fp,0(sp)
   13f64:	dec00204 	addi	sp,sp,8
   13f68:	f800283a 	ret

00013f6c <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
   13f6c:	defff704 	addi	sp,sp,-36
   13f70:	dfc00815 	stw	ra,32(sp)
   13f74:	df000715 	stw	fp,28(sp)
   13f78:	df000704 	addi	fp,sp,28
   13f7c:	e13fff15 	stw	r4,-4(fp)
  struct tcp_hdr *tcphdr;
  struct tcp_seg *seg;
  u16_t len;
  u8_t is_fin;

  LWIP_DEBUGF(TCP_DEBUG, 
   13f80:	e0bfff17 	ldw	r2,-4(fp)
   13f84:	10800117 	ldw	r2,4(r2)
   13f88:	1004d63a 	srli	r2,r2,24
   13f8c:	10803fcc 	andi	r2,r2,255
   13f90:	1007883a 	mov	r3,r2
   13f94:	e0bfff17 	ldw	r2,-4(fp)
   13f98:	10800117 	ldw	r2,4(r2)
   13f9c:	1004d23a 	srli	r2,r2,8
   13fa0:	1009883a 	mov	r4,r2
   13fa4:	00bfc004 	movi	r2,-256
   13fa8:	2084703a 	and	r2,r4,r2
   13fac:	1884b03a 	or	r2,r3,r2
   13fb0:	10bfffcc 	andi	r2,r2,65535
   13fb4:	10803fcc 	andi	r2,r2,255
   13fb8:	1009883a 	mov	r4,r2
   13fbc:	00170680 	call	17068 <printf>
              ("tcp_zero_window_probe: sending ZERO WINDOW probe to %"
               U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
               ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
               ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, 
   13fc0:	e0bfff17 	ldw	r2,-4(fp)
   13fc4:	10802943 	ldbu	r2,165(r2)
   13fc8:	10803fcc 	andi	r2,r2,255
   13fcc:	1009883a 	mov	r4,r2
   13fd0:	00170680 	call	17068 <printf>
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
   13fd4:	e0bfff17 	ldw	r2,-4(fp)
   13fd8:	10801f17 	ldw	r2,124(r2)
   13fdc:	e0bffb15 	stw	r2,-20(fp)

  if(seg == NULL)
   13fe0:	e0bffb17 	ldw	r2,-20(fp)
   13fe4:	1000031e 	bne	r2,zero,13ff4 <tcp_zero_window_probe+0x88>
    seg = pcb->unsent;
   13fe8:	e0bfff17 	ldw	r2,-4(fp)
   13fec:	10801e17 	ldw	r2,120(r2)
   13ff0:	e0bffb15 	stw	r2,-20(fp)

  if(seg == NULL)
   13ff4:	e0bffb17 	ldw	r2,-20(fp)
   13ff8:	10007f26 	beq	r2,zero,141f8 <tcp_zero_window_probe+0x28c>
    return;

  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
   13ffc:	e0bffb17 	ldw	r2,-20(fp)
   14000:	10800417 	ldw	r2,16(r2)
   14004:	1080030b 	ldhu	r2,12(r2)
   14008:	10bfffcc 	andi	r2,r2,65535
   1400c:	1004d23a 	srli	r2,r2,8
   14010:	10ffffcc 	andi	r3,r2,65535
   14014:	e0bffb17 	ldw	r2,-20(fp)
   14018:	10800417 	ldw	r2,16(r2)
   1401c:	1080030b 	ldhu	r2,12(r2)
   14020:	10bfffcc 	andi	r2,r2,65535
   14024:	1004923a 	slli	r2,r2,8
   14028:	10bfffcc 	andi	r2,r2,65535
   1402c:	1884b03a 	or	r2,r3,r2
   14030:	1080004c 	andi	r2,r2,1
   14034:	10000626 	beq	r2,zero,14050 <tcp_zero_window_probe+0xe4>
   14038:	e0bffb17 	ldw	r2,-20(fp)
   1403c:	1080030b 	ldhu	r2,12(r2)
   14040:	10bfffcc 	andi	r2,r2,65535
   14044:	1000021e 	bne	r2,zero,14050 <tcp_zero_window_probe+0xe4>
   14048:	00800044 	movi	r2,1
   1404c:	00000106 	br	14054 <tcp_zero_window_probe+0xe8>
   14050:	0005883a 	mov	r2,zero
   14054:	e0bffc05 	stb	r2,-16(fp)
  len = is_fin ? TCP_HLEN : TCP_HLEN + 1;
   14058:	e0bffc03 	ldbu	r2,-16(fp)
   1405c:	10000226 	beq	r2,zero,14068 <tcp_zero_window_probe+0xfc>
   14060:	00800504 	movi	r2,20
   14064:	00000106 	br	1406c <tcp_zero_window_probe+0x100>
   14068:	00800544 	movi	r2,21
   1406c:	e0bffc8d 	sth	r2,-14(fp)

  p = pbuf_alloc(PBUF_IP, len, PBUF_RAM);
   14070:	e0bffc8b 	ldhu	r2,-14(fp)
   14074:	01000044 	movi	r4,1
   14078:	100b883a 	mov	r5,r2
   1407c:	000d883a 	mov	r6,zero
   14080:	00097cc0 	call	97cc <pbuf_alloc>
   14084:	e0bffd15 	stw	r2,-12(fp)
  if(p == NULL) {
   14088:	e0bffd17 	ldw	r2,-12(fp)
   1408c:	1000041e 	bne	r2,zero,140a0 <tcp_zero_window_probe+0x134>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
   14090:	010000f4 	movhi	r4,3
   14094:	213f2604 	addi	r4,r4,-872
   14098:	00172f80 	call	172f8 <puts>
    return;
   1409c:	00005706 	br	141fc <tcp_zero_window_probe+0x290>
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
   140a0:	e0bffd17 	ldw	r2,-12(fp)
   140a4:	1080028b 	ldhu	r2,10(r2)
   140a8:	10bfffcc 	andi	r2,r2,65535
   140ac:	10800528 	cmpgeui	r2,r2,20
   140b0:	1000091e 	bne	r2,zero,140d8 <tcp_zero_window_probe+0x16c>
   140b4:	010000f4 	movhi	r4,3
   140b8:	213e8004 	addi	r4,r4,-1536
   140bc:	014000f4 	movhi	r5,3
   140c0:	297f0d04 	addi	r5,r5,-972
   140c4:	0180ff84 	movi	r6,1022
   140c8:	01c000f4 	movhi	r7,3
   140cc:	39fe9f04 	addi	r7,r7,-1412
   140d0:	00170680 	call	17068 <printf>
   140d4:	003fff06 	br	140d4 <tcp_zero_window_probe+0x168>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = tcp_output_set_header(pcb, p, 0, seg->tcphdr->seqno);
   140d8:	e0bffb17 	ldw	r2,-20(fp)
   140dc:	10800417 	ldw	r2,16(r2)
   140e0:	10c0010b 	ldhu	r3,4(r2)
   140e4:	1080018b 	ldhu	r2,6(r2)
   140e8:	1004943a 	slli	r2,r2,16
   140ec:	10c4b03a 	or	r2,r2,r3
   140f0:	e13fff17 	ldw	r4,-4(fp)
   140f4:	e17ffd17 	ldw	r5,-12(fp)
   140f8:	000d883a 	mov	r6,zero
   140fc:	100f883a 	mov	r7,r2
   14100:	00118bc0 	call	118bc <tcp_output_set_header>
   14104:	e0bffe15 	stw	r2,-8(fp)

  if (is_fin) {
   14108:	e0bffc03 	ldbu	r2,-16(fp)
   1410c:	10000926 	beq	r2,zero,14134 <tcp_zero_window_probe+0x1c8>
    /* FIN segment, no data */
    TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
   14110:	e0bffe17 	ldw	r2,-8(fp)
   14114:	10c0030b 	ldhu	r3,12(r2)
   14118:	00b03fc4 	movi	r2,-16129
   1411c:	1884703a 	and	r2,r3,r2
   14120:	10844014 	ori	r2,r2,4352
   14124:	1007883a 	mov	r3,r2
   14128:	e0bffe17 	ldw	r2,-8(fp)
   1412c:	10c0030d 	sth	r3,12(r2)
   14130:	00000706 	br	14150 <tcp_zero_window_probe+0x1e4>
  } else {
    /* Data segment, copy in one byte from the head of the unacked queue */
    *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;
   14134:	e0bffd17 	ldw	r2,-12(fp)
   14138:	10800117 	ldw	r2,4(r2)
   1413c:	10800504 	addi	r2,r2,20
   14140:	e0fffb17 	ldw	r3,-20(fp)
   14144:	18c00217 	ldw	r3,8(r3)
   14148:	18c00003 	ldbu	r3,0(r3)
   1414c:	10c00005 	stb	r3,0(r2)
  }

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
   14150:	e0ffff17 	ldw	r3,-4(fp)
   14154:	e0bfff17 	ldw	r2,-4(fp)
   14158:	10800104 	addi	r2,r2,4
                                      IP_PROTO_TCP, p->tot_len);
   1415c:	e13ffd17 	ldw	r4,-12(fp)
   14160:	2100020b 	ldhu	r4,8(r4)
    /* Data segment, copy in one byte from the head of the unacked queue */
    *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;
  }

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
   14164:	213fffcc 	andi	r4,r4,65535
   14168:	d9000015 	stw	r4,0(sp)
   1416c:	e13ffd17 	ldw	r4,-12(fp)
   14170:	180b883a 	mov	r5,r3
   14174:	100d883a 	mov	r6,r2
   14178:	01c00184 	movi	r7,6
   1417c:	0005e400 	call	5e40 <inet_chksum_pseudo>
   14180:	e0fffe17 	ldw	r3,-8(fp)
   14184:	1880040d 	sth	r2,16(r3)
                                      IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
   14188:	00800134 	movhi	r2,4
   1418c:	10916104 	addi	r2,r2,17796
   14190:	1080240b 	ldhu	r2,144(r2)
   14194:	10800044 	addi	r2,r2,1
   14198:	1007883a 	mov	r3,r2
   1419c:	00800134 	movhi	r2,4
   141a0:	10916104 	addi	r2,r2,17796
   141a4:	10c0240d 	sth	r3,144(r2)
  /* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
   141a8:	e17fff17 	ldw	r5,-4(fp)
   141ac:	e0bfff17 	ldw	r2,-4(fp)
   141b0:	10c00104 	addi	r3,r2,4
   141b4:	e0bfff17 	ldw	r2,-4(fp)
   141b8:	108002c3 	ldbu	r2,11(r2)
   141bc:	10803fcc 	andi	r2,r2,255
   141c0:	d8000015 	stw	zero,0(sp)
   141c4:	01000184 	movi	r4,6
   141c8:	d9000115 	stw	r4,4(sp)
   141cc:	e13ffd17 	ldw	r4,-12(fp)
   141d0:	180d883a 	mov	r6,r3
   141d4:	100f883a 	mov	r7,r2
   141d8:	0006d180 	call	6d18 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
   141dc:	e13ffd17 	ldw	r4,-12(fp)
   141e0:	000a1880 	call	a188 <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
   141e4:	e0bfff17 	ldw	r2,-4(fp)
   141e8:	10800a17 	ldw	r2,40(r2)
   141ec:	1009883a 	mov	r4,r2
   141f0:	00170680 	call	17068 <printf>
   141f4:	00000106 	br	141fc <tcp_zero_window_probe+0x290>

  if(seg == NULL)
    seg = pcb->unsent;

  if(seg == NULL)
    return;
   141f8:	0001883a 	nop
  pbuf_free(p);

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
   141fc:	e037883a 	mov	sp,fp
   14200:	dfc00117 	ldw	ra,4(sp)
   14204:	df000017 	ldw	fp,0(sp)
   14208:	dec00204 	addi	sp,sp,8
   1420c:	f800283a 	ret

00014210 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
   14210:	defff304 	addi	sp,sp,-52
   14214:	dfc00c15 	stw	ra,48(sp)
   14218:	df000b15 	stw	fp,44(sp)
   1421c:	df000b04 	addi	fp,sp,44
   14220:	e13ffe15 	stw	r4,-8(fp)
   14224:	e17fff15 	stw	r5,-4(fp)
  u8_t local_match;
  u8_t broadcast;

  PERF_START;

  UDP_STATS_INC(udp.recv);
   14228:	00800134 	movhi	r2,4
   1422c:	10916104 	addi	r2,r2,17796
   14230:	10801e8b 	ldhu	r2,122(r2)
   14234:	10800044 	addi	r2,r2,1
   14238:	1007883a 	mov	r3,r2
   1423c:	00800134 	movhi	r2,4
   14240:	10916104 	addi	r2,r2,17796
   14244:	10c01e8d 	sth	r3,122(r2)

  iphdr = p->payload;
   14248:	e0bffe17 	ldw	r2,-8(fp)
   1424c:	10800117 	ldw	r2,4(r2)
   14250:	e0bffa15 	stw	r2,-24(fp)

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
   14254:	e0bffe17 	ldw	r2,-8(fp)
   14258:	1080020b 	ldhu	r2,8(r2)
   1425c:	10ffffcc 	andi	r3,r2,65535
   14260:	e0bffa17 	ldw	r2,-24(fp)
   14264:	1080000b 	ldhu	r2,0(r2)
   14268:	10bfffcc 	andi	r2,r2,65535
   1426c:	1004d23a 	srli	r2,r2,8
   14270:	113fffcc 	andi	r4,r2,65535
   14274:	e0bffa17 	ldw	r2,-24(fp)
   14278:	1080000b 	ldhu	r2,0(r2)
   1427c:	10bfffcc 	andi	r2,r2,65535
   14280:	1004923a 	slli	r2,r2,8
   14284:	10bfffcc 	andi	r2,r2,65535
   14288:	2084b03a 	or	r2,r4,r2
   1428c:	1005d23a 	srai	r2,r2,8
   14290:	108003cc 	andi	r2,r2,15
   14294:	10800084 	addi	r2,r2,2
   14298:	1085883a 	add	r2,r2,r2
   1429c:	1085883a 	add	r2,r2,r2
   142a0:	18801816 	blt	r3,r2,14304 <udp_input+0xf4>
   142a4:	e0bffa17 	ldw	r2,-24(fp)
   142a8:	1080000b 	ldhu	r2,0(r2)
   142ac:	10bfffcc 	andi	r2,r2,65535
   142b0:	1004d23a 	srli	r2,r2,8
   142b4:	10ffffcc 	andi	r3,r2,65535
   142b8:	e0bffa17 	ldw	r2,-24(fp)
   142bc:	1080000b 	ldhu	r2,0(r2)
   142c0:	10bfffcc 	andi	r2,r2,65535
   142c4:	1004923a 	slli	r2,r2,8
   142c8:	10bfffcc 	andi	r2,r2,65535
   142cc:	1884b03a 	or	r2,r3,r2
   142d0:	1005d23a 	srai	r2,r2,8
   142d4:	108003cc 	andi	r2,r2,15
   142d8:	1085883a 	add	r2,r2,r2
   142dc:	1085883a 	add	r2,r2,r2
   142e0:	0085c83a 	sub	r2,zero,r2
   142e4:	10bfffcc 	andi	r2,r2,65535
   142e8:	10a0001c 	xori	r2,r2,32768
   142ec:	10a00004 	addi	r2,r2,-32768
   142f0:	e13ffe17 	ldw	r4,-8(fp)
   142f4:	100b883a 	mov	r5,r2
   142f8:	0009f900 	call	9f90 <pbuf_header>
   142fc:	10803fcc 	andi	r2,r2,255
   14300:	10001326 	beq	r2,zero,14350 <udp_input+0x140>
    /* drop short packets */
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
   14304:	00800134 	movhi	r2,4
   14308:	10916104 	addi	r2,r2,17796
   1430c:	1080208b 	ldhu	r2,130(r2)
   14310:	10800044 	addi	r2,r2,1
   14314:	1007883a 	mov	r3,r2
   14318:	00800134 	movhi	r2,4
   1431c:	10916104 	addi	r2,r2,17796
   14320:	10c0208d 	sth	r3,130(r2)
    UDP_STATS_INC(udp.drop);
   14324:	00800134 	movhi	r2,4
   14328:	10916104 	addi	r2,r2,17796
   1432c:	10801f8b 	ldhu	r2,126(r2)
   14330:	10800044 	addi	r2,r2,1
   14334:	1007883a 	mov	r3,r2
   14338:	00800134 	movhi	r2,4
   1433c:	10916104 	addi	r2,r2,17796
   14340:	10c01f8d 	sth	r3,126(r2)
    snmp_inc_udpinerrors();
    pbuf_free(p);
   14344:	e13ffe17 	ldw	r4,-8(fp)
   14348:	000a1880 	call	a188 <pbuf_free>
    goto end;
   1434c:	00013c06 	br	14840 <udp_input+0x630>
  }

  udphdr = (struct udp_hdr *)p->payload;
   14350:	e0bffe17 	ldw	r2,-8(fp)
   14354:	10800117 	ldw	r2,4(r2)
   14358:	e0bffb15 	stw	r2,-20(fp)

  /* is broadcast packet ? */
  broadcast = ip_addr_isbroadcast(&(iphdr->dest), inp);
   1435c:	e0bffa17 	ldw	r2,-24(fp)
   14360:	10800404 	addi	r2,r2,16
   14364:	1009883a 	mov	r4,r2
   14368:	e17fff17 	ldw	r5,-4(fp)
   1436c:	0006dcc0 	call	6dcc <ip_addr_isbroadcast>
   14370:	e0bffc05 	stb	r2,-16(fp)

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
   14374:	e0bffb17 	ldw	r2,-20(fp)
   14378:	1080000b 	ldhu	r2,0(r2)
   1437c:	10bfffcc 	andi	r2,r2,65535
   14380:	1004d23a 	srli	r2,r2,8
   14384:	1007883a 	mov	r3,r2
   14388:	e0bffb17 	ldw	r2,-20(fp)
   1438c:	1080000b 	ldhu	r2,0(r2)
   14390:	10bfffcc 	andi	r2,r2,65535
   14394:	1004923a 	slli	r2,r2,8
   14398:	1884b03a 	or	r2,r3,r2
   1439c:	e0bffc8d 	sth	r2,-14(fp)
  dest = ntohs(udphdr->dest);
   143a0:	e0bffb17 	ldw	r2,-20(fp)
   143a4:	1080008b 	ldhu	r2,2(r2)
   143a8:	10bfffcc 	andi	r2,r2,65535
   143ac:	1004d23a 	srli	r2,r2,8
   143b0:	1007883a 	mov	r3,r2
   143b4:	e0bffb17 	ldw	r2,-20(fp)
   143b8:	1080008b 	ldhu	r2,2(r2)
   143bc:	10bfffcc 	andi	r2,r2,65535
   143c0:	1004923a 	slli	r2,r2,8
   143c4:	1884b03a 	or	r2,r3,r2
   143c8:	e0bffd0d 	sth	r2,-12(fp)
               ip4_addr3(&iphdr->dest), ip4_addr4(&iphdr->dest), ntohs(udphdr->dest),
               ip4_addr1(&iphdr->src), ip4_addr2(&iphdr->src),
               ip4_addr3(&iphdr->src), ip4_addr4(&iphdr->src), ntohs(udphdr->src)));

#if LWIP_DHCP
  pcb = NULL;
   143cc:	e03ff615 	stw	zero,-40(fp)
  /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
     the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
  if (dest == DHCP_CLIENT_PORT) {
   143d0:	e0bffd0b 	ldhu	r2,-12(fp)
   143d4:	10801118 	cmpnei	r2,r2,68
   143d8:	1000231e 	bne	r2,zero,14468 <udp_input+0x258>
    /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
    if (src == DHCP_SERVER_PORT) {
   143dc:	e0bffc8b 	ldhu	r2,-14(fp)
   143e0:	108010d8 	cmpnei	r2,r2,67
   143e4:	10007d1e 	bne	r2,zero,145dc <udp_input+0x3cc>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
   143e8:	e0bfff17 	ldw	r2,-4(fp)
   143ec:	10800817 	ldw	r2,32(r2)
   143f0:	10007a26 	beq	r2,zero,145dc <udp_input+0x3cc>
   143f4:	e0bfff17 	ldw	r2,-4(fp)
   143f8:	10800817 	ldw	r2,32(r2)
   143fc:	10800117 	ldw	r2,4(r2)
   14400:	10007626 	beq	r2,zero,145dc <udp_input+0x3cc>
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
   14404:	e0bfff17 	ldw	r2,-4(fp)
   14408:	10800817 	ldw	r2,32(r2)
   1440c:	10800117 	ldw	r2,4(r2)
   14410:	10800104 	addi	r2,r2,4
   14414:	10000f26 	beq	r2,zero,14454 <udp_input+0x244>
   14418:	e0bfff17 	ldw	r2,-4(fp)
   1441c:	10800817 	ldw	r2,32(r2)
   14420:	10800117 	ldw	r2,4(r2)
   14424:	10800117 	ldw	r2,4(r2)
   14428:	10000a26 	beq	r2,zero,14454 <udp_input+0x244>
           ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &(iphdr->src)))) {
   1442c:	e0bfff17 	ldw	r2,-4(fp)
   14430:	10800817 	ldw	r2,32(r2)
   14434:	10800117 	ldw	r2,4(r2)
   14438:	10c00117 	ldw	r3,4(r2)
   1443c:	e0bffa17 	ldw	r2,-24(fp)
   14440:	1100030b 	ldhu	r4,12(r2)
   14444:	1080038b 	ldhu	r2,14(r2)
   14448:	1004943a 	slli	r2,r2,16
   1444c:	1104b03a 	or	r2,r2,r4
    if (src == DHCP_SERVER_PORT) {
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
   14450:	1880621e 	bne	r3,r2,145dc <udp_input+0x3cc>
           ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &(iphdr->src)))) {
          pcb = inp->dhcp->pcb;
   14454:	e0bfff17 	ldw	r2,-4(fp)
   14458:	10800817 	ldw	r2,32(r2)
   1445c:	10800117 	ldw	r2,4(r2)
   14460:	e0bff615 	stw	r2,-40(fp)
   14464:	00005d06 	br	145dc <udp_input+0x3cc>
      }
    }
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
   14468:	e03ff715 	stw	zero,-36(fp)
    local_match = 0;
   1446c:	e03ff905 	stb	zero,-28(fp)
    uncon_pcb = NULL;
   14470:	e03ff815 	stw	zero,-32(fp)
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
   14474:	d0a8e417 	ldw	r2,-23664(gp)
   14478:	e0bff615 	stw	r2,-40(fp)
   1447c:	00005106 	br	145c4 <udp_input+0x3b4>
      local_match = 0;
   14480:	e03ff905 	stb	zero,-28(fp)
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
   14484:	e0bff617 	ldw	r2,-40(fp)
   14488:	1080048b 	ldhu	r2,18(r2)
   1448c:	10ffffcc 	andi	r3,r2,65535
   14490:	e0bffd0b 	ldhu	r2,-12(fp)
   14494:	18801c1e 	bne	r3,r2,14508 <udp_input+0x2f8>
   14498:	e0bffc03 	ldbu	r2,-16(fp)
   1449c:	1000051e 	bne	r2,zero,144b4 <udp_input+0x2a4>
          ((!broadcast && ip_addr_isany(&pcb->local_ip)) ||
   144a0:	e0bff617 	ldw	r2,-40(fp)
   144a4:	10000d26 	beq	r2,zero,144dc <udp_input+0x2cc>
   144a8:	e0bff617 	ldw	r2,-40(fp)
   144ac:	10800017 	ldw	r2,0(r2)
   144b0:	10000a26 	beq	r2,zero,144dc <udp_input+0x2cc>
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) ||
   144b4:	e0bff617 	ldw	r2,-40(fp)
   144b8:	10c00017 	ldw	r3,0(r2)
   144bc:	e0bffa17 	ldw	r2,-24(fp)
   144c0:	1100040b 	ldhu	r4,16(r2)
   144c4:	1080048b 	ldhu	r2,18(r2)
   144c8:	1004943a 	slli	r2,r2,16
   144cc:	1104b03a 	or	r2,r2,r4
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
          ((!broadcast && ip_addr_isany(&pcb->local_ip)) ||
   144d0:	18800226 	beq	r3,r2,144dc <udp_input+0x2cc>
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) ||
   144d4:	e0bffc03 	ldbu	r2,-16(fp)
   144d8:	10000b26 	beq	r2,zero,14508 <udp_input+0x2f8>
#if IP_SOF_BROADCAST_RECV
           (broadcast && (pcb->so_options & SOF_BROADCAST)))) {
#else  /* IP_SOF_BROADCAST_RECV */
           (broadcast))) {
#endif /* IP_SOF_BROADCAST_RECV */
        local_match = 1;
   144dc:	00800044 	movi	r2,1
   144e0:	e0bff905 	stb	r2,-28(fp)
        if ((uncon_pcb == NULL) && 
   144e4:	e0bff817 	ldw	r2,-32(fp)
   144e8:	1000071e 	bne	r2,zero,14508 <udp_input+0x2f8>
            ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
   144ec:	e0bff617 	ldw	r2,-40(fp)
   144f0:	10800403 	ldbu	r2,16(r2)
   144f4:	10803fcc 	andi	r2,r2,255
   144f8:	1080010c 	andi	r2,r2,4
           (broadcast && (pcb->so_options & SOF_BROADCAST)))) {
#else  /* IP_SOF_BROADCAST_RECV */
           (broadcast))) {
#endif /* IP_SOF_BROADCAST_RECV */
        local_match = 1;
        if ((uncon_pcb == NULL) && 
   144fc:	1000021e 	bne	r2,zero,14508 <udp_input+0x2f8>
            ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
          /* the first unconnected matching PCB */
          uncon_pcb = pcb;
   14500:	e0bff617 	ldw	r2,-40(fp)
   14504:	e0bff815 	stw	r2,-32(fp)
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
   14508:	e0bff903 	ldbu	r2,-28(fp)
   1450c:	10002826 	beq	r2,zero,145b0 <udp_input+0x3a0>
          (pcb->remote_port == src) &&
   14510:	e0bff617 	ldw	r2,-40(fp)
   14514:	1080050b 	ldhu	r2,20(r2)
          /* the first unconnected matching PCB */
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
   14518:	10ffffcc 	andi	r3,r2,65535
   1451c:	e0bffc8b 	ldhu	r2,-14(fp)
   14520:	1880231e 	bne	r3,r2,145b0 <udp_input+0x3a0>
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
   14524:	e0bff617 	ldw	r2,-40(fp)
   14528:	10800104 	addi	r2,r2,4
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
   1452c:	10000b26 	beq	r2,zero,1455c <udp_input+0x34c>
          (ip_addr_isany(&pcb->remote_ip) ||
   14530:	e0bff617 	ldw	r2,-40(fp)
   14534:	10800117 	ldw	r2,4(r2)
   14538:	10000826 	beq	r2,zero,1455c <udp_input+0x34c>
           ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
   1453c:	e0bff617 	ldw	r2,-40(fp)
   14540:	10c00117 	ldw	r3,4(r2)
   14544:	e0bffa17 	ldw	r2,-24(fp)
   14548:	1100030b 	ldhu	r4,12(r2)
   1454c:	1080038b 	ldhu	r2,14(r2)
   14550:	1004943a 	slli	r2,r2,16
   14554:	1104b03a 	or	r2,r2,r4
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
   14558:	1880151e 	bne	r3,r2,145b0 <udp_input+0x3a0>
           ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
        /* the first fully matching PCB */
        if (prev != NULL) {
   1455c:	e0bff717 	ldw	r2,-36(fp)
   14560:	10000a26 	beq	r2,zero,1458c <udp_input+0x37c>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
   14564:	e0bff617 	ldw	r2,-40(fp)
   14568:	10c00317 	ldw	r3,12(r2)
   1456c:	e0bff717 	ldw	r2,-36(fp)
   14570:	10c00315 	stw	r3,12(r2)
          pcb->next = udp_pcbs;
   14574:	d0e8e417 	ldw	r3,-23664(gp)
   14578:	e0bff617 	ldw	r2,-40(fp)
   1457c:	10c00315 	stw	r3,12(r2)
          udp_pcbs = pcb;
   14580:	e0bff617 	ldw	r2,-40(fp)
   14584:	d0a8e415 	stw	r2,-23664(gp)
        } else {
          UDP_STATS_INC(udp.cachehit);
        }
        break;
   14588:	00001006 	br	145cc <udp_input+0x3bc>
             found faster next time */
          prev->next = pcb->next;
          pcb->next = udp_pcbs;
          udp_pcbs = pcb;
        } else {
          UDP_STATS_INC(udp.cachehit);
   1458c:	00800134 	movhi	r2,4
   14590:	10916104 	addi	r2,r2,17796
   14594:	1080238b 	ldhu	r2,142(r2)
   14598:	10800044 	addi	r2,r2,1
   1459c:	1007883a 	mov	r3,r2
   145a0:	00800134 	movhi	r2,4
   145a4:	10916104 	addi	r2,r2,17796
   145a8:	10c0238d 	sth	r3,142(r2)
        }
        break;
   145ac:	00000706 	br	145cc <udp_input+0x3bc>
      }
      prev = pcb;
   145b0:	e0bff617 	ldw	r2,-40(fp)
   145b4:	e0bff715 	stw	r2,-36(fp)
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
   145b8:	e0bff617 	ldw	r2,-40(fp)
   145bc:	10800317 	ldw	r2,12(r2)
   145c0:	e0bff615 	stw	r2,-40(fp)
   145c4:	e0bff617 	ldw	r2,-40(fp)
   145c8:	103fad1e 	bne	r2,zero,14480 <udp_input+0x270>
        break;
      }
      prev = pcb;
    }
    /* no fully matching pcb found? then look for an unconnected pcb */
    if (pcb == NULL) {
   145cc:	e0bff617 	ldw	r2,-40(fp)
   145d0:	1000021e 	bne	r2,zero,145dc <udp_input+0x3cc>
      pcb = uncon_pcb;
   145d4:	e0bff817 	ldw	r2,-32(fp)
   145d8:	e0bff615 	stw	r2,-40(fp)
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
   145dc:	e0bff617 	ldw	r2,-40(fp)
   145e0:	1000081e 	bne	r2,zero,14604 <udp_input+0x3f4>
   145e4:	e0bfff17 	ldw	r2,-4(fp)
   145e8:	10c00117 	ldw	r3,4(r2)
   145ec:	e0bffa17 	ldw	r2,-24(fp)
   145f0:	1100040b 	ldhu	r4,16(r2)
   145f4:	1080048b 	ldhu	r2,18(r2)
   145f8:	1004943a 	slli	r2,r2,16
   145fc:	1104b03a 	or	r2,r2,r4
   14600:	18808d1e 	bne	r3,r2,14838 <udp_input+0x628>
#endif /* CHECKSUM_CHECK_UDP */
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
   14604:	e0bffb17 	ldw	r2,-20(fp)
   14608:	1080018b 	ldhu	r2,6(r2)
   1460c:	10bfffcc 	andi	r2,r2,65535
   14610:	10002226 	beq	r2,zero,1469c <udp_input+0x48c>
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
   14614:	e0bffa17 	ldw	r2,-24(fp)
   14618:	10c00304 	addi	r3,r2,12
   1461c:	e0bffa17 	ldw	r2,-24(fp)
   14620:	10800404 	addi	r2,r2,16
                               (struct ip_addr *)&(iphdr->dest),
                               IP_PROTO_UDP, p->tot_len) != 0) {
   14624:	e13ffe17 	ldw	r4,-8(fp)
   14628:	2100020b 	ldhu	r4,8(r4)
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
   1462c:	213fffcc 	andi	r4,r4,65535
   14630:	d9000015 	stw	r4,0(sp)
   14634:	e13ffe17 	ldw	r4,-8(fp)
   14638:	180b883a 	mov	r5,r3
   1463c:	100d883a 	mov	r6,r2
   14640:	01c00444 	movi	r7,17
   14644:	0005e400 	call	5e40 <inet_chksum_pseudo>
   14648:	10bfffcc 	andi	r2,r2,65535
   1464c:	10001326 	beq	r2,zero,1469c <udp_input+0x48c>
                               (struct ip_addr *)&(iphdr->dest),
                               IP_PROTO_UDP, p->tot_len) != 0) {
          LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                      ("udp_input: UDP datagram discarded due to failing checksum\n"));
          UDP_STATS_INC(udp.chkerr);
   14650:	00800134 	movhi	r2,4
   14654:	10916104 	addi	r2,r2,17796
   14658:	1080200b 	ldhu	r2,128(r2)
   1465c:	10800044 	addi	r2,r2,1
   14660:	1007883a 	mov	r3,r2
   14664:	00800134 	movhi	r2,4
   14668:	10916104 	addi	r2,r2,17796
   1466c:	10c0200d 	sth	r3,128(r2)
          UDP_STATS_INC(udp.drop);
   14670:	00800134 	movhi	r2,4
   14674:	10916104 	addi	r2,r2,17796
   14678:	10801f8b 	ldhu	r2,126(r2)
   1467c:	10800044 	addi	r2,r2,1
   14680:	1007883a 	mov	r3,r2
   14684:	00800134 	movhi	r2,4
   14688:	10916104 	addi	r2,r2,17796
   1468c:	10c01f8d 	sth	r3,126(r2)
          snmp_inc_udpinerrors();
          pbuf_free(p);
   14690:	e13ffe17 	ldw	r4,-8(fp)
   14694:	000a1880 	call	a188 <pbuf_free>
          goto end;
   14698:	00006906 	br	14840 <udp_input+0x630>
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
   1469c:	e13ffe17 	ldw	r4,-8(fp)
   146a0:	017ffe04 	movi	r5,-8
   146a4:	0009f900 	call	9f90 <pbuf_header>
   146a8:	10803fcc 	andi	r2,r2,255
   146ac:	10000926 	beq	r2,zero,146d4 <udp_input+0x4c4>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
   146b0:	010000f4 	movhi	r4,3
   146b4:	213f3104 	addi	r4,r4,-828
   146b8:	014000f4 	movhi	r5,3
   146bc:	297f3b04 	addi	r5,r5,-788
   146c0:	01804484 	movi	r6,274
   146c4:	01c000f4 	movhi	r7,3
   146c8:	39ff4004 	addi	r7,r7,-768
   146cc:	00170680 	call	17068 <printf>
   146d0:	003fff06 	br	146d0 <udp_input+0x4c0>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
   146d4:	e0bff617 	ldw	r2,-40(fp)
   146d8:	10001426 	beq	r2,zero,1472c <udp_input+0x51c>
      snmp_inc_udpindatagrams();
      /* callback */
      if (pcb->recv != NULL) {
   146dc:	e0bff617 	ldw	r2,-40(fp)
   146e0:	10800617 	ldw	r2,24(r2)
   146e4:	10000e26 	beq	r2,zero,14720 <udp_input+0x510>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, &iphdr->src, src);
   146e8:	e0bff617 	ldw	r2,-40(fp)
   146ec:	12000617 	ldw	r8,24(r2)
   146f0:	e0bff617 	ldw	r2,-40(fp)
   146f4:	10c00717 	ldw	r3,28(r2)
   146f8:	e0bffa17 	ldw	r2,-24(fp)
   146fc:	10800304 	addi	r2,r2,12
   14700:	e13ffc8b 	ldhu	r4,-14(fp)
   14704:	d9000015 	stw	r4,0(sp)
   14708:	1809883a 	mov	r4,r3
   1470c:	e17ff617 	ldw	r5,-40(fp)
   14710:	e1bffe17 	ldw	r6,-8(fp)
   14714:	100f883a 	mov	r7,r2
   14718:	403ee83a 	callr	r8
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
   1471c:	00004806 	br	14840 <udp_input+0x630>
      if (pcb->recv != NULL) {
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, &iphdr->src, src);
      } else {
        /* no recv function registered? then we have to free the pbuf! */
        pbuf_free(p);
   14720:	e13ffe17 	ldw	r4,-8(fp)
   14724:	000a1880 	call	a188 <pbuf_free>
        goto end;
   14728:	00004506 	br	14840 <udp_input+0x630>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!broadcast &&
   1472c:	e0bffc03 	ldbu	r2,-16(fp)
   14730:	10002e1e 	bne	r2,zero,147ec <udp_input+0x5dc>
          !ip_addr_ismulticast(&iphdr->dest)) {
   14734:	e0bffa17 	ldw	r2,-24(fp)
   14738:	10c0040b 	ldhu	r3,16(r2)
   1473c:	1080048b 	ldhu	r2,18(r2)
   14740:	1004943a 	slli	r2,r2,16
   14744:	10c4b03a 	or	r2,r2,r3
   14748:	10803c0c 	andi	r2,r2,240
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!broadcast &&
   1474c:	10803820 	cmpeqi	r2,r2,224
   14750:	1000261e 	bne	r2,zero,147ec <udp_input+0x5dc>
          !ip_addr_ismulticast(&iphdr->dest)) {
        /* move payload pointer back to ip header */
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
   14754:	e0bffa17 	ldw	r2,-24(fp)
   14758:	1080000b 	ldhu	r2,0(r2)
   1475c:	10bfffcc 	andi	r2,r2,65535
   14760:	1004d23a 	srli	r2,r2,8
   14764:	10ffffcc 	andi	r3,r2,65535
   14768:	e0bffa17 	ldw	r2,-24(fp)
   1476c:	1080000b 	ldhu	r2,0(r2)
   14770:	10bfffcc 	andi	r2,r2,65535
   14774:	1004923a 	slli	r2,r2,8
   14778:	10bfffcc 	andi	r2,r2,65535
   1477c:	1884b03a 	or	r2,r3,r2
   14780:	1005d23a 	srai	r2,r2,8
   14784:	108003cc 	andi	r2,r2,15
   14788:	10800084 	addi	r2,r2,2
   1478c:	1085883a 	add	r2,r2,r2
   14790:	1085883a 	add	r2,r2,r2
   14794:	10bfffcc 	andi	r2,r2,65535
   14798:	10a0001c 	xori	r2,r2,32768
   1479c:	10a00004 	addi	r2,r2,-32768
   147a0:	e13ffe17 	ldw	r4,-8(fp)
   147a4:	100b883a 	mov	r5,r2
   147a8:	0009f900 	call	9f90 <pbuf_header>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
   147ac:	e0bffe17 	ldw	r2,-8(fp)
   147b0:	10c00117 	ldw	r3,4(r2)
   147b4:	e0bffa17 	ldw	r2,-24(fp)
   147b8:	18800926 	beq	r3,r2,147e0 <udp_input+0x5d0>
   147bc:	010000f4 	movhi	r4,3
   147c0:	213f3104 	addi	r4,r4,-828
   147c4:	014000f4 	movhi	r5,3
   147c8:	297f4504 	addi	r5,r5,-748
   147cc:	01804b44 	movi	r6,301
   147d0:	01c000f4 	movhi	r7,3
   147d4:	39ff4004 	addi	r7,r7,-768
   147d8:	00170680 	call	17068 <printf>
   147dc:	003fff06 	br	147dc <udp_input+0x5cc>
        icmp_dest_unreach(p, ICMP_DUR_PORT);
   147e0:	e13ffe17 	ldw	r4,-8(fp)
   147e4:	014000c4 	movi	r5,3
   147e8:	00054880 	call	5488 <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
   147ec:	00800134 	movhi	r2,4
   147f0:	10916104 	addi	r2,r2,17796
   147f4:	1080220b 	ldhu	r2,136(r2)
   147f8:	10800044 	addi	r2,r2,1
   147fc:	1007883a 	mov	r3,r2
   14800:	00800134 	movhi	r2,4
   14804:	10916104 	addi	r2,r2,17796
   14808:	10c0220d 	sth	r3,136(r2)
      UDP_STATS_INC(udp.drop);
   1480c:	00800134 	movhi	r2,4
   14810:	10916104 	addi	r2,r2,17796
   14814:	10801f8b 	ldhu	r2,126(r2)
   14818:	10800044 	addi	r2,r2,1
   1481c:	1007883a 	mov	r3,r2
   14820:	00800134 	movhi	r2,4
   14824:	10916104 	addi	r2,r2,17796
   14828:	10c01f8d 	sth	r3,126(r2)
      snmp_inc_udpnoports();
      pbuf_free(p);
   1482c:	e13ffe17 	ldw	r4,-8(fp)
   14830:	000a1880 	call	a188 <pbuf_free>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
   14834:	00000206 	br	14840 <udp_input+0x630>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
    }
  } else {
    pbuf_free(p);
   14838:	e13ffe17 	ldw	r4,-8(fp)
   1483c:	000a1880 	call	a188 <pbuf_free>
  }
end:
  PERF_STOP("udp_input");
}
   14840:	e037883a 	mov	sp,fp
   14844:	dfc00117 	ldw	ra,4(sp)
   14848:	df000017 	ldw	fp,0(sp)
   1484c:	dec00204 	addi	sp,sp,8
   14850:	f800283a 	ret

00014854 <udp_send>:
 *
 * @see udp_disconnect() udp_sendto()
 */
err_t
udp_send(struct udp_pcb *pcb, struct pbuf *p)
{
   14854:	defffc04 	addi	sp,sp,-16
   14858:	dfc00315 	stw	ra,12(sp)
   1485c:	df000215 	stw	fp,8(sp)
   14860:	df000204 	addi	fp,sp,8
   14864:	e13ffe15 	stw	r4,-8(fp)
   14868:	e17fff15 	stw	r5,-4(fp)
  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
   1486c:	e0bffe17 	ldw	r2,-8(fp)
   14870:	10c00104 	addi	r3,r2,4
   14874:	e0bffe17 	ldw	r2,-8(fp)
   14878:	1080050b 	ldhu	r2,20(r2)
   1487c:	10bfffcc 	andi	r2,r2,65535
   14880:	e13ffe17 	ldw	r4,-8(fp)
   14884:	e17fff17 	ldw	r5,-4(fp)
   14888:	180d883a 	mov	r6,r3
   1488c:	100f883a 	mov	r7,r2
   14890:	00148a80 	call	148a8 <udp_sendto>
}
   14894:	e037883a 	mov	sp,fp
   14898:	dfc00117 	ldw	ra,4(sp)
   1489c:	df000017 	ldw	fp,0(sp)
   148a0:	dec00204 	addi	sp,sp,8
   148a4:	f800283a 	ret

000148a8 <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port)
{
   148a8:	defff804 	addi	sp,sp,-32
   148ac:	dfc00715 	stw	ra,28(sp)
   148b0:	df000615 	stw	fp,24(sp)
   148b4:	df000604 	addi	fp,sp,24
   148b8:	e13ffc15 	stw	r4,-16(fp)
   148bc:	e17ffd15 	stw	r5,-12(fp)
   148c0:	e1bffe15 	stw	r6,-8(fp)
   148c4:	3805883a 	mov	r2,r7
   148c8:	e0bfff0d 	sth	r2,-4(fp)

  /* find the outgoing network interface for this packet */
#if LWIP_IGMP
  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
#else
  netif = ip_route(dst_ip);
   148cc:	e13ffe17 	ldw	r4,-8(fp)
   148d0:	00061b00 	call	61b0 <ip_route>
   148d4:	e0bffb15 	stw	r2,-20(fp)
#endif /* LWIP_IGMP */

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
   148d8:	e0bffb17 	ldw	r2,-20(fp)
   148dc:	10000a1e 	bne	r2,zero,14908 <udp_sendto+0x60>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: No route to 0x%"X32_F"\n", dst_ip->addr));
    UDP_STATS_INC(udp.rterr);
   148e0:	00800134 	movhi	r2,4
   148e4:	10916104 	addi	r2,r2,17796
   148e8:	1080218b 	ldhu	r2,134(r2)
   148ec:	10800044 	addi	r2,r2,1
   148f0:	1007883a 	mov	r3,r2
   148f4:	00800134 	movhi	r2,4
   148f8:	10916104 	addi	r2,r2,17796
   148fc:	10c0218d 	sth	r3,134(r2)
    return ERR_RTE;
   14900:	00bfff04 	movi	r2,-4
   14904:	00000806 	br	14928 <udp_sendto+0x80>
  }
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
   14908:	e0bfff0b 	ldhu	r2,-4(fp)
   1490c:	e0fffb17 	ldw	r3,-20(fp)
   14910:	d8c00015 	stw	r3,0(sp)
   14914:	e13ffc17 	ldw	r4,-16(fp)
   14918:	e17ffd17 	ldw	r5,-12(fp)
   1491c:	e1bffe17 	ldw	r6,-8(fp)
   14920:	100f883a 	mov	r7,r2
   14924:	001493c0 	call	1493c <udp_sendto_if>
}
   14928:	e037883a 	mov	sp,fp
   1492c:	dfc00117 	ldw	ra,4(sp)
   14930:	df000017 	ldw	fp,0(sp)
   14934:	dec00204 	addi	sp,sp,8
   14938:	f800283a 	ret

0001493c <udp_sendto_if>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port, struct netif *netif)
{
   1493c:	defff304 	addi	sp,sp,-52
   14940:	dfc00c15 	stw	ra,48(sp)
   14944:	df000b15 	stw	fp,44(sp)
   14948:	df000b04 	addi	fp,sp,44
   1494c:	e13ffc15 	stw	r4,-16(fp)
   14950:	e17ffd15 	stw	r5,-12(fp)
   14954:	e1bffe15 	stw	r6,-8(fp)
   14958:	3805883a 	mov	r2,r7
   1495c:	e0bfff0d 	sth	r2,-4(fp)
    return ERR_VAL;
  }
#endif /* IP_SOF_BROADCAST */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
   14960:	e0bffc17 	ldw	r2,-16(fp)
   14964:	1080048b 	ldhu	r2,18(r2)
   14968:	10bfffcc 	andi	r2,r2,65535
   1496c:	10000d1e 	bne	r2,zero,149a4 <udp_sendto_if+0x68>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
   14970:	e0fffc17 	ldw	r3,-16(fp)
   14974:	e0bffc17 	ldw	r2,-16(fp)
   14978:	1080048b 	ldhu	r2,18(r2)
   1497c:	10bfffcc 	andi	r2,r2,65535
   14980:	e13ffc17 	ldw	r4,-16(fp)
   14984:	180b883a 	mov	r5,r3
   14988:	100d883a 	mov	r6,r2
   1498c:	0014c1c0 	call	14c1c <udp_bind>
   14990:	e0bffa05 	stb	r2,-24(fp)
    if (err != ERR_OK) {
   14994:	e0bffa07 	ldb	r2,-24(fp)
   14998:	10000226 	beq	r2,zero,149a4 <udp_sendto_if+0x68>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: forced port bind failed\n"));
      return err;
   1499c:	e0bffa03 	ldbu	r2,-24(fp)
   149a0:	00009906 	br	14c08 <udp_sendto_if+0x2cc>
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
   149a4:	e13ffd17 	ldw	r4,-12(fp)
   149a8:	01400204 	movi	r5,8
   149ac:	0009f900 	call	9f90 <pbuf_header>
   149b0:	10803fcc 	andi	r2,r2,255
   149b4:	10000d26 	beq	r2,zero,149ec <udp_sendto_if+0xb0>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
   149b8:	01000044 	movi	r4,1
   149bc:	01400204 	movi	r5,8
   149c0:	000d883a 	mov	r6,zero
   149c4:	00097cc0 	call	97cc <pbuf_alloc>
   149c8:	e0bff915 	stw	r2,-28(fp)
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
   149cc:	e0bff917 	ldw	r2,-28(fp)
   149d0:	1000021e 	bne	r2,zero,149dc <udp_sendto_if+0xa0>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
   149d4:	00bfffc4 	movi	r2,-1
   149d8:	00008b06 	br	14c08 <udp_sendto_if+0x2cc>
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
   149dc:	e13ff917 	ldw	r4,-28(fp)
   149e0:	e17ffd17 	ldw	r5,-12(fp)
   149e4:	000a5200 	call	a520 <pbuf_chain>
   149e8:	00000206 	br	149f4 <udp_sendto_if+0xb8>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  } else {
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
   149ec:	e0bffd17 	ldw	r2,-12(fp)
   149f0:	e0bff915 	stw	r2,-28(fp)
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
   149f4:	e0bff917 	ldw	r2,-28(fp)
   149f8:	1080028b 	ldhu	r2,10(r2)
   149fc:	10bfffcc 	andi	r2,r2,65535
   14a00:	10800228 	cmpgeui	r2,r2,8
   14a04:	1000091e 	bne	r2,zero,14a2c <udp_sendto_if+0xf0>
   14a08:	010000f4 	movhi	r4,3
   14a0c:	213f3104 	addi	r4,r4,-828
   14a10:	014000f4 	movhi	r5,3
   14a14:	297f4a04 	addi	r5,r5,-728
   14a18:	018070c4 	movi	r6,451
   14a1c:	01c000f4 	movhi	r7,3
   14a20:	39ff4004 	addi	r7,r7,-768
   14a24:	00170680 	call	17068 <printf>
   14a28:	003fff06 	br	14a28 <udp_sendto_if+0xec>
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = q->payload;
   14a2c:	e0bff917 	ldw	r2,-28(fp)
   14a30:	10800117 	ldw	r2,4(r2)
   14a34:	e0bffb15 	stw	r2,-20(fp)
  udphdr->src = htons(pcb->local_port);
   14a38:	e0bffc17 	ldw	r2,-16(fp)
   14a3c:	1080048b 	ldhu	r2,18(r2)
   14a40:	10bfffcc 	andi	r2,r2,65535
   14a44:	1004d23a 	srli	r2,r2,8
   14a48:	1007883a 	mov	r3,r2
   14a4c:	e0bffc17 	ldw	r2,-16(fp)
   14a50:	1080048b 	ldhu	r2,18(r2)
   14a54:	10bfffcc 	andi	r2,r2,65535
   14a58:	1004923a 	slli	r2,r2,8
   14a5c:	1884b03a 	or	r2,r3,r2
   14a60:	1007883a 	mov	r3,r2
   14a64:	e0bffb17 	ldw	r2,-20(fp)
   14a68:	10c0000d 	sth	r3,0(r2)
  udphdr->dest = htons(dst_port);
   14a6c:	e0bfff0b 	ldhu	r2,-4(fp)
   14a70:	1004d23a 	srli	r2,r2,8
   14a74:	1007883a 	mov	r3,r2
   14a78:	e0bfff0b 	ldhu	r2,-4(fp)
   14a7c:	1004923a 	slli	r2,r2,8
   14a80:	1884b03a 	or	r2,r3,r2
   14a84:	1007883a 	mov	r3,r2
   14a88:	e0bffb17 	ldw	r2,-20(fp)
   14a8c:	10c0008d 	sth	r3,2(r2)
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
   14a90:	e0bffb17 	ldw	r2,-20(fp)
   14a94:	1000018d 	sth	zero,6(r2)

  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
   14a98:	e0bffc17 	ldw	r2,-16(fp)
   14a9c:	10000326 	beq	r2,zero,14aac <udp_sendto_if+0x170>
   14aa0:	e0bffc17 	ldw	r2,-16(fp)
   14aa4:	10800017 	ldw	r2,0(r2)
   14aa8:	1000041e 	bne	r2,zero,14abc <udp_sendto_if+0x180>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
   14aac:	e0800217 	ldw	r2,8(fp)
   14ab0:	10800104 	addi	r2,r2,4
   14ab4:	e0bff815 	stw	r2,-32(fp)
   14ab8:	00000f06 	br	14af8 <udp_sendto_if+0x1bc>
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
   14abc:	e0bffc17 	ldw	r2,-16(fp)
   14ac0:	10c00017 	ldw	r3,0(r2)
   14ac4:	e0800217 	ldw	r2,8(fp)
   14ac8:	10800117 	ldw	r2,4(r2)
   14acc:	18800826 	beq	r3,r2,14af0 <udp_sendto_if+0x1b4>
      /* local_ip doesn't match, drop the packet */
      if (q != p) {
   14ad0:	e0fff917 	ldw	r3,-28(fp)
   14ad4:	e0bffd17 	ldw	r2,-12(fp)
   14ad8:	18800326 	beq	r3,r2,14ae8 <udp_sendto_if+0x1ac>
        /* free the header pbuf */
        pbuf_free(q);
   14adc:	e13ff917 	ldw	r4,-28(fp)
   14ae0:	000a1880 	call	a188 <pbuf_free>
        q = NULL;
   14ae4:	e03ff915 	stw	zero,-28(fp)
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
   14ae8:	00bffdc4 	movi	r2,-9
   14aec:	00004606 	br	14c08 <udp_sendto_if+0x2cc>
    }
    /* use UDP PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
   14af0:	e0bffc17 	ldw	r2,-16(fp)
   14af4:	e0bff815 	stw	r2,-32(fp)
#endif /* LWIP_NETIF_HWADDRHINT*/
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
   14af8:	e0bff917 	ldw	r2,-28(fp)
   14afc:	1080020b 	ldhu	r2,8(r2)
   14b00:	10bfffcc 	andi	r2,r2,65535
   14b04:	1004d23a 	srli	r2,r2,8
   14b08:	1007883a 	mov	r3,r2
   14b0c:	e0bff917 	ldw	r2,-28(fp)
   14b10:	1080020b 	ldhu	r2,8(r2)
   14b14:	10bfffcc 	andi	r2,r2,65535
   14b18:	1004923a 	slli	r2,r2,8
   14b1c:	1884b03a 	or	r2,r3,r2
   14b20:	1007883a 	mov	r3,r2
   14b24:	e0bffb17 	ldw	r2,-20(fp)
   14b28:	10c0010d 	sth	r3,4(r2)
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
   14b2c:	e0bffc17 	ldw	r2,-16(fp)
   14b30:	10800403 	ldbu	r2,16(r2)
   14b34:	10803fcc 	andi	r2,r2,255
   14b38:	1080004c 	andi	r2,r2,1
   14b3c:	1000121e 	bne	r2,zero,14b88 <udp_sendto_if+0x24c>
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
   14b40:	e0bff917 	ldw	r2,-28(fp)
   14b44:	1080020b 	ldhu	r2,8(r2)
   14b48:	10bfffcc 	andi	r2,r2,65535
   14b4c:	d8800015 	stw	r2,0(sp)
   14b50:	e13ff917 	ldw	r4,-28(fp)
   14b54:	e17ff817 	ldw	r5,-32(fp)
   14b58:	e1bffe17 	ldw	r6,-8(fp)
   14b5c:	01c00444 	movi	r7,17
   14b60:	0005e400 	call	5e40 <inet_chksum_pseudo>
   14b64:	e0fffb17 	ldw	r3,-20(fp)
   14b68:	1880018d 	sth	r2,6(r3)
      /* chksum zero must become 0xffff, as zero means 'no checksum' */
      if (udphdr->chksum == 0x0000) udphdr->chksum = 0xffff;
   14b6c:	e0bffb17 	ldw	r2,-20(fp)
   14b70:	1080018b 	ldhu	r2,6(r2)
   14b74:	10bfffcc 	andi	r2,r2,65535
   14b78:	1000031e 	bne	r2,zero,14b88 <udp_sendto_if+0x24c>
   14b7c:	e0bffb17 	ldw	r2,-20(fp)
   14b80:	00ffffc4 	movi	r3,-1
   14b84:	10c0018d 	sth	r3,6(r2)
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
#if LWIP_NETIF_HWADDRHINT
    netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);
   14b88:	e0bffc17 	ldw	r2,-16(fp)
   14b8c:	108002c3 	ldbu	r2,11(r2)
   14b90:	10803fcc 	andi	r2,r2,255
   14b94:	e0fffc17 	ldw	r3,-16(fp)
   14b98:	18c00283 	ldbu	r3,10(r3)
   14b9c:	18c03fcc 	andi	r3,r3,255
   14ba0:	d8c00015 	stw	r3,0(sp)
   14ba4:	00c00444 	movi	r3,17
   14ba8:	d8c00115 	stw	r3,4(sp)
   14bac:	e0c00217 	ldw	r3,8(fp)
   14bb0:	d8c00215 	stw	r3,8(sp)
   14bb4:	e13ff917 	ldw	r4,-28(fp)
   14bb8:	e17ff817 	ldw	r5,-32(fp)
   14bbc:	e1bffe17 	ldw	r6,-8(fp)
   14bc0:	100f883a 	mov	r7,r2
   14bc4:	000687c0 	call	687c <ip_output_if>
   14bc8:	e0bffa05 	stb	r2,-24(fp)
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
   14bcc:	e0fff917 	ldw	r3,-28(fp)
   14bd0:	e0bffd17 	ldw	r2,-12(fp)
   14bd4:	18800326 	beq	r3,r2,14be4 <udp_sendto_if+0x2a8>
    /* free the header pbuf */
    pbuf_free(q);
   14bd8:	e13ff917 	ldw	r4,-28(fp)
   14bdc:	000a1880 	call	a188 <pbuf_free>
    q = NULL;
   14be0:	e03ff915 	stw	zero,-28(fp)
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
   14be4:	00800134 	movhi	r2,4
   14be8:	10916104 	addi	r2,r2,17796
   14bec:	10801e0b 	ldhu	r2,120(r2)
   14bf0:	10800044 	addi	r2,r2,1
   14bf4:	1007883a 	mov	r3,r2
   14bf8:	00800134 	movhi	r2,4
   14bfc:	10916104 	addi	r2,r2,17796
   14c00:	10c01e0d 	sth	r3,120(r2)
  return err;
   14c04:	e0bffa03 	ldbu	r2,-24(fp)
}
   14c08:	e037883a 	mov	sp,fp
   14c0c:	dfc00117 	ldw	ra,4(sp)
   14c10:	df000017 	ldw	fp,0(sp)
   14c14:	dec00204 	addi	sp,sp,8
   14c18:	f800283a 	ret

00014c1c <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
   14c1c:	defff904 	addi	sp,sp,-28
   14c20:	dfc00615 	stw	ra,24(sp)
   14c24:	df000515 	stw	fp,20(sp)
   14c28:	df000504 	addi	fp,sp,20
   14c2c:	e13ffd15 	stw	r4,-12(fp)
   14c30:	e17ffe15 	stw	r5,-8(fp)
   14c34:	3005883a 	mov	r2,r6
   14c38:	e0bfff0d 	sth	r2,-4(fp)

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
   14c3c:	e03ffc05 	stb	zero,-16(fp)
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
   14c40:	d0a8e417 	ldw	r2,-23664(gp)
   14c44:	e0bffb15 	stw	r2,-20(fp)
   14c48:	00001306 	br	14c98 <udp_bind+0x7c>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
   14c4c:	e0fffd17 	ldw	r3,-12(fp)
   14c50:	e0bffb17 	ldw	r2,-20(fp)
   14c54:	18800d1e 	bne	r3,r2,14c8c <udp_bind+0x70>
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
   14c58:	e0bffc03 	ldbu	r2,-16(fp)
   14c5c:	10000926 	beq	r2,zero,14c84 <udp_bind+0x68>
   14c60:	010000f4 	movhi	r4,3
   14c64:	213f3104 	addi	r4,r4,-828
   14c68:	014000f4 	movhi	r5,3
   14c6c:	297f5604 	addi	r5,r5,-680
   14c70:	01809484 	movi	r6,594
   14c74:	01c000f4 	movhi	r7,3
   14c78:	39ff4004 	addi	r7,r7,-768
   14c7c:	00170680 	call	17068 <printf>
   14c80:	003fff06 	br	14c80 <udp_bind+0x64>
      /* pcb already in list, just rebind */
      rebind = 1;
   14c84:	00800044 	movi	r2,1
   14c88:	e0bffc05 	stb	r2,-16(fp)
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
   14c8c:	e0bffb17 	ldw	r2,-20(fp)
   14c90:	10800317 	ldw	r2,12(r2)
   14c94:	e0bffb15 	stw	r2,-20(fp)
   14c98:	e0bffb17 	ldw	r2,-20(fp)
   14c9c:	103feb1e 	bne	r2,zero,14c4c <udp_bind+0x30>
        return ERR_USE;
      }
#endif
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
   14ca0:	e0bffe17 	ldw	r2,-8(fp)
   14ca4:	10000626 	beq	r2,zero,14cc0 <udp_bind+0xa4>
   14ca8:	e0bffe17 	ldw	r2,-8(fp)
   14cac:	10c0000b 	ldhu	r3,0(r2)
   14cb0:	1080008b 	ldhu	r2,2(r2)
   14cb4:	1004943a 	slli	r2,r2,16
   14cb8:	10c4b03a 	or	r2,r2,r3
   14cbc:	00000106 	br	14cc4 <udp_bind+0xa8>
   14cc0:	0005883a 	mov	r2,zero
   14cc4:	e0fffd17 	ldw	r3,-12(fp)
   14cc8:	18800015 	stw	r2,0(r3)

  /* no port specified? */
  if (port == 0) {
   14ccc:	e0bfff0b 	ldhu	r2,-4(fp)
   14cd0:	10001c1e 	bne	r2,zero,14d44 <udp_bind+0x128>
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
   14cd4:	00840004 	movi	r2,4096
   14cd8:	e0bfff0d 	sth	r2,-4(fp)
    ipcb = udp_pcbs;
   14cdc:	d0a8e417 	ldw	r2,-23664(gp)
   14ce0:	e0bffb15 	stw	r2,-20(fp)
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
   14ce4:	00000e06 	br	14d20 <udp_bind+0x104>
      if (ipcb->local_port == port) {
   14ce8:	e0bffb17 	ldw	r2,-20(fp)
   14cec:	1080048b 	ldhu	r2,18(r2)
   14cf0:	10ffffcc 	andi	r3,r2,65535
   14cf4:	e0bfff0b 	ldhu	r2,-4(fp)
   14cf8:	1880061e 	bne	r3,r2,14d14 <udp_bind+0xf8>
        /* port is already used by another udp_pcb */
        port++;
   14cfc:	e0bfff0b 	ldhu	r2,-4(fp)
   14d00:	10800044 	addi	r2,r2,1
   14d04:	e0bfff0d 	sth	r2,-4(fp)
        /* restart scanning all udp pcbs */
        ipcb = udp_pcbs;
   14d08:	d0a8e417 	ldw	r2,-23664(gp)
   14d0c:	e0bffb15 	stw	r2,-20(fp)
   14d10:	00000306 	br	14d20 <udp_bind+0x104>
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
   14d14:	e0bffb17 	ldw	r2,-20(fp)
   14d18:	10800317 	ldw	r2,12(r2)
   14d1c:	e0bffb15 	stw	r2,-20(fp)
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
   14d20:	e0bffb17 	ldw	r2,-20(fp)
   14d24:	10000326 	beq	r2,zero,14d34 <udp_bind+0x118>
   14d28:	e0bfff0b 	ldhu	r2,-4(fp)
   14d2c:	109fffd8 	cmpnei	r2,r2,32767
   14d30:	103fed1e 	bne	r2,zero,14ce8 <udp_bind+0xcc>
        ipcb = udp_pcbs;
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
    }
    if (ipcb != NULL) {
   14d34:	e0bffb17 	ldw	r2,-20(fp)
   14d38:	10000226 	beq	r2,zero,14d44 <udp_bind+0x128>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
   14d3c:	00bffd44 	movi	r2,-11
   14d40:	00000b06 	br	14d70 <udp_bind+0x154>
    }
  }
  pcb->local_port = port;
   14d44:	e0bffd17 	ldw	r2,-12(fp)
   14d48:	e0ffff0b 	ldhu	r3,-4(fp)
   14d4c:	10c0048d 	sth	r3,18(r2)
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
   14d50:	e0bffc03 	ldbu	r2,-16(fp)
   14d54:	1000051e 	bne	r2,zero,14d6c <udp_bind+0x150>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
   14d58:	d0e8e417 	ldw	r3,-23664(gp)
   14d5c:	e0bffd17 	ldw	r2,-12(fp)
   14d60:	10c00315 	stw	r3,12(r2)
    udp_pcbs = pcb;
   14d64:	e0bffd17 	ldw	r2,-12(fp)
   14d68:	d0a8e415 	stw	r2,-23664(gp)
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               (u16_t)((ntohl(pcb->local_ip.addr) >> 24) & 0xff),
               (u16_t)((ntohl(pcb->local_ip.addr) >> 16) & 0xff),
               (u16_t)((ntohl(pcb->local_ip.addr) >> 8) & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
   14d6c:	0005883a 	mov	r2,zero
}
   14d70:	e037883a 	mov	sp,fp
   14d74:	dfc00117 	ldw	ra,4(sp)
   14d78:	df000017 	ldw	fp,0(sp)
   14d7c:	dec00204 	addi	sp,sp,8
   14d80:	f800283a 	ret

00014d84 <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
   14d84:	defff904 	addi	sp,sp,-28
   14d88:	dfc00615 	stw	ra,24(sp)
   14d8c:	df000515 	stw	fp,20(sp)
   14d90:	df000504 	addi	fp,sp,20
   14d94:	e13ffd15 	stw	r4,-12(fp)
   14d98:	e17ffe15 	stw	r5,-8(fp)
   14d9c:	3005883a 	mov	r2,r6
   14da0:	e0bfff0d 	sth	r2,-4(fp)
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
   14da4:	e0bffd17 	ldw	r2,-12(fp)
   14da8:	1080048b 	ldhu	r2,18(r2)
   14dac:	10bfffcc 	andi	r2,r2,65535
   14db0:	10000d1e 	bne	r2,zero,14de8 <udp_connect+0x64>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
   14db4:	e0fffd17 	ldw	r3,-12(fp)
   14db8:	e0bffd17 	ldw	r2,-12(fp)
   14dbc:	1080048b 	ldhu	r2,18(r2)
   14dc0:	10bfffcc 	andi	r2,r2,65535
   14dc4:	e13ffd17 	ldw	r4,-12(fp)
   14dc8:	180b883a 	mov	r5,r3
   14dcc:	100d883a 	mov	r6,r2
   14dd0:	0014c1c0 	call	14c1c <udp_bind>
   14dd4:	e0bffc05 	stb	r2,-16(fp)
    if (err != ERR_OK)
   14dd8:	e0bffc07 	ldb	r2,-16(fp)
   14ddc:	10000226 	beq	r2,zero,14de8 <udp_connect+0x64>
      return err;
   14de0:	e0bffc03 	ldbu	r2,-16(fp)
   14de4:	00002706 	br	14e84 <udp_connect+0x100>
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
   14de8:	e0bffe17 	ldw	r2,-8(fp)
   14dec:	10000626 	beq	r2,zero,14e08 <udp_connect+0x84>
   14df0:	e0bffe17 	ldw	r2,-8(fp)
   14df4:	10c0000b 	ldhu	r3,0(r2)
   14df8:	1080008b 	ldhu	r2,2(r2)
   14dfc:	1004943a 	slli	r2,r2,16
   14e00:	10c4b03a 	or	r2,r2,r3
   14e04:	00000106 	br	14e0c <udp_connect+0x88>
   14e08:	0005883a 	mov	r2,zero
   14e0c:	e0fffd17 	ldw	r3,-12(fp)
   14e10:	18800115 	stw	r2,4(r3)
  pcb->remote_port = port;
   14e14:	e0bffd17 	ldw	r2,-12(fp)
   14e18:	e0ffff0b 	ldhu	r3,-4(fp)
   14e1c:	10c0050d 	sth	r3,20(r2)
  pcb->flags |= UDP_FLAGS_CONNECTED;
   14e20:	e0bffd17 	ldw	r2,-12(fp)
   14e24:	10800403 	ldbu	r2,16(r2)
   14e28:	10800114 	ori	r2,r2,4
   14e2c:	1007883a 	mov	r3,r2
   14e30:	e0bffd17 	ldw	r2,-12(fp)
   14e34:	10c00405 	stb	r3,16(r2)
               (u16_t)((ntohl(pcb->remote_ip.addr) >> 16) & 0xff),
               (u16_t)((ntohl(pcb->remote_ip.addr) >> 8) & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
   14e38:	d0a8e417 	ldw	r2,-23664(gp)
   14e3c:	e0bffb15 	stw	r2,-20(fp)
   14e40:	00000806 	br	14e64 <udp_connect+0xe0>
    if (pcb == ipcb) {
   14e44:	e0fffd17 	ldw	r3,-12(fp)
   14e48:	e0bffb17 	ldw	r2,-20(fp)
   14e4c:	1880021e 	bne	r3,r2,14e58 <udp_connect+0xd4>
      /* already on the list, just return */
      return ERR_OK;
   14e50:	0005883a 	mov	r2,zero
   14e54:	00000b06 	br	14e84 <udp_connect+0x100>
               (u16_t)((ntohl(pcb->remote_ip.addr) >> 16) & 0xff),
               (u16_t)((ntohl(pcb->remote_ip.addr) >> 8) & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
   14e58:	e0bffb17 	ldw	r2,-20(fp)
   14e5c:	10800317 	ldw	r2,12(r2)
   14e60:	e0bffb15 	stw	r2,-20(fp)
   14e64:	e0bffb17 	ldw	r2,-20(fp)
   14e68:	103ff61e 	bne	r2,zero,14e44 <udp_connect+0xc0>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
   14e6c:	d0e8e417 	ldw	r3,-23664(gp)
   14e70:	e0bffd17 	ldw	r2,-12(fp)
   14e74:	10c00315 	stw	r3,12(r2)
  udp_pcbs = pcb;
   14e78:	e0bffd17 	ldw	r2,-12(fp)
   14e7c:	d0a8e415 	stw	r2,-23664(gp)
  return ERR_OK;
   14e80:	0005883a 	mov	r2,zero
}
   14e84:	e037883a 	mov	sp,fp
   14e88:	dfc00117 	ldw	ra,4(sp)
   14e8c:	df000017 	ldw	fp,0(sp)
   14e90:	dec00204 	addi	sp,sp,8
   14e94:	f800283a 	ret

00014e98 <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
   14e98:	defffe04 	addi	sp,sp,-8
   14e9c:	df000115 	stw	fp,4(sp)
   14ea0:	df000104 	addi	fp,sp,4
   14ea4:	e13fff15 	stw	r4,-4(fp)
  /* reset remote address association */
  ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
   14ea8:	008000f4 	movhi	r2,3
   14eac:	1090ed04 	addi	r2,r2,17332
   14eb0:	10c0000b 	ldhu	r3,0(r2)
   14eb4:	1080008b 	ldhu	r2,2(r2)
   14eb8:	1004943a 	slli	r2,r2,16
   14ebc:	10c4b03a 	or	r2,r2,r3
   14ec0:	1007883a 	mov	r3,r2
   14ec4:	e0bfff17 	ldw	r2,-4(fp)
   14ec8:	10c00115 	stw	r3,4(r2)
  pcb->remote_port = 0;
   14ecc:	e0bfff17 	ldw	r2,-4(fp)
   14ed0:	1000050d 	sth	zero,20(r2)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
   14ed4:	e0bfff17 	ldw	r2,-4(fp)
   14ed8:	10c00403 	ldbu	r3,16(r2)
   14edc:	00bffec4 	movi	r2,-5
   14ee0:	1884703a 	and	r2,r3,r2
   14ee4:	1007883a 	mov	r3,r2
   14ee8:	e0bfff17 	ldw	r2,-4(fp)
   14eec:	10c00405 	stb	r3,16(r2)
}
   14ef0:	e037883a 	mov	sp,fp
   14ef4:	df000017 	ldw	fp,0(sp)
   14ef8:	dec00104 	addi	sp,sp,4
   14efc:	f800283a 	ret

00014f00 <udp_recv>:
void
udp_recv(struct udp_pcb *pcb,
         void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
                       struct ip_addr *addr, u16_t port),
         void *recv_arg)
{
   14f00:	defffc04 	addi	sp,sp,-16
   14f04:	df000315 	stw	fp,12(sp)
   14f08:	df000304 	addi	fp,sp,12
   14f0c:	e13ffd15 	stw	r4,-12(fp)
   14f10:	e17ffe15 	stw	r5,-8(fp)
   14f14:	e1bfff15 	stw	r6,-4(fp)
  /* remember recv() callback and user data */
  pcb->recv = recv;
   14f18:	e0bffd17 	ldw	r2,-12(fp)
   14f1c:	e0fffe17 	ldw	r3,-8(fp)
   14f20:	10c00615 	stw	r3,24(r2)
  pcb->recv_arg = recv_arg;
   14f24:	e0bffd17 	ldw	r2,-12(fp)
   14f28:	e0ffff17 	ldw	r3,-4(fp)
   14f2c:	10c00715 	stw	r3,28(r2)
}
   14f30:	e037883a 	mov	sp,fp
   14f34:	df000017 	ldw	fp,0(sp)
   14f38:	dec00104 	addi	sp,sp,4
   14f3c:	f800283a 	ret

00014f40 <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
   14f40:	defffc04 	addi	sp,sp,-16
   14f44:	dfc00315 	stw	ra,12(sp)
   14f48:	df000215 	stw	fp,8(sp)
   14f4c:	df000204 	addi	fp,sp,8
   14f50:	e13fff15 	stw	r4,-4(fp)
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
   14f54:	d0e8e417 	ldw	r3,-23664(gp)
   14f58:	e0bfff17 	ldw	r2,-4(fp)
   14f5c:	1880041e 	bne	r3,r2,14f70 <udp_remove+0x30>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
   14f60:	d0a8e417 	ldw	r2,-23664(gp)
   14f64:	10800317 	ldw	r2,12(r2)
   14f68:	d0a8e415 	stw	r2,-23664(gp)
   14f6c:	00001306 	br	14fbc <udp_remove+0x7c>
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
   14f70:	d0a8e417 	ldw	r2,-23664(gp)
   14f74:	e0bffe15 	stw	r2,-8(fp)
   14f78:	00000e06 	br	14fb4 <udp_remove+0x74>
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
   14f7c:	e0bffe17 	ldw	r2,-8(fp)
   14f80:	10800317 	ldw	r2,12(r2)
   14f84:	10000826 	beq	r2,zero,14fa8 <udp_remove+0x68>
   14f88:	e0bffe17 	ldw	r2,-8(fp)
   14f8c:	10c00317 	ldw	r3,12(r2)
   14f90:	e0bfff17 	ldw	r2,-4(fp)
   14f94:	1880041e 	bne	r3,r2,14fa8 <udp_remove+0x68>
        /* remove pcb from list */
        pcb2->next = pcb->next;
   14f98:	e0bfff17 	ldw	r2,-4(fp)
   14f9c:	10c00317 	ldw	r3,12(r2)
   14fa0:	e0bffe17 	ldw	r2,-8(fp)
   14fa4:	10c00315 	stw	r3,12(r2)
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
   14fa8:	e0bffe17 	ldw	r2,-8(fp)
   14fac:	10800317 	ldw	r2,12(r2)
   14fb0:	e0bffe15 	stw	r2,-8(fp)
   14fb4:	e0bffe17 	ldw	r2,-8(fp)
   14fb8:	103ff01e 	bne	r2,zero,14f7c <udp_remove+0x3c>
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  memp_free(MEMP_UDP_PCB, pcb);
   14fbc:	01000044 	movi	r4,1
   14fc0:	e17fff17 	ldw	r5,-4(fp)
   14fc4:	00090e80 	call	90e8 <memp_free>
}
   14fc8:	e037883a 	mov	sp,fp
   14fcc:	dfc00117 	ldw	ra,4(sp)
   14fd0:	df000017 	ldw	fp,0(sp)
   14fd4:	dec00204 	addi	sp,sp,8
   14fd8:	f800283a 	ret

00014fdc <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
   14fdc:	defffd04 	addi	sp,sp,-12
   14fe0:	dfc00215 	stw	ra,8(sp)
   14fe4:	df000115 	stw	fp,4(sp)
   14fe8:	df000104 	addi	fp,sp,4
  struct udp_pcb *pcb;
  pcb = memp_malloc(MEMP_UDP_PCB);
   14fec:	01000044 	movi	r4,1
   14ff0:	0008f0c0 	call	8f0c <memp_malloc>
   14ff4:	e0bfff15 	stw	r2,-4(fp)
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
   14ff8:	e0bfff17 	ldw	r2,-4(fp)
   14ffc:	10000726 	beq	r2,zero,1501c <udp_new+0x40>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
   15000:	e13fff17 	ldw	r4,-4(fp)
   15004:	000b883a 	mov	r5,zero
   15008:	01800804 	movi	r6,32
   1500c:	0016f600 	call	16f60 <memset>
    pcb->ttl = UDP_TTL;
   15010:	e0bfff17 	ldw	r2,-4(fp)
   15014:	00ffffc4 	movi	r3,-1
   15018:	10c002c5 	stb	r3,11(r2)
  }
  return pcb;
   1501c:	e0bfff17 	ldw	r2,-4(fp)
}
   15020:	e037883a 	mov	sp,fp
   15024:	dfc00117 	ldw	ra,4(sp)
   15028:	df000017 	ldw	fp,0(sp)
   1502c:	dec00204 	addi	sp,sp,8
   15030:	f800283a 	ret

00015034 <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
   15034:	defffc04 	addi	sp,sp,-16
   15038:	dfc00315 	stw	ra,12(sp)
   1503c:	df000215 	stw	fp,8(sp)
   15040:	df000204 	addi	fp,sp,8
   15044:	e13fff15 	stw	r4,-4(fp)
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
   15048:	e0bfff17 	ldw	r2,-4(fp)
   1504c:	1000091e 	bne	r2,zero,15074 <free_etharp_q+0x40>
   15050:	010000f4 	movhi	r4,3
   15054:	213f5904 	addi	r4,r4,-668
   15058:	014000f4 	movhi	r5,3
   1505c:	297f6304 	addi	r5,r5,-628
   15060:	01802484 	movi	r6,146
   15064:	01c000f4 	movhi	r7,3
   15068:	39ff6604 	addi	r7,r7,-616
   1506c:	00170680 	call	17068 <printf>
   15070:	003fff06 	br	15070 <free_etharp_q+0x3c>
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
   15074:	e0bfff17 	ldw	r2,-4(fp)
   15078:	10800117 	ldw	r2,4(r2)
   1507c:	1000211e 	bne	r2,zero,15104 <free_etharp_q+0xd0>
   15080:	010000f4 	movhi	r4,3
   15084:	213f5904 	addi	r4,r4,-668
   15088:	014000f4 	movhi	r5,3
   1508c:	297f6c04 	addi	r5,r5,-592
   15090:	018024c4 	movi	r6,147
   15094:	01c000f4 	movhi	r7,3
   15098:	39ff6604 	addi	r7,r7,-616
   1509c:	00170680 	call	17068 <printf>
   150a0:	003fff06 	br	150a0 <free_etharp_q+0x6c>
  while (q) {
    r = q;
   150a4:	e0bfff17 	ldw	r2,-4(fp)
   150a8:	e0bffe15 	stw	r2,-8(fp)
    q = q->next;
   150ac:	e0bfff17 	ldw	r2,-4(fp)
   150b0:	10800017 	ldw	r2,0(r2)
   150b4:	e0bfff15 	stw	r2,-4(fp)
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
   150b8:	e0bffe17 	ldw	r2,-8(fp)
   150bc:	10800117 	ldw	r2,4(r2)
   150c0:	1000091e 	bne	r2,zero,150e8 <free_etharp_q+0xb4>
   150c4:	010000f4 	movhi	r4,3
   150c8:	213f5904 	addi	r4,r4,-668
   150cc:	014000f4 	movhi	r5,3
   150d0:	297f7004 	addi	r5,r5,-576
   150d4:	018025c4 	movi	r6,151
   150d8:	01c000f4 	movhi	r7,3
   150dc:	39ff6604 	addi	r7,r7,-616
   150e0:	00170680 	call	17068 <printf>
   150e4:	003fff06 	br	150e4 <free_etharp_q+0xb0>
    pbuf_free(r->p);
   150e8:	e0bffe17 	ldw	r2,-8(fp)
   150ec:	10800117 	ldw	r2,4(r2)
   150f0:	1009883a 	mov	r4,r2
   150f4:	000a1880 	call	a188 <pbuf_free>
    memp_free(MEMP_ARP_QUEUE, r);
   150f8:	01000184 	movi	r4,6
   150fc:	e17ffe17 	ldw	r5,-8(fp)
   15100:	00090e80 	call	90e8 <memp_free>
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
   15104:	e0bfff17 	ldw	r2,-4(fp)
   15108:	103fe61e 	bne	r2,zero,150a4 <free_etharp_q+0x70>
    q = q->next;
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
    memp_free(MEMP_ARP_QUEUE, r);
  }
}
   1510c:	e037883a 	mov	sp,fp
   15110:	dfc00117 	ldw	ra,4(sp)
   15114:	df000017 	ldw	fp,0(sp)
   15118:	dec00204 	addi	sp,sp,8
   1511c:	f800283a 	ret

00015120 <etharp_tmr>:
 * This function should be called every ETHARP_TMR_INTERVAL microseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
   15120:	defffd04 	addi	sp,sp,-12
   15124:	dfc00215 	stw	ra,8(sp)
   15128:	df000115 	stw	fp,4(sp)
   1512c:	df000104 	addi	fp,sp,4
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
   15130:	e03fff05 	stb	zero,-4(fp)
   15134:	00005306 	br	15284 <etharp_tmr+0x164>
    arp_table[i].ctime++;
   15138:	e0bfff03 	ldbu	r2,-4(fp)
   1513c:	01000134 	movhi	r4,4
   15140:	2110cb04 	addi	r4,r4,17196
   15144:	10c00724 	muli	r3,r2,28
   15148:	20c7883a 	add	r3,r4,r3
   1514c:	18c00504 	addi	r3,r3,20
   15150:	18c00003 	ldbu	r3,0(r3)
   15154:	18c00044 	addi	r3,r3,1
   15158:	01000134 	movhi	r4,4
   1515c:	2110cb04 	addi	r4,r4,17196
   15160:	10800724 	muli	r2,r2,28
   15164:	2085883a 	add	r2,r4,r2
   15168:	10800504 	addi	r2,r2,20
   1516c:	10c00005 	stb	r3,0(r2)
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
   15170:	e0bfff03 	ldbu	r2,-4(fp)
   15174:	00c00134 	movhi	r3,4
   15178:	18d0cb04 	addi	r3,r3,17196
   1517c:	10800724 	muli	r2,r2,28
   15180:	1885883a 	add	r2,r3,r2
   15184:	10800404 	addi	r2,r2,16
   15188:	10800017 	ldw	r2,0(r2)
   1518c:	10800098 	cmpnei	r2,r2,2
   15190:	10000a1e 	bne	r2,zero,151bc <etharp_tmr+0x9c>
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
   15194:	e0bfff03 	ldbu	r2,-4(fp)
   15198:	00c00134 	movhi	r3,4
   1519c:	18d0cb04 	addi	r3,r3,17196
   151a0:	10800724 	muli	r2,r2,28
   151a4:	1885883a 	add	r2,r3,r2
   151a8:	10800504 	addi	r2,r2,20
   151ac:	10800003 	ldbu	r2,0(r2)

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
   151b0:	10803fcc 	andi	r2,r2,255
   151b4:	10803c28 	cmpgeui	r2,r2,240
   151b8:	1000131e 	bne	r2,zero,15208 <etharp_tmr+0xe8>
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
   151bc:	e0bfff03 	ldbu	r2,-4(fp)
   151c0:	00c00134 	movhi	r3,4
   151c4:	18d0cb04 	addi	r3,r3,17196
   151c8:	10800724 	muli	r2,r2,28
   151cc:	1885883a 	add	r2,r3,r2
   151d0:	10800404 	addi	r2,r2,16
   151d4:	10800017 	ldw	r2,0(r2)
  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
   151d8:	10800058 	cmpnei	r2,r2,1
   151dc:	1000261e 	bne	r2,zero,15278 <etharp_tmr+0x158>
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
         (arp_table[i].ctime >= ARP_MAXPENDING))) {
   151e0:	e0bfff03 	ldbu	r2,-4(fp)
   151e4:	00c00134 	movhi	r3,4
   151e8:	18d0cb04 	addi	r3,r3,17196
   151ec:	10800724 	muli	r2,r2,28
   151f0:	1885883a 	add	r2,r3,r2
   151f4:	10800504 	addi	r2,r2,20
   151f8:	10800003 	ldbu	r2,0(r2)
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
   151fc:	10803fcc 	andi	r2,r2,255
   15200:	108000b0 	cmpltui	r2,r2,2
   15204:	10001c1e 	bne	r2,zero,15278 <etharp_tmr+0x158>
      /* clean up entries that have just been expired */
      /* remove from SNMP ARP index tree */
      snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
#if ARP_QUEUEING
      /* and empty packet queue */
      if (arp_table[i].q != NULL) {
   15208:	e0bfff03 	ldbu	r2,-4(fp)
   1520c:	00c00134 	movhi	r3,4
   15210:	18d0cb04 	addi	r3,r3,17196
   15214:	10800724 	muli	r2,r2,28
   15218:	1885883a 	add	r2,r3,r2
   1521c:	10800017 	ldw	r2,0(r2)
   15220:	10000e26 	beq	r2,zero,1525c <etharp_tmr+0x13c>
        /* remove all queued packets */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
        free_etharp_q(arp_table[i].q);
   15224:	e0bfff03 	ldbu	r2,-4(fp)
   15228:	00c00134 	movhi	r3,4
   1522c:	18d0cb04 	addi	r3,r3,17196
   15230:	10800724 	muli	r2,r2,28
   15234:	1885883a 	add	r2,r3,r2
   15238:	10800017 	ldw	r2,0(r2)
   1523c:	1009883a 	mov	r4,r2
   15240:	00150340 	call	15034 <free_etharp_q>
        arp_table[i].q = NULL;
   15244:	e0bfff03 	ldbu	r2,-4(fp)
   15248:	00c00134 	movhi	r3,4
   1524c:	18d0cb04 	addi	r3,r3,17196
   15250:	10800724 	muli	r2,r2,28
   15254:	1885883a 	add	r2,r3,r2
   15258:	10000015 	stw	zero,0(r2)
      }
#endif
      /* recycle entry for re-use */      
      arp_table[i].state = ETHARP_STATE_EMPTY;
   1525c:	e0bfff03 	ldbu	r2,-4(fp)
   15260:	00c00134 	movhi	r3,4
   15264:	18d0cb04 	addi	r3,r3,17196
   15268:	10800724 	muli	r2,r2,28
   1526c:	1885883a 	add	r2,r3,r2
   15270:	10800404 	addi	r2,r2,16
   15274:	10000015 	stw	zero,0(r2)
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
   15278:	e0bfff03 	ldbu	r2,-4(fp)
   1527c:	10800044 	addi	r2,r2,1
   15280:	e0bfff05 	stb	r2,-4(fp)
   15284:	e0bfff03 	ldbu	r2,-4(fp)
   15288:	108002b0 	cmpltui	r2,r2,10
   1528c:	103faa1e 	bne	r2,zero,15138 <etharp_tmr+0x18>
    if (arp_table[i].state == ETHARP_STATE_PENDING) {
        /* resend an ARP query here? */
    }
#endif
  }
}
   15290:	e037883a 	mov	sp,fp
   15294:	dfc00117 	ldw	ra,4(sp)
   15298:	df000017 	ldw	fp,0(sp)
   1529c:	dec00204 	addi	sp,sp,8
   152a0:	f800283a 	ret

000152a4 <find_entry>:
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
   152a4:	defffa04 	addi	sp,sp,-24
   152a8:	dfc00515 	stw	ra,20(sp)
   152ac:	df000415 	stw	fp,16(sp)
   152b0:	df000404 	addi	fp,sp,16
   152b4:	e13ffe15 	stw	r4,-8(fp)
   152b8:	2805883a 	mov	r2,r5
   152bc:	e0bfff05 	stb	r2,-4(fp)
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
   152c0:	00800284 	movi	r2,10
   152c4:	e0bffc05 	stb	r2,-16(fp)
   152c8:	00800284 	movi	r2,10
   152cc:	e0bffc45 	stb	r2,-15(fp)
  s8_t empty = ARP_TABLE_SIZE;
   152d0:	00800284 	movi	r2,10
   152d4:	e0bffc85 	stb	r2,-14(fp)
  u8_t i = 0, age_pending = 0, age_stable = 0;
   152d8:	e03ffcc5 	stb	zero,-13(fp)
   152dc:	e03ffd05 	stb	zero,-12(fp)
   152e0:	e03ffd45 	stb	zero,-11(fp)
#if ARP_QUEUEING
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
   152e4:	00800284 	movi	r2,10
   152e8:	e0bffd85 	stb	r2,-10(fp)
  /* its age */
  u8_t age_queue = 0;
   152ec:	e03ffdc5 	stb	zero,-9(fp)
#endif

  /* First, test if the last call to this function asked for the
   * same address. If so, we're really fast! */
  if (ipaddr) {
   152f0:	e0bffe17 	ldw	r2,-8(fp)
   152f4:	10002326 	beq	r2,zero,15384 <find_entry+0xe0>
          return per_pcb_cache;
        }
      }
    }
#else /* #if LWIP_NETIF_HWADDRHINT */
    if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
   152f8:	d0a8e503 	ldbu	r2,-23660(gp)
   152fc:	10803fcc 	andi	r2,r2,255
   15300:	00c00134 	movhi	r3,4
   15304:	18d0cb04 	addi	r3,r3,17196
   15308:	10800724 	muli	r2,r2,28
   1530c:	1885883a 	add	r2,r3,r2
   15310:	10800404 	addi	r2,r2,16
   15314:	10800017 	ldw	r2,0(r2)
   15318:	10800098 	cmpnei	r2,r2,2
   1531c:	1000191e 	bne	r2,zero,15384 <find_entry+0xe0>
      /* the cached entry is stable */
      if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
   15320:	e0bffe17 	ldw	r2,-8(fp)
   15324:	10c0000b 	ldhu	r3,0(r2)
   15328:	1080008b 	ldhu	r2,2(r2)
   1532c:	1004943a 	slli	r2,r2,16
   15330:	10c4b03a 	or	r2,r2,r3
   15334:	1007883a 	mov	r3,r2
   15338:	d0a8e503 	ldbu	r2,-23660(gp)
   1533c:	10803fcc 	andi	r2,r2,255
   15340:	01000134 	movhi	r4,4
   15344:	2110cb04 	addi	r4,r4,17196
   15348:	10800724 	muli	r2,r2,28
   1534c:	2085883a 	add	r2,r4,r2
   15350:	10800104 	addi	r2,r2,4
   15354:	10800017 	ldw	r2,0(r2)
   15358:	18800a1e 	bne	r3,r2,15384 <find_entry+0xe0>
        /* cached entry was the right one! */
        ETHARP_STATS_INC(etharp.cachehit);
   1535c:	00800134 	movhi	r2,4
   15360:	10916104 	addi	r2,r2,17796
   15364:	10800b8b 	ldhu	r2,46(r2)
   15368:	10800044 	addi	r2,r2,1
   1536c:	1007883a 	mov	r3,r2
   15370:	00800134 	movhi	r2,4
   15374:	10916104 	addi	r2,r2,17796
   15378:	10c00b8d 	sth	r3,46(r2)
        return etharp_cached_entry;
   1537c:	d0a8e503 	ldbu	r2,-23660(gp)
   15380:	00010606 	br	1579c <find_entry+0x4f8>
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
   15384:	e03ffcc5 	stb	zero,-13(fp)
   15388:	00009006 	br	155cc <find_entry+0x328>
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
   1538c:	e0bffc87 	ldb	r2,-14(fp)
   15390:	10800298 	cmpnei	r2,r2,10
   15394:	10000b1e 	bne	r2,zero,153c4 <find_entry+0x120>
   15398:	e0bffcc3 	ldbu	r2,-13(fp)
   1539c:	00c00134 	movhi	r3,4
   153a0:	18d0cb04 	addi	r3,r3,17196
   153a4:	10800724 	muli	r2,r2,28
   153a8:	1885883a 	add	r2,r3,r2
   153ac:	10800404 	addi	r2,r2,16
   153b0:	10800017 	ldw	r2,0(r2)
   153b4:	1000031e 	bne	r2,zero,153c4 <find_entry+0x120>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
   153b8:	e0bffcc3 	ldbu	r2,-13(fp)
   153bc:	e0bffc85 	stb	r2,-14(fp)
   153c0:	00007f06 	br	155c0 <find_entry+0x31c>
    }
    /* pending entry? */
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
   153c4:	e0bffcc3 	ldbu	r2,-13(fp)
   153c8:	00c00134 	movhi	r3,4
   153cc:	18d0cb04 	addi	r3,r3,17196
   153d0:	10800724 	muli	r2,r2,28
   153d4:	1885883a 	add	r2,r3,r2
   153d8:	10800404 	addi	r2,r2,16
   153dc:	10800017 	ldw	r2,0(r2)
   153e0:	10800058 	cmpnei	r2,r2,1
   153e4:	1000451e 	bne	r2,zero,154fc <find_entry+0x258>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
   153e8:	e0bffe17 	ldw	r2,-8(fp)
   153ec:	10001226 	beq	r2,zero,15438 <find_entry+0x194>
   153f0:	e0bffe17 	ldw	r2,-8(fp)
   153f4:	10c0000b 	ldhu	r3,0(r2)
   153f8:	1080008b 	ldhu	r2,2(r2)
   153fc:	1004943a 	slli	r2,r2,16
   15400:	10c4b03a 	or	r2,r2,r3
   15404:	1007883a 	mov	r3,r2
   15408:	e0bffcc3 	ldbu	r2,-13(fp)
   1540c:	01000134 	movhi	r4,4
   15410:	2110cb04 	addi	r4,r4,17196
   15414:	10800724 	muli	r2,r2,28
   15418:	2085883a 	add	r2,r4,r2
   1541c:	10800104 	addi	r2,r2,4
   15420:	10800017 	ldw	r2,0(r2)
   15424:	1880041e 	bne	r3,r2,15438 <find_entry+0x194>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching pending entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
   15428:	e0bffcc3 	ldbu	r2,-13(fp)
   1542c:	d0a8e505 	stb	r2,-23660(gp)
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
   15430:	e0bffcc3 	ldbu	r2,-13(fp)
   15434:	0000d906 	br	1579c <find_entry+0x4f8>
#if ARP_QUEUEING
      /* pending with queued packets? */
      } else if (arp_table[i].q != NULL) {
   15438:	e0bffcc3 	ldbu	r2,-13(fp)
   1543c:	00c00134 	movhi	r3,4
   15440:	18d0cb04 	addi	r3,r3,17196
   15444:	10800724 	muli	r2,r2,28
   15448:	1885883a 	add	r2,r3,r2
   1544c:	10800017 	ldw	r2,0(r2)
   15450:	10001526 	beq	r2,zero,154a8 <find_entry+0x204>
        if (arp_table[i].ctime >= age_queue) {
   15454:	e0bffcc3 	ldbu	r2,-13(fp)
   15458:	00c00134 	movhi	r3,4
   1545c:	18d0cb04 	addi	r3,r3,17196
   15460:	10800724 	muli	r2,r2,28
   15464:	1885883a 	add	r2,r3,r2
   15468:	10800504 	addi	r2,r2,20
   1546c:	10800003 	ldbu	r2,0(r2)
   15470:	10c03fcc 	andi	r3,r2,255
   15474:	e0bffdc3 	ldbu	r2,-9(fp)
   15478:	18805136 	bltu	r3,r2,155c0 <find_entry+0x31c>
          old_queue = i;
   1547c:	e0bffcc3 	ldbu	r2,-13(fp)
   15480:	e0bffd85 	stb	r2,-10(fp)
          age_queue = arp_table[i].ctime;
   15484:	e0bffcc3 	ldbu	r2,-13(fp)
   15488:	00c00134 	movhi	r3,4
   1548c:	18d0cb04 	addi	r3,r3,17196
   15490:	10800724 	muli	r2,r2,28
   15494:	1885883a 	add	r2,r3,r2
   15498:	10800504 	addi	r2,r2,20
   1549c:	10800003 	ldbu	r2,0(r2)
   154a0:	e0bffdc5 	stb	r2,-9(fp)
   154a4:	00004606 	br	155c0 <find_entry+0x31c>
        }
#endif
      /* pending without queued packets? */
      } else {
        if (arp_table[i].ctime >= age_pending) {
   154a8:	e0bffcc3 	ldbu	r2,-13(fp)
   154ac:	00c00134 	movhi	r3,4
   154b0:	18d0cb04 	addi	r3,r3,17196
   154b4:	10800724 	muli	r2,r2,28
   154b8:	1885883a 	add	r2,r3,r2
   154bc:	10800504 	addi	r2,r2,20
   154c0:	10800003 	ldbu	r2,0(r2)
   154c4:	10c03fcc 	andi	r3,r2,255
   154c8:	e0bffd03 	ldbu	r2,-12(fp)
   154cc:	18803c36 	bltu	r3,r2,155c0 <find_entry+0x31c>
          old_pending = i;
   154d0:	e0bffcc3 	ldbu	r2,-13(fp)
   154d4:	e0bffc05 	stb	r2,-16(fp)
          age_pending = arp_table[i].ctime;
   154d8:	e0bffcc3 	ldbu	r2,-13(fp)
   154dc:	00c00134 	movhi	r3,4
   154e0:	18d0cb04 	addi	r3,r3,17196
   154e4:	10800724 	muli	r2,r2,28
   154e8:	1885883a 	add	r2,r3,r2
   154ec:	10800504 	addi	r2,r2,20
   154f0:	10800003 	ldbu	r2,0(r2)
   154f4:	e0bffd05 	stb	r2,-12(fp)
   154f8:	00003106 	br	155c0 <find_entry+0x31c>
        }
      }        
    }
    /* stable entry? */
    else if (arp_table[i].state == ETHARP_STATE_STABLE) {
   154fc:	e0bffcc3 	ldbu	r2,-13(fp)
   15500:	00c00134 	movhi	r3,4
   15504:	18d0cb04 	addi	r3,r3,17196
   15508:	10800724 	muli	r2,r2,28
   1550c:	1885883a 	add	r2,r3,r2
   15510:	10800404 	addi	r2,r2,16
   15514:	10800017 	ldw	r2,0(r2)
   15518:	10800098 	cmpnei	r2,r2,2
   1551c:	1000281e 	bne	r2,zero,155c0 <find_entry+0x31c>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
   15520:	e0bffe17 	ldw	r2,-8(fp)
   15524:	10001226 	beq	r2,zero,15570 <find_entry+0x2cc>
   15528:	e0bffe17 	ldw	r2,-8(fp)
   1552c:	10c0000b 	ldhu	r3,0(r2)
   15530:	1080008b 	ldhu	r2,2(r2)
   15534:	1004943a 	slli	r2,r2,16
   15538:	10c4b03a 	or	r2,r2,r3
   1553c:	1007883a 	mov	r3,r2
   15540:	e0bffcc3 	ldbu	r2,-13(fp)
   15544:	01000134 	movhi	r4,4
   15548:	2110cb04 	addi	r4,r4,17196
   1554c:	10800724 	muli	r2,r2,28
   15550:	2085883a 	add	r2,r4,r2
   15554:	10800104 	addi	r2,r2,4
   15558:	10800017 	ldw	r2,0(r2)
   1555c:	1880041e 	bne	r3,r2,15570 <find_entry+0x2cc>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching stable entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
   15560:	e0bffcc3 	ldbu	r2,-13(fp)
   15564:	d0a8e505 	stb	r2,-23660(gp)
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
   15568:	e0bffcc3 	ldbu	r2,-13(fp)
   1556c:	00008b06 	br	1579c <find_entry+0x4f8>
      /* remember entry with oldest stable entry in oldest, its age in maxtime */
      } else if (arp_table[i].ctime >= age_stable) {
   15570:	e0bffcc3 	ldbu	r2,-13(fp)
   15574:	00c00134 	movhi	r3,4
   15578:	18d0cb04 	addi	r3,r3,17196
   1557c:	10800724 	muli	r2,r2,28
   15580:	1885883a 	add	r2,r3,r2
   15584:	10800504 	addi	r2,r2,20
   15588:	10800003 	ldbu	r2,0(r2)
   1558c:	10c03fcc 	andi	r3,r2,255
   15590:	e0bffd43 	ldbu	r2,-11(fp)
   15594:	18800a36 	bltu	r3,r2,155c0 <find_entry+0x31c>
        old_stable = i;
   15598:	e0bffcc3 	ldbu	r2,-13(fp)
   1559c:	e0bffc45 	stb	r2,-15(fp)
        age_stable = arp_table[i].ctime;
   155a0:	e0bffcc3 	ldbu	r2,-13(fp)
   155a4:	00c00134 	movhi	r3,4
   155a8:	18d0cb04 	addi	r3,r3,17196
   155ac:	10800724 	muli	r2,r2,28
   155b0:	1885883a 	add	r2,r3,r2
   155b4:	10800504 	addi	r2,r2,20
   155b8:	10800003 	ldbu	r2,0(r2)
   155bc:	e0bffd45 	stb	r2,-11(fp)
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
   155c0:	e0bffcc3 	ldbu	r2,-13(fp)
   155c4:	10800044 	addi	r2,r2,1
   155c8:	e0bffcc5 	stb	r2,-13(fp)
   155cc:	e0bffcc3 	ldbu	r2,-13(fp)
   155d0:	108002b0 	cmpltui	r2,r2,10
   155d4:	103f6d1e 	bne	r2,zero,1538c <find_entry+0xe8>
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
   155d8:	e0bffc87 	ldb	r2,-14(fp)
   155dc:	10800298 	cmpnei	r2,r2,10
   155e0:	1000031e 	bne	r2,zero,155f0 <find_entry+0x34c>
   155e4:	e0bfff03 	ldbu	r2,-4(fp)
   155e8:	1080004c 	andi	r2,r2,1
   155ec:	10000326 	beq	r2,zero,155fc <find_entry+0x358>
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
   155f0:	e0bfff03 	ldbu	r2,-4(fp)
   155f4:	1080008c 	andi	r2,r2,2
   155f8:	10000226 	beq	r2,zero,15604 <find_entry+0x360>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
   155fc:	00bfffc4 	movi	r2,-1
   15600:	00006606 	br	1579c <find_entry+0x4f8>
   * 
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
   15604:	e0bffc87 	ldb	r2,-14(fp)
   15608:	10800288 	cmpgei	r2,r2,10
   1560c:	1000031e 	bne	r2,zero,1561c <find_entry+0x378>
    i = empty;
   15610:	e0bffc83 	ldbu	r2,-14(fp)
   15614:	e0bffcc5 	stb	r2,-13(fp)
   15618:	00003106 	br	156e0 <find_entry+0x43c>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  }
  /* 2) found recyclable stable entry? */
  else if (old_stable < ARP_TABLE_SIZE) {
   1561c:	e0bffc47 	ldb	r2,-15(fp)
   15620:	10800288 	cmpgei	r2,r2,10
   15624:	1000121e 	bne	r2,zero,15670 <find_entry+0x3cc>
    /* recycle oldest stable*/
    i = old_stable;
   15628:	e0bffc43 	ldbu	r2,-15(fp)
   1562c:	e0bffcc5 	stb	r2,-13(fp)
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
#if ARP_QUEUEING
    /* no queued packets should exist on stable entries */
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
   15630:	e0bffcc3 	ldbu	r2,-13(fp)
   15634:	00c00134 	movhi	r3,4
   15638:	18d0cb04 	addi	r3,r3,17196
   1563c:	10800724 	muli	r2,r2,28
   15640:	1885883a 	add	r2,r3,r2
   15644:	10800017 	ldw	r2,0(r2)
   15648:	10002526 	beq	r2,zero,156e0 <find_entry+0x43c>
   1564c:	010000f4 	movhi	r4,3
   15650:	213f5904 	addi	r4,r4,-668
   15654:	014000f4 	movhi	r5,3
   15658:	297f7404 	addi	r5,r5,-560
   1565c:	01805d04 	movi	r6,372
   15660:	01c000f4 	movhi	r7,3
   15664:	39ff6604 	addi	r7,r7,-616
   15668:	00170680 	call	17068 <printf>
   1566c:	003fff06 	br	1566c <find_entry+0x3c8>
#endif
  /* 3) found recyclable pending entry without queued packets? */
  } else if (old_pending < ARP_TABLE_SIZE) {
   15670:	e0bffc07 	ldb	r2,-16(fp)
   15674:	10800288 	cmpgei	r2,r2,10
   15678:	1000031e 	bne	r2,zero,15688 <find_entry+0x3e4>
    /* recycle oldest pending */
    i = old_pending;
   1567c:	e0bffc03 	ldbu	r2,-16(fp)
   15680:	e0bffcc5 	stb	r2,-13(fp)
   15684:	00001606 	br	156e0 <find_entry+0x43c>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
#if ARP_QUEUEING
  /* 4) found recyclable pending entry with queued packets? */
  } else if (old_queue < ARP_TABLE_SIZE) {
   15688:	e0bffd87 	ldb	r2,-10(fp)
   1568c:	10800288 	cmpgei	r2,r2,10
   15690:	1000111e 	bne	r2,zero,156d8 <find_entry+0x434>
    /* recycle oldest pending */
    i = old_queue;
   15694:	e0bffd83 	ldbu	r2,-10(fp)
   15698:	e0bffcc5 	stb	r2,-13(fp)
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
   1569c:	e0bffcc3 	ldbu	r2,-13(fp)
   156a0:	00c00134 	movhi	r3,4
   156a4:	18d0cb04 	addi	r3,r3,17196
   156a8:	10800724 	muli	r2,r2,28
   156ac:	1885883a 	add	r2,r3,r2
   156b0:	10800017 	ldw	r2,0(r2)
   156b4:	1009883a 	mov	r4,r2
   156b8:	00150340 	call	15034 <free_etharp_q>
    arp_table[i].q = NULL;
   156bc:	e0bffcc3 	ldbu	r2,-13(fp)
   156c0:	00c00134 	movhi	r3,4
   156c4:	18d0cb04 	addi	r3,r3,17196
   156c8:	10800724 	muli	r2,r2,28
   156cc:	1885883a 	add	r2,r3,r2
   156d0:	10000015 	stw	zero,0(r2)
   156d4:	00000206 	br	156e0 <find_entry+0x43c>
#endif
    /* no empty or recyclable entries found */
  } else {
    return (s8_t)ERR_MEM;
   156d8:	00bfffc4 	movi	r2,-1
   156dc:	00002f06 	br	1579c <find_entry+0x4f8>
  }

  /* { empty or recyclable entry found } */
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
   156e0:	e0bffcc3 	ldbu	r2,-13(fp)
   156e4:	108002b0 	cmpltui	r2,r2,10
   156e8:	1000091e 	bne	r2,zero,15710 <find_entry+0x46c>
   156ec:	010000f4 	movhi	r4,3
   156f0:	213f5904 	addi	r4,r4,-668
   156f4:	014000f4 	movhi	r5,3
   156f8:	297f7a04 	addi	r5,r5,-536
   156fc:	01806284 	movi	r6,394
   15700:	01c000f4 	movhi	r7,3
   15704:	39ff6604 	addi	r7,r7,-616
   15708:	00170680 	call	17068 <printf>
   1570c:	003fff06 	br	1570c <find_entry+0x468>
  if (arp_table[i].state != ETHARP_STATE_EMPTY)
  {
    snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  }
  /* recycle entry (no-op for an already empty entry) */
  arp_table[i].state = ETHARP_STATE_EMPTY;
   15710:	e0bffcc3 	ldbu	r2,-13(fp)
   15714:	00c00134 	movhi	r3,4
   15718:	18d0cb04 	addi	r3,r3,17196
   1571c:	10800724 	muli	r2,r2,28
   15720:	1885883a 	add	r2,r3,r2
   15724:	10800404 	addi	r2,r2,16
   15728:	10000015 	stw	zero,0(r2)

  /* IP address given? */
  if (ipaddr != NULL) {
   1572c:	e0bffe17 	ldw	r2,-8(fp)
   15730:	10001026 	beq	r2,zero,15774 <find_entry+0x4d0>
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
   15734:	e0fffcc3 	ldbu	r3,-13(fp)
   15738:	e0bffe17 	ldw	r2,-8(fp)
   1573c:	10000626 	beq	r2,zero,15758 <find_entry+0x4b4>
   15740:	e0bffe17 	ldw	r2,-8(fp)
   15744:	1100000b 	ldhu	r4,0(r2)
   15748:	1080008b 	ldhu	r2,2(r2)
   1574c:	1004943a 	slli	r2,r2,16
   15750:	1104b03a 	or	r2,r2,r4
   15754:	00000106 	br	1575c <find_entry+0x4b8>
   15758:	0005883a 	mov	r2,zero
   1575c:	01000134 	movhi	r4,4
   15760:	2110cb04 	addi	r4,r4,17196
   15764:	18c00724 	muli	r3,r3,28
   15768:	20c7883a 	add	r3,r4,r3
   1576c:	18c00104 	addi	r3,r3,4
   15770:	18800015 	stw	r2,0(r3)
  }
  arp_table[i].ctime = 0;
   15774:	e0bffcc3 	ldbu	r2,-13(fp)
   15778:	00c00134 	movhi	r3,4
   1577c:	18d0cb04 	addi	r3,r3,17196
   15780:	10800724 	muli	r2,r2,28
   15784:	1885883a 	add	r2,r3,r2
   15788:	10800504 	addi	r2,r2,20
   1578c:	10000005 	stb	zero,0(r2)
#if LWIP_NETIF_HWADDRHINT
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
   15790:	e0bffcc3 	ldbu	r2,-13(fp)
   15794:	d0a8e505 	stb	r2,-23660(gp)
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
   15798:	e0bffcc3 	ldbu	r2,-13(fp)
}
   1579c:	e037883a 	mov	sp,fp
   157a0:	dfc00117 	ldw	ra,4(sp)
   157a4:	df000017 	ldw	fp,0(sp)
   157a8:	dec00204 	addi	sp,sp,8
   157ac:	f800283a 	ret

000157b0 <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
   157b0:	defff804 	addi	sp,sp,-32
   157b4:	dfc00715 	stw	ra,28(sp)
   157b8:	df000615 	stw	fp,24(sp)
   157bc:	df000604 	addi	fp,sp,24
   157c0:	e13ffc15 	stw	r4,-16(fp)
   157c4:	e17ffd15 	stw	r5,-12(fp)
   157c8:	e1bffe15 	stw	r6,-8(fp)
   157cc:	e1ffff15 	stw	r7,-4(fp)
  struct eth_hdr *ethhdr = p->payload;
   157d0:	e0bffd17 	ldw	r2,-12(fp)
   157d4:	10800117 	ldw	r2,4(r2)
   157d8:	e0bffb15 	stw	r2,-20(fp)
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
   157dc:	e0bffc17 	ldw	r2,-16(fp)
   157e0:	10800983 	ldbu	r2,38(r2)
   157e4:	10803fcc 	andi	r2,r2,255
   157e8:	108001a0 	cmpeqi	r2,r2,6
   157ec:	1000091e 	bne	r2,zero,15814 <etharp_send_ip+0x64>
   157f0:	010000f4 	movhi	r4,3
   157f4:	213f5904 	addi	r4,r4,-668
   157f8:	014000f4 	movhi	r5,3
   157fc:	297f7f04 	addi	r5,r5,-516
   15800:	01806c84 	movi	r6,434
   15804:	01c000f4 	movhi	r7,3
   15808:	39ff6604 	addi	r7,r7,-616
   1580c:	00170680 	call	17068 <printf>
   15810:	003fff06 	br	15810 <etharp_send_ip+0x60>
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
   15814:	00800184 	movi	r2,6
   15818:	e0bffa05 	stb	r2,-24(fp)
  while(k > 0) {
   1581c:	00001406 	br	15870 <etharp_send_ip+0xc0>
    k--;
   15820:	e0bffa03 	ldbu	r2,-24(fp)
   15824:	10bfffc4 	addi	r2,r2,-1
   15828:	e0bffa05 	stb	r2,-24(fp)
    ethhdr->dest.addr[k] = dst->addr[k];
   1582c:	e0bffa03 	ldbu	r2,-24(fp)
   15830:	e0fffa03 	ldbu	r3,-24(fp)
   15834:	e13fff17 	ldw	r4,-4(fp)
   15838:	20c7883a 	add	r3,r4,r3
   1583c:	18c00003 	ldbu	r3,0(r3)
   15840:	e13ffb17 	ldw	r4,-20(fp)
   15844:	2085883a 	add	r2,r4,r2
   15848:	10c00085 	stb	r3,2(r2)
    ethhdr->src.addr[k]  = src->addr[k];
   1584c:	e0bffa03 	ldbu	r2,-24(fp)
   15850:	e0fffa03 	ldbu	r3,-24(fp)
   15854:	e13ffe17 	ldw	r4,-8(fp)
   15858:	20c7883a 	add	r3,r4,r3
   1585c:	18c00003 	ldbu	r3,0(r3)
   15860:	e13ffb17 	ldw	r4,-20(fp)
   15864:	2085883a 	add	r2,r4,r2
   15868:	10800204 	addi	r2,r2,8
   1586c:	10c00005 	stb	r3,0(r2)
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
   15870:	e0bffa03 	ldbu	r2,-24(fp)
   15874:	103fea1e 	bne	r2,zero,15820 <etharp_send_ip+0x70>
    k--;
    ethhdr->dest.addr[k] = dst->addr[k];
    ethhdr->src.addr[k]  = src->addr[k];
  }
  ethhdr->type = htons(ETHTYPE_IP);
   15878:	e0bffb17 	ldw	r2,-20(fp)
   1587c:	00c00204 	movi	r3,8
   15880:	10c0038d 	sth	r3,14(r2)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
   15884:	e0bffc17 	ldw	r2,-16(fp)
   15888:	10800617 	ldw	r2,24(r2)
   1588c:	e13ffc17 	ldw	r4,-16(fp)
   15890:	e17ffd17 	ldw	r5,-12(fp)
   15894:	103ee83a 	callr	r2
}
   15898:	e037883a 	mov	sp,fp
   1589c:	dfc00117 	ldw	ra,4(sp)
   158a0:	df000017 	ldw	fp,0(sp)
   158a4:	dec00204 	addi	sp,sp,8
   158a8:	f800283a 	ret

000158ac <update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
   158ac:	defff704 	addi	sp,sp,-36
   158b0:	dfc00815 	stw	ra,32(sp)
   158b4:	df000715 	stw	fp,28(sp)
   158b8:	df000704 	addi	fp,sp,28
   158bc:	e13ffc15 	stw	r4,-16(fp)
   158c0:	e17ffd15 	stw	r5,-12(fp)
   158c4:	e1bffe15 	stw	r6,-8(fp)
   158c8:	3805883a 	mov	r2,r7
   158cc:	e0bfff05 	stb	r2,-4(fp)
  s8_t i;
  u8_t k;
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry()\n"));
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
   158d0:	e0bffc17 	ldw	r2,-16(fp)
   158d4:	10800983 	ldbu	r2,38(r2)
   158d8:	10803fcc 	andi	r2,r2,255
   158dc:	108001a0 	cmpeqi	r2,r2,6
   158e0:	1000091e 	bne	r2,zero,15908 <update_arp_entry+0x5c>
   158e4:	010000f4 	movhi	r4,3
   158e8:	213f5904 	addi	r4,r4,-668
   158ec:	014000f4 	movhi	r5,3
   158f0:	297f9004 	addi	r5,r5,-448
   158f4:	01807604 	movi	r6,472
   158f8:	01c000f4 	movhi	r7,3
   158fc:	39ff6604 	addi	r7,r7,-616
   15900:	00170680 	call	17068 <printf>
   15904:	003fff06 	br	15904 <update_arp_entry+0x58>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
   15908:	e0bffd17 	ldw	r2,-12(fp)
   1590c:	10001326 	beq	r2,zero,1595c <update_arp_entry+0xb0>
   15910:	e0bffd17 	ldw	r2,-12(fp)
   15914:	10c0000b 	ldhu	r3,0(r2)
   15918:	1080008b 	ldhu	r2,2(r2)
   1591c:	1004943a 	slli	r2,r2,16
   15920:	10c4b03a 	or	r2,r2,r3
   15924:	10000d26 	beq	r2,zero,1595c <update_arp_entry+0xb0>
      ip_addr_isbroadcast(ipaddr, netif) ||
   15928:	e13ffd17 	ldw	r4,-12(fp)
   1592c:	e17ffc17 	ldw	r5,-16(fp)
   15930:	0006dcc0 	call	6dcc <ip_addr_isbroadcast>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
   15934:	10803fcc 	andi	r2,r2,255
   15938:	1000081e 	bne	r2,zero,1595c <update_arp_entry+0xb0>
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
   1593c:	e0bffd17 	ldw	r2,-12(fp)
   15940:	10c0000b 	ldhu	r3,0(r2)
   15944:	1080008b 	ldhu	r2,2(r2)
   15948:	1004943a 	slli	r2,r2,16
   1594c:	10c4b03a 	or	r2,r2,r3
   15950:	10803c0c 	andi	r2,r2,240
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
      ip_addr_isbroadcast(ipaddr, netif) ||
   15954:	10803818 	cmpnei	r2,r2,224
   15958:	1000021e 	bne	r2,zero,15964 <update_arp_entry+0xb8>
      ip_addr_ismulticast(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
   1595c:	00bffd84 	movi	r2,-10
   15960:	00005c06 	br	15ad4 <update_arp_entry+0x228>
  }
  /* find or create ARP entry */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, flags, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, flags);
   15964:	e0bfff03 	ldbu	r2,-4(fp)
   15968:	e13ffd17 	ldw	r4,-12(fp)
   1596c:	100b883a 	mov	r5,r2
   15970:	00152a40 	call	152a4 <find_entry>
   15974:	e0bff945 	stb	r2,-27(fp)
#endif /* LWIP_NETIF_HWADDRHINT */
  /* bail out if no entry could be found */
  if (i < 0)
   15978:	e0bff947 	ldb	r2,-27(fp)
   1597c:	1000020e 	bge	r2,zero,15988 <update_arp_entry+0xdc>
    return (err_t)i;
   15980:	e0bff943 	ldbu	r2,-27(fp)
   15984:	00005306 	br	15ad4 <update_arp_entry+0x228>
  
  /* mark it stable */
  arp_table[i].state = ETHARP_STATE_STABLE;
   15988:	e0bff947 	ldb	r2,-27(fp)
   1598c:	00c00134 	movhi	r3,4
   15990:	18d0cb04 	addi	r3,r3,17196
   15994:	10800724 	muli	r2,r2,28
   15998:	1885883a 	add	r2,r3,r2
   1599c:	10800404 	addi	r2,r2,16
   159a0:	00c00084 	movi	r3,2
   159a4:	10c00015 	stw	r3,0(r2)
  /* record network interface */
  arp_table[i].netif = netif;
   159a8:	e0bff947 	ldb	r2,-27(fp)
   159ac:	00c00134 	movhi	r3,4
   159b0:	18d0cb04 	addi	r3,r3,17196
   159b4:	10800724 	muli	r2,r2,28
   159b8:	1885883a 	add	r2,r3,r2
   159bc:	10800604 	addi	r2,r2,24
   159c0:	e0fffc17 	ldw	r3,-16(fp)
   159c4:	10c00015 	stw	r3,0(r2)
  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
   159c8:	00800184 	movi	r2,6
   159cc:	e0bff905 	stb	r2,-28(fp)
  while (k > 0) {
   159d0:	00001006 	br	15a14 <update_arp_entry+0x168>
    k--;
   159d4:	e0bff903 	ldbu	r2,-28(fp)
   159d8:	10bfffc4 	addi	r2,r2,-1
   159dc:	e0bff905 	stb	r2,-28(fp)
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
   159e0:	e13ff947 	ldb	r4,-27(fp)
   159e4:	e0bff903 	ldbu	r2,-28(fp)
   159e8:	e0fff903 	ldbu	r3,-28(fp)
   159ec:	e17ffe17 	ldw	r5,-8(fp)
   159f0:	28c7883a 	add	r3,r5,r3
   159f4:	18c00003 	ldbu	r3,0(r3)
   159f8:	01400134 	movhi	r5,4
   159fc:	2950cb04 	addi	r5,r5,17196
   15a00:	21000724 	muli	r4,r4,28
   15a04:	2909883a 	add	r4,r5,r4
   15a08:	2085883a 	add	r2,r4,r2
   15a0c:	10800204 	addi	r2,r2,8
   15a10:	10c00005 	stb	r3,0(r2)
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
   15a14:	e0bff903 	ldbu	r2,-28(fp)
   15a18:	103fee1e 	bne	r2,zero,159d4 <update_arp_entry+0x128>
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
   15a1c:	e0bff947 	ldb	r2,-27(fp)
   15a20:	00c00134 	movhi	r3,4
   15a24:	18d0cb04 	addi	r3,r3,17196
   15a28:	10800724 	muli	r2,r2,28
   15a2c:	1885883a 	add	r2,r3,r2
   15a30:	10800504 	addi	r2,r2,20
   15a34:	10000005 	stb	zero,0(r2)
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
   15a38:	00001e06 	br	15ab4 <update_arp_entry+0x208>
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
   15a3c:	e0bff947 	ldb	r2,-27(fp)
   15a40:	00c00134 	movhi	r3,4
   15a44:	18d0cb04 	addi	r3,r3,17196
   15a48:	10800724 	muli	r2,r2,28
   15a4c:	1885883a 	add	r2,r3,r2
   15a50:	10800017 	ldw	r2,0(r2)
   15a54:	e0bffa15 	stw	r2,-24(fp)
    /* pop first item off the queue */
    arp_table[i].q = q->next;
   15a58:	e0bff947 	ldb	r2,-27(fp)
   15a5c:	e0fffa17 	ldw	r3,-24(fp)
   15a60:	18c00017 	ldw	r3,0(r3)
   15a64:	01000134 	movhi	r4,4
   15a68:	2110cb04 	addi	r4,r4,17196
   15a6c:	10800724 	muli	r2,r2,28
   15a70:	2085883a 	add	r2,r4,r2
   15a74:	10c00015 	stw	r3,0(r2)
    /* get the packet pointer */
    p = q->p;
   15a78:	e0bffa17 	ldw	r2,-24(fp)
   15a7c:	10800117 	ldw	r2,4(r2)
   15a80:	e0bffb15 	stw	r2,-20(fp)
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
   15a84:	01000184 	movi	r4,6
   15a88:	e17ffa17 	ldw	r5,-24(fp)
   15a8c:	00090e80 	call	90e8 <memp_free>
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
   15a90:	e0bffc17 	ldw	r2,-16(fp)
   15a94:	108009c4 	addi	r2,r2,39
   15a98:	e13ffc17 	ldw	r4,-16(fp)
   15a9c:	e17ffb17 	ldw	r5,-20(fp)
   15aa0:	100d883a 	mov	r6,r2
   15aa4:	e1fffe17 	ldw	r7,-8(fp)
   15aa8:	00157b00 	call	157b0 <etharp_send_ip>
    /* free the queued IP packet */
    pbuf_free(p);
   15aac:	e13ffb17 	ldw	r4,-20(fp)
   15ab0:	000a1880 	call	a188 <pbuf_free>
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
   15ab4:	e0bff947 	ldb	r2,-27(fp)
   15ab8:	00c00134 	movhi	r3,4
   15abc:	18d0cb04 	addi	r3,r3,17196
   15ac0:	10800724 	muli	r2,r2,28
   15ac4:	1885883a 	add	r2,r3,r2
   15ac8:	10800017 	ldw	r2,0(r2)
   15acc:	103fdb1e 	bne	r2,zero,15a3c <update_arp_entry+0x190>
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
    /* free the queued IP packet */
    pbuf_free(p);
  }
#endif
  return ERR_OK;
   15ad0:	0005883a 	mov	r2,zero
}
   15ad4:	e037883a 	mov	sp,fp
   15ad8:	dfc00117 	ldw	ra,4(sp)
   15adc:	df000017 	ldw	fp,0(sp)
   15ae0:	dec00204 	addi	sp,sp,8
   15ae4:	f800283a 	ret

00015ae8 <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
         struct eth_addr **eth_ret, struct ip_addr **ip_ret)
{
   15ae8:	defff904 	addi	sp,sp,-28
   15aec:	dfc00615 	stw	ra,24(sp)
   15af0:	df000515 	stw	fp,20(sp)
   15af4:	df000504 	addi	fp,sp,20
   15af8:	e13ffc15 	stw	r4,-16(fp)
   15afc:	e17ffd15 	stw	r5,-12(fp)
   15b00:	e1bffe15 	stw	r6,-8(fp)
   15b04:	e1ffff15 	stw	r7,-4(fp)
  LWIP_UNUSED_ARG(netif);

#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_FIND_ONLY);
   15b08:	e13ffd17 	ldw	r4,-12(fp)
   15b0c:	01400084 	movi	r5,2
   15b10:	00152a40 	call	152a4 <find_entry>
   15b14:	e0bffb05 	stb	r2,-20(fp)
#endif /* LWIP_NETIF_HWADDRHINT */
  if((i >= 0) && arp_table[i].state == ETHARP_STATE_STABLE) {
   15b18:	e0bffb07 	ldb	r2,-20(fp)
   15b1c:	10001b16 	blt	r2,zero,15b8c <etharp_find_addr+0xa4>
   15b20:	e0bffb07 	ldb	r2,-20(fp)
   15b24:	00c00134 	movhi	r3,4
   15b28:	18d0cb04 	addi	r3,r3,17196
   15b2c:	10800724 	muli	r2,r2,28
   15b30:	1885883a 	add	r2,r3,r2
   15b34:	10800404 	addi	r2,r2,16
   15b38:	10800017 	ldw	r2,0(r2)
   15b3c:	10800098 	cmpnei	r2,r2,2
   15b40:	1000121e 	bne	r2,zero,15b8c <etharp_find_addr+0xa4>
      *eth_ret = &arp_table[i].ethaddr;
   15b44:	e0bffb07 	ldb	r2,-20(fp)
   15b48:	10800724 	muli	r2,r2,28
   15b4c:	10c00204 	addi	r3,r2,8
   15b50:	00800134 	movhi	r2,4
   15b54:	1090cb04 	addi	r2,r2,17196
   15b58:	1887883a 	add	r3,r3,r2
   15b5c:	e0bffe17 	ldw	r2,-8(fp)
   15b60:	10c00015 	stw	r3,0(r2)
      *ip_ret = &arp_table[i].ipaddr;
   15b64:	e0bffb07 	ldb	r2,-20(fp)
   15b68:	10800724 	muli	r2,r2,28
   15b6c:	10c00104 	addi	r3,r2,4
   15b70:	00800134 	movhi	r2,4
   15b74:	1090cb04 	addi	r2,r2,17196
   15b78:	1887883a 	add	r3,r3,r2
   15b7c:	e0bfff17 	ldw	r2,-4(fp)
   15b80:	10c00015 	stw	r3,0(r2)
      return i;
   15b84:	e0bffb03 	ldbu	r2,-20(fp)
   15b88:	00000106 	br	15b90 <etharp_find_addr+0xa8>
  }
  return -1;
   15b8c:	00bfffc4 	movi	r2,-1
}
   15b90:	e037883a 	mov	sp,fp
   15b94:	dfc00117 	ldw	ra,4(sp)
   15b98:	df000017 	ldw	fp,0(sp)
   15b9c:	dec00204 	addi	sp,sp,8
   15ba0:	f800283a 	ret

00015ba4 <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
   15ba4:	defffa04 	addi	sp,sp,-24
   15ba8:	dfc00515 	stw	ra,20(sp)
   15bac:	df000415 	stw	fp,16(sp)
   15bb0:	df000404 	addi	fp,sp,16
   15bb4:	e13ffe15 	stw	r4,-8(fp)
   15bb8:	e17fff15 	stw	r5,-4(fp)
  struct eth_hdr *ethhdr;
  struct ip_hdr *iphdr;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
   15bbc:	e0bffe17 	ldw	r2,-8(fp)
   15bc0:	1000091e 	bne	r2,zero,15be8 <etharp_ip_input+0x44>
   15bc4:	010000f4 	movhi	r4,3
   15bc8:	213f5904 	addi	r4,r4,-668
   15bcc:	014000f4 	movhi	r5,3
   15bd0:	297f9a04 	addi	r5,r5,-408
   15bd4:	01809204 	movi	r6,584
   15bd8:	01c000f4 	movhi	r7,3
   15bdc:	39ff6604 	addi	r7,r7,-616
   15be0:	00170680 	call	17068 <printf>
   15be4:	003fff06 	br	15be4 <etharp_ip_input+0x40>
  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  ethhdr = p->payload;
   15be8:	e0bfff17 	ldw	r2,-4(fp)
   15bec:	10800117 	ldw	r2,4(r2)
   15bf0:	e0bffc15 	stw	r2,-16(fp)
  iphdr = (struct ip_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
   15bf4:	e0bffc17 	ldw	r2,-16(fp)
   15bf8:	10800404 	addi	r2,r2,16
   15bfc:	e0bffd15 	stw	r2,-12(fp)
    iphdr = (struct ip_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(iphdr->src), &(netif->ip_addr), &(netif->netmask))) {
   15c00:	e0bffd17 	ldw	r2,-12(fp)
   15c04:	10c0030b 	ldhu	r3,12(r2)
   15c08:	1080038b 	ldhu	r2,14(r2)
   15c0c:	1004943a 	slli	r2,r2,16
   15c10:	10c4b03a 	or	r2,r2,r3
   15c14:	1007883a 	mov	r3,r2
   15c18:	e0bffe17 	ldw	r2,-8(fp)
   15c1c:	10800117 	ldw	r2,4(r2)
   15c20:	1886f03a 	xor	r3,r3,r2
   15c24:	e0bffe17 	ldw	r2,-8(fp)
   15c28:	10800217 	ldw	r2,8(r2)
   15c2c:	1884703a 	and	r2,r3,r2
   15c30:	10000a1e 	bne	r2,zero,15c5c <etharp_ip_input+0xb8>

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(iphdr->src), &(ethhdr->src), 0);
   15c34:	e0bffd17 	ldw	r2,-12(fp)
   15c38:	10c00304 	addi	r3,r2,12
   15c3c:	e0bffc17 	ldw	r2,-16(fp)
   15c40:	10800204 	addi	r2,r2,8
   15c44:	e13ffe17 	ldw	r4,-8(fp)
   15c48:	180b883a 	mov	r5,r3
   15c4c:	100d883a 	mov	r6,r2
   15c50:	000f883a 	mov	r7,zero
   15c54:	00158ac0 	call	158ac <update_arp_entry>
   15c58:	00000106 	br	15c60 <etharp_ip_input+0xbc>
#endif /* ETHARP_SUPPORT_VLAN */

  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(iphdr->src), &(netif->ip_addr), &(netif->netmask))) {
    /* do nothing */
    return;
   15c5c:	0001883a 	nop
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(iphdr->src), &(ethhdr->src), 0);
}
   15c60:	e037883a 	mov	sp,fp
   15c64:	dfc00117 	ldw	ra,4(sp)
   15c68:	df000017 	ldw	fp,0(sp)
   15c6c:	dec00204 	addi	sp,sp,8
   15c70:	f800283a 	ret

00015c74 <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
   15c74:	defff604 	addi	sp,sp,-40
   15c78:	dfc00915 	stw	ra,36(sp)
   15c7c:	df000815 	stw	fp,32(sp)
   15c80:	df000804 	addi	fp,sp,32
   15c84:	e13ffd15 	stw	r4,-12(fp)
   15c88:	e17ffe15 	stw	r5,-8(fp)
   15c8c:	e1bfff15 	stw	r6,-4(fp)
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
   15c90:	e0bffd17 	ldw	r2,-12(fp)
   15c94:	1000091e 	bne	r2,zero,15cbc <etharp_arp_input+0x48>
   15c98:	010000f4 	movhi	r4,3
   15c9c:	213f5904 	addi	r4,r4,-668
   15ca0:	014000f4 	movhi	r5,3
   15ca4:	297f9a04 	addi	r5,r5,-408
   15ca8:	01809f44 	movi	r6,637
   15cac:	01c000f4 	movhi	r7,3
   15cb0:	39ff6604 	addi	r7,r7,-616
   15cb4:	00170680 	call	17068 <printf>
   15cb8:	003fff06 	br	15cb8 <etharp_arp_input+0x44>
  
  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < SIZEOF_ETHARP_PACKET) {
   15cbc:	e0bfff17 	ldw	r2,-4(fp)
   15cc0:	1080028b 	ldhu	r2,10(r2)
   15cc4:	10bfffcc 	andi	r2,r2,65535
   15cc8:	10800b28 	cmpgeui	r2,r2,44
   15ccc:	1000131e 	bne	r2,zero,15d1c <etharp_arp_input+0xa8>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len,
      (s16_t)SIZEOF_ETHARP_PACKET));
    ETHARP_STATS_INC(etharp.lenerr);
   15cd0:	00800134 	movhi	r2,4
   15cd4:	10916104 	addi	r2,r2,17796
   15cd8:	1080088b 	ldhu	r2,34(r2)
   15cdc:	10800044 	addi	r2,r2,1
   15ce0:	1007883a 	mov	r3,r2
   15ce4:	00800134 	movhi	r2,4
   15ce8:	10916104 	addi	r2,r2,17796
   15cec:	10c0088d 	sth	r3,34(r2)
    ETHARP_STATS_INC(etharp.drop);
   15cf0:	00800134 	movhi	r2,4
   15cf4:	10916104 	addi	r2,r2,17796
   15cf8:	1080078b 	ldhu	r2,30(r2)
   15cfc:	10800044 	addi	r2,r2,1
   15d00:	1007883a 	mov	r3,r2
   15d04:	00800134 	movhi	r2,4
   15d08:	10916104 	addi	r2,r2,17796
   15d0c:	10c0078d 	sth	r3,30(r2)
    pbuf_free(p);
   15d10:	e13fff17 	ldw	r4,-4(fp)
   15d14:	000a1880 	call	a188 <pbuf_free>
   15d18:	0000d106 	br	16060 <etharp_arp_input+0x3ec>
    return;
  }

  ethhdr = p->payload;
   15d1c:	e0bfff17 	ldw	r2,-4(fp)
   15d20:	10800117 	ldw	r2,4(r2)
   15d24:	e0bff915 	stw	r2,-28(fp)
  hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
   15d28:	e0bff917 	ldw	r2,-28(fp)
   15d2c:	10800404 	addi	r2,r2,16
   15d30:	e0bffa15 	stw	r2,-24(fp)
    hdr = (struct etharp_hdr *)(((u8_t*)ethhdr) + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
   15d34:	e0bffa17 	ldw	r2,-24(fp)
   15d38:	1080000b 	ldhu	r2,0(r2)
   15d3c:	10bfffcc 	andi	r2,r2,65535
   15d40:	10804018 	cmpnei	r2,r2,256
   15d44:	10000f1e 	bne	r2,zero,15d84 <etharp_arp_input+0x110>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
   15d48:	e0bffa17 	ldw	r2,-24(fp)
   15d4c:	1080010b 	ldhu	r2,4(r2)
    hdr = (struct etharp_hdr *)(((u8_t*)ethhdr) + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
   15d50:	10bfffcc 	andi	r2,r2,65535
   15d54:	10810198 	cmpnei	r2,r2,1030
   15d58:	10000a1e 	bne	r2,zero,15d84 <etharp_arp_input+0x110>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
   15d5c:	e0bffa17 	ldw	r2,-24(fp)
   15d60:	1080008b 	ldhu	r2,2(r2)
  }
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
   15d64:	10bfffcc 	andi	r2,r2,65535
   15d68:	10800218 	cmpnei	r2,r2,8
   15d6c:	1000051e 	bne	r2,zero,15d84 <etharp_arp_input+0x110>
      (hdr->proto != htons(ETHTYPE_IP)) ||
      (ethhdr->type != htons(ETHTYPE_ARP)))  {
   15d70:	e0bff917 	ldw	r2,-28(fp)
   15d74:	1080038b 	ldhu	r2,14(r2)
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
   15d78:	10bfffcc 	andi	r2,r2,65535
   15d7c:	10818220 	cmpeqi	r2,r2,1544
   15d80:	1000131e 	bne	r2,zero,15dd0 <etharp_arp_input+0x15c>
      (ethhdr->type != htons(ETHTYPE_ARP)))  {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, ARPH_HWLEN(hdr), hdr->proto, ARPH_PROTOLEN(hdr), ethhdr->type));
    ETHARP_STATS_INC(etharp.proterr);
   15d84:	00800134 	movhi	r2,4
   15d88:	10916104 	addi	r2,r2,17796
   15d8c:	10800a0b 	ldhu	r2,40(r2)
   15d90:	10800044 	addi	r2,r2,1
   15d94:	1007883a 	mov	r3,r2
   15d98:	00800134 	movhi	r2,4
   15d9c:	10916104 	addi	r2,r2,17796
   15da0:	10c00a0d 	sth	r3,40(r2)
    ETHARP_STATS_INC(etharp.drop);
   15da4:	00800134 	movhi	r2,4
   15da8:	10916104 	addi	r2,r2,17796
   15dac:	1080078b 	ldhu	r2,30(r2)
   15db0:	10800044 	addi	r2,r2,1
   15db4:	1007883a 	mov	r3,r2
   15db8:	00800134 	movhi	r2,4
   15dbc:	10916104 	addi	r2,r2,17796
   15dc0:	10c0078d 	sth	r3,30(r2)
    pbuf_free(p);
   15dc4:	e13fff17 	ldw	r4,-4(fp)
   15dc8:	000a1880 	call	a188 <pbuf_free>
   15dcc:	0000a406 	br	16060 <etharp_arp_input+0x3ec>
    return;
  }
  ETHARP_STATS_INC(etharp.recv);
   15dd0:	00800134 	movhi	r2,4
   15dd4:	10916104 	addi	r2,r2,17796
   15dd8:	1080068b 	ldhu	r2,26(r2)
   15ddc:	10800044 	addi	r2,r2,1
   15de0:	1007883a 	mov	r3,r2
   15de4:	00800134 	movhi	r2,4
   15de8:	10916104 	addi	r2,r2,17796
   15dec:	10c0068d 	sth	r3,26(r2)
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
   15df0:	e0bffa17 	ldw	r2,-24(fp)
   15df4:	10c0038b 	ldhu	r3,14(r2)
   15df8:	e0fffb0d 	sth	r3,-20(fp)
   15dfc:	1080040b 	ldhu	r2,16(r2)
   15e00:	e0bffb8d 	sth	r2,-18(fp)
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
   15e04:	e0bffa17 	ldw	r2,-24(fp)
   15e08:	10c0060b 	ldhu	r3,24(r2)
   15e0c:	e0fffc0d 	sth	r3,-16(fp)
   15e10:	1080068b 	ldhu	r2,26(r2)
   15e14:	e0bffc8d 	sth	r2,-14(fp)

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
   15e18:	e0bffd17 	ldw	r2,-12(fp)
   15e1c:	10800117 	ldw	r2,4(r2)
   15e20:	1000021e 	bne	r2,zero,15e2c <etharp_arp_input+0x1b8>
    for_us = 0;
   15e24:	e03ff845 	stb	zero,-31(fp)
   15e28:	00000506 	br	15e40 <etharp_arp_input+0x1cc>
  } else {
    /* ARP packet directed to us? */
    for_us = ip_addr_cmp(&dipaddr, &(netif->ip_addr));
   15e2c:	e0fffc17 	ldw	r3,-16(fp)
   15e30:	e0bffd17 	ldw	r2,-12(fp)
   15e34:	10800117 	ldw	r2,4(r2)
   15e38:	1885003a 	cmpeq	r2,r3,r2
   15e3c:	e0bff845 	stb	r2,-31(fp)
  }

  /* ARP message directed to us? */
  if (for_us) {
   15e40:	e0bff843 	ldbu	r2,-31(fp)
   15e44:	10000926 	beq	r2,zero,15e6c <etharp_arp_input+0x1f8>
    /* add IP address in ARP cache; assume requester wants to talk to us.
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
   15e48:	e0bffa17 	ldw	r2,-24(fp)
   15e4c:	10800204 	addi	r2,r2,8
   15e50:	e0fffb04 	addi	r3,fp,-20
   15e54:	e13ffd17 	ldw	r4,-12(fp)
   15e58:	180b883a 	mov	r5,r3
   15e5c:	100d883a 	mov	r6,r2
   15e60:	01c00044 	movi	r7,1
   15e64:	00158ac0 	call	158ac <update_arp_entry>
   15e68:	00000806 	br	15e8c <etharp_arp_input+0x218>
  /* ARP message not directed to us? */
  } else {
    /* update the source IP address in the cache, if present */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
   15e6c:	e0bffa17 	ldw	r2,-24(fp)
   15e70:	10800204 	addi	r2,r2,8
   15e74:	e0fffb04 	addi	r3,fp,-20
   15e78:	e13ffd17 	ldw	r4,-12(fp)
   15e7c:	180b883a 	mov	r5,r3
   15e80:	100d883a 	mov	r6,r2
   15e84:	000f883a 	mov	r7,zero
   15e88:	00158ac0 	call	158ac <update_arp_entry>
  }

  /* now act on the message itself */
  switch (htons(hdr->opcode)) {
   15e8c:	e0bffa17 	ldw	r2,-24(fp)
   15e90:	1080018b 	ldhu	r2,6(r2)
   15e94:	10bfffcc 	andi	r2,r2,65535
   15e98:	1004d23a 	srli	r2,r2,8
   15e9c:	10ffffcc 	andi	r3,r2,65535
   15ea0:	e0bffa17 	ldw	r2,-24(fp)
   15ea4:	1080018b 	ldhu	r2,6(r2)
   15ea8:	10bfffcc 	andi	r2,r2,65535
   15eac:	1004923a 	slli	r2,r2,8
   15eb0:	10bfffcc 	andi	r2,r2,65535
   15eb4:	1884b03a 	or	r2,r3,r2
   15eb8:	10c00060 	cmpeqi	r3,r2,1
   15ebc:	1800031e 	bne	r3,zero,15ecc <etharp_arp_input+0x258>
   15ec0:	108000a0 	cmpeqi	r2,r2,2
   15ec4:	1000551e 	bne	r2,zero,1601c <etharp_arp_input+0x3a8>
   15ec8:	00005906 	br	16030 <etharp_arp_input+0x3bc>
     * reply. In any case, we time-stamp any existing ARP entry,
     * and possiby send out an IP packet that was queued on it. */

    LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
    /* ARP request for our address? */
    if (for_us) {
   15ecc:	e0bff843 	ldbu	r2,-31(fp)
   15ed0:	10006026 	beq	r2,zero,16054 <etharp_arp_input+0x3e0>

      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* Re-use pbuf to send ARP reply.
         Since we are re-using an existing pbuf, we can't call etharp_raw since
         that would allocate a new pbuf. */
      hdr->opcode = htons(ARP_REPLY);
   15ed4:	e0bffa17 	ldw	r2,-24(fp)
   15ed8:	00c08004 	movi	r3,512
   15edc:	10c0018d 	sth	r3,6(r2)

      hdr->dipaddr = hdr->sipaddr;
   15ee0:	e0bffa17 	ldw	r2,-24(fp)
   15ee4:	e0fffa17 	ldw	r3,-24(fp)
   15ee8:	1900038b 	ldhu	r4,14(r3)
   15eec:	1100060d 	sth	r4,24(r2)
   15ef0:	18c0040b 	ldhu	r3,16(r3)
   15ef4:	10c0068d 	sth	r3,26(r2)
      SMEMCPY(&hdr->sipaddr, &netif->ip_addr, sizeof(hdr->sipaddr));
   15ef8:	e0bffa17 	ldw	r2,-24(fp)
   15efc:	10c00384 	addi	r3,r2,14
   15f00:	e0bffd17 	ldw	r2,-12(fp)
   15f04:	10800104 	addi	r2,r2,4
   15f08:	1809883a 	mov	r4,r3
   15f0c:	100b883a 	mov	r5,r2
   15f10:	01800104 	movi	r6,4
   15f14:	0016e680 	call	16e68 <memcpy>

      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
   15f18:	e0bffd17 	ldw	r2,-12(fp)
   15f1c:	10800983 	ldbu	r2,38(r2)
   15f20:	10803fcc 	andi	r2,r2,255
   15f24:	108001a0 	cmpeqi	r2,r2,6
   15f28:	1000091e 	bne	r2,zero,15f50 <etharp_arp_input+0x2dc>
   15f2c:	010000f4 	movhi	r4,3
   15f30:	213f5904 	addi	r4,r4,-668
   15f34:	014000f4 	movhi	r5,3
   15f38:	297f7f04 	addi	r5,r5,-516
   15f3c:	0180b5c4 	movi	r6,727
   15f40:	01c000f4 	movhi	r7,3
   15f44:	39ff6604 	addi	r7,r7,-616
   15f48:	00170680 	call	17068 <printf>
   15f4c:	003fff06 	br	15f4c <etharp_arp_input+0x2d8>
                  (netif->hwaddr_len == ETHARP_HWADDR_LEN));
      i = ETHARP_HWADDR_LEN;
   15f50:	00800184 	movi	r2,6
   15f54:	e0bff805 	stb	r2,-32(fp)
      /* If we are using Link-Local, ARP packets must be broadcast on the
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
   15f58:	00002806 	br	15ffc <etharp_arp_input+0x388>
        i--;
   15f5c:	e0bff803 	ldbu	r2,-32(fp)
   15f60:	10bfffc4 	addi	r2,r2,-1
   15f64:	e0bff805 	stb	r2,-32(fp)
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
   15f68:	e0bff803 	ldbu	r2,-32(fp)
   15f6c:	e0fff803 	ldbu	r3,-32(fp)
   15f70:	e13ffa17 	ldw	r4,-24(fp)
   15f74:	20c7883a 	add	r3,r4,r3
   15f78:	18c00204 	addi	r3,r3,8
   15f7c:	18c00003 	ldbu	r3,0(r3)
   15f80:	e13ffa17 	ldw	r4,-24(fp)
   15f84:	2085883a 	add	r2,r4,r2
   15f88:	10800404 	addi	r2,r2,16
   15f8c:	10c00085 	stb	r3,2(r2)
#if LWIP_AUTOIP
        ethhdr->dest.addr[i] = ethdst_hwaddr[i];
#else  /* LWIP_AUTOIP */
        ethhdr->dest.addr[i] = hdr->shwaddr.addr[i];
   15f90:	e0bff803 	ldbu	r2,-32(fp)
   15f94:	e0fff803 	ldbu	r3,-32(fp)
   15f98:	e13ffa17 	ldw	r4,-24(fp)
   15f9c:	20c7883a 	add	r3,r4,r3
   15fa0:	18c00204 	addi	r3,r3,8
   15fa4:	18c00003 	ldbu	r3,0(r3)
   15fa8:	e13ff917 	ldw	r4,-28(fp)
   15fac:	2085883a 	add	r2,r4,r2
   15fb0:	10c00085 	stb	r3,2(r2)
#endif /* LWIP_AUTOIP */
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
   15fb4:	e0bff803 	ldbu	r2,-32(fp)
   15fb8:	e0fff803 	ldbu	r3,-32(fp)
   15fbc:	e13ffe17 	ldw	r4,-8(fp)
   15fc0:	20c7883a 	add	r3,r4,r3
   15fc4:	18c00003 	ldbu	r3,0(r3)
   15fc8:	e13ffa17 	ldw	r4,-24(fp)
   15fcc:	2085883a 	add	r2,r4,r2
   15fd0:	10800204 	addi	r2,r2,8
   15fd4:	10c00005 	stb	r3,0(r2)
        ethhdr->src.addr[i] = ethaddr->addr[i];
   15fd8:	e0bff803 	ldbu	r2,-32(fp)
   15fdc:	e0fff803 	ldbu	r3,-32(fp)
   15fe0:	e13ffe17 	ldw	r4,-8(fp)
   15fe4:	20c7883a 	add	r3,r4,r3
   15fe8:	18c00003 	ldbu	r3,0(r3)
   15fec:	e13ff917 	ldw	r4,-28(fp)
   15ff0:	2085883a 	add	r2,r4,r2
   15ff4:	10800204 	addi	r2,r2,8
   15ff8:	10c00005 	stb	r3,0(r2)
      /* If we are using Link-Local, ARP packets must be broadcast on the
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
   15ffc:	e0bff803 	ldbu	r2,-32(fp)
   16000:	103fd61e 	bne	r2,zero,15f5c <etharp_arp_input+0x2e8>

      /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
   16004:	e0bffd17 	ldw	r2,-12(fp)
   16008:	10800617 	ldw	r2,24(r2)
   1600c:	e13ffd17 	ldw	r4,-12(fp)
   16010:	e17fff17 	ldw	r5,-4(fp)
   16014:	103ee83a 	callr	r2
    /* request was not directed to us */
    } else {
      /* { for_us == 0 and netif->ip_addr.addr != 0 } */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP request was not for us.\n"));
    }
    break;
   16018:	00000e06 	br	16054 <etharp_arp_input+0x3e0>
#if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
    /* DHCP wants to know about ARP replies from any host with an
     * IP address also offered to us by the DHCP server. We do not
     * want to take a duplicate IP address on a single network.
     * @todo How should we handle redundant (fail-over) interfaces? */
    dhcp_arp_reply(netif, &sipaddr);
   1601c:	e0bffb04 	addi	r2,fp,-20
   16020:	e13ffd17 	ldw	r4,-12(fp)
   16024:	100b883a 	mov	r5,r2
   16028:	0002a9c0 	call	2a9c <dhcp_arp_reply>
#endif
    break;
   1602c:	00000a06 	br	16058 <etharp_arp_input+0x3e4>
  default:
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
   16030:	00800134 	movhi	r2,4
   16034:	10916104 	addi	r2,r2,17796
   16038:	10800b0b 	ldhu	r2,44(r2)
   1603c:	10800044 	addi	r2,r2,1
   16040:	1007883a 	mov	r3,r2
   16044:	00800134 	movhi	r2,4
   16048:	10916104 	addi	r2,r2,17796
   1604c:	10c00b0d 	sth	r3,44(r2)
    break;
   16050:	00000106 	br	16058 <etharp_arp_input+0x3e4>
    /* request was not directed to us */
    } else {
      /* { for_us == 0 and netif->ip_addr.addr != 0 } */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP request was not for us.\n"));
    }
    break;
   16054:	0001883a 	nop
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
   16058:	e13fff17 	ldw	r4,-4(fp)
   1605c:	000a1880 	call	a188 <pbuf_free>
}
   16060:	e037883a 	mov	sp,fp
   16064:	dfc00117 	ldw	ra,4(sp)
   16068:	df000017 	ldw	fp,0(sp)
   1606c:	dec00204 	addi	sp,sp,8
   16070:	f800283a 	ret

00016074 <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, struct ip_addr *ipaddr)
{
   16074:	defff804 	addi	sp,sp,-32
   16078:	dfc00715 	stw	ra,28(sp)
   1607c:	df000615 	stw	fp,24(sp)
   16080:	df000604 	addi	fp,sp,24
   16084:	e13ffd15 	stw	r4,-12(fp)
   16088:	e17ffe15 	stw	r5,-8(fp)
   1608c:	e1bfff15 	stw	r6,-4(fp)
  struct eth_addr *dest, mcastaddr;

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
   16090:	e13ffe17 	ldw	r4,-8(fp)
   16094:	01400404 	movi	r5,16
   16098:	0009f900 	call	9f90 <pbuf_header>
   1609c:	10803fcc 	andi	r2,r2,255
   160a0:	10000a26 	beq	r2,zero,160cc <etharp_output+0x58>
    /* bail out */
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("etharp_output: could not allocate room for header.\n"));
    LINK_STATS_INC(link.lenerr);
   160a4:	00800134 	movhi	r2,4
   160a8:	10916104 	addi	r2,r2,17796
   160ac:	1080028b 	ldhu	r2,10(r2)
   160b0:	10800044 	addi	r2,r2,1
   160b4:	1007883a 	mov	r3,r2
   160b8:	00800134 	movhi	r2,4
   160bc:	10916104 	addi	r2,r2,17796
   160c0:	10c0028d 	sth	r3,10(r2)
    return ERR_BUF;
   160c4:	00bfff84 	movi	r2,-2
   160c8:	00008106 	br	162d0 <etharp_output+0x25c>
  }

  /* assume unresolved Ethernet address */
  dest = NULL;
   160cc:	e03ffa15 	stw	zero,-24(fp)
  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
   160d0:	e13fff17 	ldw	r4,-4(fp)
   160d4:	e17ffd17 	ldw	r5,-12(fp)
   160d8:	0006dcc0 	call	6dcc <ip_addr_isbroadcast>
   160dc:	10803fcc 	andi	r2,r2,255
   160e0:	10000326 	beq	r2,zero,160f0 <etharp_output+0x7c>
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
   160e4:	d0a00704 	addi	r2,gp,-32740
   160e8:	e0bffa15 	stw	r2,-24(fp)
   160ec:	00007106 	br	162b4 <etharp_output+0x240>
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
   160f0:	e0bfff17 	ldw	r2,-4(fp)
   160f4:	10c0000b 	ldhu	r3,0(r2)
   160f8:	1080008b 	ldhu	r2,2(r2)
   160fc:	1004943a 	slli	r2,r2,16
   16100:	10c4b03a 	or	r2,r2,r3
   16104:	10803c0c 	andi	r2,r2,240
   16108:	10803818 	cmpnei	r2,r2,224
   1610c:	10004e1e 	bne	r2,zero,16248 <etharp_output+0x1d4>
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = 0x01;
   16110:	00800044 	movi	r2,1
   16114:	e0bffb05 	stb	r2,-20(fp)
    mcastaddr.addr[1] = 0x00;
   16118:	e03ffb45 	stb	zero,-19(fp)
    mcastaddr.addr[2] = 0x5e;
   1611c:	00801784 	movi	r2,94
   16120:	e0bffb85 	stb	r2,-18(fp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
   16124:	e0bfff17 	ldw	r2,-4(fp)
   16128:	10c0000b 	ldhu	r3,0(r2)
   1612c:	1080008b 	ldhu	r2,2(r2)
   16130:	1004943a 	slli	r2,r2,16
   16134:	10c4b03a 	or	r2,r2,r3
   16138:	1006d63a 	srli	r3,r2,24
   1613c:	e0bfff17 	ldw	r2,-4(fp)
   16140:	1100000b 	ldhu	r4,0(r2)
   16144:	1080008b 	ldhu	r2,2(r2)
   16148:	1004943a 	slli	r2,r2,16
   1614c:	1104b03a 	or	r2,r2,r4
   16150:	1004d23a 	srli	r2,r2,8
   16154:	10bfc00c 	andi	r2,r2,65280
   16158:	1886b03a 	or	r3,r3,r2
   1615c:	e0bfff17 	ldw	r2,-4(fp)
   16160:	1100000b 	ldhu	r4,0(r2)
   16164:	1080008b 	ldhu	r2,2(r2)
   16168:	1004943a 	slli	r2,r2,16
   1616c:	1104b03a 	or	r2,r2,r4
   16170:	10bfc00c 	andi	r2,r2,65280
   16174:	1004923a 	slli	r2,r2,8
   16178:	1886b03a 	or	r3,r3,r2
   1617c:	e0bfff17 	ldw	r2,-4(fp)
   16180:	1100000b 	ldhu	r4,0(r2)
   16184:	1080008b 	ldhu	r2,2(r2)
   16188:	1004943a 	slli	r2,r2,16
   1618c:	1104b03a 	or	r2,r2,r4
   16190:	1004963a 	slli	r2,r2,24
   16194:	1884b03a 	or	r2,r3,r2
   16198:	1004d43a 	srli	r2,r2,16
   1619c:	10801fcc 	andi	r2,r2,127
   161a0:	e0bffbc5 	stb	r2,-17(fp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
   161a4:	e0bfff17 	ldw	r2,-4(fp)
   161a8:	10c0000b 	ldhu	r3,0(r2)
   161ac:	1080008b 	ldhu	r2,2(r2)
   161b0:	1004943a 	slli	r2,r2,16
   161b4:	10c4b03a 	or	r2,r2,r3
   161b8:	1006d63a 	srli	r3,r2,24
   161bc:	e0bfff17 	ldw	r2,-4(fp)
   161c0:	1100000b 	ldhu	r4,0(r2)
   161c4:	1080008b 	ldhu	r2,2(r2)
   161c8:	1004943a 	slli	r2,r2,16
   161cc:	1104b03a 	or	r2,r2,r4
   161d0:	1004d23a 	srli	r2,r2,8
   161d4:	10bfc00c 	andi	r2,r2,65280
   161d8:	1886b03a 	or	r3,r3,r2
   161dc:	e0bfff17 	ldw	r2,-4(fp)
   161e0:	1100000b 	ldhu	r4,0(r2)
   161e4:	1080008b 	ldhu	r2,2(r2)
   161e8:	1004943a 	slli	r2,r2,16
   161ec:	1104b03a 	or	r2,r2,r4
   161f0:	10bfc00c 	andi	r2,r2,65280
   161f4:	1004923a 	slli	r2,r2,8
   161f8:	1886b03a 	or	r3,r3,r2
   161fc:	e0bfff17 	ldw	r2,-4(fp)
   16200:	1100000b 	ldhu	r4,0(r2)
   16204:	1080008b 	ldhu	r2,2(r2)
   16208:	1004943a 	slli	r2,r2,16
   1620c:	1104b03a 	or	r2,r2,r4
   16210:	1004963a 	slli	r2,r2,24
   16214:	1884b03a 	or	r2,r3,r2
   16218:	1004d23a 	srli	r2,r2,8
   1621c:	e0bffc05 	stb	r2,-16(fp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
   16220:	e0bfff17 	ldw	r2,-4(fp)
   16224:	10c0000b 	ldhu	r3,0(r2)
   16228:	1080008b 	ldhu	r2,2(r2)
   1622c:	1004943a 	slli	r2,r2,16
   16230:	10c4b03a 	or	r2,r2,r3
   16234:	1004d63a 	srli	r2,r2,24
   16238:	e0bffc45 	stb	r2,-15(fp)
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
   1623c:	e0bffb04 	addi	r2,fp,-20
   16240:	e0bffa15 	stw	r2,-24(fp)
   16244:	00001b06 	br	162b4 <etharp_output+0x240>
  /* unicast destination IP address? */
  } else {
    /* outside local network? */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
   16248:	e0bfff17 	ldw	r2,-4(fp)
   1624c:	10c0000b 	ldhu	r3,0(r2)
   16250:	1080008b 	ldhu	r2,2(r2)
   16254:	1004943a 	slli	r2,r2,16
   16258:	10c4b03a 	or	r2,r2,r3
   1625c:	1007883a 	mov	r3,r2
   16260:	e0bffd17 	ldw	r2,-12(fp)
   16264:	10800117 	ldw	r2,4(r2)
   16268:	1886f03a 	xor	r3,r3,r2
   1626c:	e0bffd17 	ldw	r2,-12(fp)
   16270:	10800217 	ldw	r2,8(r2)
   16274:	1884703a 	and	r2,r3,r2
   16278:	10000926 	beq	r2,zero,162a0 <etharp_output+0x22c>
      /* interface has default gateway? */
      if (netif->gw.addr != 0) {
   1627c:	e0bffd17 	ldw	r2,-12(fp)
   16280:	10800317 	ldw	r2,12(r2)
   16284:	10000426 	beq	r2,zero,16298 <etharp_output+0x224>
        /* send to hardware address of default gateway IP address */
        ipaddr = &(netif->gw);
   16288:	e0bffd17 	ldw	r2,-12(fp)
   1628c:	10800304 	addi	r2,r2,12
   16290:	e0bfff15 	stw	r2,-4(fp)
   16294:	00000206 	br	162a0 <etharp_output+0x22c>
      /* no default gateway available */
      } else {
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
   16298:	00bfff04 	movi	r2,-4
   1629c:	00000c06 	br	162d0 <etharp_output+0x25c>
      }
    }
    /* queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, ipaddr, q);
   162a0:	e13ffd17 	ldw	r4,-12(fp)
   162a4:	e17fff17 	ldw	r5,-4(fp)
   162a8:	e1bffe17 	ldw	r6,-8(fp)
   162ac:	00162e40 	call	162e4 <etharp_query>
   162b0:	00000706 	br	162d0 <etharp_output+0x25c>
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
   162b4:	e0bffd17 	ldw	r2,-12(fp)
   162b8:	108009c4 	addi	r2,r2,39
   162bc:	e13ffd17 	ldw	r4,-12(fp)
   162c0:	e17ffe17 	ldw	r5,-8(fp)
   162c4:	100d883a 	mov	r6,r2
   162c8:	e1fffa17 	ldw	r7,-24(fp)
   162cc:	00157b00 	call	157b0 <etharp_send_ip>
}
   162d0:	e037883a 	mov	sp,fp
   162d4:	dfc00117 	ldw	ra,4(sp)
   162d8:	df000017 	ldw	fp,0(sp)
   162dc:	dec00204 	addi	sp,sp,8
   162e0:	f800283a 	ret

000162e4 <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
   162e4:	defff404 	addi	sp,sp,-48
   162e8:	dfc00b15 	stw	ra,44(sp)
   162ec:	df000a15 	stw	fp,40(sp)
   162f0:	df000a04 	addi	fp,sp,40
   162f4:	e13ffd15 	stw	r4,-12(fp)
   162f8:	e17ffe15 	stw	r5,-8(fp)
   162fc:	e1bfff15 	stw	r6,-4(fp)
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
   16300:	e0bffd17 	ldw	r2,-12(fp)
   16304:	108009c4 	addi	r2,r2,39
   16308:	e0bffa15 	stw	r2,-24(fp)
  err_t result = ERR_MEM;
   1630c:	00bfffc4 	movi	r2,-1
   16310:	e0bff605 	stb	r2,-40(fp)
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
   16314:	e13ffe17 	ldw	r4,-8(fp)
   16318:	e17ffd17 	ldw	r5,-12(fp)
   1631c:	0006dcc0 	call	6dcc <ip_addr_isbroadcast>
   16320:	10803fcc 	andi	r2,r2,255
   16324:	1000101e 	bne	r2,zero,16368 <etharp_query+0x84>
      ip_addr_ismulticast(ipaddr) ||
   16328:	e0bffe17 	ldw	r2,-8(fp)
   1632c:	10c0000b 	ldhu	r3,0(r2)
   16330:	1080008b 	ldhu	r2,2(r2)
   16334:	1004943a 	slli	r2,r2,16
   16338:	10c4b03a 	or	r2,r2,r3
   1633c:	10803c0c 	andi	r2,r2,240
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
   16340:	10803820 	cmpeqi	r2,r2,224
   16344:	1000081e 	bne	r2,zero,16368 <etharp_query+0x84>
      ip_addr_ismulticast(ipaddr) ||
   16348:	e0bffe17 	ldw	r2,-8(fp)
   1634c:	10000626 	beq	r2,zero,16368 <etharp_query+0x84>
      ip_addr_isany(ipaddr)) {
   16350:	e0bffe17 	ldw	r2,-8(fp)
   16354:	10c0000b 	ldhu	r3,0(r2)
   16358:	1080008b 	ldhu	r2,2(r2)
   1635c:	1004943a 	slli	r2,r2,16
   16360:	10c4b03a 	or	r2,r2,r3
   16364:	1000021e 	bne	r2,zero,16370 <etharp_query+0x8c>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
   16368:	00bffd84 	movi	r2,-10
   1636c:	0000e606 	br	16708 <etharp_query+0x424>

  /* find entry in ARP cache, ask to create entry if queueing packet */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_TRY_HARD, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_TRY_HARD);
   16370:	e13ffe17 	ldw	r4,-8(fp)
   16374:	01400044 	movi	r5,1
   16378:	00152a40 	call	152a4 <find_entry>
   1637c:	e0bffb05 	stb	r2,-20(fp)
#endif /* LWIP_NETIF_HWADDRHINT */

  /* could not find or create entry? */
  if (i < 0) {
   16380:	e0bffb07 	ldb	r2,-20(fp)
   16384:	10000c0e 	bge	r2,zero,163b8 <etharp_query+0xd4>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not create ARP entry\n"));
    if (q) {
   16388:	e0bfff17 	ldw	r2,-4(fp)
   1638c:	10000826 	beq	r2,zero,163b0 <etharp_query+0xcc>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: packet dropped\n"));
      ETHARP_STATS_INC(etharp.memerr);
   16390:	00800134 	movhi	r2,4
   16394:	10916104 	addi	r2,r2,17796
   16398:	1080090b 	ldhu	r2,36(r2)
   1639c:	10800044 	addi	r2,r2,1
   163a0:	1007883a 	mov	r3,r2
   163a4:	00800134 	movhi	r2,4
   163a8:	10916104 	addi	r2,r2,17796
   163ac:	10c0090d 	sth	r3,36(r2)
    }
    return (err_t)i;
   163b0:	e0bffb03 	ldbu	r2,-20(fp)
   163b4:	0000d406 	br	16708 <etharp_query+0x424>
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
   163b8:	e0bffb07 	ldb	r2,-20(fp)
   163bc:	00c00134 	movhi	r3,4
   163c0:	18d0cb04 	addi	r3,r3,17196
   163c4:	10800724 	muli	r2,r2,28
   163c8:	1885883a 	add	r2,r3,r2
   163cc:	10800404 	addi	r2,r2,16
   163d0:	10800017 	ldw	r2,0(r2)
   163d4:	1000081e 	bne	r2,zero,163f8 <etharp_query+0x114>
    arp_table[i].state = ETHARP_STATE_PENDING;
   163d8:	e0bffb07 	ldb	r2,-20(fp)
   163dc:	00c00134 	movhi	r3,4
   163e0:	18d0cb04 	addi	r3,r3,17196
   163e4:	10800724 	muli	r2,r2,28
   163e8:	1885883a 	add	r2,r3,r2
   163ec:	10800404 	addi	r2,r2,16
   163f0:	00c00044 	movi	r3,1
   163f4:	10c00015 	stw	r3,0(r2)
  }

  /* { i is either a STABLE or (new or existing) PENDING entry } */
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
   163f8:	e0bffb07 	ldb	r2,-20(fp)
   163fc:	00c00134 	movhi	r3,4
   16400:	18d0cb04 	addi	r3,r3,17196
   16404:	10800724 	muli	r2,r2,28
   16408:	1885883a 	add	r2,r3,r2
   1640c:	10800404 	addi	r2,r2,16
   16410:	10800017 	ldw	r2,0(r2)
   16414:	10800060 	cmpeqi	r2,r2,1
   16418:	1000121e 	bne	r2,zero,16464 <etharp_query+0x180>
   1641c:	e0bffb07 	ldb	r2,-20(fp)
   16420:	00c00134 	movhi	r3,4
   16424:	18d0cb04 	addi	r3,r3,17196
   16428:	10800724 	muli	r2,r2,28
   1642c:	1885883a 	add	r2,r3,r2
   16430:	10800404 	addi	r2,r2,16
   16434:	10800017 	ldw	r2,0(r2)
   16438:	108000a0 	cmpeqi	r2,r2,2
   1643c:	1000091e 	bne	r2,zero,16464 <etharp_query+0x180>
   16440:	010000f4 	movhi	r4,3
   16444:	213f5904 	addi	r4,r4,-668
   16448:	014000f4 	movhi	r5,3
   1644c:	297f9e04 	addi	r5,r5,-392
   16450:	0180e8c4 	movi	r6,931
   16454:	01c000f4 	movhi	r7,3
   16458:	39ff6604 	addi	r7,r7,-616
   1645c:	00170680 	call	17068 <printf>
   16460:	003fff06 	br	16460 <etharp_query+0x17c>
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
   16464:	e0bffb07 	ldb	r2,-20(fp)
   16468:	00c00134 	movhi	r3,4
   1646c:	18d0cb04 	addi	r3,r3,17196
   16470:	10800724 	muli	r2,r2,28
   16474:	1885883a 	add	r2,r3,r2
   16478:	10800404 	addi	r2,r2,16
   1647c:	10800017 	ldw	r2,0(r2)
   16480:	10800060 	cmpeqi	r2,r2,1
   16484:	1000021e 	bne	r2,zero,16490 <etharp_query+0x1ac>
   16488:	e0bfff17 	ldw	r2,-4(fp)
   1648c:	1000041e 	bne	r2,zero,164a0 <etharp_query+0x1bc>
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
   16490:	e13ffd17 	ldw	r4,-12(fp)
   16494:	e17ffe17 	ldw	r5,-8(fp)
   16498:	00169a00 	call	169a0 <etharp_request>
   1649c:	e0bff605 	stb	r2,-40(fp)
         etharp_query again could lead to sending the queued packets. */
    }
  }
  
  /* packet given? */
  if (q != NULL) {
   164a0:	e0bfff17 	ldw	r2,-4(fp)
   164a4:	10009726 	beq	r2,zero,16704 <etharp_query+0x420>
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
   164a8:	e0bffb07 	ldb	r2,-20(fp)
   164ac:	00c00134 	movhi	r3,4
   164b0:	18d0cb04 	addi	r3,r3,17196
   164b4:	10800724 	muli	r2,r2,28
   164b8:	1885883a 	add	r2,r3,r2
   164bc:	10800404 	addi	r2,r2,16
   164c0:	10800017 	ldw	r2,0(r2)
   164c4:	10800098 	cmpnei	r2,r2,2
   164c8:	10000d1e 	bne	r2,zero,16500 <etharp_query+0x21c>
      /* we have a valid IP->Ethernet address mapping */
      /* send the packet */
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
   164cc:	e0bffb07 	ldb	r2,-20(fp)
   164d0:	10800724 	muli	r2,r2,28
   164d4:	10c00204 	addi	r3,r2,8
   164d8:	00800134 	movhi	r2,4
   164dc:	1090cb04 	addi	r2,r2,17196
   164e0:	1885883a 	add	r2,r3,r2
   164e4:	e13ffd17 	ldw	r4,-12(fp)
   164e8:	e17fff17 	ldw	r5,-4(fp)
   164ec:	e1bffa17 	ldw	r6,-24(fp)
   164f0:	100f883a 	mov	r7,r2
   164f4:	00157b00 	call	157b0 <etharp_send_ip>
   164f8:	e0bff605 	stb	r2,-40(fp)
   164fc:	00008106 	br	16704 <etharp_query+0x420>
    /* pending entry? (either just created or already pending */
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
   16500:	e0bffb07 	ldb	r2,-20(fp)
   16504:	00c00134 	movhi	r3,4
   16508:	18d0cb04 	addi	r3,r3,17196
   1650c:	10800724 	muli	r2,r2,28
   16510:	1885883a 	add	r2,r3,r2
   16514:	10800404 	addi	r2,r2,16
   16518:	10800017 	ldw	r2,0(r2)
   1651c:	10800058 	cmpnei	r2,r2,1
   16520:	1000781e 	bne	r2,zero,16704 <etharp_query+0x420>
#if ARP_QUEUEING /* queue the given q packet */
      struct pbuf *p;
      int copy_needed = 0;
   16524:	e03ff815 	stw	zero,-32(fp)
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
   16528:	e0bfff17 	ldw	r2,-4(fp)
   1652c:	e0bff715 	stw	r2,-36(fp)
      while (p) {
   16530:	00001e06 	br	165ac <etharp_query+0x2c8>
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
   16534:	e0bff717 	ldw	r2,-36(fp)
   16538:	10c0028b 	ldhu	r3,10(r2)
   1653c:	e0bff717 	ldw	r2,-36(fp)
   16540:	1080020b 	ldhu	r2,8(r2)
   16544:	18ffffcc 	andi	r3,r3,65535
   16548:	10bfffcc 	andi	r2,r2,65535
   1654c:	18800c1e 	bne	r3,r2,16580 <etharp_query+0x29c>
   16550:	e0bff717 	ldw	r2,-36(fp)
   16554:	10800017 	ldw	r2,0(r2)
   16558:	10000926 	beq	r2,zero,16580 <etharp_query+0x29c>
   1655c:	010000f4 	movhi	r4,3
   16560:	213f5904 	addi	r4,r4,-668
   16564:	014000f4 	movhi	r5,3
   16568:	297fa804 	addi	r5,r5,-352
   1656c:	0180f084 	movi	r6,962
   16570:	01c000f4 	movhi	r7,3
   16574:	39ff6604 	addi	r7,r7,-616
   16578:	00170680 	call	17068 <printf>
   1657c:	003fff06 	br	1657c <etharp_query+0x298>
        if(p->type != PBUF_ROM) {
   16580:	e0bff717 	ldw	r2,-36(fp)
   16584:	10800303 	ldbu	r2,12(r2)
   16588:	10803fcc 	andi	r2,r2,255
   1658c:	10800060 	cmpeqi	r2,r2,1
   16590:	1000031e 	bne	r2,zero,165a0 <etharp_query+0x2bc>
          copy_needed = 1;
   16594:	00800044 	movi	r2,1
   16598:	e0bff815 	stw	r2,-32(fp)
          break;
   1659c:	00000506 	br	165b4 <etharp_query+0x2d0>
        }
        p = p->next;
   165a0:	e0bff717 	ldw	r2,-36(fp)
   165a4:	10800017 	ldw	r2,0(r2)
   165a8:	e0bff715 	stw	r2,-36(fp)
      int copy_needed = 0;
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
   165ac:	e0bff717 	ldw	r2,-36(fp)
   165b0:	103fe01e 	bne	r2,zero,16534 <etharp_query+0x250>
          copy_needed = 1;
          break;
        }
        p = p->next;
      }
      if(copy_needed) {
   165b4:	e0bff817 	ldw	r2,-32(fp)
   165b8:	10001526 	beq	r2,zero,16610 <etharp_query+0x32c>
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
   165bc:	e0bff717 	ldw	r2,-36(fp)
   165c0:	1080020b 	ldhu	r2,8(r2)
   165c4:	10bfffcc 	andi	r2,r2,65535
   165c8:	010000c4 	movi	r4,3
   165cc:	100b883a 	mov	r5,r2
   165d0:	000d883a 	mov	r6,zero
   165d4:	00097cc0 	call	97cc <pbuf_alloc>
   165d8:	e0bff715 	stw	r2,-36(fp)
        if(p != NULL) {
   165dc:	e0bff717 	ldw	r2,-36(fp)
   165e0:	10000f26 	beq	r2,zero,16620 <etharp_query+0x33c>
          if (pbuf_copy(p, q) != ERR_OK) {
   165e4:	e13ff717 	ldw	r4,-36(fp)
   165e8:	e17fff17 	ldw	r5,-4(fp)
   165ec:	000a68c0 	call	a68c <pbuf_copy>
   165f0:	10803fcc 	andi	r2,r2,255
   165f4:	1080201c 	xori	r2,r2,128
   165f8:	10bfe004 	addi	r2,r2,-128
   165fc:	10000826 	beq	r2,zero,16620 <etharp_query+0x33c>
            pbuf_free(p);
   16600:	e13ff717 	ldw	r4,-36(fp)
   16604:	000a1880 	call	a188 <pbuf_free>
            p = NULL;
   16608:	e03ff715 	stw	zero,-36(fp)
   1660c:	00000406 	br	16620 <etharp_query+0x33c>
          }
        }
      } else {
        /* referencing the old pbuf is enough */
        p = q;
   16610:	e0bfff17 	ldw	r2,-4(fp)
   16614:	e0bff715 	stw	r2,-36(fp)
        pbuf_ref(p);
   16618:	e13ff717 	ldw	r4,-36(fp)
   1661c:	000a3a00 	call	a3a0 <pbuf_ref>
      }
      /* packet could be taken over? */
      if (p != NULL) {
   16620:	e0bff717 	ldw	r2,-36(fp)
   16624:	10002f26 	beq	r2,zero,166e4 <etharp_query+0x400>
        /* queue packet ... */
        struct etharp_q_entry *new_entry;
        /* allocate a new arp queue entry */
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
   16628:	01000184 	movi	r4,6
   1662c:	0008f0c0 	call	8f0c <memp_malloc>
   16630:	e0bffc15 	stw	r2,-16(fp)
        if (new_entry != NULL) {
   16634:	e0bffc17 	ldw	r2,-16(fp)
   16638:	10002726 	beq	r2,zero,166d8 <etharp_query+0x3f4>
          new_entry->next = 0;
   1663c:	e0bffc17 	ldw	r2,-16(fp)
   16640:	10000015 	stw	zero,0(r2)
          new_entry->p = p;
   16644:	e0bffc17 	ldw	r2,-16(fp)
   16648:	e0fff717 	ldw	r3,-36(fp)
   1664c:	10c00115 	stw	r3,4(r2)
          if(arp_table[i].q != NULL) {
   16650:	e0bffb07 	ldb	r2,-20(fp)
   16654:	00c00134 	movhi	r3,4
   16658:	18d0cb04 	addi	r3,r3,17196
   1665c:	10800724 	muli	r2,r2,28
   16660:	1885883a 	add	r2,r3,r2
   16664:	10800017 	ldw	r2,0(r2)
   16668:	10001226 	beq	r2,zero,166b4 <etharp_query+0x3d0>
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
   1666c:	e0bffb07 	ldb	r2,-20(fp)
   16670:	00c00134 	movhi	r3,4
   16674:	18d0cb04 	addi	r3,r3,17196
   16678:	10800724 	muli	r2,r2,28
   1667c:	1885883a 	add	r2,r3,r2
   16680:	10800017 	ldw	r2,0(r2)
   16684:	e0bff915 	stw	r2,-28(fp)
            while (r->next != NULL) {
   16688:	00000306 	br	16698 <etharp_query+0x3b4>
              r = r->next;
   1668c:	e0bff917 	ldw	r2,-28(fp)
   16690:	10800017 	ldw	r2,0(r2)
   16694:	e0bff915 	stw	r2,-28(fp)
          new_entry->p = p;
          if(arp_table[i].q != NULL) {
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
            while (r->next != NULL) {
   16698:	e0bff917 	ldw	r2,-28(fp)
   1669c:	10800017 	ldw	r2,0(r2)
   166a0:	103ffa1e 	bne	r2,zero,1668c <etharp_query+0x3a8>
              r = r->next;
            }
            r->next = new_entry;
   166a4:	e0bff917 	ldw	r2,-28(fp)
   166a8:	e0fffc17 	ldw	r3,-16(fp)
   166ac:	10c00015 	stw	r3,0(r2)
   166b0:	00000706 	br	166d0 <etharp_query+0x3ec>
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
   166b4:	e0bffb07 	ldb	r2,-20(fp)
   166b8:	00c00134 	movhi	r3,4
   166bc:	18d0cb04 	addi	r3,r3,17196
   166c0:	10800724 	muli	r2,r2,28
   166c4:	1885883a 	add	r2,r3,r2
   166c8:	e0fffc17 	ldw	r3,-16(fp)
   166cc:	10c00015 	stw	r3,0(r2)
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
   166d0:	e03ff605 	stb	zero,-40(fp)
   166d4:	00000b06 	br	16704 <etharp_query+0x420>
        } else {
          /* the pool MEMP_ARP_QUEUE is empty */
          pbuf_free(p);
   166d8:	e13ff717 	ldw	r4,-36(fp)
   166dc:	000a1880 	call	a188 <pbuf_free>
   166e0:	00000806 	br	16704 <etharp_query+0x420>
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
          /* { result == ERR_MEM } through initialization */
        }
      } else {
        ETHARP_STATS_INC(etharp.memerr);
   166e4:	00800134 	movhi	r2,4
   166e8:	10916104 	addi	r2,r2,17796
   166ec:	1080090b 	ldhu	r2,36(r2)
   166f0:	10800044 	addi	r2,r2,1
   166f4:	1007883a 	mov	r3,r2
   166f8:	00800134 	movhi	r2,4
   166fc:	10916104 	addi	r2,r2,17796
   16700:	10c0090d 	sth	r3,36(r2)
      /* { result == ERR_MEM } through initialization */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: Ethernet destination address unknown, queueing disabled, packet %p dropped\n", (void *)q));
#endif
    }
  }
  return result;
   16704:	e0bff603 	ldbu	r2,-40(fp)
}
   16708:	e037883a 	mov	sp,fp
   1670c:	dfc00117 	ldw	ra,4(sp)
   16710:	df000017 	ldw	fp,0(sp)
   16714:	dec00204 	addi	sp,sp,8
   16718:	f800283a 	ret

0001671c <etharp_raw>:
etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
           const struct eth_addr *ethdst_addr,
           const struct eth_addr *hwsrc_addr, const struct ip_addr *ipsrc_addr,
           const struct eth_addr *hwdst_addr, const struct ip_addr *ipdst_addr,
           const u16_t opcode)
{
   1671c:	defff504 	addi	sp,sp,-44
   16720:	dfc00a15 	stw	ra,40(sp)
   16724:	df000915 	stw	fp,36(sp)
   16728:	df000904 	addi	fp,sp,36
   1672c:	e13ffb15 	stw	r4,-20(fp)
   16730:	e17ffc15 	stw	r5,-16(fp)
   16734:	e1bffd15 	stw	r6,-12(fp)
   16738:	e1fffe15 	stw	r7,-8(fp)
   1673c:	e0800517 	ldw	r2,20(fp)
   16740:	e0bfff0d 	sth	r2,-4(fp)
  struct pbuf *p;
  err_t result = ERR_OK;
   16744:	e03ff745 	stb	zero,-35(fp)
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
   16748:	010000c4 	movi	r4,3
   1674c:	01400b04 	movi	r5,44
   16750:	000d883a 	mov	r6,zero
   16754:	00097cc0 	call	97cc <pbuf_alloc>
   16758:	e0bff815 	stw	r2,-32(fp)
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
   1675c:	e0bff817 	ldw	r2,-32(fp)
   16760:	10000a1e 	bne	r2,zero,1678c <etharp_raw+0x70>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
   16764:	00800134 	movhi	r2,4
   16768:	10916104 	addi	r2,r2,17796
   1676c:	1080090b 	ldhu	r2,36(r2)
   16770:	10800044 	addi	r2,r2,1
   16774:	1007883a 	mov	r3,r2
   16778:	00800134 	movhi	r2,4
   1677c:	10916104 	addi	r2,r2,17796
   16780:	10c0090d 	sth	r3,36(r2)
    return ERR_MEM;
   16784:	00bfffc4 	movi	r2,-1
   16788:	00008006 	br	1698c <etharp_raw+0x270>
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
   1678c:	e0bff817 	ldw	r2,-32(fp)
   16790:	1080028b 	ldhu	r2,10(r2)
   16794:	10bfffcc 	andi	r2,r2,65535
   16798:	10800b28 	cmpgeui	r2,r2,44
   1679c:	1000091e 	bne	r2,zero,167c4 <etharp_raw+0xa8>
   167a0:	010000f4 	movhi	r4,3
   167a4:	213f5904 	addi	r4,r4,-668
   167a8:	014000f4 	movhi	r5,3
   167ac:	297faf04 	addi	r5,r5,-324
   167b0:	01810bc4 	movi	r6,1071
   167b4:	01c000f4 	movhi	r7,3
   167b8:	39ff6604 	addi	r7,r7,-616
   167bc:	00170680 	call	17068 <printf>
   167c0:	003fff06 	br	167c0 <etharp_raw+0xa4>
              (p->len >= SIZEOF_ETHARP_PACKET));

  ethhdr = p->payload;
   167c4:	e0bff817 	ldw	r2,-32(fp)
   167c8:	10800117 	ldw	r2,4(r2)
   167cc:	e0bff915 	stw	r2,-28(fp)
  hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
   167d0:	e0bff917 	ldw	r2,-28(fp)
   167d4:	10800404 	addi	r2,r2,16
   167d8:	e0bffa15 	stw	r2,-24(fp)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
   167dc:	e0bfff0b 	ldhu	r2,-4(fp)
   167e0:	1004d23a 	srli	r2,r2,8
   167e4:	1007883a 	mov	r3,r2
   167e8:	e0bfff0b 	ldhu	r2,-4(fp)
   167ec:	1004923a 	slli	r2,r2,8
   167f0:	1884b03a 	or	r2,r3,r2
   167f4:	1007883a 	mov	r3,r2
   167f8:	e0bffa17 	ldw	r2,-24(fp)
   167fc:	10c0018d 	sth	r3,6(r2)

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
   16800:	e0bffb17 	ldw	r2,-20(fp)
   16804:	10800983 	ldbu	r2,38(r2)
   16808:	10803fcc 	andi	r2,r2,255
   1680c:	108001a0 	cmpeqi	r2,r2,6
   16810:	1000091e 	bne	r2,zero,16838 <etharp_raw+0x11c>
   16814:	010000f4 	movhi	r4,3
   16818:	213f5904 	addi	r4,r4,-668
   1681c:	014000f4 	movhi	r5,3
   16820:	297f7f04 	addi	r5,r5,-516
   16824:	01810dc4 	movi	r6,1079
   16828:	01c000f4 	movhi	r7,3
   1682c:	39ff6604 	addi	r7,r7,-616
   16830:	00170680 	call	17068 <printf>
   16834:	003fff06 	br	16834 <etharp_raw+0x118>
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
   16838:	00800184 	movi	r2,6
   1683c:	e0bff705 	stb	r2,-36(fp)
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
   16840:	00002606 	br	168dc <etharp_raw+0x1c0>
    k--;
   16844:	e0bff703 	ldbu	r2,-36(fp)
   16848:	10bfffc4 	addi	r2,r2,-1
   1684c:	e0bff705 	stb	r2,-36(fp)
    /* Write the ARP MAC-Addresses */
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
   16850:	e0bff703 	ldbu	r2,-36(fp)
   16854:	e0fff703 	ldbu	r3,-36(fp)
   16858:	e13ffe17 	ldw	r4,-8(fp)
   1685c:	20c7883a 	add	r3,r4,r3
   16860:	18c00003 	ldbu	r3,0(r3)
   16864:	e13ffa17 	ldw	r4,-24(fp)
   16868:	2085883a 	add	r2,r4,r2
   1686c:	10800204 	addi	r2,r2,8
   16870:	10c00005 	stb	r3,0(r2)
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
   16874:	e0bff703 	ldbu	r2,-36(fp)
   16878:	e0fff703 	ldbu	r3,-36(fp)
   1687c:	e1000317 	ldw	r4,12(fp)
   16880:	20c7883a 	add	r3,r4,r3
   16884:	18c00003 	ldbu	r3,0(r3)
   16888:	e13ffa17 	ldw	r4,-24(fp)
   1688c:	2085883a 	add	r2,r4,r2
   16890:	10800404 	addi	r2,r2,16
   16894:	10c00085 	stb	r3,2(r2)
    /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
    ethhdr->dest.addr[k] = ethdst_hwaddr[k];
#else  /* LWIP_AUTOIP */
    ethhdr->dest.addr[k] = ethdst_addr->addr[k];
   16898:	e0bff703 	ldbu	r2,-36(fp)
   1689c:	e0fff703 	ldbu	r3,-36(fp)
   168a0:	e13ffd17 	ldw	r4,-12(fp)
   168a4:	20c7883a 	add	r3,r4,r3
   168a8:	18c00003 	ldbu	r3,0(r3)
   168ac:	e13ff917 	ldw	r4,-28(fp)
   168b0:	2085883a 	add	r2,r4,r2
   168b4:	10c00085 	stb	r3,2(r2)
#endif /* LWIP_AUTOIP */
    ethhdr->src.addr[k]  = ethsrc_addr->addr[k];
   168b8:	e0bff703 	ldbu	r2,-36(fp)
   168bc:	e0fff703 	ldbu	r3,-36(fp)
   168c0:	e13ffc17 	ldw	r4,-16(fp)
   168c4:	20c7883a 	add	r3,r4,r3
   168c8:	18c00003 	ldbu	r3,0(r3)
   168cc:	e13ff917 	ldw	r4,-28(fp)
   168d0:	2085883a 	add	r2,r4,r2
   168d4:	10800204 	addi	r2,r2,8
   168d8:	10c00005 	stb	r3,0(r2)
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
   168dc:	e0bff703 	ldbu	r2,-36(fp)
   168e0:	103fd81e 	bne	r2,zero,16844 <etharp_raw+0x128>
#else  /* LWIP_AUTOIP */
    ethhdr->dest.addr[k] = ethdst_addr->addr[k];
#endif /* LWIP_AUTOIP */
    ethhdr->src.addr[k]  = ethsrc_addr->addr[k];
  }
  hdr->sipaddr = *(struct ip_addr2 *)ipsrc_addr;
   168e4:	e0bffa17 	ldw	r2,-24(fp)
   168e8:	e0c00217 	ldw	r3,8(fp)
   168ec:	1900000b 	ldhu	r4,0(r3)
   168f0:	1100038d 	sth	r4,14(r2)
   168f4:	18c0008b 	ldhu	r3,2(r3)
   168f8:	10c0040d 	sth	r3,16(r2)
  hdr->dipaddr = *(struct ip_addr2 *)ipdst_addr;
   168fc:	e0bffa17 	ldw	r2,-24(fp)
   16900:	e0c00417 	ldw	r3,16(fp)
   16904:	1900000b 	ldhu	r4,0(r3)
   16908:	1100060d 	sth	r4,24(r2)
   1690c:	18c0008b 	ldhu	r3,2(r3)
   16910:	10c0068d 	sth	r3,26(r2)

  hdr->hwtype = htons(HWTYPE_ETHERNET);
   16914:	e0bffa17 	ldw	r2,-24(fp)
   16918:	00c04004 	movi	r3,256
   1691c:	10c0000d 	sth	r3,0(r2)
  hdr->proto = htons(ETHTYPE_IP);
   16920:	e0bffa17 	ldw	r2,-24(fp)
   16924:	00c00204 	movi	r3,8
   16928:	10c0008d 	sth	r3,2(r2)
  /* set hwlen and protolen together */
  hdr->_hwlen_protolen = htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr));
   1692c:	e0bffa17 	ldw	r2,-24(fp)
   16930:	00c10184 	movi	r3,1030
   16934:	10c0010d 	sth	r3,4(r2)

  ethhdr->type = htons(ETHTYPE_ARP);
   16938:	e0bff917 	ldw	r2,-28(fp)
   1693c:	00c18204 	movi	r3,1544
   16940:	10c0038d 	sth	r3,14(r2)
  /* send ARP query */
  result = netif->linkoutput(netif, p);
   16944:	e0bffb17 	ldw	r2,-20(fp)
   16948:	10800617 	ldw	r2,24(r2)
   1694c:	e13ffb17 	ldw	r4,-20(fp)
   16950:	e17ff817 	ldw	r5,-32(fp)
   16954:	103ee83a 	callr	r2
   16958:	e0bff745 	stb	r2,-35(fp)
  ETHARP_STATS_INC(etharp.xmit);
   1695c:	00800134 	movhi	r2,4
   16960:	10916104 	addi	r2,r2,17796
   16964:	1080060b 	ldhu	r2,24(r2)
   16968:	10800044 	addi	r2,r2,1
   1696c:	1007883a 	mov	r3,r2
   16970:	00800134 	movhi	r2,4
   16974:	10916104 	addi	r2,r2,17796
   16978:	10c0060d 	sth	r3,24(r2)
  /* free ARP query packet */
  pbuf_free(p);
   1697c:	e13ff817 	ldw	r4,-32(fp)
   16980:	000a1880 	call	a188 <pbuf_free>
  p = NULL;
   16984:	e03ff815 	stw	zero,-32(fp)
  /* could not allocate pbuf for ARP request */

  return result;
   16988:	e0bff743 	ldbu	r2,-35(fp)
}
   1698c:	e037883a 	mov	sp,fp
   16990:	dfc00117 	ldw	ra,4(sp)
   16994:	df000017 	ldw	fp,0(sp)
   16998:	dec00204 	addi	sp,sp,8
   1699c:	f800283a 	ret

000169a0 <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
   169a0:	defff804 	addi	sp,sp,-32
   169a4:	dfc00715 	stw	ra,28(sp)
   169a8:	df000615 	stw	fp,24(sp)
   169ac:	df000604 	addi	fp,sp,24
   169b0:	e13ffe15 	stw	r4,-8(fp)
   169b4:	e17fff15 	stw	r5,-4(fp)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
   169b8:	e0bffe17 	ldw	r2,-8(fp)
   169bc:	10c009c4 	addi	r3,r2,39
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
   169c0:	e0bffe17 	ldw	r2,-8(fp)
   169c4:	108009c4 	addi	r2,r2,39
   169c8:	e13ffe17 	ldw	r4,-8(fp)
   169cc:	21000104 	addi	r4,r4,4
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
   169d0:	d9000015 	stw	r4,0(sp)
   169d4:	d1200884 	addi	r4,gp,-32734
   169d8:	d9000115 	stw	r4,4(sp)
   169dc:	e13fff17 	ldw	r4,-4(fp)
   169e0:	d9000215 	stw	r4,8(sp)
   169e4:	01000044 	movi	r4,1
   169e8:	d9000315 	stw	r4,12(sp)
   169ec:	e13ffe17 	ldw	r4,-8(fp)
   169f0:	180b883a 	mov	r5,r3
   169f4:	d1a00704 	addi	r6,gp,-32740
   169f8:	100f883a 	mov	r7,r2
   169fc:	001671c0 	call	1671c <etharp_raw>
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
   16a00:	e037883a 	mov	sp,fp
   16a04:	dfc00117 	ldw	ra,4(sp)
   16a08:	df000017 	ldw	fp,0(sp)
   16a0c:	dec00204 	addi	sp,sp,8
   16a10:	f800283a 	ret

00016a14 <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
   16a14:	defffa04 	addi	sp,sp,-24
   16a18:	dfc00515 	stw	ra,20(sp)
   16a1c:	df000415 	stw	fp,16(sp)
   16a20:	df000404 	addi	fp,sp,16
   16a24:	e13ffe15 	stw	r4,-8(fp)
   16a28:	e17fff15 	stw	r5,-4(fp)
  struct eth_hdr* ethhdr;
  u16_t type;

  /* points to packet payload, which starts with an Ethernet header */
  ethhdr = p->payload;
   16a2c:	e0bffe17 	ldw	r2,-8(fp)
   16a30:	10800117 	ldw	r2,4(r2)
   16a34:	e0bffc15 	stw	r2,-16(fp)
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  type = htons(ethhdr->type);
   16a38:	e0bffc17 	ldw	r2,-16(fp)
   16a3c:	1080038b 	ldhu	r2,14(r2)
   16a40:	10bfffcc 	andi	r2,r2,65535
   16a44:	1004d23a 	srli	r2,r2,8
   16a48:	1007883a 	mov	r3,r2
   16a4c:	e0bffc17 	ldw	r2,-16(fp)
   16a50:	1080038b 	ldhu	r2,14(r2)
   16a54:	10bfffcc 	andi	r2,r2,65535
   16a58:	1004923a 	slli	r2,r2,8
   16a5c:	1884b03a 	or	r2,r3,r2
   16a60:	e0bffd0d 	sth	r2,-12(fp)
#endif /* ETHARP_VLAN_CHECK */
    type = htons(vlan->tpid);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  switch (type) {
   16a64:	e0bffd0b 	ldhu	r2,-12(fp)
   16a68:	10c20020 	cmpeqi	r3,r2,2048
   16a6c:	1800031e 	bne	r3,zero,16a7c <ethernet_input+0x68>
   16a70:	108201a0 	cmpeqi	r2,r2,2054
   16a74:	1000161e 	bne	r2,zero,16ad0 <ethernet_input+0xbc>
   16a78:	00001c06 	br	16aec <ethernet_input+0xd8>
    /* IP packet? */
    case ETHTYPE_IP:
#if ETHARP_TRUST_IP_MAC
      /* update ARP table */
      etharp_ip_input(netif, p);
   16a7c:	e13fff17 	ldw	r4,-4(fp)
   16a80:	e17ffe17 	ldw	r5,-8(fp)
   16a84:	0015ba40 	call	15ba4 <etharp_ip_input>
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -(s16_t)SIZEOF_ETH_HDR)) {
   16a88:	e13ffe17 	ldw	r4,-8(fp)
   16a8c:	017ffc04 	movi	r5,-16
   16a90:	0009f900 	call	9f90 <pbuf_header>
   16a94:	10803fcc 	andi	r2,r2,255
   16a98:	10000926 	beq	r2,zero,16ac0 <ethernet_input+0xac>
        LWIP_ASSERT("Can't move over header in packet", 0);
   16a9c:	010000f4 	movhi	r4,3
   16aa0:	213f5904 	addi	r4,r4,-668
   16aa4:	014000f4 	movhi	r5,3
   16aa8:	297fbc04 	addi	r5,r5,-272
   16aac:	01812884 	movi	r6,1186
   16ab0:	01c000f4 	movhi	r7,3
   16ab4:	39ff6604 	addi	r7,r7,-616
   16ab8:	00170680 	call	17068 <printf>
   16abc:	003fff06 	br	16abc <ethernet_input+0xa8>
        pbuf_free(p);
        p = NULL;
      } else {
        /* pass to IP layer */
        ip_input(p, netif);
   16ac0:	e13ffe17 	ldw	r4,-8(fp)
   16ac4:	e17fff17 	ldw	r5,-4(fp)
   16ac8:	00062ac0 	call	62ac <ip_input>
      }
      break;
   16acc:	00001b06 	br	16b3c <ethernet_input+0x128>
      
    case ETHTYPE_ARP:
      /* pass p to ARP module */
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
   16ad0:	e0bfff17 	ldw	r2,-4(fp)
   16ad4:	108009c4 	addi	r2,r2,39
   16ad8:	e13fff17 	ldw	r4,-4(fp)
   16adc:	100b883a 	mov	r5,r2
   16ae0:	e1bffe17 	ldw	r6,-8(fp)
   16ae4:	0015c740 	call	15c74 <etharp_arp_input>
      break;
   16ae8:	00001406 	br	16b3c <ethernet_input+0x128>
      pppoe_data_input(netif, p);
      break;
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
   16aec:	00800134 	movhi	r2,4
   16af0:	10916104 	addi	r2,r2,17796
   16af4:	10800a0b 	ldhu	r2,40(r2)
   16af8:	10800044 	addi	r2,r2,1
   16afc:	1007883a 	mov	r3,r2
   16b00:	00800134 	movhi	r2,4
   16b04:	10916104 	addi	r2,r2,17796
   16b08:	10c00a0d 	sth	r3,40(r2)
      ETHARP_STATS_INC(etharp.drop);
   16b0c:	00800134 	movhi	r2,4
   16b10:	10916104 	addi	r2,r2,17796
   16b14:	1080078b 	ldhu	r2,30(r2)
   16b18:	10800044 	addi	r2,r2,1
   16b1c:	1007883a 	mov	r3,r2
   16b20:	00800134 	movhi	r2,4
   16b24:	10916104 	addi	r2,r2,17796
   16b28:	10c0078d 	sth	r3,30(r2)
      pbuf_free(p);
   16b2c:	e13ffe17 	ldw	r4,-8(fp)
   16b30:	000a1880 	call	a188 <pbuf_free>
      p = NULL;
   16b34:	e03ffe15 	stw	zero,-8(fp)
      break;
   16b38:	0001883a 	nop
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
   16b3c:	0005883a 	mov	r2,zero
}
   16b40:	e037883a 	mov	sp,fp
   16b44:	dfc00117 	ldw	ra,4(sp)
   16b48:	df000017 	ldw	fp,0(sp)
   16b4c:	dec00204 	addi	sp,sp,8
   16b50:	f800283a 	ret

00016b54 <lwipAlarmCallback>:
static alt_u32  lwipTicksPer250mS;
static alt_u32  lwip250mStimer;

//  Alarm callback function.
alt_u32 lwipAlarmCallback(void* context)
{
   16b54:	defffe04 	addi	sp,sp,-8
   16b58:	df000115 	stw	fp,4(sp)
   16b5c:	df000104 	addi	fp,sp,4
   16b60:	e13fff15 	stw	r4,-4(fp)
    lwipProcessTimerFlag = 1;          //  Set flag to process timers
   16b64:	00800044 	movi	r2,1
   16b68:	d0a8e615 	stw	r2,-23656(gp)
    return lwipTicksPer250mS;
   16b6c:	d0a8e717 	ldw	r2,-23652(gp)
}
   16b70:	e037883a 	mov	sp,fp
   16b74:	df000017 	ldw	fp,0(sp)
   16b78:	dec00104 	addi	sp,sp,4
   16b7c:	f800283a 	ret

00016b80 <main>:

//  Define netif for lwIP
struct netif    alteraTseNetif;

int main()
{
   16b80:	defffb04 	addi	sp,sp,-20
   16b84:	dfc00415 	stw	ra,16(sp)
   16b88:	df000315 	stw	fp,12(sp)
   16b8c:	df000304 	addi	fp,sp,12
static struct ip_addr   ip_zero = { 0 };
void httpd_init(void);

    printf("Running...\n");
   16b90:	010000f4 	movhi	r4,3
   16b94:	213fc504 	addi	r4,r4,-236
   16b98:	00172f80 	call	172f8 <puts>
    lwip250mStimer = 0;
   16b9c:	d028e815 	stw	zero,-23648(gp)
    lwipProcessTimerFlag = 0;
   16ba0:	d028e615 	stw	zero,-23656(gp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
   16ba4:	008000f4 	movhi	r2,3
   16ba8:	1099e104 	addi	r2,r2,26500
   16bac:	10800017 	ldw	r2,0(r2)
    lwipTicksPer250mS = alt_ticks_per_second() / 4;
   16bb0:	1004d0ba 	srli	r2,r2,2
   16bb4:	d0a8e715 	stw	r2,-23652(gp)
    if (alt_alarm_start (&lwipAlarm, lwipTicksPer250mS, lwipAlarmCallback, NULL) < 0)
   16bb8:	d0a8e717 	ldw	r2,-23652(gp)
   16bbc:	01000134 	movhi	r4,4
   16bc0:	21111104 	addi	r4,r4,17476
   16bc4:	100b883a 	mov	r5,r2
   16bc8:	01800074 	movhi	r6,1
   16bcc:	319ad504 	addi	r6,r6,27476
   16bd0:	000f883a 	mov	r7,zero
   16bd4:	002055c0 	call	2055c <alt_alarm_start>
   16bd8:	1000040e 	bge	r2,zero,16bec <main+0x6c>
        {
        printf ("System clock is required!\n");
   16bdc:	010000f4 	movhi	r4,3
   16be0:	213fc804 	addi	r4,r4,-224
   16be4:	00172f80 	call	172f8 <puts>
        for(;;);
   16be8:	003fff06 	br	16be8 <main+0x68>
        }
    
    //  Load platform specific MAC address into netif
    alteraTseNetif.hwaddr[0] = 0x00;
   16bec:	00800134 	movhi	r2,4
   16bf0:	1091a704 	addi	r2,r2,18076
   16bf4:	100009c5 	stb	zero,39(r2)
    alteraTseNetif.hwaddr[1] = 0x07;
   16bf8:	00800134 	movhi	r2,4
   16bfc:	1091a704 	addi	r2,r2,18076
   16c00:	00c001c4 	movi	r3,7
   16c04:	10c00a05 	stb	r3,40(r2)
    alteraTseNetif.hwaddr[2] = 0xab;
   16c08:	00800134 	movhi	r2,4
   16c0c:	1091a704 	addi	r2,r2,18076
   16c10:	00ffeac4 	movi	r3,-85
   16c14:	10c00a45 	stb	r3,41(r2)
    alteraTseNetif.hwaddr[3] = 0xf0;
   16c18:	00800134 	movhi	r2,4
   16c1c:	1091a704 	addi	r2,r2,18076
   16c20:	00fffc04 	movi	r3,-16
   16c24:	10c00a85 	stb	r3,42(r2)
    alteraTseNetif.hwaddr[4] = 0x0d;
   16c28:	00800134 	movhi	r2,4
   16c2c:	1091a704 	addi	r2,r2,18076
   16c30:	00c00344 	movi	r3,13
   16c34:	10c00ac5 	stb	r3,43(r2)
    alteraTseNetif.hwaddr[5] = 0xba;
   16c38:	00800134 	movhi	r2,4
   16c3c:	1091a704 	addi	r2,r2,18076
   16c40:	00ffee84 	movi	r3,-70
   16c44:	10c00b05 	stb	r3,44(r2)

    //  Initialize lwIP, Altera TSE and the ethernetif
    lwip_init();
   16c48:	0004dc00 	call	4dc0 <lwip_init>
    if(netif_add(&alteraTseNetif, &ip_zero, &ip_zero, &ip_zero, alteraTseNetif.state, ethernetif_init, ethernet_input) == NULL)
   16c4c:	00800134 	movhi	r2,4
   16c50:	1091a704 	addi	r2,r2,18076
   16c54:	10800717 	ldw	r2,28(r2)
   16c58:	d8800015 	stw	r2,0(sp)
   16c5c:	00800034 	movhi	r2,0
   16c60:	10810604 	addi	r2,r2,1048
   16c64:	d8800115 	stw	r2,4(sp)
   16c68:	00800074 	movhi	r2,1
   16c6c:	109a8504 	addi	r2,r2,27156
   16c70:	d8800215 	stw	r2,8(sp)
   16c74:	01000134 	movhi	r4,4
   16c78:	2111a704 	addi	r4,r4,18076
   16c7c:	d168e904 	addi	r5,gp,-23644
   16c80:	d1a8e904 	addi	r6,gp,-23644
   16c84:	d1e8e904 	addi	r7,gp,-23644
   16c88:	00091e00 	call	91e0 <netif_add>
   16c8c:	1000041e 	bne	r2,zero,16ca0 <main+0x120>
        {
        printf( "Fatal error initializing...\n" );
   16c90:	010000f4 	movhi	r4,3
   16c94:	213fcf04 	addi	r4,r4,-196
   16c98:	00172f80 	call	172f8 <puts>
        for(;;);
   16c9c:	003fff06 	br	16c9c <main+0x11c>
        }
    netif_set_default(&alteraTseNetif);
   16ca0:	01000134 	movhi	r4,4
   16ca4:	2111a704 	addi	r4,r4,18076
   16ca8:	00096a40 	call	96a4 <netif_set_default>
    
    // Initialize Altera TSE in a loop if waiting for a link
    printf("Waiting for link...");
   16cac:	010000f4 	movhi	r4,3
   16cb0:	213fd604 	addi	r4,r4,-168
   16cb4:	00170680 	call	17068 <printf>
    while(((struct ethernetif *) alteraTseNetif.state)->link_alive!=1)
   16cb8:	00001006 	br	16cfc <main+0x17c>
        {
        mSdelay(1000);
   16cbc:	010003f4 	movhi	r4,15
   16cc0:	21109004 	addi	r4,r4,16960
   16cc4:	00211c40 	call	211c4 <usleep>
        putchar('.');
   16cc8:	008000f4 	movhi	r2,3
   16ccc:	1090f704 	addi	r2,r2,17372
   16cd0:	10800017 	ldw	r2,0(r2)
   16cd4:	10800217 	ldw	r2,8(r2)
   16cd8:	01000b84 	movi	r4,46
   16cdc:	100b883a 	mov	r5,r2
   16ce0:	00171600 	call	17160 <putc>
        tse_mac_init(0, alteraTseNetif.state);
   16ce4:	00800134 	movhi	r2,4
   16ce8:	1091a704 	addi	r2,r2,18076
   16cec:	10800717 	ldw	r2,28(r2)
   16cf0:	0009883a 	mov	r4,zero
   16cf4:	100b883a 	mov	r5,r2
   16cf8:	0000c780 	call	c78 <tse_mac_init>
        }
    netif_set_default(&alteraTseNetif);
    
    // Initialize Altera TSE in a loop if waiting for a link
    printf("Waiting for link...");
    while(((struct ethernetif *) alteraTseNetif.state)->link_alive!=1)
   16cfc:	00800134 	movhi	r2,4
   16d00:	1091a704 	addi	r2,r2,18076
   16d04:	10800717 	ldw	r2,28(r2)
   16d08:	10800217 	ldw	r2,8(r2)
   16d0c:	10800058 	cmpnei	r2,r2,1
   16d10:	103fea1e 	bne	r2,zero,16cbc <main+0x13c>
        {
        mSdelay(1000);
        putchar('.');
        tse_mac_init(0, alteraTseNetif.state);
        }
    printf("OK\n");
   16d14:	010000f4 	movhi	r4,3
   16d18:	213fdb04 	addi	r4,r4,-148
   16d1c:	00172f80 	call	172f8 <puts>
            lwipProcessTimers();
        //  Poll lwIP for incoming packets.
        ethernetif_input(&alteraTseNetif);
        }
#else
    STATIC_IP;
   16d20:	d0a8ea0b 	ldhu	r2,-23640(gp)
   16d24:	1004703a 	and	r2,r2,zero
   16d28:	10862b14 	ori	r2,r2,6316
   16d2c:	d0a8ea0d 	sth	r2,-23640(gp)
   16d30:	008000f4 	movhi	r2,3
   16d34:	1099d684 	addi	r2,r2,26458
   16d38:	10c0000b 	ldhu	r3,0(r2)
   16d3c:	1806703a 	and	r3,r3,zero
   16d40:	18c802d4 	ori	r3,r3,8203
   16d44:	10c0000d 	sth	r3,0(r2)
    netif_set_ipaddr(&alteraTseNetif, &lwipStaticIp);
   16d48:	01000134 	movhi	r4,4
   16d4c:	2111a704 	addi	r4,r4,18076
   16d50:	d168ea04 	addi	r5,gp,-23640
   16d54:	00094ac0 	call	94ac <netif_set_ipaddr>
    netif_set_up(&alteraTseNetif);
   16d58:	01000134 	movhi	r4,4
   16d5c:	2111a704 	addi	r4,r4,18076
   16d60:	00096cc0 	call	96cc <netif_set_up>
#endif
    printf("IP address: %s\n", ip_ntoa(&alteraTseNetif.ip_addr));
   16d64:	00800134 	movhi	r2,4
   16d68:	1091a804 	addi	r2,r2,18080
   16d6c:	11000017 	ldw	r4,0(r2)
   16d70:	0005bbc0 	call	5bbc <inet_ntoa>
   16d74:	010000f4 	movhi	r4,3
   16d78:	213fdc04 	addi	r4,r4,-144
   16d7c:	100b883a 	mov	r5,r2
   16d80:	00170680 	call	17068 <printf>

#if BUILD_HTTPD
    httpd_init();
   16d84:	0000c0c0 	call	c0c <httpd_init>
#endif
    //  This is the main loop for lwIP - other processing can be done by calling application functions.
    for(;;)
        {
        //  Process lwIP timer dependent code
        if(lwipProcessTimerFlag)
   16d88:	d0a8e617 	ldw	r2,-23656(gp)
   16d8c:	10000126 	beq	r2,zero,16d94 <main+0x214>
            lwipProcessTimers();
   16d90:	0016da40 	call	16da4 <lwipProcessTimers>
        //  Poll lwIP for incoming packets.
        ethernetif_input(&alteraTseNetif);
   16d94:	01000134 	movhi	r4,4
   16d98:	2111a704 	addi	r4,r4,18076
   16d9c:	00003340 	call	334 <ethernetif_input>
        }
   16da0:	003ff906 	br	16d88 <main+0x208>

00016da4 <lwipProcessTimers>:
    return 0;
}

//  Run this every 250mS to update lwIP timers
void        lwipProcessTimers(void)
{
   16da4:	defffe04 	addi	sp,sp,-8
   16da8:	dfc00115 	stw	ra,4(sp)
   16dac:	df000015 	stw	fp,0(sp)
   16db0:	d839883a 	mov	fp,sp
    lwipProcessTimerFlag = 0;
   16db4:	d028e615 	stw	zero,-23656(gp)
    lwip250mStimer += 250;
   16db8:	d0a8e817 	ldw	r2,-23648(gp)
   16dbc:	10803e84 	addi	r2,r2,250
   16dc0:	d0a8e815 	stw	r2,-23648(gp)
    if( (lwip250mStimer % TCP_TMR_INTERVAL) == 0 ) { tcp_tmr(); }
   16dc4:	d0a8e817 	ldw	r2,-23648(gp)
   16dc8:	00c03e84 	movi	r3,250
   16dcc:	10c7203a 	divu	r3,r2,r3
   16dd0:	18c03ea4 	muli	r3,r3,250
   16dd4:	10c5c83a 	sub	r2,r2,r3
   16dd8:	1000011e 	bne	r2,zero,16de0 <lwipProcessTimers+0x3c>
   16ddc:	000b24c0 	call	b24c <tcp_tmr>
    if( (lwip250mStimer % ARP_TMR_INTERVAL) == 0 ) { etharp_tmr(); }
   16de0:	d0a8e817 	ldw	r2,-23648(gp)
   16de4:	00c4e204 	movi	r3,5000
   16de8:	10c7203a 	divu	r3,r2,r3
   16dec:	18c4e224 	muli	r3,r3,5000
   16df0:	10c5c83a 	sub	r2,r2,r3
   16df4:	1000011e 	bne	r2,zero,16dfc <lwipProcessTimers+0x58>
   16df8:	00151200 	call	15120 <etharp_tmr>
#if IP_REASSEMBLY
    if( (lwip250mStimer % IP_TMR_INTERVAL) == 0 ) { ip_reass_tmr(); }
   16dfc:	d0a8e817 	ldw	r2,-23648(gp)
   16e00:	00c0fa04 	movi	r3,1000
   16e04:	10c7203a 	divu	r3,r2,r3
   16e08:	18c0fa24 	muli	r3,r3,1000
   16e0c:	10c5c83a 	sub	r2,r2,r3
   16e10:	1000011e 	bne	r2,zero,16e18 <lwipProcessTimers+0x74>
   16e14:	0006ebc0 	call	6ebc <ip_reass_tmr>
#endif
#if LWIP_IGMP
    if( (lwip250mStimer % IGMP_TMR_INTERVAL ) == 0 ) { igmp_tmr(); } 
#endif
#if LWIP_DHCP
    if( (lwip250mStimer % DHCP_FINE_TIMER_MSECS ) == 0 ) { dhcp_fine_tmr(); }
   16e18:	d0a8e817 	ldw	r2,-23648(gp)
   16e1c:	00c07d04 	movi	r3,500
   16e20:	10c7203a 	divu	r3,r2,r3
   16e24:	18c07d24 	muli	r3,r3,500
   16e28:	10c5c83a 	sub	r2,r2,r3
   16e2c:	1000011e 	bne	r2,zero,16e34 <lwipProcessTimers+0x90>
   16e30:	0001eb80 	call	1eb8 <dhcp_fine_tmr>
    if( (lwip250mStimer % (DHCP_COARSE_TIMER_SECS*1000) ) == 0 ) { dhcp_coarse_tmr(); }
   16e34:	d0a8e817 	ldw	r2,-23648(gp)
   16e38:	00fa9814 	movui	r3,60000
   16e3c:	10c9203a 	divu	r4,r2,r3
   16e40:	00fa9814 	movui	r3,60000
   16e44:	20c7383a 	mul	r3,r4,r3
   16e48:	10c5c83a 	sub	r2,r2,r3
   16e4c:	1000011e 	bne	r2,zero,16e54 <lwipProcessTimers+0xb0>
   16e50:	0001e040 	call	1e04 <dhcp_coarse_tmr>
#endif
#if LWIP_DNS
    if( (lwip250mStimer % DNS_TMR_INTERVAL) == 0 ) { dns_tmr(); }
#endif
}
   16e54:	e037883a 	mov	sp,fp
   16e58:	dfc00117 	ldw	ra,4(sp)
   16e5c:	df000017 	ldw	fp,0(sp)
   16e60:	dec00204 	addi	sp,sp,8
   16e64:	f800283a 	ret

00016e68 <memcpy>:
   16e68:	00c003c4 	movi	r3,15
   16e6c:	2005883a 	mov	r2,r4
   16e70:	3009883a 	mov	r4,r6
   16e74:	1980032e 	bgeu	r3,r6,16e84 <memcpy+0x1c>
   16e78:	2886b03a 	or	r3,r5,r2
   16e7c:	18c000cc 	andi	r3,r3,3
   16e80:	18000926 	beq	r3,zero,16ea8 <memcpy+0x40>
   16e84:	1007883a 	mov	r3,r2
   16e88:	290f883a 	add	r7,r5,r4
   16e8c:	20000526 	beq	r4,zero,16ea4 <memcpy+0x3c>
   16e90:	29800003 	ldbu	r6,0(r5)
   16e94:	18c00044 	addi	r3,r3,1
   16e98:	29400044 	addi	r5,r5,1
   16e9c:	19bfffc5 	stb	r6,-1(r3)
   16ea0:	29fffb1e 	bne	r5,r7,16e90 <memcpy+0x28>
   16ea4:	f800283a 	ret
   16ea8:	327ffc04 	addi	r9,r6,-16
   16eac:	4812d13a 	srli	r9,r9,4
   16eb0:	11000404 	addi	r4,r2,16
   16eb4:	1007883a 	mov	r3,r2
   16eb8:	4810913a 	slli	r8,r9,4
   16ebc:	280f883a 	mov	r7,r5
   16ec0:	2209883a 	add	r4,r4,r8
   16ec4:	3a000017 	ldw	r8,0(r7)
   16ec8:	18c00404 	addi	r3,r3,16
   16ecc:	39c00404 	addi	r7,r7,16
   16ed0:	1a3ffc15 	stw	r8,-16(r3)
   16ed4:	3a3ffd17 	ldw	r8,-12(r7)
   16ed8:	1a3ffd15 	stw	r8,-12(r3)
   16edc:	3a3ffe17 	ldw	r8,-8(r7)
   16ee0:	1a3ffe15 	stw	r8,-8(r3)
   16ee4:	3a3fff17 	ldw	r8,-4(r7)
   16ee8:	1a3fff15 	stw	r8,-4(r3)
   16eec:	193ff51e 	bne	r3,r4,16ec4 <memcpy+0x5c>
   16ef0:	49c00044 	addi	r7,r9,1
   16ef4:	380e913a 	slli	r7,r7,4
   16ef8:	310003cc 	andi	r4,r6,15
   16efc:	018000c4 	movi	r6,3
   16f00:	11c7883a 	add	r3,r2,r7
   16f04:	29cb883a 	add	r5,r5,r7
   16f08:	313fdf2e 	bgeu	r6,r4,16e88 <memcpy+0x20>
   16f0c:	213fff04 	addi	r4,r4,-4
   16f10:	2014d0ba 	srli	r10,r4,2
   16f14:	1a400104 	addi	r9,r3,4
   16f18:	180d883a 	mov	r6,r3
   16f1c:	528f883a 	add	r7,r10,r10
   16f20:	39cf883a 	add	r7,r7,r7
   16f24:	49d3883a 	add	r9,r9,r7
   16f28:	280f883a 	mov	r7,r5
   16f2c:	3a000017 	ldw	r8,0(r7)
   16f30:	31800104 	addi	r6,r6,4
   16f34:	39c00104 	addi	r7,r7,4
   16f38:	323fff15 	stw	r8,-4(r6)
   16f3c:	327ffb1e 	bne	r6,r9,16f2c <memcpy+0xc4>
   16f40:	51800044 	addi	r6,r10,1
   16f44:	52bfff24 	muli	r10,r10,-4
   16f48:	318d883a 	add	r6,r6,r6
   16f4c:	318d883a 	add	r6,r6,r6
   16f50:	5109883a 	add	r4,r10,r4
   16f54:	298b883a 	add	r5,r5,r6
   16f58:	1987883a 	add	r3,r3,r6
   16f5c:	003fca06 	br	16e88 <memcpy+0x20>

00016f60 <memset>:
   16f60:	00c000c4 	movi	r3,3
   16f64:	2005883a 	mov	r2,r4
   16f68:	29403fcc 	andi	r5,r5,255
   16f6c:	19802d2e 	bgeu	r3,r6,17024 <memset+0xc4>
   16f70:	20c6703a 	and	r3,r4,r3
   16f74:	18002e1e 	bne	r3,zero,17030 <memset+0xd0>
   16f78:	2806923a 	slli	r3,r5,8
   16f7c:	010003c4 	movi	r4,15
   16f80:	3011883a 	mov	r8,r6
   16f84:	1946b03a 	or	r3,r3,r5
   16f88:	180e943a 	slli	r7,r3,16
   16f8c:	38ceb03a 	or	r7,r7,r3
   16f90:	1007883a 	mov	r3,r2
   16f94:	21800f2e 	bgeu	r4,r6,16fd4 <memset+0x74>
   16f98:	19c00015 	stw	r7,0(r3)
   16f9c:	19c00115 	stw	r7,4(r3)
   16fa0:	19c00215 	stw	r7,8(r3)
   16fa4:	19c00315 	stw	r7,12(r3)
   16fa8:	423ffc04 	addi	r8,r8,-16
   16fac:	18c00404 	addi	r3,r3,16
   16fb0:	223ff936 	bltu	r4,r8,16f98 <memset+0x38>
   16fb4:	30fffc04 	addi	r3,r6,-16
   16fb8:	1806d13a 	srli	r3,r3,4
   16fbc:	318003cc 	andi	r6,r6,15
   16fc0:	010000c4 	movi	r4,3
   16fc4:	18c00044 	addi	r3,r3,1
   16fc8:	1806913a 	slli	r3,r3,4
   16fcc:	10c7883a 	add	r3,r2,r3
   16fd0:	21800e2e 	bgeu	r4,r6,1700c <memset+0xac>
   16fd4:	1813883a 	mov	r9,r3
   16fd8:	3011883a 	mov	r8,r6
   16fdc:	010000c4 	movi	r4,3
   16fe0:	49c00015 	stw	r7,0(r9)
   16fe4:	423fff04 	addi	r8,r8,-4
   16fe8:	4a400104 	addi	r9,r9,4
   16fec:	223ffc36 	bltu	r4,r8,16fe0 <memset+0x80>
   16ff0:	313fff04 	addi	r4,r6,-4
   16ff4:	2008d0ba 	srli	r4,r4,2
   16ff8:	318000cc 	andi	r6,r6,3
   16ffc:	21000044 	addi	r4,r4,1
   17000:	2109883a 	add	r4,r4,r4
   17004:	2109883a 	add	r4,r4,r4
   17008:	1907883a 	add	r3,r3,r4
   1700c:	30000a26 	beq	r6,zero,17038 <memset+0xd8>
   17010:	198d883a 	add	r6,r3,r6
   17014:	19400005 	stb	r5,0(r3)
   17018:	18c00044 	addi	r3,r3,1
   1701c:	19bffd1e 	bne	r3,r6,17014 <memset+0xb4>
   17020:	f800283a 	ret
   17024:	2007883a 	mov	r3,r4
   17028:	303ff91e 	bne	r6,zero,17010 <memset+0xb0>
   1702c:	00000206 	br	17038 <memset+0xd8>
   17030:	2007883a 	mov	r3,r4
   17034:	003ff606 	br	17010 <memset+0xb0>
   17038:	f800283a 	ret

0001703c <_printf_r>:
   1703c:	defffd04 	addi	sp,sp,-12
   17040:	dfc00015 	stw	ra,0(sp)
   17044:	d9800115 	stw	r6,4(sp)
   17048:	d9c00215 	stw	r7,8(sp)
   1704c:	280d883a 	mov	r6,r5
   17050:	21400217 	ldw	r5,8(r4)
   17054:	d9c00104 	addi	r7,sp,4
   17058:	001756c0 	call	1756c <___vfprintf_internal_r>
   1705c:	dfc00017 	ldw	ra,0(sp)
   17060:	dec00304 	addi	sp,sp,12
   17064:	f800283a 	ret

00017068 <printf>:
   17068:	defffc04 	addi	sp,sp,-16
   1706c:	dfc00015 	stw	ra,0(sp)
   17070:	d9400115 	stw	r5,4(sp)
   17074:	d9800215 	stw	r6,8(sp)
   17078:	d9c00315 	stw	r7,12(sp)
   1707c:	008000f4 	movhi	r2,3
   17080:	1090f704 	addi	r2,r2,17372
   17084:	10800017 	ldw	r2,0(r2)
   17088:	200b883a 	mov	r5,r4
   1708c:	d9800104 	addi	r6,sp,4
   17090:	11000217 	ldw	r4,8(r2)
   17094:	00193640 	call	19364 <__vfprintf_internal>
   17098:	dfc00017 	ldw	ra,0(sp)
   1709c:	dec00404 	addi	sp,sp,16
   170a0:	f800283a 	ret

000170a4 <_putc_r>:
   170a4:	defffc04 	addi	sp,sp,-16
   170a8:	dc000215 	stw	r16,8(sp)
   170ac:	dfc00315 	stw	ra,12(sp)
   170b0:	2021883a 	mov	r16,r4
   170b4:	20000226 	beq	r4,zero,170c0 <_putc_r+0x1c>
   170b8:	20800e17 	ldw	r2,56(r4)
   170bc:	10001d26 	beq	r2,zero,17134 <_putc_r+0x90>
   170c0:	30800217 	ldw	r2,8(r6)
   170c4:	10bfffc4 	addi	r2,r2,-1
   170c8:	30800215 	stw	r2,8(r6)
   170cc:	10000a16 	blt	r2,zero,170f8 <_putc_r+0x54>
   170d0:	30800017 	ldw	r2,0(r6)
   170d4:	11400005 	stb	r5,0(r2)
   170d8:	30800017 	ldw	r2,0(r6)
   170dc:	10c00044 	addi	r3,r2,1
   170e0:	10800003 	ldbu	r2,0(r2)
   170e4:	30c00015 	stw	r3,0(r6)
   170e8:	dfc00317 	ldw	ra,12(sp)
   170ec:	dc000217 	ldw	r16,8(sp)
   170f0:	dec00404 	addi	sp,sp,16
   170f4:	f800283a 	ret
   170f8:	30c00617 	ldw	r3,24(r6)
   170fc:	10c01316 	blt	r2,r3,1714c <_putc_r+0xa8>
   17100:	30800017 	ldw	r2,0(r6)
   17104:	01000284 	movi	r4,10
   17108:	11400005 	stb	r5,0(r2)
   1710c:	30c00017 	ldw	r3,0(r6)
   17110:	19400003 	ldbu	r5,0(r3)
   17114:	29000d26 	beq	r5,r4,1714c <_putc_r+0xa8>
   17118:	18c00044 	addi	r3,r3,1
   1711c:	2805883a 	mov	r2,r5
   17120:	30c00015 	stw	r3,0(r6)
   17124:	dfc00317 	ldw	ra,12(sp)
   17128:	dc000217 	ldw	r16,8(sp)
   1712c:	dec00404 	addi	sp,sp,16
   17130:	f800283a 	ret
   17134:	d9400015 	stw	r5,0(sp)
   17138:	d9800115 	stw	r6,4(sp)
   1713c:	001b1200 	call	1b120 <__sinit>
   17140:	d9800117 	ldw	r6,4(sp)
   17144:	d9400017 	ldw	r5,0(sp)
   17148:	003fdd06 	br	170c0 <_putc_r+0x1c>
   1714c:	8009883a 	mov	r4,r16
   17150:	dfc00317 	ldw	ra,12(sp)
   17154:	dc000217 	ldw	r16,8(sp)
   17158:	dec00404 	addi	sp,sp,16
   1715c:	00193881 	jmpi	19388 <__swbuf_r>

00017160 <putc>:
   17160:	defffc04 	addi	sp,sp,-16
   17164:	dc400115 	stw	r17,4(sp)
   17168:	044000f4 	movhi	r17,3
   1716c:	8c50f704 	addi	r17,r17,17372
   17170:	88800017 	ldw	r2,0(r17)
   17174:	dc800215 	stw	r18,8(sp)
   17178:	dc000015 	stw	r16,0(sp)
   1717c:	dfc00315 	stw	ra,12(sp)
   17180:	2025883a 	mov	r18,r4
   17184:	2821883a 	mov	r16,r5
   17188:	10000226 	beq	r2,zero,17194 <putc+0x34>
   1718c:	10c00e17 	ldw	r3,56(r2)
   17190:	18002126 	beq	r3,zero,17218 <putc+0xb8>
   17194:	80800217 	ldw	r2,8(r16)
   17198:	10bfffc4 	addi	r2,r2,-1
   1719c:	80800215 	stw	r2,8(r16)
   171a0:	10000c16 	blt	r2,zero,171d4 <putc+0x74>
   171a4:	80800017 	ldw	r2,0(r16)
   171a8:	14800005 	stb	r18,0(r2)
   171ac:	80800017 	ldw	r2,0(r16)
   171b0:	10c00044 	addi	r3,r2,1
   171b4:	10800003 	ldbu	r2,0(r2)
   171b8:	80c00015 	stw	r3,0(r16)
   171bc:	dfc00317 	ldw	ra,12(sp)
   171c0:	dc800217 	ldw	r18,8(sp)
   171c4:	dc400117 	ldw	r17,4(sp)
   171c8:	dc000017 	ldw	r16,0(sp)
   171cc:	dec00404 	addi	sp,sp,16
   171d0:	f800283a 	ret
   171d4:	80c00617 	ldw	r3,24(r16)
   171d8:	10c01216 	blt	r2,r3,17224 <putc+0xc4>
   171dc:	80800017 	ldw	r2,0(r16)
   171e0:	01000284 	movi	r4,10
   171e4:	14800005 	stb	r18,0(r2)
   171e8:	80c00017 	ldw	r3,0(r16)
   171ec:	19400003 	ldbu	r5,0(r3)
   171f0:	29001526 	beq	r5,r4,17248 <putc+0xe8>
   171f4:	18c00044 	addi	r3,r3,1
   171f8:	2805883a 	mov	r2,r5
   171fc:	80c00015 	stw	r3,0(r16)
   17200:	dfc00317 	ldw	ra,12(sp)
   17204:	dc800217 	ldw	r18,8(sp)
   17208:	dc400117 	ldw	r17,4(sp)
   1720c:	dc000017 	ldw	r16,0(sp)
   17210:	dec00404 	addi	sp,sp,16
   17214:	f800283a 	ret
   17218:	1009883a 	mov	r4,r2
   1721c:	001b1200 	call	1b120 <__sinit>
   17220:	003fdc06 	br	17194 <putc+0x34>
   17224:	89000017 	ldw	r4,0(r17)
   17228:	900b883a 	mov	r5,r18
   1722c:	800d883a 	mov	r6,r16
   17230:	dfc00317 	ldw	ra,12(sp)
   17234:	dc800217 	ldw	r18,8(sp)
   17238:	dc400117 	ldw	r17,4(sp)
   1723c:	dc000017 	ldw	r16,0(sp)
   17240:	dec00404 	addi	sp,sp,16
   17244:	00193881 	jmpi	19388 <__swbuf_r>
   17248:	89000017 	ldw	r4,0(r17)
   1724c:	003ff706 	br	1722c <putc+0xcc>

00017250 <_putchar_r>:
   17250:	21800217 	ldw	r6,8(r4)
   17254:	00170a41 	jmpi	170a4 <_putc_r>

00017258 <putchar>:
   17258:	008000f4 	movhi	r2,3
   1725c:	1090f704 	addi	r2,r2,17372
   17260:	10800017 	ldw	r2,0(r2)
   17264:	200b883a 	mov	r5,r4
   17268:	11800217 	ldw	r6,8(r2)
   1726c:	1009883a 	mov	r4,r2
   17270:	00170a41 	jmpi	170a4 <_putc_r>

00017274 <_puts_r>:
   17274:	defff604 	addi	sp,sp,-40
   17278:	dc400815 	stw	r17,32(sp)
   1727c:	2023883a 	mov	r17,r4
   17280:	2809883a 	mov	r4,r5
   17284:	dc000715 	stw	r16,28(sp)
   17288:	dfc00915 	stw	ra,36(sp)
   1728c:	2821883a 	mov	r16,r5
   17290:	00173b00 	call	173b0 <strlen>
   17294:	10c00044 	addi	r3,r2,1
   17298:	d8800115 	stw	r2,4(sp)
   1729c:	89400217 	ldw	r5,8(r17)
   172a0:	008000f4 	movhi	r2,3
   172a4:	10bfe104 	addi	r2,r2,-124
   172a8:	d8800215 	stw	r2,8(sp)
   172ac:	00800044 	movi	r2,1
   172b0:	d8800315 	stw	r2,12(sp)
   172b4:	8809883a 	mov	r4,r17
   172b8:	00800084 	movi	r2,2
   172bc:	d9800404 	addi	r6,sp,16
   172c0:	dc000015 	stw	r16,0(sp)
   172c4:	d8c00615 	stw	r3,24(sp)
   172c8:	dec00415 	stw	sp,16(sp)
   172cc:	d8800515 	stw	r2,20(sp)
   172d0:	001b7740 	call	1b774 <__sfvwrite_r>
   172d4:	1000061e 	bne	r2,zero,172f0 <_puts_r+0x7c>
   172d8:	00800284 	movi	r2,10
   172dc:	dfc00917 	ldw	ra,36(sp)
   172e0:	dc400817 	ldw	r17,32(sp)
   172e4:	dc000717 	ldw	r16,28(sp)
   172e8:	dec00a04 	addi	sp,sp,40
   172ec:	f800283a 	ret
   172f0:	00bfffc4 	movi	r2,-1
   172f4:	003ff906 	br	172dc <_puts_r+0x68>

000172f8 <puts>:
   172f8:	008000f4 	movhi	r2,3
   172fc:	1090f704 	addi	r2,r2,17372
   17300:	200b883a 	mov	r5,r4
   17304:	11000017 	ldw	r4,0(r2)
   17308:	00172741 	jmpi	17274 <_puts_r>

0001730c <strcmp>:
   1730c:	2904b03a 	or	r2,r5,r4
   17310:	108000cc 	andi	r2,r2,3
   17314:	1000171e 	bne	r2,zero,17374 <strcmp+0x68>
   17318:	20800017 	ldw	r2,0(r4)
   1731c:	28c00017 	ldw	r3,0(r5)
   17320:	10c0141e 	bne	r2,r3,17374 <strcmp+0x68>
   17324:	027fbff4 	movhi	r9,65279
   17328:	4a7fbfc4 	addi	r9,r9,-257
   1732c:	1247883a 	add	r3,r2,r9
   17330:	0084303a 	nor	r2,zero,r2
   17334:	1884703a 	and	r2,r3,r2
   17338:	02202074 	movhi	r8,32897
   1733c:	42202004 	addi	r8,r8,-32640
   17340:	1204703a 	and	r2,r2,r8
   17344:	10000226 	beq	r2,zero,17350 <strcmp+0x44>
   17348:	00001706 	br	173a8 <strcmp+0x9c>
   1734c:	3000161e 	bne	r6,zero,173a8 <strcmp+0x9c>
   17350:	21000104 	addi	r4,r4,4
   17354:	20800017 	ldw	r2,0(r4)
   17358:	29400104 	addi	r5,r5,4
   1735c:	28c00017 	ldw	r3,0(r5)
   17360:	124f883a 	add	r7,r2,r9
   17364:	008c303a 	nor	r6,zero,r2
   17368:	398c703a 	and	r6,r7,r6
   1736c:	320c703a 	and	r6,r6,r8
   17370:	10fff626 	beq	r2,r3,1734c <strcmp+0x40>
   17374:	20800007 	ldb	r2,0(r4)
   17378:	1000051e 	bne	r2,zero,17390 <strcmp+0x84>
   1737c:	00000606 	br	17398 <strcmp+0x8c>
   17380:	21000044 	addi	r4,r4,1
   17384:	20800007 	ldb	r2,0(r4)
   17388:	29400044 	addi	r5,r5,1
   1738c:	10000226 	beq	r2,zero,17398 <strcmp+0x8c>
   17390:	28c00007 	ldb	r3,0(r5)
   17394:	10fffa26 	beq	r2,r3,17380 <strcmp+0x74>
   17398:	20c00003 	ldbu	r3,0(r4)
   1739c:	28800003 	ldbu	r2,0(r5)
   173a0:	1885c83a 	sub	r2,r3,r2
   173a4:	f800283a 	ret
   173a8:	0005883a 	mov	r2,zero
   173ac:	f800283a 	ret

000173b0 <strlen>:
   173b0:	208000cc 	andi	r2,r4,3
   173b4:	10001f1e 	bne	r2,zero,17434 <strlen+0x84>
   173b8:	20800017 	ldw	r2,0(r4)
   173bc:	01ffbff4 	movhi	r7,65279
   173c0:	39ffbfc4 	addi	r7,r7,-257
   173c4:	01a02074 	movhi	r6,32897
   173c8:	31a02004 	addi	r6,r6,-32640
   173cc:	11c7883a 	add	r3,r2,r7
   173d0:	0084303a 	nor	r2,zero,r2
   173d4:	1886703a 	and	r3,r3,r2
   173d8:	1986703a 	and	r3,r3,r6
   173dc:	2005883a 	mov	r2,r4
   173e0:	1800101e 	bne	r3,zero,17424 <strlen+0x74>
   173e4:	10800104 	addi	r2,r2,4
   173e8:	10c00017 	ldw	r3,0(r2)
   173ec:	19cb883a 	add	r5,r3,r7
   173f0:	00c6303a 	nor	r3,zero,r3
   173f4:	28c6703a 	and	r3,r5,r3
   173f8:	1986703a 	and	r3,r3,r6
   173fc:	1800091e 	bne	r3,zero,17424 <strlen+0x74>
   17400:	10800104 	addi	r2,r2,4
   17404:	10c00017 	ldw	r3,0(r2)
   17408:	19cb883a 	add	r5,r3,r7
   1740c:	00c6303a 	nor	r3,zero,r3
   17410:	28c6703a 	and	r3,r5,r3
   17414:	1986703a 	and	r3,r3,r6
   17418:	183ff226 	beq	r3,zero,173e4 <strlen+0x34>
   1741c:	00000106 	br	17424 <strlen+0x74>
   17420:	10800044 	addi	r2,r2,1
   17424:	10c00007 	ldb	r3,0(r2)
   17428:	183ffd1e 	bne	r3,zero,17420 <strlen+0x70>
   1742c:	1105c83a 	sub	r2,r2,r4
   17430:	f800283a 	ret
   17434:	2005883a 	mov	r2,r4
   17438:	003ffa06 	br	17424 <strlen+0x74>

0001743c <strncmp>:
   1743c:	30001826 	beq	r6,zero,174a0 <strncmp+0x64>
   17440:	2904b03a 	or	r2,r5,r4
   17444:	108000cc 	andi	r2,r2,3
   17448:	10001726 	beq	r2,zero,174a8 <strncmp+0x6c>
   1744c:	31bfffc4 	addi	r6,r6,-1
   17450:	20800007 	ldb	r2,0(r4)
   17454:	28c00007 	ldb	r3,0(r5)
   17458:	10c0331e 	bne	r2,r3,17528 <strncmp+0xec>
   1745c:	30001026 	beq	r6,zero,174a0 <strncmp+0x64>
   17460:	10000f26 	beq	r2,zero,174a0 <strncmp+0x64>
   17464:	20800044 	addi	r2,r4,1
   17468:	29400044 	addi	r5,r5,1
   1746c:	2189883a 	add	r4,r4,r6
   17470:	00000406 	br	17484 <strncmp+0x48>
   17474:	11000a26 	beq	r2,r4,174a0 <strncmp+0x64>
   17478:	18000926 	beq	r3,zero,174a0 <strncmp+0x64>
   1747c:	10800044 	addi	r2,r2,1
   17480:	29400044 	addi	r5,r5,1
   17484:	10c00007 	ldb	r3,0(r2)
   17488:	29800007 	ldb	r6,0(r5)
   1748c:	19bff926 	beq	r3,r6,17474 <strncmp+0x38>
   17490:	10c00003 	ldbu	r3,0(r2)
   17494:	28800003 	ldbu	r2,0(r5)
   17498:	1885c83a 	sub	r2,r3,r2
   1749c:	f800283a 	ret
   174a0:	0005883a 	mov	r2,zero
   174a4:	f800283a 	ret
   174a8:	024000c4 	movi	r9,3
   174ac:	49bfe72e 	bgeu	r9,r6,1744c <strncmp+0x10>
   174b0:	20800017 	ldw	r2,0(r4)
   174b4:	28c00017 	ldw	r3,0(r5)
   174b8:	10ffe41e 	bne	r2,r3,1744c <strncmp+0x10>
   174bc:	30ffff04 	addi	r3,r6,-4
   174c0:	183ff726 	beq	r3,zero,174a0 <strncmp+0x64>
   174c4:	02ffbff4 	movhi	r11,65279
   174c8:	5affbfc4 	addi	r11,r11,-257
   174cc:	12cd883a 	add	r6,r2,r11
   174d0:	0084303a 	nor	r2,zero,r2
   174d4:	3084703a 	and	r2,r6,r2
   174d8:	02a02074 	movhi	r10,32897
   174dc:	52a02004 	addi	r10,r10,-32640
   174e0:	1284703a 	and	r2,r2,r10
   174e4:	10000b26 	beq	r2,zero,17514 <strncmp+0xd8>
   174e8:	003fed06 	br	174a0 <strncmp+0x64>
   174ec:	21800017 	ldw	r6,0(r4)
   174f0:	28800017 	ldw	r2,0(r5)
   174f4:	32d1883a 	add	r8,r6,r11
   174f8:	018e303a 	nor	r7,zero,r6
   174fc:	41ce703a 	and	r7,r8,r7
   17500:	3a8e703a 	and	r7,r7,r10
   17504:	30800a1e 	bne	r6,r2,17530 <strncmp+0xf4>
   17508:	18ffff04 	addi	r3,r3,-4
   1750c:	183fe426 	beq	r3,zero,174a0 <strncmp+0x64>
   17510:	383fe31e 	bne	r7,zero,174a0 <strncmp+0x64>
   17514:	21000104 	addi	r4,r4,4
   17518:	29400104 	addi	r5,r5,4
   1751c:	48fff336 	bltu	r9,r3,174ec <strncmp+0xb0>
   17520:	19bfffc4 	addi	r6,r3,-1
   17524:	183fca1e 	bne	r3,zero,17450 <strncmp+0x14>
   17528:	2005883a 	mov	r2,r4
   1752c:	003fd806 	br	17490 <strncmp+0x54>
   17530:	19bfffc4 	addi	r6,r3,-1
   17534:	003fc606 	br	17450 <strncmp+0x14>

00017538 <__sprint_r>:
   17538:	30800217 	ldw	r2,8(r6)
   1753c:	defffe04 	addi	sp,sp,-8
   17540:	dc000015 	stw	r16,0(sp)
   17544:	dfc00115 	stw	ra,4(sp)
   17548:	3021883a 	mov	r16,r6
   1754c:	10000226 	beq	r2,zero,17558 <__sprint_r+0x20>
   17550:	001b7740 	call	1b774 <__sfvwrite_r>
   17554:	80000215 	stw	zero,8(r16)
   17558:	80000115 	stw	zero,4(r16)
   1755c:	dfc00117 	ldw	ra,4(sp)
   17560:	dc000017 	ldw	r16,0(sp)
   17564:	dec00204 	addi	sp,sp,8
   17568:	f800283a 	ret

0001756c <___vfprintf_internal_r>:
   1756c:	defeb904 	addi	sp,sp,-1308
   17570:	dc013d15 	stw	r16,1268(sp)
   17574:	d9013015 	stw	r4,1216(sp)
   17578:	dfc14615 	stw	ra,1304(sp)
   1757c:	df014515 	stw	fp,1300(sp)
   17580:	ddc14415 	stw	r23,1296(sp)
   17584:	dd814315 	stw	r22,1292(sp)
   17588:	dd414215 	stw	r21,1288(sp)
   1758c:	dd014115 	stw	r20,1284(sp)
   17590:	dcc14015 	stw	r19,1280(sp)
   17594:	dc813f15 	stw	r18,1276(sp)
   17598:	dc413e15 	stw	r17,1272(sp)
   1759c:	d9412915 	stw	r5,1188(sp)
   175a0:	3021883a 	mov	r16,r6
   175a4:	d9c12d15 	stw	r7,1204(sp)
   175a8:	001be600 	call	1be60 <_localeconv_r>
   175ac:	10800017 	ldw	r2,0(r2)
   175b0:	d9013017 	ldw	r4,1216(sp)
   175b4:	d8013315 	stw	zero,1228(sp)
   175b8:	d8813715 	stw	r2,1244(sp)
   175bc:	d8013415 	stw	zero,1232(sp)
   175c0:	20000226 	beq	r4,zero,175cc <___vfprintf_internal_r+0x60>
   175c4:	20800e17 	ldw	r2,56(r4)
   175c8:	10019826 	beq	r2,zero,17c2c <___vfprintf_internal_r+0x6c0>
   175cc:	da012917 	ldw	r8,1188(sp)
   175d0:	4080030b 	ldhu	r2,12(r8)
   175d4:	10c0020c 	andi	r3,r2,8
   175d8:	18ffffcc 	andi	r3,r3,65535
   175dc:	18e0001c 	xori	r3,r3,32768
   175e0:	18e00004 	addi	r3,r3,-32768
   175e4:	18013a26 	beq	r3,zero,17ad0 <___vfprintf_internal_r+0x564>
   175e8:	40c00417 	ldw	r3,16(r8)
   175ec:	18013826 	beq	r3,zero,17ad0 <___vfprintf_internal_r+0x564>
   175f0:	1100068c 	andi	r4,r2,26
   175f4:	00c00284 	movi	r3,10
   175f8:	20c13e26 	beq	r4,r3,17af4 <___vfprintf_internal_r+0x588>
   175fc:	da010dc4 	addi	r8,sp,1079
   17600:	d8800404 	addi	r2,sp,16
   17604:	da012615 	stw	r8,1176(sp)
   17608:	d8811b15 	stw	r2,1132(sp)
   1760c:	1013883a 	mov	r9,r2
   17610:	d8812617 	ldw	r2,1176(sp)
   17614:	da010e04 	addi	r8,sp,1080
   17618:	dc413017 	ldw	r17,1216(sp)
   1761c:	da012715 	stw	r8,1180(sp)
   17620:	4091c83a 	sub	r8,r8,r2
   17624:	d8011d15 	stw	zero,1140(sp)
   17628:	d8011c15 	stw	zero,1136(sp)
   1762c:	802b883a 	mov	r21,r16
   17630:	d8013215 	stw	zero,1224(sp)
   17634:	d8013615 	stw	zero,1240(sp)
   17638:	d8013515 	stw	zero,1236(sp)
   1763c:	d8012c15 	stw	zero,1200(sp)
   17640:	da013915 	stw	r8,1252(sp)
   17644:	a8800007 	ldb	r2,0(r21)
   17648:	1002ec26 	beq	r2,zero,181fc <___vfprintf_internal_r+0xc90>
   1764c:	00c00944 	movi	r3,37
   17650:	a825883a 	mov	r18,r21
   17654:	10c0021e 	bne	r2,r3,17660 <___vfprintf_internal_r+0xf4>
   17658:	00001406 	br	176ac <___vfprintf_internal_r+0x140>
   1765c:	10c00326 	beq	r2,r3,1766c <___vfprintf_internal_r+0x100>
   17660:	94800044 	addi	r18,r18,1
   17664:	90800007 	ldb	r2,0(r18)
   17668:	103ffc1e 	bne	r2,zero,1765c <___vfprintf_internal_r+0xf0>
   1766c:	9561c83a 	sub	r16,r18,r21
   17670:	80000e26 	beq	r16,zero,176ac <___vfprintf_internal_r+0x140>
   17674:	da011d17 	ldw	r8,1140(sp)
   17678:	d8c11c17 	ldw	r3,1136(sp)
   1767c:	4d400015 	stw	r21,0(r9)
   17680:	4c000115 	stw	r16,4(r9)
   17684:	4411883a 	add	r8,r8,r16
   17688:	18c00044 	addi	r3,r3,1
   1768c:	da011d15 	stw	r8,1140(sp)
   17690:	d8c11c15 	stw	r3,1136(sp)
   17694:	008001c4 	movi	r2,7
   17698:	10c15d16 	blt	r2,r3,17c10 <___vfprintf_internal_r+0x6a4>
   1769c:	4a400204 	addi	r9,r9,8
   176a0:	d8812c17 	ldw	r2,1200(sp)
   176a4:	1405883a 	add	r2,r2,r16
   176a8:	d8812c15 	stw	r2,1200(sp)
   176ac:	90800007 	ldb	r2,0(r18)
   176b0:	10013b26 	beq	r2,zero,17ba0 <___vfprintf_internal_r+0x634>
   176b4:	95400044 	addi	r21,r18,1
   176b8:	94800047 	ldb	r18,1(r18)
   176bc:	d8012585 	stb	zero,1174(sp)
   176c0:	073fffc4 	movi	fp,-1
   176c4:	d8012e15 	stw	zero,1208(sp)
   176c8:	0021883a 	mov	r16,zero
   176cc:	00c01604 	movi	r3,88
   176d0:	01400244 	movi	r5,9
   176d4:	02800a84 	movi	r10,42
   176d8:	01c01b04 	movi	r7,108
   176dc:	01800ac4 	movi	r6,43
   176e0:	02c00804 	movi	r11,32
   176e4:	ad400044 	addi	r21,r21,1
   176e8:	90bff804 	addi	r2,r18,-32
   176ec:	1880092e 	bgeu	r3,r2,17714 <___vfprintf_internal_r+0x1a8>
   176f0:	90012b26 	beq	r18,zero,17ba0 <___vfprintf_internal_r+0x634>
   176f4:	00c00044 	movi	r3,1
   176f8:	d8c12815 	stw	r3,1184(sp)
   176fc:	dc810405 	stb	r18,1040(sp)
   17700:	d8012585 	stb	zero,1174(sp)
   17704:	d8c12b15 	stw	r3,1196(sp)
   17708:	dcc10404 	addi	r19,sp,1040
   1770c:	d8013115 	stw	zero,1220(sp)
   17710:	00008806 	br	17934 <___vfprintf_internal_r+0x3c8>
   17714:	1085883a 	add	r2,r2,r2
   17718:	1085883a 	add	r2,r2,r2
   1771c:	01000074 	movhi	r4,1
   17720:	211dcc04 	addi	r4,r4,30512
   17724:	1105883a 	add	r2,r2,r4
   17728:	10800017 	ldw	r2,0(r2)
   1772c:	1000683a 	jmp	r2
   17730:	00017ce4 	muli	zero,zero,1523
   17734:	000176f0 	cmpltui	zero,zero,1499
   17738:	000176f0 	cmpltui	zero,zero,1499
   1773c:	00017cf8 	rdprs	zero,zero,1523
   17740:	000176f0 	cmpltui	zero,zero,1499
   17744:	000176f0 	cmpltui	zero,zero,1499
   17748:	000176f0 	cmpltui	zero,zero,1499
   1774c:	000176f0 	cmpltui	zero,zero,1499
   17750:	000176f0 	cmpltui	zero,zero,1499
   17754:	000176f0 	cmpltui	zero,zero,1499
   17758:	00017de0 	cmpeqi	zero,zero,1527
   1775c:	00017c9c 	xori	zero,zero,1522
   17760:	000176f0 	cmpltui	zero,zero,1499
   17764:	00017ac4 	movi	zero,1515
   17768:	00017ca8 	cmpgeui	zero,zero,1522
   1776c:	000176f0 	cmpltui	zero,zero,1499
   17770:	00017d04 	movi	zero,1524
   17774:	00017e04 	movi	zero,1528
   17778:	00017e04 	movi	zero,1528
   1777c:	00017e04 	movi	zero,1528
   17780:	00017e04 	movi	zero,1528
   17784:	00017e04 	movi	zero,1528
   17788:	00017e04 	movi	zero,1528
   1778c:	00017e04 	movi	zero,1528
   17790:	00017e04 	movi	zero,1528
   17794:	00017e04 	movi	zero,1528
   17798:	000176f0 	cmpltui	zero,zero,1499
   1779c:	000176f0 	cmpltui	zero,zero,1499
   177a0:	000176f0 	cmpltui	zero,zero,1499
   177a4:	000176f0 	cmpltui	zero,zero,1499
   177a8:	000176f0 	cmpltui	zero,zero,1499
   177ac:	000176f0 	cmpltui	zero,zero,1499
   177b0:	000176f0 	cmpltui	zero,zero,1499
   177b4:	000176f0 	cmpltui	zero,zero,1499
   177b8:	000176f0 	cmpltui	zero,zero,1499
   177bc:	000176f0 	cmpltui	zero,zero,1499
   177c0:	00017a60 	cmpeqi	zero,zero,1513
   177c4:	00017e2c 	andhi	zero,zero,1528
   177c8:	000176f0 	cmpltui	zero,zero,1499
   177cc:	00017e2c 	andhi	zero,zero,1528
   177d0:	000176f0 	cmpltui	zero,zero,1499
   177d4:	000176f0 	cmpltui	zero,zero,1499
   177d8:	000176f0 	cmpltui	zero,zero,1499
   177dc:	000176f0 	cmpltui	zero,zero,1499
   177e0:	00017f9c 	xori	zero,zero,1534
   177e4:	000176f0 	cmpltui	zero,zero,1499
   177e8:	000176f0 	cmpltui	zero,zero,1499
   177ec:	00017a28 	cmpgeui	zero,zero,1512
   177f0:	000176f0 	cmpltui	zero,zero,1499
   177f4:	000176f0 	cmpltui	zero,zero,1499
   177f8:	000176f0 	cmpltui	zero,zero,1499
   177fc:	000176f0 	cmpltui	zero,zero,1499
   17800:	000176f0 	cmpltui	zero,zero,1499
   17804:	00017894 	movui	zero,1506
   17808:	000176f0 	cmpltui	zero,zero,1499
   1780c:	000176f0 	cmpltui	zero,zero,1499
   17810:	00017d10 	cmplti	zero,zero,1524
   17814:	000176f0 	cmpltui	zero,zero,1499
   17818:	000176f0 	cmpltui	zero,zero,1499
   1781c:	000176f0 	cmpltui	zero,zero,1499
   17820:	000176f0 	cmpltui	zero,zero,1499
   17824:	000176f0 	cmpltui	zero,zero,1499
   17828:	000176f0 	cmpltui	zero,zero,1499
   1782c:	000176f0 	cmpltui	zero,zero,1499
   17830:	000176f0 	cmpltui	zero,zero,1499
   17834:	000176f0 	cmpltui	zero,zero,1499
   17838:	000176f0 	cmpltui	zero,zero,1499
   1783c:	00017d84 	movi	zero,1526
   17840:	00017a64 	muli	zero,zero,1513
   17844:	00017e2c 	andhi	zero,zero,1528
   17848:	00017e2c 	andhi	zero,zero,1528
   1784c:	00017e2c 	andhi	zero,zero,1528
   17850:	00017d64 	muli	zero,zero,1525
   17854:	00017a64 	muli	zero,zero,1513
   17858:	000176f0 	cmpltui	zero,zero,1499
   1785c:	000176f0 	cmpltui	zero,zero,1499
   17860:	00017d70 	cmpltui	zero,zero,1525
   17864:	000176f0 	cmpltui	zero,zero,1499
   17868:	00017db4 	movhi	zero,1526
   1786c:	00017a2c 	andhi	zero,zero,1512
   17870:	00017eb4 	movhi	zero,1530
   17874:	00017f00 	call	17f0 <tse_mac_rcv+0x54>
   17878:	000176f0 	cmpltui	zero,zero,1499
   1787c:	00017f0c 	andi	zero,zero,1532
   17880:	000176f0 	cmpltui	zero,zero,1499
   17884:	00017898 	cmpnei	zero,zero,1506
   17888:	000176f0 	cmpltui	zero,zero,1499
   1788c:	000176f0 	cmpltui	zero,zero,1499
   17890:	00017f68 	cmpgeui	zero,zero,1533
   17894:	84000414 	ori	r16,r16,16
   17898:	8080080c 	andi	r2,r16,32
   1789c:	1000f51e 	bne	r2,zero,17c74 <___vfprintf_internal_r+0x708>
   178a0:	8080040c 	andi	r2,r16,16
   178a4:	10042c26 	beq	r2,zero,18958 <___vfprintf_internal_r+0x13ec>
   178a8:	da012d17 	ldw	r8,1204(sp)
   178ac:	002d883a 	mov	r22,zero
   178b0:	00c00044 	movi	r3,1
   178b4:	45c00017 	ldw	r23,0(r8)
   178b8:	42000104 	addi	r8,r8,4
   178bc:	da012d15 	stw	r8,1204(sp)
   178c0:	b805883a 	mov	r2,r23
   178c4:	d8012585 	stb	zero,1174(sp)
   178c8:	e0000216 	blt	fp,zero,178d4 <___vfprintf_internal_r+0x368>
   178cc:	013fdfc4 	movi	r4,-129
   178d0:	8120703a 	and	r16,r16,r4
   178d4:	1002671e 	bne	r2,zero,18274 <___vfprintf_internal_r+0xd08>
   178d8:	e002661e 	bne	fp,zero,18274 <___vfprintf_internal_r+0xd08>
   178dc:	18c03fcc 	andi	r3,r3,255
   178e0:	1803561e 	bne	r3,zero,1863c <___vfprintf_internal_r+0x10d0>
   178e4:	8080004c 	andi	r2,r16,1
   178e8:	10035426 	beq	r2,zero,1863c <___vfprintf_internal_r+0x10d0>
   178ec:	da013917 	ldw	r8,1252(sp)
   178f0:	00800c04 	movi	r2,48
   178f4:	d8810dc5 	stb	r2,1079(sp)
   178f8:	da012b15 	stw	r8,1196(sp)
   178fc:	dcc10dc4 	addi	r19,sp,1079
   17900:	d8812b17 	ldw	r2,1196(sp)
   17904:	d8812815 	stw	r2,1184(sp)
   17908:	1700010e 	bge	r2,fp,17910 <___vfprintf_internal_r+0x3a4>
   1790c:	df012815 	stw	fp,1184(sp)
   17910:	d8812583 	ldbu	r2,1174(sp)
   17914:	df013115 	stw	fp,1220(sp)
   17918:	10803fcc 	andi	r2,r2,255
   1791c:	1080201c 	xori	r2,r2,128
   17920:	10bfe004 	addi	r2,r2,-128
   17924:	10000326 	beq	r2,zero,17934 <___vfprintf_internal_r+0x3c8>
   17928:	da012817 	ldw	r8,1184(sp)
   1792c:	42000044 	addi	r8,r8,1
   17930:	da012815 	stw	r8,1184(sp)
   17934:	80c0008c 	andi	r3,r16,2
   17938:	d8c12a15 	stw	r3,1192(sp)
   1793c:	18000326 	beq	r3,zero,1794c <___vfprintf_internal_r+0x3e0>
   17940:	da012817 	ldw	r8,1184(sp)
   17944:	42000084 	addi	r8,r8,2
   17948:	da012815 	stw	r8,1184(sp)
   1794c:	80c0210c 	andi	r3,r16,132
   17950:	d8c12f15 	stw	r3,1212(sp)
   17954:	1801941e 	bne	r3,zero,17fa8 <___vfprintf_internal_r+0xa3c>
   17958:	da012e17 	ldw	r8,1208(sp)
   1795c:	d8c12817 	ldw	r3,1184(sp)
   17960:	40edc83a 	sub	r22,r8,r3
   17964:	0581900e 	bge	zero,r22,17fa8 <___vfprintf_internal_r+0xa3c>
   17968:	02800404 	movi	r10,16
   1796c:	da011d17 	ldw	r8,1140(sp)
   17970:	d8c11c17 	ldw	r3,1136(sp)
   17974:	05c000f4 	movhi	r23,3
   17978:	bdfff284 	addi	r23,r23,-54
   1797c:	5580200e 	bge	r10,r22,17a00 <___vfprintf_internal_r+0x494>
   17980:	dc813815 	stw	r18,1248(sp)
   17984:	5039883a 	mov	fp,r10
   17988:	b825883a 	mov	r18,r23
   1798c:	050001c4 	movi	r20,7
   17990:	b02f883a 	mov	r23,r22
   17994:	802d883a 	mov	r22,r16
   17998:	dc012917 	ldw	r16,1188(sp)
   1799c:	00000306 	br	179ac <___vfprintf_internal_r+0x440>
   179a0:	bdfffc04 	addi	r23,r23,-16
   179a4:	4a400204 	addi	r9,r9,8
   179a8:	e5c0110e 	bge	fp,r23,179f0 <___vfprintf_internal_r+0x484>
   179ac:	4c800015 	stw	r18,0(r9)
   179b0:	4f000115 	stw	fp,4(r9)
   179b4:	42000404 	addi	r8,r8,16
   179b8:	18c00044 	addi	r3,r3,1
   179bc:	da011d15 	stw	r8,1140(sp)
   179c0:	d8c11c15 	stw	r3,1136(sp)
   179c4:	a0fff60e 	bge	r20,r3,179a0 <___vfprintf_internal_r+0x434>
   179c8:	8809883a 	mov	r4,r17
   179cc:	800b883a 	mov	r5,r16
   179d0:	d9811b04 	addi	r6,sp,1132
   179d4:	00175380 	call	17538 <__sprint_r>
   179d8:	1000771e 	bne	r2,zero,17bb8 <___vfprintf_internal_r+0x64c>
   179dc:	bdfffc04 	addi	r23,r23,-16
   179e0:	da011d17 	ldw	r8,1140(sp)
   179e4:	d8c11c17 	ldw	r3,1136(sp)
   179e8:	da400404 	addi	r9,sp,16
   179ec:	e5ffef16 	blt	fp,r23,179ac <___vfprintf_internal_r+0x440>
   179f0:	b021883a 	mov	r16,r22
   179f4:	b82d883a 	mov	r22,r23
   179f8:	902f883a 	mov	r23,r18
   179fc:	dc813817 	ldw	r18,1248(sp)
   17a00:	4dc00015 	stw	r23,0(r9)
   17a04:	4d800115 	stw	r22,4(r9)
   17a08:	4591883a 	add	r8,r8,r22
   17a0c:	18c00044 	addi	r3,r3,1
   17a10:	da011d15 	stw	r8,1140(sp)
   17a14:	d8c11c15 	stw	r3,1136(sp)
   17a18:	008001c4 	movi	r2,7
   17a1c:	10c36d16 	blt	r2,r3,187d4 <___vfprintf_internal_r+0x1268>
   17a20:	4a400204 	addi	r9,r9,8
   17a24:	00016206 	br	17fb0 <___vfprintf_internal_r+0xa44>
   17a28:	84000414 	ori	r16,r16,16
   17a2c:	8080080c 	andi	r2,r16,32
   17a30:	1000801e 	bne	r2,zero,17c34 <___vfprintf_internal_r+0x6c8>
   17a34:	8080040c 	andi	r2,r16,16
   17a38:	1003da26 	beq	r2,zero,189a4 <___vfprintf_internal_r+0x1438>
   17a3c:	d8c12d17 	ldw	r3,1204(sp)
   17a40:	002d883a 	mov	r22,zero
   17a44:	1dc00017 	ldw	r23,0(r3)
   17a48:	18c00104 	addi	r3,r3,4
   17a4c:	d8c12d15 	stw	r3,1204(sp)
   17a50:	b805883a 	mov	r2,r23
   17a54:	0007883a 	mov	r3,zero
   17a58:	d8012585 	stb	zero,1174(sp)
   17a5c:	003f9a06 	br	178c8 <___vfprintf_internal_r+0x35c>
   17a60:	84000414 	ori	r16,r16,16
   17a64:	8080080c 	andi	r2,r16,32
   17a68:	10007b1e 	bne	r2,zero,17c58 <___vfprintf_internal_r+0x6ec>
   17a6c:	8080040c 	andi	r2,r16,16
   17a70:	1003ed26 	beq	r2,zero,18a28 <___vfprintf_internal_r+0x14bc>
   17a74:	d9012d17 	ldw	r4,1204(sp)
   17a78:	25c00017 	ldw	r23,0(r4)
   17a7c:	21000104 	addi	r4,r4,4
   17a80:	d9012d15 	stw	r4,1204(sp)
   17a84:	b82dd7fa 	srai	r22,r23,31
   17a88:	b005883a 	mov	r2,r22
   17a8c:	1003230e 	bge	r2,zero,1871c <___vfprintf_internal_r+0x11b0>
   17a90:	05efc83a 	sub	r23,zero,r23
   17a94:	b804c03a 	cmpne	r2,r23,zero
   17a98:	05adc83a 	sub	r22,zero,r22
   17a9c:	b0adc83a 	sub	r22,r22,r2
   17aa0:	00800b44 	movi	r2,45
   17aa4:	d8812585 	stb	r2,1174(sp)
   17aa8:	00c00044 	movi	r3,1
   17aac:	bd84b03a 	or	r2,r23,r22
   17ab0:	003f8506 	br	178c8 <___vfprintf_internal_r+0x35c>
   17ab4:	da012e17 	ldw	r8,1208(sp)
   17ab8:	d8812d15 	stw	r2,1204(sp)
   17abc:	0211c83a 	sub	r8,zero,r8
   17ac0:	da012e15 	stw	r8,1208(sp)
   17ac4:	84000114 	ori	r16,r16,4
   17ac8:	ac800007 	ldb	r18,0(r21)
   17acc:	003f0506 	br	176e4 <___vfprintf_internal_r+0x178>
   17ad0:	d9013017 	ldw	r4,1216(sp)
   17ad4:	d9412917 	ldw	r5,1188(sp)
   17ad8:	00194e00 	call	194e0 <__swsetup_r>
   17adc:	10003d1e 	bne	r2,zero,17bd4 <___vfprintf_internal_r+0x668>
   17ae0:	d8c12917 	ldw	r3,1188(sp)
   17ae4:	1880030b 	ldhu	r2,12(r3)
   17ae8:	00c00284 	movi	r3,10
   17aec:	1100068c 	andi	r4,r2,26
   17af0:	20fec21e 	bne	r4,r3,175fc <___vfprintf_internal_r+0x90>
   17af4:	d9012917 	ldw	r4,1188(sp)
   17af8:	20c0038b 	ldhu	r3,14(r4)
   17afc:	193fffcc 	andi	r4,r3,65535
   17b00:	2120001c 	xori	r4,r4,32768
   17b04:	21200004 	addi	r4,r4,-32768
   17b08:	203ebc16 	blt	r4,zero,175fc <___vfprintf_internal_r+0x90>
   17b0c:	da012917 	ldw	r8,1188(sp)
   17b10:	d9013017 	ldw	r4,1216(sp)
   17b14:	d9c12d17 	ldw	r7,1204(sp)
   17b18:	42800717 	ldw	r10,28(r8)
   17b1c:	42400917 	ldw	r9,36(r8)
   17b20:	10bfff4c 	andi	r2,r2,65533
   17b24:	02010004 	movi	r8,1024
   17b28:	d881070d 	sth	r2,1052(sp)
   17b2c:	d9410404 	addi	r5,sp,1040
   17b30:	d8800404 	addi	r2,sp,16
   17b34:	800d883a 	mov	r6,r16
   17b38:	d8c1078d 	sth	r3,1054(sp)
   17b3c:	da810b15 	stw	r10,1068(sp)
   17b40:	da410d15 	stw	r9,1076(sp)
   17b44:	d8810415 	stw	r2,1040(sp)
   17b48:	d8810815 	stw	r2,1056(sp)
   17b4c:	da010615 	stw	r8,1048(sp)
   17b50:	da010915 	stw	r8,1060(sp)
   17b54:	d8010a15 	stw	zero,1064(sp)
   17b58:	001756c0 	call	1756c <___vfprintf_internal_r>
   17b5c:	d8812c15 	stw	r2,1200(sp)
   17b60:	10000416 	blt	r2,zero,17b74 <___vfprintf_internal_r+0x608>
   17b64:	d9013017 	ldw	r4,1216(sp)
   17b68:	d9410404 	addi	r5,sp,1040
   17b6c:	001ae780 	call	1ae78 <_fflush_r>
   17b70:	1005d81e 	bne	r2,zero,192d4 <___vfprintf_internal_r+0x1d68>
   17b74:	d881070b 	ldhu	r2,1052(sp)
   17b78:	1080100c 	andi	r2,r2,64
   17b7c:	10bfffcc 	andi	r2,r2,65535
   17b80:	10a0001c 	xori	r2,r2,32768
   17b84:	10a00004 	addi	r2,r2,-32768
   17b88:	10001426 	beq	r2,zero,17bdc <___vfprintf_internal_r+0x670>
   17b8c:	d8c12917 	ldw	r3,1188(sp)
   17b90:	1880030b 	ldhu	r2,12(r3)
   17b94:	10801014 	ori	r2,r2,64
   17b98:	1880030d 	sth	r2,12(r3)
   17b9c:	00000f06 	br	17bdc <___vfprintf_internal_r+0x670>
   17ba0:	d8811d17 	ldw	r2,1140(sp)
   17ba4:	10000426 	beq	r2,zero,17bb8 <___vfprintf_internal_r+0x64c>
   17ba8:	d9013017 	ldw	r4,1216(sp)
   17bac:	d9412917 	ldw	r5,1188(sp)
   17bb0:	d9811b04 	addi	r6,sp,1132
   17bb4:	00175380 	call	17538 <__sprint_r>
   17bb8:	d8c12917 	ldw	r3,1188(sp)
   17bbc:	1880030b 	ldhu	r2,12(r3)
   17bc0:	1080100c 	andi	r2,r2,64
   17bc4:	10bfffcc 	andi	r2,r2,65535
   17bc8:	10a0001c 	xori	r2,r2,32768
   17bcc:	10a00004 	addi	r2,r2,-32768
   17bd0:	10000226 	beq	r2,zero,17bdc <___vfprintf_internal_r+0x670>
   17bd4:	00bfffc4 	movi	r2,-1
   17bd8:	d8812c15 	stw	r2,1200(sp)
   17bdc:	d8812c17 	ldw	r2,1200(sp)
   17be0:	dfc14617 	ldw	ra,1304(sp)
   17be4:	df014517 	ldw	fp,1300(sp)
   17be8:	ddc14417 	ldw	r23,1296(sp)
   17bec:	dd814317 	ldw	r22,1292(sp)
   17bf0:	dd414217 	ldw	r21,1288(sp)
   17bf4:	dd014117 	ldw	r20,1284(sp)
   17bf8:	dcc14017 	ldw	r19,1280(sp)
   17bfc:	dc813f17 	ldw	r18,1276(sp)
   17c00:	dc413e17 	ldw	r17,1272(sp)
   17c04:	dc013d17 	ldw	r16,1268(sp)
   17c08:	dec14704 	addi	sp,sp,1308
   17c0c:	f800283a 	ret
   17c10:	d9412917 	ldw	r5,1188(sp)
   17c14:	8809883a 	mov	r4,r17
   17c18:	d9811b04 	addi	r6,sp,1132
   17c1c:	00175380 	call	17538 <__sprint_r>
   17c20:	103fe51e 	bne	r2,zero,17bb8 <___vfprintf_internal_r+0x64c>
   17c24:	da400404 	addi	r9,sp,16
   17c28:	003e9d06 	br	176a0 <___vfprintf_internal_r+0x134>
   17c2c:	001b1200 	call	1b120 <__sinit>
   17c30:	003e6606 	br	175cc <___vfprintf_internal_r+0x60>
   17c34:	d8812d17 	ldw	r2,1204(sp)
   17c38:	0007883a 	mov	r3,zero
   17c3c:	15c00017 	ldw	r23,0(r2)
   17c40:	15800117 	ldw	r22,4(r2)
   17c44:	10800204 	addi	r2,r2,8
   17c48:	d8812d15 	stw	r2,1204(sp)
   17c4c:	d8012585 	stb	zero,1174(sp)
   17c50:	bd84b03a 	or	r2,r23,r22
   17c54:	003f1c06 	br	178c8 <___vfprintf_internal_r+0x35c>
   17c58:	d8c12d17 	ldw	r3,1204(sp)
   17c5c:	18800117 	ldw	r2,4(r3)
   17c60:	1dc00017 	ldw	r23,0(r3)
   17c64:	18c00204 	addi	r3,r3,8
   17c68:	d8c12d15 	stw	r3,1204(sp)
   17c6c:	102d883a 	mov	r22,r2
   17c70:	003f8606 	br	17a8c <___vfprintf_internal_r+0x520>
   17c74:	d8c12d17 	ldw	r3,1204(sp)
   17c78:	d9012d17 	ldw	r4,1204(sp)
   17c7c:	1dc00017 	ldw	r23,0(r3)
   17c80:	1d800117 	ldw	r22,4(r3)
   17c84:	21000204 	addi	r4,r4,8
   17c88:	00c00044 	movi	r3,1
   17c8c:	d9012d15 	stw	r4,1204(sp)
   17c90:	bd84b03a 	or	r2,r23,r22
   17c94:	d8012585 	stb	zero,1174(sp)
   17c98:	003f0b06 	br	178c8 <___vfprintf_internal_r+0x35c>
   17c9c:	d9812585 	stb	r6,1174(sp)
   17ca0:	ac800007 	ldb	r18,0(r21)
   17ca4:	003e8f06 	br	176e4 <___vfprintf_internal_r+0x178>
   17ca8:	ac800007 	ldb	r18,0(r21)
   17cac:	a9000044 	addi	r4,r21,1
   17cb0:	92857d26 	beq	r18,r10,192a8 <___vfprintf_internal_r+0x1d3c>
   17cb4:	90bff404 	addi	r2,r18,-48
   17cb8:	0039883a 	mov	fp,zero
   17cbc:	28800736 	bltu	r5,r2,17cdc <___vfprintf_internal_r+0x770>
   17cc0:	24800007 	ldb	r18,0(r4)
   17cc4:	e70002a4 	muli	fp,fp,10
   17cc8:	21000044 	addi	r4,r4,1
   17ccc:	1739883a 	add	fp,r2,fp
   17cd0:	90bff404 	addi	r2,r18,-48
   17cd4:	28bffa2e 	bgeu	r5,r2,17cc0 <___vfprintf_internal_r+0x754>
   17cd8:	e0044216 	blt	fp,zero,18de4 <___vfprintf_internal_r+0x1878>
   17cdc:	202b883a 	mov	r21,r4
   17ce0:	003e8106 	br	176e8 <___vfprintf_internal_r+0x17c>
   17ce4:	d8812587 	ldb	r2,1174(sp)
   17ce8:	1003581e 	bne	r2,zero,18a4c <___vfprintf_internal_r+0x14e0>
   17cec:	dac12585 	stb	r11,1174(sp)
   17cf0:	ac800007 	ldb	r18,0(r21)
   17cf4:	003e7b06 	br	176e4 <___vfprintf_internal_r+0x178>
   17cf8:	84000054 	ori	r16,r16,1
   17cfc:	ac800007 	ldb	r18,0(r21)
   17d00:	003e7806 	br	176e4 <___vfprintf_internal_r+0x178>
   17d04:	84002014 	ori	r16,r16,128
   17d08:	ac800007 	ldb	r18,0(r21)
   17d0c:	003e7506 	br	176e4 <___vfprintf_internal_r+0x178>
   17d10:	020000f4 	movhi	r8,3
   17d14:	423fe604 	addi	r8,r8,-104
   17d18:	da013615 	stw	r8,1240(sp)
   17d1c:	8080080c 	andi	r2,r16,32
   17d20:	10009626 	beq	r2,zero,17f7c <___vfprintf_internal_r+0xa10>
   17d24:	d8812d17 	ldw	r2,1204(sp)
   17d28:	15c00017 	ldw	r23,0(r2)
   17d2c:	15800117 	ldw	r22,4(r2)
   17d30:	10800204 	addi	r2,r2,8
   17d34:	d8812d15 	stw	r2,1204(sp)
   17d38:	8080004c 	andi	r2,r16,1
   17d3c:	1002ae26 	beq	r2,zero,187f8 <___vfprintf_internal_r+0x128c>
   17d40:	bd84b03a 	or	r2,r23,r22
   17d44:	10032a26 	beq	r2,zero,189f0 <___vfprintf_internal_r+0x1484>
   17d48:	00c00c04 	movi	r3,48
   17d4c:	d8c12505 	stb	r3,1172(sp)
   17d50:	dc812545 	stb	r18,1173(sp)
   17d54:	84000094 	ori	r16,r16,2
   17d58:	00c00084 	movi	r3,2
   17d5c:	d8012585 	stb	zero,1174(sp)
   17d60:	003ed906 	br	178c8 <___vfprintf_internal_r+0x35c>
   17d64:	84001014 	ori	r16,r16,64
   17d68:	ac800007 	ldb	r18,0(r21)
   17d6c:	003e5d06 	br	176e4 <___vfprintf_internal_r+0x178>
   17d70:	ac800007 	ldb	r18,0(r21)
   17d74:	a805883a 	mov	r2,r21
   17d78:	91c43226 	beq	r18,r7,18e44 <___vfprintf_internal_r+0x18d8>
   17d7c:	84000414 	ori	r16,r16,16
   17d80:	003e5806 	br	176e4 <___vfprintf_internal_r+0x178>
   17d84:	d8c12d17 	ldw	r3,1204(sp)
   17d88:	02000044 	movi	r8,1
   17d8c:	da012815 	stw	r8,1184(sp)
   17d90:	18800017 	ldw	r2,0(r3)
   17d94:	18c00104 	addi	r3,r3,4
   17d98:	d8012585 	stb	zero,1174(sp)
   17d9c:	d8810405 	stb	r2,1040(sp)
   17da0:	d8c12d15 	stw	r3,1204(sp)
   17da4:	da012b15 	stw	r8,1196(sp)
   17da8:	dcc10404 	addi	r19,sp,1040
   17dac:	d8013115 	stw	zero,1220(sp)
   17db0:	003ee006 	br	17934 <___vfprintf_internal_r+0x3c8>
   17db4:	8080080c 	andi	r2,r16,32
   17db8:	10031026 	beq	r2,zero,189fc <___vfprintf_internal_r+0x1490>
   17dbc:	d9012d17 	ldw	r4,1204(sp)
   17dc0:	da012c17 	ldw	r8,1200(sp)
   17dc4:	20800017 	ldw	r2,0(r4)
   17dc8:	4007d7fa 	srai	r3,r8,31
   17dcc:	21000104 	addi	r4,r4,4
   17dd0:	d9012d15 	stw	r4,1204(sp)
   17dd4:	12000015 	stw	r8,0(r2)
   17dd8:	10c00115 	stw	r3,4(r2)
   17ddc:	003e1906 	br	17644 <___vfprintf_internal_r+0xd8>
   17de0:	da012d17 	ldw	r8,1204(sp)
   17de4:	d9012d17 	ldw	r4,1204(sp)
   17de8:	42000017 	ldw	r8,0(r8)
   17dec:	20800104 	addi	r2,r4,4
   17df0:	da012e15 	stw	r8,1208(sp)
   17df4:	403f2f16 	blt	r8,zero,17ab4 <___vfprintf_internal_r+0x548>
   17df8:	d8812d15 	stw	r2,1204(sp)
   17dfc:	ac800007 	ldb	r18,0(r21)
   17e00:	003e3806 	br	176e4 <___vfprintf_internal_r+0x178>
   17e04:	0009883a 	mov	r4,zero
   17e08:	90bff404 	addi	r2,r18,-48
   17e0c:	ac800007 	ldb	r18,0(r21)
   17e10:	210002a4 	muli	r4,r4,10
   17e14:	ad400044 	addi	r21,r21,1
   17e18:	2089883a 	add	r4,r4,r2
   17e1c:	90bff404 	addi	r2,r18,-48
   17e20:	28bffa2e 	bgeu	r5,r2,17e0c <___vfprintf_internal_r+0x8a0>
   17e24:	d9012e15 	stw	r4,1208(sp)
   17e28:	003e2f06 	br	176e8 <___vfprintf_internal_r+0x17c>
   17e2c:	8080020c 	andi	r2,r16,8
   17e30:	1002d426 	beq	r2,zero,18984 <___vfprintf_internal_r+0x1418>
   17e34:	d8c12d17 	ldw	r3,1204(sp)
   17e38:	1d800017 	ldw	r22,0(r3)
   17e3c:	1d000117 	ldw	r20,4(r3)
   17e40:	18c00204 	addi	r3,r3,8
   17e44:	d8c12d15 	stw	r3,1204(sp)
   17e48:	dd813315 	stw	r22,1228(sp)
   17e4c:	dd013415 	stw	r20,1232(sp)
   17e50:	b009883a 	mov	r4,r22
   17e54:	a00b883a 	mov	r5,r20
   17e58:	da413c15 	stw	r9,1264(sp)
   17e5c:	001df840 	call	1df84 <__isinfd>
   17e60:	da413c17 	ldw	r9,1264(sp)
   17e64:	b009883a 	mov	r4,r22
   17e68:	a00b883a 	mov	r5,r20
   17e6c:	10035726 	beq	r2,zero,18bcc <___vfprintf_internal_r+0x1660>
   17e70:	000d883a 	mov	r6,zero
   17e74:	000f883a 	mov	r7,zero
   17e78:	001fb800 	call	1fb80 <__ltdf2>
   17e7c:	da413c17 	ldw	r9,1264(sp)
   17e80:	10041b16 	blt	r2,zero,18ef0 <___vfprintf_internal_r+0x1984>
   17e84:	d8812583 	ldbu	r2,1174(sp)
   17e88:	00c011c4 	movi	r3,71
   17e8c:	1c830b16 	blt	r3,r18,18abc <___vfprintf_internal_r+0x1550>
   17e90:	04c000f4 	movhi	r19,3
   17e94:	9cffe204 	addi	r19,r19,-120
   17e98:	020000c4 	movi	r8,3
   17e9c:	00ffdfc4 	movi	r3,-129
   17ea0:	da012815 	stw	r8,1184(sp)
   17ea4:	80e0703a 	and	r16,r16,r3
   17ea8:	da012b15 	stw	r8,1196(sp)
   17eac:	d8013115 	stw	zero,1220(sp)
   17eb0:	003e9906 	br	17918 <___vfprintf_internal_r+0x3ac>
   17eb4:	d8812d17 	ldw	r2,1204(sp)
   17eb8:	d8c12d17 	ldw	r3,1204(sp)
   17ebc:	020000f4 	movhi	r8,3
   17ec0:	423feb04 	addi	r8,r8,-84
   17ec4:	15c00017 	ldw	r23,0(r2)
   17ec8:	00800c04 	movi	r2,48
   17ecc:	18c00104 	addi	r3,r3,4
   17ed0:	d8812505 	stb	r2,1172(sp)
   17ed4:	00801e04 	movi	r2,120
   17ed8:	d8812545 	stb	r2,1173(sp)
   17edc:	d8c12d15 	stw	r3,1204(sp)
   17ee0:	002d883a 	mov	r22,zero
   17ee4:	84000094 	ori	r16,r16,2
   17ee8:	da013615 	stw	r8,1240(sp)
   17eec:	00c00084 	movi	r3,2
   17ef0:	04801e04 	movi	r18,120
   17ef4:	b805883a 	mov	r2,r23
   17ef8:	d8012585 	stb	zero,1174(sp)
   17efc:	003e7206 	br	178c8 <___vfprintf_internal_r+0x35c>
   17f00:	84000814 	ori	r16,r16,32
   17f04:	ac800007 	ldb	r18,0(r21)
   17f08:	003df606 	br	176e4 <___vfprintf_internal_r+0x178>
   17f0c:	d8812d17 	ldw	r2,1204(sp)
   17f10:	d8012585 	stb	zero,1174(sp)
   17f14:	14c00017 	ldw	r19,0(r2)
   17f18:	15c00104 	addi	r23,r2,4
   17f1c:	98040126 	beq	r19,zero,18f24 <___vfprintf_internal_r+0x19b8>
   17f20:	9809883a 	mov	r4,r19
   17f24:	e003dd16 	blt	fp,zero,18e9c <___vfprintf_internal_r+0x1930>
   17f28:	000b883a 	mov	r5,zero
   17f2c:	e00d883a 	mov	r6,fp
   17f30:	da413c15 	stw	r9,1264(sp)
   17f34:	001c7c00 	call	1c7c0 <memchr>
   17f38:	da413c17 	ldw	r9,1264(sp)
   17f3c:	10042e26 	beq	r2,zero,18ff8 <___vfprintf_internal_r+0x1a8c>
   17f40:	14c5c83a 	sub	r2,r2,r19
   17f44:	d8812b15 	stw	r2,1196(sp)
   17f48:	e083790e 	bge	fp,r2,18d30 <___vfprintf_internal_r+0x17c4>
   17f4c:	df012815 	stw	fp,1184(sp)
   17f50:	e0049516 	blt	fp,zero,191a8 <___vfprintf_internal_r+0x1c3c>
   17f54:	d8812583 	ldbu	r2,1174(sp)
   17f58:	df012b15 	stw	fp,1196(sp)
   17f5c:	ddc12d15 	stw	r23,1204(sp)
   17f60:	d8013115 	stw	zero,1220(sp)
   17f64:	003e6c06 	br	17918 <___vfprintf_internal_r+0x3ac>
   17f68:	020000f4 	movhi	r8,3
   17f6c:	423feb04 	addi	r8,r8,-84
   17f70:	da013615 	stw	r8,1240(sp)
   17f74:	8080080c 	andi	r2,r16,32
   17f78:	103f6a1e 	bne	r2,zero,17d24 <___vfprintf_internal_r+0x7b8>
   17f7c:	8080040c 	andi	r2,r16,16
   17f80:	10029326 	beq	r2,zero,189d0 <___vfprintf_internal_r+0x1464>
   17f84:	d8c12d17 	ldw	r3,1204(sp)
   17f88:	002d883a 	mov	r22,zero
   17f8c:	1dc00017 	ldw	r23,0(r3)
   17f90:	18c00104 	addi	r3,r3,4
   17f94:	d8c12d15 	stw	r3,1204(sp)
   17f98:	003f6706 	br	17d38 <___vfprintf_internal_r+0x7cc>
   17f9c:	84000214 	ori	r16,r16,8
   17fa0:	ac800007 	ldb	r18,0(r21)
   17fa4:	003dcf06 	br	176e4 <___vfprintf_internal_r+0x178>
   17fa8:	da011d17 	ldw	r8,1140(sp)
   17fac:	d8c11c17 	ldw	r3,1136(sp)
   17fb0:	d8812587 	ldb	r2,1174(sp)
   17fb4:	10000b26 	beq	r2,zero,17fe4 <___vfprintf_internal_r+0xa78>
   17fb8:	d8812584 	addi	r2,sp,1174
   17fbc:	48800015 	stw	r2,0(r9)
   17fc0:	00800044 	movi	r2,1
   17fc4:	48800115 	stw	r2,4(r9)
   17fc8:	4091883a 	add	r8,r8,r2
   17fcc:	1887883a 	add	r3,r3,r2
   17fd0:	da011d15 	stw	r8,1140(sp)
   17fd4:	d8c11c15 	stw	r3,1136(sp)
   17fd8:	008001c4 	movi	r2,7
   17fdc:	10c18516 	blt	r2,r3,185f4 <___vfprintf_internal_r+0x1088>
   17fe0:	4a400204 	addi	r9,r9,8
   17fe4:	d9012a17 	ldw	r4,1192(sp)
   17fe8:	20000b26 	beq	r4,zero,18018 <___vfprintf_internal_r+0xaac>
   17fec:	d8812504 	addi	r2,sp,1172
   17ff0:	48800015 	stw	r2,0(r9)
   17ff4:	00800084 	movi	r2,2
   17ff8:	48800115 	stw	r2,4(r9)
   17ffc:	4091883a 	add	r8,r8,r2
   18000:	18c00044 	addi	r3,r3,1
   18004:	da011d15 	stw	r8,1140(sp)
   18008:	d8c11c15 	stw	r3,1136(sp)
   1800c:	008001c4 	movi	r2,7
   18010:	10c18116 	blt	r2,r3,18618 <___vfprintf_internal_r+0x10ac>
   18014:	4a400204 	addi	r9,r9,8
   18018:	d9012f17 	ldw	r4,1212(sp)
   1801c:	00802004 	movi	r2,128
   18020:	2080fc26 	beq	r4,r2,18414 <___vfprintf_internal_r+0xea8>
   18024:	d8813117 	ldw	r2,1220(sp)
   18028:	d9012b17 	ldw	r4,1196(sp)
   1802c:	112fc83a 	sub	r23,r2,r4
   18030:	05c02a0e 	bge	zero,r23,180dc <___vfprintf_internal_r+0xb70>
   18034:	07000404 	movi	fp,16
   18038:	050000f4 	movhi	r20,3
   1803c:	a53ff684 	addi	r20,r20,-38
   18040:	e5c01d0e 	bge	fp,r23,180b8 <___vfprintf_internal_r+0xb4c>
   18044:	dc812a15 	stw	r18,1192(sp)
   18048:	058001c4 	movi	r22,7
   1804c:	a025883a 	mov	r18,r20
   18050:	8029883a 	mov	r20,r16
   18054:	dc012917 	ldw	r16,1188(sp)
   18058:	00000306 	br	18068 <___vfprintf_internal_r+0xafc>
   1805c:	bdfffc04 	addi	r23,r23,-16
   18060:	4a400204 	addi	r9,r9,8
   18064:	e5c0110e 	bge	fp,r23,180ac <___vfprintf_internal_r+0xb40>
   18068:	4c800015 	stw	r18,0(r9)
   1806c:	4f000115 	stw	fp,4(r9)
   18070:	42000404 	addi	r8,r8,16
   18074:	18c00044 	addi	r3,r3,1
   18078:	da011d15 	stw	r8,1140(sp)
   1807c:	d8c11c15 	stw	r3,1136(sp)
   18080:	b0fff60e 	bge	r22,r3,1805c <___vfprintf_internal_r+0xaf0>
   18084:	8809883a 	mov	r4,r17
   18088:	800b883a 	mov	r5,r16
   1808c:	d9811b04 	addi	r6,sp,1132
   18090:	00175380 	call	17538 <__sprint_r>
   18094:	103ec81e 	bne	r2,zero,17bb8 <___vfprintf_internal_r+0x64c>
   18098:	bdfffc04 	addi	r23,r23,-16
   1809c:	da011d17 	ldw	r8,1140(sp)
   180a0:	d8c11c17 	ldw	r3,1136(sp)
   180a4:	da400404 	addi	r9,sp,16
   180a8:	e5ffef16 	blt	fp,r23,18068 <___vfprintf_internal_r+0xafc>
   180ac:	a021883a 	mov	r16,r20
   180b0:	9029883a 	mov	r20,r18
   180b4:	dc812a17 	ldw	r18,1192(sp)
   180b8:	4d000015 	stw	r20,0(r9)
   180bc:	4dc00115 	stw	r23,4(r9)
   180c0:	45d1883a 	add	r8,r8,r23
   180c4:	18c00044 	addi	r3,r3,1
   180c8:	da011d15 	stw	r8,1140(sp)
   180cc:	d8c11c15 	stw	r3,1136(sp)
   180d0:	008001c4 	movi	r2,7
   180d4:	10c13e16 	blt	r2,r3,185d0 <___vfprintf_internal_r+0x1064>
   180d8:	4a400204 	addi	r9,r9,8
   180dc:	8080400c 	andi	r2,r16,256
   180e0:	1000831e 	bne	r2,zero,182f0 <___vfprintf_internal_r+0xd84>
   180e4:	d8812b17 	ldw	r2,1196(sp)
   180e8:	4cc00015 	stw	r19,0(r9)
   180ec:	48800115 	stw	r2,4(r9)
   180f0:	4091883a 	add	r8,r8,r2
   180f4:	18c00044 	addi	r3,r3,1
   180f8:	da011d15 	stw	r8,1140(sp)
   180fc:	d8c11c15 	stw	r3,1136(sp)
   18100:	008001c4 	movi	r2,7
   18104:	10c05316 	blt	r2,r3,18254 <___vfprintf_internal_r+0xce8>
   18108:	4a400204 	addi	r9,r9,8
   1810c:	8400010c 	andi	r16,r16,4
   18110:	80002e26 	beq	r16,zero,181cc <___vfprintf_internal_r+0xc60>
   18114:	d8812e17 	ldw	r2,1208(sp)
   18118:	d8c12817 	ldw	r3,1184(sp)
   1811c:	10e1c83a 	sub	r16,r2,r3
   18120:	04002a0e 	bge	zero,r16,181cc <___vfprintf_internal_r+0xc60>
   18124:	04800404 	movi	r18,16
   18128:	d8c11c17 	ldw	r3,1136(sp)
   1812c:	05c000f4 	movhi	r23,3
   18130:	bdfff284 	addi	r23,r23,-54
   18134:	9400170e 	bge	r18,r16,18194 <___vfprintf_internal_r+0xc28>
   18138:	04c001c4 	movi	r19,7
   1813c:	dd012917 	ldw	r20,1188(sp)
   18140:	00000306 	br	18150 <___vfprintf_internal_r+0xbe4>
   18144:	843ffc04 	addi	r16,r16,-16
   18148:	4a400204 	addi	r9,r9,8
   1814c:	9400110e 	bge	r18,r16,18194 <___vfprintf_internal_r+0xc28>
   18150:	4dc00015 	stw	r23,0(r9)
   18154:	4c800115 	stw	r18,4(r9)
   18158:	42000404 	addi	r8,r8,16
   1815c:	18c00044 	addi	r3,r3,1
   18160:	da011d15 	stw	r8,1140(sp)
   18164:	d8c11c15 	stw	r3,1136(sp)
   18168:	98fff60e 	bge	r19,r3,18144 <___vfprintf_internal_r+0xbd8>
   1816c:	8809883a 	mov	r4,r17
   18170:	a00b883a 	mov	r5,r20
   18174:	d9811b04 	addi	r6,sp,1132
   18178:	00175380 	call	17538 <__sprint_r>
   1817c:	103e8e1e 	bne	r2,zero,17bb8 <___vfprintf_internal_r+0x64c>
   18180:	843ffc04 	addi	r16,r16,-16
   18184:	da011d17 	ldw	r8,1140(sp)
   18188:	d8c11c17 	ldw	r3,1136(sp)
   1818c:	da400404 	addi	r9,sp,16
   18190:	943fef16 	blt	r18,r16,18150 <___vfprintf_internal_r+0xbe4>
   18194:	4dc00015 	stw	r23,0(r9)
   18198:	4c000115 	stw	r16,4(r9)
   1819c:	8211883a 	add	r8,r16,r8
   181a0:	18c00044 	addi	r3,r3,1
   181a4:	da011d15 	stw	r8,1140(sp)
   181a8:	d8c11c15 	stw	r3,1136(sp)
   181ac:	008001c4 	movi	r2,7
   181b0:	10c0060e 	bge	r2,r3,181cc <___vfprintf_internal_r+0xc60>
   181b4:	d9412917 	ldw	r5,1188(sp)
   181b8:	8809883a 	mov	r4,r17
   181bc:	d9811b04 	addi	r6,sp,1132
   181c0:	00175380 	call	17538 <__sprint_r>
   181c4:	103e7c1e 	bne	r2,zero,17bb8 <___vfprintf_internal_r+0x64c>
   181c8:	da011d17 	ldw	r8,1140(sp)
   181cc:	dd012817 	ldw	r20,1184(sp)
   181d0:	d9012e17 	ldw	r4,1208(sp)
   181d4:	a100010e 	bge	r20,r4,181dc <___vfprintf_internal_r+0xc70>
   181d8:	2029883a 	mov	r20,r4
   181dc:	d8812c17 	ldw	r2,1200(sp)
   181e0:	1505883a 	add	r2,r2,r20
   181e4:	d8812c15 	stw	r2,1200(sp)
   181e8:	4000b91e 	bne	r8,zero,184d0 <___vfprintf_internal_r+0xf64>
   181ec:	d8011c15 	stw	zero,1136(sp)
   181f0:	a8800007 	ldb	r2,0(r21)
   181f4:	da400404 	addi	r9,sp,16
   181f8:	103d141e 	bne	r2,zero,1764c <___vfprintf_internal_r+0xe0>
   181fc:	a825883a 	mov	r18,r21
   18200:	003d2a06 	br	176ac <___vfprintf_internal_r+0x140>
   18204:	d9412917 	ldw	r5,1188(sp)
   18208:	8809883a 	mov	r4,r17
   1820c:	d9811b04 	addi	r6,sp,1132
   18210:	00175380 	call	17538 <__sprint_r>
   18214:	103e681e 	bne	r2,zero,17bb8 <___vfprintf_internal_r+0x64c>
   18218:	da011d17 	ldw	r8,1140(sp)
   1821c:	da400404 	addi	r9,sp,16
   18220:	8080004c 	andi	r2,r16,1
   18224:	103fb926 	beq	r2,zero,1810c <___vfprintf_internal_r+0xba0>
   18228:	d8c11c17 	ldw	r3,1136(sp)
   1822c:	d9013717 	ldw	r4,1244(sp)
   18230:	00800044 	movi	r2,1
   18234:	48800115 	stw	r2,4(r9)
   18238:	49000015 	stw	r4,0(r9)
   1823c:	4091883a 	add	r8,r8,r2
   18240:	1887883a 	add	r3,r3,r2
   18244:	da011d15 	stw	r8,1140(sp)
   18248:	d8c11c15 	stw	r3,1136(sp)
   1824c:	008001c4 	movi	r2,7
   18250:	10ffad0e 	bge	r2,r3,18108 <___vfprintf_internal_r+0xb9c>
   18254:	d9412917 	ldw	r5,1188(sp)
   18258:	8809883a 	mov	r4,r17
   1825c:	d9811b04 	addi	r6,sp,1132
   18260:	00175380 	call	17538 <__sprint_r>
   18264:	103e541e 	bne	r2,zero,17bb8 <___vfprintf_internal_r+0x64c>
   18268:	da400404 	addi	r9,sp,16
   1826c:	da011d17 	ldw	r8,1140(sp)
   18270:	003fa606 	br	1810c <___vfprintf_internal_r+0xba0>
   18274:	18803fcc 	andi	r2,r3,255
   18278:	00c00044 	movi	r3,1
   1827c:	10c10126 	beq	r2,r3,18684 <___vfprintf_internal_r+0x1118>
   18280:	00c00084 	movi	r3,2
   18284:	10c0f026 	beq	r2,r3,18648 <___vfprintf_internal_r+0x10dc>
   18288:	d8c10dc4 	addi	r3,sp,1079
   1828c:	b808d0fa 	srli	r4,r23,3
   18290:	b00a977a 	slli	r5,r22,29
   18294:	b02cd0fa 	srli	r22,r22,3
   18298:	bdc001cc 	andi	r23,r23,7
   1829c:	b8800c04 	addi	r2,r23,48
   182a0:	292eb03a 	or	r23,r5,r4
   182a4:	18800005 	stb	r2,0(r3)
   182a8:	bd88b03a 	or	r4,r23,r22
   182ac:	1827883a 	mov	r19,r3
   182b0:	18ffffc4 	addi	r3,r3,-1
   182b4:	203ff51e 	bne	r4,zero,1828c <___vfprintf_internal_r+0xd20>
   182b8:	8100004c 	andi	r4,r16,1
   182bc:	980b883a 	mov	r5,r19
   182c0:	20000726 	beq	r4,zero,182e0 <___vfprintf_internal_r+0xd74>
   182c4:	10803fcc 	andi	r2,r2,255
   182c8:	1080201c 	xori	r2,r2,128
   182cc:	10bfe004 	addi	r2,r2,-128
   182d0:	01000c04 	movi	r4,48
   182d4:	11000226 	beq	r2,r4,182e0 <___vfprintf_internal_r+0xd74>
   182d8:	1827883a 	mov	r19,r3
   182dc:	293fffc5 	stb	r4,-1(r5)
   182e0:	d8812717 	ldw	r2,1180(sp)
   182e4:	14c5c83a 	sub	r2,r2,r19
   182e8:	d8812b15 	stw	r2,1196(sp)
   182ec:	003d8406 	br	17900 <___vfprintf_internal_r+0x394>
   182f0:	00801944 	movi	r2,101
   182f4:	14807c0e 	bge	r2,r18,184e8 <___vfprintf_internal_r+0xf7c>
   182f8:	d9013317 	ldw	r4,1228(sp)
   182fc:	d9413417 	ldw	r5,1232(sp)
   18300:	000d883a 	mov	r6,zero
   18304:	000f883a 	mov	r7,zero
   18308:	d8c13b15 	stw	r3,1260(sp)
   1830c:	da013a15 	stw	r8,1256(sp)
   18310:	da413c15 	stw	r9,1264(sp)
   18314:	001fa000 	call	1fa00 <__eqdf2>
   18318:	d8c13b17 	ldw	r3,1260(sp)
   1831c:	da013a17 	ldw	r8,1256(sp)
   18320:	da413c17 	ldw	r9,1264(sp)
   18324:	1001001e 	bne	r2,zero,18728 <___vfprintf_internal_r+0x11bc>
   18328:	008000f4 	movhi	r2,3
   1832c:	10bff204 	addi	r2,r2,-56
   18330:	48800015 	stw	r2,0(r9)
   18334:	00800044 	movi	r2,1
   18338:	48800115 	stw	r2,4(r9)
   1833c:	4091883a 	add	r8,r8,r2
   18340:	1887883a 	add	r3,r3,r2
   18344:	da011d15 	stw	r8,1140(sp)
   18348:	d8c11c15 	stw	r3,1136(sp)
   1834c:	008001c4 	movi	r2,7
   18350:	10c1dd16 	blt	r2,r3,18ac8 <___vfprintf_internal_r+0x155c>
   18354:	4a400204 	addi	r9,r9,8
   18358:	d8812417 	ldw	r2,1168(sp)
   1835c:	d8c13217 	ldw	r3,1224(sp)
   18360:	10c00216 	blt	r2,r3,1836c <___vfprintf_internal_r+0xe00>
   18364:	8080004c 	andi	r2,r16,1
   18368:	103f6826 	beq	r2,zero,1810c <___vfprintf_internal_r+0xba0>
   1836c:	d8c11c17 	ldw	r3,1136(sp)
   18370:	d9013717 	ldw	r4,1244(sp)
   18374:	00800044 	movi	r2,1
   18378:	48800115 	stw	r2,4(r9)
   1837c:	49000015 	stw	r4,0(r9)
   18380:	4091883a 	add	r8,r8,r2
   18384:	1887883a 	add	r3,r3,r2
   18388:	da011d15 	stw	r8,1140(sp)
   1838c:	d8c11c15 	stw	r3,1136(sp)
   18390:	008001c4 	movi	r2,7
   18394:	10c2af16 	blt	r2,r3,18e54 <___vfprintf_internal_r+0x18e8>
   18398:	4a400204 	addi	r9,r9,8
   1839c:	d8813217 	ldw	r2,1224(sp)
   183a0:	14bfffc4 	addi	r18,r2,-1
   183a4:	04bf590e 	bge	zero,r18,1810c <___vfprintf_internal_r+0xba0>
   183a8:	04c00404 	movi	r19,16
   183ac:	d8c11c17 	ldw	r3,1136(sp)
   183b0:	050000f4 	movhi	r20,3
   183b4:	a53ff684 	addi	r20,r20,-38
   183b8:	9c81630e 	bge	r19,r18,18948 <___vfprintf_internal_r+0x13dc>
   183bc:	058001c4 	movi	r22,7
   183c0:	ddc12917 	ldw	r23,1188(sp)
   183c4:	00000306 	br	183d4 <___vfprintf_internal_r+0xe68>
   183c8:	4a400204 	addi	r9,r9,8
   183cc:	94bffc04 	addi	r18,r18,-16
   183d0:	9c815d0e 	bge	r19,r18,18948 <___vfprintf_internal_r+0x13dc>
   183d4:	4d000015 	stw	r20,0(r9)
   183d8:	4cc00115 	stw	r19,4(r9)
   183dc:	42000404 	addi	r8,r8,16
   183e0:	18c00044 	addi	r3,r3,1
   183e4:	da011d15 	stw	r8,1140(sp)
   183e8:	d8c11c15 	stw	r3,1136(sp)
   183ec:	b0fff60e 	bge	r22,r3,183c8 <___vfprintf_internal_r+0xe5c>
   183f0:	8809883a 	mov	r4,r17
   183f4:	b80b883a 	mov	r5,r23
   183f8:	d9811b04 	addi	r6,sp,1132
   183fc:	00175380 	call	17538 <__sprint_r>
   18400:	103ded1e 	bne	r2,zero,17bb8 <___vfprintf_internal_r+0x64c>
   18404:	da011d17 	ldw	r8,1140(sp)
   18408:	d8c11c17 	ldw	r3,1136(sp)
   1840c:	da400404 	addi	r9,sp,16
   18410:	003fee06 	br	183cc <___vfprintf_internal_r+0xe60>
   18414:	d8812e17 	ldw	r2,1208(sp)
   18418:	d9012817 	ldw	r4,1184(sp)
   1841c:	112fc83a 	sub	r23,r2,r4
   18420:	05ff000e 	bge	zero,r23,18024 <___vfprintf_internal_r+0xab8>
   18424:	07000404 	movi	fp,16
   18428:	050000f4 	movhi	r20,3
   1842c:	a53ff684 	addi	r20,r20,-38
   18430:	e5c01d0e 	bge	fp,r23,184a8 <___vfprintf_internal_r+0xf3c>
   18434:	dc812a15 	stw	r18,1192(sp)
   18438:	058001c4 	movi	r22,7
   1843c:	a025883a 	mov	r18,r20
   18440:	8029883a 	mov	r20,r16
   18444:	dc012917 	ldw	r16,1188(sp)
   18448:	00000306 	br	18458 <___vfprintf_internal_r+0xeec>
   1844c:	bdfffc04 	addi	r23,r23,-16
   18450:	4a400204 	addi	r9,r9,8
   18454:	e5c0110e 	bge	fp,r23,1849c <___vfprintf_internal_r+0xf30>
   18458:	4c800015 	stw	r18,0(r9)
   1845c:	4f000115 	stw	fp,4(r9)
   18460:	42000404 	addi	r8,r8,16
   18464:	18c00044 	addi	r3,r3,1
   18468:	da011d15 	stw	r8,1140(sp)
   1846c:	d8c11c15 	stw	r3,1136(sp)
   18470:	b0fff60e 	bge	r22,r3,1844c <___vfprintf_internal_r+0xee0>
   18474:	8809883a 	mov	r4,r17
   18478:	800b883a 	mov	r5,r16
   1847c:	d9811b04 	addi	r6,sp,1132
   18480:	00175380 	call	17538 <__sprint_r>
   18484:	103dcc1e 	bne	r2,zero,17bb8 <___vfprintf_internal_r+0x64c>
   18488:	bdfffc04 	addi	r23,r23,-16
   1848c:	da011d17 	ldw	r8,1140(sp)
   18490:	d8c11c17 	ldw	r3,1136(sp)
   18494:	da400404 	addi	r9,sp,16
   18498:	e5ffef16 	blt	fp,r23,18458 <___vfprintf_internal_r+0xeec>
   1849c:	a021883a 	mov	r16,r20
   184a0:	9029883a 	mov	r20,r18
   184a4:	dc812a17 	ldw	r18,1192(sp)
   184a8:	4d000015 	stw	r20,0(r9)
   184ac:	4dc00115 	stw	r23,4(r9)
   184b0:	45d1883a 	add	r8,r8,r23
   184b4:	18c00044 	addi	r3,r3,1
   184b8:	da011d15 	stw	r8,1140(sp)
   184bc:	d8c11c15 	stw	r3,1136(sp)
   184c0:	008001c4 	movi	r2,7
   184c4:	10c11716 	blt	r2,r3,18924 <___vfprintf_internal_r+0x13b8>
   184c8:	4a400204 	addi	r9,r9,8
   184cc:	003ed506 	br	18024 <___vfprintf_internal_r+0xab8>
   184d0:	d9412917 	ldw	r5,1188(sp)
   184d4:	8809883a 	mov	r4,r17
   184d8:	d9811b04 	addi	r6,sp,1132
   184dc:	00175380 	call	17538 <__sprint_r>
   184e0:	103f4226 	beq	r2,zero,181ec <___vfprintf_internal_r+0xc80>
   184e4:	003db406 	br	17bb8 <___vfprintf_internal_r+0x64c>
   184e8:	d9013217 	ldw	r4,1224(sp)
   184ec:	00800044 	movi	r2,1
   184f0:	4cc00015 	stw	r19,0(r9)
   184f4:	1100e10e 	bge	r2,r4,1887c <___vfprintf_internal_r+0x1310>
   184f8:	00800044 	movi	r2,1
   184fc:	48800115 	stw	r2,4(r9)
   18500:	4091883a 	add	r8,r8,r2
   18504:	1887883a 	add	r3,r3,r2
   18508:	da011d15 	stw	r8,1140(sp)
   1850c:	d8c11c15 	stw	r3,1136(sp)
   18510:	008001c4 	movi	r2,7
   18514:	10c0ed16 	blt	r2,r3,188cc <___vfprintf_internal_r+0x1360>
   18518:	4a400204 	addi	r9,r9,8
   1851c:	d8813717 	ldw	r2,1244(sp)
   18520:	48800015 	stw	r2,0(r9)
   18524:	00800044 	movi	r2,1
   18528:	48800115 	stw	r2,4(r9)
   1852c:	4091883a 	add	r8,r8,r2
   18530:	1887883a 	add	r3,r3,r2
   18534:	da011d15 	stw	r8,1140(sp)
   18538:	d8c11c15 	stw	r3,1136(sp)
   1853c:	008001c4 	movi	r2,7
   18540:	10c0eb16 	blt	r2,r3,188f0 <___vfprintf_internal_r+0x1384>
   18544:	4c800204 	addi	r18,r9,8
   18548:	d9013317 	ldw	r4,1228(sp)
   1854c:	d9413417 	ldw	r5,1232(sp)
   18550:	000d883a 	mov	r6,zero
   18554:	000f883a 	mov	r7,zero
   18558:	d8c13b15 	stw	r3,1260(sp)
   1855c:	da013a15 	stw	r8,1256(sp)
   18560:	001fa5c0 	call	1fa5c <__nedf2>
   18564:	d8c13b17 	ldw	r3,1260(sp)
   18568:	da013a17 	ldw	r8,1256(sp)
   1856c:	1000a626 	beq	r2,zero,18808 <___vfprintf_internal_r+0x129c>
   18570:	d9013217 	ldw	r4,1224(sp)
   18574:	9cc00044 	addi	r19,r19,1
   18578:	94c00015 	stw	r19,0(r18)
   1857c:	20bfffc4 	addi	r2,r4,-1
   18580:	90800115 	stw	r2,4(r18)
   18584:	4091883a 	add	r8,r8,r2
   18588:	18c00044 	addi	r3,r3,1
   1858c:	da011d15 	stw	r8,1140(sp)
   18590:	d8c11c15 	stw	r3,1136(sp)
   18594:	008001c4 	movi	r2,7
   18598:	10c0c316 	blt	r2,r3,188a8 <___vfprintf_internal_r+0x133c>
   1859c:	94800204 	addi	r18,r18,8
   185a0:	d9013517 	ldw	r4,1236(sp)
   185a4:	d8811fc4 	addi	r2,sp,1151
   185a8:	90800015 	stw	r2,0(r18)
   185ac:	91000115 	stw	r4,4(r18)
   185b0:	4111883a 	add	r8,r8,r4
   185b4:	18c00044 	addi	r3,r3,1
   185b8:	da011d15 	stw	r8,1140(sp)
   185bc:	d8c11c15 	stw	r3,1136(sp)
   185c0:	008001c4 	movi	r2,7
   185c4:	10ff2316 	blt	r2,r3,18254 <___vfprintf_internal_r+0xce8>
   185c8:	92400204 	addi	r9,r18,8
   185cc:	003ecf06 	br	1810c <___vfprintf_internal_r+0xba0>
   185d0:	d9412917 	ldw	r5,1188(sp)
   185d4:	8809883a 	mov	r4,r17
   185d8:	d9811b04 	addi	r6,sp,1132
   185dc:	00175380 	call	17538 <__sprint_r>
   185e0:	103d751e 	bne	r2,zero,17bb8 <___vfprintf_internal_r+0x64c>
   185e4:	da011d17 	ldw	r8,1140(sp)
   185e8:	d8c11c17 	ldw	r3,1136(sp)
   185ec:	da400404 	addi	r9,sp,16
   185f0:	003eba06 	br	180dc <___vfprintf_internal_r+0xb70>
   185f4:	d9412917 	ldw	r5,1188(sp)
   185f8:	8809883a 	mov	r4,r17
   185fc:	d9811b04 	addi	r6,sp,1132
   18600:	00175380 	call	17538 <__sprint_r>
   18604:	103d6c1e 	bne	r2,zero,17bb8 <___vfprintf_internal_r+0x64c>
   18608:	da011d17 	ldw	r8,1140(sp)
   1860c:	d8c11c17 	ldw	r3,1136(sp)
   18610:	da400404 	addi	r9,sp,16
   18614:	003e7306 	br	17fe4 <___vfprintf_internal_r+0xa78>
   18618:	d9412917 	ldw	r5,1188(sp)
   1861c:	8809883a 	mov	r4,r17
   18620:	d9811b04 	addi	r6,sp,1132
   18624:	00175380 	call	17538 <__sprint_r>
   18628:	103d631e 	bne	r2,zero,17bb8 <___vfprintf_internal_r+0x64c>
   1862c:	da011d17 	ldw	r8,1140(sp)
   18630:	d8c11c17 	ldw	r3,1136(sp)
   18634:	da400404 	addi	r9,sp,16
   18638:	003e7706 	br	18018 <___vfprintf_internal_r+0xaac>
   1863c:	d8012b15 	stw	zero,1196(sp)
   18640:	dcc10e04 	addi	r19,sp,1080
   18644:	003cae06 	br	17900 <___vfprintf_internal_r+0x394>
   18648:	d9413617 	ldw	r5,1240(sp)
   1864c:	d8810dc4 	addi	r2,sp,1079
   18650:	b8c003cc 	andi	r3,r23,15
   18654:	b008973a 	slli	r4,r22,28
   18658:	28c7883a 	add	r3,r5,r3
   1865c:	b82ed13a 	srli	r23,r23,4
   18660:	18c00003 	ldbu	r3,0(r3)
   18664:	b02cd13a 	srli	r22,r22,4
   18668:	25eeb03a 	or	r23,r4,r23
   1866c:	10c00005 	stb	r3,0(r2)
   18670:	bd86b03a 	or	r3,r23,r22
   18674:	1027883a 	mov	r19,r2
   18678:	10bfffc4 	addi	r2,r2,-1
   1867c:	183ff41e 	bne	r3,zero,18650 <___vfprintf_internal_r+0x10e4>
   18680:	003f1706 	br	182e0 <___vfprintf_internal_r+0xd74>
   18684:	b0025826 	beq	r22,zero,18fe8 <___vfprintf_internal_r+0x1a7c>
   18688:	b807883a 	mov	r3,r23
   1868c:	d8810dc4 	addi	r2,sp,1079
   18690:	882f883a 	mov	r23,r17
   18694:	04c00244 	movi	r19,9
   18698:	8023883a 	mov	r17,r16
   1869c:	da412815 	stw	r9,1184(sp)
   186a0:	1821883a 	mov	r16,r3
   186a4:	8009883a 	mov	r4,r16
   186a8:	b00b883a 	mov	r5,r22
   186ac:	01800284 	movi	r6,10
   186b0:	000f883a 	mov	r7,zero
   186b4:	1029883a 	mov	r20,r2
   186b8:	001ebd40 	call	1ebd4 <__umoddi3>
   186bc:	10800c04 	addi	r2,r2,48
   186c0:	8009883a 	mov	r4,r16
   186c4:	b00b883a 	mov	r5,r22
   186c8:	a0800005 	stb	r2,0(r20)
   186cc:	01800284 	movi	r6,10
   186d0:	000f883a 	mov	r7,zero
   186d4:	001e60c0 	call	1e60c <__udivdi3>
   186d8:	1021883a 	mov	r16,r2
   186dc:	182d883a 	mov	r22,r3
   186e0:	a0bfffc4 	addi	r2,r20,-1
   186e4:	183fef1e 	bne	r3,zero,186a4 <___vfprintf_internal_r+0x1138>
   186e8:	9c3fee36 	bltu	r19,r16,186a4 <___vfprintf_internal_r+0x1138>
   186ec:	da412817 	ldw	r9,1184(sp)
   186f0:	8005883a 	mov	r2,r16
   186f4:	8821883a 	mov	r16,r17
   186f8:	b823883a 	mov	r17,r23
   186fc:	102f883a 	mov	r23,r2
   18700:	d8812717 	ldw	r2,1180(sp)
   18704:	a4ffffc4 	addi	r19,r20,-1
   18708:	bdc00c04 	addi	r23,r23,48
   1870c:	14c5c83a 	sub	r2,r2,r19
   18710:	a5ffffc5 	stb	r23,-1(r20)
   18714:	d8812b15 	stw	r2,1196(sp)
   18718:	003c7906 	br	17900 <___vfprintf_internal_r+0x394>
   1871c:	00c00044 	movi	r3,1
   18720:	bd84b03a 	or	r2,r23,r22
   18724:	003c6806 	br	178c8 <___vfprintf_internal_r+0x35c>
   18728:	dc812417 	ldw	r18,1168(sp)
   1872c:	0480ee0e 	bge	zero,r18,18ae8 <___vfprintf_internal_r+0x157c>
   18730:	d9013217 	ldw	r4,1224(sp)
   18734:	4cc00015 	stw	r19,0(r9)
   18738:	9100c616 	blt	r18,r4,18a54 <___vfprintf_internal_r+0x14e8>
   1873c:	49000115 	stw	r4,4(r9)
   18740:	4111883a 	add	r8,r8,r4
   18744:	18c00044 	addi	r3,r3,1
   18748:	da011d15 	stw	r8,1140(sp)
   1874c:	d8c11c15 	stw	r3,1136(sp)
   18750:	008001c4 	movi	r2,7
   18754:	10c20916 	blt	r2,r3,18f7c <___vfprintf_internal_r+0x1a10>
   18758:	4a400204 	addi	r9,r9,8
   1875c:	d8813217 	ldw	r2,1224(sp)
   18760:	90a5c83a 	sub	r18,r18,r2
   18764:	04beae0e 	bge	zero,r18,18220 <___vfprintf_internal_r+0xcb4>
   18768:	04c00404 	movi	r19,16
   1876c:	d8c11c17 	ldw	r3,1136(sp)
   18770:	050000f4 	movhi	r20,3
   18774:	a53ff684 	addi	r20,r20,-38
   18778:	9c81be0e 	bge	r19,r18,18e74 <___vfprintf_internal_r+0x1908>
   1877c:	058001c4 	movi	r22,7
   18780:	ddc12917 	ldw	r23,1188(sp)
   18784:	00000306 	br	18794 <___vfprintf_internal_r+0x1228>
   18788:	4a400204 	addi	r9,r9,8
   1878c:	94bffc04 	addi	r18,r18,-16
   18790:	9c81b80e 	bge	r19,r18,18e74 <___vfprintf_internal_r+0x1908>
   18794:	4d000015 	stw	r20,0(r9)
   18798:	4cc00115 	stw	r19,4(r9)
   1879c:	42000404 	addi	r8,r8,16
   187a0:	18c00044 	addi	r3,r3,1
   187a4:	da011d15 	stw	r8,1140(sp)
   187a8:	d8c11c15 	stw	r3,1136(sp)
   187ac:	b0fff60e 	bge	r22,r3,18788 <___vfprintf_internal_r+0x121c>
   187b0:	8809883a 	mov	r4,r17
   187b4:	b80b883a 	mov	r5,r23
   187b8:	d9811b04 	addi	r6,sp,1132
   187bc:	00175380 	call	17538 <__sprint_r>
   187c0:	103cfd1e 	bne	r2,zero,17bb8 <___vfprintf_internal_r+0x64c>
   187c4:	da011d17 	ldw	r8,1140(sp)
   187c8:	d8c11c17 	ldw	r3,1136(sp)
   187cc:	da400404 	addi	r9,sp,16
   187d0:	003fee06 	br	1878c <___vfprintf_internal_r+0x1220>
   187d4:	d9412917 	ldw	r5,1188(sp)
   187d8:	8809883a 	mov	r4,r17
   187dc:	d9811b04 	addi	r6,sp,1132
   187e0:	00175380 	call	17538 <__sprint_r>
   187e4:	103cf41e 	bne	r2,zero,17bb8 <___vfprintf_internal_r+0x64c>
   187e8:	da011d17 	ldw	r8,1140(sp)
   187ec:	d8c11c17 	ldw	r3,1136(sp)
   187f0:	da400404 	addi	r9,sp,16
   187f4:	003dee06 	br	17fb0 <___vfprintf_internal_r+0xa44>
   187f8:	00c00084 	movi	r3,2
   187fc:	bd84b03a 	or	r2,r23,r22
   18800:	d8012585 	stb	zero,1174(sp)
   18804:	003c3006 	br	178c8 <___vfprintf_internal_r+0x35c>
   18808:	d8813217 	ldw	r2,1224(sp)
   1880c:	14ffffc4 	addi	r19,r2,-1
   18810:	04ff630e 	bge	zero,r19,185a0 <___vfprintf_internal_r+0x1034>
   18814:	05800404 	movi	r22,16
   18818:	050000f4 	movhi	r20,3
   1881c:	a53ff684 	addi	r20,r20,-38
   18820:	b4c03c0e 	bge	r22,r19,18914 <___vfprintf_internal_r+0x13a8>
   18824:	05c001c4 	movi	r23,7
   18828:	df012917 	ldw	fp,1188(sp)
   1882c:	00000306 	br	1883c <___vfprintf_internal_r+0x12d0>
   18830:	94800204 	addi	r18,r18,8
   18834:	9cfffc04 	addi	r19,r19,-16
   18838:	b4c0360e 	bge	r22,r19,18914 <___vfprintf_internal_r+0x13a8>
   1883c:	95000015 	stw	r20,0(r18)
   18840:	95800115 	stw	r22,4(r18)
   18844:	42000404 	addi	r8,r8,16
   18848:	18c00044 	addi	r3,r3,1
   1884c:	da011d15 	stw	r8,1140(sp)
   18850:	d8c11c15 	stw	r3,1136(sp)
   18854:	b8fff60e 	bge	r23,r3,18830 <___vfprintf_internal_r+0x12c4>
   18858:	8809883a 	mov	r4,r17
   1885c:	e00b883a 	mov	r5,fp
   18860:	d9811b04 	addi	r6,sp,1132
   18864:	00175380 	call	17538 <__sprint_r>
   18868:	103cd31e 	bne	r2,zero,17bb8 <___vfprintf_internal_r+0x64c>
   1886c:	da011d17 	ldw	r8,1140(sp)
   18870:	d8c11c17 	ldw	r3,1136(sp)
   18874:	dc800404 	addi	r18,sp,16
   18878:	003fee06 	br	18834 <___vfprintf_internal_r+0x12c8>
   1887c:	8088703a 	and	r4,r16,r2
   18880:	203f1d1e 	bne	r4,zero,184f8 <___vfprintf_internal_r+0xf8c>
   18884:	48800115 	stw	r2,4(r9)
   18888:	42000044 	addi	r8,r8,1
   1888c:	18c00044 	addi	r3,r3,1
   18890:	da011d15 	stw	r8,1140(sp)
   18894:	d8c11c15 	stw	r3,1136(sp)
   18898:	008001c4 	movi	r2,7
   1889c:	10c00216 	blt	r2,r3,188a8 <___vfprintf_internal_r+0x133c>
   188a0:	4c800204 	addi	r18,r9,8
   188a4:	003f3e06 	br	185a0 <___vfprintf_internal_r+0x1034>
   188a8:	d9412917 	ldw	r5,1188(sp)
   188ac:	8809883a 	mov	r4,r17
   188b0:	d9811b04 	addi	r6,sp,1132
   188b4:	00175380 	call	17538 <__sprint_r>
   188b8:	103cbf1e 	bne	r2,zero,17bb8 <___vfprintf_internal_r+0x64c>
   188bc:	dc800404 	addi	r18,sp,16
   188c0:	da011d17 	ldw	r8,1140(sp)
   188c4:	d8c11c17 	ldw	r3,1136(sp)
   188c8:	003f3506 	br	185a0 <___vfprintf_internal_r+0x1034>
   188cc:	d9412917 	ldw	r5,1188(sp)
   188d0:	8809883a 	mov	r4,r17
   188d4:	d9811b04 	addi	r6,sp,1132
   188d8:	00175380 	call	17538 <__sprint_r>
   188dc:	103cb61e 	bne	r2,zero,17bb8 <___vfprintf_internal_r+0x64c>
   188e0:	da011d17 	ldw	r8,1140(sp)
   188e4:	d8c11c17 	ldw	r3,1136(sp)
   188e8:	da400404 	addi	r9,sp,16
   188ec:	003f0b06 	br	1851c <___vfprintf_internal_r+0xfb0>
   188f0:	d9412917 	ldw	r5,1188(sp)
   188f4:	8809883a 	mov	r4,r17
   188f8:	d9811b04 	addi	r6,sp,1132
   188fc:	00175380 	call	17538 <__sprint_r>
   18900:	103cad1e 	bne	r2,zero,17bb8 <___vfprintf_internal_r+0x64c>
   18904:	da011d17 	ldw	r8,1140(sp)
   18908:	d8c11c17 	ldw	r3,1136(sp)
   1890c:	dc800404 	addi	r18,sp,16
   18910:	003f0d06 	br	18548 <___vfprintf_internal_r+0xfdc>
   18914:	95000015 	stw	r20,0(r18)
   18918:	94c00115 	stw	r19,4(r18)
   1891c:	44d1883a 	add	r8,r8,r19
   18920:	003f1906 	br	18588 <___vfprintf_internal_r+0x101c>
   18924:	d9412917 	ldw	r5,1188(sp)
   18928:	8809883a 	mov	r4,r17
   1892c:	d9811b04 	addi	r6,sp,1132
   18930:	00175380 	call	17538 <__sprint_r>
   18934:	103ca01e 	bne	r2,zero,17bb8 <___vfprintf_internal_r+0x64c>
   18938:	da011d17 	ldw	r8,1140(sp)
   1893c:	d8c11c17 	ldw	r3,1136(sp)
   18940:	da400404 	addi	r9,sp,16
   18944:	003db706 	br	18024 <___vfprintf_internal_r+0xab8>
   18948:	4d000015 	stw	r20,0(r9)
   1894c:	4c800115 	stw	r18,4(r9)
   18950:	4491883a 	add	r8,r8,r18
   18954:	003de706 	br	180f4 <___vfprintf_internal_r+0xb88>
   18958:	8080100c 	andi	r2,r16,64
   1895c:	10010226 	beq	r2,zero,18d68 <___vfprintf_internal_r+0x17fc>
   18960:	d8812d17 	ldw	r2,1204(sp)
   18964:	002d883a 	mov	r22,zero
   18968:	00c00044 	movi	r3,1
   1896c:	15c0000b 	ldhu	r23,0(r2)
   18970:	10800104 	addi	r2,r2,4
   18974:	d8812d15 	stw	r2,1204(sp)
   18978:	d8012585 	stb	zero,1174(sp)
   1897c:	b805883a 	mov	r2,r23
   18980:	003bd106 	br	178c8 <___vfprintf_internal_r+0x35c>
   18984:	d9012d17 	ldw	r4,1204(sp)
   18988:	25800017 	ldw	r22,0(r4)
   1898c:	25000117 	ldw	r20,4(r4)
   18990:	21000204 	addi	r4,r4,8
   18994:	d9012d15 	stw	r4,1204(sp)
   18998:	dd813315 	stw	r22,1228(sp)
   1899c:	dd013415 	stw	r20,1232(sp)
   189a0:	003d2b06 	br	17e50 <___vfprintf_internal_r+0x8e4>
   189a4:	8080100c 	andi	r2,r16,64
   189a8:	1000fe26 	beq	r2,zero,18da4 <___vfprintf_internal_r+0x1838>
   189ac:	d9012d17 	ldw	r4,1204(sp)
   189b0:	002d883a 	mov	r22,zero
   189b4:	0007883a 	mov	r3,zero
   189b8:	25c0000b 	ldhu	r23,0(r4)
   189bc:	21000104 	addi	r4,r4,4
   189c0:	d9012d15 	stw	r4,1204(sp)
   189c4:	b805883a 	mov	r2,r23
   189c8:	d8012585 	stb	zero,1174(sp)
   189cc:	003bbe06 	br	178c8 <___vfprintf_internal_r+0x35c>
   189d0:	8080100c 	andi	r2,r16,64
   189d4:	1000ed26 	beq	r2,zero,18d8c <___vfprintf_internal_r+0x1820>
   189d8:	d9012d17 	ldw	r4,1204(sp)
   189dc:	002d883a 	mov	r22,zero
   189e0:	25c0000b 	ldhu	r23,0(r4)
   189e4:	21000104 	addi	r4,r4,4
   189e8:	d9012d15 	stw	r4,1204(sp)
   189ec:	003cd206 	br	17d38 <___vfprintf_internal_r+0x7cc>
   189f0:	00c00084 	movi	r3,2
   189f4:	d8012585 	stb	zero,1174(sp)
   189f8:	003bb306 	br	178c8 <___vfprintf_internal_r+0x35c>
   189fc:	8080040c 	andi	r2,r16,16
   18a00:	1000f11e 	bne	r2,zero,18dc8 <___vfprintf_internal_r+0x185c>
   18a04:	8400100c 	andi	r16,r16,64
   18a08:	80015526 	beq	r16,zero,18f60 <___vfprintf_internal_r+0x19f4>
   18a0c:	da012d17 	ldw	r8,1204(sp)
   18a10:	d8c12c17 	ldw	r3,1200(sp)
   18a14:	40800017 	ldw	r2,0(r8)
   18a18:	42000104 	addi	r8,r8,4
   18a1c:	da012d15 	stw	r8,1204(sp)
   18a20:	10c0000d 	sth	r3,0(r2)
   18a24:	003b0706 	br	17644 <___vfprintf_internal_r+0xd8>
   18a28:	8080100c 	andi	r2,r16,64
   18a2c:	1000c726 	beq	r2,zero,18d4c <___vfprintf_internal_r+0x17e0>
   18a30:	da012d17 	ldw	r8,1204(sp)
   18a34:	45c0000f 	ldh	r23,0(r8)
   18a38:	42000104 	addi	r8,r8,4
   18a3c:	da012d15 	stw	r8,1204(sp)
   18a40:	b82dd7fa 	srai	r22,r23,31
   18a44:	b005883a 	mov	r2,r22
   18a48:	003c1006 	br	17a8c <___vfprintf_internal_r+0x520>
   18a4c:	ac800007 	ldb	r18,0(r21)
   18a50:	003b2406 	br	176e4 <___vfprintf_internal_r+0x178>
   18a54:	4c800115 	stw	r18,4(r9)
   18a58:	9211883a 	add	r8,r18,r8
   18a5c:	18c00044 	addi	r3,r3,1
   18a60:	da011d15 	stw	r8,1140(sp)
   18a64:	d8c11c15 	stw	r3,1136(sp)
   18a68:	008001c4 	movi	r2,7
   18a6c:	10c15416 	blt	r2,r3,18fc0 <___vfprintf_internal_r+0x1a54>
   18a70:	4a400204 	addi	r9,r9,8
   18a74:	d8813717 	ldw	r2,1244(sp)
   18a78:	9ca7883a 	add	r19,r19,r18
   18a7c:	48800015 	stw	r2,0(r9)
   18a80:	00800044 	movi	r2,1
   18a84:	48800115 	stw	r2,4(r9)
   18a88:	4091883a 	add	r8,r8,r2
   18a8c:	1887883a 	add	r3,r3,r2
   18a90:	da011d15 	stw	r8,1140(sp)
   18a94:	d8c11c15 	stw	r3,1136(sp)
   18a98:	008001c4 	movi	r2,7
   18a9c:	10c14016 	blt	r2,r3,18fa0 <___vfprintf_internal_r+0x1a34>
   18aa0:	4a400204 	addi	r9,r9,8
   18aa4:	d9013217 	ldw	r4,1224(sp)
   18aa8:	da011d17 	ldw	r8,1140(sp)
   18aac:	d8c11c17 	ldw	r3,1136(sp)
   18ab0:	24a5c83a 	sub	r18,r4,r18
   18ab4:	4cc00015 	stw	r19,0(r9)
   18ab8:	003fa406 	br	1894c <___vfprintf_internal_r+0x13e0>
   18abc:	04c000f4 	movhi	r19,3
   18ac0:	9cffe304 	addi	r19,r19,-116
   18ac4:	003cf406 	br	17e98 <___vfprintf_internal_r+0x92c>
   18ac8:	d9412917 	ldw	r5,1188(sp)
   18acc:	8809883a 	mov	r4,r17
   18ad0:	d9811b04 	addi	r6,sp,1132
   18ad4:	00175380 	call	17538 <__sprint_r>
   18ad8:	103c371e 	bne	r2,zero,17bb8 <___vfprintf_internal_r+0x64c>
   18adc:	da011d17 	ldw	r8,1140(sp)
   18ae0:	da400404 	addi	r9,sp,16
   18ae4:	003e1c06 	br	18358 <___vfprintf_internal_r+0xdec>
   18ae8:	008000f4 	movhi	r2,3
   18aec:	10bff204 	addi	r2,r2,-56
   18af0:	48800015 	stw	r2,0(r9)
   18af4:	00800044 	movi	r2,1
   18af8:	48800115 	stw	r2,4(r9)
   18afc:	4091883a 	add	r8,r8,r2
   18b00:	1887883a 	add	r3,r3,r2
   18b04:	da011d15 	stw	r8,1140(sp)
   18b08:	d8c11c15 	stw	r3,1136(sp)
   18b0c:	008001c4 	movi	r2,7
   18b10:	10c0c316 	blt	r2,r3,18e20 <___vfprintf_internal_r+0x18b4>
   18b14:	4a400204 	addi	r9,r9,8
   18b18:	9000041e 	bne	r18,zero,18b2c <___vfprintf_internal_r+0x15c0>
   18b1c:	d8c13217 	ldw	r3,1224(sp)
   18b20:	1800021e 	bne	r3,zero,18b2c <___vfprintf_internal_r+0x15c0>
   18b24:	8080004c 	andi	r2,r16,1
   18b28:	103d7826 	beq	r2,zero,1810c <___vfprintf_internal_r+0xba0>
   18b2c:	d8c11c17 	ldw	r3,1136(sp)
   18b30:	d9013717 	ldw	r4,1244(sp)
   18b34:	00800044 	movi	r2,1
   18b38:	48800115 	stw	r2,4(r9)
   18b3c:	49000015 	stw	r4,0(r9)
   18b40:	4091883a 	add	r8,r8,r2
   18b44:	1887883a 	add	r3,r3,r2
   18b48:	da011d15 	stw	r8,1140(sp)
   18b4c:	d8c11c15 	stw	r3,1136(sp)
   18b50:	008001c4 	movi	r2,7
   18b54:	10c12e16 	blt	r2,r3,19010 <___vfprintf_internal_r+0x1aa4>
   18b58:	4a400204 	addi	r9,r9,8
   18b5c:	04a5c83a 	sub	r18,zero,r18
   18b60:	0480de0e 	bge	zero,r18,18edc <___vfprintf_internal_r+0x1970>
   18b64:	05800404 	movi	r22,16
   18b68:	050000f4 	movhi	r20,3
   18b6c:	a53ff684 	addi	r20,r20,-38
   18b70:	b480e20e 	bge	r22,r18,18efc <___vfprintf_internal_r+0x1990>
   18b74:	05c001c4 	movi	r23,7
   18b78:	df012917 	ldw	fp,1188(sp)
   18b7c:	00000306 	br	18b8c <___vfprintf_internal_r+0x1620>
   18b80:	4a400204 	addi	r9,r9,8
   18b84:	94bffc04 	addi	r18,r18,-16
   18b88:	b480dc0e 	bge	r22,r18,18efc <___vfprintf_internal_r+0x1990>
   18b8c:	4d000015 	stw	r20,0(r9)
   18b90:	4d800115 	stw	r22,4(r9)
   18b94:	42000404 	addi	r8,r8,16
   18b98:	18c00044 	addi	r3,r3,1
   18b9c:	da011d15 	stw	r8,1140(sp)
   18ba0:	d8c11c15 	stw	r3,1136(sp)
   18ba4:	b8fff60e 	bge	r23,r3,18b80 <___vfprintf_internal_r+0x1614>
   18ba8:	8809883a 	mov	r4,r17
   18bac:	e00b883a 	mov	r5,fp
   18bb0:	d9811b04 	addi	r6,sp,1132
   18bb4:	00175380 	call	17538 <__sprint_r>
   18bb8:	103bff1e 	bne	r2,zero,17bb8 <___vfprintf_internal_r+0x64c>
   18bbc:	da011d17 	ldw	r8,1140(sp)
   18bc0:	d8c11c17 	ldw	r3,1136(sp)
   18bc4:	da400404 	addi	r9,sp,16
   18bc8:	003fee06 	br	18b84 <___vfprintf_internal_r+0x1618>
   18bcc:	da413c15 	stw	r9,1264(sp)
   18bd0:	001dfbc0 	call	1dfbc <__isnand>
   18bd4:	da413c17 	ldw	r9,1264(sp)
   18bd8:	1000851e 	bne	r2,zero,18df0 <___vfprintf_internal_r+0x1884>
   18bdc:	00bfffc4 	movi	r2,-1
   18be0:	e0817626 	beq	fp,r2,191bc <___vfprintf_internal_r+0x1c50>
   18be4:	008019c4 	movi	r2,103
   18be8:	90817126 	beq	r18,r2,191b0 <___vfprintf_internal_r+0x1c44>
   18bec:	008011c4 	movi	r2,71
   18bf0:	90816f26 	beq	r18,r2,191b0 <___vfprintf_internal_r+0x1c44>
   18bf4:	82004014 	ori	r8,r16,256
   18bf8:	da012a15 	stw	r8,1192(sp)
   18bfc:	a0017116 	blt	r20,zero,191c4 <___vfprintf_internal_r+0x1c58>
   18c00:	d8012f05 	stb	zero,1212(sp)
   18c04:	00801984 	movi	r2,102
   18c08:	90811226 	beq	r18,r2,19054 <___vfprintf_internal_r+0x1ae8>
   18c0c:	00801184 	movi	r2,70
   18c10:	90811026 	beq	r18,r2,19054 <___vfprintf_internal_r+0x1ae8>
   18c14:	00801944 	movi	r2,101
   18c18:	90819b26 	beq	r18,r2,19288 <___vfprintf_internal_r+0x1d1c>
   18c1c:	00801144 	movi	r2,69
   18c20:	90819926 	beq	r18,r2,19288 <___vfprintf_internal_r+0x1d1c>
   18c24:	e02f883a 	mov	r23,fp
   18c28:	d8812404 	addi	r2,sp,1168
   18c2c:	d8800115 	stw	r2,4(sp)
   18c30:	d8812304 	addi	r2,sp,1164
   18c34:	d8800215 	stw	r2,8(sp)
   18c38:	d8812204 	addi	r2,sp,1160
   18c3c:	ddc00015 	stw	r23,0(sp)
   18c40:	d8800315 	stw	r2,12(sp)
   18c44:	8809883a 	mov	r4,r17
   18c48:	b00b883a 	mov	r5,r22
   18c4c:	a00d883a 	mov	r6,r20
   18c50:	01c00084 	movi	r7,2
   18c54:	da413c15 	stw	r9,1264(sp)
   18c58:	001985c0 	call	1985c <_dtoa_r>
   18c5c:	1027883a 	mov	r19,r2
   18c60:	008019c4 	movi	r2,103
   18c64:	da413c17 	ldw	r9,1264(sp)
   18c68:	90818c1e 	bne	r18,r2,1929c <___vfprintf_internal_r+0x1d30>
   18c6c:	8080004c 	andi	r2,r16,1
   18c70:	10017926 	beq	r2,zero,19258 <___vfprintf_internal_r+0x1cec>
   18c74:	00801184 	movi	r2,70
   18c78:	9dc7883a 	add	r3,r19,r23
   18c7c:	90810626 	beq	r18,r2,19098 <___vfprintf_internal_r+0x1b2c>
   18c80:	b009883a 	mov	r4,r22
   18c84:	a00b883a 	mov	r5,r20
   18c88:	000d883a 	mov	r6,zero
   18c8c:	000f883a 	mov	r7,zero
   18c90:	d8c13b15 	stw	r3,1260(sp)
   18c94:	da413c15 	stw	r9,1264(sp)
   18c98:	001fa000 	call	1fa00 <__eqdf2>
   18c9c:	d8c13b17 	ldw	r3,1260(sp)
   18ca0:	da413c17 	ldw	r9,1264(sp)
   18ca4:	10000726 	beq	r2,zero,18cc4 <___vfprintf_internal_r+0x1758>
   18ca8:	d8812217 	ldw	r2,1160(sp)
   18cac:	10c1962e 	bgeu	r2,r3,19308 <___vfprintf_internal_r+0x1d9c>
   18cb0:	01000c04 	movi	r4,48
   18cb4:	11000005 	stb	r4,0(r2)
   18cb8:	10800044 	addi	r2,r2,1
   18cbc:	d8812215 	stw	r2,1160(sp)
   18cc0:	10fffc1e 	bne	r2,r3,18cb4 <___vfprintf_internal_r+0x1748>
   18cc4:	1cc7c83a 	sub	r3,r3,r19
   18cc8:	d8c13215 	stw	r3,1224(sp)
   18ccc:	008019c4 	movi	r2,103
   18cd0:	90810626 	beq	r18,r2,190ec <___vfprintf_internal_r+0x1b80>
   18cd4:	008011c4 	movi	r2,71
   18cd8:	90810426 	beq	r18,r2,190ec <___vfprintf_internal_r+0x1b80>
   18cdc:	00801984 	movi	r2,102
   18ce0:	90819a1e 	bne	r18,r2,1934c <___vfprintf_internal_r+0x1de0>
   18ce4:	d8812417 	ldw	r2,1168(sp)
   18ce8:	d8812b15 	stw	r2,1196(sp)
   18cec:	0081880e 	bge	zero,r2,19310 <___vfprintf_internal_r+0x1da4>
   18cf0:	e000021e 	bne	fp,zero,18cfc <___vfprintf_internal_r+0x1790>
   18cf4:	8400004c 	andi	r16,r16,1
   18cf8:	80000426 	beq	r16,zero,18d0c <___vfprintf_internal_r+0x17a0>
   18cfc:	d8812b17 	ldw	r2,1196(sp)
   18d00:	e2000044 	addi	r8,fp,1
   18d04:	1205883a 	add	r2,r2,r8
   18d08:	d8812b15 	stw	r2,1196(sp)
   18d0c:	d8812815 	stw	r2,1184(sp)
   18d10:	10011716 	blt	r2,zero,19170 <___vfprintf_internal_r+0x1c04>
   18d14:	ddc12f07 	ldb	r23,1212(sp)
   18d18:	b800ca26 	beq	r23,zero,19044 <___vfprintf_internal_r+0x1ad8>
   18d1c:	00800b44 	movi	r2,45
   18d20:	d8812585 	stb	r2,1174(sp)
   18d24:	dc012a17 	ldw	r16,1192(sp)
   18d28:	d8013115 	stw	zero,1220(sp)
   18d2c:	003afe06 	br	17928 <___vfprintf_internal_r+0x3bc>
   18d30:	d8812b17 	ldw	r2,1196(sp)
   18d34:	d8812815 	stw	r2,1184(sp)
   18d38:	10005e16 	blt	r2,zero,18eb4 <___vfprintf_internal_r+0x1948>
   18d3c:	d8812583 	ldbu	r2,1174(sp)
   18d40:	ddc12d15 	stw	r23,1204(sp)
   18d44:	d8013115 	stw	zero,1220(sp)
   18d48:	003af306 	br	17918 <___vfprintf_internal_r+0x3ac>
   18d4c:	d8812d17 	ldw	r2,1204(sp)
   18d50:	15c00017 	ldw	r23,0(r2)
   18d54:	10800104 	addi	r2,r2,4
   18d58:	d8812d15 	stw	r2,1204(sp)
   18d5c:	b82dd7fa 	srai	r22,r23,31
   18d60:	b005883a 	mov	r2,r22
   18d64:	003b4906 	br	17a8c <___vfprintf_internal_r+0x520>
   18d68:	d8c12d17 	ldw	r3,1204(sp)
   18d6c:	002d883a 	mov	r22,zero
   18d70:	1dc00017 	ldw	r23,0(r3)
   18d74:	18c00104 	addi	r3,r3,4
   18d78:	d8c12d15 	stw	r3,1204(sp)
   18d7c:	b805883a 	mov	r2,r23
   18d80:	00c00044 	movi	r3,1
   18d84:	d8012585 	stb	zero,1174(sp)
   18d88:	003acf06 	br	178c8 <___vfprintf_internal_r+0x35c>
   18d8c:	da012d17 	ldw	r8,1204(sp)
   18d90:	002d883a 	mov	r22,zero
   18d94:	45c00017 	ldw	r23,0(r8)
   18d98:	42000104 	addi	r8,r8,4
   18d9c:	da012d15 	stw	r8,1204(sp)
   18da0:	003be506 	br	17d38 <___vfprintf_internal_r+0x7cc>
   18da4:	da012d17 	ldw	r8,1204(sp)
   18da8:	002d883a 	mov	r22,zero
   18dac:	0007883a 	mov	r3,zero
   18db0:	45c00017 	ldw	r23,0(r8)
   18db4:	42000104 	addi	r8,r8,4
   18db8:	da012d15 	stw	r8,1204(sp)
   18dbc:	b805883a 	mov	r2,r23
   18dc0:	d8012585 	stb	zero,1174(sp)
   18dc4:	003ac006 	br	178c8 <___vfprintf_internal_r+0x35c>
   18dc8:	d8c12d17 	ldw	r3,1204(sp)
   18dcc:	d9012c17 	ldw	r4,1200(sp)
   18dd0:	18800017 	ldw	r2,0(r3)
   18dd4:	18c00104 	addi	r3,r3,4
   18dd8:	d8c12d15 	stw	r3,1204(sp)
   18ddc:	11000015 	stw	r4,0(r2)
   18de0:	003a1806 	br	17644 <___vfprintf_internal_r+0xd8>
   18de4:	073fffc4 	movi	fp,-1
   18de8:	202b883a 	mov	r21,r4
   18dec:	003a3e06 	br	176e8 <___vfprintf_internal_r+0x17c>
   18df0:	008011c4 	movi	r2,71
   18df4:	14809016 	blt	r2,r18,19038 <___vfprintf_internal_r+0x1acc>
   18df8:	04c000f4 	movhi	r19,3
   18dfc:	9cffe404 	addi	r19,r19,-112
   18e00:	00c000c4 	movi	r3,3
   18e04:	00bfdfc4 	movi	r2,-129
   18e08:	80a0703a 	and	r16,r16,r2
   18e0c:	d8c12815 	stw	r3,1184(sp)
   18e10:	d8812583 	ldbu	r2,1174(sp)
   18e14:	d8c12b15 	stw	r3,1196(sp)
   18e18:	d8013115 	stw	zero,1220(sp)
   18e1c:	003abe06 	br	17918 <___vfprintf_internal_r+0x3ac>
   18e20:	d9412917 	ldw	r5,1188(sp)
   18e24:	8809883a 	mov	r4,r17
   18e28:	d9811b04 	addi	r6,sp,1132
   18e2c:	00175380 	call	17538 <__sprint_r>
   18e30:	103b611e 	bne	r2,zero,17bb8 <___vfprintf_internal_r+0x64c>
   18e34:	dc812417 	ldw	r18,1168(sp)
   18e38:	da011d17 	ldw	r8,1140(sp)
   18e3c:	da400404 	addi	r9,sp,16
   18e40:	003f3506 	br	18b18 <___vfprintf_internal_r+0x15ac>
   18e44:	ad400044 	addi	r21,r21,1
   18e48:	84000814 	ori	r16,r16,32
   18e4c:	14800047 	ldb	r18,1(r2)
   18e50:	003a2406 	br	176e4 <___vfprintf_internal_r+0x178>
   18e54:	d9412917 	ldw	r5,1188(sp)
   18e58:	8809883a 	mov	r4,r17
   18e5c:	d9811b04 	addi	r6,sp,1132
   18e60:	00175380 	call	17538 <__sprint_r>
   18e64:	103b541e 	bne	r2,zero,17bb8 <___vfprintf_internal_r+0x64c>
   18e68:	da011d17 	ldw	r8,1140(sp)
   18e6c:	da400404 	addi	r9,sp,16
   18e70:	003d4a06 	br	1839c <___vfprintf_internal_r+0xe30>
   18e74:	4d000015 	stw	r20,0(r9)
   18e78:	4c800115 	stw	r18,4(r9)
   18e7c:	4491883a 	add	r8,r8,r18
   18e80:	18c00044 	addi	r3,r3,1
   18e84:	da011d15 	stw	r8,1140(sp)
   18e88:	d8c11c15 	stw	r3,1136(sp)
   18e8c:	008001c4 	movi	r2,7
   18e90:	10fcdc16 	blt	r2,r3,18204 <___vfprintf_internal_r+0xc98>
   18e94:	4a400204 	addi	r9,r9,8
   18e98:	003ce106 	br	18220 <___vfprintf_internal_r+0xcb4>
   18e9c:	da413c15 	stw	r9,1264(sp)
   18ea0:	00173b00 	call	173b0 <strlen>
   18ea4:	d8812b15 	stw	r2,1196(sp)
   18ea8:	d8812815 	stw	r2,1184(sp)
   18eac:	da413c17 	ldw	r9,1264(sp)
   18eb0:	103fa20e 	bge	r2,zero,18d3c <___vfprintf_internal_r+0x17d0>
   18eb4:	d8012815 	stw	zero,1184(sp)
   18eb8:	003fa006 	br	18d3c <___vfprintf_internal_r+0x17d0>
   18ebc:	d9412917 	ldw	r5,1188(sp)
   18ec0:	8809883a 	mov	r4,r17
   18ec4:	d9811b04 	addi	r6,sp,1132
   18ec8:	00175380 	call	17538 <__sprint_r>
   18ecc:	103b3a1e 	bne	r2,zero,17bb8 <___vfprintf_internal_r+0x64c>
   18ed0:	da011d17 	ldw	r8,1140(sp)
   18ed4:	d8c11c17 	ldw	r3,1136(sp)
   18ed8:	da400404 	addi	r9,sp,16
   18edc:	d8813217 	ldw	r2,1224(sp)
   18ee0:	4cc00015 	stw	r19,0(r9)
   18ee4:	48800115 	stw	r2,4(r9)
   18ee8:	4091883a 	add	r8,r8,r2
   18eec:	003c8106 	br	180f4 <___vfprintf_internal_r+0xb88>
   18ef0:	00800b44 	movi	r2,45
   18ef4:	d8812585 	stb	r2,1174(sp)
   18ef8:	003be306 	br	17e88 <___vfprintf_internal_r+0x91c>
   18efc:	4d000015 	stw	r20,0(r9)
   18f00:	4c800115 	stw	r18,4(r9)
   18f04:	4491883a 	add	r8,r8,r18
   18f08:	18c00044 	addi	r3,r3,1
   18f0c:	da011d15 	stw	r8,1140(sp)
   18f10:	d8c11c15 	stw	r3,1136(sp)
   18f14:	008001c4 	movi	r2,7
   18f18:	10ffe816 	blt	r2,r3,18ebc <___vfprintf_internal_r+0x1950>
   18f1c:	4a400204 	addi	r9,r9,8
   18f20:	003fee06 	br	18edc <___vfprintf_internal_r+0x1970>
   18f24:	df012b15 	stw	fp,1196(sp)
   18f28:	00800184 	movi	r2,6
   18f2c:	1700072e 	bgeu	r2,fp,18f4c <___vfprintf_internal_r+0x19e0>
   18f30:	d8812b15 	stw	r2,1196(sp)
   18f34:	d8812815 	stw	r2,1184(sp)
   18f38:	ddc12d15 	stw	r23,1204(sp)
   18f3c:	04c000f4 	movhi	r19,3
   18f40:	9cfff004 	addi	r19,r19,-64
   18f44:	d8013115 	stw	zero,1220(sp)
   18f48:	003a7a06 	br	17934 <___vfprintf_internal_r+0x3c8>
   18f4c:	d8812b17 	ldw	r2,1196(sp)
   18f50:	d8812815 	stw	r2,1184(sp)
   18f54:	103ff80e 	bge	r2,zero,18f38 <___vfprintf_internal_r+0x19cc>
   18f58:	d8012815 	stw	zero,1184(sp)
   18f5c:	003ff606 	br	18f38 <___vfprintf_internal_r+0x19cc>
   18f60:	d9012d17 	ldw	r4,1204(sp)
   18f64:	da012c17 	ldw	r8,1200(sp)
   18f68:	20800017 	ldw	r2,0(r4)
   18f6c:	21000104 	addi	r4,r4,4
   18f70:	d9012d15 	stw	r4,1204(sp)
   18f74:	12000015 	stw	r8,0(r2)
   18f78:	0039b206 	br	17644 <___vfprintf_internal_r+0xd8>
   18f7c:	d9412917 	ldw	r5,1188(sp)
   18f80:	8809883a 	mov	r4,r17
   18f84:	d9811b04 	addi	r6,sp,1132
   18f88:	00175380 	call	17538 <__sprint_r>
   18f8c:	103b0a1e 	bne	r2,zero,17bb8 <___vfprintf_internal_r+0x64c>
   18f90:	dc812417 	ldw	r18,1168(sp)
   18f94:	da011d17 	ldw	r8,1140(sp)
   18f98:	da400404 	addi	r9,sp,16
   18f9c:	003def06 	br	1875c <___vfprintf_internal_r+0x11f0>
   18fa0:	d9412917 	ldw	r5,1188(sp)
   18fa4:	8809883a 	mov	r4,r17
   18fa8:	d9811b04 	addi	r6,sp,1132
   18fac:	00175380 	call	17538 <__sprint_r>
   18fb0:	103b011e 	bne	r2,zero,17bb8 <___vfprintf_internal_r+0x64c>
   18fb4:	dc812417 	ldw	r18,1168(sp)
   18fb8:	da400404 	addi	r9,sp,16
   18fbc:	003eb906 	br	18aa4 <___vfprintf_internal_r+0x1538>
   18fc0:	d9412917 	ldw	r5,1188(sp)
   18fc4:	8809883a 	mov	r4,r17
   18fc8:	d9811b04 	addi	r6,sp,1132
   18fcc:	00175380 	call	17538 <__sprint_r>
   18fd0:	103af91e 	bne	r2,zero,17bb8 <___vfprintf_internal_r+0x64c>
   18fd4:	dc812417 	ldw	r18,1168(sp)
   18fd8:	da011d17 	ldw	r8,1140(sp)
   18fdc:	d8c11c17 	ldw	r3,1136(sp)
   18fe0:	da400404 	addi	r9,sp,16
   18fe4:	003ea306 	br	18a74 <___vfprintf_internal_r+0x1508>
   18fe8:	00800244 	movi	r2,9
   18fec:	15fda636 	bltu	r2,r23,18688 <___vfprintf_internal_r+0x111c>
   18ff0:	dd010e04 	addi	r20,sp,1080
   18ff4:	003dc206 	br	18700 <___vfprintf_internal_r+0x1194>
   18ff8:	df012815 	stw	fp,1184(sp)
   18ffc:	d8812583 	ldbu	r2,1174(sp)
   19000:	df012b15 	stw	fp,1196(sp)
   19004:	ddc12d15 	stw	r23,1204(sp)
   19008:	d8013115 	stw	zero,1220(sp)
   1900c:	003a4206 	br	17918 <___vfprintf_internal_r+0x3ac>
   19010:	d9412917 	ldw	r5,1188(sp)
   19014:	8809883a 	mov	r4,r17
   19018:	d9811b04 	addi	r6,sp,1132
   1901c:	00175380 	call	17538 <__sprint_r>
   19020:	103ae51e 	bne	r2,zero,17bb8 <___vfprintf_internal_r+0x64c>
   19024:	dc812417 	ldw	r18,1168(sp)
   19028:	da011d17 	ldw	r8,1140(sp)
   1902c:	d8c11c17 	ldw	r3,1136(sp)
   19030:	da400404 	addi	r9,sp,16
   19034:	003ec906 	br	18b5c <___vfprintf_internal_r+0x15f0>
   19038:	04c000f4 	movhi	r19,3
   1903c:	9cffe504 	addi	r19,r19,-108
   19040:	003f6f06 	br	18e00 <___vfprintf_internal_r+0x1894>
   19044:	d8812583 	ldbu	r2,1174(sp)
   19048:	dc012a17 	ldw	r16,1192(sp)
   1904c:	d8013115 	stw	zero,1220(sp)
   19050:	003a3106 	br	17918 <___vfprintf_internal_r+0x3ac>
   19054:	d8812404 	addi	r2,sp,1168
   19058:	d8800115 	stw	r2,4(sp)
   1905c:	d8812304 	addi	r2,sp,1164
   19060:	d8800215 	stw	r2,8(sp)
   19064:	d8812204 	addi	r2,sp,1160
   19068:	df000015 	stw	fp,0(sp)
   1906c:	d8800315 	stw	r2,12(sp)
   19070:	8809883a 	mov	r4,r17
   19074:	b00b883a 	mov	r5,r22
   19078:	a00d883a 	mov	r6,r20
   1907c:	01c000c4 	movi	r7,3
   19080:	da413c15 	stw	r9,1264(sp)
   19084:	001985c0 	call	1985c <_dtoa_r>
   19088:	da413c17 	ldw	r9,1264(sp)
   1908c:	1027883a 	mov	r19,r2
   19090:	1707883a 	add	r3,r2,fp
   19094:	e02f883a 	mov	r23,fp
   19098:	99000007 	ldb	r4,0(r19)
   1909c:	00800c04 	movi	r2,48
   190a0:	20800326 	beq	r4,r2,190b0 <___vfprintf_internal_r+0x1b44>
   190a4:	da812417 	ldw	r10,1168(sp)
   190a8:	1a87883a 	add	r3,r3,r10
   190ac:	003ef406 	br	18c80 <___vfprintf_internal_r+0x1714>
   190b0:	b009883a 	mov	r4,r22
   190b4:	a00b883a 	mov	r5,r20
   190b8:	000d883a 	mov	r6,zero
   190bc:	000f883a 	mov	r7,zero
   190c0:	d8c13b15 	stw	r3,1260(sp)
   190c4:	da413c15 	stw	r9,1264(sp)
   190c8:	001fa5c0 	call	1fa5c <__nedf2>
   190cc:	d8c13b17 	ldw	r3,1260(sp)
   190d0:	da413c17 	ldw	r9,1264(sp)
   190d4:	103ff326 	beq	r2,zero,190a4 <___vfprintf_internal_r+0x1b38>
   190d8:	00800044 	movi	r2,1
   190dc:	15d5c83a 	sub	r10,r2,r23
   190e0:	da812415 	stw	r10,1168(sp)
   190e4:	1a87883a 	add	r3,r3,r10
   190e8:	003ee506 	br	18c80 <___vfprintf_internal_r+0x1714>
   190ec:	d8812417 	ldw	r2,1168(sp)
   190f0:	d8812b15 	stw	r2,1196(sp)
   190f4:	1029883a 	mov	r20,r2
   190f8:	00bfff44 	movi	r2,-3
   190fc:	a0800116 	blt	r20,r2,19104 <___vfprintf_internal_r+0x1b98>
   19100:	e5001d0e 	bge	fp,r20,19178 <___vfprintf_internal_r+0x1c0c>
   19104:	94bfff84 	addi	r18,r18,-2
   19108:	a53fffc4 	addi	r20,r20,-1
   1910c:	dd012415 	stw	r20,1168(sp)
   19110:	dc811fc5 	stb	r18,1151(sp)
   19114:	a0007816 	blt	r20,zero,192f8 <___vfprintf_internal_r+0x1d8c>
   19118:	00800ac4 	movi	r2,43
   1911c:	d8812005 	stb	r2,1152(sp)
   19120:	00800244 	movi	r2,9
   19124:	15002b16 	blt	r2,r20,191d4 <___vfprintf_internal_r+0x1c68>
   19128:	00800c04 	movi	r2,48
   1912c:	a5000c04 	addi	r20,r20,48
   19130:	d8812045 	stb	r2,1153(sp)
   19134:	dd012085 	stb	r20,1154(sp)
   19138:	d8c120c4 	addi	r3,sp,1155
   1913c:	d8811fc4 	addi	r2,sp,1151
   19140:	da013217 	ldw	r8,1224(sp)
   19144:	1885c83a 	sub	r2,r3,r2
   19148:	d8813515 	stw	r2,1236(sp)
   1914c:	4085883a 	add	r2,r8,r2
   19150:	d8812b15 	stw	r2,1196(sp)
   19154:	00800044 	movi	r2,1
   19158:	1200610e 	bge	r2,r8,192e0 <___vfprintf_internal_r+0x1d74>
   1915c:	d8812b17 	ldw	r2,1196(sp)
   19160:	10800044 	addi	r2,r2,1
   19164:	d8812b15 	stw	r2,1196(sp)
   19168:	d8812815 	stw	r2,1184(sp)
   1916c:	103ee90e 	bge	r2,zero,18d14 <___vfprintf_internal_r+0x17a8>
   19170:	d8012815 	stw	zero,1184(sp)
   19174:	003ee706 	br	18d14 <___vfprintf_internal_r+0x17a8>
   19178:	d8812b17 	ldw	r2,1196(sp)
   1917c:	da013217 	ldw	r8,1224(sp)
   19180:	12003716 	blt	r2,r8,19260 <___vfprintf_internal_r+0x1cf4>
   19184:	8400004c 	andi	r16,r16,1
   19188:	80000326 	beq	r16,zero,19198 <___vfprintf_internal_r+0x1c2c>
   1918c:	d8812b17 	ldw	r2,1196(sp)
   19190:	10800044 	addi	r2,r2,1
   19194:	d8812b15 	stw	r2,1196(sp)
   19198:	d8812815 	stw	r2,1184(sp)
   1919c:	10003716 	blt	r2,zero,1927c <___vfprintf_internal_r+0x1d10>
   191a0:	048019c4 	movi	r18,103
   191a4:	003edb06 	br	18d14 <___vfprintf_internal_r+0x17a8>
   191a8:	d8012815 	stw	zero,1184(sp)
   191ac:	003b6906 	br	17f54 <___vfprintf_internal_r+0x9e8>
   191b0:	e03e901e 	bne	fp,zero,18bf4 <___vfprintf_internal_r+0x1688>
   191b4:	07000044 	movi	fp,1
   191b8:	003e8e06 	br	18bf4 <___vfprintf_internal_r+0x1688>
   191bc:	07000184 	movi	fp,6
   191c0:	003e8c06 	br	18bf4 <___vfprintf_internal_r+0x1688>
   191c4:	00c00b44 	movi	r3,45
   191c8:	a520003c 	xorhi	r20,r20,32768
   191cc:	d8c12f05 	stb	r3,1212(sp)
   191d0:	003e8c06 	br	18c04 <___vfprintf_internal_r+0x1698>
   191d4:	d8c11f84 	addi	r3,sp,1150
   191d8:	102f883a 	mov	r23,r2
   191dc:	4839883a 	mov	fp,r9
   191e0:	a009883a 	mov	r4,r20
   191e4:	01400284 	movi	r5,10
   191e8:	182d883a 	mov	r22,r3
   191ec:	001ff640 	call	1ff64 <__modsi3>
   191f0:	10800c04 	addi	r2,r2,48
   191f4:	a009883a 	mov	r4,r20
   191f8:	b0800005 	stb	r2,0(r22)
   191fc:	01400284 	movi	r5,10
   19200:	001ff140 	call	1ff14 <__divsi3>
   19204:	1029883a 	mov	r20,r2
   19208:	b0ffffc4 	addi	r3,r22,-1
   1920c:	b8bff416 	blt	r23,r2,191e0 <___vfprintf_internal_r+0x1c74>
   19210:	11400c04 	addi	r5,r2,48
   19214:	b17fffc5 	stb	r5,-1(r22)
   19218:	d8811fc4 	addi	r2,sp,1151
   1921c:	e013883a 	mov	r9,fp
   19220:	1880482e 	bgeu	r3,r2,19344 <___vfprintf_internal_r+0x1dd8>
   19224:	b007883a 	mov	r3,r22
   19228:	d9012044 	addi	r4,sp,1153
   1922c:	00000206 	br	19238 <___vfprintf_internal_r+0x1ccc>
   19230:	19400003 	ldbu	r5,0(r3)
   19234:	18c00044 	addi	r3,r3,1
   19238:	21400005 	stb	r5,0(r4)
   1923c:	21000044 	addi	r4,r4,1
   19240:	10fffb1e 	bne	r2,r3,19230 <___vfprintf_internal_r+0x1cc4>
   19244:	d8c12004 	addi	r3,sp,1152
   19248:	1d87c83a 	sub	r3,r3,r22
   1924c:	d9012044 	addi	r4,sp,1153
   19250:	20c7883a 	add	r3,r4,r3
   19254:	003fba06 	br	19140 <___vfprintf_internal_r+0x1bd4>
   19258:	d8c12217 	ldw	r3,1160(sp)
   1925c:	003e9906 	br	18cc4 <___vfprintf_internal_r+0x1758>
   19260:	05000b0e 	bge	zero,r20,19290 <___vfprintf_internal_r+0x1d24>
   19264:	05000044 	movi	r20,1
   19268:	da013217 	ldw	r8,1224(sp)
   1926c:	a229883a 	add	r20,r20,r8
   19270:	dd012b15 	stw	r20,1196(sp)
   19274:	dd012815 	stw	r20,1184(sp)
   19278:	a03fc90e 	bge	r20,zero,191a0 <___vfprintf_internal_r+0x1c34>
   1927c:	d8012815 	stw	zero,1184(sp)
   19280:	048019c4 	movi	r18,103
   19284:	003ea306 	br	18d14 <___vfprintf_internal_r+0x17a8>
   19288:	e5c00044 	addi	r23,fp,1
   1928c:	003e6606 	br	18c28 <___vfprintf_internal_r+0x16bc>
   19290:	00800084 	movi	r2,2
   19294:	1529c83a 	sub	r20,r2,r20
   19298:	003ff306 	br	19268 <___vfprintf_internal_r+0x1cfc>
   1929c:	008011c4 	movi	r2,71
   192a0:	90be7226 	beq	r18,r2,18c6c <___vfprintf_internal_r+0x1700>
   192a4:	003e7306 	br	18c74 <___vfprintf_internal_r+0x1708>
   192a8:	d8812d17 	ldw	r2,1204(sp)
   192ac:	ac800043 	ldbu	r18,1(r21)
   192b0:	202b883a 	mov	r21,r4
   192b4:	17000017 	ldw	fp,0(r2)
   192b8:	10800104 	addi	r2,r2,4
   192bc:	d8812d15 	stw	r2,1204(sp)
   192c0:	e0001b16 	blt	fp,zero,19330 <___vfprintf_internal_r+0x1dc4>
   192c4:	94803fcc 	andi	r18,r18,255
   192c8:	9480201c 	xori	r18,r18,128
   192cc:	94bfe004 	addi	r18,r18,-128
   192d0:	00390406 	br	176e4 <___vfprintf_internal_r+0x178>
   192d4:	00bfffc4 	movi	r2,-1
   192d8:	d8812c15 	stw	r2,1200(sp)
   192dc:	003a2506 	br	17b74 <___vfprintf_internal_r+0x608>
   192e0:	80a0703a 	and	r16,r16,r2
   192e4:	803f9d1e 	bne	r16,zero,1915c <___vfprintf_internal_r+0x1bf0>
   192e8:	d8812b17 	ldw	r2,1196(sp)
   192ec:	d8812815 	stw	r2,1184(sp)
   192f0:	103e880e 	bge	r2,zero,18d14 <___vfprintf_internal_r+0x17a8>
   192f4:	003f9e06 	br	19170 <___vfprintf_internal_r+0x1c04>
   192f8:	00800b44 	movi	r2,45
   192fc:	0529c83a 	sub	r20,zero,r20
   19300:	d8812005 	stb	r2,1152(sp)
   19304:	003f8606 	br	19120 <___vfprintf_internal_r+0x1bb4>
   19308:	1007883a 	mov	r3,r2
   1930c:	003e6d06 	br	18cc4 <___vfprintf_internal_r+0x1758>
   19310:	e000021e 	bne	fp,zero,1931c <___vfprintf_internal_r+0x1db0>
   19314:	8400004c 	andi	r16,r16,1
   19318:	80000e26 	beq	r16,zero,19354 <___vfprintf_internal_r+0x1de8>
   1931c:	e7000084 	addi	fp,fp,2
   19320:	df012b15 	stw	fp,1196(sp)
   19324:	df012815 	stw	fp,1184(sp)
   19328:	e03e7a0e 	bge	fp,zero,18d14 <___vfprintf_internal_r+0x17a8>
   1932c:	003f9006 	br	19170 <___vfprintf_internal_r+0x1c04>
   19330:	94803fcc 	andi	r18,r18,255
   19334:	9480201c 	xori	r18,r18,128
   19338:	073fffc4 	movi	fp,-1
   1933c:	94bfe004 	addi	r18,r18,-128
   19340:	0038e806 	br	176e4 <___vfprintf_internal_r+0x178>
   19344:	d8c12044 	addi	r3,sp,1153
   19348:	003f7d06 	br	19140 <___vfprintf_internal_r+0x1bd4>
   1934c:	dd012417 	ldw	r20,1168(sp)
   19350:	003f6d06 	br	19108 <___vfprintf_internal_r+0x1b9c>
   19354:	00c00044 	movi	r3,1
   19358:	d8c12815 	stw	r3,1184(sp)
   1935c:	d8c12b15 	stw	r3,1196(sp)
   19360:	003e6c06 	br	18d14 <___vfprintf_internal_r+0x17a8>

00019364 <__vfprintf_internal>:
   19364:	008000f4 	movhi	r2,3
   19368:	1090f704 	addi	r2,r2,17372
   1936c:	2007883a 	mov	r3,r4
   19370:	11000017 	ldw	r4,0(r2)
   19374:	2805883a 	mov	r2,r5
   19378:	300f883a 	mov	r7,r6
   1937c:	180b883a 	mov	r5,r3
   19380:	100d883a 	mov	r6,r2
   19384:	001756c1 	jmpi	1756c <___vfprintf_internal_r>

00019388 <__swbuf_r>:
   19388:	defffc04 	addi	sp,sp,-16
   1938c:	dc800215 	stw	r18,8(sp)
   19390:	dc400115 	stw	r17,4(sp)
   19394:	dc000015 	stw	r16,0(sp)
   19398:	dfc00315 	stw	ra,12(sp)
   1939c:	2023883a 	mov	r17,r4
   193a0:	2825883a 	mov	r18,r5
   193a4:	3021883a 	mov	r16,r6
   193a8:	20000226 	beq	r4,zero,193b4 <__swbuf_r+0x2c>
   193ac:	20800e17 	ldw	r2,56(r4)
   193b0:	10003b26 	beq	r2,zero,194a0 <__swbuf_r+0x118>
   193b4:	8080030b 	ldhu	r2,12(r16)
   193b8:	80c00617 	ldw	r3,24(r16)
   193bc:	1080020c 	andi	r2,r2,8
   193c0:	10bfffcc 	andi	r2,r2,65535
   193c4:	10a0001c 	xori	r2,r2,32768
   193c8:	80c00215 	stw	r3,8(r16)
   193cc:	10a00004 	addi	r2,r2,-32768
   193d0:	10002226 	beq	r2,zero,1945c <__swbuf_r+0xd4>
   193d4:	80800417 	ldw	r2,16(r16)
   193d8:	10002026 	beq	r2,zero,1945c <__swbuf_r+0xd4>
   193dc:	80c00017 	ldw	r3,0(r16)
   193e0:	81000517 	ldw	r4,20(r16)
   193e4:	94803fcc 	andi	r18,r18,255
   193e8:	1885c83a 	sub	r2,r3,r2
   193ec:	1100250e 	bge	r2,r4,19484 <__swbuf_r+0xfc>
   193f0:	10800044 	addi	r2,r2,1
   193f4:	81400217 	ldw	r5,8(r16)
   193f8:	19000044 	addi	r4,r3,1
   193fc:	297fffc4 	addi	r5,r5,-1
   19400:	81400215 	stw	r5,8(r16)
   19404:	1c800005 	stb	r18,0(r3)
   19408:	80c00517 	ldw	r3,20(r16)
   1940c:	81000015 	stw	r4,0(r16)
   19410:	18800c26 	beq	r3,r2,19444 <__swbuf_r+0xbc>
   19414:	8080030b 	ldhu	r2,12(r16)
   19418:	1080004c 	andi	r2,r2,1
   1941c:	10000226 	beq	r2,zero,19428 <__swbuf_r+0xa0>
   19420:	00800284 	movi	r2,10
   19424:	90800726 	beq	r18,r2,19444 <__swbuf_r+0xbc>
   19428:	9005883a 	mov	r2,r18
   1942c:	dfc00317 	ldw	ra,12(sp)
   19430:	dc800217 	ldw	r18,8(sp)
   19434:	dc400117 	ldw	r17,4(sp)
   19438:	dc000017 	ldw	r16,0(sp)
   1943c:	dec00404 	addi	sp,sp,16
   19440:	f800283a 	ret
   19444:	8809883a 	mov	r4,r17
   19448:	800b883a 	mov	r5,r16
   1944c:	001ae780 	call	1ae78 <_fflush_r>
   19450:	103ff526 	beq	r2,zero,19428 <__swbuf_r+0xa0>
   19454:	04bfffc4 	movi	r18,-1
   19458:	003ff306 	br	19428 <__swbuf_r+0xa0>
   1945c:	8809883a 	mov	r4,r17
   19460:	800b883a 	mov	r5,r16
   19464:	00194e00 	call	194e0 <__swsetup_r>
   19468:	10000f1e 	bne	r2,zero,194a8 <__swbuf_r+0x120>
   1946c:	80800417 	ldw	r2,16(r16)
   19470:	80c00017 	ldw	r3,0(r16)
   19474:	81000517 	ldw	r4,20(r16)
   19478:	94803fcc 	andi	r18,r18,255
   1947c:	1885c83a 	sub	r2,r3,r2
   19480:	113fdb16 	blt	r2,r4,193f0 <__swbuf_r+0x68>
   19484:	8809883a 	mov	r4,r17
   19488:	800b883a 	mov	r5,r16
   1948c:	001ae780 	call	1ae78 <_fflush_r>
   19490:	103ff01e 	bne	r2,zero,19454 <__swbuf_r+0xcc>
   19494:	80c00017 	ldw	r3,0(r16)
   19498:	00800044 	movi	r2,1
   1949c:	003fd506 	br	193f4 <__swbuf_r+0x6c>
   194a0:	001b1200 	call	1b120 <__sinit>
   194a4:	003fc306 	br	193b4 <__swbuf_r+0x2c>
   194a8:	8080030b 	ldhu	r2,12(r16)
   194ac:	04bfffc4 	movi	r18,-1
   194b0:	10801014 	ori	r2,r2,64
   194b4:	8080030d 	sth	r2,12(r16)
   194b8:	00800244 	movi	r2,9
   194bc:	88800015 	stw	r2,0(r17)
   194c0:	003fd906 	br	19428 <__swbuf_r+0xa0>

000194c4 <__swbuf>:
   194c4:	00c000f4 	movhi	r3,3
   194c8:	18d0f704 	addi	r3,r3,17372
   194cc:	2005883a 	mov	r2,r4
   194d0:	19000017 	ldw	r4,0(r3)
   194d4:	280d883a 	mov	r6,r5
   194d8:	100b883a 	mov	r5,r2
   194dc:	00193881 	jmpi	19388 <__swbuf_r>

000194e0 <__swsetup_r>:
   194e0:	008000f4 	movhi	r2,3
   194e4:	1090f704 	addi	r2,r2,17372
   194e8:	10800017 	ldw	r2,0(r2)
   194ec:	defffd04 	addi	sp,sp,-12
   194f0:	dc400115 	stw	r17,4(sp)
   194f4:	dc000015 	stw	r16,0(sp)
   194f8:	dfc00215 	stw	ra,8(sp)
   194fc:	2023883a 	mov	r17,r4
   19500:	2821883a 	mov	r16,r5
   19504:	10000226 	beq	r2,zero,19510 <__swsetup_r+0x30>
   19508:	10c00e17 	ldw	r3,56(r2)
   1950c:	18003d26 	beq	r3,zero,19604 <__swsetup_r+0x124>
   19510:	8080030b 	ldhu	r2,12(r16)
   19514:	10c0020c 	andi	r3,r2,8
   19518:	18ffffcc 	andi	r3,r3,65535
   1951c:	18e0001c 	xori	r3,r3,32768
   19520:	18e00004 	addi	r3,r3,-32768
   19524:	18001226 	beq	r3,zero,19570 <__swsetup_r+0x90>
   19528:	80c00417 	ldw	r3,16(r16)
   1952c:	18001f26 	beq	r3,zero,195ac <__swsetup_r+0xcc>
   19530:	1100004c 	andi	r4,r2,1
   19534:	2000261e 	bne	r4,zero,195d0 <__swsetup_r+0xf0>
   19538:	1080008c 	andi	r2,r2,2
   1953c:	10bfffcc 	andi	r2,r2,65535
   19540:	10a0001c 	xori	r2,r2,32768
   19544:	10a00004 	addi	r2,r2,-32768
   19548:	1000311e 	bne	r2,zero,19610 <__swsetup_r+0x130>
   1954c:	80800517 	ldw	r2,20(r16)
   19550:	80800215 	stw	r2,8(r16)
   19554:	18002326 	beq	r3,zero,195e4 <__swsetup_r+0x104>
   19558:	0005883a 	mov	r2,zero
   1955c:	dfc00217 	ldw	ra,8(sp)
   19560:	dc400117 	ldw	r17,4(sp)
   19564:	dc000017 	ldw	r16,0(sp)
   19568:	dec00304 	addi	sp,sp,12
   1956c:	f800283a 	ret
   19570:	10c0040c 	andi	r3,r2,16
   19574:	18ffffcc 	andi	r3,r3,65535
   19578:	18e0001c 	xori	r3,r3,32768
   1957c:	18e00004 	addi	r3,r3,-32768
   19580:	18001e26 	beq	r3,zero,195fc <__swsetup_r+0x11c>
   19584:	10c0010c 	andi	r3,r2,4
   19588:	18ffffcc 	andi	r3,r3,65535
   1958c:	18e0001c 	xori	r3,r3,32768
   19590:	18e00004 	addi	r3,r3,-32768
   19594:	1800211e 	bne	r3,zero,1961c <__swsetup_r+0x13c>
   19598:	80c00417 	ldw	r3,16(r16)
   1959c:	11400214 	ori	r5,r2,8
   195a0:	8140030d 	sth	r5,12(r16)
   195a4:	2805883a 	mov	r2,r5
   195a8:	183fe11e 	bne	r3,zero,19530 <__swsetup_r+0x50>
   195ac:	1140a00c 	andi	r5,r2,640
   195b0:	01008004 	movi	r4,512
   195b4:	293fde26 	beq	r5,r4,19530 <__swsetup_r+0x50>
   195b8:	8809883a 	mov	r4,r17
   195bc:	800b883a 	mov	r5,r16
   195c0:	001be940 	call	1be94 <__smakebuf_r>
   195c4:	8080030b 	ldhu	r2,12(r16)
   195c8:	80c00417 	ldw	r3,16(r16)
   195cc:	003fd806 	br	19530 <__swsetup_r+0x50>
   195d0:	80800517 	ldw	r2,20(r16)
   195d4:	80000215 	stw	zero,8(r16)
   195d8:	0085c83a 	sub	r2,zero,r2
   195dc:	80800615 	stw	r2,24(r16)
   195e0:	183fdd1e 	bne	r3,zero,19558 <__swsetup_r+0x78>
   195e4:	8080030b 	ldhu	r2,12(r16)
   195e8:	1080200c 	andi	r2,r2,128
   195ec:	10bfffcc 	andi	r2,r2,65535
   195f0:	10a0001c 	xori	r2,r2,32768
   195f4:	10a00004 	addi	r2,r2,-32768
   195f8:	103fd826 	beq	r2,zero,1955c <__swsetup_r+0x7c>
   195fc:	00bfffc4 	movi	r2,-1
   19600:	003fd606 	br	1955c <__swsetup_r+0x7c>
   19604:	1009883a 	mov	r4,r2
   19608:	001b1200 	call	1b120 <__sinit>
   1960c:	003fc006 	br	19510 <__swsetup_r+0x30>
   19610:	0005883a 	mov	r2,zero
   19614:	80800215 	stw	r2,8(r16)
   19618:	003fce06 	br	19554 <__swsetup_r+0x74>
   1961c:	81400c17 	ldw	r5,48(r16)
   19620:	28000626 	beq	r5,zero,1963c <__swsetup_r+0x15c>
   19624:	80c01004 	addi	r3,r16,64
   19628:	28c00326 	beq	r5,r3,19638 <__swsetup_r+0x158>
   1962c:	8809883a 	mov	r4,r17
   19630:	001b4a40 	call	1b4a4 <_free_r>
   19634:	8080030b 	ldhu	r2,12(r16)
   19638:	80000c15 	stw	zero,48(r16)
   1963c:	80c00417 	ldw	r3,16(r16)
   19640:	013ff6c4 	movi	r4,-37
   19644:	2084703a 	and	r2,r4,r2
   19648:	80000115 	stw	zero,4(r16)
   1964c:	80c00015 	stw	r3,0(r16)
   19650:	003fd206 	br	1959c <__swsetup_r+0xbc>

00019654 <quorem>:
   19654:	defff704 	addi	sp,sp,-36
   19658:	dc400115 	stw	r17,4(sp)
   1965c:	20800417 	ldw	r2,16(r4)
   19660:	2c400417 	ldw	r17,16(r5)
   19664:	dd800615 	stw	r22,24(sp)
   19668:	dd400515 	stw	r21,20(sp)
   1966c:	dfc00815 	stw	ra,32(sp)
   19670:	ddc00715 	stw	r23,28(sp)
   19674:	dd000415 	stw	r20,16(sp)
   19678:	dcc00315 	stw	r19,12(sp)
   1967c:	dc800215 	stw	r18,8(sp)
   19680:	dc000015 	stw	r16,0(sp)
   19684:	202b883a 	mov	r21,r4
   19688:	282d883a 	mov	r22,r5
   1968c:	14407116 	blt	r2,r17,19854 <quorem+0x200>
   19690:	88800104 	addi	r2,r17,4
   19694:	1085883a 	add	r2,r2,r2
   19698:	1085883a 	add	r2,r2,r2
   1969c:	28a7883a 	add	r19,r5,r2
   196a0:	2085883a 	add	r2,r4,r2
   196a4:	15c00017 	ldw	r23,0(r2)
   196a8:	99400017 	ldw	r5,0(r19)
   196ac:	8c7fffc4 	addi	r17,r17,-1
   196b0:	b809883a 	mov	r4,r23
   196b4:	29400044 	addi	r5,r5,1
   196b8:	001ffc00 	call	1ffc0 <__udivsi3>
   196bc:	1025883a 	mov	r18,r2
   196c0:	b4000504 	addi	r16,r22,20
   196c4:	ad000504 	addi	r20,r21,20
   196c8:	10002d26 	beq	r2,zero,19780 <quorem+0x12c>
   196cc:	800d883a 	mov	r6,r16
   196d0:	a007883a 	mov	r3,r20
   196d4:	000f883a 	mov	r7,zero
   196d8:	0005883a 	mov	r2,zero
   196dc:	32c00017 	ldw	r11,0(r6)
   196e0:	1a400017 	ldw	r9,0(r3)
   196e4:	31800104 	addi	r6,r6,4
   196e8:	5abfffcc 	andi	r10,r11,65535
   196ec:	5495383a 	mul	r10,r10,r18
   196f0:	5816d43a 	srli	r11,r11,16
   196f4:	4a3fffcc 	andi	r8,r9,65535
   196f8:	3a95883a 	add	r10,r7,r10
   196fc:	500ed43a 	srli	r7,r10,16
   19700:	5c97383a 	mul	r11,r11,r18
   19704:	4085883a 	add	r2,r8,r2
   19708:	52bfffcc 	andi	r10,r10,65535
   1970c:	1291c83a 	sub	r8,r2,r10
   19710:	4804d43a 	srli	r2,r9,16
   19714:	3acf883a 	add	r7,r7,r11
   19718:	4015d43a 	srai	r10,r8,16
   1971c:	393fffcc 	andi	r4,r7,65535
   19720:	1105c83a 	sub	r2,r2,r4
   19724:	1285883a 	add	r2,r2,r10
   19728:	1880008d 	sth	r2,2(r3)
   1972c:	1a00000d 	sth	r8,0(r3)
   19730:	380ed43a 	srli	r7,r7,16
   19734:	1005d43a 	srai	r2,r2,16
   19738:	18c00104 	addi	r3,r3,4
   1973c:	99bfe72e 	bgeu	r19,r6,196dc <quorem+0x88>
   19740:	b8000f1e 	bne	r23,zero,19780 <quorem+0x12c>
   19744:	88800144 	addi	r2,r17,5
   19748:	1085883a 	add	r2,r2,r2
   1974c:	1085883a 	add	r2,r2,r2
   19750:	a887883a 	add	r3,r21,r2
   19754:	18bfff04 	addi	r2,r3,-4
   19758:	a080082e 	bgeu	r20,r2,1977c <quorem+0x128>
   1975c:	18ffff17 	ldw	r3,-4(r3)
   19760:	18000326 	beq	r3,zero,19770 <quorem+0x11c>
   19764:	00000506 	br	1977c <quorem+0x128>
   19768:	10c00017 	ldw	r3,0(r2)
   1976c:	1800031e 	bne	r3,zero,1977c <quorem+0x128>
   19770:	10bfff04 	addi	r2,r2,-4
   19774:	8c7fffc4 	addi	r17,r17,-1
   19778:	a0bffb36 	bltu	r20,r2,19768 <quorem+0x114>
   1977c:	ac400415 	stw	r17,16(r21)
   19780:	a809883a 	mov	r4,r21
   19784:	b00b883a 	mov	r5,r22
   19788:	001d2840 	call	1d284 <__mcmp>
   1978c:	10002516 	blt	r2,zero,19824 <quorem+0x1d0>
   19790:	94800044 	addi	r18,r18,1
   19794:	a007883a 	mov	r3,r20
   19798:	000b883a 	mov	r5,zero
   1979c:	1a000017 	ldw	r8,0(r3)
   197a0:	81c00017 	ldw	r7,0(r16)
   197a4:	84000104 	addi	r16,r16,4
   197a8:	41bfffcc 	andi	r6,r8,65535
   197ac:	38bfffcc 	andi	r2,r7,65535
   197b0:	314b883a 	add	r5,r6,r5
   197b4:	288dc83a 	sub	r6,r5,r2
   197b8:	380ed43a 	srli	r7,r7,16
   197bc:	400ad43a 	srli	r5,r8,16
   197c0:	3005d43a 	srai	r2,r6,16
   197c4:	1980000d 	sth	r6,0(r3)
   197c8:	29cbc83a 	sub	r5,r5,r7
   197cc:	288b883a 	add	r5,r5,r2
   197d0:	1940008d 	sth	r5,2(r3)
   197d4:	280bd43a 	srai	r5,r5,16
   197d8:	18c00104 	addi	r3,r3,4
   197dc:	9c3fef2e 	bgeu	r19,r16,1979c <quorem+0x148>
   197e0:	88800144 	addi	r2,r17,5
   197e4:	1085883a 	add	r2,r2,r2
   197e8:	1085883a 	add	r2,r2,r2
   197ec:	a885883a 	add	r2,r21,r2
   197f0:	10c00017 	ldw	r3,0(r2)
   197f4:	18000b1e 	bne	r3,zero,19824 <quorem+0x1d0>
   197f8:	10ffff04 	addi	r3,r2,-4
   197fc:	a0c0082e 	bgeu	r20,r3,19820 <quorem+0x1cc>
   19800:	10bfff17 	ldw	r2,-4(r2)
   19804:	10000326 	beq	r2,zero,19814 <quorem+0x1c0>
   19808:	00000506 	br	19820 <quorem+0x1cc>
   1980c:	18800017 	ldw	r2,0(r3)
   19810:	1000031e 	bne	r2,zero,19820 <quorem+0x1cc>
   19814:	18ffff04 	addi	r3,r3,-4
   19818:	8c7fffc4 	addi	r17,r17,-1
   1981c:	a0fffb36 	bltu	r20,r3,1980c <quorem+0x1b8>
   19820:	ac400415 	stw	r17,16(r21)
   19824:	9005883a 	mov	r2,r18
   19828:	dfc00817 	ldw	ra,32(sp)
   1982c:	ddc00717 	ldw	r23,28(sp)
   19830:	dd800617 	ldw	r22,24(sp)
   19834:	dd400517 	ldw	r21,20(sp)
   19838:	dd000417 	ldw	r20,16(sp)
   1983c:	dcc00317 	ldw	r19,12(sp)
   19840:	dc800217 	ldw	r18,8(sp)
   19844:	dc400117 	ldw	r17,4(sp)
   19848:	dc000017 	ldw	r16,0(sp)
   1984c:	dec00904 	addi	sp,sp,36
   19850:	f800283a 	ret
   19854:	0005883a 	mov	r2,zero
   19858:	003ff306 	br	19828 <quorem+0x1d4>

0001985c <_dtoa_r>:
   1985c:	20801017 	ldw	r2,64(r4)
   19860:	deffdf04 	addi	sp,sp,-132
   19864:	dcc01a15 	stw	r19,104(sp)
   19868:	dc801915 	stw	r18,100(sp)
   1986c:	dc401815 	stw	r17,96(sp)
   19870:	dc001715 	stw	r16,92(sp)
   19874:	dfc02015 	stw	ra,128(sp)
   19878:	df001f15 	stw	fp,124(sp)
   1987c:	ddc01e15 	stw	r23,120(sp)
   19880:	dd801d15 	stw	r22,116(sp)
   19884:	dd401c15 	stw	r21,112(sp)
   19888:	dd001b15 	stw	r20,108(sp)
   1988c:	d9400315 	stw	r5,12(sp)
   19890:	d9c00415 	stw	r7,16(sp)
   19894:	2021883a 	mov	r16,r4
   19898:	3025883a 	mov	r18,r6
   1989c:	dcc02317 	ldw	r19,140(sp)
   198a0:	3023883a 	mov	r17,r6
   198a4:	10000826 	beq	r2,zero,198c8 <_dtoa_r+0x6c>
   198a8:	20c01117 	ldw	r3,68(r4)
   198ac:	01800044 	movi	r6,1
   198b0:	100b883a 	mov	r5,r2
   198b4:	30cc983a 	sll	r6,r6,r3
   198b8:	10c00115 	stw	r3,4(r2)
   198bc:	11800215 	stw	r6,8(r2)
   198c0:	001ca880 	call	1ca88 <_Bfree>
   198c4:	80001015 	stw	zero,64(r16)
   198c8:	90002f16 	blt	r18,zero,19988 <_dtoa_r+0x12c>
   198cc:	98000015 	stw	zero,0(r19)
   198d0:	90dffc2c 	andhi	r3,r18,32752
   198d4:	009ffc34 	movhi	r2,32752
   198d8:	18801c26 	beq	r3,r2,1994c <_dtoa_r+0xf0>
   198dc:	d9000317 	ldw	r4,12(sp)
   198e0:	880b883a 	mov	r5,r17
   198e4:	000d883a 	mov	r6,zero
   198e8:	000f883a 	mov	r7,zero
   198ec:	001fa000 	call	1fa00 <__eqdf2>
   198f0:	10002c1e 	bne	r2,zero,199a4 <_dtoa_r+0x148>
   198f4:	d9002217 	ldw	r4,136(sp)
   198f8:	d9c02417 	ldw	r7,144(sp)
   198fc:	00800044 	movi	r2,1
   19900:	20800015 	stw	r2,0(r4)
   19904:	38019426 	beq	r7,zero,19f58 <_dtoa_r+0x6fc>
   19908:	008000f4 	movhi	r2,3
   1990c:	10bff244 	addi	r2,r2,-55
   19910:	38800015 	stw	r2,0(r7)
   19914:	15ffffc4 	addi	r23,r2,-1
   19918:	b805883a 	mov	r2,r23
   1991c:	dfc02017 	ldw	ra,128(sp)
   19920:	df001f17 	ldw	fp,124(sp)
   19924:	ddc01e17 	ldw	r23,120(sp)
   19928:	dd801d17 	ldw	r22,116(sp)
   1992c:	dd401c17 	ldw	r21,112(sp)
   19930:	dd001b17 	ldw	r20,108(sp)
   19934:	dcc01a17 	ldw	r19,104(sp)
   19938:	dc801917 	ldw	r18,100(sp)
   1993c:	dc401817 	ldw	r17,96(sp)
   19940:	dc001717 	ldw	r16,92(sp)
   19944:	dec02104 	addi	sp,sp,132
   19948:	f800283a 	ret
   1994c:	d8c02217 	ldw	r3,136(sp)
   19950:	d9000317 	ldw	r4,12(sp)
   19954:	0089c3c4 	movi	r2,9999
   19958:	18800015 	stw	r2,0(r3)
   1995c:	20016c26 	beq	r4,zero,19f10 <_dtoa_r+0x6b4>
   19960:	05c000f4 	movhi	r23,3
   19964:	bdfffe04 	addi	r23,r23,-8
   19968:	d9c02417 	ldw	r7,144(sp)
   1996c:	383fea26 	beq	r7,zero,19918 <_dtoa_r+0xbc>
   19970:	b88000c7 	ldb	r2,3(r23)
   19974:	10016d1e 	bne	r2,zero,19f2c <_dtoa_r+0x6d0>
   19978:	b88000c4 	addi	r2,r23,3
   1997c:	d8c02417 	ldw	r3,144(sp)
   19980:	18800015 	stw	r2,0(r3)
   19984:	003fe406 	br	19918 <_dtoa_r+0xbc>
   19988:	04600034 	movhi	r17,32768
   1998c:	8c7fffc4 	addi	r17,r17,-1
   19990:	9462703a 	and	r17,r18,r17
   19994:	00800044 	movi	r2,1
   19998:	98800015 	stw	r2,0(r19)
   1999c:	8825883a 	mov	r18,r17
   199a0:	003fcb06 	br	198d0 <_dtoa_r+0x74>
   199a4:	d9400317 	ldw	r5,12(sp)
   199a8:	9028d53a 	srli	r20,r18,20
   199ac:	d8800204 	addi	r2,sp,8
   199b0:	d8800015 	stw	r2,0(sp)
   199b4:	8009883a 	mov	r4,r16
   199b8:	880d883a 	mov	r6,r17
   199bc:	d9c00104 	addi	r7,sp,4
   199c0:	001d62c0 	call	1d62c <__d2b>
   199c4:	a501ffcc 	andi	r20,r20,2047
   199c8:	1039883a 	mov	fp,r2
   199cc:	a001591e 	bne	r20,zero,19f34 <_dtoa_r+0x6d8>
   199d0:	dd400217 	ldw	r21,8(sp)
   199d4:	dd000117 	ldw	r20,4(sp)
   199d8:	00befbc4 	movi	r2,-1041
   199dc:	ad29883a 	add	r20,r21,r20
   199e0:	a082d216 	blt	r20,r2,1a52c <_dtoa_r+0xcd0>
   199e4:	d8c00317 	ldw	r3,12(sp)
   199e8:	013f0384 	movi	r4,-1010
   199ec:	2509c83a 	sub	r4,r4,r20
   199f0:	a0810484 	addi	r2,r20,1042
   199f4:	9124983a 	sll	r18,r18,r4
   199f8:	1884d83a 	srl	r2,r3,r2
   199fc:	9088b03a 	or	r4,r18,r2
   19a00:	001fd840 	call	1fd84 <__floatunsidf>
   19a04:	1009883a 	mov	r4,r2
   19a08:	017f8434 	movhi	r5,65040
   19a0c:	00800044 	movi	r2,1
   19a10:	194b883a 	add	r5,r3,r5
   19a14:	a53fffc4 	addi	r20,r20,-1
   19a18:	d8800f15 	stw	r2,60(sp)
   19a1c:	000d883a 	mov	r6,zero
   19a20:	01cffe34 	movhi	r7,16376
   19a24:	001f5080 	call	1f508 <__subdf3>
   19a28:	1009883a 	mov	r4,r2
   19a2c:	180b883a 	mov	r5,r3
   19a30:	0198dbf4 	movhi	r6,25455
   19a34:	3190d844 	addi	r6,r6,17249
   19a38:	01cff4f4 	movhi	r7,16339
   19a3c:	39e1e9c4 	addi	r7,r7,-30809
   19a40:	001f5680 	call	1f568 <__muldf3>
   19a44:	180b883a 	mov	r5,r3
   19a48:	01a2d874 	movhi	r6,35681
   19a4c:	31b22cc4 	addi	r6,r6,-14157
   19a50:	01cff1f4 	movhi	r7,16327
   19a54:	39e28a04 	addi	r7,r7,-30168
   19a58:	1009883a 	mov	r4,r2
   19a5c:	001f4b40 	call	1f4b4 <__adddf3>
   19a60:	a009883a 	mov	r4,r20
   19a64:	1027883a 	mov	r19,r2
   19a68:	1825883a 	mov	r18,r3
   19a6c:	001fbdc0 	call	1fbdc <__floatsidf>
   19a70:	1009883a 	mov	r4,r2
   19a74:	180b883a 	mov	r5,r3
   19a78:	019427f4 	movhi	r6,20639
   19a7c:	319e7ec4 	addi	r6,r6,31227
   19a80:	01cff4f4 	movhi	r7,16339
   19a84:	39d104c4 	addi	r7,r7,17427
   19a88:	001f5680 	call	1f568 <__muldf3>
   19a8c:	9809883a 	mov	r4,r19
   19a90:	900b883a 	mov	r5,r18
   19a94:	100d883a 	mov	r6,r2
   19a98:	180f883a 	mov	r7,r3
   19a9c:	001f4b40 	call	1f4b4 <__adddf3>
   19aa0:	1009883a 	mov	r4,r2
   19aa4:	180b883a 	mov	r5,r3
   19aa8:	1027883a 	mov	r19,r2
   19aac:	1825883a 	mov	r18,r3
   19ab0:	001fcb00 	call	1fcb0 <__fixdfsi>
   19ab4:	9809883a 	mov	r4,r19
   19ab8:	900b883a 	mov	r5,r18
   19abc:	000d883a 	mov	r6,zero
   19ac0:	000f883a 	mov	r7,zero
   19ac4:	d8800615 	stw	r2,24(sp)
   19ac8:	001fb800 	call	1fb80 <__ltdf2>
   19acc:	10027e16 	blt	r2,zero,1a4c8 <_dtoa_r+0xc6c>
   19ad0:	d8c00617 	ldw	r3,24(sp)
   19ad4:	00800584 	movi	r2,22
   19ad8:	10c26c36 	bltu	r2,r3,1a48c <_dtoa_r+0xc30>
   19adc:	180490fa 	slli	r2,r3,3
   19ae0:	00c000f4 	movhi	r3,3
   19ae4:	18c02304 	addi	r3,r3,140
   19ae8:	d9800317 	ldw	r6,12(sp)
   19aec:	1885883a 	add	r2,r3,r2
   19af0:	11000017 	ldw	r4,0(r2)
   19af4:	11400117 	ldw	r5,4(r2)
   19af8:	880f883a 	mov	r7,r17
   19afc:	001fab80 	call	1fab8 <__gtdf2>
   19b00:	00828f0e 	bge	zero,r2,1a540 <_dtoa_r+0xce4>
   19b04:	d8800617 	ldw	r2,24(sp)
   19b08:	d8000d15 	stw	zero,52(sp)
   19b0c:	10bfffc4 	addi	r2,r2,-1
   19b10:	d8800615 	stw	r2,24(sp)
   19b14:	ad29c83a 	sub	r20,r21,r20
   19b18:	a53fffc4 	addi	r20,r20,-1
   19b1c:	a0026616 	blt	r20,zero,1a4b8 <_dtoa_r+0xc5c>
   19b20:	dd000715 	stw	r20,28(sp)
   19b24:	d8000815 	stw	zero,32(sp)
   19b28:	d8800617 	ldw	r2,24(sp)
   19b2c:	10025a16 	blt	r2,zero,1a498 <_dtoa_r+0xc3c>
   19b30:	d8c00717 	ldw	r3,28(sp)
   19b34:	d8800b15 	stw	r2,44(sp)
   19b38:	d8000a15 	stw	zero,40(sp)
   19b3c:	1887883a 	add	r3,r3,r2
   19b40:	d8c00715 	stw	r3,28(sp)
   19b44:	d9c00417 	ldw	r7,16(sp)
   19b48:	00800244 	movi	r2,9
   19b4c:	11c10536 	bltu	r2,r7,19f64 <_dtoa_r+0x708>
   19b50:	00800144 	movi	r2,5
   19b54:	11c4c60e 	bge	r2,r7,1ae70 <_dtoa_r+0x1614>
   19b58:	39ffff04 	addi	r7,r7,-4
   19b5c:	d9c00415 	stw	r7,16(sp)
   19b60:	0027883a 	mov	r19,zero
   19b64:	d9c00417 	ldw	r7,16(sp)
   19b68:	008000c4 	movi	r2,3
   19b6c:	3883a226 	beq	r7,r2,1a9f8 <_dtoa_r+0x119c>
   19b70:	11c2bc16 	blt	r2,r7,1a664 <_dtoa_r+0xe08>
   19b74:	00800084 	movi	r2,2
   19b78:	3880fb1e 	bne	r7,r2,19f68 <_dtoa_r+0x70c>
   19b7c:	d8000c15 	stw	zero,48(sp)
   19b80:	d9002117 	ldw	r4,132(sp)
   19b84:	0103ae0e 	bge	zero,r4,1aa40 <_dtoa_r+0x11e4>
   19b88:	2025883a 	mov	r18,r4
   19b8c:	d9000e15 	stw	r4,56(sp)
   19b90:	d9000915 	stw	r4,36(sp)
   19b94:	80001115 	stw	zero,68(r16)
   19b98:	008005c4 	movi	r2,23
   19b9c:	1484b22e 	bgeu	r2,r18,1ae68 <_dtoa_r+0x160c>
   19ba0:	00c00044 	movi	r3,1
   19ba4:	00800104 	movi	r2,4
   19ba8:	1085883a 	add	r2,r2,r2
   19bac:	11000504 	addi	r4,r2,20
   19bb0:	180b883a 	mov	r5,r3
   19bb4:	18c00044 	addi	r3,r3,1
   19bb8:	913ffb2e 	bgeu	r18,r4,19ba8 <_dtoa_r+0x34c>
   19bbc:	81401115 	stw	r5,68(r16)
   19bc0:	8009883a 	mov	r4,r16
   19bc4:	001c9e00 	call	1c9e0 <_Balloc>
   19bc8:	102f883a 	mov	r23,r2
   19bcc:	80801015 	stw	r2,64(r16)
   19bd0:	00800384 	movi	r2,14
   19bd4:	1480f036 	bltu	r2,r18,19f98 <_dtoa_r+0x73c>
   19bd8:	9800ef26 	beq	r19,zero,19f98 <_dtoa_r+0x73c>
   19bdc:	d8800617 	ldw	r2,24(sp)
   19be0:	00839c0e 	bge	zero,r2,1aa54 <_dtoa_r+0x11f8>
   19be4:	d8c00617 	ldw	r3,24(sp)
   19be8:	108003cc 	andi	r2,r2,15
   19bec:	100490fa 	slli	r2,r2,3
   19bf0:	182bd13a 	srai	r21,r3,4
   19bf4:	00c000f4 	movhi	r3,3
   19bf8:	18c02304 	addi	r3,r3,140
   19bfc:	1885883a 	add	r2,r3,r2
   19c00:	a8c0040c 	andi	r3,r21,16
   19c04:	12800017 	ldw	r10,0(r2)
   19c08:	15800117 	ldw	r22,4(r2)
   19c0c:	18038726 	beq	r3,zero,1aa2c <_dtoa_r+0x11d0>
   19c10:	008000f4 	movhi	r2,3
   19c14:	10801904 	addi	r2,r2,100
   19c18:	11800817 	ldw	r6,32(r2)
   19c1c:	11c00917 	ldw	r7,36(r2)
   19c20:	d9000317 	ldw	r4,12(sp)
   19c24:	880b883a 	mov	r5,r17
   19c28:	da801515 	stw	r10,84(sp)
   19c2c:	001f84c0 	call	1f84c <__divdf3>
   19c30:	da801517 	ldw	r10,84(sp)
   19c34:	d8801015 	stw	r2,64(sp)
   19c38:	1829883a 	mov	r20,r3
   19c3c:	ad4003cc 	andi	r21,r21,15
   19c40:	048000c4 	movi	r18,3
   19c44:	a8001126 	beq	r21,zero,19c8c <_dtoa_r+0x430>
   19c48:	04c000f4 	movhi	r19,3
   19c4c:	9cc01904 	addi	r19,r19,100
   19c50:	5005883a 	mov	r2,r10
   19c54:	b007883a 	mov	r3,r22
   19c58:	a980004c 	andi	r6,r21,1
   19c5c:	1009883a 	mov	r4,r2
   19c60:	a82bd07a 	srai	r21,r21,1
   19c64:	180b883a 	mov	r5,r3
   19c68:	30000426 	beq	r6,zero,19c7c <_dtoa_r+0x420>
   19c6c:	99800017 	ldw	r6,0(r19)
   19c70:	99c00117 	ldw	r7,4(r19)
   19c74:	94800044 	addi	r18,r18,1
   19c78:	001f5680 	call	1f568 <__muldf3>
   19c7c:	9cc00204 	addi	r19,r19,8
   19c80:	a83ff51e 	bne	r21,zero,19c58 <_dtoa_r+0x3fc>
   19c84:	1015883a 	mov	r10,r2
   19c88:	182d883a 	mov	r22,r3
   19c8c:	d9001017 	ldw	r4,64(sp)
   19c90:	a00b883a 	mov	r5,r20
   19c94:	500d883a 	mov	r6,r10
   19c98:	b00f883a 	mov	r7,r22
   19c9c:	001f84c0 	call	1f84c <__divdf3>
   19ca0:	1027883a 	mov	r19,r2
   19ca4:	1829883a 	mov	r20,r3
   19ca8:	d8c00d17 	ldw	r3,52(sp)
   19cac:	18000626 	beq	r3,zero,19cc8 <_dtoa_r+0x46c>
   19cb0:	9809883a 	mov	r4,r19
   19cb4:	a00b883a 	mov	r5,r20
   19cb8:	000d883a 	mov	r6,zero
   19cbc:	01cffc34 	movhi	r7,16368
   19cc0:	001fb800 	call	1fb80 <__ltdf2>
   19cc4:	10040e16 	blt	r2,zero,1ad00 <_dtoa_r+0x14a4>
   19cc8:	9009883a 	mov	r4,r18
   19ccc:	001fbdc0 	call	1fbdc <__floatsidf>
   19cd0:	1009883a 	mov	r4,r2
   19cd4:	180b883a 	mov	r5,r3
   19cd8:	980d883a 	mov	r6,r19
   19cdc:	a00f883a 	mov	r7,r20
   19ce0:	001f5680 	call	1f568 <__muldf3>
   19ce4:	1009883a 	mov	r4,r2
   19ce8:	180b883a 	mov	r5,r3
   19cec:	000d883a 	mov	r6,zero
   19cf0:	01d00734 	movhi	r7,16412
   19cf4:	001f4b40 	call	1f4b4 <__adddf3>
   19cf8:	057f3034 	movhi	r21,64704
   19cfc:	1d6b883a 	add	r21,r3,r21
   19d00:	d8c00917 	ldw	r3,36(sp)
   19d04:	1025883a 	mov	r18,r2
   19d08:	18031f26 	beq	r3,zero,1a988 <_dtoa_r+0x112c>
   19d0c:	d8800617 	ldw	r2,24(sp)
   19d10:	dac00917 	ldw	r11,36(sp)
   19d14:	d8801315 	stw	r2,76(sp)
   19d18:	d8c00c17 	ldw	r3,48(sp)
   19d1c:	18039026 	beq	r3,zero,1ab60 <_dtoa_r+0x1304>
   19d20:	58bfffc4 	addi	r2,r11,-1
   19d24:	100490fa 	slli	r2,r2,3
   19d28:	00c000f4 	movhi	r3,3
   19d2c:	18c02304 	addi	r3,r3,140
   19d30:	0009883a 	mov	r4,zero
   19d34:	1885883a 	add	r2,r3,r2
   19d38:	11800017 	ldw	r6,0(r2)
   19d3c:	11c00117 	ldw	r7,4(r2)
   19d40:	014ff834 	movhi	r5,16352
   19d44:	dac01615 	stw	r11,88(sp)
   19d48:	001f84c0 	call	1f84c <__divdf3>
   19d4c:	900d883a 	mov	r6,r18
   19d50:	a80f883a 	mov	r7,r21
   19d54:	1009883a 	mov	r4,r2
   19d58:	180b883a 	mov	r5,r3
   19d5c:	001f5080 	call	1f508 <__subdf3>
   19d60:	a00b883a 	mov	r5,r20
   19d64:	9809883a 	mov	r4,r19
   19d68:	182b883a 	mov	r21,r3
   19d6c:	d8801015 	stw	r2,64(sp)
   19d70:	001fcb00 	call	1fcb0 <__fixdfsi>
   19d74:	1009883a 	mov	r4,r2
   19d78:	d8801515 	stw	r2,84(sp)
   19d7c:	001fbdc0 	call	1fbdc <__floatsidf>
   19d80:	9809883a 	mov	r4,r19
   19d84:	a00b883a 	mov	r5,r20
   19d88:	100d883a 	mov	r6,r2
   19d8c:	180f883a 	mov	r7,r3
   19d90:	001f5080 	call	1f508 <__subdf3>
   19d94:	da401517 	ldw	r9,84(sp)
   19d98:	d9001017 	ldw	r4,64(sp)
   19d9c:	a80b883a 	mov	r5,r21
   19da0:	4d000c04 	addi	r20,r9,48
   19da4:	bd000005 	stb	r20,0(r23)
   19da8:	100d883a 	mov	r6,r2
   19dac:	180f883a 	mov	r7,r3
   19db0:	bd800044 	addi	r22,r23,1
   19db4:	1025883a 	mov	r18,r2
   19db8:	1827883a 	mov	r19,r3
   19dbc:	001fab80 	call	1fab8 <__gtdf2>
   19dc0:	00842216 	blt	zero,r2,1ae4c <_dtoa_r+0x15f0>
   19dc4:	0009883a 	mov	r4,zero
   19dc8:	014ffc34 	movhi	r5,16368
   19dcc:	900d883a 	mov	r6,r18
   19dd0:	980f883a 	mov	r7,r19
   19dd4:	001f5080 	call	1f508 <__subdf3>
   19dd8:	d9001017 	ldw	r4,64(sp)
   19ddc:	a80b883a 	mov	r5,r21
   19de0:	100d883a 	mov	r6,r2
   19de4:	180f883a 	mov	r7,r3
   19de8:	001fab80 	call	1fab8 <__gtdf2>
   19dec:	dac01617 	ldw	r11,88(sp)
   19df0:	00841316 	blt	zero,r2,1ae40 <_dtoa_r+0x15e4>
   19df4:	00800044 	movi	r2,1
   19df8:	12c0670e 	bge	r2,r11,19f98 <_dtoa_r+0x73c>
   19dfc:	bad7883a 	add	r11,r23,r11
   19e00:	df001115 	stw	fp,68(sp)
   19e04:	dc401215 	stw	r17,72(sp)
   19e08:	5839883a 	mov	fp,r11
   19e0c:	dc401017 	ldw	r17,64(sp)
   19e10:	00000806 	br	19e34 <_dtoa_r+0x5d8>
   19e14:	001f5080 	call	1f508 <__subdf3>
   19e18:	1009883a 	mov	r4,r2
   19e1c:	180b883a 	mov	r5,r3
   19e20:	880d883a 	mov	r6,r17
   19e24:	a80f883a 	mov	r7,r21
   19e28:	001fb800 	call	1fb80 <__ltdf2>
   19e2c:	1003ee16 	blt	r2,zero,1ade8 <_dtoa_r+0x158c>
   19e30:	b703f126 	beq	r22,fp,1adf8 <_dtoa_r+0x159c>
   19e34:	8809883a 	mov	r4,r17
   19e38:	a80b883a 	mov	r5,r21
   19e3c:	000d883a 	mov	r6,zero
   19e40:	01d00934 	movhi	r7,16420
   19e44:	001f5680 	call	1f568 <__muldf3>
   19e48:	000d883a 	mov	r6,zero
   19e4c:	01d00934 	movhi	r7,16420
   19e50:	9009883a 	mov	r4,r18
   19e54:	980b883a 	mov	r5,r19
   19e58:	1023883a 	mov	r17,r2
   19e5c:	182b883a 	mov	r21,r3
   19e60:	001f5680 	call	1f568 <__muldf3>
   19e64:	180b883a 	mov	r5,r3
   19e68:	1009883a 	mov	r4,r2
   19e6c:	1825883a 	mov	r18,r3
   19e70:	1027883a 	mov	r19,r2
   19e74:	001fcb00 	call	1fcb0 <__fixdfsi>
   19e78:	1009883a 	mov	r4,r2
   19e7c:	1029883a 	mov	r20,r2
   19e80:	001fbdc0 	call	1fbdc <__floatsidf>
   19e84:	9809883a 	mov	r4,r19
   19e88:	900b883a 	mov	r5,r18
   19e8c:	100d883a 	mov	r6,r2
   19e90:	180f883a 	mov	r7,r3
   19e94:	001f5080 	call	1f508 <__subdf3>
   19e98:	a5000c04 	addi	r20,r20,48
   19e9c:	b5000005 	stb	r20,0(r22)
   19ea0:	1009883a 	mov	r4,r2
   19ea4:	180b883a 	mov	r5,r3
   19ea8:	880d883a 	mov	r6,r17
   19eac:	a80f883a 	mov	r7,r21
   19eb0:	1025883a 	mov	r18,r2
   19eb4:	1827883a 	mov	r19,r3
   19eb8:	001fb800 	call	1fb80 <__ltdf2>
   19ebc:	b5800044 	addi	r22,r22,1
   19ec0:	0009883a 	mov	r4,zero
   19ec4:	014ffc34 	movhi	r5,16368
   19ec8:	900d883a 	mov	r6,r18
   19ecc:	980f883a 	mov	r7,r19
   19ed0:	103fd00e 	bge	r2,zero,19e14 <_dtoa_r+0x5b8>
   19ed4:	d9001317 	ldw	r4,76(sp)
   19ed8:	df001117 	ldw	fp,68(sp)
   19edc:	d9000615 	stw	r4,24(sp)
   19ee0:	8009883a 	mov	r4,r16
   19ee4:	e00b883a 	mov	r5,fp
   19ee8:	001ca880 	call	1ca88 <_Bfree>
   19eec:	d9c00617 	ldw	r7,24(sp)
   19ef0:	d8c02217 	ldw	r3,136(sp)
   19ef4:	d9002417 	ldw	r4,144(sp)
   19ef8:	b0000005 	stb	zero,0(r22)
   19efc:	38800044 	addi	r2,r7,1
   19f00:	18800015 	stw	r2,0(r3)
   19f04:	203e8426 	beq	r4,zero,19918 <_dtoa_r+0xbc>
   19f08:	25800015 	stw	r22,0(r4)
   19f0c:	003e8206 	br	19918 <_dtoa_r+0xbc>
   19f10:	00800434 	movhi	r2,16
   19f14:	10bfffc4 	addi	r2,r2,-1
   19f18:	90a4703a 	and	r18,r18,r2
   19f1c:	903e901e 	bne	r18,zero,19960 <_dtoa_r+0x104>
   19f20:	05c000f4 	movhi	r23,3
   19f24:	bdfffb04 	addi	r23,r23,-20
   19f28:	003e8f06 	br	19968 <_dtoa_r+0x10c>
   19f2c:	b8800204 	addi	r2,r23,8
   19f30:	003e9206 	br	1997c <_dtoa_r+0x120>
   19f34:	01400434 	movhi	r5,16
   19f38:	297fffc4 	addi	r5,r5,-1
   19f3c:	894a703a 	and	r5,r17,r5
   19f40:	d9000317 	ldw	r4,12(sp)
   19f44:	294ffc34 	orhi	r5,r5,16368
   19f48:	a53f0044 	addi	r20,r20,-1023
   19f4c:	dd400217 	ldw	r21,8(sp)
   19f50:	d8000f15 	stw	zero,60(sp)
   19f54:	003eb106 	br	19a1c <_dtoa_r+0x1c0>
   19f58:	05c000f4 	movhi	r23,3
   19f5c:	bdfff204 	addi	r23,r23,-56
   19f60:	003e6d06 	br	19918 <_dtoa_r+0xbc>
   19f64:	d8000415 	stw	zero,16(sp)
   19f68:	80001115 	stw	zero,68(r16)
   19f6c:	8009883a 	mov	r4,r16
   19f70:	000b883a 	mov	r5,zero
   19f74:	001c9e00 	call	1c9e0 <_Balloc>
   19f78:	01ffffc4 	movi	r7,-1
   19f7c:	102f883a 	mov	r23,r2
   19f80:	80801015 	stw	r2,64(r16)
   19f84:	00800044 	movi	r2,1
   19f88:	d9c00915 	stw	r7,36(sp)
   19f8c:	d8002115 	stw	zero,132(sp)
   19f90:	d9c00e15 	stw	r7,56(sp)
   19f94:	d8800c15 	stw	r2,48(sp)
   19f98:	d8800117 	ldw	r2,4(sp)
   19f9c:	10008b16 	blt	r2,zero,1a1cc <_dtoa_r+0x970>
   19fa0:	d9000617 	ldw	r4,24(sp)
   19fa4:	00c00384 	movi	r3,14
   19fa8:	19008816 	blt	r3,r4,1a1cc <_dtoa_r+0x970>
   19fac:	200490fa 	slli	r2,r4,3
   19fb0:	d9c02117 	ldw	r7,132(sp)
   19fb4:	00c000f4 	movhi	r3,3
   19fb8:	18c02304 	addi	r3,r3,140
   19fbc:	1885883a 	add	r2,r3,r2
   19fc0:	14800017 	ldw	r18,0(r2)
   19fc4:	14c00117 	ldw	r19,4(r2)
   19fc8:	3801c916 	blt	r7,zero,1a6f0 <_dtoa_r+0xe94>
   19fcc:	d9000317 	ldw	r4,12(sp)
   19fd0:	900d883a 	mov	r6,r18
   19fd4:	980f883a 	mov	r7,r19
   19fd8:	880b883a 	mov	r5,r17
   19fdc:	001f84c0 	call	1f84c <__divdf3>
   19fe0:	180b883a 	mov	r5,r3
   19fe4:	1009883a 	mov	r4,r2
   19fe8:	001fcb00 	call	1fcb0 <__fixdfsi>
   19fec:	1009883a 	mov	r4,r2
   19ff0:	102b883a 	mov	r21,r2
   19ff4:	001fbdc0 	call	1fbdc <__floatsidf>
   19ff8:	1009883a 	mov	r4,r2
   19ffc:	180b883a 	mov	r5,r3
   1a000:	900d883a 	mov	r6,r18
   1a004:	980f883a 	mov	r7,r19
   1a008:	001f5680 	call	1f568 <__muldf3>
   1a00c:	d9000317 	ldw	r4,12(sp)
   1a010:	880b883a 	mov	r5,r17
   1a014:	100d883a 	mov	r6,r2
   1a018:	180f883a 	mov	r7,r3
   1a01c:	001f5080 	call	1f508 <__subdf3>
   1a020:	d9c00917 	ldw	r7,36(sp)
   1a024:	1009883a 	mov	r4,r2
   1a028:	a8800c04 	addi	r2,r21,48
   1a02c:	b8800005 	stb	r2,0(r23)
   1a030:	01800044 	movi	r6,1
   1a034:	180b883a 	mov	r5,r3
   1a038:	2005883a 	mov	r2,r4
   1a03c:	bd800044 	addi	r22,r23,1
   1a040:	39803726 	beq	r7,r6,1a120 <_dtoa_r+0x8c4>
   1a044:	000d883a 	mov	r6,zero
   1a048:	01d00934 	movhi	r7,16420
   1a04c:	001f5680 	call	1f568 <__muldf3>
   1a050:	1009883a 	mov	r4,r2
   1a054:	180b883a 	mov	r5,r3
   1a058:	000d883a 	mov	r6,zero
   1a05c:	000f883a 	mov	r7,zero
   1a060:	1029883a 	mov	r20,r2
   1a064:	1823883a 	mov	r17,r3
   1a068:	001fa000 	call	1fa00 <__eqdf2>
   1a06c:	103f9c26 	beq	r2,zero,19ee0 <_dtoa_r+0x684>
   1a070:	dd400917 	ldw	r21,36(sp)
   1a074:	dc000415 	stw	r16,16(sp)
   1a078:	00000906 	br	1a0a0 <_dtoa_r+0x844>
   1a07c:	001f5680 	call	1f568 <__muldf3>
   1a080:	1009883a 	mov	r4,r2
   1a084:	180b883a 	mov	r5,r3
   1a088:	000d883a 	mov	r6,zero
   1a08c:	000f883a 	mov	r7,zero
   1a090:	1029883a 	mov	r20,r2
   1a094:	1823883a 	mov	r17,r3
   1a098:	001fa000 	call	1fa00 <__eqdf2>
   1a09c:	10022926 	beq	r2,zero,1a944 <_dtoa_r+0x10e8>
   1a0a0:	900d883a 	mov	r6,r18
   1a0a4:	980f883a 	mov	r7,r19
   1a0a8:	a009883a 	mov	r4,r20
   1a0ac:	880b883a 	mov	r5,r17
   1a0b0:	001f84c0 	call	1f84c <__divdf3>
   1a0b4:	180b883a 	mov	r5,r3
   1a0b8:	1009883a 	mov	r4,r2
   1a0bc:	001fcb00 	call	1fcb0 <__fixdfsi>
   1a0c0:	1009883a 	mov	r4,r2
   1a0c4:	1021883a 	mov	r16,r2
   1a0c8:	001fbdc0 	call	1fbdc <__floatsidf>
   1a0cc:	1009883a 	mov	r4,r2
   1a0d0:	180b883a 	mov	r5,r3
   1a0d4:	900d883a 	mov	r6,r18
   1a0d8:	980f883a 	mov	r7,r19
   1a0dc:	001f5680 	call	1f568 <__muldf3>
   1a0e0:	a009883a 	mov	r4,r20
   1a0e4:	880b883a 	mov	r5,r17
   1a0e8:	100d883a 	mov	r6,r2
   1a0ec:	180f883a 	mov	r7,r3
   1a0f0:	001f5080 	call	1f508 <__subdf3>
   1a0f4:	82400c04 	addi	r9,r16,48
   1a0f8:	b2400005 	stb	r9,0(r22)
   1a0fc:	b5800044 	addi	r22,r22,1
   1a100:	b5d3c83a 	sub	r9,r22,r23
   1a104:	000d883a 	mov	r6,zero
   1a108:	01d00934 	movhi	r7,16420
   1a10c:	1009883a 	mov	r4,r2
   1a110:	180b883a 	mov	r5,r3
   1a114:	aa7fd91e 	bne	r21,r9,1a07c <_dtoa_r+0x820>
   1a118:	802b883a 	mov	r21,r16
   1a11c:	dc000417 	ldw	r16,16(sp)
   1a120:	1009883a 	mov	r4,r2
   1a124:	180b883a 	mov	r5,r3
   1a128:	100d883a 	mov	r6,r2
   1a12c:	180f883a 	mov	r7,r3
   1a130:	001f4b40 	call	1f4b4 <__adddf3>
   1a134:	9009883a 	mov	r4,r18
   1a138:	980b883a 	mov	r5,r19
   1a13c:	100d883a 	mov	r6,r2
   1a140:	180f883a 	mov	r7,r3
   1a144:	1023883a 	mov	r17,r2
   1a148:	1829883a 	mov	r20,r3
   1a14c:	001fb800 	call	1fb80 <__ltdf2>
   1a150:	10000816 	blt	r2,zero,1a174 <_dtoa_r+0x918>
   1a154:	9009883a 	mov	r4,r18
   1a158:	980b883a 	mov	r5,r19
   1a15c:	880d883a 	mov	r6,r17
   1a160:	a00f883a 	mov	r7,r20
   1a164:	001fa000 	call	1fa00 <__eqdf2>
   1a168:	103f5d1e 	bne	r2,zero,19ee0 <_dtoa_r+0x684>
   1a16c:	ad40004c 	andi	r21,r21,1
   1a170:	a83f5b26 	beq	r21,zero,19ee0 <_dtoa_r+0x684>
   1a174:	b53fffc3 	ldbu	r20,-1(r22)
   1a178:	b0ffff84 	addi	r3,r22,-2
   1a17c:	01400e44 	movi	r5,57
   1a180:	00000306 	br	1a190 <_dtoa_r+0x934>
   1a184:	1d000003 	ldbu	r20,0(r3)
   1a188:	102d883a 	mov	r22,r2
   1a18c:	18ffffc4 	addi	r3,r3,-1
   1a190:	a1003fcc 	andi	r4,r20,255
   1a194:	2100201c 	xori	r4,r4,128
   1a198:	213fe004 	addi	r4,r4,-128
   1a19c:	b0bfffc4 	addi	r2,r22,-1
   1a1a0:	2142ca1e 	bne	r4,r5,1accc <_dtoa_r+0x1470>
   1a1a4:	b8bff71e 	bne	r23,r2,1a184 <_dtoa_r+0x928>
   1a1a8:	d8800617 	ldw	r2,24(sp)
   1a1ac:	05000c44 	movi	r20,49
   1a1b0:	10800044 	addi	r2,r2,1
   1a1b4:	d8800615 	stw	r2,24(sp)
   1a1b8:	00800c04 	movi	r2,48
   1a1bc:	b8800005 	stb	r2,0(r23)
   1a1c0:	b805883a 	mov	r2,r23
   1a1c4:	15000005 	stb	r20,0(r2)
   1a1c8:	003f4506 	br	19ee0 <_dtoa_r+0x684>
   1a1cc:	d9c00c17 	ldw	r7,48(sp)
   1a1d0:	3800c926 	beq	r7,zero,1a4f8 <_dtoa_r+0xc9c>
   1a1d4:	d9c00417 	ldw	r7,16(sp)
   1a1d8:	00c00044 	movi	r3,1
   1a1dc:	19c16c0e 	bge	r3,r7,1a790 <_dtoa_r+0xf34>
   1a1e0:	d9000917 	ldw	r4,36(sp)
   1a1e4:	d9c00a17 	ldw	r7,40(sp)
   1a1e8:	24ffffc4 	addi	r19,r4,-1
   1a1ec:	3cc20716 	blt	r7,r19,1aa0c <_dtoa_r+0x11b0>
   1a1f0:	3ce7c83a 	sub	r19,r7,r19
   1a1f4:	d9c00917 	ldw	r7,36(sp)
   1a1f8:	3802ae16 	blt	r7,zero,1acb4 <_dtoa_r+0x1458>
   1a1fc:	dc800817 	ldw	r18,32(sp)
   1a200:	d8800917 	ldw	r2,36(sp)
   1a204:	d8c00817 	ldw	r3,32(sp)
   1a208:	d9c00717 	ldw	r7,28(sp)
   1a20c:	8009883a 	mov	r4,r16
   1a210:	1887883a 	add	r3,r3,r2
   1a214:	388f883a 	add	r7,r7,r2
   1a218:	01400044 	movi	r5,1
   1a21c:	d8c00815 	stw	r3,32(sp)
   1a220:	d9c00715 	stw	r7,28(sp)
   1a224:	001cde00 	call	1cde0 <__i2b>
   1a228:	102b883a 	mov	r21,r2
   1a22c:	90000a26 	beq	r18,zero,1a258 <_dtoa_r+0x9fc>
   1a230:	d8800717 	ldw	r2,28(sp)
   1a234:	0080080e 	bge	zero,r2,1a258 <_dtoa_r+0x9fc>
   1a238:	90812b16 	blt	r18,r2,1a6e8 <_dtoa_r+0xe8c>
   1a23c:	d8c00817 	ldw	r3,32(sp)
   1a240:	d9000717 	ldw	r4,28(sp)
   1a244:	90a5c83a 	sub	r18,r18,r2
   1a248:	1887c83a 	sub	r3,r3,r2
   1a24c:	2089c83a 	sub	r4,r4,r2
   1a250:	d8c00815 	stw	r3,32(sp)
   1a254:	d9000715 	stw	r4,28(sp)
   1a258:	d9c00a17 	ldw	r7,40(sp)
   1a25c:	01c0140e 	bge	zero,r7,1a2b0 <_dtoa_r+0xa54>
   1a260:	d8800c17 	ldw	r2,48(sp)
   1a264:	1001de26 	beq	r2,zero,1a9e0 <_dtoa_r+0x1184>
   1a268:	04c00e0e 	bge	zero,r19,1a2a4 <_dtoa_r+0xa48>
   1a26c:	a80b883a 	mov	r5,r21
   1a270:	8009883a 	mov	r4,r16
   1a274:	980d883a 	mov	r6,r19
   1a278:	001cffc0 	call	1cffc <__pow5mult>
   1a27c:	e00d883a 	mov	r6,fp
   1a280:	8009883a 	mov	r4,r16
   1a284:	100b883a 	mov	r5,r2
   1a288:	102b883a 	mov	r21,r2
   1a28c:	001ce1c0 	call	1ce1c <__multiply>
   1a290:	1029883a 	mov	r20,r2
   1a294:	e00b883a 	mov	r5,fp
   1a298:	8009883a 	mov	r4,r16
   1a29c:	001ca880 	call	1ca88 <_Bfree>
   1a2a0:	a039883a 	mov	fp,r20
   1a2a4:	d8c00a17 	ldw	r3,40(sp)
   1a2a8:	1ccdc83a 	sub	r6,r3,r19
   1a2ac:	3001291e 	bne	r6,zero,1a754 <_dtoa_r+0xef8>
   1a2b0:	8009883a 	mov	r4,r16
   1a2b4:	01400044 	movi	r5,1
   1a2b8:	001cde00 	call	1cde0 <__i2b>
   1a2bc:	d9000b17 	ldw	r4,44(sp)
   1a2c0:	1029883a 	mov	r20,r2
   1a2c4:	0100050e 	bge	zero,r4,1a2dc <_dtoa_r+0xa80>
   1a2c8:	d9800b17 	ldw	r6,44(sp)
   1a2cc:	8009883a 	mov	r4,r16
   1a2d0:	100b883a 	mov	r5,r2
   1a2d4:	001cffc0 	call	1cffc <__pow5mult>
   1a2d8:	1029883a 	mov	r20,r2
   1a2dc:	d9c00417 	ldw	r7,16(sp)
   1a2e0:	00800044 	movi	r2,1
   1a2e4:	11c0f00e 	bge	r2,r7,1a6a8 <_dtoa_r+0xe4c>
   1a2e8:	0023883a 	mov	r17,zero
   1a2ec:	d8800b17 	ldw	r2,44(sp)
   1a2f0:	1001741e 	bne	r2,zero,1a8c4 <_dtoa_r+0x1068>
   1a2f4:	00800044 	movi	r2,1
   1a2f8:	d8c00717 	ldw	r3,28(sp)
   1a2fc:	10c5883a 	add	r2,r2,r3
   1a300:	108007cc 	andi	r2,r2,31
   1a304:	10008026 	beq	r2,zero,1a508 <_dtoa_r+0xcac>
   1a308:	01000804 	movi	r4,32
   1a30c:	2089c83a 	sub	r4,r4,r2
   1a310:	00c00104 	movi	r3,4
   1a314:	1902d00e 	bge	r3,r4,1ae58 <_dtoa_r+0x15fc>
   1a318:	d9000817 	ldw	r4,32(sp)
   1a31c:	d9c00717 	ldw	r7,28(sp)
   1a320:	00c00704 	movi	r3,28
   1a324:	1885c83a 	sub	r2,r3,r2
   1a328:	2089883a 	add	r4,r4,r2
   1a32c:	388f883a 	add	r7,r7,r2
   1a330:	d9000815 	stw	r4,32(sp)
   1a334:	90a5883a 	add	r18,r18,r2
   1a338:	d9c00715 	stw	r7,28(sp)
   1a33c:	d9c00817 	ldw	r7,32(sp)
   1a340:	01c0050e 	bge	zero,r7,1a358 <_dtoa_r+0xafc>
   1a344:	e00b883a 	mov	r5,fp
   1a348:	8009883a 	mov	r4,r16
   1a34c:	380d883a 	mov	r6,r7
   1a350:	001d1280 	call	1d128 <__lshift>
   1a354:	1039883a 	mov	fp,r2
   1a358:	d8800717 	ldw	r2,28(sp)
   1a35c:	0080050e 	bge	zero,r2,1a374 <_dtoa_r+0xb18>
   1a360:	a00b883a 	mov	r5,r20
   1a364:	8009883a 	mov	r4,r16
   1a368:	100d883a 	mov	r6,r2
   1a36c:	001d1280 	call	1d128 <__lshift>
   1a370:	1029883a 	mov	r20,r2
   1a374:	d8c00d17 	ldw	r3,52(sp)
   1a378:	1801401e 	bne	r3,zero,1a87c <_dtoa_r+0x1020>
   1a37c:	d8800917 	ldw	r2,36(sp)
   1a380:	00815a0e 	bge	zero,r2,1a8ec <_dtoa_r+0x1090>
   1a384:	d8c00c17 	ldw	r3,48(sp)
   1a388:	18006f1e 	bne	r3,zero,1a548 <_dtoa_r+0xcec>
   1a38c:	b823883a 	mov	r17,r23
   1a390:	dc800917 	ldw	r18,36(sp)
   1a394:	00000206 	br	1a3a0 <_dtoa_r+0xb44>
   1a398:	001cab00 	call	1cab0 <__multadd>
   1a39c:	1039883a 	mov	fp,r2
   1a3a0:	e009883a 	mov	r4,fp
   1a3a4:	a00b883a 	mov	r5,r20
   1a3a8:	00196540 	call	19654 <quorem>
   1a3ac:	10800c04 	addi	r2,r2,48
   1a3b0:	88800005 	stb	r2,0(r17)
   1a3b4:	8c400044 	addi	r17,r17,1
   1a3b8:	8dc7c83a 	sub	r3,r17,r23
   1a3bc:	8009883a 	mov	r4,r16
   1a3c0:	e00b883a 	mov	r5,fp
   1a3c4:	01800284 	movi	r6,10
   1a3c8:	000f883a 	mov	r7,zero
   1a3cc:	1cbff216 	blt	r3,r18,1a398 <_dtoa_r+0xb3c>
   1a3d0:	dd800917 	ldw	r22,36(sp)
   1a3d4:	1007883a 	mov	r3,r2
   1a3d8:	05823a0e 	bge	zero,r22,1acc4 <_dtoa_r+0x1468>
   1a3dc:	bdad883a 	add	r22,r23,r22
   1a3e0:	0023883a 	mov	r17,zero
   1a3e4:	e00b883a 	mov	r5,fp
   1a3e8:	01800044 	movi	r6,1
   1a3ec:	8009883a 	mov	r4,r16
   1a3f0:	d8c01515 	stw	r3,84(sp)
   1a3f4:	001d1280 	call	1d128 <__lshift>
   1a3f8:	1009883a 	mov	r4,r2
   1a3fc:	a00b883a 	mov	r5,r20
   1a400:	1039883a 	mov	fp,r2
   1a404:	001d2840 	call	1d284 <__mcmp>
   1a408:	d8c01517 	ldw	r3,84(sp)
   1a40c:	0080d60e 	bge	zero,r2,1a768 <_dtoa_r+0xf0c>
   1a410:	b13fffc3 	ldbu	r4,-1(r22)
   1a414:	b0ffff84 	addi	r3,r22,-2
   1a418:	01800e44 	movi	r6,57
   1a41c:	00000306 	br	1a42c <_dtoa_r+0xbd0>
   1a420:	19000003 	ldbu	r4,0(r3)
   1a424:	102d883a 	mov	r22,r2
   1a428:	18ffffc4 	addi	r3,r3,-1
   1a42c:	21403fcc 	andi	r5,r4,255
   1a430:	2940201c 	xori	r5,r5,128
   1a434:	297fe004 	addi	r5,r5,-128
   1a438:	b0bfffc4 	addi	r2,r22,-1
   1a43c:	2981a71e 	bne	r5,r6,1aadc <_dtoa_r+0x1280>
   1a440:	b8bff71e 	bne	r23,r2,1a420 <_dtoa_r+0xbc4>
   1a444:	d8800617 	ldw	r2,24(sp)
   1a448:	10800044 	addi	r2,r2,1
   1a44c:	d8800615 	stw	r2,24(sp)
   1a450:	00800c44 	movi	r2,49
   1a454:	b8800005 	stb	r2,0(r23)
   1a458:	8009883a 	mov	r4,r16
   1a45c:	a00b883a 	mov	r5,r20
   1a460:	001ca880 	call	1ca88 <_Bfree>
   1a464:	a83e9e26 	beq	r21,zero,19ee0 <_dtoa_r+0x684>
   1a468:	88000426 	beq	r17,zero,1a47c <_dtoa_r+0xc20>
   1a46c:	8d400326 	beq	r17,r21,1a47c <_dtoa_r+0xc20>
   1a470:	8009883a 	mov	r4,r16
   1a474:	880b883a 	mov	r5,r17
   1a478:	001ca880 	call	1ca88 <_Bfree>
   1a47c:	8009883a 	mov	r4,r16
   1a480:	a80b883a 	mov	r5,r21
   1a484:	001ca880 	call	1ca88 <_Bfree>
   1a488:	003e9506 	br	19ee0 <_dtoa_r+0x684>
   1a48c:	00c00044 	movi	r3,1
   1a490:	d8c00d15 	stw	r3,52(sp)
   1a494:	003d9f06 	br	19b14 <_dtoa_r+0x2b8>
   1a498:	d9000817 	ldw	r4,32(sp)
   1a49c:	d8800617 	ldw	r2,24(sp)
   1a4a0:	d8000b15 	stw	zero,44(sp)
   1a4a4:	2089c83a 	sub	r4,r4,r2
   1a4a8:	0087c83a 	sub	r3,zero,r2
   1a4ac:	d9000815 	stw	r4,32(sp)
   1a4b0:	d8c00a15 	stw	r3,40(sp)
   1a4b4:	003da306 	br	19b44 <_dtoa_r+0x2e8>
   1a4b8:	0529c83a 	sub	r20,zero,r20
   1a4bc:	dd000815 	stw	r20,32(sp)
   1a4c0:	d8000715 	stw	zero,28(sp)
   1a4c4:	003d9806 	br	19b28 <_dtoa_r+0x2cc>
   1a4c8:	d9000617 	ldw	r4,24(sp)
   1a4cc:	001fbdc0 	call	1fbdc <__floatsidf>
   1a4d0:	1009883a 	mov	r4,r2
   1a4d4:	180b883a 	mov	r5,r3
   1a4d8:	980d883a 	mov	r6,r19
   1a4dc:	900f883a 	mov	r7,r18
   1a4e0:	001fa5c0 	call	1fa5c <__nedf2>
   1a4e4:	103d7a26 	beq	r2,zero,19ad0 <_dtoa_r+0x274>
   1a4e8:	d8800617 	ldw	r2,24(sp)
   1a4ec:	10bfffc4 	addi	r2,r2,-1
   1a4f0:	d8800615 	stw	r2,24(sp)
   1a4f4:	003d7606 	br	19ad0 <_dtoa_r+0x274>
   1a4f8:	dcc00a17 	ldw	r19,40(sp)
   1a4fc:	dc800817 	ldw	r18,32(sp)
   1a500:	002b883a 	mov	r21,zero
   1a504:	003f4906 	br	1a22c <_dtoa_r+0x9d0>
   1a508:	00800704 	movi	r2,28
   1a50c:	d8c00817 	ldw	r3,32(sp)
   1a510:	d9000717 	ldw	r4,28(sp)
   1a514:	90a5883a 	add	r18,r18,r2
   1a518:	1887883a 	add	r3,r3,r2
   1a51c:	2089883a 	add	r4,r4,r2
   1a520:	d8c00815 	stw	r3,32(sp)
   1a524:	d9000715 	stw	r4,28(sp)
   1a528:	003f8406 	br	1a33c <_dtoa_r+0xae0>
   1a52c:	d9c00317 	ldw	r7,12(sp)
   1a530:	013efb84 	movi	r4,-1042
   1a534:	2509c83a 	sub	r4,r4,r20
   1a538:	3908983a 	sll	r4,r7,r4
   1a53c:	003d3006 	br	19a00 <_dtoa_r+0x1a4>
   1a540:	d8000d15 	stw	zero,52(sp)
   1a544:	003d7306 	br	19b14 <_dtoa_r+0x2b8>
   1a548:	0480050e 	bge	zero,r18,1a560 <_dtoa_r+0xd04>
   1a54c:	a80b883a 	mov	r5,r21
   1a550:	8009883a 	mov	r4,r16
   1a554:	900d883a 	mov	r6,r18
   1a558:	001d1280 	call	1d128 <__lshift>
   1a55c:	102b883a 	mov	r21,r2
   1a560:	8801611e 	bne	r17,zero,1aae8 <_dtoa_r+0x128c>
   1a564:	a827883a 	mov	r19,r21
   1a568:	d8c00317 	ldw	r3,12(sp)
   1a56c:	d9000917 	ldw	r4,36(sp)
   1a570:	b8bfffc4 	addi	r2,r23,-1
   1a574:	18c0004c 	andi	r3,r3,1
   1a578:	1105883a 	add	r2,r2,r4
   1a57c:	b825883a 	mov	r18,r23
   1a580:	d8800515 	stw	r2,20(sp)
   1a584:	a823883a 	mov	r17,r21
   1a588:	d8c00315 	stw	r3,12(sp)
   1a58c:	ddc00715 	stw	r23,28(sp)
   1a590:	e009883a 	mov	r4,fp
   1a594:	a00b883a 	mov	r5,r20
   1a598:	00196540 	call	19654 <quorem>
   1a59c:	e009883a 	mov	r4,fp
   1a5a0:	880b883a 	mov	r5,r17
   1a5a4:	102d883a 	mov	r22,r2
   1a5a8:	001d2840 	call	1d284 <__mcmp>
   1a5ac:	980d883a 	mov	r6,r19
   1a5b0:	8009883a 	mov	r4,r16
   1a5b4:	a00b883a 	mov	r5,r20
   1a5b8:	102b883a 	mov	r21,r2
   1a5bc:	001d2dc0 	call	1d2dc <__mdiff>
   1a5c0:	100d883a 	mov	r6,r2
   1a5c4:	10800317 	ldw	r2,12(r2)
   1a5c8:	b5c00c04 	addi	r23,r22,48
   1a5cc:	10008c26 	beq	r2,zero,1a800 <_dtoa_r+0xfa4>
   1a5d0:	8009883a 	mov	r4,r16
   1a5d4:	300b883a 	mov	r5,r6
   1a5d8:	001ca880 	call	1ca88 <_Bfree>
   1a5dc:	00800044 	movi	r2,1
   1a5e0:	a8007116 	blt	r21,zero,1a7a8 <_dtoa_r+0xf4c>
   1a5e4:	a800041e 	bne	r21,zero,1a5f8 <_dtoa_r+0xd9c>
   1a5e8:	d9c00417 	ldw	r7,16(sp)
   1a5ec:	3800021e 	bne	r7,zero,1a5f8 <_dtoa_r+0xd9c>
   1a5f0:	d8c00317 	ldw	r3,12(sp)
   1a5f4:	18006c26 	beq	r3,zero,1a7a8 <_dtoa_r+0xf4c>
   1a5f8:	00814c16 	blt	zero,r2,1ab2c <_dtoa_r+0x12d0>
   1a5fc:	d8c00517 	ldw	r3,20(sp)
   1a600:	95400044 	addi	r21,r18,1
   1a604:	95c00005 	stb	r23,0(r18)
   1a608:	a82d883a 	mov	r22,r21
   1a60c:	90c14d26 	beq	r18,r3,1ab44 <_dtoa_r+0x12e8>
   1a610:	e00b883a 	mov	r5,fp
   1a614:	8009883a 	mov	r4,r16
   1a618:	01800284 	movi	r6,10
   1a61c:	000f883a 	mov	r7,zero
   1a620:	001cab00 	call	1cab0 <__multadd>
   1a624:	1039883a 	mov	fp,r2
   1a628:	8cc08b26 	beq	r17,r19,1a858 <_dtoa_r+0xffc>
   1a62c:	880b883a 	mov	r5,r17
   1a630:	01800284 	movi	r6,10
   1a634:	000f883a 	mov	r7,zero
   1a638:	8009883a 	mov	r4,r16
   1a63c:	001cab00 	call	1cab0 <__multadd>
   1a640:	980b883a 	mov	r5,r19
   1a644:	8009883a 	mov	r4,r16
   1a648:	01800284 	movi	r6,10
   1a64c:	000f883a 	mov	r7,zero
   1a650:	1023883a 	mov	r17,r2
   1a654:	001cab00 	call	1cab0 <__multadd>
   1a658:	1027883a 	mov	r19,r2
   1a65c:	a825883a 	mov	r18,r21
   1a660:	003fcb06 	br	1a590 <_dtoa_r+0xd34>
   1a664:	d9c00417 	ldw	r7,16(sp)
   1a668:	00800104 	movi	r2,4
   1a66c:	3880e426 	beq	r7,r2,1aa00 <_dtoa_r+0x11a4>
   1a670:	00800144 	movi	r2,5
   1a674:	38be3c1e 	bne	r7,r2,19f68 <_dtoa_r+0x70c>
   1a678:	00c00044 	movi	r3,1
   1a67c:	d8c00c15 	stw	r3,48(sp)
   1a680:	d9c02117 	ldw	r7,132(sp)
   1a684:	d8800617 	ldw	r2,24(sp)
   1a688:	388f883a 	add	r7,r7,r2
   1a68c:	3c800044 	addi	r18,r7,1
   1a690:	d9c00e15 	stw	r7,56(sp)
   1a694:	dc800915 	stw	r18,36(sp)
   1a698:	04bd3e16 	blt	zero,r18,19b94 <_dtoa_r+0x338>
   1a69c:	80001115 	stw	zero,68(r16)
   1a6a0:	000b883a 	mov	r5,zero
   1a6a4:	003d4606 	br	19bc0 <_dtoa_r+0x364>
   1a6a8:	d8c00317 	ldw	r3,12(sp)
   1a6ac:	183f0e1e 	bne	r3,zero,1a2e8 <_dtoa_r+0xa8c>
   1a6b0:	00c00434 	movhi	r3,16
   1a6b4:	18ffffc4 	addi	r3,r3,-1
   1a6b8:	88c6703a 	and	r3,r17,r3
   1a6bc:	183f0a1e 	bne	r3,zero,1a2e8 <_dtoa_r+0xa8c>
   1a6c0:	8c5ffc2c 	andhi	r17,r17,32752
   1a6c4:	883f0826 	beq	r17,zero,1a2e8 <_dtoa_r+0xa8c>
   1a6c8:	d9000817 	ldw	r4,32(sp)
   1a6cc:	d9c00717 	ldw	r7,28(sp)
   1a6d0:	1023883a 	mov	r17,r2
   1a6d4:	2089883a 	add	r4,r4,r2
   1a6d8:	388f883a 	add	r7,r7,r2
   1a6dc:	d9000815 	stw	r4,32(sp)
   1a6e0:	d9c00715 	stw	r7,28(sp)
   1a6e4:	003f0106 	br	1a2ec <_dtoa_r+0xa90>
   1a6e8:	9005883a 	mov	r2,r18
   1a6ec:	003ed306 	br	1a23c <_dtoa_r+0x9e0>
   1a6f0:	d8800917 	ldw	r2,36(sp)
   1a6f4:	00be3516 	blt	zero,r2,19fcc <_dtoa_r+0x770>
   1a6f8:	1000b61e 	bne	r2,zero,1a9d4 <_dtoa_r+0x1178>
   1a6fc:	9009883a 	mov	r4,r18
   1a700:	980b883a 	mov	r5,r19
   1a704:	000d883a 	mov	r6,zero
   1a708:	01d00534 	movhi	r7,16404
   1a70c:	001f5680 	call	1f568 <__muldf3>
   1a710:	d9800317 	ldw	r6,12(sp)
   1a714:	1009883a 	mov	r4,r2
   1a718:	180b883a 	mov	r5,r3
   1a71c:	880f883a 	mov	r7,r17
   1a720:	001fb1c0 	call	1fb1c <__gedf2>
   1a724:	0029883a 	mov	r20,zero
   1a728:	002b883a 	mov	r21,zero
   1a72c:	10007e16 	blt	r2,zero,1a928 <_dtoa_r+0x10cc>
   1a730:	d8802117 	ldw	r2,132(sp)
   1a734:	b82d883a 	mov	r22,r23
   1a738:	0084303a 	nor	r2,zero,r2
   1a73c:	d8800615 	stw	r2,24(sp)
   1a740:	8009883a 	mov	r4,r16
   1a744:	a00b883a 	mov	r5,r20
   1a748:	001ca880 	call	1ca88 <_Bfree>
   1a74c:	a83f4b1e 	bne	r21,zero,1a47c <_dtoa_r+0xc20>
   1a750:	003de306 	br	19ee0 <_dtoa_r+0x684>
   1a754:	e00b883a 	mov	r5,fp
   1a758:	8009883a 	mov	r4,r16
   1a75c:	001cffc0 	call	1cffc <__pow5mult>
   1a760:	1039883a 	mov	fp,r2
   1a764:	003ed206 	br	1a2b0 <_dtoa_r+0xa54>
   1a768:	1000021e 	bne	r2,zero,1a774 <_dtoa_r+0xf18>
   1a76c:	18c0004c 	andi	r3,r3,1
   1a770:	183f271e 	bne	r3,zero,1a410 <_dtoa_r+0xbb4>
   1a774:	01000c04 	movi	r4,48
   1a778:	00000106 	br	1a780 <_dtoa_r+0xf24>
   1a77c:	102d883a 	mov	r22,r2
   1a780:	b0bfffc4 	addi	r2,r22,-1
   1a784:	10c00007 	ldb	r3,0(r2)
   1a788:	193ffc26 	beq	r3,r4,1a77c <_dtoa_r+0xf20>
   1a78c:	003f3206 	br	1a458 <_dtoa_r+0xbfc>
   1a790:	d8c00f17 	ldw	r3,60(sp)
   1a794:	18015026 	beq	r3,zero,1acd8 <_dtoa_r+0x147c>
   1a798:	10810cc4 	addi	r2,r2,1075
   1a79c:	dcc00a17 	ldw	r19,40(sp)
   1a7a0:	dc800817 	ldw	r18,32(sp)
   1a7a4:	003e9706 	br	1a204 <_dtoa_r+0x9a8>
   1a7a8:	b807883a 	mov	r3,r23
   1a7ac:	182b883a 	mov	r21,r3
   1a7b0:	ddc00717 	ldw	r23,28(sp)
   1a7b4:	00800e0e 	bge	zero,r2,1a7f0 <_dtoa_r+0xf94>
   1a7b8:	e00b883a 	mov	r5,fp
   1a7bc:	01800044 	movi	r6,1
   1a7c0:	8009883a 	mov	r4,r16
   1a7c4:	d8c01515 	stw	r3,84(sp)
   1a7c8:	001d1280 	call	1d128 <__lshift>
   1a7cc:	1009883a 	mov	r4,r2
   1a7d0:	a00b883a 	mov	r5,r20
   1a7d4:	1039883a 	mov	fp,r2
   1a7d8:	001d2840 	call	1d284 <__mcmp>
   1a7dc:	d8c01517 	ldw	r3,84(sp)
   1a7e0:	0081880e 	bge	zero,r2,1ae04 <_dtoa_r+0x15a8>
   1a7e4:	00800e44 	movi	r2,57
   1a7e8:	b0c00c44 	addi	r3,r22,49
   1a7ec:	a8816326 	beq	r21,r2,1ad7c <_dtoa_r+0x1520>
   1a7f0:	90c00005 	stb	r3,0(r18)
   1a7f4:	95800044 	addi	r22,r18,1
   1a7f8:	982b883a 	mov	r21,r19
   1a7fc:	003f1606 	br	1a458 <_dtoa_r+0xbfc>
   1a800:	300b883a 	mov	r5,r6
   1a804:	e009883a 	mov	r4,fp
   1a808:	d9801515 	stw	r6,84(sp)
   1a80c:	001d2840 	call	1d284 <__mcmp>
   1a810:	d9801517 	ldw	r6,84(sp)
   1a814:	8009883a 	mov	r4,r16
   1a818:	d8801515 	stw	r2,84(sp)
   1a81c:	300b883a 	mov	r5,r6
   1a820:	001ca880 	call	1ca88 <_Bfree>
   1a824:	d8801517 	ldw	r2,84(sp)
   1a828:	103f6d1e 	bne	r2,zero,1a5e0 <_dtoa_r+0xd84>
   1a82c:	d9c00417 	ldw	r7,16(sp)
   1a830:	383f6b1e 	bne	r7,zero,1a5e0 <_dtoa_r+0xd84>
   1a834:	d8c00317 	ldw	r3,12(sp)
   1a838:	183f691e 	bne	r3,zero,1a5e0 <_dtoa_r+0xd84>
   1a83c:	b807883a 	mov	r3,r23
   1a840:	00800e44 	movi	r2,57
   1a844:	ddc00717 	ldw	r23,28(sp)
   1a848:	18814c26 	beq	r3,r2,1ad7c <_dtoa_r+0x1520>
   1a84c:	057fe80e 	bge	zero,r21,1a7f0 <_dtoa_r+0xf94>
   1a850:	b0c00c44 	addi	r3,r22,49
   1a854:	003fe606 	br	1a7f0 <_dtoa_r+0xf94>
   1a858:	880b883a 	mov	r5,r17
   1a85c:	8009883a 	mov	r4,r16
   1a860:	01800284 	movi	r6,10
   1a864:	000f883a 	mov	r7,zero
   1a868:	001cab00 	call	1cab0 <__multadd>
   1a86c:	1023883a 	mov	r17,r2
   1a870:	1027883a 	mov	r19,r2
   1a874:	a825883a 	mov	r18,r21
   1a878:	003f4506 	br	1a590 <_dtoa_r+0xd34>
   1a87c:	e009883a 	mov	r4,fp
   1a880:	a00b883a 	mov	r5,r20
   1a884:	001d2840 	call	1d284 <__mcmp>
   1a888:	103ebc0e 	bge	r2,zero,1a37c <_dtoa_r+0xb20>
   1a88c:	e00b883a 	mov	r5,fp
   1a890:	8009883a 	mov	r4,r16
   1a894:	01800284 	movi	r6,10
   1a898:	000f883a 	mov	r7,zero
   1a89c:	001cab00 	call	1cab0 <__multadd>
   1a8a0:	1039883a 	mov	fp,r2
   1a8a4:	d8800617 	ldw	r2,24(sp)
   1a8a8:	d8c00c17 	ldw	r3,48(sp)
   1a8ac:	10bfffc4 	addi	r2,r2,-1
   1a8b0:	d8800615 	stw	r2,24(sp)
   1a8b4:	1801571e 	bne	r3,zero,1ae14 <_dtoa_r+0x15b8>
   1a8b8:	d9c00e17 	ldw	r7,56(sp)
   1a8bc:	d9c00915 	stw	r7,36(sp)
   1a8c0:	003eae06 	br	1a37c <_dtoa_r+0xb20>
   1a8c4:	a0800417 	ldw	r2,16(r20)
   1a8c8:	10800104 	addi	r2,r2,4
   1a8cc:	1085883a 	add	r2,r2,r2
   1a8d0:	1085883a 	add	r2,r2,r2
   1a8d4:	a085883a 	add	r2,r20,r2
   1a8d8:	11000017 	ldw	r4,0(r2)
   1a8dc:	001ccc80 	call	1ccc8 <__hi0bits>
   1a8e0:	00c00804 	movi	r3,32
   1a8e4:	1885c83a 	sub	r2,r3,r2
   1a8e8:	003e8306 	br	1a2f8 <_dtoa_r+0xa9c>
   1a8ec:	d9c00417 	ldw	r7,16(sp)
   1a8f0:	00800084 	movi	r2,2
   1a8f4:	11fea30e 	bge	r2,r7,1a384 <_dtoa_r+0xb28>
   1a8f8:	d8800917 	ldw	r2,36(sp)
   1a8fc:	103f8c1e 	bne	r2,zero,1a730 <_dtoa_r+0xed4>
   1a900:	a00b883a 	mov	r5,r20
   1a904:	8009883a 	mov	r4,r16
   1a908:	01800144 	movi	r6,5
   1a90c:	000f883a 	mov	r7,zero
   1a910:	001cab00 	call	1cab0 <__multadd>
   1a914:	e009883a 	mov	r4,fp
   1a918:	100b883a 	mov	r5,r2
   1a91c:	1029883a 	mov	r20,r2
   1a920:	001d2840 	call	1d284 <__mcmp>
   1a924:	00bf820e 	bge	zero,r2,1a730 <_dtoa_r+0xed4>
   1a928:	00800c44 	movi	r2,49
   1a92c:	b8800005 	stb	r2,0(r23)
   1a930:	d8800617 	ldw	r2,24(sp)
   1a934:	bd800044 	addi	r22,r23,1
   1a938:	10800044 	addi	r2,r2,1
   1a93c:	d8800615 	stw	r2,24(sp)
   1a940:	003f7f06 	br	1a740 <_dtoa_r+0xee4>
   1a944:	dc000417 	ldw	r16,16(sp)
   1a948:	003d6506 	br	19ee0 <_dtoa_r+0x684>
   1a94c:	9009883a 	mov	r4,r18
   1a950:	001fbdc0 	call	1fbdc <__floatsidf>
   1a954:	1009883a 	mov	r4,r2
   1a958:	180b883a 	mov	r5,r3
   1a95c:	980d883a 	mov	r6,r19
   1a960:	a00f883a 	mov	r7,r20
   1a964:	001f5680 	call	1f568 <__muldf3>
   1a968:	1009883a 	mov	r4,r2
   1a96c:	180b883a 	mov	r5,r3
   1a970:	000d883a 	mov	r6,zero
   1a974:	01d00734 	movhi	r7,16412
   1a978:	001f4b40 	call	1f4b4 <__adddf3>
   1a97c:	057f3034 	movhi	r21,64704
   1a980:	1025883a 	mov	r18,r2
   1a984:	1d6b883a 	add	r21,r3,r21
   1a988:	9809883a 	mov	r4,r19
   1a98c:	a00b883a 	mov	r5,r20
   1a990:	000d883a 	mov	r6,zero
   1a994:	01d00534 	movhi	r7,16404
   1a998:	001f5080 	call	1f508 <__subdf3>
   1a99c:	1009883a 	mov	r4,r2
   1a9a0:	180b883a 	mov	r5,r3
   1a9a4:	900d883a 	mov	r6,r18
   1a9a8:	a80f883a 	mov	r7,r21
   1a9ac:	1027883a 	mov	r19,r2
   1a9b0:	1829883a 	mov	r20,r3
   1a9b4:	001fab80 	call	1fab8 <__gtdf2>
   1a9b8:	00806616 	blt	zero,r2,1ab54 <_dtoa_r+0x12f8>
   1a9bc:	a9e0003c 	xorhi	r7,r21,32768
   1a9c0:	9809883a 	mov	r4,r19
   1a9c4:	a00b883a 	mov	r5,r20
   1a9c8:	900d883a 	mov	r6,r18
   1a9cc:	001fb800 	call	1fb80 <__ltdf2>
   1a9d0:	103d710e 	bge	r2,zero,19f98 <_dtoa_r+0x73c>
   1a9d4:	0029883a 	mov	r20,zero
   1a9d8:	002b883a 	mov	r21,zero
   1a9dc:	003f5406 	br	1a730 <_dtoa_r+0xed4>
   1a9e0:	d9800a17 	ldw	r6,40(sp)
   1a9e4:	e00b883a 	mov	r5,fp
   1a9e8:	8009883a 	mov	r4,r16
   1a9ec:	001cffc0 	call	1cffc <__pow5mult>
   1a9f0:	1039883a 	mov	fp,r2
   1a9f4:	003e2e06 	br	1a2b0 <_dtoa_r+0xa54>
   1a9f8:	d8000c15 	stw	zero,48(sp)
   1a9fc:	003f2006 	br	1a680 <_dtoa_r+0xe24>
   1aa00:	00800044 	movi	r2,1
   1aa04:	d8800c15 	stw	r2,48(sp)
   1aa08:	003c5d06 	br	19b80 <_dtoa_r+0x324>
   1aa0c:	d8c00a17 	ldw	r3,40(sp)
   1aa10:	d9000b17 	ldw	r4,44(sp)
   1aa14:	dcc00a15 	stw	r19,40(sp)
   1aa18:	98c5c83a 	sub	r2,r19,r3
   1aa1c:	2089883a 	add	r4,r4,r2
   1aa20:	d9000b15 	stw	r4,44(sp)
   1aa24:	0027883a 	mov	r19,zero
   1aa28:	003df206 	br	1a1f4 <_dtoa_r+0x998>
   1aa2c:	d9000317 	ldw	r4,12(sp)
   1aa30:	8829883a 	mov	r20,r17
   1aa34:	04800084 	movi	r18,2
   1aa38:	d9001015 	stw	r4,64(sp)
   1aa3c:	003c8106 	br	19c44 <_dtoa_r+0x3e8>
   1aa40:	04800044 	movi	r18,1
   1aa44:	dc800e15 	stw	r18,56(sp)
   1aa48:	dc800915 	stw	r18,36(sp)
   1aa4c:	dc802115 	stw	r18,132(sp)
   1aa50:	003f1206 	br	1a69c <_dtoa_r+0xe40>
   1aa54:	d8800617 	ldw	r2,24(sp)
   1aa58:	00abc83a 	sub	r21,zero,r2
   1aa5c:	a800a426 	beq	r21,zero,1acf0 <_dtoa_r+0x1494>
   1aa60:	a88003cc 	andi	r2,r21,15
   1aa64:	100490fa 	slli	r2,r2,3
   1aa68:	00c000f4 	movhi	r3,3
   1aa6c:	18c02304 	addi	r3,r3,140
   1aa70:	d9000317 	ldw	r4,12(sp)
   1aa74:	1885883a 	add	r2,r3,r2
   1aa78:	11800017 	ldw	r6,0(r2)
   1aa7c:	11c00117 	ldw	r7,4(r2)
   1aa80:	a82bd13a 	srai	r21,r21,4
   1aa84:	880b883a 	mov	r5,r17
   1aa88:	001f5680 	call	1f568 <__muldf3>
   1aa8c:	1027883a 	mov	r19,r2
   1aa90:	1829883a 	mov	r20,r3
   1aa94:	a800e826 	beq	r21,zero,1ae38 <_dtoa_r+0x15dc>
   1aa98:	058000f4 	movhi	r22,3
   1aa9c:	b5801904 	addi	r22,r22,100
   1aaa0:	04800084 	movi	r18,2
   1aaa4:	a980004c 	andi	r6,r21,1
   1aaa8:	1009883a 	mov	r4,r2
   1aaac:	a82bd07a 	srai	r21,r21,1
   1aab0:	180b883a 	mov	r5,r3
   1aab4:	30000426 	beq	r6,zero,1aac8 <_dtoa_r+0x126c>
   1aab8:	b1800017 	ldw	r6,0(r22)
   1aabc:	b1c00117 	ldw	r7,4(r22)
   1aac0:	94800044 	addi	r18,r18,1
   1aac4:	001f5680 	call	1f568 <__muldf3>
   1aac8:	b5800204 	addi	r22,r22,8
   1aacc:	a83ff51e 	bne	r21,zero,1aaa4 <_dtoa_r+0x1248>
   1aad0:	1027883a 	mov	r19,r2
   1aad4:	1829883a 	mov	r20,r3
   1aad8:	003c7306 	br	19ca8 <_dtoa_r+0x44c>
   1aadc:	21000044 	addi	r4,r4,1
   1aae0:	11000005 	stb	r4,0(r2)
   1aae4:	003e5c06 	br	1a458 <_dtoa_r+0xbfc>
   1aae8:	a9400117 	ldw	r5,4(r21)
   1aaec:	8009883a 	mov	r4,r16
   1aaf0:	001c9e00 	call	1c9e0 <_Balloc>
   1aaf4:	a9800417 	ldw	r6,16(r21)
   1aaf8:	11000304 	addi	r4,r2,12
   1aafc:	a9400304 	addi	r5,r21,12
   1ab00:	31800084 	addi	r6,r6,2
   1ab04:	318d883a 	add	r6,r6,r6
   1ab08:	318d883a 	add	r6,r6,r6
   1ab0c:	1023883a 	mov	r17,r2
   1ab10:	0016e680 	call	16e68 <memcpy>
   1ab14:	8009883a 	mov	r4,r16
   1ab18:	880b883a 	mov	r5,r17
   1ab1c:	01800044 	movi	r6,1
   1ab20:	001d1280 	call	1d128 <__lshift>
   1ab24:	1027883a 	mov	r19,r2
   1ab28:	003e8f06 	br	1a568 <_dtoa_r+0xd0c>
   1ab2c:	b807883a 	mov	r3,r23
   1ab30:	00800e44 	movi	r2,57
   1ab34:	ddc00717 	ldw	r23,28(sp)
   1ab38:	18809026 	beq	r3,r2,1ad7c <_dtoa_r+0x1520>
   1ab3c:	18c00044 	addi	r3,r3,1
   1ab40:	003f2b06 	br	1a7f0 <_dtoa_r+0xf94>
   1ab44:	b807883a 	mov	r3,r23
   1ab48:	982b883a 	mov	r21,r19
   1ab4c:	ddc00717 	ldw	r23,28(sp)
   1ab50:	003e2406 	br	1a3e4 <_dtoa_r+0xb88>
   1ab54:	0029883a 	mov	r20,zero
   1ab58:	002b883a 	mov	r21,zero
   1ab5c:	003f7206 	br	1a928 <_dtoa_r+0x10cc>
   1ab60:	593fffc4 	addi	r4,r11,-1
   1ab64:	200490fa 	slli	r2,r4,3
   1ab68:	00c000f4 	movhi	r3,3
   1ab6c:	18c02304 	addi	r3,r3,140
   1ab70:	d9001015 	stw	r4,64(sp)
   1ab74:	1885883a 	add	r2,r3,r2
   1ab78:	11000017 	ldw	r4,0(r2)
   1ab7c:	11400117 	ldw	r5,4(r2)
   1ab80:	900d883a 	mov	r6,r18
   1ab84:	a80f883a 	mov	r7,r21
   1ab88:	dac01615 	stw	r11,88(sp)
   1ab8c:	001f5680 	call	1f568 <__muldf3>
   1ab90:	a00b883a 	mov	r5,r20
   1ab94:	9809883a 	mov	r4,r19
   1ab98:	d8c01215 	stw	r3,72(sp)
   1ab9c:	d8801115 	stw	r2,68(sp)
   1aba0:	001fcb00 	call	1fcb0 <__fixdfsi>
   1aba4:	1009883a 	mov	r4,r2
   1aba8:	1025883a 	mov	r18,r2
   1abac:	001fbdc0 	call	1fbdc <__floatsidf>
   1abb0:	9809883a 	mov	r4,r19
   1abb4:	a00b883a 	mov	r5,r20
   1abb8:	100d883a 	mov	r6,r2
   1abbc:	180f883a 	mov	r7,r3
   1abc0:	94800c04 	addi	r18,r18,48
   1abc4:	001f5080 	call	1f508 <__subdf3>
   1abc8:	bc800005 	stb	r18,0(r23)
   1abcc:	dac01617 	ldw	r11,88(sp)
   1abd0:	102b883a 	mov	r21,r2
   1abd4:	00800044 	movi	r2,1
   1abd8:	bd800044 	addi	r22,r23,1
   1abdc:	1815883a 	mov	r10,r3
   1abe0:	58802226 	beq	r11,r2,1ac6c <_dtoa_r+0x1410>
   1abe4:	bad7883a 	add	r11,r23,r11
   1abe8:	dc001415 	stw	r16,80(sp)
   1abec:	a805883a 	mov	r2,r21
   1abf0:	b027883a 	mov	r19,r22
   1abf4:	5821883a 	mov	r16,r11
   1abf8:	882b883a 	mov	r21,r17
   1abfc:	000d883a 	mov	r6,zero
   1ac00:	01d00934 	movhi	r7,16420
   1ac04:	1009883a 	mov	r4,r2
   1ac08:	180b883a 	mov	r5,r3
   1ac0c:	001f5680 	call	1f568 <__muldf3>
   1ac10:	180b883a 	mov	r5,r3
   1ac14:	1009883a 	mov	r4,r2
   1ac18:	1829883a 	mov	r20,r3
   1ac1c:	1023883a 	mov	r17,r2
   1ac20:	001fcb00 	call	1fcb0 <__fixdfsi>
   1ac24:	1009883a 	mov	r4,r2
   1ac28:	1025883a 	mov	r18,r2
   1ac2c:	001fbdc0 	call	1fbdc <__floatsidf>
   1ac30:	8809883a 	mov	r4,r17
   1ac34:	a00b883a 	mov	r5,r20
   1ac38:	100d883a 	mov	r6,r2
   1ac3c:	180f883a 	mov	r7,r3
   1ac40:	94800c04 	addi	r18,r18,48
   1ac44:	001f5080 	call	1f508 <__subdf3>
   1ac48:	9cc00044 	addi	r19,r19,1
   1ac4c:	9cbfffc5 	stb	r18,-1(r19)
   1ac50:	9c3fea1e 	bne	r19,r16,1abfc <_dtoa_r+0x13a0>
   1ac54:	1815883a 	mov	r10,r3
   1ac58:	d8c01017 	ldw	r3,64(sp)
   1ac5c:	dc001417 	ldw	r16,80(sp)
   1ac60:	a823883a 	mov	r17,r21
   1ac64:	b0ed883a 	add	r22,r22,r3
   1ac68:	102b883a 	mov	r21,r2
   1ac6c:	d9001117 	ldw	r4,68(sp)
   1ac70:	d9401217 	ldw	r5,72(sp)
   1ac74:	000d883a 	mov	r6,zero
   1ac78:	01cff834 	movhi	r7,16352
   1ac7c:	da801515 	stw	r10,84(sp)
   1ac80:	001f4b40 	call	1f4b4 <__adddf3>
   1ac84:	da801517 	ldw	r10,84(sp)
   1ac88:	1009883a 	mov	r4,r2
   1ac8c:	180b883a 	mov	r5,r3
   1ac90:	500f883a 	mov	r7,r10
   1ac94:	a80d883a 	mov	r6,r21
   1ac98:	001fb800 	call	1fb80 <__ltdf2>
   1ac9c:	da801517 	ldw	r10,84(sp)
   1aca0:	10003b0e 	bge	r2,zero,1ad90 <_dtoa_r+0x1534>
   1aca4:	d9c01317 	ldw	r7,76(sp)
   1aca8:	b53fffc3 	ldbu	r20,-1(r22)
   1acac:	d9c00615 	stw	r7,24(sp)
   1acb0:	003d3106 	br	1a178 <_dtoa_r+0x91c>
   1acb4:	d8800817 	ldw	r2,32(sp)
   1acb8:	11e5c83a 	sub	r18,r2,r7
   1acbc:	0005883a 	mov	r2,zero
   1acc0:	003d5006 	br	1a204 <_dtoa_r+0x9a8>
   1acc4:	05800044 	movi	r22,1
   1acc8:	003dc406 	br	1a3dc <_dtoa_r+0xb80>
   1accc:	a5000044 	addi	r20,r20,1
   1acd0:	15000005 	stb	r20,0(r2)
   1acd4:	003c8206 	br	19ee0 <_dtoa_r+0x684>
   1acd8:	d8800217 	ldw	r2,8(sp)
   1acdc:	00c00d84 	movi	r3,54
   1ace0:	dcc00a17 	ldw	r19,40(sp)
   1ace4:	1885c83a 	sub	r2,r3,r2
   1ace8:	dc800817 	ldw	r18,32(sp)
   1acec:	003d4506 	br	1a204 <_dtoa_r+0x9a8>
   1acf0:	dcc00317 	ldw	r19,12(sp)
   1acf4:	8829883a 	mov	r20,r17
   1acf8:	04800084 	movi	r18,2
   1acfc:	003bea06 	br	19ca8 <_dtoa_r+0x44c>
   1ad00:	d9000917 	ldw	r4,36(sp)
   1ad04:	203f1126 	beq	r4,zero,1a94c <_dtoa_r+0x10f0>
   1ad08:	d9c00e17 	ldw	r7,56(sp)
   1ad0c:	01fca20e 	bge	zero,r7,19f98 <_dtoa_r+0x73c>
   1ad10:	a00b883a 	mov	r5,r20
   1ad14:	9809883a 	mov	r4,r19
   1ad18:	000d883a 	mov	r6,zero
   1ad1c:	01d00934 	movhi	r7,16420
   1ad20:	001f5680 	call	1f568 <__muldf3>
   1ad24:	91000044 	addi	r4,r18,1
   1ad28:	1027883a 	mov	r19,r2
   1ad2c:	1829883a 	mov	r20,r3
   1ad30:	001fbdc0 	call	1fbdc <__floatsidf>
   1ad34:	9809883a 	mov	r4,r19
   1ad38:	a00b883a 	mov	r5,r20
   1ad3c:	100d883a 	mov	r6,r2
   1ad40:	180f883a 	mov	r7,r3
   1ad44:	001f5680 	call	1f568 <__muldf3>
   1ad48:	1009883a 	mov	r4,r2
   1ad4c:	180b883a 	mov	r5,r3
   1ad50:	000d883a 	mov	r6,zero
   1ad54:	01d00734 	movhi	r7,16412
   1ad58:	001f4b40 	call	1f4b4 <__adddf3>
   1ad5c:	1025883a 	mov	r18,r2
   1ad60:	d8800617 	ldw	r2,24(sp)
   1ad64:	057f3034 	movhi	r21,64704
   1ad68:	1d6b883a 	add	r21,r3,r21
   1ad6c:	10bfffc4 	addi	r2,r2,-1
   1ad70:	d8801315 	stw	r2,76(sp)
   1ad74:	dac00e17 	ldw	r11,56(sp)
   1ad78:	003be706 	br	19d18 <_dtoa_r+0x4bc>
   1ad7c:	01000e44 	movi	r4,57
   1ad80:	91000005 	stb	r4,0(r18)
   1ad84:	95800044 	addi	r22,r18,1
   1ad88:	982b883a 	mov	r21,r19
   1ad8c:	003da106 	br	1a414 <_dtoa_r+0xbb8>
   1ad90:	d9801117 	ldw	r6,68(sp)
   1ad94:	d9c01217 	ldw	r7,72(sp)
   1ad98:	0009883a 	mov	r4,zero
   1ad9c:	014ff834 	movhi	r5,16352
   1ada0:	da801515 	stw	r10,84(sp)
   1ada4:	001f5080 	call	1f508 <__subdf3>
   1ada8:	da801517 	ldw	r10,84(sp)
   1adac:	1009883a 	mov	r4,r2
   1adb0:	180b883a 	mov	r5,r3
   1adb4:	a80d883a 	mov	r6,r21
   1adb8:	500f883a 	mov	r7,r10
   1adbc:	001fab80 	call	1fab8 <__gtdf2>
   1adc0:	00bc750e 	bge	zero,r2,19f98 <_dtoa_r+0x73c>
   1adc4:	01000c04 	movi	r4,48
   1adc8:	00000106 	br	1add0 <_dtoa_r+0x1574>
   1adcc:	102d883a 	mov	r22,r2
   1add0:	b0bfffc4 	addi	r2,r22,-1
   1add4:	10c00007 	ldb	r3,0(r2)
   1add8:	193ffc26 	beq	r3,r4,1adcc <_dtoa_r+0x1570>
   1addc:	d8801317 	ldw	r2,76(sp)
   1ade0:	d8800615 	stw	r2,24(sp)
   1ade4:	003c3e06 	br	19ee0 <_dtoa_r+0x684>
   1ade8:	d9001317 	ldw	r4,76(sp)
   1adec:	df001117 	ldw	fp,68(sp)
   1adf0:	d9000615 	stw	r4,24(sp)
   1adf4:	003ce006 	br	1a178 <_dtoa_r+0x91c>
   1adf8:	df001117 	ldw	fp,68(sp)
   1adfc:	dc401217 	ldw	r17,72(sp)
   1ae00:	003c6506 	br	19f98 <_dtoa_r+0x73c>
   1ae04:	103e7a1e 	bne	r2,zero,1a7f0 <_dtoa_r+0xf94>
   1ae08:	1880004c 	andi	r2,r3,1
   1ae0c:	103e7826 	beq	r2,zero,1a7f0 <_dtoa_r+0xf94>
   1ae10:	003e7406 	br	1a7e4 <_dtoa_r+0xf88>
   1ae14:	8009883a 	mov	r4,r16
   1ae18:	a80b883a 	mov	r5,r21
   1ae1c:	01800284 	movi	r6,10
   1ae20:	000f883a 	mov	r7,zero
   1ae24:	001cab00 	call	1cab0 <__multadd>
   1ae28:	d9000e17 	ldw	r4,56(sp)
   1ae2c:	102b883a 	mov	r21,r2
   1ae30:	d9000915 	stw	r4,36(sp)
   1ae34:	003d5106 	br	1a37c <_dtoa_r+0xb20>
   1ae38:	04800084 	movi	r18,2
   1ae3c:	003b9a06 	br	19ca8 <_dtoa_r+0x44c>
   1ae40:	d8c01317 	ldw	r3,76(sp)
   1ae44:	d8c00615 	stw	r3,24(sp)
   1ae48:	003ccb06 	br	1a178 <_dtoa_r+0x91c>
   1ae4c:	d8c01317 	ldw	r3,76(sp)
   1ae50:	d8c00615 	stw	r3,24(sp)
   1ae54:	003c2206 	br	19ee0 <_dtoa_r+0x684>
   1ae58:	20fd3826 	beq	r4,r3,1a33c <_dtoa_r+0xae0>
   1ae5c:	00c00f04 	movi	r3,60
   1ae60:	1885c83a 	sub	r2,r3,r2
   1ae64:	003da906 	br	1a50c <_dtoa_r+0xcb0>
   1ae68:	000b883a 	mov	r5,zero
   1ae6c:	003b5406 	br	19bc0 <_dtoa_r+0x364>
   1ae70:	04c00044 	movi	r19,1
   1ae74:	003b3b06 	br	19b64 <_dtoa_r+0x308>

0001ae78 <_fflush_r>:
   1ae78:	defffb04 	addi	sp,sp,-20
   1ae7c:	dcc00315 	stw	r19,12(sp)
   1ae80:	dc400115 	stw	r17,4(sp)
   1ae84:	dfc00415 	stw	ra,16(sp)
   1ae88:	dc800215 	stw	r18,8(sp)
   1ae8c:	dc000015 	stw	r16,0(sp)
   1ae90:	2027883a 	mov	r19,r4
   1ae94:	2823883a 	mov	r17,r5
   1ae98:	20000226 	beq	r4,zero,1aea4 <_fflush_r+0x2c>
   1ae9c:	20800e17 	ldw	r2,56(r4)
   1aea0:	10005726 	beq	r2,zero,1b000 <_fflush_r+0x188>
   1aea4:	8880030b 	ldhu	r2,12(r17)
   1aea8:	10c0020c 	andi	r3,r2,8
   1aeac:	18ffffcc 	andi	r3,r3,65535
   1aeb0:	18e0001c 	xori	r3,r3,32768
   1aeb4:	18e00004 	addi	r3,r3,-32768
   1aeb8:	1800311e 	bne	r3,zero,1af80 <_fflush_r+0x108>
   1aebc:	89000117 	ldw	r4,4(r17)
   1aec0:	10c20014 	ori	r3,r2,2048
   1aec4:	88c0030d 	sth	r3,12(r17)
   1aec8:	180b883a 	mov	r5,r3
   1aecc:	0100520e 	bge	zero,r4,1b018 <_fflush_r+0x1a0>
   1aed0:	88c00a17 	ldw	r3,40(r17)
   1aed4:	18002226 	beq	r3,zero,1af60 <_fflush_r+0xe8>
   1aed8:	1084000c 	andi	r2,r2,4096
   1aedc:	10bfffcc 	andi	r2,r2,65535
   1aee0:	10a0001c 	xori	r2,r2,32768
   1aee4:	10a00004 	addi	r2,r2,-32768
   1aee8:	10004e26 	beq	r2,zero,1b024 <_fflush_r+0x1ac>
   1aeec:	8c001417 	ldw	r16,80(r17)
   1aef0:	2940010c 	andi	r5,r5,4
   1aef4:	297fffcc 	andi	r5,r5,65535
   1aef8:	2960001c 	xori	r5,r5,32768
   1aefc:	29600004 	addi	r5,r5,-32768
   1af00:	28000626 	beq	r5,zero,1af1c <_fflush_r+0xa4>
   1af04:	89000117 	ldw	r4,4(r17)
   1af08:	88800c17 	ldw	r2,48(r17)
   1af0c:	8121c83a 	sub	r16,r16,r4
   1af10:	10000226 	beq	r2,zero,1af1c <_fflush_r+0xa4>
   1af14:	88800f17 	ldw	r2,60(r17)
   1af18:	80a1c83a 	sub	r16,r16,r2
   1af1c:	89400717 	ldw	r5,28(r17)
   1af20:	9809883a 	mov	r4,r19
   1af24:	800d883a 	mov	r6,r16
   1af28:	000f883a 	mov	r7,zero
   1af2c:	183ee83a 	callr	r3
   1af30:	8080281e 	bne	r16,r2,1afd4 <_fflush_r+0x15c>
   1af34:	8880030b 	ldhu	r2,12(r17)
   1af38:	88c00417 	ldw	r3,16(r17)
   1af3c:	88000115 	stw	zero,4(r17)
   1af40:	113dffcc 	andi	r4,r2,63487
   1af44:	1084000c 	andi	r2,r2,4096
   1af48:	10bfffcc 	andi	r2,r2,65535
   1af4c:	10a0001c 	xori	r2,r2,32768
   1af50:	8900030d 	sth	r4,12(r17)
   1af54:	88c00015 	stw	r3,0(r17)
   1af58:	10a00004 	addi	r2,r2,-32768
   1af5c:	10002c1e 	bne	r2,zero,1b010 <_fflush_r+0x198>
   1af60:	0005883a 	mov	r2,zero
   1af64:	dfc00417 	ldw	ra,16(sp)
   1af68:	dcc00317 	ldw	r19,12(sp)
   1af6c:	dc800217 	ldw	r18,8(sp)
   1af70:	dc400117 	ldw	r17,4(sp)
   1af74:	dc000017 	ldw	r16,0(sp)
   1af78:	dec00504 	addi	sp,sp,20
   1af7c:	f800283a 	ret
   1af80:	8c800417 	ldw	r18,16(r17)
   1af84:	903ff626 	beq	r18,zero,1af60 <_fflush_r+0xe8>
   1af88:	8c000017 	ldw	r16,0(r17)
   1af8c:	108000cc 	andi	r2,r2,3
   1af90:	8c800015 	stw	r18,0(r17)
   1af94:	84a1c83a 	sub	r16,r16,r18
   1af98:	10001b1e 	bne	r2,zero,1b008 <_fflush_r+0x190>
   1af9c:	88800517 	ldw	r2,20(r17)
   1afa0:	88800215 	stw	r2,8(r17)
   1afa4:	04000316 	blt	zero,r16,1afb4 <_fflush_r+0x13c>
   1afa8:	003fed06 	br	1af60 <_fflush_r+0xe8>
   1afac:	90a5883a 	add	r18,r18,r2
   1afb0:	043feb0e 	bge	zero,r16,1af60 <_fflush_r+0xe8>
   1afb4:	88800917 	ldw	r2,36(r17)
   1afb8:	89400717 	ldw	r5,28(r17)
   1afbc:	800f883a 	mov	r7,r16
   1afc0:	900d883a 	mov	r6,r18
   1afc4:	9809883a 	mov	r4,r19
   1afc8:	103ee83a 	callr	r2
   1afcc:	80a1c83a 	sub	r16,r16,r2
   1afd0:	00bff616 	blt	zero,r2,1afac <_fflush_r+0x134>
   1afd4:	88c0030b 	ldhu	r3,12(r17)
   1afd8:	00bfffc4 	movi	r2,-1
   1afdc:	18c01014 	ori	r3,r3,64
   1afe0:	88c0030d 	sth	r3,12(r17)
   1afe4:	dfc00417 	ldw	ra,16(sp)
   1afe8:	dcc00317 	ldw	r19,12(sp)
   1afec:	dc800217 	ldw	r18,8(sp)
   1aff0:	dc400117 	ldw	r17,4(sp)
   1aff4:	dc000017 	ldw	r16,0(sp)
   1aff8:	dec00504 	addi	sp,sp,20
   1affc:	f800283a 	ret
   1b000:	001b1200 	call	1b120 <__sinit>
   1b004:	003fa706 	br	1aea4 <_fflush_r+0x2c>
   1b008:	0005883a 	mov	r2,zero
   1b00c:	003fe406 	br	1afa0 <_fflush_r+0x128>
   1b010:	8c001415 	stw	r16,80(r17)
   1b014:	003fd206 	br	1af60 <_fflush_r+0xe8>
   1b018:	88c00f17 	ldw	r3,60(r17)
   1b01c:	00ffac16 	blt	zero,r3,1aed0 <_fflush_r+0x58>
   1b020:	003fcf06 	br	1af60 <_fflush_r+0xe8>
   1b024:	89400717 	ldw	r5,28(r17)
   1b028:	9809883a 	mov	r4,r19
   1b02c:	000d883a 	mov	r6,zero
   1b030:	01c00044 	movi	r7,1
   1b034:	183ee83a 	callr	r3
   1b038:	1021883a 	mov	r16,r2
   1b03c:	00bfffc4 	movi	r2,-1
   1b040:	80800326 	beq	r16,r2,1b050 <_fflush_r+0x1d8>
   1b044:	8940030b 	ldhu	r5,12(r17)
   1b048:	88c00a17 	ldw	r3,40(r17)
   1b04c:	003fa806 	br	1aef0 <_fflush_r+0x78>
   1b050:	98c00017 	ldw	r3,0(r19)
   1b054:	00800744 	movi	r2,29
   1b058:	18bfde1e 	bne	r3,r2,1afd4 <_fflush_r+0x15c>
   1b05c:	003fc006 	br	1af60 <_fflush_r+0xe8>

0001b060 <fflush>:
   1b060:	200b883a 	mov	r5,r4
   1b064:	20000426 	beq	r4,zero,1b078 <fflush+0x18>
   1b068:	008000f4 	movhi	r2,3
   1b06c:	1090f704 	addi	r2,r2,17372
   1b070:	11000017 	ldw	r4,0(r2)
   1b074:	001ae781 	jmpi	1ae78 <_fflush_r>
   1b078:	008000f4 	movhi	r2,3
   1b07c:	1090f604 	addi	r2,r2,17368
   1b080:	11000017 	ldw	r4,0(r2)
   1b084:	014000b4 	movhi	r5,2
   1b088:	296b9e04 	addi	r5,r5,-20872
   1b08c:	001bd001 	jmpi	1bd00 <_fwalk_reent>

0001b090 <__fp_lock>:
   1b090:	0005883a 	mov	r2,zero
   1b094:	f800283a 	ret

0001b098 <__fp_unlock>:
   1b098:	0005883a 	mov	r2,zero
   1b09c:	f800283a 	ret

0001b0a0 <_cleanup_r>:
   1b0a0:	014000b4 	movhi	r5,2
   1b0a4:	29791504 	addi	r5,r5,-7084
   1b0a8:	001bc581 	jmpi	1bc58 <_fwalk>

0001b0ac <__sfmoreglue>:
   1b0ac:	defffc04 	addi	sp,sp,-16
   1b0b0:	dc400115 	stw	r17,4(sp)
   1b0b4:	2c401724 	muli	r17,r5,92
   1b0b8:	dc800215 	stw	r18,8(sp)
   1b0bc:	2825883a 	mov	r18,r5
   1b0c0:	89400304 	addi	r5,r17,12
   1b0c4:	dc000015 	stw	r16,0(sp)
   1b0c8:	dfc00315 	stw	ra,12(sp)
   1b0cc:	001c03c0 	call	1c03c <_malloc_r>
   1b0d0:	1021883a 	mov	r16,r2
   1b0d4:	10000726 	beq	r2,zero,1b0f4 <__sfmoreglue+0x48>
   1b0d8:	11000304 	addi	r4,r2,12
   1b0dc:	10000015 	stw	zero,0(r2)
   1b0e0:	14800115 	stw	r18,4(r2)
   1b0e4:	11000215 	stw	r4,8(r2)
   1b0e8:	000b883a 	mov	r5,zero
   1b0ec:	880d883a 	mov	r6,r17
   1b0f0:	0016f600 	call	16f60 <memset>
   1b0f4:	8005883a 	mov	r2,r16
   1b0f8:	dfc00317 	ldw	ra,12(sp)
   1b0fc:	dc800217 	ldw	r18,8(sp)
   1b100:	dc400117 	ldw	r17,4(sp)
   1b104:	dc000017 	ldw	r16,0(sp)
   1b108:	dec00404 	addi	sp,sp,16
   1b10c:	f800283a 	ret

0001b110 <_cleanup>:
   1b110:	008000f4 	movhi	r2,3
   1b114:	1090f604 	addi	r2,r2,17368
   1b118:	11000017 	ldw	r4,0(r2)
   1b11c:	001b0a01 	jmpi	1b0a0 <_cleanup_r>

0001b120 <__sinit>:
   1b120:	20800e17 	ldw	r2,56(r4)
   1b124:	1000401e 	bne	r2,zero,1b228 <__sinit+0x108>
   1b128:	21400117 	ldw	r5,4(r4)
   1b12c:	018000b4 	movhi	r6,2
   1b130:	31ac2804 	addi	r6,r6,-20320
   1b134:	20c00217 	ldw	r3,8(r4)
   1b138:	21800f15 	stw	r6,60(r4)
   1b13c:	2080bb04 	addi	r2,r4,748
   1b140:	02400044 	movi	r9,1
   1b144:	018000c4 	movi	r6,3
   1b148:	2180b915 	stw	r6,740(r4)
   1b14c:	2080ba15 	stw	r2,744(r4)
   1b150:	22400e15 	stw	r9,56(r4)
   1b154:	20800317 	ldw	r2,12(r4)
   1b158:	2000b815 	stw	zero,736(r4)
   1b15c:	020000b4 	movhi	r8,2
   1b160:	42381304 	addi	r8,r8,-8116
   1b164:	01c000b4 	movhi	r7,2
   1b168:	39f82804 	addi	r7,r7,-8032
   1b16c:	018000b4 	movhi	r6,2
   1b170:	31b84a04 	addi	r6,r6,-7896
   1b174:	010000b4 	movhi	r4,2
   1b178:	21386104 	addi	r4,r4,-7804
   1b17c:	02800104 	movi	r10,4
   1b180:	28000015 	stw	zero,0(r5)
   1b184:	28000115 	stw	zero,4(r5)
   1b188:	28000215 	stw	zero,8(r5)
   1b18c:	2a80030d 	sth	r10,12(r5)
   1b190:	2800038d 	sth	zero,14(r5)
   1b194:	28000415 	stw	zero,16(r5)
   1b198:	28000515 	stw	zero,20(r5)
   1b19c:	28000615 	stw	zero,24(r5)
   1b1a0:	29400715 	stw	r5,28(r5)
   1b1a4:	2a000815 	stw	r8,32(r5)
   1b1a8:	29c00915 	stw	r7,36(r5)
   1b1ac:	29800a15 	stw	r6,40(r5)
   1b1b0:	29000b15 	stw	r4,44(r5)
   1b1b4:	01400284 	movi	r5,10
   1b1b8:	18000015 	stw	zero,0(r3)
   1b1bc:	18000115 	stw	zero,4(r3)
   1b1c0:	18000215 	stw	zero,8(r3)
   1b1c4:	1940030d 	sth	r5,12(r3)
   1b1c8:	1a40038d 	sth	r9,14(r3)
   1b1cc:	18000415 	stw	zero,16(r3)
   1b1d0:	18000515 	stw	zero,20(r3)
   1b1d4:	18000615 	stw	zero,24(r3)
   1b1d8:	18c00715 	stw	r3,28(r3)
   1b1dc:	1a000815 	stw	r8,32(r3)
   1b1e0:	19c00915 	stw	r7,36(r3)
   1b1e4:	19800a15 	stw	r6,40(r3)
   1b1e8:	19000b15 	stw	r4,44(r3)
   1b1ec:	00c00484 	movi	r3,18
   1b1f0:	10c0030d 	sth	r3,12(r2)
   1b1f4:	00c00084 	movi	r3,2
   1b1f8:	10000015 	stw	zero,0(r2)
   1b1fc:	10000115 	stw	zero,4(r2)
   1b200:	10000215 	stw	zero,8(r2)
   1b204:	10c0038d 	sth	r3,14(r2)
   1b208:	10000415 	stw	zero,16(r2)
   1b20c:	10000515 	stw	zero,20(r2)
   1b210:	10000615 	stw	zero,24(r2)
   1b214:	10800715 	stw	r2,28(r2)
   1b218:	12000815 	stw	r8,32(r2)
   1b21c:	11c00915 	stw	r7,36(r2)
   1b220:	11800a15 	stw	r6,40(r2)
   1b224:	11000b15 	stw	r4,44(r2)
   1b228:	f800283a 	ret

0001b22c <__sfp>:
   1b22c:	defffc04 	addi	sp,sp,-16
   1b230:	008000f4 	movhi	r2,3
   1b234:	1090f604 	addi	r2,r2,17368
   1b238:	dc400115 	stw	r17,4(sp)
   1b23c:	14400017 	ldw	r17,0(r2)
   1b240:	dc800215 	stw	r18,8(sp)
   1b244:	dfc00315 	stw	ra,12(sp)
   1b248:	88800e17 	ldw	r2,56(r17)
   1b24c:	dc000015 	stw	r16,0(sp)
   1b250:	2025883a 	mov	r18,r4
   1b254:	10002826 	beq	r2,zero,1b2f8 <__sfp+0xcc>
   1b258:	8c40b804 	addi	r17,r17,736
   1b25c:	043fffc4 	movi	r16,-1
   1b260:	89400117 	ldw	r5,4(r17)
   1b264:	88800217 	ldw	r2,8(r17)
   1b268:	297fffc4 	addi	r5,r5,-1
   1b26c:	28000a16 	blt	r5,zero,1b298 <__sfp+0x6c>
   1b270:	10c0030f 	ldh	r3,12(r2)
   1b274:	18000c26 	beq	r3,zero,1b2a8 <__sfp+0x7c>
   1b278:	10c01a04 	addi	r3,r2,104
   1b27c:	00000206 	br	1b288 <__sfp+0x5c>
   1b280:	19bfe90f 	ldh	r6,-92(r3)
   1b284:	30000826 	beq	r6,zero,1b2a8 <__sfp+0x7c>
   1b288:	297fffc4 	addi	r5,r5,-1
   1b28c:	18bffd04 	addi	r2,r3,-12
   1b290:	18c01704 	addi	r3,r3,92
   1b294:	2c3ffa1e 	bne	r5,r16,1b280 <__sfp+0x54>
   1b298:	88800017 	ldw	r2,0(r17)
   1b29c:	10001926 	beq	r2,zero,1b304 <__sfp+0xd8>
   1b2a0:	1023883a 	mov	r17,r2
   1b2a4:	003fee06 	br	1b260 <__sfp+0x34>
   1b2a8:	00ffffc4 	movi	r3,-1
   1b2ac:	10c0038d 	sth	r3,14(r2)
   1b2b0:	00c00044 	movi	r3,1
   1b2b4:	10c0030d 	sth	r3,12(r2)
   1b2b8:	10000015 	stw	zero,0(r2)
   1b2bc:	10000215 	stw	zero,8(r2)
   1b2c0:	10000115 	stw	zero,4(r2)
   1b2c4:	10000415 	stw	zero,16(r2)
   1b2c8:	10000515 	stw	zero,20(r2)
   1b2cc:	10000615 	stw	zero,24(r2)
   1b2d0:	10000c15 	stw	zero,48(r2)
   1b2d4:	10000d15 	stw	zero,52(r2)
   1b2d8:	10001115 	stw	zero,68(r2)
   1b2dc:	10001215 	stw	zero,72(r2)
   1b2e0:	dfc00317 	ldw	ra,12(sp)
   1b2e4:	dc800217 	ldw	r18,8(sp)
   1b2e8:	dc400117 	ldw	r17,4(sp)
   1b2ec:	dc000017 	ldw	r16,0(sp)
   1b2f0:	dec00404 	addi	sp,sp,16
   1b2f4:	f800283a 	ret
   1b2f8:	8809883a 	mov	r4,r17
   1b2fc:	001b1200 	call	1b120 <__sinit>
   1b300:	003fd506 	br	1b258 <__sfp+0x2c>
   1b304:	9009883a 	mov	r4,r18
   1b308:	01400104 	movi	r5,4
   1b30c:	001b0ac0 	call	1b0ac <__sfmoreglue>
   1b310:	88800015 	stw	r2,0(r17)
   1b314:	103fe21e 	bne	r2,zero,1b2a0 <__sfp+0x74>
   1b318:	00800304 	movi	r2,12
   1b31c:	90800015 	stw	r2,0(r18)
   1b320:	0005883a 	mov	r2,zero
   1b324:	003fee06 	br	1b2e0 <__sfp+0xb4>

0001b328 <__sfp_lock_acquire>:
   1b328:	f800283a 	ret

0001b32c <__sfp_lock_release>:
   1b32c:	f800283a 	ret

0001b330 <__sinit_lock_acquire>:
   1b330:	f800283a 	ret

0001b334 <__sinit_lock_release>:
   1b334:	f800283a 	ret

0001b338 <__fp_lock_all>:
   1b338:	008000f4 	movhi	r2,3
   1b33c:	1090f704 	addi	r2,r2,17372
   1b340:	11000017 	ldw	r4,0(r2)
   1b344:	014000b4 	movhi	r5,2
   1b348:	296c2404 	addi	r5,r5,-20336
   1b34c:	001bc581 	jmpi	1bc58 <_fwalk>

0001b350 <__fp_unlock_all>:
   1b350:	008000f4 	movhi	r2,3
   1b354:	1090f704 	addi	r2,r2,17372
   1b358:	11000017 	ldw	r4,0(r2)
   1b35c:	014000b4 	movhi	r5,2
   1b360:	296c2604 	addi	r5,r5,-20328
   1b364:	001bc581 	jmpi	1bc58 <_fwalk>

0001b368 <_malloc_trim_r>:
   1b368:	defffb04 	addi	sp,sp,-20
   1b36c:	dcc00315 	stw	r19,12(sp)
   1b370:	dc800215 	stw	r18,8(sp)
   1b374:	dc400115 	stw	r17,4(sp)
   1b378:	dc000015 	stw	r16,0(sp)
   1b37c:	2827883a 	mov	r19,r5
   1b380:	dfc00415 	stw	ra,16(sp)
   1b384:	044000f4 	movhi	r17,3
   1b388:	8c4a1804 	addi	r17,r17,10336
   1b38c:	2021883a 	mov	r16,r4
   1b390:	0020c7c0 	call	20c7c <__malloc_lock>
   1b394:	88800217 	ldw	r2,8(r17)
   1b398:	14800117 	ldw	r18,4(r2)
   1b39c:	00bfff04 	movi	r2,-4
   1b3a0:	90a4703a 	and	r18,r18,r2
   1b3a4:	9083fbc4 	addi	r2,r18,4079
   1b3a8:	14e7c83a 	sub	r19,r2,r19
   1b3ac:	9826d33a 	srli	r19,r19,12
   1b3b0:	0083ffc4 	movi	r2,4095
   1b3b4:	9cffffc4 	addi	r19,r19,-1
   1b3b8:	9826933a 	slli	r19,r19,12
   1b3bc:	14c0060e 	bge	r2,r19,1b3d8 <_malloc_trim_r+0x70>
   1b3c0:	8009883a 	mov	r4,r16
   1b3c4:	000b883a 	mov	r5,zero
   1b3c8:	001dfe80 	call	1dfe8 <_sbrk_r>
   1b3cc:	88c00217 	ldw	r3,8(r17)
   1b3d0:	1c87883a 	add	r3,r3,r18
   1b3d4:	10c00a26 	beq	r2,r3,1b400 <_malloc_trim_r+0x98>
   1b3d8:	8009883a 	mov	r4,r16
   1b3dc:	0020c9c0 	call	20c9c <__malloc_unlock>
   1b3e0:	0005883a 	mov	r2,zero
   1b3e4:	dfc00417 	ldw	ra,16(sp)
   1b3e8:	dcc00317 	ldw	r19,12(sp)
   1b3ec:	dc800217 	ldw	r18,8(sp)
   1b3f0:	dc400117 	ldw	r17,4(sp)
   1b3f4:	dc000017 	ldw	r16,0(sp)
   1b3f8:	dec00504 	addi	sp,sp,20
   1b3fc:	f800283a 	ret
   1b400:	8009883a 	mov	r4,r16
   1b404:	04cbc83a 	sub	r5,zero,r19
   1b408:	001dfe80 	call	1dfe8 <_sbrk_r>
   1b40c:	00ffffc4 	movi	r3,-1
   1b410:	10c01326 	beq	r2,r3,1b460 <_malloc_trim_r+0xf8>
   1b414:	00800134 	movhi	r2,4
   1b418:	10911704 	addi	r2,r2,17500
   1b41c:	11000017 	ldw	r4,0(r2)
   1b420:	88c00217 	ldw	r3,8(r17)
   1b424:	94e5c83a 	sub	r18,r18,r19
   1b428:	94800054 	ori	r18,r18,1
   1b42c:	24e7c83a 	sub	r19,r4,r19
   1b430:	1c800115 	stw	r18,4(r3)
   1b434:	8009883a 	mov	r4,r16
   1b438:	14c00015 	stw	r19,0(r2)
   1b43c:	0020c9c0 	call	20c9c <__malloc_unlock>
   1b440:	00800044 	movi	r2,1
   1b444:	dfc00417 	ldw	ra,16(sp)
   1b448:	dcc00317 	ldw	r19,12(sp)
   1b44c:	dc800217 	ldw	r18,8(sp)
   1b450:	dc400117 	ldw	r17,4(sp)
   1b454:	dc000017 	ldw	r16,0(sp)
   1b458:	dec00504 	addi	sp,sp,20
   1b45c:	f800283a 	ret
   1b460:	8009883a 	mov	r4,r16
   1b464:	000b883a 	mov	r5,zero
   1b468:	001dfe80 	call	1dfe8 <_sbrk_r>
   1b46c:	88c00217 	ldw	r3,8(r17)
   1b470:	014003c4 	movi	r5,15
   1b474:	10c9c83a 	sub	r4,r2,r3
   1b478:	293fd70e 	bge	r5,r4,1b3d8 <_malloc_trim_r+0x70>
   1b47c:	014000f4 	movhi	r5,3
   1b480:	2950f904 	addi	r5,r5,17380
   1b484:	29400017 	ldw	r5,0(r5)
   1b488:	21000054 	ori	r4,r4,1
   1b48c:	19000115 	stw	r4,4(r3)
   1b490:	1145c83a 	sub	r2,r2,r5
   1b494:	01400134 	movhi	r5,4
   1b498:	29511704 	addi	r5,r5,17500
   1b49c:	28800015 	stw	r2,0(r5)
   1b4a0:	003fcd06 	br	1b3d8 <_malloc_trim_r+0x70>

0001b4a4 <_free_r>:
   1b4a4:	defffd04 	addi	sp,sp,-12
   1b4a8:	dc400115 	stw	r17,4(sp)
   1b4ac:	dc000015 	stw	r16,0(sp)
   1b4b0:	dfc00215 	stw	ra,8(sp)
   1b4b4:	2821883a 	mov	r16,r5
   1b4b8:	2023883a 	mov	r17,r4
   1b4bc:	28004b26 	beq	r5,zero,1b5ec <_free_r+0x148>
   1b4c0:	0020c7c0 	call	20c7c <__malloc_lock>
   1b4c4:	823fff17 	ldw	r8,-4(r16)
   1b4c8:	00bfff84 	movi	r2,-2
   1b4cc:	81bffe04 	addi	r6,r16,-8
   1b4d0:	4084703a 	and	r2,r8,r2
   1b4d4:	3087883a 	add	r3,r6,r2
   1b4d8:	014000f4 	movhi	r5,3
   1b4dc:	294a1804 	addi	r5,r5,10336
   1b4e0:	1a400117 	ldw	r9,4(r3)
   1b4e4:	29000217 	ldw	r4,8(r5)
   1b4e8:	01ffff04 	movi	r7,-4
   1b4ec:	49ce703a 	and	r7,r9,r7
   1b4f0:	20c06526 	beq	r4,r3,1b688 <_free_r+0x1e4>
   1b4f4:	19c00115 	stw	r7,4(r3)
   1b4f8:	4200004c 	andi	r8,r8,1
   1b4fc:	40003026 	beq	r8,zero,1b5c0 <_free_r+0x11c>
   1b500:	0009883a 	mov	r4,zero
   1b504:	19d1883a 	add	r8,r3,r7
   1b508:	42000117 	ldw	r8,4(r8)
   1b50c:	4200004c 	andi	r8,r8,1
   1b510:	4000061e 	bne	r8,zero,1b52c <_free_r+0x88>
   1b514:	11c5883a 	add	r2,r2,r7
   1b518:	19c00217 	ldw	r7,8(r3)
   1b51c:	20004e26 	beq	r4,zero,1b658 <_free_r+0x1b4>
   1b520:	18c00317 	ldw	r3,12(r3)
   1b524:	38c00315 	stw	r3,12(r7)
   1b528:	19c00215 	stw	r7,8(r3)
   1b52c:	11c00054 	ori	r7,r2,1
   1b530:	3087883a 	add	r3,r6,r2
   1b534:	31c00115 	stw	r7,4(r6)
   1b538:	18800015 	stw	r2,0(r3)
   1b53c:	20001a1e 	bne	r4,zero,1b5a8 <_free_r+0x104>
   1b540:	00c07fc4 	movi	r3,511
   1b544:	18802e2e 	bgeu	r3,r2,1b600 <_free_r+0x15c>
   1b548:	1006d27a 	srli	r3,r2,9
   1b54c:	01000104 	movi	r4,4
   1b550:	20c06636 	bltu	r4,r3,1b6ec <_free_r+0x248>
   1b554:	1008d1ba 	srli	r4,r2,6
   1b558:	21000e04 	addi	r4,r4,56
   1b55c:	210f883a 	add	r7,r4,r4
   1b560:	39cf883a 	add	r7,r7,r7
   1b564:	39cf883a 	add	r7,r7,r7
   1b568:	29cf883a 	add	r7,r5,r7
   1b56c:	38c00217 	ldw	r3,8(r7)
   1b570:	014000f4 	movhi	r5,3
   1b574:	294a1804 	addi	r5,r5,10336
   1b578:	19c06126 	beq	r3,r7,1b700 <_free_r+0x25c>
   1b57c:	013fff04 	movi	r4,-4
   1b580:	19400117 	ldw	r5,4(r3)
   1b584:	290a703a 	and	r5,r5,r4
   1b588:	1140022e 	bgeu	r2,r5,1b594 <_free_r+0xf0>
   1b58c:	18c00217 	ldw	r3,8(r3)
   1b590:	38fffb1e 	bne	r7,r3,1b580 <_free_r+0xdc>
   1b594:	18800317 	ldw	r2,12(r3)
   1b598:	30800315 	stw	r2,12(r6)
   1b59c:	30c00215 	stw	r3,8(r6)
   1b5a0:	11800215 	stw	r6,8(r2)
   1b5a4:	19800315 	stw	r6,12(r3)
   1b5a8:	8809883a 	mov	r4,r17
   1b5ac:	dfc00217 	ldw	ra,8(sp)
   1b5b0:	dc400117 	ldw	r17,4(sp)
   1b5b4:	dc000017 	ldw	r16,0(sp)
   1b5b8:	dec00304 	addi	sp,sp,12
   1b5bc:	0020c9c1 	jmpi	20c9c <__malloc_unlock>
   1b5c0:	813ffe17 	ldw	r4,-8(r16)
   1b5c4:	2a400204 	addi	r9,r5,8
   1b5c8:	310dc83a 	sub	r6,r6,r4
   1b5cc:	32000217 	ldw	r8,8(r6)
   1b5d0:	1105883a 	add	r2,r2,r4
   1b5d4:	42404326 	beq	r8,r9,1b6e4 <_free_r+0x240>
   1b5d8:	32400317 	ldw	r9,12(r6)
   1b5dc:	0009883a 	mov	r4,zero
   1b5e0:	42400315 	stw	r9,12(r8)
   1b5e4:	4a000215 	stw	r8,8(r9)
   1b5e8:	003fc606 	br	1b504 <_free_r+0x60>
   1b5ec:	dfc00217 	ldw	ra,8(sp)
   1b5f0:	dc400117 	ldw	r17,4(sp)
   1b5f4:	dc000017 	ldw	r16,0(sp)
   1b5f8:	dec00304 	addi	sp,sp,12
   1b5fc:	f800283a 	ret
   1b600:	1004d0fa 	srli	r2,r2,3
   1b604:	02000044 	movi	r8,1
   1b608:	29c00117 	ldw	r7,4(r5)
   1b60c:	1087883a 	add	r3,r2,r2
   1b610:	18c7883a 	add	r3,r3,r3
   1b614:	1005d0ba 	srai	r2,r2,2
   1b618:	18c7883a 	add	r3,r3,r3
   1b61c:	28c7883a 	add	r3,r5,r3
   1b620:	19000217 	ldw	r4,8(r3)
   1b624:	4084983a 	sll	r2,r8,r2
   1b628:	30c00315 	stw	r3,12(r6)
   1b62c:	31000215 	stw	r4,8(r6)
   1b630:	11c4b03a 	or	r2,r2,r7
   1b634:	21800315 	stw	r6,12(r4)
   1b638:	8809883a 	mov	r4,r17
   1b63c:	28800115 	stw	r2,4(r5)
   1b640:	19800215 	stw	r6,8(r3)
   1b644:	dfc00217 	ldw	ra,8(sp)
   1b648:	dc400117 	ldw	r17,4(sp)
   1b64c:	dc000017 	ldw	r16,0(sp)
   1b650:	dec00304 	addi	sp,sp,12
   1b654:	0020c9c1 	jmpi	20c9c <__malloc_unlock>
   1b658:	020000f4 	movhi	r8,3
   1b65c:	420a1a04 	addi	r8,r8,10344
   1b660:	3a3faf1e 	bne	r7,r8,1b520 <_free_r+0x7c>
   1b664:	29800515 	stw	r6,20(r5)
   1b668:	29800415 	stw	r6,16(r5)
   1b66c:	11000054 	ori	r4,r2,1
   1b670:	3087883a 	add	r3,r6,r2
   1b674:	31c00315 	stw	r7,12(r6)
   1b678:	31c00215 	stw	r7,8(r6)
   1b67c:	31000115 	stw	r4,4(r6)
   1b680:	18800015 	stw	r2,0(r3)
   1b684:	003fc806 	br	1b5a8 <_free_r+0x104>
   1b688:	4200004c 	andi	r8,r8,1
   1b68c:	3885883a 	add	r2,r7,r2
   1b690:	4000071e 	bne	r8,zero,1b6b0 <_free_r+0x20c>
   1b694:	81fffe17 	ldw	r7,-8(r16)
   1b698:	31cdc83a 	sub	r6,r6,r7
   1b69c:	30c00317 	ldw	r3,12(r6)
   1b6a0:	31000217 	ldw	r4,8(r6)
   1b6a4:	11c5883a 	add	r2,r2,r7
   1b6a8:	20c00315 	stw	r3,12(r4)
   1b6ac:	19000215 	stw	r4,8(r3)
   1b6b0:	00c000f4 	movhi	r3,3
   1b6b4:	18d0fa04 	addi	r3,r3,17384
   1b6b8:	18c00017 	ldw	r3,0(r3)
   1b6bc:	11000054 	ori	r4,r2,1
   1b6c0:	31000115 	stw	r4,4(r6)
   1b6c4:	29800215 	stw	r6,8(r5)
   1b6c8:	10ffb736 	bltu	r2,r3,1b5a8 <_free_r+0x104>
   1b6cc:	008000f4 	movhi	r2,3
   1b6d0:	1099dc04 	addi	r2,r2,26480
   1b6d4:	11400017 	ldw	r5,0(r2)
   1b6d8:	8809883a 	mov	r4,r17
   1b6dc:	001b3680 	call	1b368 <_malloc_trim_r>
   1b6e0:	003fb106 	br	1b5a8 <_free_r+0x104>
   1b6e4:	01000044 	movi	r4,1
   1b6e8:	003f8606 	br	1b504 <_free_r+0x60>
   1b6ec:	01000504 	movi	r4,20
   1b6f0:	20c00b36 	bltu	r4,r3,1b720 <_free_r+0x27c>
   1b6f4:	190016c4 	addi	r4,r3,91
   1b6f8:	210f883a 	add	r7,r4,r4
   1b6fc:	003f9806 	br	1b560 <_free_r+0xbc>
   1b700:	2009d0ba 	srai	r4,r4,2
   1b704:	00800044 	movi	r2,1
   1b708:	29c00117 	ldw	r7,4(r5)
   1b70c:	1108983a 	sll	r4,r2,r4
   1b710:	1805883a 	mov	r2,r3
   1b714:	21c8b03a 	or	r4,r4,r7
   1b718:	29000115 	stw	r4,4(r5)
   1b71c:	003f9e06 	br	1b598 <_free_r+0xf4>
   1b720:	01001504 	movi	r4,84
   1b724:	20c00436 	bltu	r4,r3,1b738 <_free_r+0x294>
   1b728:	1008d33a 	srli	r4,r2,12
   1b72c:	21001b84 	addi	r4,r4,110
   1b730:	210f883a 	add	r7,r4,r4
   1b734:	003f8a06 	br	1b560 <_free_r+0xbc>
   1b738:	01005504 	movi	r4,340
   1b73c:	20c00436 	bltu	r4,r3,1b750 <_free_r+0x2ac>
   1b740:	1008d3fa 	srli	r4,r2,15
   1b744:	21001dc4 	addi	r4,r4,119
   1b748:	210f883a 	add	r7,r4,r4
   1b74c:	003f8406 	br	1b560 <_free_r+0xbc>
   1b750:	01015504 	movi	r4,1364
   1b754:	20c00436 	bltu	r4,r3,1b768 <_free_r+0x2c4>
   1b758:	1008d4ba 	srli	r4,r2,18
   1b75c:	21001f04 	addi	r4,r4,124
   1b760:	210f883a 	add	r7,r4,r4
   1b764:	003f7e06 	br	1b560 <_free_r+0xbc>
   1b768:	01c03f04 	movi	r7,252
   1b76c:	01001f84 	movi	r4,126
   1b770:	003f7b06 	br	1b560 <_free_r+0xbc>

0001b774 <__sfvwrite_r>:
   1b774:	30800217 	ldw	r2,8(r6)
   1b778:	defff504 	addi	sp,sp,-44
   1b77c:	dd400615 	stw	r21,24(sp)
   1b780:	dd000515 	stw	r20,20(sp)
   1b784:	dc000115 	stw	r16,4(sp)
   1b788:	dfc00a15 	stw	ra,40(sp)
   1b78c:	df000915 	stw	fp,36(sp)
   1b790:	ddc00815 	stw	r23,32(sp)
   1b794:	dd800715 	stw	r22,28(sp)
   1b798:	dcc00415 	stw	r19,16(sp)
   1b79c:	dc800315 	stw	r18,12(sp)
   1b7a0:	dc400215 	stw	r17,8(sp)
   1b7a4:	3029883a 	mov	r20,r6
   1b7a8:	202b883a 	mov	r21,r4
   1b7ac:	2821883a 	mov	r16,r5
   1b7b0:	10002126 	beq	r2,zero,1b838 <__sfvwrite_r+0xc4>
   1b7b4:	2880030b 	ldhu	r2,12(r5)
   1b7b8:	10c0020c 	andi	r3,r2,8
   1b7bc:	18ffffcc 	andi	r3,r3,65535
   1b7c0:	18e0001c 	xori	r3,r3,32768
   1b7c4:	18e00004 	addi	r3,r3,-32768
   1b7c8:	18002826 	beq	r3,zero,1b86c <__sfvwrite_r+0xf8>
   1b7cc:	28c00417 	ldw	r3,16(r5)
   1b7d0:	18002626 	beq	r3,zero,1b86c <__sfvwrite_r+0xf8>
   1b7d4:	10c0008c 	andi	r3,r2,2
   1b7d8:	18ffffcc 	andi	r3,r3,65535
   1b7dc:	18e0001c 	xori	r3,r3,32768
   1b7e0:	18e00004 	addi	r3,r3,-32768
   1b7e4:	a4400017 	ldw	r17,0(r20)
   1b7e8:	18002b26 	beq	r3,zero,1b898 <__sfvwrite_r+0x124>
   1b7ec:	0027883a 	mov	r19,zero
   1b7f0:	0025883a 	mov	r18,zero
   1b7f4:	05810004 	movi	r22,1024
   1b7f8:	980d883a 	mov	r6,r19
   1b7fc:	a809883a 	mov	r4,r21
   1b800:	90004f26 	beq	r18,zero,1b940 <__sfvwrite_r+0x1cc>
   1b804:	900f883a 	mov	r7,r18
   1b808:	81400717 	ldw	r5,28(r16)
   1b80c:	b480012e 	bgeu	r22,r18,1b814 <__sfvwrite_r+0xa0>
   1b810:	01c10004 	movi	r7,1024
   1b814:	80800917 	ldw	r2,36(r16)
   1b818:	103ee83a 	callr	r2
   1b81c:	0080540e 	bge	zero,r2,1b970 <__sfvwrite_r+0x1fc>
   1b820:	a0c00217 	ldw	r3,8(r20)
   1b824:	98a7883a 	add	r19,r19,r2
   1b828:	90a5c83a 	sub	r18,r18,r2
   1b82c:	1885c83a 	sub	r2,r3,r2
   1b830:	a0800215 	stw	r2,8(r20)
   1b834:	103ff01e 	bne	r2,zero,1b7f8 <__sfvwrite_r+0x84>
   1b838:	0005883a 	mov	r2,zero
   1b83c:	dfc00a17 	ldw	ra,40(sp)
   1b840:	df000917 	ldw	fp,36(sp)
   1b844:	ddc00817 	ldw	r23,32(sp)
   1b848:	dd800717 	ldw	r22,28(sp)
   1b84c:	dd400617 	ldw	r21,24(sp)
   1b850:	dd000517 	ldw	r20,20(sp)
   1b854:	dcc00417 	ldw	r19,16(sp)
   1b858:	dc800317 	ldw	r18,12(sp)
   1b85c:	dc400217 	ldw	r17,8(sp)
   1b860:	dc000117 	ldw	r16,4(sp)
   1b864:	dec00b04 	addi	sp,sp,44
   1b868:	f800283a 	ret
   1b86c:	a809883a 	mov	r4,r21
   1b870:	800b883a 	mov	r5,r16
   1b874:	00194e00 	call	194e0 <__swsetup_r>
   1b878:	1000f01e 	bne	r2,zero,1bc3c <__sfvwrite_r+0x4c8>
   1b87c:	8080030b 	ldhu	r2,12(r16)
   1b880:	a4400017 	ldw	r17,0(r20)
   1b884:	10c0008c 	andi	r3,r2,2
   1b888:	18ffffcc 	andi	r3,r3,65535
   1b88c:	18e0001c 	xori	r3,r3,32768
   1b890:	18e00004 	addi	r3,r3,-32768
   1b894:	183fd51e 	bne	r3,zero,1b7ec <__sfvwrite_r+0x78>
   1b898:	10c0004c 	andi	r3,r2,1
   1b89c:	002d883a 	mov	r22,zero
   1b8a0:	1800381e 	bne	r3,zero,1b984 <__sfvwrite_r+0x210>
   1b8a4:	0025883a 	mov	r18,zero
   1b8a8:	90002126 	beq	r18,zero,1b930 <__sfvwrite_r+0x1bc>
   1b8ac:	10c0800c 	andi	r3,r2,512
   1b8b0:	18ffffcc 	andi	r3,r3,65535
   1b8b4:	18e0001c 	xori	r3,r3,32768
   1b8b8:	18e00004 	addi	r3,r3,-32768
   1b8bc:	84c00217 	ldw	r19,8(r16)
   1b8c0:	18006b26 	beq	r3,zero,1ba70 <__sfvwrite_r+0x2fc>
   1b8c4:	980f883a 	mov	r7,r19
   1b8c8:	94c08636 	bltu	r18,r19,1bae4 <__sfvwrite_r+0x370>
   1b8cc:	10c1200c 	andi	r3,r2,1152
   1b8d0:	18009f1e 	bne	r3,zero,1bb50 <__sfvwrite_r+0x3dc>
   1b8d4:	81000017 	ldw	r4,0(r16)
   1b8d8:	982f883a 	mov	r23,r19
   1b8dc:	9039883a 	mov	fp,r18
   1b8e0:	9027883a 	mov	r19,r18
   1b8e4:	380d883a 	mov	r6,r7
   1b8e8:	b00b883a 	mov	r5,r22
   1b8ec:	d9c00015 	stw	r7,0(sp)
   1b8f0:	001c8b80 	call	1c8b8 <memmove>
   1b8f4:	d9c00017 	ldw	r7,0(sp)
   1b8f8:	81000217 	ldw	r4,8(r16)
   1b8fc:	80800017 	ldw	r2,0(r16)
   1b900:	25efc83a 	sub	r23,r4,r23
   1b904:	11cf883a 	add	r7,r2,r7
   1b908:	85c00215 	stw	r23,8(r16)
   1b90c:	81c00015 	stw	r7,0(r16)
   1b910:	a0800217 	ldw	r2,8(r20)
   1b914:	b72d883a 	add	r22,r22,fp
   1b918:	9725c83a 	sub	r18,r18,fp
   1b91c:	14e7c83a 	sub	r19,r2,r19
   1b920:	a4c00215 	stw	r19,8(r20)
   1b924:	983fc426 	beq	r19,zero,1b838 <__sfvwrite_r+0xc4>
   1b928:	8080030b 	ldhu	r2,12(r16)
   1b92c:	903fdf1e 	bne	r18,zero,1b8ac <__sfvwrite_r+0x138>
   1b930:	8d800017 	ldw	r22,0(r17)
   1b934:	8c800117 	ldw	r18,4(r17)
   1b938:	8c400204 	addi	r17,r17,8
   1b93c:	003fda06 	br	1b8a8 <__sfvwrite_r+0x134>
   1b940:	8cc00017 	ldw	r19,0(r17)
   1b944:	8c800117 	ldw	r18,4(r17)
   1b948:	8c400204 	addi	r17,r17,8
   1b94c:	003faa06 	br	1b7f8 <__sfvwrite_r+0x84>
   1b950:	001d9880 	call	1d988 <_realloc_r>
   1b954:	102f883a 	mov	r23,r2
   1b958:	10009f1e 	bne	r2,zero,1bbd8 <__sfvwrite_r+0x464>
   1b95c:	81400417 	ldw	r5,16(r16)
   1b960:	a809883a 	mov	r4,r21
   1b964:	001b4a40 	call	1b4a4 <_free_r>
   1b968:	00800304 	movi	r2,12
   1b96c:	a8800015 	stw	r2,0(r21)
   1b970:	80c0030b 	ldhu	r3,12(r16)
   1b974:	00bfffc4 	movi	r2,-1
   1b978:	18c01014 	ori	r3,r3,64
   1b97c:	80c0030d 	sth	r3,12(r16)
   1b980:	003fae06 	br	1b83c <__sfvwrite_r+0xc8>
   1b984:	0007883a 	mov	r3,zero
   1b988:	0039883a 	mov	fp,zero
   1b98c:	0025883a 	mov	r18,zero
   1b990:	90001e26 	beq	r18,zero,1ba0c <__sfvwrite_r+0x298>
   1b994:	18006526 	beq	r3,zero,1bb2c <__sfvwrite_r+0x3b8>
   1b998:	b02f883a 	mov	r23,r22
   1b99c:	9580012e 	bgeu	r18,r22,1b9a4 <__sfvwrite_r+0x230>
   1b9a0:	902f883a 	mov	r23,r18
   1b9a4:	81000017 	ldw	r4,0(r16)
   1b9a8:	80800417 	ldw	r2,16(r16)
   1b9ac:	84c00217 	ldw	r19,8(r16)
   1b9b0:	81c00517 	ldw	r7,20(r16)
   1b9b4:	1100022e 	bgeu	r2,r4,1b9c0 <__sfvwrite_r+0x24c>
   1b9b8:	99e7883a 	add	r19,r19,r7
   1b9bc:	9dc01816 	blt	r19,r23,1ba20 <__sfvwrite_r+0x2ac>
   1b9c0:	b9c03b16 	blt	r23,r7,1bab0 <__sfvwrite_r+0x33c>
   1b9c4:	80800917 	ldw	r2,36(r16)
   1b9c8:	81400717 	ldw	r5,28(r16)
   1b9cc:	a809883a 	mov	r4,r21
   1b9d0:	d8c00015 	stw	r3,0(sp)
   1b9d4:	e00d883a 	mov	r6,fp
   1b9d8:	103ee83a 	callr	r2
   1b9dc:	1027883a 	mov	r19,r2
   1b9e0:	d8c00017 	ldw	r3,0(sp)
   1b9e4:	00bfe20e 	bge	zero,r2,1b970 <__sfvwrite_r+0x1fc>
   1b9e8:	b4edc83a 	sub	r22,r22,r19
   1b9ec:	b0001a26 	beq	r22,zero,1ba58 <__sfvwrite_r+0x2e4>
   1b9f0:	a0800217 	ldw	r2,8(r20)
   1b9f4:	e4f9883a 	add	fp,fp,r19
   1b9f8:	94e5c83a 	sub	r18,r18,r19
   1b9fc:	14e7c83a 	sub	r19,r2,r19
   1ba00:	a4c00215 	stw	r19,8(r20)
   1ba04:	983f8c26 	beq	r19,zero,1b838 <__sfvwrite_r+0xc4>
   1ba08:	903fe21e 	bne	r18,zero,1b994 <__sfvwrite_r+0x220>
   1ba0c:	8f000017 	ldw	fp,0(r17)
   1ba10:	8c800117 	ldw	r18,4(r17)
   1ba14:	0007883a 	mov	r3,zero
   1ba18:	8c400204 	addi	r17,r17,8
   1ba1c:	003fdc06 	br	1b990 <__sfvwrite_r+0x21c>
   1ba20:	e00b883a 	mov	r5,fp
   1ba24:	980d883a 	mov	r6,r19
   1ba28:	d8c00015 	stw	r3,0(sp)
   1ba2c:	001c8b80 	call	1c8b8 <memmove>
   1ba30:	80800017 	ldw	r2,0(r16)
   1ba34:	a809883a 	mov	r4,r21
   1ba38:	800b883a 	mov	r5,r16
   1ba3c:	14c5883a 	add	r2,r2,r19
   1ba40:	80800015 	stw	r2,0(r16)
   1ba44:	001ae780 	call	1ae78 <_fflush_r>
   1ba48:	d8c00017 	ldw	r3,0(sp)
   1ba4c:	103fc81e 	bne	r2,zero,1b970 <__sfvwrite_r+0x1fc>
   1ba50:	b4edc83a 	sub	r22,r22,r19
   1ba54:	b03fe61e 	bne	r22,zero,1b9f0 <__sfvwrite_r+0x27c>
   1ba58:	a809883a 	mov	r4,r21
   1ba5c:	800b883a 	mov	r5,r16
   1ba60:	001ae780 	call	1ae78 <_fflush_r>
   1ba64:	103fc21e 	bne	r2,zero,1b970 <__sfvwrite_r+0x1fc>
   1ba68:	0007883a 	mov	r3,zero
   1ba6c:	003fe006 	br	1b9f0 <__sfvwrite_r+0x27c>
   1ba70:	81000017 	ldw	r4,0(r16)
   1ba74:	80800417 	ldw	r2,16(r16)
   1ba78:	1100022e 	bgeu	r2,r4,1ba84 <__sfvwrite_r+0x310>
   1ba7c:	9839883a 	mov	fp,r19
   1ba80:	9c806036 	bltu	r19,r18,1bc04 <__sfvwrite_r+0x490>
   1ba84:	81c00517 	ldw	r7,20(r16)
   1ba88:	91c01c36 	bltu	r18,r7,1bafc <__sfvwrite_r+0x388>
   1ba8c:	80800917 	ldw	r2,36(r16)
   1ba90:	81400717 	ldw	r5,28(r16)
   1ba94:	a809883a 	mov	r4,r21
   1ba98:	b00d883a 	mov	r6,r22
   1ba9c:	103ee83a 	callr	r2
   1baa0:	1027883a 	mov	r19,r2
   1baa4:	00bfb20e 	bge	zero,r2,1b970 <__sfvwrite_r+0x1fc>
   1baa8:	1039883a 	mov	fp,r2
   1baac:	003f9806 	br	1b910 <__sfvwrite_r+0x19c>
   1bab0:	b80d883a 	mov	r6,r23
   1bab4:	e00b883a 	mov	r5,fp
   1bab8:	d8c00015 	stw	r3,0(sp)
   1babc:	001c8b80 	call	1c8b8 <memmove>
   1bac0:	80800217 	ldw	r2,8(r16)
   1bac4:	81000017 	ldw	r4,0(r16)
   1bac8:	b827883a 	mov	r19,r23
   1bacc:	15c5c83a 	sub	r2,r2,r23
   1bad0:	25ef883a 	add	r23,r4,r23
   1bad4:	80800215 	stw	r2,8(r16)
   1bad8:	85c00015 	stw	r23,0(r16)
   1badc:	d8c00017 	ldw	r3,0(sp)
   1bae0:	003fc106 	br	1b9e8 <__sfvwrite_r+0x274>
   1bae4:	81000017 	ldw	r4,0(r16)
   1bae8:	902f883a 	mov	r23,r18
   1baec:	9039883a 	mov	fp,r18
   1baf0:	9027883a 	mov	r19,r18
   1baf4:	900f883a 	mov	r7,r18
   1baf8:	003f7a06 	br	1b8e4 <__sfvwrite_r+0x170>
   1bafc:	b00b883a 	mov	r5,r22
   1bb00:	900d883a 	mov	r6,r18
   1bb04:	001c8b80 	call	1c8b8 <memmove>
   1bb08:	80c00217 	ldw	r3,8(r16)
   1bb0c:	80800017 	ldw	r2,0(r16)
   1bb10:	9027883a 	mov	r19,r18
   1bb14:	1c87c83a 	sub	r3,r3,r18
   1bb18:	1485883a 	add	r2,r2,r18
   1bb1c:	80c00215 	stw	r3,8(r16)
   1bb20:	80800015 	stw	r2,0(r16)
   1bb24:	9039883a 	mov	fp,r18
   1bb28:	003f7906 	br	1b910 <__sfvwrite_r+0x19c>
   1bb2c:	e009883a 	mov	r4,fp
   1bb30:	01400284 	movi	r5,10
   1bb34:	900d883a 	mov	r6,r18
   1bb38:	001c7c00 	call	1c7c0 <memchr>
   1bb3c:	10003c26 	beq	r2,zero,1bc30 <__sfvwrite_r+0x4bc>
   1bb40:	15800044 	addi	r22,r2,1
   1bb44:	b72dc83a 	sub	r22,r22,fp
   1bb48:	00c00044 	movi	r3,1
   1bb4c:	003f9206 	br	1b998 <__sfvwrite_r+0x224>
   1bb50:	81000517 	ldw	r4,20(r16)
   1bb54:	81400417 	ldw	r5,16(r16)
   1bb58:	80c00017 	ldw	r3,0(r16)
   1bb5c:	210d883a 	add	r6,r4,r4
   1bb60:	3109883a 	add	r4,r6,r4
   1bb64:	2026d7fa 	srli	r19,r4,31
   1bb68:	1979c83a 	sub	fp,r3,r5
   1bb6c:	e1800044 	addi	r6,fp,1
   1bb70:	9909883a 	add	r4,r19,r4
   1bb74:	2027d07a 	srai	r19,r4,1
   1bb78:	3489883a 	add	r4,r6,r18
   1bb7c:	980d883a 	mov	r6,r19
   1bb80:	9900022e 	bgeu	r19,r4,1bb8c <__sfvwrite_r+0x418>
   1bb84:	2027883a 	mov	r19,r4
   1bb88:	200d883a 	mov	r6,r4
   1bb8c:	1081000c 	andi	r2,r2,1024
   1bb90:	10bfffcc 	andi	r2,r2,65535
   1bb94:	10a0001c 	xori	r2,r2,32768
   1bb98:	10a00004 	addi	r2,r2,-32768
   1bb9c:	a809883a 	mov	r4,r21
   1bba0:	103f6b26 	beq	r2,zero,1b950 <__sfvwrite_r+0x1dc>
   1bba4:	300b883a 	mov	r5,r6
   1bba8:	001c03c0 	call	1c03c <_malloc_r>
   1bbac:	102f883a 	mov	r23,r2
   1bbb0:	103f6d26 	beq	r2,zero,1b968 <__sfvwrite_r+0x1f4>
   1bbb4:	81400417 	ldw	r5,16(r16)
   1bbb8:	1009883a 	mov	r4,r2
   1bbbc:	e00d883a 	mov	r6,fp
   1bbc0:	0016e680 	call	16e68 <memcpy>
   1bbc4:	8080030b 	ldhu	r2,12(r16)
   1bbc8:	00fedfc4 	movi	r3,-1153
   1bbcc:	10c4703a 	and	r2,r2,r3
   1bbd0:	10802014 	ori	r2,r2,128
   1bbd4:	8080030d 	sth	r2,12(r16)
   1bbd8:	bf09883a 	add	r4,r23,fp
   1bbdc:	9f07c83a 	sub	r3,r19,fp
   1bbe0:	85c00415 	stw	r23,16(r16)
   1bbe4:	84c00515 	stw	r19,20(r16)
   1bbe8:	81000015 	stw	r4,0(r16)
   1bbec:	902f883a 	mov	r23,r18
   1bbf0:	80c00215 	stw	r3,8(r16)
   1bbf4:	9039883a 	mov	fp,r18
   1bbf8:	9027883a 	mov	r19,r18
   1bbfc:	900f883a 	mov	r7,r18
   1bc00:	003f3806 	br	1b8e4 <__sfvwrite_r+0x170>
   1bc04:	b00b883a 	mov	r5,r22
   1bc08:	980d883a 	mov	r6,r19
   1bc0c:	001c8b80 	call	1c8b8 <memmove>
   1bc10:	80800017 	ldw	r2,0(r16)
   1bc14:	a809883a 	mov	r4,r21
   1bc18:	800b883a 	mov	r5,r16
   1bc1c:	14c5883a 	add	r2,r2,r19
   1bc20:	80800015 	stw	r2,0(r16)
   1bc24:	001ae780 	call	1ae78 <_fflush_r>
   1bc28:	103f3926 	beq	r2,zero,1b910 <__sfvwrite_r+0x19c>
   1bc2c:	003f5006 	br	1b970 <__sfvwrite_r+0x1fc>
   1bc30:	95800044 	addi	r22,r18,1
   1bc34:	00c00044 	movi	r3,1
   1bc38:	003f5706 	br	1b998 <__sfvwrite_r+0x224>
   1bc3c:	80c0030b 	ldhu	r3,12(r16)
   1bc40:	00bfffc4 	movi	r2,-1
   1bc44:	18c01014 	ori	r3,r3,64
   1bc48:	80c0030d 	sth	r3,12(r16)
   1bc4c:	00c00244 	movi	r3,9
   1bc50:	a8c00015 	stw	r3,0(r21)
   1bc54:	003ef906 	br	1b83c <__sfvwrite_r+0xc8>

0001bc58 <_fwalk>:
   1bc58:	defff904 	addi	sp,sp,-28
   1bc5c:	dcc00315 	stw	r19,12(sp)
   1bc60:	24c0b804 	addi	r19,r4,736
   1bc64:	dd400515 	stw	r21,20(sp)
   1bc68:	dd000415 	stw	r20,16(sp)
   1bc6c:	dfc00615 	stw	ra,24(sp)
   1bc70:	dc800215 	stw	r18,8(sp)
   1bc74:	dc400115 	stw	r17,4(sp)
   1bc78:	dc000015 	stw	r16,0(sp)
   1bc7c:	282b883a 	mov	r21,r5
   1bc80:	0029883a 	mov	r20,zero
   1bc84:	001b3280 	call	1b328 <__sfp_lock_acquire>
   1bc88:	98001226 	beq	r19,zero,1bcd4 <_fwalk+0x7c>
   1bc8c:	04bfffc4 	movi	r18,-1
   1bc90:	9c400117 	ldw	r17,4(r19)
   1bc94:	9c000217 	ldw	r16,8(r19)
   1bc98:	8c7fffc4 	addi	r17,r17,-1
   1bc9c:	88000b16 	blt	r17,zero,1bccc <_fwalk+0x74>
   1bca0:	84000304 	addi	r16,r16,12
   1bca4:	80c0000f 	ldh	r3,0(r16)
   1bca8:	8c7fffc4 	addi	r17,r17,-1
   1bcac:	813ffd04 	addi	r4,r16,-12
   1bcb0:	18000426 	beq	r3,zero,1bcc4 <_fwalk+0x6c>
   1bcb4:	80c0008f 	ldh	r3,2(r16)
   1bcb8:	1c800226 	beq	r3,r18,1bcc4 <_fwalk+0x6c>
   1bcbc:	a83ee83a 	callr	r21
   1bcc0:	a0a8b03a 	or	r20,r20,r2
   1bcc4:	84001704 	addi	r16,r16,92
   1bcc8:	8cbff61e 	bne	r17,r18,1bca4 <_fwalk+0x4c>
   1bccc:	9cc00017 	ldw	r19,0(r19)
   1bcd0:	983fef1e 	bne	r19,zero,1bc90 <_fwalk+0x38>
   1bcd4:	001b32c0 	call	1b32c <__sfp_lock_release>
   1bcd8:	a005883a 	mov	r2,r20
   1bcdc:	dfc00617 	ldw	ra,24(sp)
   1bce0:	dd400517 	ldw	r21,20(sp)
   1bce4:	dd000417 	ldw	r20,16(sp)
   1bce8:	dcc00317 	ldw	r19,12(sp)
   1bcec:	dc800217 	ldw	r18,8(sp)
   1bcf0:	dc400117 	ldw	r17,4(sp)
   1bcf4:	dc000017 	ldw	r16,0(sp)
   1bcf8:	dec00704 	addi	sp,sp,28
   1bcfc:	f800283a 	ret

0001bd00 <_fwalk_reent>:
   1bd00:	defff804 	addi	sp,sp,-32
   1bd04:	dcc00315 	stw	r19,12(sp)
   1bd08:	24c0b804 	addi	r19,r4,736
   1bd0c:	dd800615 	stw	r22,24(sp)
   1bd10:	dd400515 	stw	r21,20(sp)
   1bd14:	dd000415 	stw	r20,16(sp)
   1bd18:	dfc00715 	stw	ra,28(sp)
   1bd1c:	dc800215 	stw	r18,8(sp)
   1bd20:	dc400115 	stw	r17,4(sp)
   1bd24:	dc000015 	stw	r16,0(sp)
   1bd28:	2029883a 	mov	r20,r4
   1bd2c:	282b883a 	mov	r21,r5
   1bd30:	002d883a 	mov	r22,zero
   1bd34:	001b3280 	call	1b328 <__sfp_lock_acquire>
   1bd38:	98001326 	beq	r19,zero,1bd88 <_fwalk_reent+0x88>
   1bd3c:	04bfffc4 	movi	r18,-1
   1bd40:	9c400117 	ldw	r17,4(r19)
   1bd44:	9c000217 	ldw	r16,8(r19)
   1bd48:	8c7fffc4 	addi	r17,r17,-1
   1bd4c:	88000c16 	blt	r17,zero,1bd80 <_fwalk_reent+0x80>
   1bd50:	84000304 	addi	r16,r16,12
   1bd54:	80c0000f 	ldh	r3,0(r16)
   1bd58:	8c7fffc4 	addi	r17,r17,-1
   1bd5c:	817ffd04 	addi	r5,r16,-12
   1bd60:	18000526 	beq	r3,zero,1bd78 <_fwalk_reent+0x78>
   1bd64:	80c0008f 	ldh	r3,2(r16)
   1bd68:	a009883a 	mov	r4,r20
   1bd6c:	1c800226 	beq	r3,r18,1bd78 <_fwalk_reent+0x78>
   1bd70:	a83ee83a 	callr	r21
   1bd74:	b0acb03a 	or	r22,r22,r2
   1bd78:	84001704 	addi	r16,r16,92
   1bd7c:	8cbff51e 	bne	r17,r18,1bd54 <_fwalk_reent+0x54>
   1bd80:	9cc00017 	ldw	r19,0(r19)
   1bd84:	983fee1e 	bne	r19,zero,1bd40 <_fwalk_reent+0x40>
   1bd88:	001b32c0 	call	1b32c <__sfp_lock_release>
   1bd8c:	b005883a 	mov	r2,r22
   1bd90:	dfc00717 	ldw	ra,28(sp)
   1bd94:	dd800617 	ldw	r22,24(sp)
   1bd98:	dd400517 	ldw	r21,20(sp)
   1bd9c:	dd000417 	ldw	r20,16(sp)
   1bda0:	dcc00317 	ldw	r19,12(sp)
   1bda4:	dc800217 	ldw	r18,8(sp)
   1bda8:	dc400117 	ldw	r17,4(sp)
   1bdac:	dc000017 	ldw	r16,0(sp)
   1bdb0:	dec00804 	addi	sp,sp,32
   1bdb4:	f800283a 	ret

0001bdb8 <_setlocale_r>:
   1bdb8:	defffc04 	addi	sp,sp,-16
   1bdbc:	dc800215 	stw	r18,8(sp)
   1bdc0:	dc400115 	stw	r17,4(sp)
   1bdc4:	dc000015 	stw	r16,0(sp)
   1bdc8:	dfc00315 	stw	ra,12(sp)
   1bdcc:	3021883a 	mov	r16,r6
   1bdd0:	2023883a 	mov	r17,r4
   1bdd4:	2825883a 	mov	r18,r5
   1bdd8:	30001626 	beq	r6,zero,1be34 <_setlocale_r+0x7c>
   1bddc:	3009883a 	mov	r4,r6
   1bde0:	014000f4 	movhi	r5,3
   1bde4:	297fe004 	addi	r5,r5,-128
   1bde8:	001730c0 	call	1730c <strcmp>
   1bdec:	10000a1e 	bne	r2,zero,1be18 <_setlocale_r+0x60>
   1bdf0:	8c800c15 	stw	r18,48(r17)
   1bdf4:	8c000d15 	stw	r16,52(r17)
   1bdf8:	008000f4 	movhi	r2,3
   1bdfc:	10bfe004 	addi	r2,r2,-128
   1be00:	dfc00317 	ldw	ra,12(sp)
   1be04:	dc800217 	ldw	r18,8(sp)
   1be08:	dc400117 	ldw	r17,4(sp)
   1be0c:	dc000017 	ldw	r16,0(sp)
   1be10:	dec00404 	addi	sp,sp,16
   1be14:	f800283a 	ret
   1be18:	8009883a 	mov	r4,r16
   1be1c:	014000f4 	movhi	r5,3
   1be20:	297fea04 	addi	r5,r5,-88
   1be24:	001730c0 	call	1730c <strcmp>
   1be28:	103ff126 	beq	r2,zero,1bdf0 <_setlocale_r+0x38>
   1be2c:	0005883a 	mov	r2,zero
   1be30:	003ff306 	br	1be00 <_setlocale_r+0x48>
   1be34:	008000f4 	movhi	r2,3
   1be38:	10bfe004 	addi	r2,r2,-128
   1be3c:	dfc00317 	ldw	ra,12(sp)
   1be40:	dc800217 	ldw	r18,8(sp)
   1be44:	dc400117 	ldw	r17,4(sp)
   1be48:	dc000017 	ldw	r16,0(sp)
   1be4c:	dec00404 	addi	sp,sp,16
   1be50:	f800283a 	ret

0001be54 <__locale_charset>:
   1be54:	008000f4 	movhi	r2,3
   1be58:	10bfff04 	addi	r2,r2,-4
   1be5c:	f800283a 	ret

0001be60 <_localeconv_r>:
   1be60:	008000f4 	movhi	r2,3
   1be64:	10800304 	addi	r2,r2,12
   1be68:	f800283a 	ret

0001be6c <setlocale>:
   1be6c:	00c000f4 	movhi	r3,3
   1be70:	18d0f704 	addi	r3,r3,17372
   1be74:	2005883a 	mov	r2,r4
   1be78:	19000017 	ldw	r4,0(r3)
   1be7c:	280d883a 	mov	r6,r5
   1be80:	100b883a 	mov	r5,r2
   1be84:	001bdb81 	jmpi	1bdb8 <_setlocale_r>

0001be88 <localeconv>:
   1be88:	008000f4 	movhi	r2,3
   1be8c:	10800304 	addi	r2,r2,12
   1be90:	f800283a 	ret

0001be94 <__smakebuf_r>:
   1be94:	2880030b 	ldhu	r2,12(r5)
   1be98:	deffed04 	addi	sp,sp,-76
   1be9c:	dc401015 	stw	r17,64(sp)
   1bea0:	10c0008c 	andi	r3,r2,2
   1bea4:	18ffffcc 	andi	r3,r3,65535
   1bea8:	18e0001c 	xori	r3,r3,32768
   1beac:	dc000f15 	stw	r16,60(sp)
   1beb0:	dfc01215 	stw	ra,72(sp)
   1beb4:	dc801115 	stw	r18,68(sp)
   1beb8:	18e00004 	addi	r3,r3,-32768
   1bebc:	2821883a 	mov	r16,r5
   1bec0:	2023883a 	mov	r17,r4
   1bec4:	1800381e 	bne	r3,zero,1bfa8 <__smakebuf_r+0x114>
   1bec8:	2940038f 	ldh	r5,14(r5)
   1becc:	28002d16 	blt	r5,zero,1bf84 <__smakebuf_r+0xf0>
   1bed0:	d80d883a 	mov	r6,sp
   1bed4:	001e4680 	call	1e468 <_fstat_r>
   1bed8:	10002916 	blt	r2,zero,1bf80 <__smakebuf_r+0xec>
   1bedc:	d8800117 	ldw	r2,4(sp)
   1bee0:	00e00014 	movui	r3,32768
   1bee4:	10bc000c 	andi	r2,r2,61440
   1bee8:	10c03c26 	beq	r2,r3,1bfdc <__smakebuf_r+0x148>
   1beec:	80c0030b 	ldhu	r3,12(r16)
   1bef0:	18c20014 	ori	r3,r3,2048
   1bef4:	80c0030d 	sth	r3,12(r16)
   1bef8:	00c80004 	movi	r3,8192
   1befc:	10c00c1e 	bne	r2,r3,1bf30 <__smakebuf_r+0x9c>
   1bf00:	8140038f 	ldh	r5,14(r16)
   1bf04:	8809883a 	mov	r4,r17
   1bf08:	001e4d00 	call	1e4d0 <_isatty_r>
   1bf0c:	10000826 	beq	r2,zero,1bf30 <__smakebuf_r+0x9c>
   1bf10:	80c0030b 	ldhu	r3,12(r16)
   1bf14:	808010c4 	addi	r2,r16,67
   1bf18:	80800015 	stw	r2,0(r16)
   1bf1c:	18c00054 	ori	r3,r3,1
   1bf20:	80800415 	stw	r2,16(r16)
   1bf24:	00800044 	movi	r2,1
   1bf28:	80c0030d 	sth	r3,12(r16)
   1bf2c:	80800515 	stw	r2,20(r16)
   1bf30:	04810004 	movi	r18,1024
   1bf34:	8809883a 	mov	r4,r17
   1bf38:	900b883a 	mov	r5,r18
   1bf3c:	001c03c0 	call	1c03c <_malloc_r>
   1bf40:	10003026 	beq	r2,zero,1c004 <__smakebuf_r+0x170>
   1bf44:	80c0030b 	ldhu	r3,12(r16)
   1bf48:	010000b4 	movhi	r4,2
   1bf4c:	212c2804 	addi	r4,r4,-20320
   1bf50:	89000f15 	stw	r4,60(r17)
   1bf54:	18c02014 	ori	r3,r3,128
   1bf58:	80c0030d 	sth	r3,12(r16)
   1bf5c:	80800015 	stw	r2,0(r16)
   1bf60:	80800415 	stw	r2,16(r16)
   1bf64:	84800515 	stw	r18,20(r16)
   1bf68:	dfc01217 	ldw	ra,72(sp)
   1bf6c:	dc801117 	ldw	r18,68(sp)
   1bf70:	dc401017 	ldw	r17,64(sp)
   1bf74:	dc000f17 	ldw	r16,60(sp)
   1bf78:	dec01304 	addi	sp,sp,76
   1bf7c:	f800283a 	ret
   1bf80:	8080030b 	ldhu	r2,12(r16)
   1bf84:	10c0200c 	andi	r3,r2,128
   1bf88:	18ffffcc 	andi	r3,r3,65535
   1bf8c:	18e0001c 	xori	r3,r3,32768
   1bf90:	18e00004 	addi	r3,r3,-32768
   1bf94:	18000f1e 	bne	r3,zero,1bfd4 <__smakebuf_r+0x140>
   1bf98:	04810004 	movi	r18,1024
   1bf9c:	10820014 	ori	r2,r2,2048
   1bfa0:	8080030d 	sth	r2,12(r16)
   1bfa4:	003fe306 	br	1bf34 <__smakebuf_r+0xa0>
   1bfa8:	288010c4 	addi	r2,r5,67
   1bfac:	28800015 	stw	r2,0(r5)
   1bfb0:	28800415 	stw	r2,16(r5)
   1bfb4:	00800044 	movi	r2,1
   1bfb8:	28800515 	stw	r2,20(r5)
   1bfbc:	dfc01217 	ldw	ra,72(sp)
   1bfc0:	dc801117 	ldw	r18,68(sp)
   1bfc4:	dc401017 	ldw	r17,64(sp)
   1bfc8:	dc000f17 	ldw	r16,60(sp)
   1bfcc:	dec01304 	addi	sp,sp,76
   1bfd0:	f800283a 	ret
   1bfd4:	04801004 	movi	r18,64
   1bfd8:	003ff006 	br	1bf9c <__smakebuf_r+0x108>
   1bfdc:	81000a17 	ldw	r4,40(r16)
   1bfe0:	00c000b4 	movhi	r3,2
   1bfe4:	18f84a04 	addi	r3,r3,-7896
   1bfe8:	20ffc01e 	bne	r4,r3,1beec <__smakebuf_r+0x58>
   1bfec:	8080030b 	ldhu	r2,12(r16)
   1bff0:	00c10004 	movi	r3,1024
   1bff4:	80c01315 	stw	r3,76(r16)
   1bff8:	10c4b03a 	or	r2,r2,r3
   1bffc:	8080030d 	sth	r2,12(r16)
   1c000:	003fcb06 	br	1bf30 <__smakebuf_r+0x9c>
   1c004:	8080030b 	ldhu	r2,12(r16)
   1c008:	10c0800c 	andi	r3,r2,512
   1c00c:	18ffffcc 	andi	r3,r3,65535
   1c010:	18e0001c 	xori	r3,r3,32768
   1c014:	18e00004 	addi	r3,r3,-32768
   1c018:	183fd31e 	bne	r3,zero,1bf68 <__smakebuf_r+0xd4>
   1c01c:	10800094 	ori	r2,r2,2
   1c020:	80c010c4 	addi	r3,r16,67
   1c024:	8080030d 	sth	r2,12(r16)
   1c028:	00800044 	movi	r2,1
   1c02c:	80c00015 	stw	r3,0(r16)
   1c030:	80c00415 	stw	r3,16(r16)
   1c034:	80800515 	stw	r2,20(r16)
   1c038:	003fcb06 	br	1bf68 <__smakebuf_r+0xd4>

0001c03c <_malloc_r>:
   1c03c:	defff604 	addi	sp,sp,-40
   1c040:	dc800215 	stw	r18,8(sp)
   1c044:	dfc00915 	stw	ra,36(sp)
   1c048:	df000815 	stw	fp,32(sp)
   1c04c:	ddc00715 	stw	r23,28(sp)
   1c050:	dd800615 	stw	r22,24(sp)
   1c054:	dd400515 	stw	r21,20(sp)
   1c058:	dd000415 	stw	r20,16(sp)
   1c05c:	dcc00315 	stw	r19,12(sp)
   1c060:	dc400115 	stw	r17,4(sp)
   1c064:	dc000015 	stw	r16,0(sp)
   1c068:	288002c4 	addi	r2,r5,11
   1c06c:	00c00584 	movi	r3,22
   1c070:	2025883a 	mov	r18,r4
   1c074:	18802b2e 	bgeu	r3,r2,1c124 <_malloc_r+0xe8>
   1c078:	047ffe04 	movi	r17,-8
   1c07c:	1462703a 	and	r17,r2,r17
   1c080:	88002a16 	blt	r17,zero,1c12c <_malloc_r+0xf0>
   1c084:	89402936 	bltu	r17,r5,1c12c <_malloc_r+0xf0>
   1c088:	9009883a 	mov	r4,r18
   1c08c:	0020c7c0 	call	20c7c <__malloc_lock>
   1c090:	00807dc4 	movi	r2,503
   1c094:	14402936 	bltu	r2,r17,1c13c <_malloc_r+0x100>
   1c098:	8808d0fa 	srli	r4,r17,3
   1c09c:	04c000f4 	movhi	r19,3
   1c0a0:	9cca1804 	addi	r19,r19,10336
   1c0a4:	2105883a 	add	r2,r4,r4
   1c0a8:	1085883a 	add	r2,r2,r2
   1c0ac:	1085883a 	add	r2,r2,r2
   1c0b0:	9885883a 	add	r2,r19,r2
   1c0b4:	14000317 	ldw	r16,12(r2)
   1c0b8:	80815526 	beq	r16,r2,1c610 <_malloc_r+0x5d4>
   1c0bc:	81000117 	ldw	r4,4(r16)
   1c0c0:	00bfff04 	movi	r2,-4
   1c0c4:	80c00317 	ldw	r3,12(r16)
   1c0c8:	2084703a 	and	r2,r4,r2
   1c0cc:	8085883a 	add	r2,r16,r2
   1c0d0:	11800117 	ldw	r6,4(r2)
   1c0d4:	81400217 	ldw	r5,8(r16)
   1c0d8:	9009883a 	mov	r4,r18
   1c0dc:	31800054 	ori	r6,r6,1
   1c0e0:	11800115 	stw	r6,4(r2)
   1c0e4:	28c00315 	stw	r3,12(r5)
   1c0e8:	19400215 	stw	r5,8(r3)
   1c0ec:	0020c9c0 	call	20c9c <__malloc_unlock>
   1c0f0:	80800204 	addi	r2,r16,8
   1c0f4:	dfc00917 	ldw	ra,36(sp)
   1c0f8:	df000817 	ldw	fp,32(sp)
   1c0fc:	ddc00717 	ldw	r23,28(sp)
   1c100:	dd800617 	ldw	r22,24(sp)
   1c104:	dd400517 	ldw	r21,20(sp)
   1c108:	dd000417 	ldw	r20,16(sp)
   1c10c:	dcc00317 	ldw	r19,12(sp)
   1c110:	dc800217 	ldw	r18,8(sp)
   1c114:	dc400117 	ldw	r17,4(sp)
   1c118:	dc000017 	ldw	r16,0(sp)
   1c11c:	dec00a04 	addi	sp,sp,40
   1c120:	f800283a 	ret
   1c124:	04400404 	movi	r17,16
   1c128:	897fd72e 	bgeu	r17,r5,1c088 <_malloc_r+0x4c>
   1c12c:	00800304 	movi	r2,12
   1c130:	90800015 	stw	r2,0(r18)
   1c134:	0005883a 	mov	r2,zero
   1c138:	003fee06 	br	1c0f4 <_malloc_r+0xb8>
   1c13c:	8808d27a 	srli	r4,r17,9
   1c140:	20007126 	beq	r4,zero,1c308 <_malloc_r+0x2cc>
   1c144:	00800104 	movi	r2,4
   1c148:	1100eb36 	bltu	r2,r4,1c4f8 <_malloc_r+0x4bc>
   1c14c:	8808d1ba 	srli	r4,r17,6
   1c150:	21000e04 	addi	r4,r4,56
   1c154:	210b883a 	add	r5,r4,r4
   1c158:	294b883a 	add	r5,r5,r5
   1c15c:	294b883a 	add	r5,r5,r5
   1c160:	04c000f4 	movhi	r19,3
   1c164:	9cca1804 	addi	r19,r19,10336
   1c168:	994b883a 	add	r5,r19,r5
   1c16c:	2c000317 	ldw	r16,12(r5)
   1c170:	2c000e26 	beq	r5,r16,1c1ac <_malloc_r+0x170>
   1c174:	80c00117 	ldw	r3,4(r16)
   1c178:	01ffff04 	movi	r7,-4
   1c17c:	018003c4 	movi	r6,15
   1c180:	19c6703a 	and	r3,r3,r7
   1c184:	1c45c83a 	sub	r2,r3,r17
   1c188:	30800716 	blt	r6,r2,1c1a8 <_malloc_r+0x16c>
   1c18c:	1000610e 	bge	r2,zero,1c314 <_malloc_r+0x2d8>
   1c190:	84000317 	ldw	r16,12(r16)
   1c194:	2c000526 	beq	r5,r16,1c1ac <_malloc_r+0x170>
   1c198:	80c00117 	ldw	r3,4(r16)
   1c19c:	19c6703a 	and	r3,r3,r7
   1c1a0:	1c45c83a 	sub	r2,r3,r17
   1c1a4:	30bff90e 	bge	r6,r2,1c18c <_malloc_r+0x150>
   1c1a8:	213fffc4 	addi	r4,r4,-1
   1c1ac:	21000044 	addi	r4,r4,1
   1c1b0:	9c000417 	ldw	r16,16(r19)
   1c1b4:	00c000f4 	movhi	r3,3
   1c1b8:	18ca1804 	addi	r3,r3,10336
   1c1bc:	1a400204 	addi	r9,r3,8
   1c1c0:	8240ff26 	beq	r16,r9,1c5c0 <_malloc_r+0x584>
   1c1c4:	81400117 	ldw	r5,4(r16)
   1c1c8:	00bfff04 	movi	r2,-4
   1c1cc:	018003c4 	movi	r6,15
   1c1d0:	2884703a 	and	r2,r5,r2
   1c1d4:	144bc83a 	sub	r5,r2,r17
   1c1d8:	3140ea16 	blt	r6,r5,1c584 <_malloc_r+0x548>
   1c1dc:	1a400515 	stw	r9,20(r3)
   1c1e0:	1a400415 	stw	r9,16(r3)
   1c1e4:	2800570e 	bge	r5,zero,1c344 <_malloc_r+0x308>
   1c1e8:	01407fc4 	movi	r5,511
   1c1ec:	2880ca36 	bltu	r5,r2,1c518 <_malloc_r+0x4dc>
   1c1f0:	1004d0fa 	srli	r2,r2,3
   1c1f4:	02000044 	movi	r8,1
   1c1f8:	19c00117 	ldw	r7,4(r3)
   1c1fc:	108b883a 	add	r5,r2,r2
   1c200:	294b883a 	add	r5,r5,r5
   1c204:	1005d0ba 	srai	r2,r2,2
   1c208:	294b883a 	add	r5,r5,r5
   1c20c:	28cb883a 	add	r5,r5,r3
   1c210:	29800217 	ldw	r6,8(r5)
   1c214:	4084983a 	sll	r2,r8,r2
   1c218:	81400315 	stw	r5,12(r16)
   1c21c:	81800215 	stw	r6,8(r16)
   1c220:	11c4b03a 	or	r2,r2,r7
   1c224:	18800115 	stw	r2,4(r3)
   1c228:	2c000215 	stw	r16,8(r5)
   1c22c:	34000315 	stw	r16,12(r6)
   1c230:	200bd0ba 	srai	r5,r4,2
   1c234:	00c00044 	movi	r3,1
   1c238:	194a983a 	sll	r5,r3,r5
   1c23c:	11404936 	bltu	r2,r5,1c364 <_malloc_r+0x328>
   1c240:	1146703a 	and	r3,r2,r5
   1c244:	18000a1e 	bne	r3,zero,1c270 <_malloc_r+0x234>
   1c248:	00ffff04 	movi	r3,-4
   1c24c:	294b883a 	add	r5,r5,r5
   1c250:	20c8703a 	and	r4,r4,r3
   1c254:	1146703a 	and	r3,r2,r5
   1c258:	21000104 	addi	r4,r4,4
   1c25c:	1800041e 	bne	r3,zero,1c270 <_malloc_r+0x234>
   1c260:	294b883a 	add	r5,r5,r5
   1c264:	1146703a 	and	r3,r2,r5
   1c268:	21000104 	addi	r4,r4,4
   1c26c:	183ffc26 	beq	r3,zero,1c260 <_malloc_r+0x224>
   1c270:	023fff04 	movi	r8,-4
   1c274:	01c003c4 	movi	r7,15
   1c278:	2105883a 	add	r2,r4,r4
   1c27c:	1085883a 	add	r2,r2,r2
   1c280:	1085883a 	add	r2,r2,r2
   1c284:	9899883a 	add	r12,r19,r2
   1c288:	62800304 	addi	r10,r12,12
   1c28c:	2017883a 	mov	r11,r4
   1c290:	54000017 	ldw	r16,0(r10)
   1c294:	51bffd04 	addi	r6,r10,-12
   1c298:	8180041e 	bne	r16,r6,1c2ac <_malloc_r+0x270>
   1c29c:	0000ca06 	br	1c5c8 <_malloc_r+0x58c>
   1c2a0:	10001c0e 	bge	r2,zero,1c314 <_malloc_r+0x2d8>
   1c2a4:	84000317 	ldw	r16,12(r16)
   1c2a8:	8180c726 	beq	r16,r6,1c5c8 <_malloc_r+0x58c>
   1c2ac:	80c00117 	ldw	r3,4(r16)
   1c2b0:	1a06703a 	and	r3,r3,r8
   1c2b4:	1c45c83a 	sub	r2,r3,r17
   1c2b8:	38bff90e 	bge	r7,r2,1c2a0 <_malloc_r+0x264>
   1c2bc:	81000317 	ldw	r4,12(r16)
   1c2c0:	81400217 	ldw	r5,8(r16)
   1c2c4:	8447883a 	add	r3,r16,r17
   1c2c8:	8c400054 	ori	r17,r17,1
   1c2cc:	29000315 	stw	r4,12(r5)
   1c2d0:	21400215 	stw	r5,8(r4)
   1c2d4:	84400115 	stw	r17,4(r16)
   1c2d8:	1889883a 	add	r4,r3,r2
   1c2dc:	11400054 	ori	r5,r2,1
   1c2e0:	98c00515 	stw	r3,20(r19)
   1c2e4:	98c00415 	stw	r3,16(r19)
   1c2e8:	20800015 	stw	r2,0(r4)
   1c2ec:	1a400315 	stw	r9,12(r3)
   1c2f0:	1a400215 	stw	r9,8(r3)
   1c2f4:	19400115 	stw	r5,4(r3)
   1c2f8:	9009883a 	mov	r4,r18
   1c2fc:	0020c9c0 	call	20c9c <__malloc_unlock>
   1c300:	80800204 	addi	r2,r16,8
   1c304:	003f7b06 	br	1c0f4 <_malloc_r+0xb8>
   1c308:	8808d0fa 	srli	r4,r17,3
   1c30c:	210b883a 	add	r5,r4,r4
   1c310:	003f9106 	br	1c158 <_malloc_r+0x11c>
   1c314:	80c7883a 	add	r3,r16,r3
   1c318:	19400117 	ldw	r5,4(r3)
   1c31c:	80800317 	ldw	r2,12(r16)
   1c320:	81000217 	ldw	r4,8(r16)
   1c324:	29400054 	ori	r5,r5,1
   1c328:	19400115 	stw	r5,4(r3)
   1c32c:	20800315 	stw	r2,12(r4)
   1c330:	11000215 	stw	r4,8(r2)
   1c334:	9009883a 	mov	r4,r18
   1c338:	0020c9c0 	call	20c9c <__malloc_unlock>
   1c33c:	80800204 	addi	r2,r16,8
   1c340:	003f6c06 	br	1c0f4 <_malloc_r+0xb8>
   1c344:	8085883a 	add	r2,r16,r2
   1c348:	10c00117 	ldw	r3,4(r2)
   1c34c:	9009883a 	mov	r4,r18
   1c350:	18c00054 	ori	r3,r3,1
   1c354:	10c00115 	stw	r3,4(r2)
   1c358:	0020c9c0 	call	20c9c <__malloc_unlock>
   1c35c:	80800204 	addi	r2,r16,8
   1c360:	003f6406 	br	1c0f4 <_malloc_r+0xb8>
   1c364:	9c000217 	ldw	r16,8(r19)
   1c368:	00bfff04 	movi	r2,-4
   1c36c:	85400117 	ldw	r21,4(r16)
   1c370:	a8aa703a 	and	r21,r21,r2
   1c374:	ac400336 	bltu	r21,r17,1c384 <_malloc_r+0x348>
   1c378:	ac45c83a 	sub	r2,r21,r17
   1c37c:	00c003c4 	movi	r3,15
   1c380:	18805316 	blt	r3,r2,1c4d0 <_malloc_r+0x494>
   1c384:	d5e8f017 	ldw	r23,-23616(gp)
   1c388:	d0e00d17 	ldw	r3,-32716(gp)
   1c38c:	00bfffc4 	movi	r2,-1
   1c390:	8579883a 	add	fp,r16,r21
   1c394:	8def883a 	add	r23,r17,r23
   1c398:	1880d226 	beq	r3,r2,1c6e4 <_malloc_r+0x6a8>
   1c39c:	bdc403c4 	addi	r23,r23,4111
   1c3a0:	00bc0004 	movi	r2,-4096
   1c3a4:	b8ae703a 	and	r23,r23,r2
   1c3a8:	9009883a 	mov	r4,r18
   1c3ac:	b80b883a 	mov	r5,r23
   1c3b0:	001dfe80 	call	1dfe8 <_sbrk_r>
   1c3b4:	1029883a 	mov	r20,r2
   1c3b8:	00bfffc4 	movi	r2,-1
   1c3bc:	a080d126 	beq	r20,r2,1c704 <_malloc_r+0x6c8>
   1c3c0:	a7009f36 	bltu	r20,fp,1c640 <_malloc_r+0x604>
   1c3c4:	05800134 	movhi	r22,4
   1c3c8:	b5911704 	addi	r22,r22,17500
   1c3cc:	b0800017 	ldw	r2,0(r22)
   1c3d0:	b885883a 	add	r2,r23,r2
   1c3d4:	b0800015 	stw	r2,0(r22)
   1c3d8:	e500cf26 	beq	fp,r20,1c718 <_malloc_r+0x6dc>
   1c3dc:	d1200d17 	ldw	r4,-32716(gp)
   1c3e0:	00ffffc4 	movi	r3,-1
   1c3e4:	20c0e026 	beq	r4,r3,1c768 <_malloc_r+0x72c>
   1c3e8:	a739c83a 	sub	fp,r20,fp
   1c3ec:	1705883a 	add	r2,r2,fp
   1c3f0:	b0800015 	stw	r2,0(r22)
   1c3f4:	a08001cc 	andi	r2,r20,7
   1c3f8:	1000a526 	beq	r2,zero,1c690 <_malloc_r+0x654>
   1c3fc:	a0a9c83a 	sub	r20,r20,r2
   1c400:	00c40204 	movi	r3,4104
   1c404:	a5000204 	addi	r20,r20,8
   1c408:	1885c83a 	sub	r2,r3,r2
   1c40c:	a5c7883a 	add	r3,r20,r23
   1c410:	18c3ffcc 	andi	r3,r3,4095
   1c414:	10efc83a 	sub	r23,r2,r3
   1c418:	9009883a 	mov	r4,r18
   1c41c:	b80b883a 	mov	r5,r23
   1c420:	001dfe80 	call	1dfe8 <_sbrk_r>
   1c424:	00ffffc4 	movi	r3,-1
   1c428:	10c0cc26 	beq	r2,r3,1c75c <_malloc_r+0x720>
   1c42c:	1505c83a 	sub	r2,r2,r20
   1c430:	b887883a 	add	r3,r23,r2
   1c434:	18c00054 	ori	r3,r3,1
   1c438:	b0800017 	ldw	r2,0(r22)
   1c43c:	9d000215 	stw	r20,8(r19)
   1c440:	a0c00115 	stw	r3,4(r20)
   1c444:	b885883a 	add	r2,r23,r2
   1c448:	b0800015 	stw	r2,0(r22)
   1c44c:	84c00e26 	beq	r16,r19,1c488 <_malloc_r+0x44c>
   1c450:	00c003c4 	movi	r3,15
   1c454:	1d40902e 	bgeu	r3,r21,1c698 <_malloc_r+0x65c>
   1c458:	ad7ffd04 	addi	r21,r21,-12
   1c45c:	013ffe04 	movi	r4,-8
   1c460:	a908703a 	and	r4,r21,r4
   1c464:	810b883a 	add	r5,r16,r4
   1c468:	01800144 	movi	r6,5
   1c46c:	29800115 	stw	r6,4(r5)
   1c470:	29800215 	stw	r6,8(r5)
   1c474:	81400117 	ldw	r5,4(r16)
   1c478:	2940004c 	andi	r5,r5,1
   1c47c:	214ab03a 	or	r5,r4,r5
   1c480:	81400115 	stw	r5,4(r16)
   1c484:	1900ae36 	bltu	r3,r4,1c740 <_malloc_r+0x704>
   1c488:	d0e8ef17 	ldw	r3,-23620(gp)
   1c48c:	1880012e 	bgeu	r3,r2,1c494 <_malloc_r+0x458>
   1c490:	d0a8ef15 	stw	r2,-23620(gp)
   1c494:	d0e8ee17 	ldw	r3,-23624(gp)
   1c498:	9c000217 	ldw	r16,8(r19)
   1c49c:	1880012e 	bgeu	r3,r2,1c4a4 <_malloc_r+0x468>
   1c4a0:	d0a8ee15 	stw	r2,-23624(gp)
   1c4a4:	80c00117 	ldw	r3,4(r16)
   1c4a8:	00bfff04 	movi	r2,-4
   1c4ac:	1886703a 	and	r3,r3,r2
   1c4b0:	1c45c83a 	sub	r2,r3,r17
   1c4b4:	1c400236 	bltu	r3,r17,1c4c0 <_malloc_r+0x484>
   1c4b8:	00c003c4 	movi	r3,15
   1c4bc:	18800416 	blt	r3,r2,1c4d0 <_malloc_r+0x494>
   1c4c0:	9009883a 	mov	r4,r18
   1c4c4:	0020c9c0 	call	20c9c <__malloc_unlock>
   1c4c8:	0005883a 	mov	r2,zero
   1c4cc:	003f0906 	br	1c0f4 <_malloc_r+0xb8>
   1c4d0:	88c00054 	ori	r3,r17,1
   1c4d4:	10800054 	ori	r2,r2,1
   1c4d8:	80c00115 	stw	r3,4(r16)
   1c4dc:	8463883a 	add	r17,r16,r17
   1c4e0:	88800115 	stw	r2,4(r17)
   1c4e4:	9009883a 	mov	r4,r18
   1c4e8:	9c400215 	stw	r17,8(r19)
   1c4ec:	0020c9c0 	call	20c9c <__malloc_unlock>
   1c4f0:	80800204 	addi	r2,r16,8
   1c4f4:	003eff06 	br	1c0f4 <_malloc_r+0xb8>
   1c4f8:	00800504 	movi	r2,20
   1c4fc:	1100492e 	bgeu	r2,r4,1c624 <_malloc_r+0x5e8>
   1c500:	00801504 	movi	r2,84
   1c504:	11005c36 	bltu	r2,r4,1c678 <_malloc_r+0x63c>
   1c508:	8808d33a 	srli	r4,r17,12
   1c50c:	21001b84 	addi	r4,r4,110
   1c510:	210b883a 	add	r5,r4,r4
   1c514:	003f1006 	br	1c158 <_malloc_r+0x11c>
   1c518:	1006d27a 	srli	r3,r2,9
   1c51c:	01400104 	movi	r5,4
   1c520:	28c0432e 	bgeu	r5,r3,1c630 <_malloc_r+0x5f4>
   1c524:	01400504 	movi	r5,20
   1c528:	28c07036 	bltu	r5,r3,1c6ec <_malloc_r+0x6b0>
   1c52c:	194016c4 	addi	r5,r3,91
   1c530:	294d883a 	add	r6,r5,r5
   1c534:	318d883a 	add	r6,r6,r6
   1c538:	318d883a 	add	r6,r6,r6
   1c53c:	998d883a 	add	r6,r19,r6
   1c540:	30c00217 	ldw	r3,8(r6)
   1c544:	01c000f4 	movhi	r7,3
   1c548:	39ca1804 	addi	r7,r7,10336
   1c54c:	19805726 	beq	r3,r6,1c6ac <_malloc_r+0x670>
   1c550:	01ffff04 	movi	r7,-4
   1c554:	19400117 	ldw	r5,4(r3)
   1c558:	29ca703a 	and	r5,r5,r7
   1c55c:	1140022e 	bgeu	r2,r5,1c568 <_malloc_r+0x52c>
   1c560:	18c00217 	ldw	r3,8(r3)
   1c564:	30fffb1e 	bne	r6,r3,1c554 <_malloc_r+0x518>
   1c568:	19400317 	ldw	r5,12(r3)
   1c56c:	98800117 	ldw	r2,4(r19)
   1c570:	81400315 	stw	r5,12(r16)
   1c574:	80c00215 	stw	r3,8(r16)
   1c578:	2c000215 	stw	r16,8(r5)
   1c57c:	1c000315 	stw	r16,12(r3)
   1c580:	003f2b06 	br	1c230 <_malloc_r+0x1f4>
   1c584:	8445883a 	add	r2,r16,r17
   1c588:	8c400054 	ori	r17,r17,1
   1c58c:	18800515 	stw	r2,20(r3)
   1c590:	18800415 	stw	r2,16(r3)
   1c594:	29000054 	ori	r4,r5,1
   1c598:	1147883a 	add	r3,r2,r5
   1c59c:	84400115 	stw	r17,4(r16)
   1c5a0:	11000115 	stw	r4,4(r2)
   1c5a4:	12400315 	stw	r9,12(r2)
   1c5a8:	12400215 	stw	r9,8(r2)
   1c5ac:	19400015 	stw	r5,0(r3)
   1c5b0:	9009883a 	mov	r4,r18
   1c5b4:	0020c9c0 	call	20c9c <__malloc_unlock>
   1c5b8:	80800204 	addi	r2,r16,8
   1c5bc:	003ecd06 	br	1c0f4 <_malloc_r+0xb8>
   1c5c0:	18800117 	ldw	r2,4(r3)
   1c5c4:	003f1a06 	br	1c230 <_malloc_r+0x1f4>
   1c5c8:	5ac00044 	addi	r11,r11,1
   1c5cc:	588000cc 	andi	r2,r11,3
   1c5d0:	52800204 	addi	r10,r10,8
   1c5d4:	103f2e1e 	bne	r2,zero,1c290 <_malloc_r+0x254>
   1c5d8:	20c000cc 	andi	r3,r4,3
   1c5dc:	60bffe04 	addi	r2,r12,-8
   1c5e0:	18006f26 	beq	r3,zero,1c7a0 <_malloc_r+0x764>
   1c5e4:	63000017 	ldw	r12,0(r12)
   1c5e8:	213fffc4 	addi	r4,r4,-1
   1c5ec:	60bffa26 	beq	r12,r2,1c5d8 <_malloc_r+0x59c>
   1c5f0:	98800117 	ldw	r2,4(r19)
   1c5f4:	294b883a 	add	r5,r5,r5
   1c5f8:	117f5a36 	bltu	r2,r5,1c364 <_malloc_r+0x328>
   1c5fc:	283f5926 	beq	r5,zero,1c364 <_malloc_r+0x328>
   1c600:	1146703a 	and	r3,r2,r5
   1c604:	18001626 	beq	r3,zero,1c660 <_malloc_r+0x624>
   1c608:	5809883a 	mov	r4,r11
   1c60c:	003f1a06 	br	1c278 <_malloc_r+0x23c>
   1c610:	80800204 	addi	r2,r16,8
   1c614:	84000517 	ldw	r16,20(r16)
   1c618:	143ea81e 	bne	r2,r16,1c0bc <_malloc_r+0x80>
   1c61c:	21000084 	addi	r4,r4,2
   1c620:	003ee306 	br	1c1b0 <_malloc_r+0x174>
   1c624:	210016c4 	addi	r4,r4,91
   1c628:	210b883a 	add	r5,r4,r4
   1c62c:	003eca06 	br	1c158 <_malloc_r+0x11c>
   1c630:	100ad1ba 	srli	r5,r2,6
   1c634:	29400e04 	addi	r5,r5,56
   1c638:	294d883a 	add	r6,r5,r5
   1c63c:	003fbd06 	br	1c534 <_malloc_r+0x4f8>
   1c640:	84ff6026 	beq	r16,r19,1c3c4 <_malloc_r+0x388>
   1c644:	008000f4 	movhi	r2,3
   1c648:	108a1804 	addi	r2,r2,10336
   1c64c:	14000217 	ldw	r16,8(r2)
   1c650:	00bfff04 	movi	r2,-4
   1c654:	80c00117 	ldw	r3,4(r16)
   1c658:	1886703a 	and	r3,r3,r2
   1c65c:	003f9406 	br	1c4b0 <_malloc_r+0x474>
   1c660:	294b883a 	add	r5,r5,r5
   1c664:	1146703a 	and	r3,r2,r5
   1c668:	5ac00104 	addi	r11,r11,4
   1c66c:	183ffc26 	beq	r3,zero,1c660 <_malloc_r+0x624>
   1c670:	5809883a 	mov	r4,r11
   1c674:	003f0006 	br	1c278 <_malloc_r+0x23c>
   1c678:	00805504 	movi	r2,340
   1c67c:	11001336 	bltu	r2,r4,1c6cc <_malloc_r+0x690>
   1c680:	8808d3fa 	srli	r4,r17,15
   1c684:	21001dc4 	addi	r4,r4,119
   1c688:	210b883a 	add	r5,r4,r4
   1c68c:	003eb206 	br	1c158 <_malloc_r+0x11c>
   1c690:	00840004 	movi	r2,4096
   1c694:	003f5d06 	br	1c40c <_malloc_r+0x3d0>
   1c698:	00800044 	movi	r2,1
   1c69c:	a0800115 	stw	r2,4(r20)
   1c6a0:	a021883a 	mov	r16,r20
   1c6a4:	0007883a 	mov	r3,zero
   1c6a8:	003f8106 	br	1c4b0 <_malloc_r+0x474>
   1c6ac:	280bd0ba 	srai	r5,r5,2
   1c6b0:	01800044 	movi	r6,1
   1c6b4:	38800117 	ldw	r2,4(r7)
   1c6b8:	314c983a 	sll	r6,r6,r5
   1c6bc:	180b883a 	mov	r5,r3
   1c6c0:	3084b03a 	or	r2,r6,r2
   1c6c4:	38800115 	stw	r2,4(r7)
   1c6c8:	003fa906 	br	1c570 <_malloc_r+0x534>
   1c6cc:	00815504 	movi	r2,1364
   1c6d0:	11001836 	bltu	r2,r4,1c734 <_malloc_r+0x6f8>
   1c6d4:	8808d4ba 	srli	r4,r17,18
   1c6d8:	21001f04 	addi	r4,r4,124
   1c6dc:	210b883a 	add	r5,r4,r4
   1c6e0:	003e9d06 	br	1c158 <_malloc_r+0x11c>
   1c6e4:	bdc00404 	addi	r23,r23,16
   1c6e8:	003f2f06 	br	1c3a8 <_malloc_r+0x36c>
   1c6ec:	01401504 	movi	r5,84
   1c6f0:	28c01f36 	bltu	r5,r3,1c770 <_malloc_r+0x734>
   1c6f4:	100ad33a 	srli	r5,r2,12
   1c6f8:	29401b84 	addi	r5,r5,110
   1c6fc:	294d883a 	add	r6,r5,r5
   1c700:	003f8c06 	br	1c534 <_malloc_r+0x4f8>
   1c704:	9c000217 	ldw	r16,8(r19)
   1c708:	00bfff04 	movi	r2,-4
   1c70c:	80c00117 	ldw	r3,4(r16)
   1c710:	1886703a 	and	r3,r3,r2
   1c714:	003f6606 	br	1c4b0 <_malloc_r+0x474>
   1c718:	e0c3ffcc 	andi	r3,fp,4095
   1c71c:	183f2f1e 	bne	r3,zero,1c3dc <_malloc_r+0x3a0>
   1c720:	98c00217 	ldw	r3,8(r19)
   1c724:	bd49883a 	add	r4,r23,r21
   1c728:	21000054 	ori	r4,r4,1
   1c72c:	19000115 	stw	r4,4(r3)
   1c730:	003f5506 	br	1c488 <_malloc_r+0x44c>
   1c734:	01403f04 	movi	r5,252
   1c738:	01001f84 	movi	r4,126
   1c73c:	003e8606 	br	1c158 <_malloc_r+0x11c>
   1c740:	9009883a 	mov	r4,r18
   1c744:	81400204 	addi	r5,r16,8
   1c748:	001b4a40 	call	1b4a4 <_free_r>
   1c74c:	00800134 	movhi	r2,4
   1c750:	10911704 	addi	r2,r2,17500
   1c754:	10800017 	ldw	r2,0(r2)
   1c758:	003f4b06 	br	1c488 <_malloc_r+0x44c>
   1c75c:	00c00044 	movi	r3,1
   1c760:	002f883a 	mov	r23,zero
   1c764:	003f3406 	br	1c438 <_malloc_r+0x3fc>
   1c768:	d5200d15 	stw	r20,-32716(gp)
   1c76c:	003f2106 	br	1c3f4 <_malloc_r+0x3b8>
   1c770:	01405504 	movi	r5,340
   1c774:	28c00436 	bltu	r5,r3,1c788 <_malloc_r+0x74c>
   1c778:	100ad3fa 	srli	r5,r2,15
   1c77c:	29401dc4 	addi	r5,r5,119
   1c780:	294d883a 	add	r6,r5,r5
   1c784:	003f6b06 	br	1c534 <_malloc_r+0x4f8>
   1c788:	01415504 	movi	r5,1364
   1c78c:	28c00936 	bltu	r5,r3,1c7b4 <_malloc_r+0x778>
   1c790:	100ad4ba 	srli	r5,r2,18
   1c794:	29401f04 	addi	r5,r5,124
   1c798:	294d883a 	add	r6,r5,r5
   1c79c:	003f6506 	br	1c534 <_malloc_r+0x4f8>
   1c7a0:	98800117 	ldw	r2,4(r19)
   1c7a4:	0146303a 	nor	r3,zero,r5
   1c7a8:	1884703a 	and	r2,r3,r2
   1c7ac:	98800115 	stw	r2,4(r19)
   1c7b0:	003f9006 	br	1c5f4 <_malloc_r+0x5b8>
   1c7b4:	01803f04 	movi	r6,252
   1c7b8:	01401f84 	movi	r5,126
   1c7bc:	003f5d06 	br	1c534 <_malloc_r+0x4f8>

0001c7c0 <memchr>:
   1c7c0:	008000c4 	movi	r2,3
   1c7c4:	29403fcc 	andi	r5,r5,255
   1c7c8:	1180282e 	bgeu	r2,r6,1c86c <memchr+0xac>
   1c7cc:	2086703a 	and	r3,r4,r2
   1c7d0:	1800351e 	bne	r3,zero,1c8a8 <memchr+0xe8>
   1c7d4:	2816923a 	slli	r11,r5,8
   1c7d8:	2093883a 	add	r9,r4,r2
   1c7dc:	22000084 	addi	r8,r4,2
   1c7e0:	5957883a 	add	r11,r11,r5
   1c7e4:	5816923a 	slli	r11,r11,8
   1c7e8:	20c00044 	addi	r3,r4,1
   1c7ec:	037fbff4 	movhi	r13,65279
   1c7f0:	6b7fbfc4 	addi	r13,r13,-257
   1c7f4:	5957883a 	add	r11,r11,r5
   1c7f8:	5816923a 	slli	r11,r11,8
   1c7fc:	03202074 	movhi	r12,32897
   1c800:	63202004 	addi	r12,r12,-32640
   1c804:	101d883a 	mov	r14,r2
   1c808:	5957883a 	add	r11,r11,r5
   1c80c:	21c00017 	ldw	r7,0(r4)
   1c810:	31bfff04 	addi	r6,r6,-4
   1c814:	1805883a 	mov	r2,r3
   1c818:	3acef03a 	xor	r7,r7,r11
   1c81c:	3b55883a 	add	r10,r7,r13
   1c820:	01ce303a 	nor	r7,zero,r7
   1c824:	51ce703a 	and	r7,r10,r7
   1c828:	3b0e703a 	and	r7,r7,r12
   1c82c:	38000a26 	beq	r7,zero,1c858 <memchr+0x98>
   1c830:	21c00003 	ldbu	r7,0(r4)
   1c834:	39401e26 	beq	r7,r5,1c8b0 <memchr+0xf0>
   1c838:	19c00003 	ldbu	r7,0(r3)
   1c83c:	39401926 	beq	r7,r5,1c8a4 <memchr+0xe4>
   1c840:	41c00003 	ldbu	r7,0(r8)
   1c844:	4005883a 	mov	r2,r8
   1c848:	39401626 	beq	r7,r5,1c8a4 <memchr+0xe4>
   1c84c:	49c00003 	ldbu	r7,0(r9)
   1c850:	4805883a 	mov	r2,r9
   1c854:	39401326 	beq	r7,r5,1c8a4 <memchr+0xe4>
   1c858:	21000104 	addi	r4,r4,4
   1c85c:	4a400104 	addi	r9,r9,4
   1c860:	42000104 	addi	r8,r8,4
   1c864:	18c00104 	addi	r3,r3,4
   1c868:	71bfe836 	bltu	r14,r6,1c80c <memchr+0x4c>
   1c86c:	2005883a 	mov	r2,r4
   1c870:	30000a26 	beq	r6,zero,1c89c <memchr+0xdc>
   1c874:	10c00003 	ldbu	r3,0(r2)
   1c878:	19400a26 	beq	r3,r5,1c8a4 <memchr+0xe4>
   1c87c:	10c00044 	addi	r3,r2,1
   1c880:	118d883a 	add	r6,r2,r6
   1c884:	00000306 	br	1c894 <memchr+0xd4>
   1c888:	11000003 	ldbu	r4,0(r2)
   1c88c:	18c00044 	addi	r3,r3,1
   1c890:	21400426 	beq	r4,r5,1c8a4 <memchr+0xe4>
   1c894:	1805883a 	mov	r2,r3
   1c898:	19bffb1e 	bne	r3,r6,1c888 <memchr+0xc8>
   1c89c:	0005883a 	mov	r2,zero
   1c8a0:	f800283a 	ret
   1c8a4:	f800283a 	ret
   1c8a8:	2005883a 	mov	r2,r4
   1c8ac:	003ff106 	br	1c874 <memchr+0xb4>
   1c8b0:	2005883a 	mov	r2,r4
   1c8b4:	f800283a 	ret

0001c8b8 <memmove>:
   1c8b8:	2005883a 	mov	r2,r4
   1c8bc:	300f883a 	mov	r7,r6
   1c8c0:	29000b2e 	bgeu	r5,r4,1c8f0 <memmove+0x38>
   1c8c4:	2987883a 	add	r3,r5,r6
   1c8c8:	20c0092e 	bgeu	r4,r3,1c8f0 <memmove+0x38>
   1c8cc:	218b883a 	add	r5,r4,r6
   1c8d0:	198fc83a 	sub	r7,r3,r6
   1c8d4:	30003f26 	beq	r6,zero,1c9d4 <memmove+0x11c>
   1c8d8:	18ffffc4 	addi	r3,r3,-1
   1c8dc:	19000003 	ldbu	r4,0(r3)
   1c8e0:	297fffc4 	addi	r5,r5,-1
   1c8e4:	29000005 	stb	r4,0(r5)
   1c8e8:	19fffb1e 	bne	r3,r7,1c8d8 <memmove+0x20>
   1c8ec:	f800283a 	ret
   1c8f0:	00c003c4 	movi	r3,15
   1c8f4:	1980382e 	bgeu	r3,r6,1c9d8 <memmove+0x120>
   1c8f8:	2886b03a 	or	r3,r5,r2
   1c8fc:	18c000cc 	andi	r3,r3,3
   1c900:	1800351e 	bne	r3,zero,1c9d8 <memmove+0x120>
   1c904:	327ffc04 	addi	r9,r6,-16
   1c908:	4812d13a 	srli	r9,r9,4
   1c90c:	12000404 	addi	r8,r2,16
   1c910:	1007883a 	mov	r3,r2
   1c914:	4808913a 	slli	r4,r9,4
   1c918:	280f883a 	mov	r7,r5
   1c91c:	4111883a 	add	r8,r8,r4
   1c920:	39000017 	ldw	r4,0(r7)
   1c924:	18c00404 	addi	r3,r3,16
   1c928:	39c00404 	addi	r7,r7,16
   1c92c:	193ffc15 	stw	r4,-16(r3)
   1c930:	393ffd17 	ldw	r4,-12(r7)
   1c934:	193ffd15 	stw	r4,-12(r3)
   1c938:	393ffe17 	ldw	r4,-8(r7)
   1c93c:	193ffe15 	stw	r4,-8(r3)
   1c940:	393fff17 	ldw	r4,-4(r7)
   1c944:	193fff15 	stw	r4,-4(r3)
   1c948:	1a3ff51e 	bne	r3,r8,1c920 <memmove+0x68>
   1c94c:	49000044 	addi	r4,r9,1
   1c950:	2008913a 	slli	r4,r4,4
   1c954:	31c003cc 	andi	r7,r6,15
   1c958:	1107883a 	add	r3,r2,r4
   1c95c:	290b883a 	add	r5,r5,r4
   1c960:	010000c4 	movi	r4,3
   1c964:	21c0142e 	bgeu	r4,r7,1c9b8 <memmove+0x100>
   1c968:	39ffff04 	addi	r7,r7,-4
   1c96c:	3814d0ba 	srli	r10,r7,2
   1c970:	1a400104 	addi	r9,r3,4
   1c974:	180d883a 	mov	r6,r3
   1c978:	5289883a 	add	r4,r10,r10
   1c97c:	2109883a 	add	r4,r4,r4
   1c980:	4913883a 	add	r9,r9,r4
   1c984:	2809883a 	mov	r4,r5
   1c988:	22000017 	ldw	r8,0(r4)
   1c98c:	31800104 	addi	r6,r6,4
   1c990:	21000104 	addi	r4,r4,4
   1c994:	323fff15 	stw	r8,-4(r6)
   1c998:	327ffb1e 	bne	r6,r9,1c988 <memmove+0xd0>
   1c99c:	51000044 	addi	r4,r10,1
   1c9a0:	52bfff24 	muli	r10,r10,-4
   1c9a4:	2109883a 	add	r4,r4,r4
   1c9a8:	2109883a 	add	r4,r4,r4
   1c9ac:	51cf883a 	add	r7,r10,r7
   1c9b0:	290b883a 	add	r5,r5,r4
   1c9b4:	1907883a 	add	r3,r3,r4
   1c9b8:	38000626 	beq	r7,zero,1c9d4 <memmove+0x11c>
   1c9bc:	19cf883a 	add	r7,r3,r7
   1c9c0:	29800003 	ldbu	r6,0(r5)
   1c9c4:	18c00044 	addi	r3,r3,1
   1c9c8:	29400044 	addi	r5,r5,1
   1c9cc:	19bfffc5 	stb	r6,-1(r3)
   1c9d0:	19fffb1e 	bne	r3,r7,1c9c0 <memmove+0x108>
   1c9d4:	f800283a 	ret
   1c9d8:	1007883a 	mov	r3,r2
   1c9dc:	003ff606 	br	1c9b8 <memmove+0x100>

0001c9e0 <_Balloc>:
   1c9e0:	20801317 	ldw	r2,76(r4)
   1c9e4:	defffc04 	addi	sp,sp,-16
   1c9e8:	dc400115 	stw	r17,4(sp)
   1c9ec:	dc000015 	stw	r16,0(sp)
   1c9f0:	dfc00315 	stw	ra,12(sp)
   1c9f4:	dc800215 	stw	r18,8(sp)
   1c9f8:	2023883a 	mov	r17,r4
   1c9fc:	2821883a 	mov	r16,r5
   1ca00:	10000f26 	beq	r2,zero,1ca40 <_Balloc+0x60>
   1ca04:	8407883a 	add	r3,r16,r16
   1ca08:	18c7883a 	add	r3,r3,r3
   1ca0c:	10c7883a 	add	r3,r2,r3
   1ca10:	18800017 	ldw	r2,0(r3)
   1ca14:	10001126 	beq	r2,zero,1ca5c <_Balloc+0x7c>
   1ca18:	11000017 	ldw	r4,0(r2)
   1ca1c:	19000015 	stw	r4,0(r3)
   1ca20:	10000415 	stw	zero,16(r2)
   1ca24:	10000315 	stw	zero,12(r2)
   1ca28:	dfc00317 	ldw	ra,12(sp)
   1ca2c:	dc800217 	ldw	r18,8(sp)
   1ca30:	dc400117 	ldw	r17,4(sp)
   1ca34:	dc000017 	ldw	r16,0(sp)
   1ca38:	dec00404 	addi	sp,sp,16
   1ca3c:	f800283a 	ret
   1ca40:	01400104 	movi	r5,4
   1ca44:	01800404 	movi	r6,16
   1ca48:	001e1f80 	call	1e1f8 <_calloc_r>
   1ca4c:	88801315 	stw	r2,76(r17)
   1ca50:	103fec1e 	bne	r2,zero,1ca04 <_Balloc+0x24>
   1ca54:	0005883a 	mov	r2,zero
   1ca58:	003ff306 	br	1ca28 <_Balloc+0x48>
   1ca5c:	01400044 	movi	r5,1
   1ca60:	2c24983a 	sll	r18,r5,r16
   1ca64:	8809883a 	mov	r4,r17
   1ca68:	91800144 	addi	r6,r18,5
   1ca6c:	318d883a 	add	r6,r6,r6
   1ca70:	318d883a 	add	r6,r6,r6
   1ca74:	001e1f80 	call	1e1f8 <_calloc_r>
   1ca78:	103ff626 	beq	r2,zero,1ca54 <_Balloc+0x74>
   1ca7c:	14000115 	stw	r16,4(r2)
   1ca80:	14800215 	stw	r18,8(r2)
   1ca84:	003fe606 	br	1ca20 <_Balloc+0x40>

0001ca88 <_Bfree>:
   1ca88:	28000826 	beq	r5,zero,1caac <_Bfree+0x24>
   1ca8c:	28c00117 	ldw	r3,4(r5)
   1ca90:	20801317 	ldw	r2,76(r4)
   1ca94:	18c7883a 	add	r3,r3,r3
   1ca98:	18c7883a 	add	r3,r3,r3
   1ca9c:	10c5883a 	add	r2,r2,r3
   1caa0:	10c00017 	ldw	r3,0(r2)
   1caa4:	28c00015 	stw	r3,0(r5)
   1caa8:	11400015 	stw	r5,0(r2)
   1caac:	f800283a 	ret

0001cab0 <__multadd>:
   1cab0:	defffa04 	addi	sp,sp,-24
   1cab4:	dc000115 	stw	r16,4(sp)
   1cab8:	2c000417 	ldw	r16,16(r5)
   1cabc:	dc800315 	stw	r18,12(sp)
   1cac0:	dc400215 	stw	r17,8(sp)
   1cac4:	dfc00515 	stw	ra,20(sp)
   1cac8:	dcc00415 	stw	r19,16(sp)
   1cacc:	2823883a 	mov	r17,r5
   1cad0:	2025883a 	mov	r18,r4
   1cad4:	28c00504 	addi	r3,r5,20
   1cad8:	0011883a 	mov	r8,zero
   1cadc:	1a800017 	ldw	r10,0(r3)
   1cae0:	18c00104 	addi	r3,r3,4
   1cae4:	42000044 	addi	r8,r8,1
   1cae8:	527fffcc 	andi	r9,r10,65535
   1caec:	4993383a 	mul	r9,r9,r6
   1caf0:	5014d43a 	srli	r10,r10,16
   1caf4:	49d3883a 	add	r9,r9,r7
   1caf8:	480ed43a 	srli	r7,r9,16
   1cafc:	5195383a 	mul	r10,r10,r6
   1cb00:	4a7fffcc 	andi	r9,r9,65535
   1cb04:	3a8f883a 	add	r7,r7,r10
   1cb08:	3814943a 	slli	r10,r7,16
   1cb0c:	380ed43a 	srli	r7,r7,16
   1cb10:	5253883a 	add	r9,r10,r9
   1cb14:	1a7fff15 	stw	r9,-4(r3)
   1cb18:	443ff016 	blt	r8,r16,1cadc <__multadd+0x2c>
   1cb1c:	38000926 	beq	r7,zero,1cb44 <__multadd+0x94>
   1cb20:	88800217 	ldw	r2,8(r17)
   1cb24:	80800f0e 	bge	r16,r2,1cb64 <__multadd+0xb4>
   1cb28:	80800144 	addi	r2,r16,5
   1cb2c:	1085883a 	add	r2,r2,r2
   1cb30:	1085883a 	add	r2,r2,r2
   1cb34:	8885883a 	add	r2,r17,r2
   1cb38:	84000044 	addi	r16,r16,1
   1cb3c:	11c00015 	stw	r7,0(r2)
   1cb40:	8c000415 	stw	r16,16(r17)
   1cb44:	8805883a 	mov	r2,r17
   1cb48:	dfc00517 	ldw	ra,20(sp)
   1cb4c:	dcc00417 	ldw	r19,16(sp)
   1cb50:	dc800317 	ldw	r18,12(sp)
   1cb54:	dc400217 	ldw	r17,8(sp)
   1cb58:	dc000117 	ldw	r16,4(sp)
   1cb5c:	dec00604 	addi	sp,sp,24
   1cb60:	f800283a 	ret
   1cb64:	89400117 	ldw	r5,4(r17)
   1cb68:	9009883a 	mov	r4,r18
   1cb6c:	d9c00015 	stw	r7,0(sp)
   1cb70:	29400044 	addi	r5,r5,1
   1cb74:	001c9e00 	call	1c9e0 <_Balloc>
   1cb78:	89800417 	ldw	r6,16(r17)
   1cb7c:	89400304 	addi	r5,r17,12
   1cb80:	11000304 	addi	r4,r2,12
   1cb84:	31800084 	addi	r6,r6,2
   1cb88:	318d883a 	add	r6,r6,r6
   1cb8c:	318d883a 	add	r6,r6,r6
   1cb90:	1027883a 	mov	r19,r2
   1cb94:	0016e680 	call	16e68 <memcpy>
   1cb98:	88c00117 	ldw	r3,4(r17)
   1cb9c:	90801317 	ldw	r2,76(r18)
   1cba0:	d9c00017 	ldw	r7,0(sp)
   1cba4:	18c7883a 	add	r3,r3,r3
   1cba8:	18c7883a 	add	r3,r3,r3
   1cbac:	10c5883a 	add	r2,r2,r3
   1cbb0:	10c00017 	ldw	r3,0(r2)
   1cbb4:	88c00015 	stw	r3,0(r17)
   1cbb8:	14400015 	stw	r17,0(r2)
   1cbbc:	9823883a 	mov	r17,r19
   1cbc0:	003fd906 	br	1cb28 <__multadd+0x78>

0001cbc4 <__s2b>:
   1cbc4:	defff904 	addi	sp,sp,-28
   1cbc8:	dd000415 	stw	r20,16(sp)
   1cbcc:	dc400115 	stw	r17,4(sp)
   1cbd0:	2829883a 	mov	r20,r5
   1cbd4:	2023883a 	mov	r17,r4
   1cbd8:	01400244 	movi	r5,9
   1cbdc:	39000204 	addi	r4,r7,8
   1cbe0:	dcc00315 	stw	r19,12(sp)
   1cbe4:	dc800215 	stw	r18,8(sp)
   1cbe8:	dfc00615 	stw	ra,24(sp)
   1cbec:	dd400515 	stw	r21,20(sp)
   1cbf0:	dc000015 	stw	r16,0(sp)
   1cbf4:	3825883a 	mov	r18,r7
   1cbf8:	3027883a 	mov	r19,r6
   1cbfc:	001ff140 	call	1ff14 <__divsi3>
   1cc00:	00c00044 	movi	r3,1
   1cc04:	000b883a 	mov	r5,zero
   1cc08:	1880030e 	bge	r3,r2,1cc18 <__s2b+0x54>
   1cc0c:	18c7883a 	add	r3,r3,r3
   1cc10:	29400044 	addi	r5,r5,1
   1cc14:	18bffd16 	blt	r3,r2,1cc0c <__s2b+0x48>
   1cc18:	8809883a 	mov	r4,r17
   1cc1c:	001c9e00 	call	1c9e0 <_Balloc>
   1cc20:	d8c00717 	ldw	r3,28(sp)
   1cc24:	10c00515 	stw	r3,20(r2)
   1cc28:	00c00044 	movi	r3,1
   1cc2c:	10c00415 	stw	r3,16(r2)
   1cc30:	00c00244 	movi	r3,9
   1cc34:	1cc0210e 	bge	r3,r19,1ccbc <__s2b+0xf8>
   1cc38:	a0eb883a 	add	r21,r20,r3
   1cc3c:	a821883a 	mov	r16,r21
   1cc40:	a4e9883a 	add	r20,r20,r19
   1cc44:	81c00007 	ldb	r7,0(r16)
   1cc48:	8809883a 	mov	r4,r17
   1cc4c:	84000044 	addi	r16,r16,1
   1cc50:	100b883a 	mov	r5,r2
   1cc54:	01800284 	movi	r6,10
   1cc58:	39fff404 	addi	r7,r7,-48
   1cc5c:	001cab00 	call	1cab0 <__multadd>
   1cc60:	853ff81e 	bne	r16,r20,1cc44 <__s2b+0x80>
   1cc64:	ace1883a 	add	r16,r21,r19
   1cc68:	843ffe04 	addi	r16,r16,-8
   1cc6c:	9c800a0e 	bge	r19,r18,1cc98 <__s2b+0xd4>
   1cc70:	94e5c83a 	sub	r18,r18,r19
   1cc74:	84a5883a 	add	r18,r16,r18
   1cc78:	81c00007 	ldb	r7,0(r16)
   1cc7c:	8809883a 	mov	r4,r17
   1cc80:	84000044 	addi	r16,r16,1
   1cc84:	100b883a 	mov	r5,r2
   1cc88:	01800284 	movi	r6,10
   1cc8c:	39fff404 	addi	r7,r7,-48
   1cc90:	001cab00 	call	1cab0 <__multadd>
   1cc94:	84bff81e 	bne	r16,r18,1cc78 <__s2b+0xb4>
   1cc98:	dfc00617 	ldw	ra,24(sp)
   1cc9c:	dd400517 	ldw	r21,20(sp)
   1cca0:	dd000417 	ldw	r20,16(sp)
   1cca4:	dcc00317 	ldw	r19,12(sp)
   1cca8:	dc800217 	ldw	r18,8(sp)
   1ccac:	dc400117 	ldw	r17,4(sp)
   1ccb0:	dc000017 	ldw	r16,0(sp)
   1ccb4:	dec00704 	addi	sp,sp,28
   1ccb8:	f800283a 	ret
   1ccbc:	a4000284 	addi	r16,r20,10
   1ccc0:	1827883a 	mov	r19,r3
   1ccc4:	003fe906 	br	1cc6c <__s2b+0xa8>

0001ccc8 <__hi0bits>:
   1ccc8:	20bfffec 	andhi	r2,r4,65535
   1cccc:	1000141e 	bne	r2,zero,1cd20 <__hi0bits+0x58>
   1ccd0:	2008943a 	slli	r4,r4,16
   1ccd4:	00800404 	movi	r2,16
   1ccd8:	20ffc02c 	andhi	r3,r4,65280
   1ccdc:	1800021e 	bne	r3,zero,1cce8 <__hi0bits+0x20>
   1cce0:	2008923a 	slli	r4,r4,8
   1cce4:	10800204 	addi	r2,r2,8
   1cce8:	20fc002c 	andhi	r3,r4,61440
   1ccec:	1800021e 	bne	r3,zero,1ccf8 <__hi0bits+0x30>
   1ccf0:	2008913a 	slli	r4,r4,4
   1ccf4:	10800104 	addi	r2,r2,4
   1ccf8:	20f0002c 	andhi	r3,r4,49152
   1ccfc:	1800031e 	bne	r3,zero,1cd0c <__hi0bits+0x44>
   1cd00:	2109883a 	add	r4,r4,r4
   1cd04:	10800084 	addi	r2,r2,2
   1cd08:	2109883a 	add	r4,r4,r4
   1cd0c:	20000316 	blt	r4,zero,1cd1c <__hi0bits+0x54>
   1cd10:	2110002c 	andhi	r4,r4,16384
   1cd14:	2000041e 	bne	r4,zero,1cd28 <__hi0bits+0x60>
   1cd18:	00800804 	movi	r2,32
   1cd1c:	f800283a 	ret
   1cd20:	0005883a 	mov	r2,zero
   1cd24:	003fec06 	br	1ccd8 <__hi0bits+0x10>
   1cd28:	10800044 	addi	r2,r2,1
   1cd2c:	f800283a 	ret

0001cd30 <__lo0bits>:
   1cd30:	20c00017 	ldw	r3,0(r4)
   1cd34:	188001cc 	andi	r2,r3,7
   1cd38:	10000826 	beq	r2,zero,1cd5c <__lo0bits+0x2c>
   1cd3c:	1880004c 	andi	r2,r3,1
   1cd40:	1000211e 	bne	r2,zero,1cdc8 <__lo0bits+0x98>
   1cd44:	1880008c 	andi	r2,r3,2
   1cd48:	1000211e 	bne	r2,zero,1cdd0 <__lo0bits+0xa0>
   1cd4c:	1806d0ba 	srli	r3,r3,2
   1cd50:	00800084 	movi	r2,2
   1cd54:	20c00015 	stw	r3,0(r4)
   1cd58:	f800283a 	ret
   1cd5c:	18bfffcc 	andi	r2,r3,65535
   1cd60:	10001326 	beq	r2,zero,1cdb0 <__lo0bits+0x80>
   1cd64:	0005883a 	mov	r2,zero
   1cd68:	19403fcc 	andi	r5,r3,255
   1cd6c:	2800021e 	bne	r5,zero,1cd78 <__lo0bits+0x48>
   1cd70:	1806d23a 	srli	r3,r3,8
   1cd74:	10800204 	addi	r2,r2,8
   1cd78:	194003cc 	andi	r5,r3,15
   1cd7c:	2800021e 	bne	r5,zero,1cd88 <__lo0bits+0x58>
   1cd80:	1806d13a 	srli	r3,r3,4
   1cd84:	10800104 	addi	r2,r2,4
   1cd88:	194000cc 	andi	r5,r3,3
   1cd8c:	2800021e 	bne	r5,zero,1cd98 <__lo0bits+0x68>
   1cd90:	1806d0ba 	srli	r3,r3,2
   1cd94:	10800084 	addi	r2,r2,2
   1cd98:	1940004c 	andi	r5,r3,1
   1cd9c:	2800081e 	bne	r5,zero,1cdc0 <__lo0bits+0x90>
   1cda0:	1806d07a 	srli	r3,r3,1
   1cda4:	1800051e 	bne	r3,zero,1cdbc <__lo0bits+0x8c>
   1cda8:	00800804 	movi	r2,32
   1cdac:	f800283a 	ret
   1cdb0:	1806d43a 	srli	r3,r3,16
   1cdb4:	00800404 	movi	r2,16
   1cdb8:	003feb06 	br	1cd68 <__lo0bits+0x38>
   1cdbc:	10800044 	addi	r2,r2,1
   1cdc0:	20c00015 	stw	r3,0(r4)
   1cdc4:	f800283a 	ret
   1cdc8:	0005883a 	mov	r2,zero
   1cdcc:	f800283a 	ret
   1cdd0:	1806d07a 	srli	r3,r3,1
   1cdd4:	00800044 	movi	r2,1
   1cdd8:	20c00015 	stw	r3,0(r4)
   1cddc:	f800283a 	ret

0001cde0 <__i2b>:
   1cde0:	defffd04 	addi	sp,sp,-12
   1cde4:	dc000015 	stw	r16,0(sp)
   1cde8:	04000044 	movi	r16,1
   1cdec:	dc400115 	stw	r17,4(sp)
   1cdf0:	2823883a 	mov	r17,r5
   1cdf4:	800b883a 	mov	r5,r16
   1cdf8:	dfc00215 	stw	ra,8(sp)
   1cdfc:	001c9e00 	call	1c9e0 <_Balloc>
   1ce00:	14400515 	stw	r17,20(r2)
   1ce04:	14000415 	stw	r16,16(r2)
   1ce08:	dfc00217 	ldw	ra,8(sp)
   1ce0c:	dc400117 	ldw	r17,4(sp)
   1ce10:	dc000017 	ldw	r16,0(sp)
   1ce14:	dec00304 	addi	sp,sp,12
   1ce18:	f800283a 	ret

0001ce1c <__multiply>:
   1ce1c:	defffa04 	addi	sp,sp,-24
   1ce20:	dcc00315 	stw	r19,12(sp)
   1ce24:	dc400115 	stw	r17,4(sp)
   1ce28:	34c00417 	ldw	r19,16(r6)
   1ce2c:	2c400417 	ldw	r17,16(r5)
   1ce30:	dd000415 	stw	r20,16(sp)
   1ce34:	dc800215 	stw	r18,8(sp)
   1ce38:	dfc00515 	stw	ra,20(sp)
   1ce3c:	dc000015 	stw	r16,0(sp)
   1ce40:	2825883a 	mov	r18,r5
   1ce44:	3029883a 	mov	r20,r6
   1ce48:	8cc0050e 	bge	r17,r19,1ce60 <__multiply+0x44>
   1ce4c:	8807883a 	mov	r3,r17
   1ce50:	3025883a 	mov	r18,r6
   1ce54:	9823883a 	mov	r17,r19
   1ce58:	2829883a 	mov	r20,r5
   1ce5c:	1827883a 	mov	r19,r3
   1ce60:	90800217 	ldw	r2,8(r18)
   1ce64:	8ce1883a 	add	r16,r17,r19
   1ce68:	91400117 	ldw	r5,4(r18)
   1ce6c:	1400010e 	bge	r2,r16,1ce74 <__multiply+0x58>
   1ce70:	29400044 	addi	r5,r5,1
   1ce74:	001c9e00 	call	1c9e0 <_Balloc>
   1ce78:	83c00144 	addi	r15,r16,5
   1ce7c:	7bdf883a 	add	r15,r15,r15
   1ce80:	7bdf883a 	add	r15,r15,r15
   1ce84:	13800504 	addi	r14,r2,20
   1ce88:	13df883a 	add	r15,r2,r15
   1ce8c:	7007883a 	mov	r3,r14
   1ce90:	73c0032e 	bgeu	r14,r15,1cea0 <__multiply+0x84>
   1ce94:	18000015 	stw	zero,0(r3)
   1ce98:	18c00104 	addi	r3,r3,4
   1ce9c:	1bfffd36 	bltu	r3,r15,1ce94 <__multiply+0x78>
   1cea0:	99800144 	addi	r6,r19,5
   1cea4:	8b000144 	addi	r12,r17,5
   1cea8:	318d883a 	add	r6,r6,r6
   1ceac:	6319883a 	add	r12,r12,r12
   1ceb0:	318d883a 	add	r6,r6,r6
   1ceb4:	6319883a 	add	r12,r12,r12
   1ceb8:	a3400504 	addi	r13,r20,20
   1cebc:	a18d883a 	add	r6,r20,r6
   1cec0:	94400504 	addi	r17,r18,20
   1cec4:	9319883a 	add	r12,r18,r12
   1cec8:	6980392e 	bgeu	r13,r6,1cfb0 <__multiply+0x194>
   1cecc:	6a800017 	ldw	r10,0(r13)
   1ced0:	52ffffcc 	andi	r11,r10,65535
   1ced4:	58001826 	beq	r11,zero,1cf38 <__multiply+0x11c>
   1ced8:	7007883a 	mov	r3,r14
   1cedc:	8809883a 	mov	r4,r17
   1cee0:	000b883a 	mov	r5,zero
   1cee4:	22400017 	ldw	r9,0(r4)
   1cee8:	1a000017 	ldw	r8,0(r3)
   1ceec:	21000104 	addi	r4,r4,4
   1cef0:	49ffffcc 	andi	r7,r9,65535
   1cef4:	3acf383a 	mul	r7,r7,r11
   1cef8:	4812d43a 	srli	r9,r9,16
   1cefc:	42bfffcc 	andi	r10,r8,65535
   1cf00:	3a8f883a 	add	r7,r7,r10
   1cf04:	394f883a 	add	r7,r7,r5
   1cf08:	4010d43a 	srli	r8,r8,16
   1cf0c:	4acb383a 	mul	r5,r9,r11
   1cf10:	3814d43a 	srli	r10,r7,16
   1cf14:	19c0000d 	sth	r7,0(r3)
   1cf18:	2a0b883a 	add	r5,r5,r8
   1cf1c:	2a8b883a 	add	r5,r5,r10
   1cf20:	1940008d 	sth	r5,2(r3)
   1cf24:	280ad43a 	srli	r5,r5,16
   1cf28:	18c00104 	addi	r3,r3,4
   1cf2c:	233fed36 	bltu	r4,r12,1cee4 <__multiply+0xc8>
   1cf30:	19400015 	stw	r5,0(r3)
   1cf34:	6a800017 	ldw	r10,0(r13)
   1cf38:	5014d43a 	srli	r10,r10,16
   1cf3c:	50001926 	beq	r10,zero,1cfa4 <__multiply+0x188>
   1cf40:	71400017 	ldw	r5,0(r14)
   1cf44:	7007883a 	mov	r3,r14
   1cf48:	8809883a 	mov	r4,r17
   1cf4c:	280f883a 	mov	r7,r5
   1cf50:	0017883a 	mov	r11,zero
   1cf54:	22400017 	ldw	r9,0(r4)
   1cf58:	380ed43a 	srli	r7,r7,16
   1cf5c:	1940000d 	sth	r5,0(r3)
   1cf60:	4a3fffcc 	andi	r8,r9,65535
   1cf64:	4291383a 	mul	r8,r8,r10
   1cf68:	4812d43a 	srli	r9,r9,16
   1cf6c:	18c00104 	addi	r3,r3,4
   1cf70:	41d1883a 	add	r8,r8,r7
   1cf74:	19c00017 	ldw	r7,0(r3)
   1cf78:	42d1883a 	add	r8,r8,r11
   1cf7c:	4a93383a 	mul	r9,r9,r10
   1cf80:	1a3fff8d 	sth	r8,-2(r3)
   1cf84:	4010d43a 	srli	r8,r8,16
   1cf88:	397fffcc 	andi	r5,r7,65535
   1cf8c:	2a4b883a 	add	r5,r5,r9
   1cf90:	2a0b883a 	add	r5,r5,r8
   1cf94:	21000104 	addi	r4,r4,4
   1cf98:	2816d43a 	srli	r11,r5,16
   1cf9c:	233fed36 	bltu	r4,r12,1cf54 <__multiply+0x138>
   1cfa0:	19400015 	stw	r5,0(r3)
   1cfa4:	6b400104 	addi	r13,r13,4
   1cfa8:	73800104 	addi	r14,r14,4
   1cfac:	69bfc736 	bltu	r13,r6,1cecc <__multiply+0xb0>
   1cfb0:	0400090e 	bge	zero,r16,1cfd8 <__multiply+0x1bc>
   1cfb4:	78ffff17 	ldw	r3,-4(r15)
   1cfb8:	7bffff04 	addi	r15,r15,-4
   1cfbc:	18000326 	beq	r3,zero,1cfcc <__multiply+0x1b0>
   1cfc0:	00000506 	br	1cfd8 <__multiply+0x1bc>
   1cfc4:	78c00017 	ldw	r3,0(r15)
   1cfc8:	1800031e 	bne	r3,zero,1cfd8 <__multiply+0x1bc>
   1cfcc:	843fffc4 	addi	r16,r16,-1
   1cfd0:	7bffff04 	addi	r15,r15,-4
   1cfd4:	803ffb1e 	bne	r16,zero,1cfc4 <__multiply+0x1a8>
   1cfd8:	14000415 	stw	r16,16(r2)
   1cfdc:	dfc00517 	ldw	ra,20(sp)
   1cfe0:	dd000417 	ldw	r20,16(sp)
   1cfe4:	dcc00317 	ldw	r19,12(sp)
   1cfe8:	dc800217 	ldw	r18,8(sp)
   1cfec:	dc400117 	ldw	r17,4(sp)
   1cff0:	dc000017 	ldw	r16,0(sp)
   1cff4:	dec00604 	addi	sp,sp,24
   1cff8:	f800283a 	ret

0001cffc <__pow5mult>:
   1cffc:	defffb04 	addi	sp,sp,-20
   1d000:	dcc00315 	stw	r19,12(sp)
   1d004:	dc800215 	stw	r18,8(sp)
   1d008:	dc000015 	stw	r16,0(sp)
   1d00c:	dfc00415 	stw	ra,16(sp)
   1d010:	dc400115 	stw	r17,4(sp)
   1d014:	308000cc 	andi	r2,r6,3
   1d018:	3021883a 	mov	r16,r6
   1d01c:	2027883a 	mov	r19,r4
   1d020:	2825883a 	mov	r18,r5
   1d024:	10002e1e 	bne	r2,zero,1d0e0 <__pow5mult+0xe4>
   1d028:	8021d0ba 	srai	r16,r16,2
   1d02c:	80001a26 	beq	r16,zero,1d098 <__pow5mult+0x9c>
   1d030:	9c401217 	ldw	r17,72(r19)
   1d034:	8800061e 	bne	r17,zero,1d050 <__pow5mult+0x54>
   1d038:	00003406 	br	1d10c <__pow5mult+0x110>
   1d03c:	8021d07a 	srai	r16,r16,1
   1d040:	80001526 	beq	r16,zero,1d098 <__pow5mult+0x9c>
   1d044:	88c00017 	ldw	r3,0(r17)
   1d048:	18001b26 	beq	r3,zero,1d0b8 <__pow5mult+0xbc>
   1d04c:	1823883a 	mov	r17,r3
   1d050:	80c0004c 	andi	r3,r16,1
   1d054:	183ff926 	beq	r3,zero,1d03c <__pow5mult+0x40>
   1d058:	900b883a 	mov	r5,r18
   1d05c:	880d883a 	mov	r6,r17
   1d060:	9809883a 	mov	r4,r19
   1d064:	001ce1c0 	call	1ce1c <__multiply>
   1d068:	90001b26 	beq	r18,zero,1d0d8 <__pow5mult+0xdc>
   1d06c:	91000117 	ldw	r4,4(r18)
   1d070:	98c01317 	ldw	r3,76(r19)
   1d074:	8021d07a 	srai	r16,r16,1
   1d078:	2109883a 	add	r4,r4,r4
   1d07c:	2109883a 	add	r4,r4,r4
   1d080:	1907883a 	add	r3,r3,r4
   1d084:	19000017 	ldw	r4,0(r3)
   1d088:	91000015 	stw	r4,0(r18)
   1d08c:	1c800015 	stw	r18,0(r3)
   1d090:	1025883a 	mov	r18,r2
   1d094:	803feb1e 	bne	r16,zero,1d044 <__pow5mult+0x48>
   1d098:	9005883a 	mov	r2,r18
   1d09c:	dfc00417 	ldw	ra,16(sp)
   1d0a0:	dcc00317 	ldw	r19,12(sp)
   1d0a4:	dc800217 	ldw	r18,8(sp)
   1d0a8:	dc400117 	ldw	r17,4(sp)
   1d0ac:	dc000017 	ldw	r16,0(sp)
   1d0b0:	dec00504 	addi	sp,sp,20
   1d0b4:	f800283a 	ret
   1d0b8:	880b883a 	mov	r5,r17
   1d0bc:	880d883a 	mov	r6,r17
   1d0c0:	9809883a 	mov	r4,r19
   1d0c4:	001ce1c0 	call	1ce1c <__multiply>
   1d0c8:	88800015 	stw	r2,0(r17)
   1d0cc:	10000015 	stw	zero,0(r2)
   1d0d0:	1023883a 	mov	r17,r2
   1d0d4:	003fde06 	br	1d050 <__pow5mult+0x54>
   1d0d8:	1025883a 	mov	r18,r2
   1d0dc:	003fd706 	br	1d03c <__pow5mult+0x40>
   1d0e0:	10bfffc4 	addi	r2,r2,-1
   1d0e4:	1085883a 	add	r2,r2,r2
   1d0e8:	00c000f4 	movhi	r3,3
   1d0ec:	18c05504 	addi	r3,r3,340
   1d0f0:	1085883a 	add	r2,r2,r2
   1d0f4:	1885883a 	add	r2,r3,r2
   1d0f8:	11800017 	ldw	r6,0(r2)
   1d0fc:	000f883a 	mov	r7,zero
   1d100:	001cab00 	call	1cab0 <__multadd>
   1d104:	1025883a 	mov	r18,r2
   1d108:	003fc706 	br	1d028 <__pow5mult+0x2c>
   1d10c:	9809883a 	mov	r4,r19
   1d110:	01409c44 	movi	r5,625
   1d114:	001cde00 	call	1cde0 <__i2b>
   1d118:	98801215 	stw	r2,72(r19)
   1d11c:	1023883a 	mov	r17,r2
   1d120:	10000015 	stw	zero,0(r2)
   1d124:	003fca06 	br	1d050 <__pow5mult+0x54>

0001d128 <__lshift>:
   1d128:	defff904 	addi	sp,sp,-28
   1d12c:	dd400515 	stw	r21,20(sp)
   1d130:	dc400115 	stw	r17,4(sp)
   1d134:	2d400417 	ldw	r21,16(r5)
   1d138:	3023d17a 	srai	r17,r6,5
   1d13c:	28800217 	ldw	r2,8(r5)
   1d140:	dd000415 	stw	r20,16(sp)
   1d144:	8d6b883a 	add	r21,r17,r21
   1d148:	dcc00315 	stw	r19,12(sp)
   1d14c:	dc800215 	stw	r18,8(sp)
   1d150:	dc000015 	stw	r16,0(sp)
   1d154:	dfc00615 	stw	ra,24(sp)
   1d158:	ac000044 	addi	r16,r21,1
   1d15c:	2825883a 	mov	r18,r5
   1d160:	3029883a 	mov	r20,r6
   1d164:	2027883a 	mov	r19,r4
   1d168:	29400117 	ldw	r5,4(r5)
   1d16c:	1400030e 	bge	r2,r16,1d17c <__lshift+0x54>
   1d170:	1085883a 	add	r2,r2,r2
   1d174:	29400044 	addi	r5,r5,1
   1d178:	143ffd16 	blt	r2,r16,1d170 <__lshift+0x48>
   1d17c:	9809883a 	mov	r4,r19
   1d180:	001c9e00 	call	1c9e0 <_Balloc>
   1d184:	10c00504 	addi	r3,r2,20
   1d188:	0440090e 	bge	zero,r17,1d1b0 <__lshift+0x88>
   1d18c:	000f883a 	mov	r7,zero
   1d190:	18000015 	stw	zero,0(r3)
   1d194:	39c00044 	addi	r7,r7,1
   1d198:	18c00104 	addi	r3,r3,4
   1d19c:	3c7ffc1e 	bne	r7,r17,1d190 <__lshift+0x68>
   1d1a0:	38c00144 	addi	r3,r7,5
   1d1a4:	18c7883a 	add	r3,r3,r3
   1d1a8:	18c7883a 	add	r3,r3,r3
   1d1ac:	10c7883a 	add	r3,r2,r3
   1d1b0:	92000417 	ldw	r8,16(r18)
   1d1b4:	a18007cc 	andi	r6,r20,31
   1d1b8:	91c00504 	addi	r7,r18,20
   1d1bc:	42000144 	addi	r8,r8,5
   1d1c0:	4211883a 	add	r8,r8,r8
   1d1c4:	4211883a 	add	r8,r8,r8
   1d1c8:	9211883a 	add	r8,r18,r8
   1d1cc:	30002226 	beq	r6,zero,1d258 <__lshift+0x130>
   1d1d0:	02800804 	movi	r10,32
   1d1d4:	5195c83a 	sub	r10,r10,r6
   1d1d8:	000b883a 	mov	r5,zero
   1d1dc:	3a400017 	ldw	r9,0(r7)
   1d1e0:	18c00104 	addi	r3,r3,4
   1d1e4:	39c00104 	addi	r7,r7,4
   1d1e8:	4992983a 	sll	r9,r9,r6
   1d1ec:	2a4ab03a 	or	r5,r5,r9
   1d1f0:	197fff15 	stw	r5,-4(r3)
   1d1f4:	397fff17 	ldw	r5,-4(r7)
   1d1f8:	2a8ad83a 	srl	r5,r5,r10
   1d1fc:	3a3ff736 	bltu	r7,r8,1d1dc <__lshift+0xb4>
   1d200:	19400015 	stw	r5,0(r3)
   1d204:	28000126 	beq	r5,zero,1d20c <__lshift+0xe4>
   1d208:	ac000084 	addi	r16,r21,2
   1d20c:	91000117 	ldw	r4,4(r18)
   1d210:	98c01317 	ldw	r3,76(r19)
   1d214:	843fffc4 	addi	r16,r16,-1
   1d218:	2109883a 	add	r4,r4,r4
   1d21c:	2109883a 	add	r4,r4,r4
   1d220:	1907883a 	add	r3,r3,r4
   1d224:	19000017 	ldw	r4,0(r3)
   1d228:	14000415 	stw	r16,16(r2)
   1d22c:	91000015 	stw	r4,0(r18)
   1d230:	1c800015 	stw	r18,0(r3)
   1d234:	dfc00617 	ldw	ra,24(sp)
   1d238:	dd400517 	ldw	r21,20(sp)
   1d23c:	dd000417 	ldw	r20,16(sp)
   1d240:	dcc00317 	ldw	r19,12(sp)
   1d244:	dc800217 	ldw	r18,8(sp)
   1d248:	dc400117 	ldw	r17,4(sp)
   1d24c:	dc000017 	ldw	r16,0(sp)
   1d250:	dec00704 	addi	sp,sp,28
   1d254:	f800283a 	ret
   1d258:	39400017 	ldw	r5,0(r7)
   1d25c:	18c00104 	addi	r3,r3,4
   1d260:	39c00104 	addi	r7,r7,4
   1d264:	197fff15 	stw	r5,-4(r3)
   1d268:	3a3fe82e 	bgeu	r7,r8,1d20c <__lshift+0xe4>
   1d26c:	39400017 	ldw	r5,0(r7)
   1d270:	18c00104 	addi	r3,r3,4
   1d274:	39c00104 	addi	r7,r7,4
   1d278:	197fff15 	stw	r5,-4(r3)
   1d27c:	3a3ff636 	bltu	r7,r8,1d258 <__lshift+0x130>
   1d280:	003fe206 	br	1d20c <__lshift+0xe4>

0001d284 <__mcmp>:
   1d284:	20800417 	ldw	r2,16(r4)
   1d288:	28c00417 	ldw	r3,16(r5)
   1d28c:	10c5c83a 	sub	r2,r2,r3
   1d290:	10000f1e 	bne	r2,zero,1d2d0 <__mcmp+0x4c>
   1d294:	18c00144 	addi	r3,r3,5
   1d298:	18c7883a 	add	r3,r3,r3
   1d29c:	18c7883a 	add	r3,r3,r3
   1d2a0:	21c00504 	addi	r7,r4,20
   1d2a4:	28cb883a 	add	r5,r5,r3
   1d2a8:	20c9883a 	add	r4,r4,r3
   1d2ac:	213fff04 	addi	r4,r4,-4
   1d2b0:	297fff04 	addi	r5,r5,-4
   1d2b4:	21800017 	ldw	r6,0(r4)
   1d2b8:	28c00017 	ldw	r3,0(r5)
   1d2bc:	30c0021e 	bne	r6,r3,1d2c8 <__mcmp+0x44>
   1d2c0:	393ffa36 	bltu	r7,r4,1d2ac <__mcmp+0x28>
   1d2c4:	f800283a 	ret
   1d2c8:	30c00236 	bltu	r6,r3,1d2d4 <__mcmp+0x50>
   1d2cc:	00800044 	movi	r2,1
   1d2d0:	f800283a 	ret
   1d2d4:	00bfffc4 	movi	r2,-1
   1d2d8:	f800283a 	ret

0001d2dc <__mdiff>:
   1d2dc:	defffb04 	addi	sp,sp,-20
   1d2e0:	dc000015 	stw	r16,0(sp)
   1d2e4:	2821883a 	mov	r16,r5
   1d2e8:	dc800215 	stw	r18,8(sp)
   1d2ec:	300b883a 	mov	r5,r6
   1d2f0:	2025883a 	mov	r18,r4
   1d2f4:	8009883a 	mov	r4,r16
   1d2f8:	dc400115 	stw	r17,4(sp)
   1d2fc:	dfc00415 	stw	ra,16(sp)
   1d300:	dcc00315 	stw	r19,12(sp)
   1d304:	3023883a 	mov	r17,r6
   1d308:	001d2840 	call	1d284 <__mcmp>
   1d30c:	10005026 	beq	r2,zero,1d450 <__mdiff+0x174>
   1d310:	10004a16 	blt	r2,zero,1d43c <__mdiff+0x160>
   1d314:	0027883a 	mov	r19,zero
   1d318:	81400117 	ldw	r5,4(r16)
   1d31c:	9009883a 	mov	r4,r18
   1d320:	001c9e00 	call	1c9e0 <_Balloc>
   1d324:	82400417 	ldw	r9,16(r16)
   1d328:	89800417 	ldw	r6,16(r17)
   1d32c:	14c00315 	stw	r19,12(r2)
   1d330:	4b800144 	addi	r14,r9,5
   1d334:	31800144 	addi	r6,r6,5
   1d338:	739d883a 	add	r14,r14,r14
   1d33c:	318d883a 	add	r6,r6,r6
   1d340:	739d883a 	add	r14,r14,r14
   1d344:	318d883a 	add	r6,r6,r6
   1d348:	81c00504 	addi	r7,r16,20
   1d34c:	839d883a 	add	r14,r16,r14
   1d350:	8a000504 	addi	r8,r17,20
   1d354:	898d883a 	add	r6,r17,r6
   1d358:	10c00504 	addi	r3,r2,20
   1d35c:	0009883a 	mov	r4,zero
   1d360:	3b000017 	ldw	r12,0(r7)
   1d364:	42c00017 	ldw	r11,0(r8)
   1d368:	42000104 	addi	r8,r8,4
   1d36c:	62bfffcc 	andi	r10,r12,65535
   1d370:	5b7fffcc 	andi	r13,r11,65535
   1d374:	5109883a 	add	r4,r10,r4
   1d378:	2355c83a 	sub	r10,r4,r13
   1d37c:	5816d43a 	srli	r11,r11,16
   1d380:	6008d43a 	srli	r4,r12,16
   1d384:	501bd43a 	srai	r13,r10,16
   1d388:	1a80000d 	sth	r10,0(r3)
   1d38c:	22c9c83a 	sub	r4,r4,r11
   1d390:	2349883a 	add	r4,r4,r13
   1d394:	1900008d 	sth	r4,2(r3)
   1d398:	39c00104 	addi	r7,r7,4
   1d39c:	2009d43a 	srai	r4,r4,16
   1d3a0:	18c00104 	addi	r3,r3,4
   1d3a4:	41bfee36 	bltu	r8,r6,1d360 <__mdiff+0x84>
   1d3a8:	180b883a 	mov	r5,r3
   1d3ac:	3815883a 	mov	r10,r7
   1d3b0:	3b80132e 	bgeu	r7,r14,1d400 <__mdiff+0x124>
   1d3b4:	3a000017 	ldw	r8,0(r7)
   1d3b8:	18c00104 	addi	r3,r3,4
   1d3bc:	39c00104 	addi	r7,r7,4
   1d3c0:	41bfffcc 	andi	r6,r8,65535
   1d3c4:	310d883a 	add	r6,r6,r4
   1d3c8:	3009d43a 	srai	r4,r6,16
   1d3cc:	4010d43a 	srli	r8,r8,16
   1d3d0:	19bfff0d 	sth	r6,-4(r3)
   1d3d4:	2209883a 	add	r4,r4,r8
   1d3d8:	193fff8d 	sth	r4,-2(r3)
   1d3dc:	2009d43a 	srai	r4,r4,16
   1d3e0:	3bbff436 	bltu	r7,r14,1d3b4 <__mdiff+0xd8>
   1d3e4:	0286303a 	nor	r3,zero,r10
   1d3e8:	1b87883a 	add	r3,r3,r14
   1d3ec:	1806d0ba 	srli	r3,r3,2
   1d3f0:	18c00044 	addi	r3,r3,1
   1d3f4:	18c7883a 	add	r3,r3,r3
   1d3f8:	18c7883a 	add	r3,r3,r3
   1d3fc:	28c7883a 	add	r3,r5,r3
   1d400:	193fff17 	ldw	r4,-4(r3)
   1d404:	18ffff04 	addi	r3,r3,-4
   1d408:	2000041e 	bne	r4,zero,1d41c <__mdiff+0x140>
   1d40c:	18ffff04 	addi	r3,r3,-4
   1d410:	19000017 	ldw	r4,0(r3)
   1d414:	4a7fffc4 	addi	r9,r9,-1
   1d418:	203ffc26 	beq	r4,zero,1d40c <__mdiff+0x130>
   1d41c:	12400415 	stw	r9,16(r2)
   1d420:	dfc00417 	ldw	ra,16(sp)
   1d424:	dcc00317 	ldw	r19,12(sp)
   1d428:	dc800217 	ldw	r18,8(sp)
   1d42c:	dc400117 	ldw	r17,4(sp)
   1d430:	dc000017 	ldw	r16,0(sp)
   1d434:	dec00504 	addi	sp,sp,20
   1d438:	f800283a 	ret
   1d43c:	8005883a 	mov	r2,r16
   1d440:	04c00044 	movi	r19,1
   1d444:	8821883a 	mov	r16,r17
   1d448:	1023883a 	mov	r17,r2
   1d44c:	003fb206 	br	1d318 <__mdiff+0x3c>
   1d450:	9009883a 	mov	r4,r18
   1d454:	000b883a 	mov	r5,zero
   1d458:	001c9e00 	call	1c9e0 <_Balloc>
   1d45c:	00c00044 	movi	r3,1
   1d460:	10c00415 	stw	r3,16(r2)
   1d464:	10000515 	stw	zero,20(r2)
   1d468:	dfc00417 	ldw	ra,16(sp)
   1d46c:	dcc00317 	ldw	r19,12(sp)
   1d470:	dc800217 	ldw	r18,8(sp)
   1d474:	dc400117 	ldw	r17,4(sp)
   1d478:	dc000017 	ldw	r16,0(sp)
   1d47c:	dec00504 	addi	sp,sp,20
   1d480:	f800283a 	ret

0001d484 <__ulp>:
   1d484:	295ffc2c 	andhi	r5,r5,32752
   1d488:	00bf3034 	movhi	r2,64704
   1d48c:	2887883a 	add	r3,r5,r2
   1d490:	00c0020e 	bge	zero,r3,1d49c <__ulp+0x18>
   1d494:	0005883a 	mov	r2,zero
   1d498:	f800283a 	ret
   1d49c:	00c7c83a 	sub	r3,zero,r3
   1d4a0:	1805d53a 	srai	r2,r3,20
   1d4a4:	00c004c4 	movi	r3,19
   1d4a8:	18800a0e 	bge	r3,r2,1d4d4 <__ulp+0x50>
   1d4ac:	01000c84 	movi	r4,50
   1d4b0:	0007883a 	mov	r3,zero
   1d4b4:	20800516 	blt	r4,r2,1d4cc <__ulp+0x48>
   1d4b8:	01000cc4 	movi	r4,51
   1d4bc:	2085c83a 	sub	r2,r4,r2
   1d4c0:	01000044 	movi	r4,1
   1d4c4:	2084983a 	sll	r2,r4,r2
   1d4c8:	f800283a 	ret
   1d4cc:	00800044 	movi	r2,1
   1d4d0:	f800283a 	ret
   1d4d4:	00c00234 	movhi	r3,8
   1d4d8:	1887d83a 	sra	r3,r3,r2
   1d4dc:	0005883a 	mov	r2,zero
   1d4e0:	f800283a 	ret

0001d4e4 <__b2d>:
   1d4e4:	defffa04 	addi	sp,sp,-24
   1d4e8:	dc000015 	stw	r16,0(sp)
   1d4ec:	24000417 	ldw	r16,16(r4)
   1d4f0:	dc400115 	stw	r17,4(sp)
   1d4f4:	dcc00315 	stw	r19,12(sp)
   1d4f8:	84000144 	addi	r16,r16,5
   1d4fc:	8421883a 	add	r16,r16,r16
   1d500:	8421883a 	add	r16,r16,r16
   1d504:	2421883a 	add	r16,r4,r16
   1d508:	847fff17 	ldw	r17,-4(r16)
   1d50c:	24c00504 	addi	r19,r4,20
   1d510:	dd000415 	stw	r20,16(sp)
   1d514:	8809883a 	mov	r4,r17
   1d518:	dc800215 	stw	r18,8(sp)
   1d51c:	2829883a 	mov	r20,r5
   1d520:	dfc00515 	stw	ra,20(sp)
   1d524:	001ccc80 	call	1ccc8 <__hi0bits>
   1d528:	00c00804 	movi	r3,32
   1d52c:	1887c83a 	sub	r3,r3,r2
   1d530:	a0c00015 	stw	r3,0(r20)
   1d534:	00c00284 	movi	r3,10
   1d538:	84bfff04 	addi	r18,r16,-4
   1d53c:	18801216 	blt	r3,r2,1d588 <__b2d+0xa4>
   1d540:	010002c4 	movi	r4,11
   1d544:	2089c83a 	sub	r4,r4,r2
   1d548:	8906d83a 	srl	r3,r17,r4
   1d54c:	18cffc34 	orhi	r3,r3,16368
   1d550:	9c80322e 	bgeu	r19,r18,1d61c <__b2d+0x138>
   1d554:	817ffe17 	ldw	r5,-8(r16)
   1d558:	2908d83a 	srl	r4,r5,r4
   1d55c:	10800544 	addi	r2,r2,21
   1d560:	88a2983a 	sll	r17,r17,r2
   1d564:	2444b03a 	or	r2,r4,r17
   1d568:	dfc00517 	ldw	ra,20(sp)
   1d56c:	dd000417 	ldw	r20,16(sp)
   1d570:	dcc00317 	ldw	r19,12(sp)
   1d574:	dc800217 	ldw	r18,8(sp)
   1d578:	dc400117 	ldw	r17,4(sp)
   1d57c:	dc000017 	ldw	r16,0(sp)
   1d580:	dec00604 	addi	sp,sp,24
   1d584:	f800283a 	ret
   1d588:	9c801636 	bltu	r19,r18,1d5e4 <__b2d+0x100>
   1d58c:	113ffd44 	addi	r4,r2,-11
   1d590:	000b883a 	mov	r5,zero
   1d594:	20001726 	beq	r4,zero,1d5f4 <__b2d+0x110>
   1d598:	00c00ac4 	movi	r3,43
   1d59c:	1885c83a 	sub	r2,r3,r2
   1d5a0:	8906983a 	sll	r3,r17,r4
   1d5a4:	288cd83a 	srl	r6,r5,r2
   1d5a8:	18cffc34 	orhi	r3,r3,16368
   1d5ac:	1986b03a 	or	r3,r3,r6
   1d5b0:	9c801c2e 	bgeu	r19,r18,1d624 <__b2d+0x140>
   1d5b4:	91bfff17 	ldw	r6,-4(r18)
   1d5b8:	3084d83a 	srl	r2,r6,r2
   1d5bc:	2908983a 	sll	r4,r5,r4
   1d5c0:	1104b03a 	or	r2,r2,r4
   1d5c4:	dfc00517 	ldw	ra,20(sp)
   1d5c8:	dd000417 	ldw	r20,16(sp)
   1d5cc:	dcc00317 	ldw	r19,12(sp)
   1d5d0:	dc800217 	ldw	r18,8(sp)
   1d5d4:	dc400117 	ldw	r17,4(sp)
   1d5d8:	dc000017 	ldw	r16,0(sp)
   1d5dc:	dec00604 	addi	sp,sp,24
   1d5e0:	f800283a 	ret
   1d5e4:	113ffd44 	addi	r4,r2,-11
   1d5e8:	84bffe04 	addi	r18,r16,-8
   1d5ec:	817ffe17 	ldw	r5,-8(r16)
   1d5f0:	203fe91e 	bne	r4,zero,1d598 <__b2d+0xb4>
   1d5f4:	88cffc34 	orhi	r3,r17,16368
   1d5f8:	2805883a 	mov	r2,r5
   1d5fc:	dfc00517 	ldw	ra,20(sp)
   1d600:	dd000417 	ldw	r20,16(sp)
   1d604:	dcc00317 	ldw	r19,12(sp)
   1d608:	dc800217 	ldw	r18,8(sp)
   1d60c:	dc400117 	ldw	r17,4(sp)
   1d610:	dc000017 	ldw	r16,0(sp)
   1d614:	dec00604 	addi	sp,sp,24
   1d618:	f800283a 	ret
   1d61c:	0009883a 	mov	r4,zero
   1d620:	003fce06 	br	1d55c <__b2d+0x78>
   1d624:	0005883a 	mov	r2,zero
   1d628:	003fe406 	br	1d5bc <__b2d+0xd8>

0001d62c <__d2b>:
   1d62c:	defff804 	addi	sp,sp,-32
   1d630:	dc400315 	stw	r17,12(sp)
   1d634:	3023883a 	mov	r17,r6
   1d638:	dc800415 	stw	r18,16(sp)
   1d63c:	8824907a 	slli	r18,r17,1
   1d640:	dcc00515 	stw	r19,20(sp)
   1d644:	2827883a 	mov	r19,r5
   1d648:	9024d57a 	srli	r18,r18,21
   1d64c:	01400044 	movi	r5,1
   1d650:	dd000615 	stw	r20,24(sp)
   1d654:	dc000215 	stw	r16,8(sp)
   1d658:	dfc00715 	stw	ra,28(sp)
   1d65c:	3829883a 	mov	r20,r7
   1d660:	001c9e00 	call	1c9e0 <_Balloc>
   1d664:	1021883a 	mov	r16,r2
   1d668:	00800434 	movhi	r2,16
   1d66c:	10bfffc4 	addi	r2,r2,-1
   1d670:	88a2703a 	and	r17,r17,r2
   1d674:	90000126 	beq	r18,zero,1d67c <__d2b+0x50>
   1d678:	8c400434 	orhi	r17,r17,16
   1d67c:	dc400015 	stw	r17,0(sp)
   1d680:	98002226 	beq	r19,zero,1d70c <__d2b+0xe0>
   1d684:	d9000104 	addi	r4,sp,4
   1d688:	dcc00115 	stw	r19,4(sp)
   1d68c:	001cd300 	call	1cd30 <__lo0bits>
   1d690:	d8c00017 	ldw	r3,0(sp)
   1d694:	10002d1e 	bne	r2,zero,1d74c <__d2b+0x120>
   1d698:	d9000117 	ldw	r4,4(sp)
   1d69c:	81000515 	stw	r4,20(r16)
   1d6a0:	1823003a 	cmpeq	r17,r3,zero
   1d6a4:	01000084 	movi	r4,2
   1d6a8:	2463c83a 	sub	r17,r4,r17
   1d6ac:	80c00615 	stw	r3,24(r16)
   1d6b0:	84400415 	stw	r17,16(r16)
   1d6b4:	90001d1e 	bne	r18,zero,1d72c <__d2b+0x100>
   1d6b8:	88c00104 	addi	r3,r17,4
   1d6bc:	18c7883a 	add	r3,r3,r3
   1d6c0:	18c7883a 	add	r3,r3,r3
   1d6c4:	80c7883a 	add	r3,r16,r3
   1d6c8:	19000017 	ldw	r4,0(r3)
   1d6cc:	10bef384 	addi	r2,r2,-1074
   1d6d0:	a0800015 	stw	r2,0(r20)
   1d6d4:	001ccc80 	call	1ccc8 <__hi0bits>
   1d6d8:	8822917a 	slli	r17,r17,5
   1d6dc:	d8c00817 	ldw	r3,32(sp)
   1d6e0:	8885c83a 	sub	r2,r17,r2
   1d6e4:	18800015 	stw	r2,0(r3)
   1d6e8:	8005883a 	mov	r2,r16
   1d6ec:	dfc00717 	ldw	ra,28(sp)
   1d6f0:	dd000617 	ldw	r20,24(sp)
   1d6f4:	dcc00517 	ldw	r19,20(sp)
   1d6f8:	dc800417 	ldw	r18,16(sp)
   1d6fc:	dc400317 	ldw	r17,12(sp)
   1d700:	dc000217 	ldw	r16,8(sp)
   1d704:	dec00804 	addi	sp,sp,32
   1d708:	f800283a 	ret
   1d70c:	d809883a 	mov	r4,sp
   1d710:	001cd300 	call	1cd30 <__lo0bits>
   1d714:	d8c00017 	ldw	r3,0(sp)
   1d718:	04400044 	movi	r17,1
   1d71c:	84400415 	stw	r17,16(r16)
   1d720:	80c00515 	stw	r3,20(r16)
   1d724:	10800804 	addi	r2,r2,32
   1d728:	903fe326 	beq	r18,zero,1d6b8 <__d2b+0x8c>
   1d72c:	00c00d44 	movi	r3,53
   1d730:	94bef344 	addi	r18,r18,-1075
   1d734:	90a5883a 	add	r18,r18,r2
   1d738:	1885c83a 	sub	r2,r3,r2
   1d73c:	d8c00817 	ldw	r3,32(sp)
   1d740:	a4800015 	stw	r18,0(r20)
   1d744:	18800015 	stw	r2,0(r3)
   1d748:	003fe706 	br	1d6e8 <__d2b+0xbc>
   1d74c:	01000804 	movi	r4,32
   1d750:	2089c83a 	sub	r4,r4,r2
   1d754:	1908983a 	sll	r4,r3,r4
   1d758:	d9400117 	ldw	r5,4(sp)
   1d75c:	1886d83a 	srl	r3,r3,r2
   1d760:	2148b03a 	or	r4,r4,r5
   1d764:	81000515 	stw	r4,20(r16)
   1d768:	d8c00015 	stw	r3,0(sp)
   1d76c:	003fcc06 	br	1d6a0 <__d2b+0x74>

0001d770 <__ratio>:
   1d770:	defff904 	addi	sp,sp,-28
   1d774:	dc400315 	stw	r17,12(sp)
   1d778:	2823883a 	mov	r17,r5
   1d77c:	d9400104 	addi	r5,sp,4
   1d780:	dfc00615 	stw	ra,24(sp)
   1d784:	dcc00515 	stw	r19,20(sp)
   1d788:	dc800415 	stw	r18,16(sp)
   1d78c:	2027883a 	mov	r19,r4
   1d790:	dc000215 	stw	r16,8(sp)
   1d794:	001d4e40 	call	1d4e4 <__b2d>
   1d798:	8809883a 	mov	r4,r17
   1d79c:	d80b883a 	mov	r5,sp
   1d7a0:	1025883a 	mov	r18,r2
   1d7a4:	1821883a 	mov	r16,r3
   1d7a8:	001d4e40 	call	1d4e4 <__b2d>
   1d7ac:	99400417 	ldw	r5,16(r19)
   1d7b0:	89000417 	ldw	r4,16(r17)
   1d7b4:	d9800117 	ldw	r6,4(sp)
   1d7b8:	2909c83a 	sub	r4,r5,r4
   1d7bc:	d9400017 	ldw	r5,0(sp)
   1d7c0:	2008917a 	slli	r4,r4,5
   1d7c4:	314bc83a 	sub	r5,r6,r5
   1d7c8:	290b883a 	add	r5,r5,r4
   1d7cc:	01400e0e 	bge	zero,r5,1d808 <__ratio+0x98>
   1d7d0:	280a953a 	slli	r5,r5,20
   1d7d4:	2c21883a 	add	r16,r5,r16
   1d7d8:	9009883a 	mov	r4,r18
   1d7dc:	800b883a 	mov	r5,r16
   1d7e0:	100d883a 	mov	r6,r2
   1d7e4:	180f883a 	mov	r7,r3
   1d7e8:	001f84c0 	call	1f84c <__divdf3>
   1d7ec:	dfc00617 	ldw	ra,24(sp)
   1d7f0:	dcc00517 	ldw	r19,20(sp)
   1d7f4:	dc800417 	ldw	r18,16(sp)
   1d7f8:	dc400317 	ldw	r17,12(sp)
   1d7fc:	dc000217 	ldw	r16,8(sp)
   1d800:	dec00704 	addi	sp,sp,28
   1d804:	f800283a 	ret
   1d808:	280a953a 	slli	r5,r5,20
   1d80c:	1947c83a 	sub	r3,r3,r5
   1d810:	003ff106 	br	1d7d8 <__ratio+0x68>

0001d814 <_mprec_log10>:
   1d814:	defffe04 	addi	sp,sp,-8
   1d818:	dc000015 	stw	r16,0(sp)
   1d81c:	dfc00115 	stw	ra,4(sp)
   1d820:	008005c4 	movi	r2,23
   1d824:	2021883a 	mov	r16,r4
   1d828:	11000d0e 	bge	r2,r4,1d860 <_mprec_log10+0x4c>
   1d82c:	0005883a 	mov	r2,zero
   1d830:	00cffc34 	movhi	r3,16368
   1d834:	843fffc4 	addi	r16,r16,-1
   1d838:	1009883a 	mov	r4,r2
   1d83c:	180b883a 	mov	r5,r3
   1d840:	000d883a 	mov	r6,zero
   1d844:	01d00934 	movhi	r7,16420
   1d848:	001f5680 	call	1f568 <__muldf3>
   1d84c:	803ff91e 	bne	r16,zero,1d834 <_mprec_log10+0x20>
   1d850:	dfc00117 	ldw	ra,4(sp)
   1d854:	dc000017 	ldw	r16,0(sp)
   1d858:	dec00204 	addi	sp,sp,8
   1d85c:	f800283a 	ret
   1d860:	202090fa 	slli	r16,r4,3
   1d864:	008000f4 	movhi	r2,3
   1d868:	10802304 	addi	r2,r2,140
   1d86c:	1421883a 	add	r16,r2,r16
   1d870:	80800017 	ldw	r2,0(r16)
   1d874:	80c00117 	ldw	r3,4(r16)
   1d878:	dfc00117 	ldw	ra,4(sp)
   1d87c:	dc000017 	ldw	r16,0(sp)
   1d880:	dec00204 	addi	sp,sp,8
   1d884:	f800283a 	ret

0001d888 <__copybits>:
   1d888:	297fffc4 	addi	r5,r5,-1
   1d88c:	31c00417 	ldw	r7,16(r6)
   1d890:	2811d17a 	srai	r8,r5,5
   1d894:	30800504 	addi	r2,r6,20
   1d898:	39c00144 	addi	r7,r7,5
   1d89c:	42000044 	addi	r8,r8,1
   1d8a0:	39cf883a 	add	r7,r7,r7
   1d8a4:	4211883a 	add	r8,r8,r8
   1d8a8:	39cf883a 	add	r7,r7,r7
   1d8ac:	4211883a 	add	r8,r8,r8
   1d8b0:	31cf883a 	add	r7,r6,r7
   1d8b4:	2211883a 	add	r8,r4,r8
   1d8b8:	11c00d2e 	bgeu	r2,r7,1d8f0 <__copybits+0x68>
   1d8bc:	2007883a 	mov	r3,r4
   1d8c0:	11400017 	ldw	r5,0(r2)
   1d8c4:	18c00104 	addi	r3,r3,4
   1d8c8:	10800104 	addi	r2,r2,4
   1d8cc:	197fff15 	stw	r5,-4(r3)
   1d8d0:	11fffb36 	bltu	r2,r7,1d8c0 <__copybits+0x38>
   1d8d4:	3985c83a 	sub	r2,r7,r6
   1d8d8:	10bffac4 	addi	r2,r2,-21
   1d8dc:	1004d0ba 	srli	r2,r2,2
   1d8e0:	10800044 	addi	r2,r2,1
   1d8e4:	1085883a 	add	r2,r2,r2
   1d8e8:	1085883a 	add	r2,r2,r2
   1d8ec:	2089883a 	add	r4,r4,r2
   1d8f0:	2200032e 	bgeu	r4,r8,1d900 <__copybits+0x78>
   1d8f4:	20000015 	stw	zero,0(r4)
   1d8f8:	21000104 	addi	r4,r4,4
   1d8fc:	223ffd36 	bltu	r4,r8,1d8f4 <__copybits+0x6c>
   1d900:	f800283a 	ret

0001d904 <__any_on>:
   1d904:	21800417 	ldw	r6,16(r4)
   1d908:	2805d17a 	srai	r2,r5,5
   1d90c:	20c00504 	addi	r3,r4,20
   1d910:	30800f0e 	bge	r6,r2,1d950 <__any_on+0x4c>
   1d914:	3005883a 	mov	r2,r6
   1d918:	10800144 	addi	r2,r2,5
   1d91c:	1085883a 	add	r2,r2,r2
   1d920:	1085883a 	add	r2,r2,r2
   1d924:	2089883a 	add	r4,r4,r2
   1d928:	1900152e 	bgeu	r3,r4,1d980 <__any_on+0x7c>
   1d92c:	20bfff17 	ldw	r2,-4(r4)
   1d930:	213fff04 	addi	r4,r4,-4
   1d934:	1000041e 	bne	r2,zero,1d948 <__any_on+0x44>
   1d938:	1900112e 	bgeu	r3,r4,1d980 <__any_on+0x7c>
   1d93c:	213fff04 	addi	r4,r4,-4
   1d940:	20800017 	ldw	r2,0(r4)
   1d944:	103ffc26 	beq	r2,zero,1d938 <__any_on+0x34>
   1d948:	00800044 	movi	r2,1
   1d94c:	f800283a 	ret
   1d950:	11bff10e 	bge	r2,r6,1d918 <__any_on+0x14>
   1d954:	294007cc 	andi	r5,r5,31
   1d958:	283fef26 	beq	r5,zero,1d918 <__any_on+0x14>
   1d95c:	11800144 	addi	r6,r2,5
   1d960:	318d883a 	add	r6,r6,r6
   1d964:	318d883a 	add	r6,r6,r6
   1d968:	218d883a 	add	r6,r4,r6
   1d96c:	31800017 	ldw	r6,0(r6)
   1d970:	314ed83a 	srl	r7,r6,r5
   1d974:	394a983a 	sll	r5,r7,r5
   1d978:	29bff31e 	bne	r5,r6,1d948 <__any_on+0x44>
   1d97c:	003fe606 	br	1d918 <__any_on+0x14>
   1d980:	0005883a 	mov	r2,zero
   1d984:	f800283a 	ret

0001d988 <_realloc_r>:
   1d988:	defff504 	addi	sp,sp,-44
   1d98c:	dd400615 	stw	r21,24(sp)
   1d990:	dc800315 	stw	r18,12(sp)
   1d994:	dc000115 	stw	r16,4(sp)
   1d998:	dfc00a15 	stw	ra,40(sp)
   1d99c:	df000915 	stw	fp,36(sp)
   1d9a0:	ddc00815 	stw	r23,32(sp)
   1d9a4:	dd800715 	stw	r22,28(sp)
   1d9a8:	dd000515 	stw	r20,20(sp)
   1d9ac:	dcc00415 	stw	r19,16(sp)
   1d9b0:	dc400215 	stw	r17,8(sp)
   1d9b4:	2821883a 	mov	r16,r5
   1d9b8:	202b883a 	mov	r21,r4
   1d9bc:	3025883a 	mov	r18,r6
   1d9c0:	28009626 	beq	r5,zero,1dc1c <_realloc_r+0x294>
   1d9c4:	0020c7c0 	call	20c7c <__malloc_lock>
   1d9c8:	80bfff17 	ldw	r2,-4(r16)
   1d9cc:	04ffff04 	movi	r19,-4
   1d9d0:	90c002c4 	addi	r3,r18,11
   1d9d4:	01000584 	movi	r4,22
   1d9d8:	85bffe04 	addi	r22,r16,-8
   1d9dc:	14e6703a 	and	r19,r2,r19
   1d9e0:	20c0372e 	bgeu	r4,r3,1dac0 <_realloc_r+0x138>
   1d9e4:	047ffe04 	movi	r17,-8
   1d9e8:	1c62703a 	and	r17,r3,r17
   1d9ec:	8807883a 	mov	r3,r17
   1d9f0:	88005a16 	blt	r17,zero,1db5c <_realloc_r+0x1d4>
   1d9f4:	8c805936 	bltu	r17,r18,1db5c <_realloc_r+0x1d4>
   1d9f8:	98c0340e 	bge	r19,r3,1dacc <_realloc_r+0x144>
   1d9fc:	070000f4 	movhi	fp,3
   1da00:	e70a1804 	addi	fp,fp,10336
   1da04:	e1400217 	ldw	r5,8(fp)
   1da08:	b4c9883a 	add	r4,r22,r19
   1da0c:	29009026 	beq	r5,r4,1dc50 <_realloc_r+0x2c8>
   1da10:	21800117 	ldw	r6,4(r4)
   1da14:	01ffff84 	movi	r7,-2
   1da18:	31ce703a 	and	r7,r6,r7
   1da1c:	21cf883a 	add	r7,r4,r7
   1da20:	39c00117 	ldw	r7,4(r7)
   1da24:	39c0004c 	andi	r7,r7,1
   1da28:	38004326 	beq	r7,zero,1db38 <_realloc_r+0x1b0>
   1da2c:	000d883a 	mov	r6,zero
   1da30:	0009883a 	mov	r4,zero
   1da34:	1080004c 	andi	r2,r2,1
   1da38:	10005a1e 	bne	r2,zero,1dba4 <_realloc_r+0x21c>
   1da3c:	85fffe17 	ldw	r23,-8(r16)
   1da40:	00bfff04 	movi	r2,-4
   1da44:	b5efc83a 	sub	r23,r22,r23
   1da48:	b9c00117 	ldw	r7,4(r23)
   1da4c:	388e703a 	and	r7,r7,r2
   1da50:	3ccf883a 	add	r7,r7,r19
   1da54:	20005226 	beq	r4,zero,1dba0 <_realloc_r+0x218>
   1da58:	31e9883a 	add	r20,r6,r7
   1da5c:	2140c726 	beq	r4,r5,1dd7c <_realloc_r+0x3f4>
   1da60:	a0c04f16 	blt	r20,r3,1dba0 <_realloc_r+0x218>
   1da64:	20800317 	ldw	r2,12(r4)
   1da68:	20c00217 	ldw	r3,8(r4)
   1da6c:	99bfff04 	addi	r6,r19,-4
   1da70:	01000904 	movi	r4,36
   1da74:	18800315 	stw	r2,12(r3)
   1da78:	10c00215 	stw	r3,8(r2)
   1da7c:	b8c00217 	ldw	r3,8(r23)
   1da80:	b8800317 	ldw	r2,12(r23)
   1da84:	bc800204 	addi	r18,r23,8
   1da88:	18800315 	stw	r2,12(r3)
   1da8c:	10c00215 	stw	r3,8(r2)
   1da90:	2180ed36 	bltu	r4,r6,1de48 <_realloc_r+0x4c0>
   1da94:	008004c4 	movi	r2,19
   1da98:	11809b2e 	bgeu	r2,r6,1dd08 <_realloc_r+0x380>
   1da9c:	80800017 	ldw	r2,0(r16)
   1daa0:	b8800215 	stw	r2,8(r23)
   1daa4:	80800117 	ldw	r2,4(r16)
   1daa8:	b8800315 	stw	r2,12(r23)
   1daac:	008006c4 	movi	r2,27
   1dab0:	1180f936 	bltu	r2,r6,1de98 <_realloc_r+0x510>
   1dab4:	b8800404 	addi	r2,r23,16
   1dab8:	80c00204 	addi	r3,r16,8
   1dabc:	00009406 	br	1dd10 <_realloc_r+0x388>
   1dac0:	00c00404 	movi	r3,16
   1dac4:	1823883a 	mov	r17,r3
   1dac8:	003fca06 	br	1d9f4 <_realloc_r+0x6c>
   1dacc:	9829883a 	mov	r20,r19
   1dad0:	a447c83a 	sub	r3,r20,r17
   1dad4:	010003c4 	movi	r4,15
   1dad8:	1080004c 	andi	r2,r2,1
   1dadc:	20c02336 	bltu	r4,r3,1db6c <_realloc_r+0x1e4>
   1dae0:	1504b03a 	or	r2,r2,r20
   1dae4:	b0800115 	stw	r2,4(r22)
   1dae8:	b52d883a 	add	r22,r22,r20
   1daec:	b0800117 	ldw	r2,4(r22)
   1daf0:	10800054 	ori	r2,r2,1
   1daf4:	b0800115 	stw	r2,4(r22)
   1daf8:	a809883a 	mov	r4,r21
   1dafc:	0020c9c0 	call	20c9c <__malloc_unlock>
   1db00:	8025883a 	mov	r18,r16
   1db04:	9005883a 	mov	r2,r18
   1db08:	dfc00a17 	ldw	ra,40(sp)
   1db0c:	df000917 	ldw	fp,36(sp)
   1db10:	ddc00817 	ldw	r23,32(sp)
   1db14:	dd800717 	ldw	r22,28(sp)
   1db18:	dd400617 	ldw	r21,24(sp)
   1db1c:	dd000517 	ldw	r20,20(sp)
   1db20:	dcc00417 	ldw	r19,16(sp)
   1db24:	dc800317 	ldw	r18,12(sp)
   1db28:	dc400217 	ldw	r17,8(sp)
   1db2c:	dc000117 	ldw	r16,4(sp)
   1db30:	dec00b04 	addi	sp,sp,44
   1db34:	f800283a 	ret
   1db38:	01ffff04 	movi	r7,-4
   1db3c:	31cc703a 	and	r6,r6,r7
   1db40:	34e9883a 	add	r20,r6,r19
   1db44:	a0ffbb16 	blt	r20,r3,1da34 <_realloc_r+0xac>
   1db48:	20c00317 	ldw	r3,12(r4)
   1db4c:	21000217 	ldw	r4,8(r4)
   1db50:	20c00315 	stw	r3,12(r4)
   1db54:	19000215 	stw	r4,8(r3)
   1db58:	003fdd06 	br	1dad0 <_realloc_r+0x148>
   1db5c:	00800304 	movi	r2,12
   1db60:	a8800015 	stw	r2,0(r21)
   1db64:	0025883a 	mov	r18,zero
   1db68:	003fe606 	br	1db04 <_realloc_r+0x17c>
   1db6c:	1444b03a 	or	r2,r2,r17
   1db70:	b0800115 	stw	r2,4(r22)
   1db74:	b44b883a 	add	r5,r22,r17
   1db78:	18800054 	ori	r2,r3,1
   1db7c:	28800115 	stw	r2,4(r5)
   1db80:	28c7883a 	add	r3,r5,r3
   1db84:	18800117 	ldw	r2,4(r3)
   1db88:	a809883a 	mov	r4,r21
   1db8c:	29400204 	addi	r5,r5,8
   1db90:	10800054 	ori	r2,r2,1
   1db94:	18800115 	stw	r2,4(r3)
   1db98:	001b4a40 	call	1b4a4 <_free_r>
   1db9c:	003fd606 	br	1daf8 <_realloc_r+0x170>
   1dba0:	38c0330e 	bge	r7,r3,1dc70 <_realloc_r+0x2e8>
   1dba4:	900b883a 	mov	r5,r18
   1dba8:	a809883a 	mov	r4,r21
   1dbac:	001c03c0 	call	1c03c <_malloc_r>
   1dbb0:	1025883a 	mov	r18,r2
   1dbb4:	10001626 	beq	r2,zero,1dc10 <_realloc_r+0x288>
   1dbb8:	80bfff17 	ldw	r2,-4(r16)
   1dbbc:	00ffff84 	movi	r3,-2
   1dbc0:	913ffe04 	addi	r4,r18,-8
   1dbc4:	10c6703a 	and	r3,r2,r3
   1dbc8:	b0c7883a 	add	r3,r22,r3
   1dbcc:	20c09926 	beq	r4,r3,1de34 <_realloc_r+0x4ac>
   1dbd0:	99bfff04 	addi	r6,r19,-4
   1dbd4:	00800904 	movi	r2,36
   1dbd8:	11806436 	bltu	r2,r6,1dd6c <_realloc_r+0x3e4>
   1dbdc:	00c004c4 	movi	r3,19
   1dbe0:	19804036 	bltu	r3,r6,1dce4 <_realloc_r+0x35c>
   1dbe4:	9005883a 	mov	r2,r18
   1dbe8:	8007883a 	mov	r3,r16
   1dbec:	19000017 	ldw	r4,0(r3)
   1dbf0:	11000015 	stw	r4,0(r2)
   1dbf4:	19000117 	ldw	r4,4(r3)
   1dbf8:	11000115 	stw	r4,4(r2)
   1dbfc:	18c00217 	ldw	r3,8(r3)
   1dc00:	10c00215 	stw	r3,8(r2)
   1dc04:	a809883a 	mov	r4,r21
   1dc08:	800b883a 	mov	r5,r16
   1dc0c:	001b4a40 	call	1b4a4 <_free_r>
   1dc10:	a809883a 	mov	r4,r21
   1dc14:	0020c9c0 	call	20c9c <__malloc_unlock>
   1dc18:	003fba06 	br	1db04 <_realloc_r+0x17c>
   1dc1c:	300b883a 	mov	r5,r6
   1dc20:	dfc00a17 	ldw	ra,40(sp)
   1dc24:	df000917 	ldw	fp,36(sp)
   1dc28:	ddc00817 	ldw	r23,32(sp)
   1dc2c:	dd800717 	ldw	r22,28(sp)
   1dc30:	dd400617 	ldw	r21,24(sp)
   1dc34:	dd000517 	ldw	r20,20(sp)
   1dc38:	dcc00417 	ldw	r19,16(sp)
   1dc3c:	dc800317 	ldw	r18,12(sp)
   1dc40:	dc400217 	ldw	r17,8(sp)
   1dc44:	dc000117 	ldw	r16,4(sp)
   1dc48:	dec00b04 	addi	sp,sp,44
   1dc4c:	001c03c1 	jmpi	1c03c <_malloc_r>
   1dc50:	29800117 	ldw	r6,4(r5)
   1dc54:	013fff04 	movi	r4,-4
   1dc58:	89c00404 	addi	r7,r17,16
   1dc5c:	310c703a 	and	r6,r6,r4
   1dc60:	34c9883a 	add	r4,r6,r19
   1dc64:	21c0340e 	bge	r4,r7,1dd38 <_realloc_r+0x3b0>
   1dc68:	2809883a 	mov	r4,r5
   1dc6c:	003f7106 	br	1da34 <_realloc_r+0xac>
   1dc70:	b8800317 	ldw	r2,12(r23)
   1dc74:	b8c00217 	ldw	r3,8(r23)
   1dc78:	99bfff04 	addi	r6,r19,-4
   1dc7c:	01000904 	movi	r4,36
   1dc80:	18800315 	stw	r2,12(r3)
   1dc84:	10c00215 	stw	r3,8(r2)
   1dc88:	bc800204 	addi	r18,r23,8
   1dc8c:	21807836 	bltu	r4,r6,1de70 <_realloc_r+0x4e8>
   1dc90:	008004c4 	movi	r2,19
   1dc94:	1180732e 	bgeu	r2,r6,1de64 <_realloc_r+0x4dc>
   1dc98:	80800017 	ldw	r2,0(r16)
   1dc9c:	b8800215 	stw	r2,8(r23)
   1dca0:	80800117 	ldw	r2,4(r16)
   1dca4:	b8800315 	stw	r2,12(r23)
   1dca8:	008006c4 	movi	r2,27
   1dcac:	11808936 	bltu	r2,r6,1ded4 <_realloc_r+0x54c>
   1dcb0:	b8800404 	addi	r2,r23,16
   1dcb4:	80c00204 	addi	r3,r16,8
   1dcb8:	19000017 	ldw	r4,0(r3)
   1dcbc:	9021883a 	mov	r16,r18
   1dcc0:	3829883a 	mov	r20,r7
   1dcc4:	11000015 	stw	r4,0(r2)
   1dcc8:	19000117 	ldw	r4,4(r3)
   1dccc:	b82d883a 	mov	r22,r23
   1dcd0:	11000115 	stw	r4,4(r2)
   1dcd4:	18c00217 	ldw	r3,8(r3)
   1dcd8:	10c00215 	stw	r3,8(r2)
   1dcdc:	b8800117 	ldw	r2,4(r23)
   1dce0:	003f7b06 	br	1dad0 <_realloc_r+0x148>
   1dce4:	80c00017 	ldw	r3,0(r16)
   1dce8:	90c00015 	stw	r3,0(r18)
   1dcec:	80c00117 	ldw	r3,4(r16)
   1dcf0:	90c00115 	stw	r3,4(r18)
   1dcf4:	00c006c4 	movi	r3,27
   1dcf8:	19804636 	bltu	r3,r6,1de14 <_realloc_r+0x48c>
   1dcfc:	90800204 	addi	r2,r18,8
   1dd00:	80c00204 	addi	r3,r16,8
   1dd04:	003fb906 	br	1dbec <_realloc_r+0x264>
   1dd08:	9005883a 	mov	r2,r18
   1dd0c:	8007883a 	mov	r3,r16
   1dd10:	19000017 	ldw	r4,0(r3)
   1dd14:	9021883a 	mov	r16,r18
   1dd18:	b82d883a 	mov	r22,r23
   1dd1c:	11000015 	stw	r4,0(r2)
   1dd20:	19000117 	ldw	r4,4(r3)
   1dd24:	11000115 	stw	r4,4(r2)
   1dd28:	18c00217 	ldw	r3,8(r3)
   1dd2c:	10c00215 	stw	r3,8(r2)
   1dd30:	b8800117 	ldw	r2,4(r23)
   1dd34:	003f6606 	br	1dad0 <_realloc_r+0x148>
   1dd38:	2445c83a 	sub	r2,r4,r17
   1dd3c:	b46d883a 	add	r22,r22,r17
   1dd40:	10800054 	ori	r2,r2,1
   1dd44:	b0800115 	stw	r2,4(r22)
   1dd48:	80bfff17 	ldw	r2,-4(r16)
   1dd4c:	a809883a 	mov	r4,r21
   1dd50:	e5800215 	stw	r22,8(fp)
   1dd54:	1080004c 	andi	r2,r2,1
   1dd58:	88a2b03a 	or	r17,r17,r2
   1dd5c:	847fff15 	stw	r17,-4(r16)
   1dd60:	0020c9c0 	call	20c9c <__malloc_unlock>
   1dd64:	8025883a 	mov	r18,r16
   1dd68:	003f6606 	br	1db04 <_realloc_r+0x17c>
   1dd6c:	9009883a 	mov	r4,r18
   1dd70:	800b883a 	mov	r5,r16
   1dd74:	001c8b80 	call	1c8b8 <memmove>
   1dd78:	003fa206 	br	1dc04 <_realloc_r+0x27c>
   1dd7c:	88800404 	addi	r2,r17,16
   1dd80:	a0bf8716 	blt	r20,r2,1dba0 <_realloc_r+0x218>
   1dd84:	b8800317 	ldw	r2,12(r23)
   1dd88:	b8c00217 	ldw	r3,8(r23)
   1dd8c:	99bfff04 	addi	r6,r19,-4
   1dd90:	01000904 	movi	r4,36
   1dd94:	18800315 	stw	r2,12(r3)
   1dd98:	10c00215 	stw	r3,8(r2)
   1dd9c:	bc800204 	addi	r18,r23,8
   1dda0:	21806536 	bltu	r4,r6,1df38 <_realloc_r+0x5b0>
   1dda4:	008004c4 	movi	r2,19
   1dda8:	1180592e 	bgeu	r2,r6,1df10 <_realloc_r+0x588>
   1ddac:	80800017 	ldw	r2,0(r16)
   1ddb0:	b8800215 	stw	r2,8(r23)
   1ddb4:	80800117 	ldw	r2,4(r16)
   1ddb8:	b8800315 	stw	r2,12(r23)
   1ddbc:	008006c4 	movi	r2,27
   1ddc0:	11806136 	bltu	r2,r6,1df48 <_realloc_r+0x5c0>
   1ddc4:	b8800404 	addi	r2,r23,16
   1ddc8:	80c00204 	addi	r3,r16,8
   1ddcc:	19000017 	ldw	r4,0(r3)
   1ddd0:	11000015 	stw	r4,0(r2)
   1ddd4:	19000117 	ldw	r4,4(r3)
   1ddd8:	11000115 	stw	r4,4(r2)
   1dddc:	18c00217 	ldw	r3,8(r3)
   1dde0:	10c00215 	stw	r3,8(r2)
   1dde4:	a447c83a 	sub	r3,r20,r17
   1dde8:	bc45883a 	add	r2,r23,r17
   1ddec:	18c00054 	ori	r3,r3,1
   1ddf0:	10c00115 	stw	r3,4(r2)
   1ddf4:	b8c00117 	ldw	r3,4(r23)
   1ddf8:	e0800215 	stw	r2,8(fp)
   1ddfc:	a809883a 	mov	r4,r21
   1de00:	1880004c 	andi	r2,r3,1
   1de04:	88a2b03a 	or	r17,r17,r2
   1de08:	bc400115 	stw	r17,4(r23)
   1de0c:	0020c9c0 	call	20c9c <__malloc_unlock>
   1de10:	003f3c06 	br	1db04 <_realloc_r+0x17c>
   1de14:	80c00217 	ldw	r3,8(r16)
   1de18:	90c00215 	stw	r3,8(r18)
   1de1c:	80c00317 	ldw	r3,12(r16)
   1de20:	90c00315 	stw	r3,12(r18)
   1de24:	30802426 	beq	r6,r2,1deb8 <_realloc_r+0x530>
   1de28:	90800404 	addi	r2,r18,16
   1de2c:	80c00404 	addi	r3,r16,16
   1de30:	003f6e06 	br	1dbec <_realloc_r+0x264>
   1de34:	953fff17 	ldw	r20,-4(r18)
   1de38:	00ffff04 	movi	r3,-4
   1de3c:	a0e8703a 	and	r20,r20,r3
   1de40:	a4e9883a 	add	r20,r20,r19
   1de44:	003f2206 	br	1dad0 <_realloc_r+0x148>
   1de48:	800b883a 	mov	r5,r16
   1de4c:	9009883a 	mov	r4,r18
   1de50:	001c8b80 	call	1c8b8 <memmove>
   1de54:	9021883a 	mov	r16,r18
   1de58:	b8800117 	ldw	r2,4(r23)
   1de5c:	b82d883a 	mov	r22,r23
   1de60:	003f1b06 	br	1dad0 <_realloc_r+0x148>
   1de64:	9005883a 	mov	r2,r18
   1de68:	8007883a 	mov	r3,r16
   1de6c:	003f9206 	br	1dcb8 <_realloc_r+0x330>
   1de70:	800b883a 	mov	r5,r16
   1de74:	9009883a 	mov	r4,r18
   1de78:	d9c00015 	stw	r7,0(sp)
   1de7c:	001c8b80 	call	1c8b8 <memmove>
   1de80:	d9c00017 	ldw	r7,0(sp)
   1de84:	9021883a 	mov	r16,r18
   1de88:	b8800117 	ldw	r2,4(r23)
   1de8c:	3829883a 	mov	r20,r7
   1de90:	b82d883a 	mov	r22,r23
   1de94:	003f0e06 	br	1dad0 <_realloc_r+0x148>
   1de98:	80800217 	ldw	r2,8(r16)
   1de9c:	b8800415 	stw	r2,16(r23)
   1dea0:	80800317 	ldw	r2,12(r16)
   1dea4:	b8800515 	stw	r2,20(r23)
   1dea8:	31001226 	beq	r6,r4,1def4 <_realloc_r+0x56c>
   1deac:	b8800604 	addi	r2,r23,24
   1deb0:	80c00404 	addi	r3,r16,16
   1deb4:	003f9606 	br	1dd10 <_realloc_r+0x388>
   1deb8:	81000417 	ldw	r4,16(r16)
   1debc:	90800604 	addi	r2,r18,24
   1dec0:	80c00604 	addi	r3,r16,24
   1dec4:	91000415 	stw	r4,16(r18)
   1dec8:	81000517 	ldw	r4,20(r16)
   1decc:	91000515 	stw	r4,20(r18)
   1ded0:	003f4606 	br	1dbec <_realloc_r+0x264>
   1ded4:	80800217 	ldw	r2,8(r16)
   1ded8:	b8800415 	stw	r2,16(r23)
   1dedc:	80800317 	ldw	r2,12(r16)
   1dee0:	b8800515 	stw	r2,20(r23)
   1dee4:	31000d26 	beq	r6,r4,1df1c <_realloc_r+0x594>
   1dee8:	b8800604 	addi	r2,r23,24
   1deec:	80c00404 	addi	r3,r16,16
   1def0:	003f7106 	br	1dcb8 <_realloc_r+0x330>
   1def4:	81000417 	ldw	r4,16(r16)
   1def8:	b8800804 	addi	r2,r23,32
   1defc:	80c00604 	addi	r3,r16,24
   1df00:	b9000615 	stw	r4,24(r23)
   1df04:	81000517 	ldw	r4,20(r16)
   1df08:	b9000715 	stw	r4,28(r23)
   1df0c:	003f8006 	br	1dd10 <_realloc_r+0x388>
   1df10:	9005883a 	mov	r2,r18
   1df14:	8007883a 	mov	r3,r16
   1df18:	003fac06 	br	1ddcc <_realloc_r+0x444>
   1df1c:	81000417 	ldw	r4,16(r16)
   1df20:	b8800804 	addi	r2,r23,32
   1df24:	80c00604 	addi	r3,r16,24
   1df28:	b9000615 	stw	r4,24(r23)
   1df2c:	81000517 	ldw	r4,20(r16)
   1df30:	b9000715 	stw	r4,28(r23)
   1df34:	003f6006 	br	1dcb8 <_realloc_r+0x330>
   1df38:	9009883a 	mov	r4,r18
   1df3c:	800b883a 	mov	r5,r16
   1df40:	001c8b80 	call	1c8b8 <memmove>
   1df44:	003fa706 	br	1dde4 <_realloc_r+0x45c>
   1df48:	80800217 	ldw	r2,8(r16)
   1df4c:	b8800415 	stw	r2,16(r23)
   1df50:	80800317 	ldw	r2,12(r16)
   1df54:	b8800515 	stw	r2,20(r23)
   1df58:	31000326 	beq	r6,r4,1df68 <_realloc_r+0x5e0>
   1df5c:	b8800604 	addi	r2,r23,24
   1df60:	80c00404 	addi	r3,r16,16
   1df64:	003f9906 	br	1ddcc <_realloc_r+0x444>
   1df68:	81000417 	ldw	r4,16(r16)
   1df6c:	b8800804 	addi	r2,r23,32
   1df70:	80c00604 	addi	r3,r16,24
   1df74:	b9000615 	stw	r4,24(r23)
   1df78:	81000517 	ldw	r4,20(r16)
   1df7c:	b9000715 	stw	r4,28(r23)
   1df80:	003f9206 	br	1ddcc <_realloc_r+0x444>

0001df84 <__isinfd>:
   1df84:	0105c83a 	sub	r2,zero,r4
   1df88:	1108b03a 	or	r4,r2,r4
   1df8c:	2004d7fa 	srli	r2,r4,31
   1df90:	00e00034 	movhi	r3,32768
   1df94:	18ffffc4 	addi	r3,r3,-1
   1df98:	28ca703a 	and	r5,r5,r3
   1df9c:	1144b03a 	or	r2,r2,r5
   1dfa0:	00dffc34 	movhi	r3,32752
   1dfa4:	1885c83a 	sub	r2,r3,r2
   1dfa8:	0087c83a 	sub	r3,zero,r2
   1dfac:	1884b03a 	or	r2,r3,r2
   1dfb0:	1005d7fa 	srai	r2,r2,31
   1dfb4:	10800044 	addi	r2,r2,1
   1dfb8:	f800283a 	ret

0001dfbc <__isnand>:
   1dfbc:	0105c83a 	sub	r2,zero,r4
   1dfc0:	1108b03a 	or	r4,r2,r4
   1dfc4:	2004d7fa 	srli	r2,r4,31
   1dfc8:	00e00034 	movhi	r3,32768
   1dfcc:	18ffffc4 	addi	r3,r3,-1
   1dfd0:	28ca703a 	and	r5,r5,r3
   1dfd4:	1144b03a 	or	r2,r2,r5
   1dfd8:	00dffc34 	movhi	r3,32752
   1dfdc:	1885c83a 	sub	r2,r3,r2
   1dfe0:	1004d7fa 	srli	r2,r2,31
   1dfe4:	f800283a 	ret

0001dfe8 <_sbrk_r>:
   1dfe8:	defffd04 	addi	sp,sp,-12
   1dfec:	dc400115 	stw	r17,4(sp)
   1dff0:	dc000015 	stw	r16,0(sp)
   1dff4:	2023883a 	mov	r17,r4
   1dff8:	040000f4 	movhi	r16,3
   1dffc:	8419dd04 	addi	r16,r16,26484
   1e000:	2809883a 	mov	r4,r5
   1e004:	dfc00215 	stw	ra,8(sp)
   1e008:	80000015 	stw	zero,0(r16)
   1e00c:	0020e9c0 	call	20e9c <sbrk>
   1e010:	00ffffc4 	movi	r3,-1
   1e014:	10c00526 	beq	r2,r3,1e02c <_sbrk_r+0x44>
   1e018:	dfc00217 	ldw	ra,8(sp)
   1e01c:	dc400117 	ldw	r17,4(sp)
   1e020:	dc000017 	ldw	r16,0(sp)
   1e024:	dec00304 	addi	sp,sp,12
   1e028:	f800283a 	ret
   1e02c:	80c00017 	ldw	r3,0(r16)
   1e030:	183ff926 	beq	r3,zero,1e018 <_sbrk_r+0x30>
   1e034:	88c00015 	stw	r3,0(r17)
   1e038:	dfc00217 	ldw	ra,8(sp)
   1e03c:	dc400117 	ldw	r17,4(sp)
   1e040:	dc000017 	ldw	r16,0(sp)
   1e044:	dec00304 	addi	sp,sp,12
   1e048:	f800283a 	ret

0001e04c <__sread>:
   1e04c:	defffe04 	addi	sp,sp,-8
   1e050:	dc000015 	stw	r16,0(sp)
   1e054:	2821883a 	mov	r16,r5
   1e058:	2940038f 	ldh	r5,14(r5)
   1e05c:	dfc00115 	stw	ra,4(sp)
   1e060:	001e5a00 	call	1e5a0 <_read_r>
   1e064:	10000716 	blt	r2,zero,1e084 <__sread+0x38>
   1e068:	80c01417 	ldw	r3,80(r16)
   1e06c:	1887883a 	add	r3,r3,r2
   1e070:	80c01415 	stw	r3,80(r16)
   1e074:	dfc00117 	ldw	ra,4(sp)
   1e078:	dc000017 	ldw	r16,0(sp)
   1e07c:	dec00204 	addi	sp,sp,8
   1e080:	f800283a 	ret
   1e084:	80c0030b 	ldhu	r3,12(r16)
   1e088:	18fbffcc 	andi	r3,r3,61439
   1e08c:	80c0030d 	sth	r3,12(r16)
   1e090:	dfc00117 	ldw	ra,4(sp)
   1e094:	dc000017 	ldw	r16,0(sp)
   1e098:	dec00204 	addi	sp,sp,8
   1e09c:	f800283a 	ret

0001e0a0 <__swrite>:
   1e0a0:	2880030b 	ldhu	r2,12(r5)
   1e0a4:	defffb04 	addi	sp,sp,-20
   1e0a8:	dcc00315 	stw	r19,12(sp)
   1e0ac:	10c0400c 	andi	r3,r2,256
   1e0b0:	18ffffcc 	andi	r3,r3,65535
   1e0b4:	18e0001c 	xori	r3,r3,32768
   1e0b8:	dc800215 	stw	r18,8(sp)
   1e0bc:	dc400115 	stw	r17,4(sp)
   1e0c0:	dc000015 	stw	r16,0(sp)
   1e0c4:	dfc00415 	stw	ra,16(sp)
   1e0c8:	18e00004 	addi	r3,r3,-32768
   1e0cc:	2821883a 	mov	r16,r5
   1e0d0:	2027883a 	mov	r19,r4
   1e0d4:	3025883a 	mov	r18,r6
   1e0d8:	3823883a 	mov	r17,r7
   1e0dc:	18000526 	beq	r3,zero,1e0f4 <__swrite+0x54>
   1e0e0:	2940038f 	ldh	r5,14(r5)
   1e0e4:	000d883a 	mov	r6,zero
   1e0e8:	01c00084 	movi	r7,2
   1e0ec:	001e5340 	call	1e534 <_lseek_r>
   1e0f0:	8080030b 	ldhu	r2,12(r16)
   1e0f4:	8140038f 	ldh	r5,14(r16)
   1e0f8:	10bbffcc 	andi	r2,r2,61439
   1e0fc:	9809883a 	mov	r4,r19
   1e100:	900d883a 	mov	r6,r18
   1e104:	880f883a 	mov	r7,r17
   1e108:	8080030d 	sth	r2,12(r16)
   1e10c:	dfc00417 	ldw	ra,16(sp)
   1e110:	dcc00317 	ldw	r19,12(sp)
   1e114:	dc800217 	ldw	r18,8(sp)
   1e118:	dc400117 	ldw	r17,4(sp)
   1e11c:	dc000017 	ldw	r16,0(sp)
   1e120:	dec00504 	addi	sp,sp,20
   1e124:	001e18c1 	jmpi	1e18c <_write_r>

0001e128 <__sseek>:
   1e128:	defffe04 	addi	sp,sp,-8
   1e12c:	dc000015 	stw	r16,0(sp)
   1e130:	2821883a 	mov	r16,r5
   1e134:	2940038f 	ldh	r5,14(r5)
   1e138:	dfc00115 	stw	ra,4(sp)
   1e13c:	001e5340 	call	1e534 <_lseek_r>
   1e140:	00ffffc4 	movi	r3,-1
   1e144:	10c00826 	beq	r2,r3,1e168 <__sseek+0x40>
   1e148:	80c0030b 	ldhu	r3,12(r16)
   1e14c:	80801415 	stw	r2,80(r16)
   1e150:	18c40014 	ori	r3,r3,4096
   1e154:	80c0030d 	sth	r3,12(r16)
   1e158:	dfc00117 	ldw	ra,4(sp)
   1e15c:	dc000017 	ldw	r16,0(sp)
   1e160:	dec00204 	addi	sp,sp,8
   1e164:	f800283a 	ret
   1e168:	80c0030b 	ldhu	r3,12(r16)
   1e16c:	18fbffcc 	andi	r3,r3,61439
   1e170:	80c0030d 	sth	r3,12(r16)
   1e174:	dfc00117 	ldw	ra,4(sp)
   1e178:	dc000017 	ldw	r16,0(sp)
   1e17c:	dec00204 	addi	sp,sp,8
   1e180:	f800283a 	ret

0001e184 <__sclose>:
   1e184:	2940038f 	ldh	r5,14(r5)
   1e188:	001e2b41 	jmpi	1e2b4 <_close_r>

0001e18c <_write_r>:
   1e18c:	defffd04 	addi	sp,sp,-12
   1e190:	dc400115 	stw	r17,4(sp)
   1e194:	dc000015 	stw	r16,0(sp)
   1e198:	2023883a 	mov	r17,r4
   1e19c:	040000f4 	movhi	r16,3
   1e1a0:	8419dd04 	addi	r16,r16,26484
   1e1a4:	2809883a 	mov	r4,r5
   1e1a8:	300b883a 	mov	r5,r6
   1e1ac:	380d883a 	mov	r6,r7
   1e1b0:	dfc00215 	stw	ra,8(sp)
   1e1b4:	80000015 	stw	zero,0(r16)
   1e1b8:	00212440 	call	21244 <write>
   1e1bc:	00ffffc4 	movi	r3,-1
   1e1c0:	10c00526 	beq	r2,r3,1e1d8 <_write_r+0x4c>
   1e1c4:	dfc00217 	ldw	ra,8(sp)
   1e1c8:	dc400117 	ldw	r17,4(sp)
   1e1cc:	dc000017 	ldw	r16,0(sp)
   1e1d0:	dec00304 	addi	sp,sp,12
   1e1d4:	f800283a 	ret
   1e1d8:	80c00017 	ldw	r3,0(r16)
   1e1dc:	183ff926 	beq	r3,zero,1e1c4 <_write_r+0x38>
   1e1e0:	88c00015 	stw	r3,0(r17)
   1e1e4:	dfc00217 	ldw	ra,8(sp)
   1e1e8:	dc400117 	ldw	r17,4(sp)
   1e1ec:	dc000017 	ldw	r16,0(sp)
   1e1f0:	dec00304 	addi	sp,sp,12
   1e1f4:	f800283a 	ret

0001e1f8 <_calloc_r>:
   1e1f8:	314b383a 	mul	r5,r6,r5
   1e1fc:	defffe04 	addi	sp,sp,-8
   1e200:	dc000015 	stw	r16,0(sp)
   1e204:	dfc00115 	stw	ra,4(sp)
   1e208:	001c03c0 	call	1c03c <_malloc_r>
   1e20c:	1021883a 	mov	r16,r2
   1e210:	10000c26 	beq	r2,zero,1e244 <_calloc_r+0x4c>
   1e214:	11bfff17 	ldw	r6,-4(r2)
   1e218:	00ffff04 	movi	r3,-4
   1e21c:	00800904 	movi	r2,36
   1e220:	30cc703a 	and	r6,r6,r3
   1e224:	30cd883a 	add	r6,r6,r3
   1e228:	11801436 	bltu	r2,r6,1e27c <_calloc_r+0x84>
   1e22c:	00c004c4 	movi	r3,19
   1e230:	19800936 	bltu	r3,r6,1e258 <_calloc_r+0x60>
   1e234:	8005883a 	mov	r2,r16
   1e238:	10000015 	stw	zero,0(r2)
   1e23c:	10000115 	stw	zero,4(r2)
   1e240:	10000215 	stw	zero,8(r2)
   1e244:	8005883a 	mov	r2,r16
   1e248:	dfc00117 	ldw	ra,4(sp)
   1e24c:	dc000017 	ldw	r16,0(sp)
   1e250:	dec00204 	addi	sp,sp,8
   1e254:	f800283a 	ret
   1e258:	80000015 	stw	zero,0(r16)
   1e25c:	80000115 	stw	zero,4(r16)
   1e260:	00c006c4 	movi	r3,27
   1e264:	19800d2e 	bgeu	r3,r6,1e29c <_calloc_r+0xa4>
   1e268:	80000215 	stw	zero,8(r16)
   1e26c:	80000315 	stw	zero,12(r16)
   1e270:	30800c26 	beq	r6,r2,1e2a4 <_calloc_r+0xac>
   1e274:	80800404 	addi	r2,r16,16
   1e278:	003fef06 	br	1e238 <_calloc_r+0x40>
   1e27c:	8009883a 	mov	r4,r16
   1e280:	000b883a 	mov	r5,zero
   1e284:	0016f600 	call	16f60 <memset>
   1e288:	8005883a 	mov	r2,r16
   1e28c:	dfc00117 	ldw	ra,4(sp)
   1e290:	dc000017 	ldw	r16,0(sp)
   1e294:	dec00204 	addi	sp,sp,8
   1e298:	f800283a 	ret
   1e29c:	80800204 	addi	r2,r16,8
   1e2a0:	003fe506 	br	1e238 <_calloc_r+0x40>
   1e2a4:	80000415 	stw	zero,16(r16)
   1e2a8:	80000515 	stw	zero,20(r16)
   1e2ac:	80800604 	addi	r2,r16,24
   1e2b0:	003fe106 	br	1e238 <_calloc_r+0x40>

0001e2b4 <_close_r>:
   1e2b4:	defffd04 	addi	sp,sp,-12
   1e2b8:	dc400115 	stw	r17,4(sp)
   1e2bc:	dc000015 	stw	r16,0(sp)
   1e2c0:	2023883a 	mov	r17,r4
   1e2c4:	040000f4 	movhi	r16,3
   1e2c8:	8419dd04 	addi	r16,r16,26484
   1e2cc:	2809883a 	mov	r4,r5
   1e2d0:	dfc00215 	stw	ra,8(sp)
   1e2d4:	80000015 	stw	zero,0(r16)
   1e2d8:	00207180 	call	20718 <close>
   1e2dc:	00ffffc4 	movi	r3,-1
   1e2e0:	10c00526 	beq	r2,r3,1e2f8 <_close_r+0x44>
   1e2e4:	dfc00217 	ldw	ra,8(sp)
   1e2e8:	dc400117 	ldw	r17,4(sp)
   1e2ec:	dc000017 	ldw	r16,0(sp)
   1e2f0:	dec00304 	addi	sp,sp,12
   1e2f4:	f800283a 	ret
   1e2f8:	80c00017 	ldw	r3,0(r16)
   1e2fc:	183ff926 	beq	r3,zero,1e2e4 <_close_r+0x30>
   1e300:	88c00015 	stw	r3,0(r17)
   1e304:	dfc00217 	ldw	ra,8(sp)
   1e308:	dc400117 	ldw	r17,4(sp)
   1e30c:	dc000017 	ldw	r16,0(sp)
   1e310:	dec00304 	addi	sp,sp,12
   1e314:	f800283a 	ret

0001e318 <_fclose_r>:
   1e318:	defffc04 	addi	sp,sp,-16
   1e31c:	dc400115 	stw	r17,4(sp)
   1e320:	dc000015 	stw	r16,0(sp)
   1e324:	dfc00315 	stw	ra,12(sp)
   1e328:	dc800215 	stw	r18,8(sp)
   1e32c:	2821883a 	mov	r16,r5
   1e330:	2023883a 	mov	r17,r4
   1e334:	28003426 	beq	r5,zero,1e408 <_fclose_r+0xf0>
   1e338:	001b3280 	call	1b328 <__sfp_lock_acquire>
   1e33c:	88000226 	beq	r17,zero,1e348 <_fclose_r+0x30>
   1e340:	88800e17 	ldw	r2,56(r17)
   1e344:	10003826 	beq	r2,zero,1e428 <_fclose_r+0x110>
   1e348:	8080030f 	ldh	r2,12(r16)
   1e34c:	10002526 	beq	r2,zero,1e3e4 <_fclose_r+0xcc>
   1e350:	8809883a 	mov	r4,r17
   1e354:	800b883a 	mov	r5,r16
   1e358:	001ae780 	call	1ae78 <_fflush_r>
   1e35c:	1025883a 	mov	r18,r2
   1e360:	80800b17 	ldw	r2,44(r16)
   1e364:	10000426 	beq	r2,zero,1e378 <_fclose_r+0x60>
   1e368:	81400717 	ldw	r5,28(r16)
   1e36c:	8809883a 	mov	r4,r17
   1e370:	103ee83a 	callr	r2
   1e374:	10003516 	blt	r2,zero,1e44c <_fclose_r+0x134>
   1e378:	8080030b 	ldhu	r2,12(r16)
   1e37c:	1080200c 	andi	r2,r2,128
   1e380:	10bfffcc 	andi	r2,r2,65535
   1e384:	10a0001c 	xori	r2,r2,32768
   1e388:	10a00004 	addi	r2,r2,-32768
   1e38c:	10002b1e 	bne	r2,zero,1e43c <_fclose_r+0x124>
   1e390:	81400c17 	ldw	r5,48(r16)
   1e394:	28000526 	beq	r5,zero,1e3ac <_fclose_r+0x94>
   1e398:	80801004 	addi	r2,r16,64
   1e39c:	28800226 	beq	r5,r2,1e3a8 <_fclose_r+0x90>
   1e3a0:	8809883a 	mov	r4,r17
   1e3a4:	001b4a40 	call	1b4a4 <_free_r>
   1e3a8:	80000c15 	stw	zero,48(r16)
   1e3ac:	81401117 	ldw	r5,68(r16)
   1e3b0:	28000326 	beq	r5,zero,1e3c0 <_fclose_r+0xa8>
   1e3b4:	8809883a 	mov	r4,r17
   1e3b8:	001b4a40 	call	1b4a4 <_free_r>
   1e3bc:	80001115 	stw	zero,68(r16)
   1e3c0:	8000030d 	sth	zero,12(r16)
   1e3c4:	001b32c0 	call	1b32c <__sfp_lock_release>
   1e3c8:	9005883a 	mov	r2,r18
   1e3cc:	dfc00317 	ldw	ra,12(sp)
   1e3d0:	dc800217 	ldw	r18,8(sp)
   1e3d4:	dc400117 	ldw	r17,4(sp)
   1e3d8:	dc000017 	ldw	r16,0(sp)
   1e3dc:	dec00404 	addi	sp,sp,16
   1e3e0:	f800283a 	ret
   1e3e4:	001b32c0 	call	1b32c <__sfp_lock_release>
   1e3e8:	0025883a 	mov	r18,zero
   1e3ec:	9005883a 	mov	r2,r18
   1e3f0:	dfc00317 	ldw	ra,12(sp)
   1e3f4:	dc800217 	ldw	r18,8(sp)
   1e3f8:	dc400117 	ldw	r17,4(sp)
   1e3fc:	dc000017 	ldw	r16,0(sp)
   1e400:	dec00404 	addi	sp,sp,16
   1e404:	f800283a 	ret
   1e408:	0025883a 	mov	r18,zero
   1e40c:	9005883a 	mov	r2,r18
   1e410:	dfc00317 	ldw	ra,12(sp)
   1e414:	dc800217 	ldw	r18,8(sp)
   1e418:	dc400117 	ldw	r17,4(sp)
   1e41c:	dc000017 	ldw	r16,0(sp)
   1e420:	dec00404 	addi	sp,sp,16
   1e424:	f800283a 	ret
   1e428:	8809883a 	mov	r4,r17
   1e42c:	001b1200 	call	1b120 <__sinit>
   1e430:	8080030f 	ldh	r2,12(r16)
   1e434:	103fc61e 	bne	r2,zero,1e350 <_fclose_r+0x38>
   1e438:	003fea06 	br	1e3e4 <_fclose_r+0xcc>
   1e43c:	81400417 	ldw	r5,16(r16)
   1e440:	8809883a 	mov	r4,r17
   1e444:	001b4a40 	call	1b4a4 <_free_r>
   1e448:	003fd106 	br	1e390 <_fclose_r+0x78>
   1e44c:	04bfffc4 	movi	r18,-1
   1e450:	003fc906 	br	1e378 <_fclose_r+0x60>

0001e454 <fclose>:
   1e454:	008000f4 	movhi	r2,3
   1e458:	1090f704 	addi	r2,r2,17372
   1e45c:	200b883a 	mov	r5,r4
   1e460:	11000017 	ldw	r4,0(r2)
   1e464:	001e3181 	jmpi	1e318 <_fclose_r>

0001e468 <_fstat_r>:
   1e468:	defffd04 	addi	sp,sp,-12
   1e46c:	dc400115 	stw	r17,4(sp)
   1e470:	dc000015 	stw	r16,0(sp)
   1e474:	2023883a 	mov	r17,r4
   1e478:	040000f4 	movhi	r16,3
   1e47c:	8419dd04 	addi	r16,r16,26484
   1e480:	2809883a 	mov	r4,r5
   1e484:	300b883a 	mov	r5,r6
   1e488:	dfc00215 	stw	ra,8(sp)
   1e48c:	80000015 	stw	zero,0(r16)
   1e490:	002085c0 	call	2085c <fstat>
   1e494:	00ffffc4 	movi	r3,-1
   1e498:	10c00526 	beq	r2,r3,1e4b0 <_fstat_r+0x48>
   1e49c:	dfc00217 	ldw	ra,8(sp)
   1e4a0:	dc400117 	ldw	r17,4(sp)
   1e4a4:	dc000017 	ldw	r16,0(sp)
   1e4a8:	dec00304 	addi	sp,sp,12
   1e4ac:	f800283a 	ret
   1e4b0:	80c00017 	ldw	r3,0(r16)
   1e4b4:	183ff926 	beq	r3,zero,1e49c <_fstat_r+0x34>
   1e4b8:	88c00015 	stw	r3,0(r17)
   1e4bc:	dfc00217 	ldw	ra,8(sp)
   1e4c0:	dc400117 	ldw	r17,4(sp)
   1e4c4:	dc000017 	ldw	r16,0(sp)
   1e4c8:	dec00304 	addi	sp,sp,12
   1e4cc:	f800283a 	ret

0001e4d0 <_isatty_r>:
   1e4d0:	defffd04 	addi	sp,sp,-12
   1e4d4:	dc400115 	stw	r17,4(sp)
   1e4d8:	dc000015 	stw	r16,0(sp)
   1e4dc:	2023883a 	mov	r17,r4
   1e4e0:	040000f4 	movhi	r16,3
   1e4e4:	8419dd04 	addi	r16,r16,26484
   1e4e8:	2809883a 	mov	r4,r5
   1e4ec:	dfc00215 	stw	ra,8(sp)
   1e4f0:	80000015 	stw	zero,0(r16)
   1e4f4:	00209580 	call	20958 <isatty>
   1e4f8:	00ffffc4 	movi	r3,-1
   1e4fc:	10c00526 	beq	r2,r3,1e514 <_isatty_r+0x44>
   1e500:	dfc00217 	ldw	ra,8(sp)
   1e504:	dc400117 	ldw	r17,4(sp)
   1e508:	dc000017 	ldw	r16,0(sp)
   1e50c:	dec00304 	addi	sp,sp,12
   1e510:	f800283a 	ret
   1e514:	80c00017 	ldw	r3,0(r16)
   1e518:	183ff926 	beq	r3,zero,1e500 <_isatty_r+0x30>
   1e51c:	88c00015 	stw	r3,0(r17)
   1e520:	dfc00217 	ldw	ra,8(sp)
   1e524:	dc400117 	ldw	r17,4(sp)
   1e528:	dc000017 	ldw	r16,0(sp)
   1e52c:	dec00304 	addi	sp,sp,12
   1e530:	f800283a 	ret

0001e534 <_lseek_r>:
   1e534:	defffd04 	addi	sp,sp,-12
   1e538:	dc400115 	stw	r17,4(sp)
   1e53c:	dc000015 	stw	r16,0(sp)
   1e540:	2023883a 	mov	r17,r4
   1e544:	040000f4 	movhi	r16,3
   1e548:	8419dd04 	addi	r16,r16,26484
   1e54c:	2809883a 	mov	r4,r5
   1e550:	300b883a 	mov	r5,r6
   1e554:	380d883a 	mov	r6,r7
   1e558:	dfc00215 	stw	ra,8(sp)
   1e55c:	80000015 	stw	zero,0(r16)
   1e560:	0020b340 	call	20b34 <lseek>
   1e564:	00ffffc4 	movi	r3,-1
   1e568:	10c00526 	beq	r2,r3,1e580 <_lseek_r+0x4c>
   1e56c:	dfc00217 	ldw	ra,8(sp)
   1e570:	dc400117 	ldw	r17,4(sp)
   1e574:	dc000017 	ldw	r16,0(sp)
   1e578:	dec00304 	addi	sp,sp,12
   1e57c:	f800283a 	ret
   1e580:	80c00017 	ldw	r3,0(r16)
   1e584:	183ff926 	beq	r3,zero,1e56c <_lseek_r+0x38>
   1e588:	88c00015 	stw	r3,0(r17)
   1e58c:	dfc00217 	ldw	ra,8(sp)
   1e590:	dc400117 	ldw	r17,4(sp)
   1e594:	dc000017 	ldw	r16,0(sp)
   1e598:	dec00304 	addi	sp,sp,12
   1e59c:	f800283a 	ret

0001e5a0 <_read_r>:
   1e5a0:	defffd04 	addi	sp,sp,-12
   1e5a4:	dc400115 	stw	r17,4(sp)
   1e5a8:	dc000015 	stw	r16,0(sp)
   1e5ac:	2023883a 	mov	r17,r4
   1e5b0:	040000f4 	movhi	r16,3
   1e5b4:	8419dd04 	addi	r16,r16,26484
   1e5b8:	2809883a 	mov	r4,r5
   1e5bc:	300b883a 	mov	r5,r6
   1e5c0:	380d883a 	mov	r6,r7
   1e5c4:	dfc00215 	stw	ra,8(sp)
   1e5c8:	80000015 	stw	zero,0(r16)
   1e5cc:	0020d0c0 	call	20d0c <read>
   1e5d0:	00ffffc4 	movi	r3,-1
   1e5d4:	10c00526 	beq	r2,r3,1e5ec <_read_r+0x4c>
   1e5d8:	dfc00217 	ldw	ra,8(sp)
   1e5dc:	dc400117 	ldw	r17,4(sp)
   1e5e0:	dc000017 	ldw	r16,0(sp)
   1e5e4:	dec00304 	addi	sp,sp,12
   1e5e8:	f800283a 	ret
   1e5ec:	80c00017 	ldw	r3,0(r16)
   1e5f0:	183ff926 	beq	r3,zero,1e5d8 <_read_r+0x38>
   1e5f4:	88c00015 	stw	r3,0(r17)
   1e5f8:	dfc00217 	ldw	ra,8(sp)
   1e5fc:	dc400117 	ldw	r17,4(sp)
   1e600:	dc000017 	ldw	r16,0(sp)
   1e604:	dec00304 	addi	sp,sp,12
   1e608:	f800283a 	ret

0001e60c <__udivdi3>:
   1e60c:	defff504 	addi	sp,sp,-44
   1e610:	dd000515 	stw	r20,20(sp)
   1e614:	dcc00415 	stw	r19,16(sp)
   1e618:	dc800315 	stw	r18,12(sp)
   1e61c:	dc400215 	stw	r17,8(sp)
   1e620:	dc000115 	stw	r16,4(sp)
   1e624:	dfc00a15 	stw	ra,40(sp)
   1e628:	df000915 	stw	fp,36(sp)
   1e62c:	ddc00815 	stw	r23,32(sp)
   1e630:	dd800715 	stw	r22,28(sp)
   1e634:	dd400615 	stw	r21,24(sp)
   1e638:	2025883a 	mov	r18,r4
   1e63c:	2823883a 	mov	r17,r5
   1e640:	3021883a 	mov	r16,r6
   1e644:	2027883a 	mov	r19,r4
   1e648:	2829883a 	mov	r20,r5
   1e64c:	3800401e 	bne	r7,zero,1e750 <__udivdi3+0x144>
   1e650:	2980602e 	bgeu	r5,r6,1e7d4 <__udivdi3+0x1c8>
   1e654:	00bfffd4 	movui	r2,65535
   1e658:	1180aa36 	bltu	r2,r6,1e904 <__udivdi3+0x2f8>
   1e65c:	00803fc4 	movi	r2,255
   1e660:	11814436 	bltu	r2,r6,1eb74 <__udivdi3+0x568>
   1e664:	0005883a 	mov	r2,zero
   1e668:	0007883a 	mov	r3,zero
   1e66c:	3084d83a 	srl	r2,r6,r2
   1e670:	010000f4 	movhi	r4,3
   1e674:	21005d04 	addi	r4,r4,372
   1e678:	2085883a 	add	r2,r4,r2
   1e67c:	10800003 	ldbu	r2,0(r2)
   1e680:	10c7883a 	add	r3,r2,r3
   1e684:	00800804 	movi	r2,32
   1e688:	10c5c83a 	sub	r2,r2,r3
   1e68c:	10000526 	beq	r2,zero,1e6a4 <__udivdi3+0x98>
   1e690:	88a2983a 	sll	r17,r17,r2
   1e694:	90c6d83a 	srl	r3,r18,r3
   1e698:	30a0983a 	sll	r16,r6,r2
   1e69c:	90a6983a 	sll	r19,r18,r2
   1e6a0:	88e8b03a 	or	r20,r17,r3
   1e6a4:	8022d43a 	srli	r17,r16,16
   1e6a8:	a009883a 	mov	r4,r20
   1e6ac:	857fffcc 	andi	r21,r16,65535
   1e6b0:	880b883a 	mov	r5,r17
   1e6b4:	001ffc80 	call	1ffc8 <__umodsi3>
   1e6b8:	a009883a 	mov	r4,r20
   1e6bc:	880b883a 	mov	r5,r17
   1e6c0:	102d883a 	mov	r22,r2
   1e6c4:	001ffc00 	call	1ffc0 <__udivsi3>
   1e6c8:	b02c943a 	slli	r22,r22,16
   1e6cc:	9806d43a 	srli	r3,r19,16
   1e6d0:	1549383a 	mul	r4,r2,r21
   1e6d4:	1025883a 	mov	r18,r2
   1e6d8:	b0c6b03a 	or	r3,r22,r3
   1e6dc:	1900052e 	bgeu	r3,r4,1e6f4 <__udivdi3+0xe8>
   1e6e0:	1c07883a 	add	r3,r3,r16
   1e6e4:	10bfffc4 	addi	r2,r2,-1
   1e6e8:	1c000136 	bltu	r3,r16,1e6f0 <__udivdi3+0xe4>
   1e6ec:	19013636 	bltu	r3,r4,1ebc8 <__udivdi3+0x5bc>
   1e6f0:	1025883a 	mov	r18,r2
   1e6f4:	1929c83a 	sub	r20,r3,r4
   1e6f8:	a009883a 	mov	r4,r20
   1e6fc:	880b883a 	mov	r5,r17
   1e700:	001ffc80 	call	1ffc8 <__umodsi3>
   1e704:	102d883a 	mov	r22,r2
   1e708:	a009883a 	mov	r4,r20
   1e70c:	880b883a 	mov	r5,r17
   1e710:	001ffc00 	call	1ffc0 <__udivsi3>
   1e714:	b02c943a 	slli	r22,r22,16
   1e718:	156b383a 	mul	r21,r2,r21
   1e71c:	9cffffcc 	andi	r19,r19,65535
   1e720:	b4e6b03a 	or	r19,r22,r19
   1e724:	1009883a 	mov	r4,r2
   1e728:	9d40052e 	bgeu	r19,r21,1e740 <__udivdi3+0x134>
   1e72c:	9c27883a 	add	r19,r19,r16
   1e730:	10bfffc4 	addi	r2,r2,-1
   1e734:	9c00f736 	bltu	r19,r16,1eb14 <__udivdi3+0x508>
   1e738:	9d40f62e 	bgeu	r19,r21,1eb14 <__udivdi3+0x508>
   1e73c:	213fff84 	addi	r4,r4,-2
   1e740:	9004943a 	slli	r2,r18,16
   1e744:	0007883a 	mov	r3,zero
   1e748:	2084b03a 	or	r2,r4,r2
   1e74c:	00001506 	br	1e7a4 <__udivdi3+0x198>
   1e750:	29c06536 	bltu	r5,r7,1e8e8 <__udivdi3+0x2dc>
   1e754:	00bfffd4 	movui	r2,65535
   1e758:	11c0652e 	bgeu	r2,r7,1e8f0 <__udivdi3+0x2e4>
   1e75c:	00804034 	movhi	r2,256
   1e760:	10bfffc4 	addi	r2,r2,-1
   1e764:	11c0f736 	bltu	r2,r7,1eb44 <__udivdi3+0x538>
   1e768:	00c00404 	movi	r3,16
   1e76c:	180b883a 	mov	r5,r3
   1e770:	38c6d83a 	srl	r3,r7,r3
   1e774:	010000f4 	movhi	r4,3
   1e778:	21005d04 	addi	r4,r4,372
   1e77c:	04000804 	movi	r16,32
   1e780:	20c7883a 	add	r3,r4,r3
   1e784:	18800003 	ldbu	r2,0(r3)
   1e788:	1145883a 	add	r2,r2,r5
   1e78c:	80a1c83a 	sub	r16,r16,r2
   1e790:	8000691e 	bne	r16,zero,1e938 <__udivdi3+0x32c>
   1e794:	0007883a 	mov	r3,zero
   1e798:	3c406536 	bltu	r7,r17,1e930 <__udivdi3+0x324>
   1e79c:	9180642e 	bgeu	r18,r6,1e930 <__udivdi3+0x324>
   1e7a0:	0005883a 	mov	r2,zero
   1e7a4:	dfc00a17 	ldw	ra,40(sp)
   1e7a8:	df000917 	ldw	fp,36(sp)
   1e7ac:	ddc00817 	ldw	r23,32(sp)
   1e7b0:	dd800717 	ldw	r22,28(sp)
   1e7b4:	dd400617 	ldw	r21,24(sp)
   1e7b8:	dd000517 	ldw	r20,20(sp)
   1e7bc:	dcc00417 	ldw	r19,16(sp)
   1e7c0:	dc800317 	ldw	r18,12(sp)
   1e7c4:	dc400217 	ldw	r17,8(sp)
   1e7c8:	dc000117 	ldw	r16,4(sp)
   1e7cc:	dec00b04 	addi	sp,sp,44
   1e7d0:	f800283a 	ret
   1e7d4:	3000041e 	bne	r6,zero,1e7e8 <__udivdi3+0x1dc>
   1e7d8:	01000044 	movi	r4,1
   1e7dc:	000b883a 	mov	r5,zero
   1e7e0:	001ffc00 	call	1ffc0 <__udivsi3>
   1e7e4:	1021883a 	mov	r16,r2
   1e7e8:	00bfffd4 	movui	r2,65535
   1e7ec:	14004b2e 	bgeu	r2,r16,1e91c <__udivdi3+0x310>
   1e7f0:	00804034 	movhi	r2,256
   1e7f4:	10bfffc4 	addi	r2,r2,-1
   1e7f8:	1400d836 	bltu	r2,r16,1eb5c <__udivdi3+0x550>
   1e7fc:	00800404 	movi	r2,16
   1e800:	1007883a 	mov	r3,r2
   1e804:	8084d83a 	srl	r2,r16,r2
   1e808:	010000f4 	movhi	r4,3
   1e80c:	21005d04 	addi	r4,r4,372
   1e810:	2085883a 	add	r2,r4,r2
   1e814:	10800003 	ldbu	r2,0(r2)
   1e818:	10c7883a 	add	r3,r2,r3
   1e81c:	00800804 	movi	r2,32
   1e820:	10c5c83a 	sub	r2,r2,r3
   1e824:	1000891e 	bne	r2,zero,1ea4c <__udivdi3+0x440>
   1e828:	8028d43a 	srli	r20,r16,16
   1e82c:	8c23c83a 	sub	r17,r17,r16
   1e830:	84bfffcc 	andi	r18,r16,65535
   1e834:	00c00044 	movi	r3,1
   1e838:	8809883a 	mov	r4,r17
   1e83c:	a00b883a 	mov	r5,r20
   1e840:	d8c00015 	stw	r3,0(sp)
   1e844:	001ffc80 	call	1ffc8 <__umodsi3>
   1e848:	8809883a 	mov	r4,r17
   1e84c:	a00b883a 	mov	r5,r20
   1e850:	102b883a 	mov	r21,r2
   1e854:	001ffc00 	call	1ffc0 <__udivsi3>
   1e858:	a82a943a 	slli	r21,r21,16
   1e85c:	9808d43a 	srli	r4,r19,16
   1e860:	148b383a 	mul	r5,r2,r18
   1e864:	1023883a 	mov	r17,r2
   1e868:	a908b03a 	or	r4,r21,r4
   1e86c:	d8c00017 	ldw	r3,0(sp)
   1e870:	2140052e 	bgeu	r4,r5,1e888 <__udivdi3+0x27c>
   1e874:	2409883a 	add	r4,r4,r16
   1e878:	10bfffc4 	addi	r2,r2,-1
   1e87c:	24000136 	bltu	r4,r16,1e884 <__udivdi3+0x278>
   1e880:	2140ce36 	bltu	r4,r5,1ebbc <__udivdi3+0x5b0>
   1e884:	1023883a 	mov	r17,r2
   1e888:	216bc83a 	sub	r21,r4,r5
   1e88c:	a809883a 	mov	r4,r21
   1e890:	a00b883a 	mov	r5,r20
   1e894:	d8c00015 	stw	r3,0(sp)
   1e898:	001ffc80 	call	1ffc8 <__umodsi3>
   1e89c:	102d883a 	mov	r22,r2
   1e8a0:	a809883a 	mov	r4,r21
   1e8a4:	a00b883a 	mov	r5,r20
   1e8a8:	001ffc00 	call	1ffc0 <__udivsi3>
   1e8ac:	b02c943a 	slli	r22,r22,16
   1e8b0:	14a5383a 	mul	r18,r2,r18
   1e8b4:	9cffffcc 	andi	r19,r19,65535
   1e8b8:	b4e6b03a 	or	r19,r22,r19
   1e8bc:	1009883a 	mov	r4,r2
   1e8c0:	d8c00017 	ldw	r3,0(sp)
   1e8c4:	9c80052e 	bgeu	r19,r18,1e8dc <__udivdi3+0x2d0>
   1e8c8:	9c27883a 	add	r19,r19,r16
   1e8cc:	10bfffc4 	addi	r2,r2,-1
   1e8d0:	9c009236 	bltu	r19,r16,1eb1c <__udivdi3+0x510>
   1e8d4:	9c80912e 	bgeu	r19,r18,1eb1c <__udivdi3+0x510>
   1e8d8:	213fff84 	addi	r4,r4,-2
   1e8dc:	8804943a 	slli	r2,r17,16
   1e8e0:	2084b03a 	or	r2,r4,r2
   1e8e4:	003faf06 	br	1e7a4 <__udivdi3+0x198>
   1e8e8:	0007883a 	mov	r3,zero
   1e8ec:	003fac06 	br	1e7a0 <__udivdi3+0x194>
   1e8f0:	00803fc4 	movi	r2,255
   1e8f4:	11c09636 	bltu	r2,r7,1eb50 <__udivdi3+0x544>
   1e8f8:	0007883a 	mov	r3,zero
   1e8fc:	000b883a 	mov	r5,zero
   1e900:	003f9b06 	br	1e770 <__udivdi3+0x164>
   1e904:	00804034 	movhi	r2,256
   1e908:	10bfffc4 	addi	r2,r2,-1
   1e90c:	11809636 	bltu	r2,r6,1eb68 <__udivdi3+0x55c>
   1e910:	00800404 	movi	r2,16
   1e914:	1007883a 	mov	r3,r2
   1e918:	003f5406 	br	1e66c <__udivdi3+0x60>
   1e91c:	00803fc4 	movi	r2,255
   1e920:	14009736 	bltu	r2,r16,1eb80 <__udivdi3+0x574>
   1e924:	0005883a 	mov	r2,zero
   1e928:	0007883a 	mov	r3,zero
   1e92c:	003fb506 	br	1e804 <__udivdi3+0x1f8>
   1e930:	00800044 	movi	r2,1
   1e934:	003f9b06 	br	1e7a4 <__udivdi3+0x198>
   1e938:	3086d83a 	srl	r3,r6,r2
   1e93c:	3c0e983a 	sll	r7,r7,r16
   1e940:	88aad83a 	srl	r21,r17,r2
   1e944:	9084d83a 	srl	r2,r18,r2
   1e948:	38e6b03a 	or	r19,r7,r3
   1e94c:	9828d43a 	srli	r20,r19,16
   1e950:	8c22983a 	sll	r17,r17,r16
   1e954:	a809883a 	mov	r4,r21
   1e958:	a00b883a 	mov	r5,r20
   1e95c:	342c983a 	sll	r22,r6,r16
   1e960:	88a2b03a 	or	r17,r17,r2
   1e964:	001ffc80 	call	1ffc8 <__umodsi3>
   1e968:	a809883a 	mov	r4,r21
   1e96c:	a00b883a 	mov	r5,r20
   1e970:	1039883a 	mov	fp,r2
   1e974:	001ffc00 	call	1ffc0 <__udivsi3>
   1e978:	102b883a 	mov	r21,r2
   1e97c:	9dffffcc 	andi	r23,r19,65535
   1e980:	e008943a 	slli	r4,fp,16
   1e984:	8804d43a 	srli	r2,r17,16
   1e988:	adcd383a 	mul	r6,r21,r23
   1e98c:	2088b03a 	or	r4,r4,r2
   1e990:	2180042e 	bgeu	r4,r6,1e9a4 <__udivdi3+0x398>
   1e994:	24c9883a 	add	r4,r4,r19
   1e998:	a8bfffc4 	addi	r2,r21,-1
   1e99c:	24c07f2e 	bgeu	r4,r19,1eb9c <__udivdi3+0x590>
   1e9a0:	102b883a 	mov	r21,r2
   1e9a4:	21b9c83a 	sub	fp,r4,r6
   1e9a8:	e009883a 	mov	r4,fp
   1e9ac:	a00b883a 	mov	r5,r20
   1e9b0:	001ffc80 	call	1ffc8 <__umodsi3>
   1e9b4:	e009883a 	mov	r4,fp
   1e9b8:	a00b883a 	mov	r5,r20
   1e9bc:	d8800015 	stw	r2,0(sp)
   1e9c0:	001ffc00 	call	1ffc0 <__udivsi3>
   1e9c4:	d8c00017 	ldw	r3,0(sp)
   1e9c8:	15cb383a 	mul	r5,r2,r23
   1e9cc:	8c7fffcc 	andi	r17,r17,65535
   1e9d0:	1806943a 	slli	r3,r3,16
   1e9d4:	1009883a 	mov	r4,r2
   1e9d8:	1c46b03a 	or	r3,r3,r17
   1e9dc:	1940042e 	bgeu	r3,r5,1e9f0 <__udivdi3+0x3e4>
   1e9e0:	1cc7883a 	add	r3,r3,r19
   1e9e4:	10bfffc4 	addi	r2,r2,-1
   1e9e8:	1cc0682e 	bgeu	r3,r19,1eb8c <__udivdi3+0x580>
   1e9ec:	1009883a 	mov	r4,r2
   1e9f0:	a804943a 	slli	r2,r21,16
   1e9f4:	b1ffffcc 	andi	r7,r22,65535
   1e9f8:	b02cd43a 	srli	r22,r22,16
   1e9fc:	2084b03a 	or	r2,r4,r2
   1ea00:	113fffcc 	andi	r4,r2,65535
   1ea04:	100cd43a 	srli	r6,r2,16
   1ea08:	21d1383a 	mul	r8,r4,r7
   1ea0c:	2589383a 	mul	r4,r4,r22
   1ea10:	31cf383a 	mul	r7,r6,r7
   1ea14:	4012d43a 	srli	r9,r8,16
   1ea18:	1947c83a 	sub	r3,r3,r5
   1ea1c:	3909883a 	add	r4,r7,r4
   1ea20:	2249883a 	add	r4,r4,r9
   1ea24:	35ad383a 	mul	r22,r6,r22
   1ea28:	21c0022e 	bgeu	r4,r7,1ea34 <__udivdi3+0x428>
   1ea2c:	01400074 	movhi	r5,1
   1ea30:	b16d883a 	add	r22,r22,r5
   1ea34:	200ad43a 	srli	r5,r4,16
   1ea38:	b16d883a 	add	r22,r22,r5
   1ea3c:	1d803e36 	bltu	r3,r22,1eb38 <__udivdi3+0x52c>
   1ea40:	1d803826 	beq	r3,r22,1eb24 <__udivdi3+0x518>
   1ea44:	0007883a 	mov	r3,zero
   1ea48:	003f5606 	br	1e7a4 <__udivdi3+0x198>
   1ea4c:	80a0983a 	sll	r16,r16,r2
   1ea50:	88ead83a 	srl	r21,r17,r3
   1ea54:	90c6d83a 	srl	r3,r18,r3
   1ea58:	8028d43a 	srli	r20,r16,16
   1ea5c:	88a2983a 	sll	r17,r17,r2
   1ea60:	a809883a 	mov	r4,r21
   1ea64:	a00b883a 	mov	r5,r20
   1ea68:	88ecb03a 	or	r22,r17,r3
   1ea6c:	90a6983a 	sll	r19,r18,r2
   1ea70:	001ffc80 	call	1ffc8 <__umodsi3>
   1ea74:	a809883a 	mov	r4,r21
   1ea78:	a00b883a 	mov	r5,r20
   1ea7c:	1023883a 	mov	r17,r2
   1ea80:	001ffc00 	call	1ffc0 <__udivsi3>
   1ea84:	102b883a 	mov	r21,r2
   1ea88:	84bfffcc 	andi	r18,r16,65535
   1ea8c:	8808943a 	slli	r4,r17,16
   1ea90:	b004d43a 	srli	r2,r22,16
   1ea94:	ac87383a 	mul	r3,r21,r18
   1ea98:	2088b03a 	or	r4,r4,r2
   1ea9c:	20c0062e 	bgeu	r4,r3,1eab8 <__udivdi3+0x4ac>
   1eaa0:	2409883a 	add	r4,r4,r16
   1eaa4:	a8bfffc4 	addi	r2,r21,-1
   1eaa8:	24004236 	bltu	r4,r16,1ebb4 <__udivdi3+0x5a8>
   1eaac:	20c0412e 	bgeu	r4,r3,1ebb4 <__udivdi3+0x5a8>
   1eab0:	ad7fff84 	addi	r21,r21,-2
   1eab4:	2409883a 	add	r4,r4,r16
   1eab8:	20efc83a 	sub	r23,r4,r3
   1eabc:	b809883a 	mov	r4,r23
   1eac0:	a00b883a 	mov	r5,r20
   1eac4:	001ffc80 	call	1ffc8 <__umodsi3>
   1eac8:	1023883a 	mov	r17,r2
   1eacc:	a00b883a 	mov	r5,r20
   1ead0:	b809883a 	mov	r4,r23
   1ead4:	001ffc00 	call	1ffc0 <__udivsi3>
   1ead8:	8822943a 	slli	r17,r17,16
   1eadc:	148b383a 	mul	r5,r2,r18
   1eae0:	b5bfffcc 	andi	r22,r22,65535
   1eae4:	8da2b03a 	or	r17,r17,r22
   1eae8:	8940062e 	bgeu	r17,r5,1eb04 <__udivdi3+0x4f8>
   1eaec:	8c23883a 	add	r17,r17,r16
   1eaf0:	10ffffc4 	addi	r3,r2,-1
   1eaf4:	8c002d36 	bltu	r17,r16,1ebac <__udivdi3+0x5a0>
   1eaf8:	89402c2e 	bgeu	r17,r5,1ebac <__udivdi3+0x5a0>
   1eafc:	10bfff84 	addi	r2,r2,-2
   1eb00:	8c23883a 	add	r17,r17,r16
   1eb04:	a806943a 	slli	r3,r21,16
   1eb08:	8963c83a 	sub	r17,r17,r5
   1eb0c:	10c6b03a 	or	r3,r2,r3
   1eb10:	003f4906 	br	1e838 <__udivdi3+0x22c>
   1eb14:	1009883a 	mov	r4,r2
   1eb18:	003f0906 	br	1e740 <__udivdi3+0x134>
   1eb1c:	1009883a 	mov	r4,r2
   1eb20:	003f6e06 	br	1e8dc <__udivdi3+0x2d0>
   1eb24:	2008943a 	slli	r4,r4,16
   1eb28:	9420983a 	sll	r16,r18,r16
   1eb2c:	423fffcc 	andi	r8,r8,65535
   1eb30:	2209883a 	add	r4,r4,r8
   1eb34:	813fc32e 	bgeu	r16,r4,1ea44 <__udivdi3+0x438>
   1eb38:	10bfffc4 	addi	r2,r2,-1
   1eb3c:	0007883a 	mov	r3,zero
   1eb40:	003f1806 	br	1e7a4 <__udivdi3+0x198>
   1eb44:	00c00604 	movi	r3,24
   1eb48:	180b883a 	mov	r5,r3
   1eb4c:	003f0806 	br	1e770 <__udivdi3+0x164>
   1eb50:	00c00204 	movi	r3,8
   1eb54:	180b883a 	mov	r5,r3
   1eb58:	003f0506 	br	1e770 <__udivdi3+0x164>
   1eb5c:	00800604 	movi	r2,24
   1eb60:	1007883a 	mov	r3,r2
   1eb64:	003f2706 	br	1e804 <__udivdi3+0x1f8>
   1eb68:	00800604 	movi	r2,24
   1eb6c:	1007883a 	mov	r3,r2
   1eb70:	003ebe06 	br	1e66c <__udivdi3+0x60>
   1eb74:	00800204 	movi	r2,8
   1eb78:	1007883a 	mov	r3,r2
   1eb7c:	003ebb06 	br	1e66c <__udivdi3+0x60>
   1eb80:	00800204 	movi	r2,8
   1eb84:	1007883a 	mov	r3,r2
   1eb88:	003f1e06 	br	1e804 <__udivdi3+0x1f8>
   1eb8c:	197f972e 	bgeu	r3,r5,1e9ec <__udivdi3+0x3e0>
   1eb90:	213fff84 	addi	r4,r4,-2
   1eb94:	1cc7883a 	add	r3,r3,r19
   1eb98:	003f9506 	br	1e9f0 <__udivdi3+0x3e4>
   1eb9c:	21bf802e 	bgeu	r4,r6,1e9a0 <__udivdi3+0x394>
   1eba0:	ad7fff84 	addi	r21,r21,-2
   1eba4:	24c9883a 	add	r4,r4,r19
   1eba8:	003f7e06 	br	1e9a4 <__udivdi3+0x398>
   1ebac:	1805883a 	mov	r2,r3
   1ebb0:	003fd406 	br	1eb04 <__udivdi3+0x4f8>
   1ebb4:	102b883a 	mov	r21,r2
   1ebb8:	003fbf06 	br	1eab8 <__udivdi3+0x4ac>
   1ebbc:	8c7fff84 	addi	r17,r17,-2
   1ebc0:	2409883a 	add	r4,r4,r16
   1ebc4:	003f3006 	br	1e888 <__udivdi3+0x27c>
   1ebc8:	94bfff84 	addi	r18,r18,-2
   1ebcc:	1c07883a 	add	r3,r3,r16
   1ebd0:	003ec806 	br	1e6f4 <__udivdi3+0xe8>

0001ebd4 <__umoddi3>:
   1ebd4:	defff504 	addi	sp,sp,-44
   1ebd8:	dd000515 	stw	r20,20(sp)
   1ebdc:	dcc00415 	stw	r19,16(sp)
   1ebe0:	dc800315 	stw	r18,12(sp)
   1ebe4:	dc400215 	stw	r17,8(sp)
   1ebe8:	dc000115 	stw	r16,4(sp)
   1ebec:	dfc00a15 	stw	ra,40(sp)
   1ebf0:	df000915 	stw	fp,36(sp)
   1ebf4:	ddc00815 	stw	r23,32(sp)
   1ebf8:	dd800715 	stw	r22,28(sp)
   1ebfc:	dd400615 	stw	r21,24(sp)
   1ec00:	2025883a 	mov	r18,r4
   1ec04:	2823883a 	mov	r17,r5
   1ec08:	3021883a 	mov	r16,r6
   1ec0c:	2027883a 	mov	r19,r4
   1ec10:	2829883a 	mov	r20,r5
   1ec14:	3800351e 	bne	r7,zero,1ecec <__umoddi3+0x118>
   1ec18:	29804d2e 	bgeu	r5,r6,1ed50 <__umoddi3+0x17c>
   1ec1c:	00bfffd4 	movui	r2,65535
   1ec20:	11809a36 	bltu	r2,r6,1ee8c <__umoddi3+0x2b8>
   1ec24:	00803fc4 	movi	r2,255
   1ec28:	11813936 	bltu	r2,r6,1f110 <__umoddi3+0x53c>
   1ec2c:	0005883a 	mov	r2,zero
   1ec30:	0009883a 	mov	r4,zero
   1ec34:	3084d83a 	srl	r2,r6,r2
   1ec38:	00c000f4 	movhi	r3,3
   1ec3c:	18c05d04 	addi	r3,r3,372
   1ec40:	05400804 	movi	r21,32
   1ec44:	1885883a 	add	r2,r3,r2
   1ec48:	10800003 	ldbu	r2,0(r2)
   1ec4c:	1109883a 	add	r4,r2,r4
   1ec50:	a92bc83a 	sub	r21,r21,r4
   1ec54:	a800ec26 	beq	r21,zero,1f008 <__umoddi3+0x434>
   1ec58:	8d62983a 	sll	r17,r17,r21
   1ec5c:	9108d83a 	srl	r4,r18,r4
   1ec60:	3560983a 	sll	r16,r6,r21
   1ec64:	9566983a 	sll	r19,r18,r21
   1ec68:	8928b03a 	or	r20,r17,r4
   1ec6c:	8022d43a 	srli	r17,r16,16
   1ec70:	a009883a 	mov	r4,r20
   1ec74:	84bfffcc 	andi	r18,r16,65535
   1ec78:	880b883a 	mov	r5,r17
   1ec7c:	001ffc80 	call	1ffc8 <__umodsi3>
   1ec80:	a009883a 	mov	r4,r20
   1ec84:	880b883a 	mov	r5,r17
   1ec88:	102d883a 	mov	r22,r2
   1ec8c:	001ffc00 	call	1ffc0 <__udivsi3>
   1ec90:	b02c943a 	slli	r22,r22,16
   1ec94:	9806d43a 	srli	r3,r19,16
   1ec98:	1485383a 	mul	r2,r2,r18
   1ec9c:	b0c6b03a 	or	r3,r22,r3
   1eca0:	1880042e 	bgeu	r3,r2,1ecb4 <__umoddi3+0xe0>
   1eca4:	1c07883a 	add	r3,r3,r16
   1eca8:	1c000236 	bltu	r3,r16,1ecb4 <__umoddi3+0xe0>
   1ecac:	1880012e 	bgeu	r3,r2,1ecb4 <__umoddi3+0xe0>
   1ecb0:	1c07883a 	add	r3,r3,r16
   1ecb4:	18a9c83a 	sub	r20,r3,r2
   1ecb8:	a009883a 	mov	r4,r20
   1ecbc:	880b883a 	mov	r5,r17
   1ecc0:	001ffc80 	call	1ffc8 <__umodsi3>
   1ecc4:	102d883a 	mov	r22,r2
   1ecc8:	a009883a 	mov	r4,r20
   1eccc:	880b883a 	mov	r5,r17
   1ecd0:	001ffc00 	call	1ffc0 <__udivsi3>
   1ecd4:	b02c943a 	slli	r22,r22,16
   1ecd8:	1485383a 	mul	r2,r2,r18
   1ecdc:	9cffffcc 	andi	r19,r19,65535
   1ece0:	b4e6b03a 	or	r19,r22,r19
   1ece4:	9880522e 	bgeu	r19,r2,1ee30 <__umoddi3+0x25c>
   1ece8:	00004d06 	br	1ee20 <__umoddi3+0x24c>
   1ecec:	29c05436 	bltu	r5,r7,1ee40 <__umoddi3+0x26c>
   1ecf0:	00bfffd4 	movui	r2,65535
   1ecf4:	11c0602e 	bgeu	r2,r7,1ee78 <__umoddi3+0x2a4>
   1ecf8:	00804034 	movhi	r2,256
   1ecfc:	10bfffc4 	addi	r2,r2,-1
   1ed00:	11c0f736 	bltu	r2,r7,1f0e0 <__umoddi3+0x50c>
   1ed04:	00c00404 	movi	r3,16
   1ed08:	1827883a 	mov	r19,r3
   1ed0c:	38c6d83a 	srl	r3,r7,r3
   1ed10:	010000f4 	movhi	r4,3
   1ed14:	21005d04 	addi	r4,r4,372
   1ed18:	04000804 	movi	r16,32
   1ed1c:	20c7883a 	add	r3,r4,r3
   1ed20:	18800003 	ldbu	r2,0(r3)
   1ed24:	14e7883a 	add	r19,r2,r19
   1ed28:	84e1c83a 	sub	r16,r16,r19
   1ed2c:	8000621e 	bne	r16,zero,1eeb8 <__umoddi3+0x2e4>
   1ed30:	3c400136 	bltu	r7,r17,1ed38 <__umoddi3+0x164>
   1ed34:	91810336 	bltu	r18,r6,1f144 <__umoddi3+0x570>
   1ed38:	9185c83a 	sub	r2,r18,r6
   1ed3c:	89e3c83a 	sub	r17,r17,r7
   1ed40:	90a5803a 	cmpltu	r18,r18,r2
   1ed44:	8ca9c83a 	sub	r20,r17,r18
   1ed48:	a007883a 	mov	r3,r20
   1ed4c:	00003e06 	br	1ee48 <__umoddi3+0x274>
   1ed50:	3000041e 	bne	r6,zero,1ed64 <__umoddi3+0x190>
   1ed54:	01000044 	movi	r4,1
   1ed58:	000b883a 	mov	r5,zero
   1ed5c:	001ffc00 	call	1ffc0 <__udivsi3>
   1ed60:	1021883a 	mov	r16,r2
   1ed64:	00bfffd4 	movui	r2,65535
   1ed68:	14004e2e 	bgeu	r2,r16,1eea4 <__umoddi3+0x2d0>
   1ed6c:	00804034 	movhi	r2,256
   1ed70:	10bfffc4 	addi	r2,r2,-1
   1ed74:	1400e336 	bltu	r2,r16,1f104 <__umoddi3+0x530>
   1ed78:	00800404 	movi	r2,16
   1ed7c:	1007883a 	mov	r3,r2
   1ed80:	8084d83a 	srl	r2,r16,r2
   1ed84:	010000f4 	movhi	r4,3
   1ed88:	21005d04 	addi	r4,r4,372
   1ed8c:	05400804 	movi	r21,32
   1ed90:	2085883a 	add	r2,r4,r2
   1ed94:	10800003 	ldbu	r2,0(r2)
   1ed98:	10c7883a 	add	r3,r2,r3
   1ed9c:	a8ebc83a 	sub	r21,r21,r3
   1eda0:	a8009b1e 	bne	r21,zero,1f010 <__umoddi3+0x43c>
   1eda4:	8028d43a 	srli	r20,r16,16
   1eda8:	8c23c83a 	sub	r17,r17,r16
   1edac:	85bfffcc 	andi	r22,r16,65535
   1edb0:	8809883a 	mov	r4,r17
   1edb4:	a00b883a 	mov	r5,r20
   1edb8:	001ffc80 	call	1ffc8 <__umodsi3>
   1edbc:	8809883a 	mov	r4,r17
   1edc0:	a00b883a 	mov	r5,r20
   1edc4:	1025883a 	mov	r18,r2
   1edc8:	001ffc00 	call	1ffc0 <__udivsi3>
   1edcc:	9024943a 	slli	r18,r18,16
   1edd0:	9806d43a 	srli	r3,r19,16
   1edd4:	1585383a 	mul	r2,r2,r22
   1edd8:	90c6b03a 	or	r3,r18,r3
   1eddc:	1880032e 	bgeu	r3,r2,1edec <__umoddi3+0x218>
   1ede0:	1c07883a 	add	r3,r3,r16
   1ede4:	1c000136 	bltu	r3,r16,1edec <__umoddi3+0x218>
   1ede8:	1880d436 	bltu	r3,r2,1f13c <__umoddi3+0x568>
   1edec:	18a3c83a 	sub	r17,r3,r2
   1edf0:	8809883a 	mov	r4,r17
   1edf4:	a00b883a 	mov	r5,r20
   1edf8:	001ffc80 	call	1ffc8 <__umodsi3>
   1edfc:	1025883a 	mov	r18,r2
   1ee00:	8809883a 	mov	r4,r17
   1ee04:	a00b883a 	mov	r5,r20
   1ee08:	001ffc00 	call	1ffc0 <__udivsi3>
   1ee0c:	9024943a 	slli	r18,r18,16
   1ee10:	1585383a 	mul	r2,r2,r22
   1ee14:	9cffffcc 	andi	r19,r19,65535
   1ee18:	94e6b03a 	or	r19,r18,r19
   1ee1c:	9880042e 	bgeu	r19,r2,1ee30 <__umoddi3+0x25c>
   1ee20:	9c27883a 	add	r19,r19,r16
   1ee24:	9c000236 	bltu	r19,r16,1ee30 <__umoddi3+0x25c>
   1ee28:	9880012e 	bgeu	r19,r2,1ee30 <__umoddi3+0x25c>
   1ee2c:	9c27883a 	add	r19,r19,r16
   1ee30:	98a7c83a 	sub	r19,r19,r2
   1ee34:	9d44d83a 	srl	r2,r19,r21
   1ee38:	0007883a 	mov	r3,zero
   1ee3c:	00000206 	br	1ee48 <__umoddi3+0x274>
   1ee40:	2005883a 	mov	r2,r4
   1ee44:	2807883a 	mov	r3,r5
   1ee48:	dfc00a17 	ldw	ra,40(sp)
   1ee4c:	df000917 	ldw	fp,36(sp)
   1ee50:	ddc00817 	ldw	r23,32(sp)
   1ee54:	dd800717 	ldw	r22,28(sp)
   1ee58:	dd400617 	ldw	r21,24(sp)
   1ee5c:	dd000517 	ldw	r20,20(sp)
   1ee60:	dcc00417 	ldw	r19,16(sp)
   1ee64:	dc800317 	ldw	r18,12(sp)
   1ee68:	dc400217 	ldw	r17,8(sp)
   1ee6c:	dc000117 	ldw	r16,4(sp)
   1ee70:	dec00b04 	addi	sp,sp,44
   1ee74:	f800283a 	ret
   1ee78:	00803fc4 	movi	r2,255
   1ee7c:	11c09536 	bltu	r2,r7,1f0d4 <__umoddi3+0x500>
   1ee80:	0007883a 	mov	r3,zero
   1ee84:	0027883a 	mov	r19,zero
   1ee88:	003fa006 	br	1ed0c <__umoddi3+0x138>
   1ee8c:	00804034 	movhi	r2,256
   1ee90:	10bfffc4 	addi	r2,r2,-1
   1ee94:	11809536 	bltu	r2,r6,1f0ec <__umoddi3+0x518>
   1ee98:	00800404 	movi	r2,16
   1ee9c:	1009883a 	mov	r4,r2
   1eea0:	003f6406 	br	1ec34 <__umoddi3+0x60>
   1eea4:	00803fc4 	movi	r2,255
   1eea8:	14009336 	bltu	r2,r16,1f0f8 <__umoddi3+0x524>
   1eeac:	0005883a 	mov	r2,zero
   1eeb0:	0007883a 	mov	r3,zero
   1eeb4:	003fb206 	br	1ed80 <__umoddi3+0x1ac>
   1eeb8:	34c4d83a 	srl	r2,r6,r19
   1eebc:	3c0e983a 	sll	r7,r7,r16
   1eec0:	8ceed83a 	srl	r23,r17,r19
   1eec4:	8c22983a 	sll	r17,r17,r16
   1eec8:	38a8b03a 	or	r20,r7,r2
   1eecc:	a02ad43a 	srli	r21,r20,16
   1eed0:	94c4d83a 	srl	r2,r18,r19
   1eed4:	b809883a 	mov	r4,r23
   1eed8:	a80b883a 	mov	r5,r21
   1eedc:	88a2b03a 	or	r17,r17,r2
   1eee0:	342c983a 	sll	r22,r6,r16
   1eee4:	001ffc80 	call	1ffc8 <__umodsi3>
   1eee8:	b809883a 	mov	r4,r23
   1eeec:	a80b883a 	mov	r5,r21
   1eef0:	d8800015 	stw	r2,0(sp)
   1eef4:	001ffc00 	call	1ffc0 <__udivsi3>
   1eef8:	d8c00017 	ldw	r3,0(sp)
   1eefc:	102f883a 	mov	r23,r2
   1ef00:	a73fffcc 	andi	fp,r20,65535
   1ef04:	180a943a 	slli	r5,r3,16
   1ef08:	8804d43a 	srli	r2,r17,16
   1ef0c:	bf09383a 	mul	r4,r23,fp
   1ef10:	9424983a 	sll	r18,r18,r16
   1ef14:	288ab03a 	or	r5,r5,r2
   1ef18:	2900042e 	bgeu	r5,r4,1ef2c <__umoddi3+0x358>
   1ef1c:	2d0b883a 	add	r5,r5,r20
   1ef20:	b8bfffc4 	addi	r2,r23,-1
   1ef24:	2d00812e 	bgeu	r5,r20,1f12c <__umoddi3+0x558>
   1ef28:	102f883a 	mov	r23,r2
   1ef2c:	2907c83a 	sub	r3,r5,r4
   1ef30:	1809883a 	mov	r4,r3
   1ef34:	a80b883a 	mov	r5,r21
   1ef38:	d8c00015 	stw	r3,0(sp)
   1ef3c:	001ffc80 	call	1ffc8 <__umodsi3>
   1ef40:	d8c00017 	ldw	r3,0(sp)
   1ef44:	a80b883a 	mov	r5,r21
   1ef48:	d8800015 	stw	r2,0(sp)
   1ef4c:	1809883a 	mov	r4,r3
   1ef50:	001ffc00 	call	1ffc0 <__udivsi3>
   1ef54:	d9800017 	ldw	r6,0(sp)
   1ef58:	8c7fffcc 	andi	r17,r17,65535
   1ef5c:	3008943a 	slli	r4,r6,16
   1ef60:	170d383a 	mul	r6,r2,fp
   1ef64:	2448b03a 	or	r4,r4,r17
   1ef68:	2180042e 	bgeu	r4,r6,1ef7c <__umoddi3+0x3a8>
   1ef6c:	2509883a 	add	r4,r4,r20
   1ef70:	10ffffc4 	addi	r3,r2,-1
   1ef74:	2500692e 	bgeu	r4,r20,1f11c <__umoddi3+0x548>
   1ef78:	1805883a 	mov	r2,r3
   1ef7c:	b82e943a 	slli	r23,r23,16
   1ef80:	b010d43a 	srli	r8,r22,16
   1ef84:	b1ffffcc 	andi	r7,r22,65535
   1ef88:	15eeb03a 	or	r23,r2,r23
   1ef8c:	b8bfffcc 	andi	r2,r23,65535
   1ef90:	b82ed43a 	srli	r23,r23,16
   1ef94:	11c7383a 	mul	r3,r2,r7
   1ef98:	1205383a 	mul	r2,r2,r8
   1ef9c:	b9cf383a 	mul	r7,r23,r7
   1efa0:	400b883a 	mov	r5,r8
   1efa4:	1810d43a 	srli	r8,r3,16
   1efa8:	3885883a 	add	r2,r7,r2
   1efac:	2189c83a 	sub	r4,r4,r6
   1efb0:	1205883a 	add	r2,r2,r8
   1efb4:	b94b383a 	mul	r5,r23,r5
   1efb8:	11c0022e 	bgeu	r2,r7,1efc4 <__umoddi3+0x3f0>
   1efbc:	01800074 	movhi	r6,1
   1efc0:	298b883a 	add	r5,r5,r6
   1efc4:	100cd43a 	srli	r6,r2,16
   1efc8:	1004943a 	slli	r2,r2,16
   1efcc:	18ffffcc 	andi	r3,r3,65535
   1efd0:	298b883a 	add	r5,r5,r6
   1efd4:	10c5883a 	add	r2,r2,r3
   1efd8:	21403836 	bltu	r4,r5,1f0bc <__umoddi3+0x4e8>
   1efdc:	21405c26 	beq	r4,r5,1f150 <__umoddi3+0x57c>
   1efe0:	2147c83a 	sub	r3,r4,r5
   1efe4:	102d883a 	mov	r22,r2
   1efe8:	95adc83a 	sub	r22,r18,r22
   1efec:	95a5803a 	cmpltu	r18,r18,r22
   1eff0:	1c87c83a 	sub	r3,r3,r18
   1eff4:	1cc4983a 	sll	r2,r3,r19
   1eff8:	b42cd83a 	srl	r22,r22,r16
   1effc:	1c06d83a 	srl	r3,r3,r16
   1f000:	1584b03a 	or	r2,r2,r22
   1f004:	003f9006 	br	1ee48 <__umoddi3+0x274>
   1f008:	002b883a 	mov	r21,zero
   1f00c:	003f1706 	br	1ec6c <__umoddi3+0x98>
   1f010:	8560983a 	sll	r16,r16,r21
   1f014:	88e6d83a 	srl	r19,r17,r3
   1f018:	90c6d83a 	srl	r3,r18,r3
   1f01c:	8028d43a 	srli	r20,r16,16
   1f020:	8d62983a 	sll	r17,r17,r21
   1f024:	9809883a 	mov	r4,r19
   1f028:	a00b883a 	mov	r5,r20
   1f02c:	88eeb03a 	or	r23,r17,r3
   1f030:	001ffc80 	call	1ffc8 <__umodsi3>
   1f034:	9809883a 	mov	r4,r19
   1f038:	a00b883a 	mov	r5,r20
   1f03c:	1023883a 	mov	r17,r2
   1f040:	001ffc00 	call	1ffc0 <__udivsi3>
   1f044:	85bfffcc 	andi	r22,r16,65535
   1f048:	880a943a 	slli	r5,r17,16
   1f04c:	b806d43a 	srli	r3,r23,16
   1f050:	1585383a 	mul	r2,r2,r22
   1f054:	9566983a 	sll	r19,r18,r21
   1f058:	28cab03a 	or	r5,r5,r3
   1f05c:	2880042e 	bgeu	r5,r2,1f070 <__umoddi3+0x49c>
   1f060:	2c0b883a 	add	r5,r5,r16
   1f064:	2c000236 	bltu	r5,r16,1f070 <__umoddi3+0x49c>
   1f068:	2880012e 	bgeu	r5,r2,1f070 <__umoddi3+0x49c>
   1f06c:	2c0b883a 	add	r5,r5,r16
   1f070:	28a5c83a 	sub	r18,r5,r2
   1f074:	9009883a 	mov	r4,r18
   1f078:	a00b883a 	mov	r5,r20
   1f07c:	001ffc80 	call	1ffc8 <__umodsi3>
   1f080:	1023883a 	mov	r17,r2
   1f084:	9009883a 	mov	r4,r18
   1f088:	a00b883a 	mov	r5,r20
   1f08c:	001ffc00 	call	1ffc0 <__udivsi3>
   1f090:	8822943a 	slli	r17,r17,16
   1f094:	1585383a 	mul	r2,r2,r22
   1f098:	bdffffcc 	andi	r23,r23,65535
   1f09c:	8de2b03a 	or	r17,r17,r23
   1f0a0:	8880042e 	bgeu	r17,r2,1f0b4 <__umoddi3+0x4e0>
   1f0a4:	8c23883a 	add	r17,r17,r16
   1f0a8:	8c000236 	bltu	r17,r16,1f0b4 <__umoddi3+0x4e0>
   1f0ac:	8880012e 	bgeu	r17,r2,1f0b4 <__umoddi3+0x4e0>
   1f0b0:	8c23883a 	add	r17,r17,r16
   1f0b4:	88a3c83a 	sub	r17,r17,r2
   1f0b8:	003f3d06 	br	1edb0 <__umoddi3+0x1dc>
   1f0bc:	15adc83a 	sub	r22,r2,r22
   1f0c0:	2d07c83a 	sub	r3,r5,r20
   1f0c4:	1585803a 	cmpltu	r2,r2,r22
   1f0c8:	1887c83a 	sub	r3,r3,r2
   1f0cc:	20c7c83a 	sub	r3,r4,r3
   1f0d0:	003fc506 	br	1efe8 <__umoddi3+0x414>
   1f0d4:	00c00204 	movi	r3,8
   1f0d8:	1827883a 	mov	r19,r3
   1f0dc:	003f0b06 	br	1ed0c <__umoddi3+0x138>
   1f0e0:	00c00604 	movi	r3,24
   1f0e4:	1827883a 	mov	r19,r3
   1f0e8:	003f0806 	br	1ed0c <__umoddi3+0x138>
   1f0ec:	00800604 	movi	r2,24
   1f0f0:	1009883a 	mov	r4,r2
   1f0f4:	003ecf06 	br	1ec34 <__umoddi3+0x60>
   1f0f8:	00800204 	movi	r2,8
   1f0fc:	1007883a 	mov	r3,r2
   1f100:	003f1f06 	br	1ed80 <__umoddi3+0x1ac>
   1f104:	00800604 	movi	r2,24
   1f108:	1007883a 	mov	r3,r2
   1f10c:	003f1c06 	br	1ed80 <__umoddi3+0x1ac>
   1f110:	00800204 	movi	r2,8
   1f114:	1009883a 	mov	r4,r2
   1f118:	003ec606 	br	1ec34 <__umoddi3+0x60>
   1f11c:	21bf962e 	bgeu	r4,r6,1ef78 <__umoddi3+0x3a4>
   1f120:	10bfff84 	addi	r2,r2,-2
   1f124:	2509883a 	add	r4,r4,r20
   1f128:	003f9406 	br	1ef7c <__umoddi3+0x3a8>
   1f12c:	293f7e2e 	bgeu	r5,r4,1ef28 <__umoddi3+0x354>
   1f130:	bdffff84 	addi	r23,r23,-2
   1f134:	2d0b883a 	add	r5,r5,r20
   1f138:	003f7c06 	br	1ef2c <__umoddi3+0x358>
   1f13c:	1c07883a 	add	r3,r3,r16
   1f140:	003f2a06 	br	1edec <__umoddi3+0x218>
   1f144:	9005883a 	mov	r2,r18
   1f148:	a007883a 	mov	r3,r20
   1f14c:	003f3e06 	br	1ee48 <__umoddi3+0x274>
   1f150:	90bfda36 	bltu	r18,r2,1f0bc <__umoddi3+0x4e8>
   1f154:	102d883a 	mov	r22,r2
   1f158:	0007883a 	mov	r3,zero
   1f15c:	003fa206 	br	1efe8 <__umoddi3+0x414>

0001f160 <_fpadd_parts>:
   1f160:	2005883a 	mov	r2,r4
   1f164:	21000017 	ldw	r4,0(r4)
   1f168:	01c00044 	movi	r7,1
   1f16c:	3900622e 	bgeu	r7,r4,1f2f8 <_fpadd_parts+0x198>
   1f170:	28c00017 	ldw	r3,0(r5)
   1f174:	38c05f2e 	bgeu	r7,r3,1f2f4 <_fpadd_parts+0x194>
   1f178:	01c00104 	movi	r7,4
   1f17c:	21c0c626 	beq	r4,r7,1f498 <_fpadd_parts+0x338>
   1f180:	19c05c26 	beq	r3,r7,1f2f4 <_fpadd_parts+0x194>
   1f184:	01c00084 	movi	r7,2
   1f188:	19c06b26 	beq	r3,r7,1f338 <_fpadd_parts+0x1d8>
   1f18c:	21c05926 	beq	r4,r7,1f2f4 <_fpadd_parts+0x194>
   1f190:	11c00217 	ldw	r7,8(r2)
   1f194:	2ac00217 	ldw	r11,8(r5)
   1f198:	13000317 	ldw	r12,12(r2)
   1f19c:	13400417 	ldw	r13,16(r2)
   1f1a0:	3ac9c83a 	sub	r4,r7,r11
   1f1a4:	2a000317 	ldw	r8,12(r5)
   1f1a8:	2a400417 	ldw	r9,16(r5)
   1f1ac:	2015883a 	mov	r10,r4
   1f1b0:	20007516 	blt	r4,zero,1f388 <_fpadd_parts+0x228>
   1f1b4:	00c00fc4 	movi	r3,63
   1f1b8:	1a805016 	blt	r3,r10,1f2fc <_fpadd_parts+0x19c>
   1f1bc:	0100870e 	bge	zero,r4,1f3dc <_fpadd_parts+0x27c>
   1f1c0:	50fff804 	addi	r3,r10,-32
   1f1c4:	18009916 	blt	r3,zero,1f42c <_fpadd_parts+0x2cc>
   1f1c8:	48d6d83a 	srl	r11,r9,r3
   1f1cc:	001d883a 	mov	r14,zero
   1f1d0:	18009e16 	blt	r3,zero,1f44c <_fpadd_parts+0x2ec>
   1f1d4:	01000044 	movi	r4,1
   1f1d8:	20c6983a 	sll	r3,r4,r3
   1f1dc:	0015883a 	mov	r10,zero
   1f1e0:	513fffc4 	addi	r4,r10,-1
   1f1e4:	2295403a 	cmpgeu	r10,r4,r10
   1f1e8:	1a87c83a 	sub	r3,r3,r10
   1f1ec:	1a52703a 	and	r9,r3,r9
   1f1f0:	2210703a 	and	r8,r4,r8
   1f1f4:	4250b03a 	or	r8,r8,r9
   1f1f8:	4010c03a 	cmpne	r8,r8,zero
   1f1fc:	42d0b03a 	or	r8,r8,r11
   1f200:	7013883a 	mov	r9,r14
   1f204:	11000117 	ldw	r4,4(r2)
   1f208:	28800117 	ldw	r2,4(r5)
   1f20c:	20804126 	beq	r4,r2,1f314 <_fpadd_parts+0x1b4>
   1f210:	20006326 	beq	r4,zero,1f3a0 <_fpadd_parts+0x240>
   1f214:	4305c83a 	sub	r2,r8,r12
   1f218:	4091803a 	cmpltu	r8,r8,r2
   1f21c:	4b47c83a 	sub	r3,r9,r13
   1f220:	1a07c83a 	sub	r3,r3,r8
   1f224:	18006316 	blt	r3,zero,1f3b4 <_fpadd_parts+0x254>
   1f228:	30000115 	stw	zero,4(r6)
   1f22c:	31c00215 	stw	r7,8(r6)
   1f230:	30800315 	stw	r2,12(r6)
   1f234:	30c00415 	stw	r3,16(r6)
   1f238:	11ffffc4 	addi	r7,r2,-1
   1f23c:	388b403a 	cmpgeu	r5,r7,r2
   1f240:	194bc83a 	sub	r5,r3,r5
   1f244:	01040034 	movhi	r4,4096
   1f248:	213fffc4 	addi	r4,r4,-1
   1f24c:	21401736 	bltu	r4,r5,1f2ac <_fpadd_parts+0x14c>
   1f250:	29008226 	beq	r5,r4,1f45c <_fpadd_parts+0x2fc>
   1f254:	31400217 	ldw	r5,8(r6)
   1f258:	02840034 	movhi	r10,4096
   1f25c:	52bfffc4 	addi	r10,r10,-1
   1f260:	033fff84 	movi	r12,-2
   1f264:	297fffc4 	addi	r5,r5,-1
   1f268:	00000106 	br	1f270 <_fpadd_parts+0x110>
   1f26c:	3a804a26 	beq	r7,r10,1f398 <_fpadd_parts+0x238>
   1f270:	1089883a 	add	r4,r2,r2
   1f274:	2091803a 	cmpltu	r8,r4,r2
   1f278:	18c7883a 	add	r3,r3,r3
   1f27c:	227fffc4 	addi	r9,r4,-1
   1f280:	40d1883a 	add	r8,r8,r3
   1f284:	490f403a 	cmpgeu	r7,r9,r4
   1f288:	41cfc83a 	sub	r7,r8,r7
   1f28c:	2817883a 	mov	r11,r5
   1f290:	2005883a 	mov	r2,r4
   1f294:	4007883a 	mov	r3,r8
   1f298:	297fffc4 	addi	r5,r5,-1
   1f29c:	51fff32e 	bgeu	r10,r7,1f26c <_fpadd_parts+0x10c>
   1f2a0:	31000315 	stw	r4,12(r6)
   1f2a4:	32000415 	stw	r8,16(r6)
   1f2a8:	32c00215 	stw	r11,8(r6)
   1f2ac:	010000c4 	movi	r4,3
   1f2b0:	31000015 	stw	r4,0(r6)
   1f2b4:	01080034 	movhi	r4,8192
   1f2b8:	213fffc4 	addi	r4,r4,-1
   1f2bc:	20c00b2e 	bgeu	r4,r3,1f2ec <_fpadd_parts+0x18c>
   1f2c0:	180e97fa 	slli	r7,r3,31
   1f2c4:	1008d07a 	srli	r4,r2,1
   1f2c8:	31400217 	ldw	r5,8(r6)
   1f2cc:	1806d07a 	srli	r3,r3,1
   1f2d0:	1080004c 	andi	r2,r2,1
   1f2d4:	3908b03a 	or	r4,r7,r4
   1f2d8:	1108b03a 	or	r4,r2,r4
   1f2dc:	29400044 	addi	r5,r5,1
   1f2e0:	31000315 	stw	r4,12(r6)
   1f2e4:	30c00415 	stw	r3,16(r6)
   1f2e8:	31400215 	stw	r5,8(r6)
   1f2ec:	3005883a 	mov	r2,r6
   1f2f0:	f800283a 	ret
   1f2f4:	2805883a 	mov	r2,r5
   1f2f8:	f800283a 	ret
   1f2fc:	59c01e0e 	bge	r11,r7,1f378 <_fpadd_parts+0x218>
   1f300:	11000117 	ldw	r4,4(r2)
   1f304:	28800117 	ldw	r2,4(r5)
   1f308:	0011883a 	mov	r8,zero
   1f30c:	0013883a 	mov	r9,zero
   1f310:	20bfbf1e 	bne	r4,r2,1f210 <_fpadd_parts+0xb0>
   1f314:	4305883a 	add	r2,r8,r12
   1f318:	1207803a 	cmpltu	r3,r2,r8
   1f31c:	4b53883a 	add	r9,r9,r13
   1f320:	1a47883a 	add	r3,r3,r9
   1f324:	31000115 	stw	r4,4(r6)
   1f328:	31c00215 	stw	r7,8(r6)
   1f32c:	30800315 	stw	r2,12(r6)
   1f330:	30c00415 	stw	r3,16(r6)
   1f334:	003fdd06 	br	1f2ac <_fpadd_parts+0x14c>
   1f338:	20ffef1e 	bne	r4,r3,1f2f8 <_fpadd_parts+0x198>
   1f33c:	31000015 	stw	r4,0(r6)
   1f340:	10c00117 	ldw	r3,4(r2)
   1f344:	30c00115 	stw	r3,4(r6)
   1f348:	10c00217 	ldw	r3,8(r2)
   1f34c:	11000117 	ldw	r4,4(r2)
   1f350:	29400117 	ldw	r5,4(r5)
   1f354:	30c00215 	stw	r3,8(r6)
   1f358:	10c00317 	ldw	r3,12(r2)
   1f35c:	2908703a 	and	r4,r5,r4
   1f360:	30c00315 	stw	r3,12(r6)
   1f364:	10c00417 	ldw	r3,16(r2)
   1f368:	31000115 	stw	r4,4(r6)
   1f36c:	3005883a 	mov	r2,r6
   1f370:	30c00415 	stw	r3,16(r6)
   1f374:	f800283a 	ret
   1f378:	580f883a 	mov	r7,r11
   1f37c:	0019883a 	mov	r12,zero
   1f380:	001b883a 	mov	r13,zero
   1f384:	003f9f06 	br	1f204 <_fpadd_parts+0xa4>
   1f388:	0115c83a 	sub	r10,zero,r4
   1f38c:	00c00fc4 	movi	r3,63
   1f390:	1abfda16 	blt	r3,r10,1f2fc <_fpadd_parts+0x19c>
   1f394:	003f8906 	br	1f1bc <_fpadd_parts+0x5c>
   1f398:	627fb52e 	bgeu	r12,r9,1f270 <_fpadd_parts+0x110>
   1f39c:	003fc006 	br	1f2a0 <_fpadd_parts+0x140>
   1f3a0:	6205c83a 	sub	r2,r12,r8
   1f3a4:	6099803a 	cmpltu	r12,r12,r2
   1f3a8:	6a47c83a 	sub	r3,r13,r9
   1f3ac:	1b07c83a 	sub	r3,r3,r12
   1f3b0:	183f9d0e 	bge	r3,zero,1f228 <_fpadd_parts+0xc8>
   1f3b4:	0085c83a 	sub	r2,zero,r2
   1f3b8:	1008c03a 	cmpne	r4,r2,zero
   1f3bc:	00c7c83a 	sub	r3,zero,r3
   1f3c0:	1907c83a 	sub	r3,r3,r4
   1f3c4:	01000044 	movi	r4,1
   1f3c8:	31000115 	stw	r4,4(r6)
   1f3cc:	31c00215 	stw	r7,8(r6)
   1f3d0:	30800315 	stw	r2,12(r6)
   1f3d4:	30c00415 	stw	r3,16(r6)
   1f3d8:	003f9706 	br	1f238 <_fpadd_parts+0xd8>
   1f3dc:	203f8926 	beq	r4,zero,1f204 <_fpadd_parts+0xa4>
   1f3e0:	50fff804 	addi	r3,r10,-32
   1f3e4:	3a8f883a 	add	r7,r7,r10
   1f3e8:	18002316 	blt	r3,zero,1f478 <_fpadd_parts+0x318>
   1f3ec:	68d6d83a 	srl	r11,r13,r3
   1f3f0:	001d883a 	mov	r14,zero
   1f3f4:	18001c16 	blt	r3,zero,1f468 <_fpadd_parts+0x308>
   1f3f8:	01000044 	movi	r4,1
   1f3fc:	20c6983a 	sll	r3,r4,r3
   1f400:	0015883a 	mov	r10,zero
   1f404:	513fffc4 	addi	r4,r10,-1
   1f408:	2295403a 	cmpgeu	r10,r4,r10
   1f40c:	1a87c83a 	sub	r3,r3,r10
   1f410:	1b5a703a 	and	r13,r3,r13
   1f414:	2318703a 	and	r12,r4,r12
   1f418:	6358b03a 	or	r12,r12,r13
   1f41c:	6018c03a 	cmpne	r12,r12,zero
   1f420:	62d8b03a 	or	r12,r12,r11
   1f424:	701b883a 	mov	r13,r14
   1f428:	003f7606 	br	1f204 <_fpadd_parts+0xa4>
   1f42c:	4808907a 	slli	r4,r9,1
   1f430:	02c007c4 	movi	r11,31
   1f434:	5a97c83a 	sub	r11,r11,r10
   1f438:	22c8983a 	sll	r4,r4,r11
   1f43c:	4296d83a 	srl	r11,r8,r10
   1f440:	4a9cd83a 	srl	r14,r9,r10
   1f444:	22d6b03a 	or	r11,r4,r11
   1f448:	003f6106 	br	1f1d0 <_fpadd_parts+0x70>
   1f44c:	00c00044 	movi	r3,1
   1f450:	1a94983a 	sll	r10,r3,r10
   1f454:	0007883a 	mov	r3,zero
   1f458:	003f6106 	br	1f1e0 <_fpadd_parts+0x80>
   1f45c:	013fff84 	movi	r4,-2
   1f460:	21ff7c2e 	bgeu	r4,r7,1f254 <_fpadd_parts+0xf4>
   1f464:	003f9106 	br	1f2ac <_fpadd_parts+0x14c>
   1f468:	00c00044 	movi	r3,1
   1f46c:	1a94983a 	sll	r10,r3,r10
   1f470:	0007883a 	mov	r3,zero
   1f474:	003fe306 	br	1f404 <_fpadd_parts+0x2a4>
   1f478:	6816907a 	slli	r11,r13,1
   1f47c:	010007c4 	movi	r4,31
   1f480:	2289c83a 	sub	r4,r4,r10
   1f484:	5908983a 	sll	r4,r11,r4
   1f488:	6296d83a 	srl	r11,r12,r10
   1f48c:	6a9cd83a 	srl	r14,r13,r10
   1f490:	22d6b03a 	or	r11,r4,r11
   1f494:	003fd706 	br	1f3f4 <_fpadd_parts+0x294>
   1f498:	193f971e 	bne	r3,r4,1f2f8 <_fpadd_parts+0x198>
   1f49c:	11000117 	ldw	r4,4(r2)
   1f4a0:	28c00117 	ldw	r3,4(r5)
   1f4a4:	20ff9426 	beq	r4,r3,1f2f8 <_fpadd_parts+0x198>
   1f4a8:	008000f4 	movhi	r2,3
   1f4ac:	10805804 	addi	r2,r2,352
   1f4b0:	f800283a 	ret

0001f4b4 <__adddf3>:
   1f4b4:	deffec04 	addi	sp,sp,-80
   1f4b8:	d9001115 	stw	r4,68(sp)
   1f4bc:	d9401215 	stw	r5,72(sp)
   1f4c0:	d9001104 	addi	r4,sp,68
   1f4c4:	d9400a04 	addi	r5,sp,40
   1f4c8:	dfc01315 	stw	ra,76(sp)
   1f4cc:	d9c01015 	stw	r7,64(sp)
   1f4d0:	d9800f15 	stw	r6,60(sp)
   1f4d4:	00203000 	call	20300 <__unpack_d>
   1f4d8:	d9000f04 	addi	r4,sp,60
   1f4dc:	d9400504 	addi	r5,sp,20
   1f4e0:	00203000 	call	20300 <__unpack_d>
   1f4e4:	d9000a04 	addi	r4,sp,40
   1f4e8:	d9400504 	addi	r5,sp,20
   1f4ec:	d80d883a 	mov	r6,sp
   1f4f0:	001f1600 	call	1f160 <_fpadd_parts>
   1f4f4:	1009883a 	mov	r4,r2
   1f4f8:	00200dc0 	call	200dc <__pack_d>
   1f4fc:	dfc01317 	ldw	ra,76(sp)
   1f500:	dec01404 	addi	sp,sp,80
   1f504:	f800283a 	ret

0001f508 <__subdf3>:
   1f508:	deffec04 	addi	sp,sp,-80
   1f50c:	d9001115 	stw	r4,68(sp)
   1f510:	d9401215 	stw	r5,72(sp)
   1f514:	d9001104 	addi	r4,sp,68
   1f518:	d9400a04 	addi	r5,sp,40
   1f51c:	dfc01315 	stw	ra,76(sp)
   1f520:	d9c01015 	stw	r7,64(sp)
   1f524:	d9800f15 	stw	r6,60(sp)
   1f528:	00203000 	call	20300 <__unpack_d>
   1f52c:	d9000f04 	addi	r4,sp,60
   1f530:	d9400504 	addi	r5,sp,20
   1f534:	00203000 	call	20300 <__unpack_d>
   1f538:	d8800617 	ldw	r2,24(sp)
   1f53c:	d9000a04 	addi	r4,sp,40
   1f540:	d9400504 	addi	r5,sp,20
   1f544:	d80d883a 	mov	r6,sp
   1f548:	1080005c 	xori	r2,r2,1
   1f54c:	d8800615 	stw	r2,24(sp)
   1f550:	001f1600 	call	1f160 <_fpadd_parts>
   1f554:	1009883a 	mov	r4,r2
   1f558:	00200dc0 	call	200dc <__pack_d>
   1f55c:	dfc01317 	ldw	ra,76(sp)
   1f560:	dec01404 	addi	sp,sp,80
   1f564:	f800283a 	ret

0001f568 <__muldf3>:
   1f568:	deffe404 	addi	sp,sp,-112
   1f56c:	d9001115 	stw	r4,68(sp)
   1f570:	d9401215 	stw	r5,72(sp)
   1f574:	d9001104 	addi	r4,sp,68
   1f578:	d9400a04 	addi	r5,sp,40
   1f57c:	dfc01b15 	stw	ra,108(sp)
   1f580:	d9800f15 	stw	r6,60(sp)
   1f584:	d9c01015 	stw	r7,64(sp)
   1f588:	ddc01a15 	stw	r23,104(sp)
   1f58c:	dd801915 	stw	r22,100(sp)
   1f590:	dd401815 	stw	r21,96(sp)
   1f594:	dd001715 	stw	r20,92(sp)
   1f598:	dcc01615 	stw	r19,88(sp)
   1f59c:	dc801515 	stw	r18,84(sp)
   1f5a0:	dc401415 	stw	r17,80(sp)
   1f5a4:	dc001315 	stw	r16,76(sp)
   1f5a8:	00203000 	call	20300 <__unpack_d>
   1f5ac:	d9000f04 	addi	r4,sp,60
   1f5b0:	d9400504 	addi	r5,sp,20
   1f5b4:	00203000 	call	20300 <__unpack_d>
   1f5b8:	d8c00a17 	ldw	r3,40(sp)
   1f5bc:	00800044 	movi	r2,1
   1f5c0:	10c01136 	bltu	r2,r3,1f608 <__muldf3+0xa0>
   1f5c4:	d8c00b17 	ldw	r3,44(sp)
   1f5c8:	d8800617 	ldw	r2,24(sp)
   1f5cc:	d9000a04 	addi	r4,sp,40
   1f5d0:	1884c03a 	cmpne	r2,r3,r2
   1f5d4:	d8800b15 	stw	r2,44(sp)
   1f5d8:	00200dc0 	call	200dc <__pack_d>
   1f5dc:	dfc01b17 	ldw	ra,108(sp)
   1f5e0:	ddc01a17 	ldw	r23,104(sp)
   1f5e4:	dd801917 	ldw	r22,100(sp)
   1f5e8:	dd401817 	ldw	r21,96(sp)
   1f5ec:	dd001717 	ldw	r20,92(sp)
   1f5f0:	dcc01617 	ldw	r19,88(sp)
   1f5f4:	dc801517 	ldw	r18,84(sp)
   1f5f8:	dc401417 	ldw	r17,80(sp)
   1f5fc:	dc001317 	ldw	r16,76(sp)
   1f600:	dec01c04 	addi	sp,sp,112
   1f604:	f800283a 	ret
   1f608:	d9000517 	ldw	r4,20(sp)
   1f60c:	11000636 	bltu	r2,r4,1f628 <__muldf3+0xc0>
   1f610:	d8800617 	ldw	r2,24(sp)
   1f614:	d8c00b17 	ldw	r3,44(sp)
   1f618:	d9000504 	addi	r4,sp,20
   1f61c:	1884c03a 	cmpne	r2,r3,r2
   1f620:	d8800615 	stw	r2,24(sp)
   1f624:	003fec06 	br	1f5d8 <__muldf3+0x70>
   1f628:	00800104 	movi	r2,4
   1f62c:	1880051e 	bne	r3,r2,1f644 <__muldf3+0xdc>
   1f630:	00800084 	movi	r2,2
   1f634:	20bfe31e 	bne	r4,r2,1f5c4 <__muldf3+0x5c>
   1f638:	010000f4 	movhi	r4,3
   1f63c:	21005804 	addi	r4,r4,352
   1f640:	003fe506 	br	1f5d8 <__muldf3+0x70>
   1f644:	2080031e 	bne	r4,r2,1f654 <__muldf3+0xec>
   1f648:	00800084 	movi	r2,2
   1f64c:	18bffa26 	beq	r3,r2,1f638 <__muldf3+0xd0>
   1f650:	003fef06 	br	1f610 <__muldf3+0xa8>
   1f654:	00800084 	movi	r2,2
   1f658:	18bfda26 	beq	r3,r2,1f5c4 <__muldf3+0x5c>
   1f65c:	20bfec26 	beq	r4,r2,1f610 <__muldf3+0xa8>
   1f660:	dc000d17 	ldw	r16,52(sp)
   1f664:	dd000817 	ldw	r20,32(sp)
   1f668:	dc800917 	ldw	r18,36(sp)
   1f66c:	8009883a 	mov	r4,r16
   1f670:	000b883a 	mov	r5,zero
   1f674:	a00d883a 	mov	r6,r20
   1f678:	000f883a 	mov	r7,zero
   1f67c:	001ffd00 	call	1ffd0 <__muldi3>
   1f680:	dc400e17 	ldw	r17,56(sp)
   1f684:	9009883a 	mov	r4,r18
   1f688:	800d883a 	mov	r6,r16
   1f68c:	000b883a 	mov	r5,zero
   1f690:	000f883a 	mov	r7,zero
   1f694:	102f883a 	mov	r23,r2
   1f698:	1827883a 	mov	r19,r3
   1f69c:	001ffd00 	call	1ffd0 <__muldi3>
   1f6a0:	900d883a 	mov	r6,r18
   1f6a4:	8809883a 	mov	r4,r17
   1f6a8:	000b883a 	mov	r5,zero
   1f6ac:	000f883a 	mov	r7,zero
   1f6b0:	102b883a 	mov	r21,r2
   1f6b4:	1821883a 	mov	r16,r3
   1f6b8:	001ffd00 	call	1ffd0 <__muldi3>
   1f6bc:	8809883a 	mov	r4,r17
   1f6c0:	000b883a 	mov	r5,zero
   1f6c4:	a00d883a 	mov	r6,r20
   1f6c8:	000f883a 	mov	r7,zero
   1f6cc:	102d883a 	mov	r22,r2
   1f6d0:	1825883a 	mov	r18,r3
   1f6d4:	001ffd00 	call	1ffd0 <__muldi3>
   1f6d8:	154b883a 	add	r5,r2,r21
   1f6dc:	2889803a 	cmpltu	r4,r5,r2
   1f6e0:	1c07883a 	add	r3,r3,r16
   1f6e4:	20c9883a 	add	r4,r4,r3
   1f6e8:	24004b36 	bltu	r4,r16,1f818 <__muldf3+0x2b0>
   1f6ec:	8100011e 	bne	r16,r4,1f6f4 <__muldf3+0x18c>
   1f6f0:	2d404936 	bltu	r5,r21,1f818 <__muldf3+0x2b0>
   1f6f4:	0011883a 	mov	r8,zero
   1f6f8:	0007883a 	mov	r3,zero
   1f6fc:	2ccb883a 	add	r5,r5,r19
   1f700:	b80d883a 	mov	r6,r23
   1f704:	2cc0012e 	bgeu	r5,r19,1f70c <__muldf3+0x1a4>
   1f708:	02000044 	movi	r8,1
   1f70c:	258f883a 	add	r7,r4,r22
   1f710:	3909803a 	cmpltu	r4,r7,r4
   1f714:	da400c17 	ldw	r9,48(sp)
   1f718:	2489883a 	add	r4,r4,r18
   1f71c:	d8800717 	ldw	r2,28(sp)
   1f720:	20c9883a 	add	r4,r4,r3
   1f724:	da800b17 	ldw	r10,44(sp)
   1f728:	d8c00617 	ldw	r3,24(sp)
   1f72c:	3a11883a 	add	r8,r7,r8
   1f730:	4885883a 	add	r2,r9,r2
   1f734:	50c6c03a 	cmpne	r3,r10,r3
   1f738:	41cf803a 	cmpltu	r7,r8,r7
   1f73c:	12400104 	addi	r9,r2,4
   1f740:	d8c00115 	stw	r3,4(sp)
   1f744:	3909883a 	add	r4,r7,r4
   1f748:	da400215 	stw	r9,8(sp)
   1f74c:	03480034 	movhi	r13,8192
   1f750:	6b7fffc4 	addi	r13,r13,-1
   1f754:	4007883a 	mov	r3,r8
   1f758:	6900102e 	bgeu	r13,r4,1f79c <__muldf3+0x234>
   1f75c:	10800144 	addi	r2,r2,5
   1f760:	180ed07a 	srli	r7,r3,1
   1f764:	18c0004c 	andi	r3,r3,1
   1f768:	201097fa 	slli	r8,r4,31
   1f76c:	281697fa 	slli	r11,r5,31
   1f770:	2008d07a 	srli	r4,r4,1
   1f774:	3014d07a 	srli	r10,r6,1
   1f778:	2812d07a 	srli	r9,r5,1
   1f77c:	1019883a 	mov	r12,r2
   1f780:	18000226 	beq	r3,zero,1f78c <__muldf3+0x224>
   1f784:	5a8cb03a 	or	r6,r11,r10
   1f788:	49600034 	orhi	r5,r9,32768
   1f78c:	41c6b03a 	or	r3,r8,r7
   1f790:	10800044 	addi	r2,r2,1
   1f794:	693ff236 	bltu	r13,r4,1f760 <__muldf3+0x1f8>
   1f798:	db000215 	stw	r12,8(sp)
   1f79c:	03440034 	movhi	r13,4096
   1f7a0:	6b7fffc4 	addi	r13,r13,-1
   1f7a4:	69001336 	bltu	r13,r4,1f7f4 <__muldf3+0x28c>
   1f7a8:	d8800217 	ldw	r2,8(sp)
   1f7ac:	10bfffc4 	addi	r2,r2,-1
   1f7b0:	18d3883a 	add	r9,r3,r3
   1f7b4:	48c7803a 	cmpltu	r3,r9,r3
   1f7b8:	2109883a 	add	r4,r4,r4
   1f7bc:	190f883a 	add	r7,r3,r4
   1f7c0:	3191883a 	add	r8,r6,r6
   1f7c4:	4197803a 	cmpltu	r11,r8,r6
   1f7c8:	2955883a 	add	r10,r5,r5
   1f7cc:	1019883a 	mov	r12,r2
   1f7d0:	4807883a 	mov	r3,r9
   1f7d4:	3809883a 	mov	r4,r7
   1f7d8:	2800010e 	bge	r5,zero,1f7e0 <__muldf3+0x278>
   1f7dc:	48c00054 	ori	r3,r9,1
   1f7e0:	400d883a 	mov	r6,r8
   1f7e4:	5a8b883a 	add	r5,r11,r10
   1f7e8:	10bfffc4 	addi	r2,r2,-1
   1f7ec:	69fff02e 	bgeu	r13,r7,1f7b0 <__muldf3+0x248>
   1f7f0:	db000215 	stw	r12,8(sp)
   1f7f4:	18803fcc 	andi	r2,r3,255
   1f7f8:	01c02004 	movi	r7,128
   1f7fc:	11c00926 	beq	r2,r7,1f824 <__muldf3+0x2bc>
   1f800:	008000c4 	movi	r2,3
   1f804:	d9000415 	stw	r4,16(sp)
   1f808:	d8c00315 	stw	r3,12(sp)
   1f80c:	d8800015 	stw	r2,0(sp)
   1f810:	d809883a 	mov	r4,sp
   1f814:	003f7006 	br	1f5d8 <__muldf3+0x70>
   1f818:	0011883a 	mov	r8,zero
   1f81c:	00c00044 	movi	r3,1
   1f820:	003fb606 	br	1f6fc <__muldf3+0x194>
   1f824:	19c0400c 	andi	r7,r3,256
   1f828:	383ff51e 	bne	r7,zero,1f800 <__muldf3+0x298>
   1f82c:	314ab03a 	or	r5,r6,r5
   1f830:	283ff326 	beq	r5,zero,1f800 <__muldf3+0x298>
   1f834:	1885883a 	add	r2,r3,r2
   1f838:	10cb803a 	cmpltu	r5,r2,r3
   1f83c:	00ffc004 	movi	r3,-256
   1f840:	10c6703a 	and	r3,r2,r3
   1f844:	2909883a 	add	r4,r5,r4
   1f848:	003fed06 	br	1f800 <__muldf3+0x298>

0001f84c <__divdf3>:
   1f84c:	defff104 	addi	sp,sp,-60
   1f850:	d9000c15 	stw	r4,48(sp)
   1f854:	d9400d15 	stw	r5,52(sp)
   1f858:	d9000c04 	addi	r4,sp,48
   1f85c:	d9400504 	addi	r5,sp,20
   1f860:	dfc00e15 	stw	ra,56(sp)
   1f864:	d9800a15 	stw	r6,40(sp)
   1f868:	d9c00b15 	stw	r7,44(sp)
   1f86c:	00203000 	call	20300 <__unpack_d>
   1f870:	d9000a04 	addi	r4,sp,40
   1f874:	d80b883a 	mov	r5,sp
   1f878:	00203000 	call	20300 <__unpack_d>
   1f87c:	d8c00517 	ldw	r3,20(sp)
   1f880:	00800044 	movi	r2,1
   1f884:	10c00536 	bltu	r2,r3,1f89c <__divdf3+0x50>
   1f888:	d9000504 	addi	r4,sp,20
   1f88c:	00200dc0 	call	200dc <__pack_d>
   1f890:	dfc00e17 	ldw	ra,56(sp)
   1f894:	dec00f04 	addi	sp,sp,60
   1f898:	f800283a 	ret
   1f89c:	d9000017 	ldw	r4,0(sp)
   1f8a0:	11000536 	bltu	r2,r4,1f8b8 <__divdf3+0x6c>
   1f8a4:	d809883a 	mov	r4,sp
   1f8a8:	00200dc0 	call	200dc <__pack_d>
   1f8ac:	dfc00e17 	ldw	ra,56(sp)
   1f8b0:	dec00f04 	addi	sp,sp,60
   1f8b4:	f800283a 	ret
   1f8b8:	d9800617 	ldw	r6,24(sp)
   1f8bc:	d9400117 	ldw	r5,4(sp)
   1f8c0:	00800104 	movi	r2,4
   1f8c4:	314af03a 	xor	r5,r6,r5
   1f8c8:	d9400615 	stw	r5,24(sp)
   1f8cc:	18800226 	beq	r3,r2,1f8d8 <__divdf3+0x8c>
   1f8d0:	01400084 	movi	r5,2
   1f8d4:	1940041e 	bne	r3,r5,1f8e8 <__divdf3+0x9c>
   1f8d8:	193feb1e 	bne	r3,r4,1f888 <__divdf3+0x3c>
   1f8dc:	010000f4 	movhi	r4,3
   1f8e0:	21005804 	addi	r4,r4,352
   1f8e4:	003fe906 	br	1f88c <__divdf3+0x40>
   1f8e8:	20803326 	beq	r4,r2,1f9b8 <__divdf3+0x16c>
   1f8ec:	21403726 	beq	r4,r5,1f9cc <__divdf3+0x180>
   1f8f0:	d8800217 	ldw	r2,8(sp)
   1f8f4:	d9000717 	ldw	r4,28(sp)
   1f8f8:	d8c00917 	ldw	r3,36(sp)
   1f8fc:	da000417 	ldw	r8,16(sp)
   1f900:	2089c83a 	sub	r4,r4,r2
   1f904:	d9000715 	stw	r4,28(sp)
   1f908:	d8800817 	ldw	r2,32(sp)
   1f90c:	dbc00317 	ldw	r15,12(sp)
   1f910:	1a000236 	bltu	r3,r8,1f91c <__divdf3+0xd0>
   1f914:	40c0081e 	bne	r8,r3,1f938 <__divdf3+0xec>
   1f918:	13c0072e 	bgeu	r2,r15,1f938 <__divdf3+0xec>
   1f91c:	108b883a 	add	r5,r2,r2
   1f920:	288d803a 	cmpltu	r6,r5,r2
   1f924:	18c7883a 	add	r3,r3,r3
   1f928:	213fffc4 	addi	r4,r4,-1
   1f92c:	2805883a 	mov	r2,r5
   1f930:	30c7883a 	add	r3,r6,r3
   1f934:	d9000715 	stw	r4,28(sp)
   1f938:	01400f44 	movi	r5,61
   1f93c:	000f883a 	mov	r7,zero
   1f940:	01040034 	movhi	r4,4096
   1f944:	0019883a 	mov	r12,zero
   1f948:	001b883a 	mov	r13,zero
   1f94c:	201697fa 	slli	r11,r4,31
   1f950:	3814d07a 	srli	r10,r7,1
   1f954:	297fffc4 	addi	r5,r5,-1
   1f958:	1a000936 	bltu	r3,r8,1f980 <__divdf3+0x134>
   1f95c:	13cdc83a 	sub	r6,r2,r15
   1f960:	1193803a 	cmpltu	r9,r2,r6
   1f964:	1a1dc83a 	sub	r14,r3,r8
   1f968:	40c0011e 	bne	r8,r3,1f970 <__divdf3+0x124>
   1f96c:	13c00436 	bltu	r2,r15,1f980 <__divdf3+0x134>
   1f970:	3005883a 	mov	r2,r6
   1f974:	7247c83a 	sub	r3,r14,r9
   1f978:	61d8b03a 	or	r12,r12,r7
   1f97c:	691ab03a 	or	r13,r13,r4
   1f980:	108d883a 	add	r6,r2,r2
   1f984:	3093803a 	cmpltu	r9,r6,r2
   1f988:	18c7883a 	add	r3,r3,r3
   1f98c:	5a8eb03a 	or	r7,r11,r10
   1f990:	2008d07a 	srli	r4,r4,1
   1f994:	3005883a 	mov	r2,r6
   1f998:	48c7883a 	add	r3,r9,r3
   1f99c:	283feb1e 	bne	r5,zero,1f94c <__divdf3+0x100>
   1f9a0:	61003fcc 	andi	r4,r12,255
   1f9a4:	01402004 	movi	r5,128
   1f9a8:	21400b26 	beq	r4,r5,1f9d8 <__divdf3+0x18c>
   1f9ac:	db000815 	stw	r12,32(sp)
   1f9b0:	db400915 	stw	r13,36(sp)
   1f9b4:	003fb406 	br	1f888 <__divdf3+0x3c>
   1f9b8:	d8000815 	stw	zero,32(sp)
   1f9bc:	d8000915 	stw	zero,36(sp)
   1f9c0:	d8000715 	stw	zero,28(sp)
   1f9c4:	d9000504 	addi	r4,sp,20
   1f9c8:	003fb006 	br	1f88c <__divdf3+0x40>
   1f9cc:	d8800515 	stw	r2,20(sp)
   1f9d0:	d9000504 	addi	r4,sp,20
   1f9d4:	003fad06 	br	1f88c <__divdf3+0x40>
   1f9d8:	6140400c 	andi	r5,r12,256
   1f9dc:	283ff31e 	bne	r5,zero,1f9ac <__divdf3+0x160>
   1f9e0:	30c4b03a 	or	r2,r6,r3
   1f9e4:	103ff126 	beq	r2,zero,1f9ac <__divdf3+0x160>
   1f9e8:	6109883a 	add	r4,r12,r4
   1f9ec:	2305803a 	cmpltu	r2,r4,r12
   1f9f0:	033fc004 	movi	r12,-256
   1f9f4:	2318703a 	and	r12,r4,r12
   1f9f8:	135b883a 	add	r13,r2,r13
   1f9fc:	003feb06 	br	1f9ac <__divdf3+0x160>

0001fa00 <__eqdf2>:
   1fa00:	defff104 	addi	sp,sp,-60
   1fa04:	d9000c15 	stw	r4,48(sp)
   1fa08:	d9400d15 	stw	r5,52(sp)
   1fa0c:	d9000c04 	addi	r4,sp,48
   1fa10:	d9400504 	addi	r5,sp,20
   1fa14:	dfc00e15 	stw	ra,56(sp)
   1fa18:	d9800a15 	stw	r6,40(sp)
   1fa1c:	d9c00b15 	stw	r7,44(sp)
   1fa20:	00203000 	call	20300 <__unpack_d>
   1fa24:	d9000a04 	addi	r4,sp,40
   1fa28:	d80b883a 	mov	r5,sp
   1fa2c:	00203000 	call	20300 <__unpack_d>
   1fa30:	d8c00517 	ldw	r3,20(sp)
   1fa34:	00800044 	movi	r2,1
   1fa38:	10c0052e 	bgeu	r2,r3,1fa50 <__eqdf2+0x50>
   1fa3c:	d8c00017 	ldw	r3,0(sp)
   1fa40:	10c0032e 	bgeu	r2,r3,1fa50 <__eqdf2+0x50>
   1fa44:	d9000504 	addi	r4,sp,20
   1fa48:	d80b883a 	mov	r5,sp
   1fa4c:	00204040 	call	20404 <__fpcmp_parts_d>
   1fa50:	dfc00e17 	ldw	ra,56(sp)
   1fa54:	dec00f04 	addi	sp,sp,60
   1fa58:	f800283a 	ret

0001fa5c <__nedf2>:
   1fa5c:	defff104 	addi	sp,sp,-60
   1fa60:	d9000c15 	stw	r4,48(sp)
   1fa64:	d9400d15 	stw	r5,52(sp)
   1fa68:	d9000c04 	addi	r4,sp,48
   1fa6c:	d9400504 	addi	r5,sp,20
   1fa70:	dfc00e15 	stw	ra,56(sp)
   1fa74:	d9800a15 	stw	r6,40(sp)
   1fa78:	d9c00b15 	stw	r7,44(sp)
   1fa7c:	00203000 	call	20300 <__unpack_d>
   1fa80:	d9000a04 	addi	r4,sp,40
   1fa84:	d80b883a 	mov	r5,sp
   1fa88:	00203000 	call	20300 <__unpack_d>
   1fa8c:	d8c00517 	ldw	r3,20(sp)
   1fa90:	00800044 	movi	r2,1
   1fa94:	10c0052e 	bgeu	r2,r3,1faac <__nedf2+0x50>
   1fa98:	d8c00017 	ldw	r3,0(sp)
   1fa9c:	10c0032e 	bgeu	r2,r3,1faac <__nedf2+0x50>
   1faa0:	d9000504 	addi	r4,sp,20
   1faa4:	d80b883a 	mov	r5,sp
   1faa8:	00204040 	call	20404 <__fpcmp_parts_d>
   1faac:	dfc00e17 	ldw	ra,56(sp)
   1fab0:	dec00f04 	addi	sp,sp,60
   1fab4:	f800283a 	ret

0001fab8 <__gtdf2>:
   1fab8:	defff104 	addi	sp,sp,-60
   1fabc:	d9000c15 	stw	r4,48(sp)
   1fac0:	d9400d15 	stw	r5,52(sp)
   1fac4:	d9000c04 	addi	r4,sp,48
   1fac8:	d9400504 	addi	r5,sp,20
   1facc:	dfc00e15 	stw	ra,56(sp)
   1fad0:	d9800a15 	stw	r6,40(sp)
   1fad4:	d9c00b15 	stw	r7,44(sp)
   1fad8:	00203000 	call	20300 <__unpack_d>
   1fadc:	d9000a04 	addi	r4,sp,40
   1fae0:	d80b883a 	mov	r5,sp
   1fae4:	00203000 	call	20300 <__unpack_d>
   1fae8:	d8c00517 	ldw	r3,20(sp)
   1faec:	00800044 	movi	r2,1
   1faf0:	10c0082e 	bgeu	r2,r3,1fb14 <__gtdf2+0x5c>
   1faf4:	d8c00017 	ldw	r3,0(sp)
   1faf8:	10c0062e 	bgeu	r2,r3,1fb14 <__gtdf2+0x5c>
   1fafc:	d9000504 	addi	r4,sp,20
   1fb00:	d80b883a 	mov	r5,sp
   1fb04:	00204040 	call	20404 <__fpcmp_parts_d>
   1fb08:	dfc00e17 	ldw	ra,56(sp)
   1fb0c:	dec00f04 	addi	sp,sp,60
   1fb10:	f800283a 	ret
   1fb14:	00bfffc4 	movi	r2,-1
   1fb18:	003ffb06 	br	1fb08 <__gtdf2+0x50>

0001fb1c <__gedf2>:
   1fb1c:	defff104 	addi	sp,sp,-60
   1fb20:	d9000c15 	stw	r4,48(sp)
   1fb24:	d9400d15 	stw	r5,52(sp)
   1fb28:	d9000c04 	addi	r4,sp,48
   1fb2c:	d9400504 	addi	r5,sp,20
   1fb30:	dfc00e15 	stw	ra,56(sp)
   1fb34:	d9800a15 	stw	r6,40(sp)
   1fb38:	d9c00b15 	stw	r7,44(sp)
   1fb3c:	00203000 	call	20300 <__unpack_d>
   1fb40:	d9000a04 	addi	r4,sp,40
   1fb44:	d80b883a 	mov	r5,sp
   1fb48:	00203000 	call	20300 <__unpack_d>
   1fb4c:	d8c00517 	ldw	r3,20(sp)
   1fb50:	00800044 	movi	r2,1
   1fb54:	10c0082e 	bgeu	r2,r3,1fb78 <__gedf2+0x5c>
   1fb58:	d8c00017 	ldw	r3,0(sp)
   1fb5c:	10c0062e 	bgeu	r2,r3,1fb78 <__gedf2+0x5c>
   1fb60:	d9000504 	addi	r4,sp,20
   1fb64:	d80b883a 	mov	r5,sp
   1fb68:	00204040 	call	20404 <__fpcmp_parts_d>
   1fb6c:	dfc00e17 	ldw	ra,56(sp)
   1fb70:	dec00f04 	addi	sp,sp,60
   1fb74:	f800283a 	ret
   1fb78:	00bfffc4 	movi	r2,-1
   1fb7c:	003ffb06 	br	1fb6c <__gedf2+0x50>

0001fb80 <__ltdf2>:
   1fb80:	defff104 	addi	sp,sp,-60
   1fb84:	d9000c15 	stw	r4,48(sp)
   1fb88:	d9400d15 	stw	r5,52(sp)
   1fb8c:	d9000c04 	addi	r4,sp,48
   1fb90:	d9400504 	addi	r5,sp,20
   1fb94:	dfc00e15 	stw	ra,56(sp)
   1fb98:	d9800a15 	stw	r6,40(sp)
   1fb9c:	d9c00b15 	stw	r7,44(sp)
   1fba0:	00203000 	call	20300 <__unpack_d>
   1fba4:	d9000a04 	addi	r4,sp,40
   1fba8:	d80b883a 	mov	r5,sp
   1fbac:	00203000 	call	20300 <__unpack_d>
   1fbb0:	d8c00517 	ldw	r3,20(sp)
   1fbb4:	00800044 	movi	r2,1
   1fbb8:	10c0052e 	bgeu	r2,r3,1fbd0 <__ltdf2+0x50>
   1fbbc:	d8c00017 	ldw	r3,0(sp)
   1fbc0:	10c0032e 	bgeu	r2,r3,1fbd0 <__ltdf2+0x50>
   1fbc4:	d9000504 	addi	r4,sp,20
   1fbc8:	d80b883a 	mov	r5,sp
   1fbcc:	00204040 	call	20404 <__fpcmp_parts_d>
   1fbd0:	dfc00e17 	ldw	ra,56(sp)
   1fbd4:	dec00f04 	addi	sp,sp,60
   1fbd8:	f800283a 	ret

0001fbdc <__floatsidf>:
   1fbdc:	2004d7fa 	srli	r2,r4,31
   1fbe0:	defff904 	addi	sp,sp,-28
   1fbe4:	00c000c4 	movi	r3,3
   1fbe8:	dfc00615 	stw	ra,24(sp)
   1fbec:	dc000515 	stw	r16,20(sp)
   1fbf0:	d8c00015 	stw	r3,0(sp)
   1fbf4:	d8800115 	stw	r2,4(sp)
   1fbf8:	2000081e 	bne	r4,zero,1fc1c <__floatsidf+0x40>
   1fbfc:	00800084 	movi	r2,2
   1fc00:	d8800015 	stw	r2,0(sp)
   1fc04:	d809883a 	mov	r4,sp
   1fc08:	00200dc0 	call	200dc <__pack_d>
   1fc0c:	dfc00617 	ldw	ra,24(sp)
   1fc10:	dc000517 	ldw	r16,20(sp)
   1fc14:	dec00704 	addi	sp,sp,28
   1fc18:	f800283a 	ret
   1fc1c:	00c00f04 	movi	r3,60
   1fc20:	d8c00215 	stw	r3,8(sp)
   1fc24:	10000f1e 	bne	r2,zero,1fc64 <__floatsidf+0x88>
   1fc28:	2021883a 	mov	r16,r4
   1fc2c:	8009883a 	mov	r4,r16
   1fc30:	00200300 	call	20030 <__clzsi2>
   1fc34:	11000744 	addi	r4,r2,29
   1fc38:	0100110e 	bge	zero,r4,1fc80 <__floatsidf+0xa4>
   1fc3c:	10ffff44 	addi	r3,r2,-3
   1fc40:	18001216 	blt	r3,zero,1fc8c <__floatsidf+0xb0>
   1fc44:	80c6983a 	sll	r3,r16,r3
   1fc48:	0009883a 	mov	r4,zero
   1fc4c:	014007c4 	movi	r5,31
   1fc50:	2885c83a 	sub	r2,r5,r2
   1fc54:	d9000315 	stw	r4,12(sp)
   1fc58:	d8c00415 	stw	r3,16(sp)
   1fc5c:	d8800215 	stw	r2,8(sp)
   1fc60:	003fe806 	br	1fc04 <__floatsidf+0x28>
   1fc64:	00a00034 	movhi	r2,32768
   1fc68:	20800e26 	beq	r4,r2,1fca4 <__floatsidf+0xc8>
   1fc6c:	0121c83a 	sub	r16,zero,r4
   1fc70:	8009883a 	mov	r4,r16
   1fc74:	00200300 	call	20030 <__clzsi2>
   1fc78:	11000744 	addi	r4,r2,29
   1fc7c:	013fef16 	blt	zero,r4,1fc3c <__floatsidf+0x60>
   1fc80:	dc000315 	stw	r16,12(sp)
   1fc84:	d8000415 	stw	zero,16(sp)
   1fc88:	003fde06 	br	1fc04 <__floatsidf+0x28>
   1fc8c:	800ad07a 	srli	r5,r16,1
   1fc90:	00c007c4 	movi	r3,31
   1fc94:	1907c83a 	sub	r3,r3,r4
   1fc98:	28c6d83a 	srl	r3,r5,r3
   1fc9c:	8108983a 	sll	r4,r16,r4
   1fca0:	003fea06 	br	1fc4c <__floatsidf+0x70>
   1fca4:	0005883a 	mov	r2,zero
   1fca8:	00f07834 	movhi	r3,49632
   1fcac:	003fd706 	br	1fc0c <__floatsidf+0x30>

0001fcb0 <__fixdfsi>:
   1fcb0:	defff804 	addi	sp,sp,-32
   1fcb4:	d9000515 	stw	r4,20(sp)
   1fcb8:	d9400615 	stw	r5,24(sp)
   1fcbc:	d9000504 	addi	r4,sp,20
   1fcc0:	d80b883a 	mov	r5,sp
   1fcc4:	dfc00715 	stw	ra,28(sp)
   1fcc8:	00203000 	call	20300 <__unpack_d>
   1fccc:	d8800017 	ldw	r2,0(sp)
   1fcd0:	00c00084 	movi	r3,2
   1fcd4:	10c01c26 	beq	r2,r3,1fd48 <__fixdfsi+0x98>
   1fcd8:	00c00044 	movi	r3,1
   1fcdc:	18801a2e 	bgeu	r3,r2,1fd48 <__fixdfsi+0x98>
   1fce0:	00c00104 	movi	r3,4
   1fce4:	10c01126 	beq	r2,r3,1fd2c <__fixdfsi+0x7c>
   1fce8:	d8800217 	ldw	r2,8(sp)
   1fcec:	10001616 	blt	r2,zero,1fd48 <__fixdfsi+0x98>
   1fcf0:	00c00784 	movi	r3,30
   1fcf4:	18800d16 	blt	r3,r2,1fd2c <__fixdfsi+0x7c>
   1fcf8:	00c00f04 	movi	r3,60
   1fcfc:	1885c83a 	sub	r2,r3,r2
   1fd00:	10fff804 	addi	r3,r2,-32
   1fd04:	d9400317 	ldw	r5,12(sp)
   1fd08:	d9000417 	ldw	r4,16(sp)
   1fd0c:	18001616 	blt	r3,zero,1fd68 <__fixdfsi+0xb8>
   1fd10:	20c4d83a 	srl	r2,r4,r3
   1fd14:	d8c00117 	ldw	r3,4(sp)
   1fd18:	18000126 	beq	r3,zero,1fd20 <__fixdfsi+0x70>
   1fd1c:	0085c83a 	sub	r2,zero,r2
   1fd20:	dfc00717 	ldw	ra,28(sp)
   1fd24:	dec00804 	addi	sp,sp,32
   1fd28:	f800283a 	ret
   1fd2c:	d8800117 	ldw	r2,4(sp)
   1fd30:	1000091e 	bne	r2,zero,1fd58 <__fixdfsi+0xa8>
   1fd34:	00a00034 	movhi	r2,32768
   1fd38:	10bfffc4 	addi	r2,r2,-1
   1fd3c:	dfc00717 	ldw	ra,28(sp)
   1fd40:	dec00804 	addi	sp,sp,32
   1fd44:	f800283a 	ret
   1fd48:	0005883a 	mov	r2,zero
   1fd4c:	dfc00717 	ldw	ra,28(sp)
   1fd50:	dec00804 	addi	sp,sp,32
   1fd54:	f800283a 	ret
   1fd58:	00a00034 	movhi	r2,32768
   1fd5c:	dfc00717 	ldw	ra,28(sp)
   1fd60:	dec00804 	addi	sp,sp,32
   1fd64:	f800283a 	ret
   1fd68:	2008907a 	slli	r4,r4,1
   1fd6c:	018007c4 	movi	r6,31
   1fd70:	308dc83a 	sub	r6,r6,r2
   1fd74:	2188983a 	sll	r4,r4,r6
   1fd78:	2884d83a 	srl	r2,r5,r2
   1fd7c:	2084b03a 	or	r2,r4,r2
   1fd80:	003fe406 	br	1fd14 <__fixdfsi+0x64>

0001fd84 <__floatunsidf>:
   1fd84:	defff904 	addi	sp,sp,-28
   1fd88:	dc000515 	stw	r16,20(sp)
   1fd8c:	dfc00615 	stw	ra,24(sp)
   1fd90:	d8000115 	stw	zero,4(sp)
   1fd94:	2021883a 	mov	r16,r4
   1fd98:	20001726 	beq	r4,zero,1fdf8 <__floatunsidf+0x74>
   1fd9c:	008000c4 	movi	r2,3
   1fda0:	d8800015 	stw	r2,0(sp)
   1fda4:	00800f04 	movi	r2,60
   1fda8:	d8800215 	stw	r2,8(sp)
   1fdac:	00200300 	call	20030 <__clzsi2>
   1fdb0:	10c00744 	addi	r3,r2,29
   1fdb4:	18001816 	blt	r3,zero,1fe18 <__floatunsidf+0x94>
   1fdb8:	18002d26 	beq	r3,zero,1fe70 <__floatunsidf+0xec>
   1fdbc:	113fff44 	addi	r4,r2,-3
   1fdc0:	20002e16 	blt	r4,zero,1fe7c <__floatunsidf+0xf8>
   1fdc4:	8108983a 	sll	r4,r16,r4
   1fdc8:	0021883a 	mov	r16,zero
   1fdcc:	014007c4 	movi	r5,31
   1fdd0:	2885c83a 	sub	r2,r5,r2
   1fdd4:	dc000315 	stw	r16,12(sp)
   1fdd8:	d9000415 	stw	r4,16(sp)
   1fddc:	d8800215 	stw	r2,8(sp)
   1fde0:	d809883a 	mov	r4,sp
   1fde4:	00200dc0 	call	200dc <__pack_d>
   1fde8:	dfc00617 	ldw	ra,24(sp)
   1fdec:	dc000517 	ldw	r16,20(sp)
   1fdf0:	dec00704 	addi	sp,sp,28
   1fdf4:	f800283a 	ret
   1fdf8:	00800084 	movi	r2,2
   1fdfc:	d809883a 	mov	r4,sp
   1fe00:	d8800015 	stw	r2,0(sp)
   1fe04:	00200dc0 	call	200dc <__pack_d>
   1fe08:	dfc00617 	ldw	ra,24(sp)
   1fe0c:	dc000517 	ldw	r16,20(sp)
   1fe10:	dec00704 	addi	sp,sp,28
   1fe14:	f800283a 	ret
   1fe18:	00c7c83a 	sub	r3,zero,r3
   1fe1c:	193ff804 	addi	r4,r3,-32
   1fe20:	20001c16 	blt	r4,zero,1fe94 <__floatunsidf+0x110>
   1fe24:	000b883a 	mov	r5,zero
   1fe28:	2009d7fa 	srai	r4,r4,31
   1fe2c:	80c6d83a 	srl	r3,r16,r3
   1fe30:	297fffc4 	addi	r5,r5,-1
   1fe34:	2c20703a 	and	r16,r5,r16
   1fe38:	8020c03a 	cmpne	r16,r16,zero
   1fe3c:	1906703a 	and	r3,r3,r4
   1fe40:	010007c4 	movi	r4,31
   1fe44:	80c6b03a 	or	r3,r16,r3
   1fe48:	2085c83a 	sub	r2,r4,r2
   1fe4c:	d809883a 	mov	r4,sp
   1fe50:	d8c00315 	stw	r3,12(sp)
   1fe54:	d8000415 	stw	zero,16(sp)
   1fe58:	d8800215 	stw	r2,8(sp)
   1fe5c:	00200dc0 	call	200dc <__pack_d>
   1fe60:	dfc00617 	ldw	ra,24(sp)
   1fe64:	dc000517 	ldw	r16,20(sp)
   1fe68:	dec00704 	addi	sp,sp,28
   1fe6c:	f800283a 	ret
   1fe70:	dc000315 	stw	r16,12(sp)
   1fe74:	d8000415 	stw	zero,16(sp)
   1fe78:	003fd906 	br	1fde0 <__floatunsidf+0x5c>
   1fe7c:	800ad07a 	srli	r5,r16,1
   1fe80:	010007c4 	movi	r4,31
   1fe84:	20c9c83a 	sub	r4,r4,r3
   1fe88:	2908d83a 	srl	r4,r5,r4
   1fe8c:	80e0983a 	sll	r16,r16,r3
   1fe90:	003fce06 	br	1fdcc <__floatunsidf+0x48>
   1fe94:	01400044 	movi	r5,1
   1fe98:	28ca983a 	sll	r5,r5,r3
   1fe9c:	003fe206 	br	1fe28 <__floatunsidf+0xa4>

0001fea0 <udivmodsi4>:
   1fea0:	2005883a 	mov	r2,r4
   1fea4:	2900182e 	bgeu	r5,r4,1ff08 <udivmodsi4+0x68>
   1fea8:	28001716 	blt	r5,zero,1ff08 <udivmodsi4+0x68>
   1feac:	01000804 	movi	r4,32
   1feb0:	00c00044 	movi	r3,1
   1feb4:	00000206 	br	1fec0 <udivmodsi4+0x20>
   1feb8:	20001126 	beq	r4,zero,1ff00 <udivmodsi4+0x60>
   1febc:	28000516 	blt	r5,zero,1fed4 <udivmodsi4+0x34>
   1fec0:	294b883a 	add	r5,r5,r5
   1fec4:	213fffc4 	addi	r4,r4,-1
   1fec8:	18c7883a 	add	r3,r3,r3
   1fecc:	28bffa36 	bltu	r5,r2,1feb8 <udivmodsi4+0x18>
   1fed0:	18000b26 	beq	r3,zero,1ff00 <udivmodsi4+0x60>
   1fed4:	0009883a 	mov	r4,zero
   1fed8:	11400236 	bltu	r2,r5,1fee4 <udivmodsi4+0x44>
   1fedc:	1145c83a 	sub	r2,r2,r5
   1fee0:	20c8b03a 	or	r4,r4,r3
   1fee4:	1806d07a 	srli	r3,r3,1
   1fee8:	280ad07a 	srli	r5,r5,1
   1feec:	183ffa1e 	bne	r3,zero,1fed8 <udivmodsi4+0x38>
   1fef0:	3000021e 	bne	r6,zero,1fefc <udivmodsi4+0x5c>
   1fef4:	2005883a 	mov	r2,r4
   1fef8:	f800283a 	ret
   1fefc:	f800283a 	ret
   1ff00:	0009883a 	mov	r4,zero
   1ff04:	003ffa06 	br	1fef0 <udivmodsi4+0x50>
   1ff08:	00c00044 	movi	r3,1
   1ff0c:	0009883a 	mov	r4,zero
   1ff10:	003ff106 	br	1fed8 <udivmodsi4+0x38>

0001ff14 <__divsi3>:
   1ff14:	defffe04 	addi	sp,sp,-8
   1ff18:	dfc00115 	stw	ra,4(sp)
   1ff1c:	dc000015 	stw	r16,0(sp)
   1ff20:	20000a16 	blt	r4,zero,1ff4c <__divsi3+0x38>
   1ff24:	0021883a 	mov	r16,zero
   1ff28:	28000b16 	blt	r5,zero,1ff58 <__divsi3+0x44>
   1ff2c:	000d883a 	mov	r6,zero
   1ff30:	001fea00 	call	1fea0 <udivmodsi4>
   1ff34:	80000126 	beq	r16,zero,1ff3c <__divsi3+0x28>
   1ff38:	0085c83a 	sub	r2,zero,r2
   1ff3c:	dfc00117 	ldw	ra,4(sp)
   1ff40:	dc000017 	ldw	r16,0(sp)
   1ff44:	dec00204 	addi	sp,sp,8
   1ff48:	f800283a 	ret
   1ff4c:	0109c83a 	sub	r4,zero,r4
   1ff50:	04000044 	movi	r16,1
   1ff54:	283ff50e 	bge	r5,zero,1ff2c <__divsi3+0x18>
   1ff58:	014bc83a 	sub	r5,zero,r5
   1ff5c:	8400005c 	xori	r16,r16,1
   1ff60:	003ff206 	br	1ff2c <__divsi3+0x18>

0001ff64 <__modsi3>:
   1ff64:	deffff04 	addi	sp,sp,-4
   1ff68:	dfc00015 	stw	ra,0(sp)
   1ff6c:	20000516 	blt	r4,zero,1ff84 <__modsi3+0x20>
   1ff70:	28000c16 	blt	r5,zero,1ffa4 <__modsi3+0x40>
   1ff74:	01800044 	movi	r6,1
   1ff78:	dfc00017 	ldw	ra,0(sp)
   1ff7c:	dec00104 	addi	sp,sp,4
   1ff80:	001fea01 	jmpi	1fea0 <udivmodsi4>
   1ff84:	0109c83a 	sub	r4,zero,r4
   1ff88:	28000b16 	blt	r5,zero,1ffb8 <__modsi3+0x54>
   1ff8c:	01800044 	movi	r6,1
   1ff90:	001fea00 	call	1fea0 <udivmodsi4>
   1ff94:	0085c83a 	sub	r2,zero,r2
   1ff98:	dfc00017 	ldw	ra,0(sp)
   1ff9c:	dec00104 	addi	sp,sp,4
   1ffa0:	f800283a 	ret
   1ffa4:	014bc83a 	sub	r5,zero,r5
   1ffa8:	01800044 	movi	r6,1
   1ffac:	dfc00017 	ldw	ra,0(sp)
   1ffb0:	dec00104 	addi	sp,sp,4
   1ffb4:	001fea01 	jmpi	1fea0 <udivmodsi4>
   1ffb8:	014bc83a 	sub	r5,zero,r5
   1ffbc:	003ff306 	br	1ff8c <__modsi3+0x28>

0001ffc0 <__udivsi3>:
   1ffc0:	000d883a 	mov	r6,zero
   1ffc4:	001fea01 	jmpi	1fea0 <udivmodsi4>

0001ffc8 <__umodsi3>:
   1ffc8:	01800044 	movi	r6,1
   1ffcc:	001fea01 	jmpi	1fea0 <udivmodsi4>

0001ffd0 <__muldi3>:
   1ffd0:	20bfffcc 	andi	r2,r4,65535
   1ffd4:	2010d43a 	srli	r8,r4,16
   1ffd8:	30ffffcc 	andi	r3,r6,65535
   1ffdc:	3014d43a 	srli	r10,r6,16
   1ffe0:	1893383a 	mul	r9,r3,r2
   1ffe4:	1a07383a 	mul	r3,r3,r8
   1ffe8:	5085383a 	mul	r2,r10,r2
   1ffec:	4816d43a 	srli	r11,r9,16
   1fff0:	5211383a 	mul	r8,r10,r8
   1fff4:	1885883a 	add	r2,r3,r2
   1fff8:	12c5883a 	add	r2,r2,r11
   1fffc:	10c0022e 	bgeu	r2,r3,20008 <__muldi3+0x38>
   20000:	00c00074 	movhi	r3,1
   20004:	40d1883a 	add	r8,r8,r3
   20008:	1014d43a 	srli	r10,r2,16
   2000c:	21c9383a 	mul	r4,r4,r7
   20010:	314d383a 	mul	r6,r6,r5
   20014:	1004943a 	slli	r2,r2,16
   20018:	4291883a 	add	r8,r8,r10
   2001c:	4a7fffcc 	andi	r9,r9,65535
   20020:	2187883a 	add	r3,r4,r6
   20024:	1245883a 	add	r2,r2,r9
   20028:	1a07883a 	add	r3,r3,r8
   2002c:	f800283a 	ret

00020030 <__clzsi2>:
   20030:	00bfffd4 	movui	r2,65535
   20034:	11000b36 	bltu	r2,r4,20064 <__clzsi2+0x34>
   20038:	00803fc4 	movi	r2,255
   2003c:	11001e2e 	bgeu	r2,r4,200b8 <__clzsi2+0x88>
   20040:	00c00204 	movi	r3,8
   20044:	20c8d83a 	srl	r4,r4,r3
   20048:	00c000f4 	movhi	r3,3
   2004c:	18c05d04 	addi	r3,r3,372
   20050:	00800604 	movi	r2,24
   20054:	1909883a 	add	r4,r3,r4
   20058:	20c00003 	ldbu	r3,0(r4)
   2005c:	10c5c83a 	sub	r2,r2,r3
   20060:	f800283a 	ret
   20064:	00804034 	movhi	r2,256
   20068:	10bfffc4 	addi	r2,r2,-1
   2006c:	11000936 	bltu	r2,r4,20094 <__clzsi2+0x64>
   20070:	00800404 	movi	r2,16
   20074:	1007883a 	mov	r3,r2
   20078:	20c8d83a 	srl	r4,r4,r3
   2007c:	00c000f4 	movhi	r3,3
   20080:	18c05d04 	addi	r3,r3,372
   20084:	1909883a 	add	r4,r3,r4
   20088:	20c00003 	ldbu	r3,0(r4)
   2008c:	10c5c83a 	sub	r2,r2,r3
   20090:	f800283a 	ret
   20094:	00c00604 	movi	r3,24
   20098:	20c8d83a 	srl	r4,r4,r3
   2009c:	00c000f4 	movhi	r3,3
   200a0:	18c05d04 	addi	r3,r3,372
   200a4:	00800204 	movi	r2,8
   200a8:	1909883a 	add	r4,r3,r4
   200ac:	20c00003 	ldbu	r3,0(r4)
   200b0:	10c5c83a 	sub	r2,r2,r3
   200b4:	f800283a 	ret
   200b8:	0007883a 	mov	r3,zero
   200bc:	20c8d83a 	srl	r4,r4,r3
   200c0:	00c000f4 	movhi	r3,3
   200c4:	18c05d04 	addi	r3,r3,372
   200c8:	00800804 	movi	r2,32
   200cc:	1909883a 	add	r4,r3,r4
   200d0:	20c00003 	ldbu	r3,0(r4)
   200d4:	10c5c83a 	sub	r2,r2,r3
   200d8:	f800283a 	ret

000200dc <__pack_d>:
   200dc:	20800017 	ldw	r2,0(r4)
   200e0:	defff804 	addi	sp,sp,-32
   200e4:	dcc00315 	stw	r19,12(sp)
   200e8:	dc800215 	stw	r18,8(sp)
   200ec:	dfc00715 	stw	ra,28(sp)
   200f0:	dd800615 	stw	r22,24(sp)
   200f4:	dd400515 	stw	r21,20(sp)
   200f8:	dd000415 	stw	r20,16(sp)
   200fc:	dc400115 	stw	r17,4(sp)
   20100:	dc000015 	stw	r16,0(sp)
   20104:	04800044 	movi	r18,1
   20108:	24400317 	ldw	r17,12(r4)
   2010c:	24000417 	ldw	r16,16(r4)
   20110:	24c00117 	ldw	r19,4(r4)
   20114:	9080422e 	bgeu	r18,r2,20220 <__pack_d+0x144>
   20118:	00c00104 	movi	r3,4
   2011c:	10c03c26 	beq	r2,r3,20210 <__pack_d+0x134>
   20120:	00c00084 	movi	r3,2
   20124:	10c01926 	beq	r2,r3,2018c <__pack_d+0xb0>
   20128:	8c04b03a 	or	r2,r17,r16
   2012c:	10001726 	beq	r2,zero,2018c <__pack_d+0xb0>
   20130:	21000217 	ldw	r4,8(r4)
   20134:	00bf0084 	movi	r2,-1022
   20138:	20804016 	blt	r4,r2,2023c <__pack_d+0x160>
   2013c:	0080ffc4 	movi	r2,1023
   20140:	11003316 	blt	r2,r4,20210 <__pack_d+0x134>
   20144:	88803fcc 	andi	r2,r17,255
   20148:	00c02004 	movi	r3,128
   2014c:	10c02926 	beq	r2,r3,201f4 <__pack_d+0x118>
   20150:	88801fc4 	addi	r2,r17,127
   20154:	1463803a 	cmpltu	r17,r2,r17
   20158:	8c21883a 	add	r16,r17,r16
   2015c:	1023883a 	mov	r17,r2
   20160:	00880034 	movhi	r2,8192
   20164:	10bfffc4 	addi	r2,r2,-1
   20168:	14001c36 	bltu	r2,r16,201dc <__pack_d+0x100>
   2016c:	2100ffc4 	addi	r4,r4,1023
   20170:	8006963a 	slli	r3,r16,24
   20174:	8804d23a 	srli	r2,r17,8
   20178:	8020913a 	slli	r16,r16,4
   2017c:	2101ffcc 	andi	r4,r4,2047
   20180:	1884b03a 	or	r2,r3,r2
   20184:	8020d33a 	srli	r16,r16,12
   20188:	00000306 	br	20198 <__pack_d+0xbc>
   2018c:	0009883a 	mov	r4,zero
   20190:	0005883a 	mov	r2,zero
   20194:	0021883a 	mov	r16,zero
   20198:	2008953a 	slli	r4,r4,20
   2019c:	982697fa 	slli	r19,r19,31
   201a0:	00c00434 	movhi	r3,16
   201a4:	18ffffc4 	addi	r3,r3,-1
   201a8:	80e0703a 	and	r16,r16,r3
   201ac:	8106b03a 	or	r3,r16,r4
   201b0:	1cc6b03a 	or	r3,r3,r19
   201b4:	dfc00717 	ldw	ra,28(sp)
   201b8:	dd800617 	ldw	r22,24(sp)
   201bc:	dd400517 	ldw	r21,20(sp)
   201c0:	dd000417 	ldw	r20,16(sp)
   201c4:	dcc00317 	ldw	r19,12(sp)
   201c8:	dc800217 	ldw	r18,8(sp)
   201cc:	dc400117 	ldw	r17,4(sp)
   201d0:	dc000017 	ldw	r16,0(sp)
   201d4:	dec00804 	addi	sp,sp,32
   201d8:	f800283a 	ret
   201dc:	800697fa 	slli	r3,r16,31
   201e0:	8804d07a 	srli	r2,r17,1
   201e4:	21010004 	addi	r4,r4,1024
   201e8:	8020d07a 	srli	r16,r16,1
   201ec:	18a2b03a 	or	r17,r3,r2
   201f0:	003fdf06 	br	20170 <__pack_d+0x94>
   201f4:	88c0400c 	andi	r3,r17,256
   201f8:	183fd926 	beq	r3,zero,20160 <__pack_d+0x84>
   201fc:	8885883a 	add	r2,r17,r2
   20200:	1463803a 	cmpltu	r17,r2,r17
   20204:	8c21883a 	add	r16,r17,r16
   20208:	1023883a 	mov	r17,r2
   2020c:	003fd406 	br	20160 <__pack_d+0x84>
   20210:	0101ffc4 	movi	r4,2047
   20214:	0005883a 	mov	r2,zero
   20218:	0021883a 	mov	r16,zero
   2021c:	003fde06 	br	20198 <__pack_d+0xbc>
   20220:	84000234 	orhi	r16,r16,8
   20224:	00c00434 	movhi	r3,16
   20228:	18ffffc4 	addi	r3,r3,-1
   2022c:	8805883a 	mov	r2,r17
   20230:	80e0703a 	and	r16,r16,r3
   20234:	0101ffc4 	movi	r4,2047
   20238:	003fd706 	br	20198 <__pack_d+0xbc>
   2023c:	1129c83a 	sub	r20,r2,r4
   20240:	00800e04 	movi	r2,56
   20244:	15002716 	blt	r2,r20,202e4 <__pack_d+0x208>
   20248:	800b883a 	mov	r5,r16
   2024c:	a00d883a 	mov	r6,r20
   20250:	8809883a 	mov	r4,r17
   20254:	00204d40 	call	204d4 <__lshrdi3>
   20258:	9009883a 	mov	r4,r18
   2025c:	000b883a 	mov	r5,zero
   20260:	a00d883a 	mov	r6,r20
   20264:	102d883a 	mov	r22,r2
   20268:	182b883a 	mov	r21,r3
   2026c:	00205180 	call	20518 <__ashldi3>
   20270:	1009003a 	cmpeq	r4,r2,zero
   20274:	1907c83a 	sub	r3,r3,r4
   20278:	10bfffc4 	addi	r2,r2,-1
   2027c:	1c20703a 	and	r16,r3,r16
   20280:	1444703a 	and	r2,r2,r17
   20284:	1404b03a 	or	r2,r2,r16
   20288:	1004c03a 	cmpne	r2,r2,zero
   2028c:	1584b03a 	or	r2,r2,r22
   20290:	11003fcc 	andi	r4,r2,255
   20294:	01402004 	movi	r5,128
   20298:	a807883a 	mov	r3,r21
   2029c:	2140131e 	bne	r4,r5,202ec <__pack_d+0x210>
   202a0:	1140400c 	andi	r5,r2,256
   202a4:	28000426 	beq	r5,zero,202b8 <__pack_d+0x1dc>
   202a8:	1109883a 	add	r4,r2,r4
   202ac:	2085803a 	cmpltu	r2,r4,r2
   202b0:	1547883a 	add	r3,r2,r21
   202b4:	2005883a 	mov	r2,r4
   202b8:	1808963a 	slli	r4,r3,24
   202bc:	1004d23a 	srli	r2,r2,8
   202c0:	1820913a 	slli	r16,r3,4
   202c4:	01440034 	movhi	r5,4096
   202c8:	297fffc4 	addi	r5,r5,-1
   202cc:	2084b03a 	or	r2,r4,r2
   202d0:	8020d33a 	srli	r16,r16,12
   202d4:	01000044 	movi	r4,1
   202d8:	28ffaf36 	bltu	r5,r3,20198 <__pack_d+0xbc>
   202dc:	0009883a 	mov	r4,zero
   202e0:	003fad06 	br	20198 <__pack_d+0xbc>
   202e4:	0005883a 	mov	r2,zero
   202e8:	0007883a 	mov	r3,zero
   202ec:	11001fc4 	addi	r4,r2,127
   202f0:	2085803a 	cmpltu	r2,r4,r2
   202f4:	10c7883a 	add	r3,r2,r3
   202f8:	2005883a 	mov	r2,r4
   202fc:	003fee06 	br	202b8 <__pack_d+0x1dc>

00020300 <__unpack_d>:
   20300:	21800117 	ldw	r6,4(r4)
   20304:	20c00017 	ldw	r3,0(r4)
   20308:	3004d7fa 	srli	r2,r6,31
   2030c:	3008d53a 	srli	r4,r6,20
   20310:	28800115 	stw	r2,4(r5)
   20314:	2101ffcc 	andi	r4,r4,2047
   20318:	00800434 	movhi	r2,16
   2031c:	10bfffc4 	addi	r2,r2,-1
   20320:	3084703a 	and	r2,r6,r2
   20324:	20001a1e 	bne	r4,zero,20390 <__unpack_d+0x90>
   20328:	1888b03a 	or	r4,r3,r2
   2032c:	20002626 	beq	r4,zero,203c8 <__unpack_d+0xc8>
   20330:	1808d63a 	srli	r4,r3,24
   20334:	1004923a 	slli	r2,r2,8
   20338:	01bf0084 	movi	r6,-1022
   2033c:	29800215 	stw	r6,8(r5)
   20340:	2084b03a 	or	r2,r4,r2
   20344:	010000c4 	movi	r4,3
   20348:	29000015 	stw	r4,0(r5)
   2034c:	02040034 	movhi	r8,4096
   20350:	423fffc4 	addi	r8,r8,-1
   20354:	1806923a 	slli	r3,r3,8
   20358:	40801836 	bltu	r8,r2,203bc <__unpack_d+0xbc>
   2035c:	013f0044 	movi	r4,-1023
   20360:	18cd883a 	add	r6,r3,r3
   20364:	30c7803a 	cmpltu	r3,r6,r3
   20368:	1085883a 	add	r2,r2,r2
   2036c:	1885883a 	add	r2,r3,r2
   20370:	200f883a 	mov	r7,r4
   20374:	3007883a 	mov	r3,r6
   20378:	213fffc4 	addi	r4,r4,-1
   2037c:	40bff82e 	bgeu	r8,r2,20360 <__unpack_d+0x60>
   20380:	29c00215 	stw	r7,8(r5)
   20384:	28c00315 	stw	r3,12(r5)
   20388:	28800415 	stw	r2,16(r5)
   2038c:	f800283a 	ret
   20390:	01c1ffc4 	movi	r7,2047
   20394:	21c00f26 	beq	r4,r7,203d4 <__unpack_d+0xd4>
   20398:	180cd63a 	srli	r6,r3,24
   2039c:	1004923a 	slli	r2,r2,8
   203a0:	213f0044 	addi	r4,r4,-1023
   203a4:	1806923a 	slli	r3,r3,8
   203a8:	3084b03a 	or	r2,r6,r2
   203ac:	29000215 	stw	r4,8(r5)
   203b0:	010000c4 	movi	r4,3
   203b4:	10840034 	orhi	r2,r2,4096
   203b8:	29000015 	stw	r4,0(r5)
   203bc:	28c00315 	stw	r3,12(r5)
   203c0:	28800415 	stw	r2,16(r5)
   203c4:	f800283a 	ret
   203c8:	00800084 	movi	r2,2
   203cc:	28800015 	stw	r2,0(r5)
   203d0:	f800283a 	ret
   203d4:	1888b03a 	or	r4,r3,r2
   203d8:	20000526 	beq	r4,zero,203f0 <__unpack_d+0xf0>
   203dc:	3180022c 	andhi	r6,r6,8
   203e0:	30000626 	beq	r6,zero,203fc <__unpack_d+0xfc>
   203e4:	01000044 	movi	r4,1
   203e8:	29000015 	stw	r4,0(r5)
   203ec:	003ff306 	br	203bc <__unpack_d+0xbc>
   203f0:	00800104 	movi	r2,4
   203f4:	28800015 	stw	r2,0(r5)
   203f8:	f800283a 	ret
   203fc:	28000015 	stw	zero,0(r5)
   20400:	003fee06 	br	203bc <__unpack_d+0xbc>

00020404 <__fpcmp_parts_d>:
   20404:	20c00017 	ldw	r3,0(r4)
   20408:	00800044 	movi	r2,1
   2040c:	10c0142e 	bgeu	r2,r3,20460 <__fpcmp_parts_d+0x5c>
   20410:	29800017 	ldw	r6,0(r5)
   20414:	1180122e 	bgeu	r2,r6,20460 <__fpcmp_parts_d+0x5c>
   20418:	01c00104 	movi	r7,4
   2041c:	19c02826 	beq	r3,r7,204c0 <__fpcmp_parts_d+0xbc>
   20420:	31c00926 	beq	r6,r7,20448 <__fpcmp_parts_d+0x44>
   20424:	01c00084 	movi	r7,2
   20428:	19c00626 	beq	r3,r7,20444 <__fpcmp_parts_d+0x40>
   2042c:	31c00a26 	beq	r6,r7,20458 <__fpcmp_parts_d+0x54>
   20430:	20c00117 	ldw	r3,4(r4)
   20434:	29800117 	ldw	r6,4(r5)
   20438:	19800b26 	beq	r3,r6,20468 <__fpcmp_parts_d+0x64>
   2043c:	1800041e 	bne	r3,zero,20450 <__fpcmp_parts_d+0x4c>
   20440:	f800283a 	ret
   20444:	30c01a26 	beq	r6,r3,204b0 <__fpcmp_parts_d+0xac>
   20448:	28800117 	ldw	r2,4(r5)
   2044c:	1000041e 	bne	r2,zero,20460 <__fpcmp_parts_d+0x5c>
   20450:	00bfffc4 	movi	r2,-1
   20454:	f800283a 	ret
   20458:	20800117 	ldw	r2,4(r4)
   2045c:	103ffc1e 	bne	r2,zero,20450 <__fpcmp_parts_d+0x4c>
   20460:	00800044 	movi	r2,1
   20464:	f800283a 	ret
   20468:	21c00217 	ldw	r7,8(r4)
   2046c:	29800217 	ldw	r6,8(r5)
   20470:	31c0020e 	bge	r6,r7,2047c <__fpcmp_parts_d+0x78>
   20474:	183ff61e 	bne	r3,zero,20450 <__fpcmp_parts_d+0x4c>
   20478:	f800283a 	ret
   2047c:	39800a16 	blt	r7,r6,204a8 <__fpcmp_parts_d+0xa4>
   20480:	20800417 	ldw	r2,16(r4)
   20484:	29800417 	ldw	r6,16(r5)
   20488:	21c00317 	ldw	r7,12(r4)
   2048c:	29000317 	ldw	r4,12(r5)
   20490:	30800936 	bltu	r6,r2,204b8 <__fpcmp_parts_d+0xb4>
   20494:	1180011e 	bne	r2,r6,2049c <__fpcmp_parts_d+0x98>
   20498:	21c00736 	bltu	r4,r7,204b8 <__fpcmp_parts_d+0xb4>
   2049c:	11800236 	bltu	r2,r6,204a8 <__fpcmp_parts_d+0xa4>
   204a0:	3080031e 	bne	r6,r2,204b0 <__fpcmp_parts_d+0xac>
   204a4:	3900022e 	bgeu	r7,r4,204b0 <__fpcmp_parts_d+0xac>
   204a8:	183fe926 	beq	r3,zero,20450 <__fpcmp_parts_d+0x4c>
   204ac:	003fec06 	br	20460 <__fpcmp_parts_d+0x5c>
   204b0:	0005883a 	mov	r2,zero
   204b4:	f800283a 	ret
   204b8:	183fe926 	beq	r3,zero,20460 <__fpcmp_parts_d+0x5c>
   204bc:	003fe406 	br	20450 <__fpcmp_parts_d+0x4c>
   204c0:	30ffe51e 	bne	r6,r3,20458 <__fpcmp_parts_d+0x54>
   204c4:	28c00117 	ldw	r3,4(r5)
   204c8:	20800117 	ldw	r2,4(r4)
   204cc:	1885c83a 	sub	r2,r3,r2
   204d0:	f800283a 	ret

000204d4 <__lshrdi3>:
   204d4:	2005883a 	mov	r2,r4
   204d8:	2807883a 	mov	r3,r5
   204dc:	30000826 	beq	r6,zero,20500 <__lshrdi3+0x2c>
   204e0:	01000804 	movi	r4,32
   204e4:	2189c83a 	sub	r4,r4,r6
   204e8:	0100060e 	bge	zero,r4,20504 <__lshrdi3+0x30>
   204ec:	1184d83a 	srl	r2,r2,r6
   204f0:	2908983a 	sll	r4,r5,r4
   204f4:	298cd83a 	srl	r6,r5,r6
   204f8:	2084b03a 	or	r2,r4,r2
   204fc:	3007883a 	mov	r3,r6
   20500:	f800283a 	ret
   20504:	0105c83a 	sub	r2,zero,r4
   20508:	000d883a 	mov	r6,zero
   2050c:	2884d83a 	srl	r2,r5,r2
   20510:	3007883a 	mov	r3,r6
   20514:	003ffa06 	br	20500 <__lshrdi3+0x2c>

00020518 <__ashldi3>:
   20518:	2005883a 	mov	r2,r4
   2051c:	2807883a 	mov	r3,r5
   20520:	30000826 	beq	r6,zero,20544 <__ashldi3+0x2c>
   20524:	01000804 	movi	r4,32
   20528:	2189c83a 	sub	r4,r4,r6
   2052c:	0100060e 	bge	zero,r4,20548 <__ashldi3+0x30>
   20530:	1108d83a 	srl	r4,r2,r4
   20534:	2986983a 	sll	r3,r5,r6
   20538:	118c983a 	sll	r6,r2,r6
   2053c:	20c6b03a 	or	r3,r4,r3
   20540:	3005883a 	mov	r2,r6
   20544:	f800283a 	ret
   20548:	0107c83a 	sub	r3,zero,r4
   2054c:	000d883a 	mov	r6,zero
   20550:	10c6983a 	sll	r3,r2,r3
   20554:	3005883a 	mov	r2,r6
   20558:	003ffa06 	br	20544 <__ashldi3+0x2c>

0002055c <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
   2055c:	defff404 	addi	sp,sp,-48
   20560:	df000b15 	stw	fp,44(sp)
   20564:	df000b04 	addi	fp,sp,44
   20568:	e13ffc15 	stw	r4,-16(fp)
   2056c:	e17ffd15 	stw	r5,-12(fp)
   20570:	e1bffe15 	stw	r6,-8(fp)
   20574:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
   20578:	e03ff515 	stw	zero,-44(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
   2057c:	008000f4 	movhi	r2,3
   20580:	1099e104 	addi	r2,r2,26500
   20584:	10800017 	ldw	r2,0(r2)
  
  if (alt_ticks_per_second ())
   20588:	10004a26 	beq	r2,zero,206b4 <alt_alarm_start+0x158>
  {
    if (alarm)
   2058c:	e0bffc17 	ldw	r2,-16(fp)
   20590:	10004626 	beq	r2,zero,206ac <alt_alarm_start+0x150>
    {
      alarm->callback = callback;
   20594:	e0bffc17 	ldw	r2,-16(fp)
   20598:	e0fffe17 	ldw	r3,-8(fp)
   2059c:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
   205a0:	e0bffc17 	ldw	r2,-16(fp)
   205a4:	e0ffff17 	ldw	r3,-4(fp)
   205a8:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   205ac:	0005303a 	rdctl	r2,status
   205b0:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   205b4:	e0fff717 	ldw	r3,-36(fp)
   205b8:	00bfff84 	movi	r2,-2
   205bc:	1884703a 	and	r2,r3,r2
   205c0:	1001703a 	wrctl	status,r2
  
  return context;
   205c4:	e0bff717 	ldw	r2,-36(fp)
 
      irq_context = alt_irq_disable_all ();
   205c8:	e0bff615 	stw	r2,-40(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
   205cc:	008000f4 	movhi	r2,3
   205d0:	1099e204 	addi	r2,r2,26504
   205d4:	10800017 	ldw	r2,0(r2)
      
      current_nticks = alt_nticks();
   205d8:	e0bff515 	stw	r2,-44(fp)
      
      alarm->time = nticks + current_nticks + 1; 
   205dc:	e0fffd17 	ldw	r3,-12(fp)
   205e0:	e0bff517 	ldw	r2,-44(fp)
   205e4:	1885883a 	add	r2,r3,r2
   205e8:	10c00044 	addi	r3,r2,1
   205ec:	e0bffc17 	ldw	r2,-16(fp)
   205f0:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
   205f4:	e0bffc17 	ldw	r2,-16(fp)
   205f8:	10c00217 	ldw	r3,8(r2)
   205fc:	e0bff517 	ldw	r2,-44(fp)
   20600:	1880042e 	bgeu	r3,r2,20614 <alt_alarm_start+0xb8>
      {
        alarm->rollover = 1;
   20604:	e0bffc17 	ldw	r2,-16(fp)
   20608:	00c00044 	movi	r3,1
   2060c:	10c00405 	stb	r3,16(r2)
   20610:	00000206 	br	2061c <alt_alarm_start+0xc0>
      }
      else
      {
        alarm->rollover = 0;
   20614:	e0bffc17 	ldw	r2,-16(fp)
   20618:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
   2061c:	e0bffc17 	ldw	r2,-16(fp)
   20620:	00c000f4 	movhi	r3,3
   20624:	18d10204 	addi	r3,r3,17416
   20628:	e0fff815 	stw	r3,-32(fp)
   2062c:	e0bff915 	stw	r2,-28(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
   20630:	e0bff917 	ldw	r2,-28(fp)
   20634:	e0fff817 	ldw	r3,-32(fp)
   20638:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
   2063c:	e0bff817 	ldw	r2,-32(fp)
   20640:	10c00017 	ldw	r3,0(r2)
   20644:	e0bff917 	ldw	r2,-28(fp)
   20648:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
   2064c:	e0bff817 	ldw	r2,-32(fp)
   20650:	10800017 	ldw	r2,0(r2)
   20654:	e0fff917 	ldw	r3,-28(fp)
   20658:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
   2065c:	e0bff817 	ldw	r2,-32(fp)
   20660:	e0fff917 	ldw	r3,-28(fp)
   20664:	10c00015 	stw	r3,0(r2)
   20668:	e0bff617 	ldw	r2,-40(fp)
   2066c:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   20670:	0005303a 	rdctl	r2,status
   20674:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   20678:	e0fffb17 	ldw	r3,-20(fp)
   2067c:	00bfff84 	movi	r2,-2
   20680:	1884703a 	and	r2,r3,r2
   20684:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   20688:	e0bffa17 	ldw	r2,-24(fp)
   2068c:	1080004c 	andi	r2,r2,1
   20690:	e0fffb17 	ldw	r3,-20(fp)
   20694:	1884b03a 	or	r2,r3,r2
   20698:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
   2069c:	e0bffb17 	ldw	r2,-20(fp)
   206a0:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
   206a4:	0005883a 	mov	r2,zero
   206a8:	00000306 	br	206b8 <alt_alarm_start+0x15c>
    }
    else
    {
      return -EINVAL;
   206ac:	00bffa84 	movi	r2,-22
   206b0:	00000106 	br	206b8 <alt_alarm_start+0x15c>
    }
  }
  else
  {
    return -ENOTSUP;
   206b4:	00bfde84 	movi	r2,-134
  }
}
   206b8:	e037883a 	mov	sp,fp
   206bc:	df000017 	ldw	fp,0(sp)
   206c0:	dec00104 	addi	sp,sp,4
   206c4:	f800283a 	ret

000206c8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   206c8:	defffe04 	addi	sp,sp,-8
   206cc:	dfc00115 	stw	ra,4(sp)
   206d0:	df000015 	stw	fp,0(sp)
   206d4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   206d8:	008000f4 	movhi	r2,3
   206dc:	10910004 	addi	r2,r2,17408
   206e0:	10800017 	ldw	r2,0(r2)
   206e4:	10000526 	beq	r2,zero,206fc <alt_get_errno+0x34>
   206e8:	008000f4 	movhi	r2,3
   206ec:	10910004 	addi	r2,r2,17408
   206f0:	10800017 	ldw	r2,0(r2)
   206f4:	103ee83a 	callr	r2
   206f8:	00000206 	br	20704 <alt_get_errno+0x3c>
   206fc:	008000f4 	movhi	r2,3
   20700:	1099dd04 	addi	r2,r2,26484
}
   20704:	e037883a 	mov	sp,fp
   20708:	dfc00117 	ldw	ra,4(sp)
   2070c:	df000017 	ldw	fp,0(sp)
   20710:	dec00204 	addi	sp,sp,8
   20714:	f800283a 	ret

00020718 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
   20718:	defffb04 	addi	sp,sp,-20
   2071c:	dfc00415 	stw	ra,16(sp)
   20720:	df000315 	stw	fp,12(sp)
   20724:	df000304 	addi	fp,sp,12
   20728:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
   2072c:	e0bfff17 	ldw	r2,-4(fp)
   20730:	10000616 	blt	r2,zero,2074c <close+0x34>
   20734:	e0bfff17 	ldw	r2,-4(fp)
   20738:	10c00324 	muli	r3,r2,12
   2073c:	008000f4 	movhi	r2,3
   20740:	108b2404 	addi	r2,r2,11408
   20744:	1885883a 	add	r2,r3,r2
   20748:	00000106 	br	20750 <close+0x38>
   2074c:	0005883a 	mov	r2,zero
   20750:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
   20754:	e0bffd17 	ldw	r2,-12(fp)
   20758:	10001826 	beq	r2,zero,207bc <close+0xa4>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
   2075c:	e0bffd17 	ldw	r2,-12(fp)
   20760:	10800017 	ldw	r2,0(r2)
   20764:	10800417 	ldw	r2,16(r2)
   20768:	10000626 	beq	r2,zero,20784 <close+0x6c>
   2076c:	e0bffd17 	ldw	r2,-12(fp)
   20770:	10800017 	ldw	r2,0(r2)
   20774:	10800417 	ldw	r2,16(r2)
   20778:	e13ffd17 	ldw	r4,-12(fp)
   2077c:	103ee83a 	callr	r2
   20780:	00000106 	br	20788 <close+0x70>
   20784:	0005883a 	mov	r2,zero
   20788:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
   2078c:	e13fff17 	ldw	r4,-4(fp)
   20790:	0020dfc0 	call	20dfc <alt_release_fd>
    if (rval < 0)
   20794:	e0bffe17 	ldw	r2,-8(fp)
   20798:	1000060e 	bge	r2,zero,207b4 <close+0x9c>
    {
      ALT_ERRNO = -rval;
   2079c:	00206c80 	call	206c8 <alt_get_errno>
   207a0:	e0fffe17 	ldw	r3,-8(fp)
   207a4:	00c7c83a 	sub	r3,zero,r3
   207a8:	10c00015 	stw	r3,0(r2)
      return -1;
   207ac:	00bfffc4 	movi	r2,-1
   207b0:	00000606 	br	207cc <close+0xb4>
    }
    return 0;
   207b4:	0005883a 	mov	r2,zero
   207b8:	00000406 	br	207cc <close+0xb4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
   207bc:	00206c80 	call	206c8 <alt_get_errno>
   207c0:	00c01444 	movi	r3,81
   207c4:	10c00015 	stw	r3,0(r2)
    return -1;
   207c8:	00bfffc4 	movi	r2,-1
  }
}
   207cc:	e037883a 	mov	sp,fp
   207d0:	dfc00117 	ldw	ra,4(sp)
   207d4:	df000017 	ldw	fp,0(sp)
   207d8:	dec00204 	addi	sp,sp,8
   207dc:	f800283a 	ret

000207e0 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
   207e0:	defffc04 	addi	sp,sp,-16
   207e4:	df000315 	stw	fp,12(sp)
   207e8:	df000304 	addi	fp,sp,12
   207ec:	e13ffd15 	stw	r4,-12(fp)
   207f0:	e17ffe15 	stw	r5,-8(fp)
   207f4:	e1bfff15 	stw	r6,-4(fp)
  return len;
   207f8:	e0bfff17 	ldw	r2,-4(fp)
}
   207fc:	e037883a 	mov	sp,fp
   20800:	df000017 	ldw	fp,0(sp)
   20804:	dec00104 	addi	sp,sp,4
   20808:	f800283a 	ret

0002080c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   2080c:	defffe04 	addi	sp,sp,-8
   20810:	dfc00115 	stw	ra,4(sp)
   20814:	df000015 	stw	fp,0(sp)
   20818:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   2081c:	008000f4 	movhi	r2,3
   20820:	10910004 	addi	r2,r2,17408
   20824:	10800017 	ldw	r2,0(r2)
   20828:	10000526 	beq	r2,zero,20840 <alt_get_errno+0x34>
   2082c:	008000f4 	movhi	r2,3
   20830:	10910004 	addi	r2,r2,17408
   20834:	10800017 	ldw	r2,0(r2)
   20838:	103ee83a 	callr	r2
   2083c:	00000206 	br	20848 <alt_get_errno+0x3c>
   20840:	008000f4 	movhi	r2,3
   20844:	1099dd04 	addi	r2,r2,26484
}
   20848:	e037883a 	mov	sp,fp
   2084c:	dfc00117 	ldw	ra,4(sp)
   20850:	df000017 	ldw	fp,0(sp)
   20854:	dec00204 	addi	sp,sp,8
   20858:	f800283a 	ret

0002085c <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
   2085c:	defffb04 	addi	sp,sp,-20
   20860:	dfc00415 	stw	ra,16(sp)
   20864:	df000315 	stw	fp,12(sp)
   20868:	df000304 	addi	fp,sp,12
   2086c:	e13ffe15 	stw	r4,-8(fp)
   20870:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
   20874:	e0bffe17 	ldw	r2,-8(fp)
   20878:	10000616 	blt	r2,zero,20894 <fstat+0x38>
   2087c:	e0bffe17 	ldw	r2,-8(fp)
   20880:	10c00324 	muli	r3,r2,12
   20884:	008000f4 	movhi	r2,3
   20888:	108b2404 	addi	r2,r2,11408
   2088c:	1885883a 	add	r2,r3,r2
   20890:	00000106 	br	20898 <fstat+0x3c>
   20894:	0005883a 	mov	r2,zero
   20898:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
   2089c:	e0bffd17 	ldw	r2,-12(fp)
   208a0:	10001026 	beq	r2,zero,208e4 <fstat+0x88>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
   208a4:	e0bffd17 	ldw	r2,-12(fp)
   208a8:	10800017 	ldw	r2,0(r2)
   208ac:	10800817 	ldw	r2,32(r2)
   208b0:	10000726 	beq	r2,zero,208d0 <fstat+0x74>
    {
      return fd->dev->fstat(fd, st);
   208b4:	e0bffd17 	ldw	r2,-12(fp)
   208b8:	10800017 	ldw	r2,0(r2)
   208bc:	10800817 	ldw	r2,32(r2)
   208c0:	e13ffd17 	ldw	r4,-12(fp)
   208c4:	e17fff17 	ldw	r5,-4(fp)
   208c8:	103ee83a 	callr	r2
   208cc:	00000906 	br	208f4 <fstat+0x98>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
   208d0:	e0bfff17 	ldw	r2,-4(fp)
   208d4:	00c80004 	movi	r3,8192
   208d8:	10c00115 	stw	r3,4(r2)
      return 0;
   208dc:	0005883a 	mov	r2,zero
   208e0:	00000406 	br	208f4 <fstat+0x98>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
   208e4:	002080c0 	call	2080c <alt_get_errno>
   208e8:	00c01444 	movi	r3,81
   208ec:	10c00015 	stw	r3,0(r2)
    return -1;
   208f0:	00bfffc4 	movi	r2,-1
  }
}
   208f4:	e037883a 	mov	sp,fp
   208f8:	dfc00117 	ldw	ra,4(sp)
   208fc:	df000017 	ldw	fp,0(sp)
   20900:	dec00204 	addi	sp,sp,8
   20904:	f800283a 	ret

00020908 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   20908:	defffe04 	addi	sp,sp,-8
   2090c:	dfc00115 	stw	ra,4(sp)
   20910:	df000015 	stw	fp,0(sp)
   20914:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   20918:	008000f4 	movhi	r2,3
   2091c:	10910004 	addi	r2,r2,17408
   20920:	10800017 	ldw	r2,0(r2)
   20924:	10000526 	beq	r2,zero,2093c <alt_get_errno+0x34>
   20928:	008000f4 	movhi	r2,3
   2092c:	10910004 	addi	r2,r2,17408
   20930:	10800017 	ldw	r2,0(r2)
   20934:	103ee83a 	callr	r2
   20938:	00000206 	br	20944 <alt_get_errno+0x3c>
   2093c:	008000f4 	movhi	r2,3
   20940:	1099dd04 	addi	r2,r2,26484
}
   20944:	e037883a 	mov	sp,fp
   20948:	dfc00117 	ldw	ra,4(sp)
   2094c:	df000017 	ldw	fp,0(sp)
   20950:	dec00204 	addi	sp,sp,8
   20954:	f800283a 	ret

00020958 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
   20958:	deffed04 	addi	sp,sp,-76
   2095c:	dfc01215 	stw	ra,72(sp)
   20960:	df001115 	stw	fp,68(sp)
   20964:	df001104 	addi	fp,sp,68
   20968:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
   2096c:	e0bfff17 	ldw	r2,-4(fp)
   20970:	10000616 	blt	r2,zero,2098c <isatty+0x34>
   20974:	e0bfff17 	ldw	r2,-4(fp)
   20978:	10c00324 	muli	r3,r2,12
   2097c:	008000f4 	movhi	r2,3
   20980:	108b2404 	addi	r2,r2,11408
   20984:	1885883a 	add	r2,r3,r2
   20988:	00000106 	br	20990 <isatty+0x38>
   2098c:	0005883a 	mov	r2,zero
   20990:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
   20994:	e0bfef17 	ldw	r2,-68(fp)
   20998:	10000e26 	beq	r2,zero,209d4 <isatty+0x7c>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
   2099c:	e0bfef17 	ldw	r2,-68(fp)
   209a0:	10800017 	ldw	r2,0(r2)
   209a4:	10800817 	ldw	r2,32(r2)
   209a8:	1000021e 	bne	r2,zero,209b4 <isatty+0x5c>
    {
      return 1;
   209ac:	00800044 	movi	r2,1
   209b0:	00000c06 	br	209e4 <isatty+0x8c>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
   209b4:	e0bff004 	addi	r2,fp,-64
   209b8:	e13fff17 	ldw	r4,-4(fp)
   209bc:	100b883a 	mov	r5,r2
   209c0:	002085c0 	call	2085c <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
   209c4:	e0bff117 	ldw	r2,-60(fp)
   209c8:	10880020 	cmpeqi	r2,r2,8192
   209cc:	10803fcc 	andi	r2,r2,255
   209d0:	00000406 	br	209e4 <isatty+0x8c>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
   209d4:	00209080 	call	20908 <alt_get_errno>
   209d8:	00c01444 	movi	r3,81
   209dc:	10c00015 	stw	r3,0(r2)
    return 0;
   209e0:	0005883a 	mov	r2,zero
  }
}
   209e4:	e037883a 	mov	sp,fp
   209e8:	dfc00117 	ldw	ra,4(sp)
   209ec:	df000017 	ldw	fp,0(sp)
   209f0:	dec00204 	addi	sp,sp,8
   209f4:	f800283a 	ret

000209f8 <alt_load_section>:
   209f8:	defffc04 	addi	sp,sp,-16
   209fc:	df000315 	stw	fp,12(sp)
   20a00:	df000304 	addi	fp,sp,12
   20a04:	e13ffd15 	stw	r4,-12(fp)
   20a08:	e17ffe15 	stw	r5,-8(fp)
   20a0c:	e1bfff15 	stw	r6,-4(fp)
   20a10:	e0fffe17 	ldw	r3,-8(fp)
   20a14:	e0bffd17 	ldw	r2,-12(fp)
   20a18:	18800e26 	beq	r3,r2,20a54 <alt_load_section+0x5c>
   20a1c:	00000a06 	br	20a48 <alt_load_section+0x50>
   20a20:	e0bffd17 	ldw	r2,-12(fp)
   20a24:	10c00017 	ldw	r3,0(r2)
   20a28:	e0bffe17 	ldw	r2,-8(fp)
   20a2c:	10c00015 	stw	r3,0(r2)
   20a30:	e0bffe17 	ldw	r2,-8(fp)
   20a34:	10800104 	addi	r2,r2,4
   20a38:	e0bffe15 	stw	r2,-8(fp)
   20a3c:	e0bffd17 	ldw	r2,-12(fp)
   20a40:	10800104 	addi	r2,r2,4
   20a44:	e0bffd15 	stw	r2,-12(fp)
   20a48:	e0fffe17 	ldw	r3,-8(fp)
   20a4c:	e0bfff17 	ldw	r2,-4(fp)
   20a50:	18bff31e 	bne	r3,r2,20a20 <alt_load_section+0x28>
   20a54:	e037883a 	mov	sp,fp
   20a58:	df000017 	ldw	fp,0(sp)
   20a5c:	dec00104 	addi	sp,sp,4
   20a60:	f800283a 	ret

00020a64 <alt_load>:
   20a64:	defffe04 	addi	sp,sp,-8
   20a68:	dfc00115 	stw	ra,4(sp)
   20a6c:	df000015 	stw	fp,0(sp)
   20a70:	d839883a 	mov	fp,sp
   20a74:	010000f4 	movhi	r4,3
   20a78:	21110b04 	addi	r4,r4,17452
   20a7c:	014000f4 	movhi	r5,3
   20a80:	29486204 	addi	r5,r5,8584
   20a84:	018000f4 	movhi	r6,3
   20a88:	31910b04 	addi	r6,r6,17452
   20a8c:	00209f80 	call	209f8 <alt_load_section>
   20a90:	01000034 	movhi	r4,0
   20a94:	21000804 	addi	r4,r4,32
   20a98:	01400034 	movhi	r5,0
   20a9c:	29400804 	addi	r5,r5,32
   20aa0:	01800034 	movhi	r6,0
   20aa4:	31800804 	addi	r6,r6,32
   20aa8:	00209f80 	call	209f8 <alt_load_section>
   20aac:	010000f4 	movhi	r4,3
   20ab0:	2133cb04 	addi	r4,r4,-12500
   20ab4:	014000f4 	movhi	r5,3
   20ab8:	2973cb04 	addi	r5,r5,-12500
   20abc:	018000f4 	movhi	r6,3
   20ac0:	31886204 	addi	r6,r6,8584
   20ac4:	00209f80 	call	209f8 <alt_load_section>
   20ac8:	002b8cc0 	call	2b8cc <alt_dcache_flush_all>
   20acc:	002bbd80 	call	2bbd8 <alt_icache_flush_all>
   20ad0:	e037883a 	mov	sp,fp
   20ad4:	dfc00117 	ldw	ra,4(sp)
   20ad8:	df000017 	ldw	fp,0(sp)
   20adc:	dec00204 	addi	sp,sp,8
   20ae0:	f800283a 	ret

00020ae4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   20ae4:	defffe04 	addi	sp,sp,-8
   20ae8:	dfc00115 	stw	ra,4(sp)
   20aec:	df000015 	stw	fp,0(sp)
   20af0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   20af4:	008000f4 	movhi	r2,3
   20af8:	10910004 	addi	r2,r2,17408
   20afc:	10800017 	ldw	r2,0(r2)
   20b00:	10000526 	beq	r2,zero,20b18 <alt_get_errno+0x34>
   20b04:	008000f4 	movhi	r2,3
   20b08:	10910004 	addi	r2,r2,17408
   20b0c:	10800017 	ldw	r2,0(r2)
   20b10:	103ee83a 	callr	r2
   20b14:	00000206 	br	20b20 <alt_get_errno+0x3c>
   20b18:	008000f4 	movhi	r2,3
   20b1c:	1099dd04 	addi	r2,r2,26484
}
   20b20:	e037883a 	mov	sp,fp
   20b24:	dfc00117 	ldw	ra,4(sp)
   20b28:	df000017 	ldw	fp,0(sp)
   20b2c:	dec00204 	addi	sp,sp,8
   20b30:	f800283a 	ret

00020b34 <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
   20b34:	defff904 	addi	sp,sp,-28
   20b38:	dfc00615 	stw	ra,24(sp)
   20b3c:	df000515 	stw	fp,20(sp)
   20b40:	df000504 	addi	fp,sp,20
   20b44:	e13ffd15 	stw	r4,-12(fp)
   20b48:	e17ffe15 	stw	r5,-8(fp)
   20b4c:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
   20b50:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
   20b54:	e0bffd17 	ldw	r2,-12(fp)
   20b58:	10000616 	blt	r2,zero,20b74 <lseek+0x40>
   20b5c:	e0bffd17 	ldw	r2,-12(fp)
   20b60:	10c00324 	muli	r3,r2,12
   20b64:	008000f4 	movhi	r2,3
   20b68:	108b2404 	addi	r2,r2,11408
   20b6c:	1885883a 	add	r2,r3,r2
   20b70:	00000106 	br	20b78 <lseek+0x44>
   20b74:	0005883a 	mov	r2,zero
   20b78:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
   20b7c:	e0bffc17 	ldw	r2,-16(fp)
   20b80:	10001026 	beq	r2,zero,20bc4 <lseek+0x90>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
   20b84:	e0bffc17 	ldw	r2,-16(fp)
   20b88:	10800017 	ldw	r2,0(r2)
   20b8c:	10800717 	ldw	r2,28(r2)
   20b90:	10000926 	beq	r2,zero,20bb8 <lseek+0x84>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
   20b94:	e0bffc17 	ldw	r2,-16(fp)
   20b98:	10800017 	ldw	r2,0(r2)
   20b9c:	10800717 	ldw	r2,28(r2)
   20ba0:	e13ffc17 	ldw	r4,-16(fp)
   20ba4:	e17ffe17 	ldw	r5,-8(fp)
   20ba8:	e1bfff17 	ldw	r6,-4(fp)
   20bac:	103ee83a 	callr	r2
   20bb0:	e0bffb15 	stw	r2,-20(fp)
   20bb4:	00000506 	br	20bcc <lseek+0x98>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
   20bb8:	00bfde84 	movi	r2,-134
   20bbc:	e0bffb15 	stw	r2,-20(fp)
   20bc0:	00000206 	br	20bcc <lseek+0x98>
    }
  }
  else  
  {
    rc = -EBADFD;
   20bc4:	00bfebc4 	movi	r2,-81
   20bc8:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
   20bcc:	e0bffb17 	ldw	r2,-20(fp)
   20bd0:	1000060e 	bge	r2,zero,20bec <lseek+0xb8>
  {
    ALT_ERRNO = -rc;
   20bd4:	0020ae40 	call	20ae4 <alt_get_errno>
   20bd8:	e0fffb17 	ldw	r3,-20(fp)
   20bdc:	00c7c83a 	sub	r3,zero,r3
   20be0:	10c00015 	stw	r3,0(r2)
    rc = -1;
   20be4:	00bfffc4 	movi	r2,-1
   20be8:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
   20bec:	e0bffb17 	ldw	r2,-20(fp)
}
   20bf0:	e037883a 	mov	sp,fp
   20bf4:	dfc00117 	ldw	ra,4(sp)
   20bf8:	df000017 	ldw	fp,0(sp)
   20bfc:	dec00204 	addi	sp,sp,8
   20c00:	f800283a 	ret

00020c04 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
   20c04:	defffd04 	addi	sp,sp,-12
   20c08:	dfc00215 	stw	ra,8(sp)
   20c0c:	df000115 	stw	fp,4(sp)
   20c10:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
   20c14:	0009883a 	mov	r4,zero
   20c18:	00213680 	call	21368 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
   20c1c:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
   20c20:	00213a80 	call	213a8 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
   20c24:	010000f4 	movhi	r4,3
   20c28:	2100a004 	addi	r4,r4,640
   20c2c:	014000f4 	movhi	r5,3
   20c30:	2940a004 	addi	r5,r5,640
   20c34:	018000f4 	movhi	r6,3
   20c38:	3180a004 	addi	r6,r6,640
   20c3c:	002bcc80 	call	2bcc8 <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
   20c40:	002b9d80 	call	2b9d8 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
   20c44:	010000f4 	movhi	r4,3
   20c48:	212e8d04 	addi	r4,r4,-17868
   20c4c:	002ca9c0 	call	2ca9c <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
   20c50:	d128f217 	ldw	r4,-23608(gp)
   20c54:	d0e8f317 	ldw	r3,-23604(gp)
   20c58:	d0a8f417 	ldw	r2,-23600(gp)
   20c5c:	180b883a 	mov	r5,r3
   20c60:	100d883a 	mov	r6,r2
   20c64:	0016b800 	call	16b80 <main>
   20c68:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
   20c6c:	01000044 	movi	r4,1
   20c70:	00207180 	call	20718 <close>
  exit (result);
   20c74:	e13fff17 	ldw	r4,-4(fp)
   20c78:	002cab00 	call	2cab0 <exit>

00020c7c <__malloc_lock>:
   20c7c:	defffe04 	addi	sp,sp,-8
   20c80:	df000115 	stw	fp,4(sp)
   20c84:	df000104 	addi	fp,sp,4
   20c88:	e13fff15 	stw	r4,-4(fp)
   20c8c:	e037883a 	mov	sp,fp
   20c90:	df000017 	ldw	fp,0(sp)
   20c94:	dec00104 	addi	sp,sp,4
   20c98:	f800283a 	ret

00020c9c <__malloc_unlock>:
   20c9c:	defffe04 	addi	sp,sp,-8
   20ca0:	df000115 	stw	fp,4(sp)
   20ca4:	df000104 	addi	fp,sp,4
   20ca8:	e13fff15 	stw	r4,-4(fp)
   20cac:	e037883a 	mov	sp,fp
   20cb0:	df000017 	ldw	fp,0(sp)
   20cb4:	dec00104 	addi	sp,sp,4
   20cb8:	f800283a 	ret

00020cbc <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   20cbc:	defffe04 	addi	sp,sp,-8
   20cc0:	dfc00115 	stw	ra,4(sp)
   20cc4:	df000015 	stw	fp,0(sp)
   20cc8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   20ccc:	008000f4 	movhi	r2,3
   20cd0:	10910004 	addi	r2,r2,17408
   20cd4:	10800017 	ldw	r2,0(r2)
   20cd8:	10000526 	beq	r2,zero,20cf0 <alt_get_errno+0x34>
   20cdc:	008000f4 	movhi	r2,3
   20ce0:	10910004 	addi	r2,r2,17408
   20ce4:	10800017 	ldw	r2,0(r2)
   20ce8:	103ee83a 	callr	r2
   20cec:	00000206 	br	20cf8 <alt_get_errno+0x3c>
   20cf0:	008000f4 	movhi	r2,3
   20cf4:	1099dd04 	addi	r2,r2,26484
}
   20cf8:	e037883a 	mov	sp,fp
   20cfc:	dfc00117 	ldw	ra,4(sp)
   20d00:	df000017 	ldw	fp,0(sp)
   20d04:	dec00204 	addi	sp,sp,8
   20d08:	f800283a 	ret

00020d0c <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
   20d0c:	defff904 	addi	sp,sp,-28
   20d10:	dfc00615 	stw	ra,24(sp)
   20d14:	df000515 	stw	fp,20(sp)
   20d18:	df000504 	addi	fp,sp,20
   20d1c:	e13ffd15 	stw	r4,-12(fp)
   20d20:	e17ffe15 	stw	r5,-8(fp)
   20d24:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
   20d28:	e0bffd17 	ldw	r2,-12(fp)
   20d2c:	10000616 	blt	r2,zero,20d48 <read+0x3c>
   20d30:	e0bffd17 	ldw	r2,-12(fp)
   20d34:	10c00324 	muli	r3,r2,12
   20d38:	008000f4 	movhi	r2,3
   20d3c:	108b2404 	addi	r2,r2,11408
   20d40:	1885883a 	add	r2,r3,r2
   20d44:	00000106 	br	20d4c <read+0x40>
   20d48:	0005883a 	mov	r2,zero
   20d4c:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
   20d50:	e0bffb17 	ldw	r2,-20(fp)
   20d54:	10002026 	beq	r2,zero,20dd8 <read+0xcc>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
   20d58:	e0bffb17 	ldw	r2,-20(fp)
   20d5c:	10800217 	ldw	r2,8(r2)
   20d60:	108000cc 	andi	r2,r2,3
   20d64:	10800060 	cmpeqi	r2,r2,1
   20d68:	1000171e 	bne	r2,zero,20dc8 <read+0xbc>
        (fd->dev->read))
   20d6c:	e0bffb17 	ldw	r2,-20(fp)
   20d70:	10800017 	ldw	r2,0(r2)
   20d74:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
   20d78:	10001326 	beq	r2,zero,20dc8 <read+0xbc>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
   20d7c:	e0bffb17 	ldw	r2,-20(fp)
   20d80:	10800017 	ldw	r2,0(r2)
   20d84:	10c00517 	ldw	r3,20(r2)
   20d88:	e0bfff17 	ldw	r2,-4(fp)
   20d8c:	e13ffb17 	ldw	r4,-20(fp)
   20d90:	e17ffe17 	ldw	r5,-8(fp)
   20d94:	100d883a 	mov	r6,r2
   20d98:	183ee83a 	callr	r3
   20d9c:	e0bffc15 	stw	r2,-16(fp)
   20da0:	e0bffc17 	ldw	r2,-16(fp)
   20da4:	1000060e 	bge	r2,zero,20dc0 <read+0xb4>
        {
          ALT_ERRNO = -rval;
   20da8:	0020cbc0 	call	20cbc <alt_get_errno>
   20dac:	e0fffc17 	ldw	r3,-16(fp)
   20db0:	00c7c83a 	sub	r3,zero,r3
   20db4:	10c00015 	stw	r3,0(r2)
          return -1;
   20db8:	00bfffc4 	movi	r2,-1
   20dbc:	00000a06 	br	20de8 <read+0xdc>
        }
        return rval;
   20dc0:	e0bffc17 	ldw	r2,-16(fp)
   20dc4:	00000806 	br	20de8 <read+0xdc>
      }
      else
      {
        ALT_ERRNO = EACCES;
   20dc8:	0020cbc0 	call	20cbc <alt_get_errno>
   20dcc:	00c00344 	movi	r3,13
   20dd0:	10c00015 	stw	r3,0(r2)
   20dd4:	00000306 	br	20de4 <read+0xd8>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
   20dd8:	0020cbc0 	call	20cbc <alt_get_errno>
   20ddc:	00c01444 	movi	r3,81
   20de0:	10c00015 	stw	r3,0(r2)
  }
  return -1;
   20de4:	00bfffc4 	movi	r2,-1
}
   20de8:	e037883a 	mov	sp,fp
   20dec:	dfc00117 	ldw	ra,4(sp)
   20df0:	df000017 	ldw	fp,0(sp)
   20df4:	dec00204 	addi	sp,sp,8
   20df8:	f800283a 	ret

00020dfc <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
   20dfc:	defffe04 	addi	sp,sp,-8
   20e00:	df000115 	stw	fp,4(sp)
   20e04:	df000104 	addi	fp,sp,4
   20e08:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
   20e0c:	e0bfff17 	ldw	r2,-4(fp)
   20e10:	108000d0 	cmplti	r2,r2,3
   20e14:	10000d1e 	bne	r2,zero,20e4c <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
   20e18:	00c000f4 	movhi	r3,3
   20e1c:	18cb2404 	addi	r3,r3,11408
   20e20:	e0bfff17 	ldw	r2,-4(fp)
   20e24:	10800324 	muli	r2,r2,12
   20e28:	1885883a 	add	r2,r3,r2
   20e2c:	10800204 	addi	r2,r2,8
   20e30:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
   20e34:	00c000f4 	movhi	r3,3
   20e38:	18cb2404 	addi	r3,r3,11408
   20e3c:	e0bfff17 	ldw	r2,-4(fp)
   20e40:	10800324 	muli	r2,r2,12
   20e44:	1885883a 	add	r2,r3,r2
   20e48:	10000015 	stw	zero,0(r2)
  }
}
   20e4c:	e037883a 	mov	sp,fp
   20e50:	df000017 	ldw	fp,0(sp)
   20e54:	dec00104 	addi	sp,sp,4
   20e58:	f800283a 	ret

00020e5c <alt_remap_uncached>:
 * Convert a pointer to a block of cached memory, into a block of
 * uncached memory.
 */

volatile void* alt_remap_uncached (void* ptr, alt_u32 len)
{
   20e5c:	defffc04 	addi	sp,sp,-16
   20e60:	dfc00315 	stw	ra,12(sp)
   20e64:	df000215 	stw	fp,8(sp)
   20e68:	df000204 	addi	fp,sp,8
   20e6c:	e13ffe15 	stw	r4,-8(fp)
   20e70:	e17fff15 	stw	r5,-4(fp)
  alt_dcache_flush (ptr, len);
   20e74:	e13ffe17 	ldw	r4,-8(fp)
   20e78:	e17fff17 	ldw	r5,-4(fp)
   20e7c:	002b8a80 	call	2b8a8 <alt_dcache_flush>
  return (volatile void*) (((alt_u32) ptr) | BYPASS_DCACHE_MASK);
   20e80:	e0bffe17 	ldw	r2,-8(fp)
   20e84:	10a00034 	orhi	r2,r2,32768
}
   20e88:	e037883a 	mov	sp,fp
   20e8c:	dfc00117 	ldw	ra,4(sp)
   20e90:	df000017 	ldw	fp,0(sp)
   20e94:	dec00204 	addi	sp,sp,8
   20e98:	f800283a 	ret

00020e9c <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
   20e9c:	defff704 	addi	sp,sp,-36
   20ea0:	df000815 	stw	fp,32(sp)
   20ea4:	df000804 	addi	fp,sp,32
   20ea8:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   20eac:	0005303a 	rdctl	r2,status
   20eb0:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   20eb4:	e0fffa17 	ldw	r3,-24(fp)
   20eb8:	00bfff84 	movi	r2,-2
   20ebc:	1884703a 	and	r2,r3,r2
   20ec0:	1001703a 	wrctl	status,r2
  
  return context;
   20ec4:	e0bffa17 	ldw	r2,-24(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
   20ec8:	e0bff815 	stw	r2,-32(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
   20ecc:	d0a01517 	ldw	r2,-32684(gp)
   20ed0:	10c000c4 	addi	r3,r2,3
   20ed4:	00bfff04 	movi	r2,-4
   20ed8:	1884703a 	and	r2,r3,r2
   20edc:	d0a01515 	stw	r2,-32684(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
   20ee0:	d0e01517 	ldw	r3,-32684(gp)
   20ee4:	e0bfff17 	ldw	r2,-4(fp)
   20ee8:	1885883a 	add	r2,r3,r2
   20eec:	00c08034 	movhi	r3,512
   20ef0:	18c00004 	addi	r3,r3,0
   20ef4:	1880112e 	bgeu	r3,r2,20f3c <sbrk+0xa0>
   20ef8:	e0bff817 	ldw	r2,-32(fp)
   20efc:	e0bffb15 	stw	r2,-20(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   20f00:	0005303a 	rdctl	r2,status
   20f04:	e0bffc15 	stw	r2,-16(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   20f08:	e0fffc17 	ldw	r3,-16(fp)
   20f0c:	00bfff84 	movi	r2,-2
   20f10:	1884703a 	and	r2,r3,r2
   20f14:	e0bffc15 	stw	r2,-16(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   20f18:	e0bffb17 	ldw	r2,-20(fp)
   20f1c:	1080004c 	andi	r2,r2,1
   20f20:	e0fffc17 	ldw	r3,-16(fp)
   20f24:	1884b03a 	or	r2,r3,r2
   20f28:	e0bffc15 	stw	r2,-16(fp)
  
  NIOS2_WRITE_STATUS (status);
   20f2c:	e0bffc17 	ldw	r2,-16(fp)
   20f30:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
   20f34:	00bfffc4 	movi	r2,-1
   20f38:	00001606 	br	20f94 <sbrk+0xf8>
  }
#endif

  prev_heap_end = heap_end; 
   20f3c:	d0a01517 	ldw	r2,-32684(gp)
   20f40:	e0bff915 	stw	r2,-28(fp)
  heap_end += incr; 
   20f44:	d0e01517 	ldw	r3,-32684(gp)
   20f48:	e0bfff17 	ldw	r2,-4(fp)
   20f4c:	1885883a 	add	r2,r3,r2
   20f50:	d0a01515 	stw	r2,-32684(gp)
   20f54:	e0bff817 	ldw	r2,-32(fp)
   20f58:	e0bffd15 	stw	r2,-12(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   20f5c:	0005303a 	rdctl	r2,status
   20f60:	e0bffe15 	stw	r2,-8(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   20f64:	e0fffe17 	ldw	r3,-8(fp)
   20f68:	00bfff84 	movi	r2,-2
   20f6c:	1884703a 	and	r2,r3,r2
   20f70:	e0bffe15 	stw	r2,-8(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   20f74:	e0bffd17 	ldw	r2,-12(fp)
   20f78:	1080004c 	andi	r2,r2,1
   20f7c:	e0fffe17 	ldw	r3,-8(fp)
   20f80:	1884b03a 	or	r2,r3,r2
   20f84:	e0bffe15 	stw	r2,-8(fp)
  
  NIOS2_WRITE_STATUS (status);
   20f88:	e0bffe17 	ldw	r2,-8(fp)
   20f8c:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
   20f90:	e0bff917 	ldw	r2,-28(fp)
} 
   20f94:	e037883a 	mov	sp,fp
   20f98:	df000017 	ldw	fp,0(sp)
   20f9c:	dec00104 	addi	sp,sp,4
   20fa0:	f800283a 	ret

00020fa4 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
   20fa4:	defff904 	addi	sp,sp,-28
   20fa8:	df000615 	stw	fp,24(sp)
   20fac:	df000604 	addi	fp,sp,24
   20fb0:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   20fb4:	0005303a 	rdctl	r2,status
   20fb8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   20fbc:	e0fffb17 	ldw	r3,-20(fp)
   20fc0:	00bfff84 	movi	r2,-2
   20fc4:	1884703a 	and	r2,r3,r2
   20fc8:	1001703a 	wrctl	status,r2
  
  return context;
   20fcc:	e0bffb17 	ldw	r2,-20(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
   20fd0:	e0bffa15 	stw	r2,-24(fp)
  alt_llist_remove (&alarm->llist);
   20fd4:	e0bfff17 	ldw	r2,-4(fp)
   20fd8:	e0bffc15 	stw	r2,-16(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
   20fdc:	e0bffc17 	ldw	r2,-16(fp)
   20fe0:	10800017 	ldw	r2,0(r2)
   20fe4:	e0fffc17 	ldw	r3,-16(fp)
   20fe8:	18c00117 	ldw	r3,4(r3)
   20fec:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
   20ff0:	e0bffc17 	ldw	r2,-16(fp)
   20ff4:	10800117 	ldw	r2,4(r2)
   20ff8:	e0fffc17 	ldw	r3,-16(fp)
   20ffc:	18c00017 	ldw	r3,0(r3)
   21000:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
   21004:	e0bffc17 	ldw	r2,-16(fp)
   21008:	e0fffc17 	ldw	r3,-16(fp)
   2100c:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
   21010:	e0bffc17 	ldw	r2,-16(fp)
   21014:	e0fffc17 	ldw	r3,-16(fp)
   21018:	10c00015 	stw	r3,0(r2)
   2101c:	e0bffa17 	ldw	r2,-24(fp)
   21020:	e0bffd15 	stw	r2,-12(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   21024:	0005303a 	rdctl	r2,status
   21028:	e0bffe15 	stw	r2,-8(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   2102c:	e0fffe17 	ldw	r3,-8(fp)
   21030:	00bfff84 	movi	r2,-2
   21034:	1884703a 	and	r2,r3,r2
   21038:	e0bffe15 	stw	r2,-8(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   2103c:	e0bffd17 	ldw	r2,-12(fp)
   21040:	1080004c 	andi	r2,r2,1
   21044:	e0fffe17 	ldw	r3,-8(fp)
   21048:	1884b03a 	or	r2,r3,r2
   2104c:	e0bffe15 	stw	r2,-8(fp)
  
  NIOS2_WRITE_STATUS (status);
   21050:	e0bffe17 	ldw	r2,-8(fp)
   21054:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
   21058:	e037883a 	mov	sp,fp
   2105c:	df000017 	ldw	fp,0(sp)
   21060:	dec00104 	addi	sp,sp,4
   21064:	f800283a 	ret

00021068 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
   21068:	defffb04 	addi	sp,sp,-20
   2106c:	dfc00415 	stw	ra,16(sp)
   21070:	df000315 	stw	fp,12(sp)
   21074:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
   21078:	d0a01617 	ldw	r2,-32680(gp)
   2107c:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
   21080:	d0a8f617 	ldw	r2,-23592(gp)
   21084:	10800044 	addi	r2,r2,1
   21088:	d0a8f615 	stw	r2,-23592(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
   2108c:	00002e06 	br	21148 <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
   21090:	e0bffd17 	ldw	r2,-12(fp)
   21094:	10800017 	ldw	r2,0(r2)
   21098:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
   2109c:	e0bffd17 	ldw	r2,-12(fp)
   210a0:	10800403 	ldbu	r2,16(r2)
   210a4:	10803fcc 	andi	r2,r2,255
   210a8:	10000426 	beq	r2,zero,210bc <alt_tick+0x54>
   210ac:	d0a8f617 	ldw	r2,-23592(gp)
   210b0:	1000021e 	bne	r2,zero,210bc <alt_tick+0x54>
    {
      alarm->rollover = 0;
   210b4:	e0bffd17 	ldw	r2,-12(fp)
   210b8:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
   210bc:	e0bffd17 	ldw	r2,-12(fp)
   210c0:	10800217 	ldw	r2,8(r2)
   210c4:	d0e8f617 	ldw	r3,-23592(gp)
   210c8:	18801d36 	bltu	r3,r2,21140 <alt_tick+0xd8>
   210cc:	e0bffd17 	ldw	r2,-12(fp)
   210d0:	10800403 	ldbu	r2,16(r2)
   210d4:	10803fcc 	andi	r2,r2,255
   210d8:	1000191e 	bne	r2,zero,21140 <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
   210dc:	e0bffd17 	ldw	r2,-12(fp)
   210e0:	10c00317 	ldw	r3,12(r2)
   210e4:	e0bffd17 	ldw	r2,-12(fp)
   210e8:	10800517 	ldw	r2,20(r2)
   210ec:	1009883a 	mov	r4,r2
   210f0:	183ee83a 	callr	r3
   210f4:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
   210f8:	e0bfff17 	ldw	r2,-4(fp)
   210fc:	1000031e 	bne	r2,zero,2110c <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
   21100:	e13ffd17 	ldw	r4,-12(fp)
   21104:	0020fa40 	call	20fa4 <alt_alarm_stop>
   21108:	00000d06 	br	21140 <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
   2110c:	e0bffd17 	ldw	r2,-12(fp)
   21110:	10c00217 	ldw	r3,8(r2)
   21114:	e0bfff17 	ldw	r2,-4(fp)
   21118:	1887883a 	add	r3,r3,r2
   2111c:	e0bffd17 	ldw	r2,-12(fp)
   21120:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
   21124:	e0bffd17 	ldw	r2,-12(fp)
   21128:	10c00217 	ldw	r3,8(r2)
   2112c:	d0a8f617 	ldw	r2,-23592(gp)
   21130:	1880032e 	bgeu	r3,r2,21140 <alt_tick+0xd8>
        {
          alarm->rollover = 1;
   21134:	e0bffd17 	ldw	r2,-12(fp)
   21138:	00c00044 	movi	r3,1
   2113c:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
   21140:	e0bffe17 	ldw	r2,-8(fp)
   21144:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
   21148:	e0fffd17 	ldw	r3,-12(fp)
   2114c:	d0a01604 	addi	r2,gp,-32680
   21150:	18bfcf1e 	bne	r3,r2,21090 <alt_tick+0x28>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
   21154:	0001883a 	nop
}
   21158:	e037883a 	mov	sp,fp
   2115c:	dfc00117 	ldw	ra,4(sp)
   21160:	df000017 	ldw	fp,0(sp)
   21164:	dec00204 	addi	sp,sp,8
   21168:	f800283a 	ret

0002116c <alt_uncached_malloc>:
/*
 * Allocate a block of uncached memory.
 */

volatile void* alt_uncached_malloc (size_t size)
{
   2116c:	defffc04 	addi	sp,sp,-16
   21170:	dfc00315 	stw	ra,12(sp)
   21174:	df000215 	stw	fp,8(sp)
   21178:	df000204 	addi	fp,sp,8
   2117c:	e13fff15 	stw	r4,-4(fp)
  void* ptr;

  ptr = malloc (size);
   21180:	e13fff17 	ldw	r4,-4(fp)
   21184:	002cae80 	call	2cae8 <malloc>
   21188:	e0bffe15 	stw	r2,-8(fp)

  alt_dcache_flush (ptr, size);
   2118c:	e13ffe17 	ldw	r4,-8(fp)
   21190:	e17fff17 	ldw	r5,-4(fp)
   21194:	002b8a80 	call	2b8a8 <alt_dcache_flush>

  return ptr ? (volatile void*) (((alt_u32) ptr) | BYPASS_DCACHE_MASK) : NULL;
   21198:	e0bffe17 	ldw	r2,-8(fp)
   2119c:	10000326 	beq	r2,zero,211ac <alt_uncached_malloc+0x40>
   211a0:	e0bffe17 	ldw	r2,-8(fp)
   211a4:	10a00034 	orhi	r2,r2,32768
   211a8:	00000106 	br	211b0 <alt_uncached_malloc+0x44>
   211ac:	0005883a 	mov	r2,zero
}
   211b0:	e037883a 	mov	sp,fp
   211b4:	dfc00117 	ldw	ra,4(sp)
   211b8:	df000017 	ldw	fp,0(sp)
   211bc:	dec00204 	addi	sp,sp,8
   211c0:	f800283a 	ret

000211c4 <usleep>:
   211c4:	defffd04 	addi	sp,sp,-12
   211c8:	dfc00215 	stw	ra,8(sp)
   211cc:	df000115 	stw	fp,4(sp)
   211d0:	df000104 	addi	fp,sp,4
   211d4:	e13fff15 	stw	r4,-4(fp)
   211d8:	e13fff17 	ldw	r4,-4(fp)
   211dc:	002b7800 	call	2b780 <alt_busy_sleep>
   211e0:	e037883a 	mov	sp,fp
   211e4:	dfc00117 	ldw	ra,4(sp)
   211e8:	df000017 	ldw	fp,0(sp)
   211ec:	dec00204 	addi	sp,sp,8
   211f0:	f800283a 	ret

000211f4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   211f4:	defffe04 	addi	sp,sp,-8
   211f8:	dfc00115 	stw	ra,4(sp)
   211fc:	df000015 	stw	fp,0(sp)
   21200:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   21204:	008000f4 	movhi	r2,3
   21208:	10910004 	addi	r2,r2,17408
   2120c:	10800017 	ldw	r2,0(r2)
   21210:	10000526 	beq	r2,zero,21228 <alt_get_errno+0x34>
   21214:	008000f4 	movhi	r2,3
   21218:	10910004 	addi	r2,r2,17408
   2121c:	10800017 	ldw	r2,0(r2)
   21220:	103ee83a 	callr	r2
   21224:	00000206 	br	21230 <alt_get_errno+0x3c>
   21228:	008000f4 	movhi	r2,3
   2122c:	1099dd04 	addi	r2,r2,26484
}
   21230:	e037883a 	mov	sp,fp
   21234:	dfc00117 	ldw	ra,4(sp)
   21238:	df000017 	ldw	fp,0(sp)
   2123c:	dec00204 	addi	sp,sp,8
   21240:	f800283a 	ret

00021244 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
   21244:	defff904 	addi	sp,sp,-28
   21248:	dfc00615 	stw	ra,24(sp)
   2124c:	df000515 	stw	fp,20(sp)
   21250:	df000504 	addi	fp,sp,20
   21254:	e13ffd15 	stw	r4,-12(fp)
   21258:	e17ffe15 	stw	r5,-8(fp)
   2125c:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
   21260:	e0bffd17 	ldw	r2,-12(fp)
   21264:	10000616 	blt	r2,zero,21280 <write+0x3c>
   21268:	e0bffd17 	ldw	r2,-12(fp)
   2126c:	10c00324 	muli	r3,r2,12
   21270:	008000f4 	movhi	r2,3
   21274:	108b2404 	addi	r2,r2,11408
   21278:	1885883a 	add	r2,r3,r2
   2127c:	00000106 	br	21284 <write+0x40>
   21280:	0005883a 	mov	r2,zero
   21284:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
   21288:	e0bffb17 	ldw	r2,-20(fp)
   2128c:	10001f26 	beq	r2,zero,2130c <write+0xc8>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
   21290:	e0bffb17 	ldw	r2,-20(fp)
   21294:	10800217 	ldw	r2,8(r2)
   21298:	108000cc 	andi	r2,r2,3
   2129c:	10001726 	beq	r2,zero,212fc <write+0xb8>
   212a0:	e0bffb17 	ldw	r2,-20(fp)
   212a4:	10800017 	ldw	r2,0(r2)
   212a8:	10800617 	ldw	r2,24(r2)
   212ac:	10001326 	beq	r2,zero,212fc <write+0xb8>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
   212b0:	e0bffb17 	ldw	r2,-20(fp)
   212b4:	10800017 	ldw	r2,0(r2)
   212b8:	10c00617 	ldw	r3,24(r2)
   212bc:	e0bfff17 	ldw	r2,-4(fp)
   212c0:	e13ffb17 	ldw	r4,-20(fp)
   212c4:	e17ffe17 	ldw	r5,-8(fp)
   212c8:	100d883a 	mov	r6,r2
   212cc:	183ee83a 	callr	r3
   212d0:	e0bffc15 	stw	r2,-16(fp)
   212d4:	e0bffc17 	ldw	r2,-16(fp)
   212d8:	1000060e 	bge	r2,zero,212f4 <write+0xb0>
      {
        ALT_ERRNO = -rval;
   212dc:	00211f40 	call	211f4 <alt_get_errno>
   212e0:	e0fffc17 	ldw	r3,-16(fp)
   212e4:	00c7c83a 	sub	r3,zero,r3
   212e8:	10c00015 	stw	r3,0(r2)
        return -1;
   212ec:	00bfffc4 	movi	r2,-1
   212f0:	00000a06 	br	2131c <write+0xd8>
      }
      return rval;
   212f4:	e0bffc17 	ldw	r2,-16(fp)
   212f8:	00000806 	br	2131c <write+0xd8>
    }
    else
    {
      ALT_ERRNO = EACCES;
   212fc:	00211f40 	call	211f4 <alt_get_errno>
   21300:	00c00344 	movi	r3,13
   21304:	10c00015 	stw	r3,0(r2)
   21308:	00000306 	br	21318 <write+0xd4>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
   2130c:	00211f40 	call	211f4 <alt_get_errno>
   21310:	00c01444 	movi	r3,81
   21314:	10c00015 	stw	r3,0(r2)
  }
  return -1;
   21318:	00bfffc4 	movi	r2,-1
}
   2131c:	e037883a 	mov	sp,fp
   21320:	dfc00117 	ldw	ra,4(sp)
   21324:	df000017 	ldw	fp,0(sp)
   21328:	dec00204 	addi	sp,sp,8
   2132c:	f800283a 	ret

00021330 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
   21330:	defffd04 	addi	sp,sp,-12
   21334:	dfc00215 	stw	ra,8(sp)
   21338:	df000115 	stw	fp,4(sp)
   2133c:	df000104 	addi	fp,sp,4
   21340:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
   21344:	e13fff17 	ldw	r4,-4(fp)
   21348:	014000f4 	movhi	r5,3
   2134c:	2950fd04 	addi	r5,r5,17396
   21350:	002b9380 	call	2b938 <alt_dev_llist_insert>
}
   21354:	e037883a 	mov	sp,fp
   21358:	dfc00117 	ldw	ra,4(sp)
   2135c:	df000017 	ldw	fp,0(sp)
   21360:	dec00204 	addi	sp,sp,8
   21364:	f800283a 	ret

00021368 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
   21368:	defffd04 	addi	sp,sp,-12
   2136c:	dfc00215 	stw	ra,8(sp)
   21370:	df000115 	stw	fp,4(sp)
   21374:	df000104 	addi	fp,sp,4
   21378:	e13fff15 	stw	r4,-4(fp)
    ALTERA_VIC_IRQ_INIT ( VIC_0, vic_0);
   2137c:	010000f4 	movhi	r4,3
   21380:	210b8404 	addi	r4,r4,11792
   21384:	002b4ec0 	call	2b4ec <alt_vic_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts ()
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
   21388:	00802034 	movhi	r2,128
   2138c:	10800044 	addi	r2,r2,1
   21390:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
   21394:	e037883a 	mov	sp,fp
   21398:	dfc00117 	ldw	ra,4(sp)
   2139c:	df000017 	ldw	fp,0(sp)
   213a0:	dec00204 	addi	sp,sp,8
   213a4:	f800283a 	ret

000213a8 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
   213a8:	defffe04 	addi	sp,sp,-8
   213ac:	dfc00115 	stw	ra,4(sp)
   213b0:	df000015 	stw	fp,0(sp)
   213b4:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( SYS_CLK_TIMER, sys_clk_timer);
   213b8:	01020034 	movhi	r4,2048
   213bc:	21005804 	addi	r4,r4,352
   213c0:	000b883a 	mov	r5,zero
   213c4:	000d883a 	mov	r6,zero
   213c8:	01c0fa04 	movi	r7,1000
   213cc:	00258f00 	call	258f0 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_TIMER_INIT ( TIMER_5, timer_5);
    ALTERA_AVALON_TIMER_INIT ( TIMER_6, timer_6);
    ALTERA_AVALON_TIMER_INIT ( TIMER_7, timer_7);
    ALTERA_AVALON_TIMER_INIT ( TIMER_8, timer_8);
    ALTERA_AVALON_TIMER_INIT ( TIMER_9, timer_9);
    ALTERA_AVALON_CFI_FLASH_INIT ( EXT_FLASH, ext_flash);
   213d0:	010000f4 	movhi	r4,3
   213d4:	210bab04 	addi	r4,r4,11948
   213d8:	00214f00 	call	214f0 <alt_flash_cfi_init>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
   213dc:	010000f4 	movhi	r4,3
   213e0:	210beb04 	addi	r4,r4,12204
   213e4:	000b883a 	mov	r5,zero
   213e8:	01800044 	movi	r6,1
   213ec:	00232e00 	call	232e0 <altera_avalon_jtag_uart_init>
   213f0:	010000f4 	movhi	r4,3
   213f4:	210be104 	addi	r4,r4,12164
   213f8:	00213300 	call	21330 <alt_dev_reg>
    ALTERA_AVALON_LCD_16207_INIT ( LCD, lcd);
   213fc:	010000f4 	movhi	r4,3
   21400:	21100304 	addi	r4,r4,16396
   21404:	002498c0 	call	2498c <altera_avalon_lcd_16207_init>
   21408:	010000f4 	movhi	r4,3
   2140c:	210ff904 	addi	r4,r4,16356
   21410:	00213300 	call	21330 <alt_dev_reg>
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_RX, sgdma_rx);
   21414:	010000f4 	movhi	r4,3
   21418:	21104104 	addi	r4,r4,16644
   2141c:	000b883a 	mov	r5,zero
   21420:	01800304 	movi	r6,12
   21424:	00257ac0 	call	257ac <alt_avalon_sgdma_init>
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_TX, sgdma_tx);
   21428:	010000f4 	movhi	r4,3
   2142c:	21104d04 	addi	r4,r4,16692
   21430:	000b883a 	mov	r5,zero
   21434:	01800344 	movi	r6,13
   21438:	00257ac0 	call	257ac <alt_avalon_sgdma_init>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID, sysid);
   2143c:	0001883a 	nop
    ALTERA_AVALON_UART_INIT ( RS232, rs232);
   21440:	010000f4 	movhi	r4,3
   21444:	21106304 	addi	r4,r4,16780
   21448:	000b883a 	mov	r5,zero
   2144c:	018001c4 	movi	r6,7
   21450:	002aa300 	call	2aa30 <altera_avalon_uart_init>
   21454:	010000f4 	movhi	r4,3
   21458:	21105904 	addi	r4,r4,16740
   2145c:	00213300 	call	21330 <alt_dev_reg>
    ALTERA_AVALON_UART_INIT ( UART_0, uart_0);
   21460:	010000f4 	movhi	r4,3
   21464:	21109404 	addi	r4,r4,16976
   21468:	000b883a 	mov	r5,zero
   2146c:	018000c4 	movi	r6,3
   21470:	002aa300 	call	2aa30 <altera_avalon_uart_init>
   21474:	010000f4 	movhi	r4,3
   21478:	21108a04 	addi	r4,r4,16936
   2147c:	00213300 	call	21330 <alt_dev_reg>
    ALTERA_AVALON_UART_INIT ( UART_1, uart_1);
   21480:	010000f4 	movhi	r4,3
   21484:	2110c504 	addi	r4,r4,17172
   21488:	000b883a 	mov	r5,zero
   2148c:	01800104 	movi	r6,4
   21490:	002aa300 	call	2aa30 <altera_avalon_uart_init>
   21494:	010000f4 	movhi	r4,3
   21498:	2110bb04 	addi	r4,r4,17132
   2149c:	00213300 	call	21330 <alt_dev_reg>
    ALTERA_ETH_TSE_INIT ( TSE_MAC, tse_mac);
   214a0:	0001883a 	nop
}
   214a4:	e037883a 	mov	sp,fp
   214a8:	dfc00117 	ldw	ra,4(sp)
   214ac:	df000017 	ldw	fp,0(sp)
   214b0:	dec00204 	addi	sp,sp,8
   214b4:	f800283a 	ret

000214b8 <alt_flash_device_register>:
   214b8:	defffd04 	addi	sp,sp,-12
   214bc:	dfc00215 	stw	ra,8(sp)
   214c0:	df000115 	stw	fp,4(sp)
   214c4:	df000104 	addi	fp,sp,4
   214c8:	e13fff15 	stw	r4,-4(fp)
   214cc:	e13fff17 	ldw	r4,-4(fp)
   214d0:	014000f4 	movhi	r5,3
   214d4:	29510804 	addi	r5,r5,17440
   214d8:	002b9380 	call	2b938 <alt_dev_llist_insert>
   214dc:	e037883a 	mov	sp,fp
   214e0:	dfc00117 	ldw	ra,4(sp)
   214e4:	df000017 	ldw	fp,0(sp)
   214e8:	dec00204 	addi	sp,sp,8
   214ec:	f800283a 	ret

000214f0 <alt_flash_cfi_init>:
   214f0:	defffc04 	addi	sp,sp,-16
   214f4:	dfc00315 	stw	ra,12(sp)
   214f8:	df000215 	stw	fp,8(sp)
   214fc:	df000204 	addi	fp,sp,8
   21500:	e13fff15 	stw	r4,-4(fp)
   21504:	e03ffe15 	stw	zero,-8(fp)
   21508:	e13fff17 	ldw	r4,-4(fp)
   2150c:	00229380 	call	22938 <alt_read_cfi_width>
   21510:	e0bffe15 	stw	r2,-8(fp)
   21514:	e0bffe17 	ldw	r2,-8(fp)
   21518:	1000031e 	bne	r2,zero,21528 <alt_flash_cfi_init+0x38>
   2151c:	e13fff17 	ldw	r4,-4(fp)
   21520:	00220900 	call	22090 <alt_set_flash_width_func>
   21524:	e0bffe15 	stw	r2,-8(fp)
   21528:	e0bffe17 	ldw	r2,-8(fp)
   2152c:	1000031e 	bne	r2,zero,2153c <alt_flash_cfi_init+0x4c>
   21530:	e13fff17 	ldw	r4,-4(fp)
   21534:	00223700 	call	22370 <alt_read_cfi_table>
   21538:	e0bffe15 	stw	r2,-8(fp)
   2153c:	e0bffe17 	ldw	r2,-8(fp)
   21540:	1000031e 	bne	r2,zero,21550 <alt_flash_cfi_init+0x60>
   21544:	e13fff17 	ldw	r4,-4(fp)
   21548:	00222540 	call	22254 <alt_set_flash_algorithm_func>
   2154c:	e0bffe15 	stw	r2,-8(fp)
   21550:	e0bffe17 	ldw	r2,-8(fp)
   21554:	1000041e 	bne	r2,zero,21568 <alt_flash_cfi_init+0x78>
   21558:	e0bfff17 	ldw	r2,-4(fp)
   2155c:	1009883a 	mov	r4,r2
   21560:	00214b80 	call	214b8 <alt_flash_device_register>
   21564:	e0bffe15 	stw	r2,-8(fp)
   21568:	e0bffe17 	ldw	r2,-8(fp)
   2156c:	e037883a 	mov	sp,fp
   21570:	dfc00117 	ldw	ra,4(sp)
   21574:	df000017 	ldw	fp,0(sp)
   21578:	dec00204 	addi	sp,sp,8
   2157c:	f800283a 	ret

00021580 <alt_flash_cfi_write>:
   21580:	defff104 	addi	sp,sp,-60
   21584:	dfc00e15 	stw	ra,56(sp)
   21588:	df000d15 	stw	fp,52(sp)
   2158c:	df000d04 	addi	fp,sp,52
   21590:	e13ffc15 	stw	r4,-16(fp)
   21594:	e17ffd15 	stw	r5,-12(fp)
   21598:	e1bffe15 	stw	r6,-8(fp)
   2159c:	e1ffff15 	stw	r7,-4(fp)
   215a0:	e03ff415 	stw	zero,-48(fp)
   215a4:	e0bfff17 	ldw	r2,-4(fp)
   215a8:	e0bff815 	stw	r2,-32(fp)
   215ac:	e0bffd17 	ldw	r2,-12(fp)
   215b0:	e0bff915 	stw	r2,-28(fp)
   215b4:	e0bffc17 	ldw	r2,-16(fp)
   215b8:	e0bffa15 	stw	r2,-24(fp)
   215bc:	e03ff515 	stw	zero,-44(fp)
   215c0:	00008806 	br	217e4 <alt_flash_cfi_write+0x264>
   215c4:	e0fffa17 	ldw	r3,-24(fp)
   215c8:	e0bff517 	ldw	r2,-44(fp)
   215cc:	1004913a 	slli	r2,r2,4
   215d0:	1885883a 	add	r2,r3,r2
   215d4:	10800d04 	addi	r2,r2,52
   215d8:	10800017 	ldw	r2,0(r2)
   215dc:	e0fffd17 	ldw	r3,-12(fp)
   215e0:	18807d16 	blt	r3,r2,217d8 <alt_flash_cfi_write+0x258>
   215e4:	e0fffa17 	ldw	r3,-24(fp)
   215e8:	e0bff517 	ldw	r2,-44(fp)
   215ec:	1004913a 	slli	r2,r2,4
   215f0:	1885883a 	add	r2,r3,r2
   215f4:	10800d04 	addi	r2,r2,52
   215f8:	10c00017 	ldw	r3,0(r2)
   215fc:	e13ffa17 	ldw	r4,-24(fp)
   21600:	e0bff517 	ldw	r2,-44(fp)
   21604:	1004913a 	slli	r2,r2,4
   21608:	2085883a 	add	r2,r4,r2
   2160c:	10800e04 	addi	r2,r2,56
   21610:	10800017 	ldw	r2,0(r2)
   21614:	1885883a 	add	r2,r3,r2
   21618:	e0fffd17 	ldw	r3,-12(fp)
   2161c:	18806e0e 	bge	r3,r2,217d8 <alt_flash_cfi_write+0x258>
   21620:	e0fffa17 	ldw	r3,-24(fp)
   21624:	e0bff517 	ldw	r2,-44(fp)
   21628:	1004913a 	slli	r2,r2,4
   2162c:	1885883a 	add	r2,r3,r2
   21630:	10800d04 	addi	r2,r2,52
   21634:	10800017 	ldw	r2,0(r2)
   21638:	e0bff715 	stw	r2,-36(fp)
   2163c:	e03ff615 	stw	zero,-40(fp)
   21640:	00005d06 	br	217b8 <alt_flash_cfi_write+0x238>
   21644:	e0fffd17 	ldw	r3,-12(fp)
   21648:	e0bff717 	ldw	r2,-36(fp)
   2164c:	18804e16 	blt	r3,r2,21788 <alt_flash_cfi_write+0x208>
   21650:	e0fffa17 	ldw	r3,-24(fp)
   21654:	e0bff517 	ldw	r2,-44(fp)
   21658:	10800104 	addi	r2,r2,4
   2165c:	1004913a 	slli	r2,r2,4
   21660:	1885883a 	add	r2,r3,r2
   21664:	10c00017 	ldw	r3,0(r2)
   21668:	e0bff717 	ldw	r2,-36(fp)
   2166c:	1885883a 	add	r2,r3,r2
   21670:	e0fffd17 	ldw	r3,-12(fp)
   21674:	1880440e 	bge	r3,r2,21788 <alt_flash_cfi_write+0x208>
   21678:	e0fffa17 	ldw	r3,-24(fp)
   2167c:	e0bff517 	ldw	r2,-44(fp)
   21680:	10800104 	addi	r2,r2,4
   21684:	1004913a 	slli	r2,r2,4
   21688:	1885883a 	add	r2,r3,r2
   2168c:	10c00017 	ldw	r3,0(r2)
   21690:	e0bff717 	ldw	r2,-36(fp)
   21694:	1887883a 	add	r3,r3,r2
   21698:	e0bffd17 	ldw	r2,-12(fp)
   2169c:	1885c83a 	sub	r2,r3,r2
   216a0:	e0bffb15 	stw	r2,-20(fp)
   216a4:	e0fffb17 	ldw	r3,-20(fp)
   216a8:	e0bfff17 	ldw	r2,-4(fp)
   216ac:	1880010e 	bge	r3,r2,216b4 <alt_flash_cfi_write+0x134>
   216b0:	1805883a 	mov	r2,r3
   216b4:	e0bffb15 	stw	r2,-20(fp)
   216b8:	e0bffa17 	ldw	r2,-24(fp)
   216bc:	10c00a17 	ldw	r3,40(r2)
   216c0:	e0bffd17 	ldw	r2,-12(fp)
   216c4:	1887883a 	add	r3,r3,r2
   216c8:	e0bffb17 	ldw	r2,-20(fp)
   216cc:	e13ffe17 	ldw	r4,-8(fp)
   216d0:	180b883a 	mov	r5,r3
   216d4:	100d883a 	mov	r6,r2
   216d8:	002cb100 	call	2cb10 <memcmp>
   216dc:	10001426 	beq	r2,zero,21730 <alt_flash_cfi_write+0x1b0>
   216e0:	e0bffa17 	ldw	r2,-24(fp)
   216e4:	10c00817 	ldw	r3,32(r2)
   216e8:	e0bffa17 	ldw	r2,-24(fp)
   216ec:	1009883a 	mov	r4,r2
   216f0:	e17ff717 	ldw	r5,-36(fp)
   216f4:	183ee83a 	callr	r3
   216f8:	e0bff415 	stw	r2,-48(fp)
   216fc:	e0bff417 	ldw	r2,-48(fp)
   21700:	10000b1e 	bne	r2,zero,21730 <alt_flash_cfi_write+0x1b0>
   21704:	e0bffa17 	ldw	r2,-24(fp)
   21708:	10c00917 	ldw	r3,36(r2)
   2170c:	e0bffa17 	ldw	r2,-24(fp)
   21710:	e13ffb17 	ldw	r4,-20(fp)
   21714:	d9000015 	stw	r4,0(sp)
   21718:	1009883a 	mov	r4,r2
   2171c:	e17ff717 	ldw	r5,-36(fp)
   21720:	e1bffd17 	ldw	r6,-12(fp)
   21724:	e1fffe17 	ldw	r7,-8(fp)
   21728:	183ee83a 	callr	r3
   2172c:	e0bff415 	stw	r2,-48(fp)
   21730:	e0ffff17 	ldw	r3,-4(fp)
   21734:	e0bffb17 	ldw	r2,-20(fp)
   21738:	18802e26 	beq	r3,r2,217f4 <alt_flash_cfi_write+0x274>
   2173c:	e0bff417 	ldw	r2,-48(fp)
   21740:	10002c1e 	bne	r2,zero,217f4 <alt_flash_cfi_write+0x274>
   21744:	e0ffff17 	ldw	r3,-4(fp)
   21748:	e0bffb17 	ldw	r2,-20(fp)
   2174c:	1885c83a 	sub	r2,r3,r2
   21750:	e0bfff15 	stw	r2,-4(fp)
   21754:	e0fffa17 	ldw	r3,-24(fp)
   21758:	e0bff517 	ldw	r2,-44(fp)
   2175c:	10800104 	addi	r2,r2,4
   21760:	1004913a 	slli	r2,r2,4
   21764:	1885883a 	add	r2,r3,r2
   21768:	10c00017 	ldw	r3,0(r2)
   2176c:	e0bff717 	ldw	r2,-36(fp)
   21770:	1885883a 	add	r2,r3,r2
   21774:	e0bffd15 	stw	r2,-12(fp)
   21778:	e0bffb17 	ldw	r2,-20(fp)
   2177c:	e0fffe17 	ldw	r3,-8(fp)
   21780:	1885883a 	add	r2,r3,r2
   21784:	e0bffe15 	stw	r2,-8(fp)
   21788:	e0fffa17 	ldw	r3,-24(fp)
   2178c:	e0bff517 	ldw	r2,-44(fp)
   21790:	10800104 	addi	r2,r2,4
   21794:	1004913a 	slli	r2,r2,4
   21798:	1885883a 	add	r2,r3,r2
   2179c:	10800017 	ldw	r2,0(r2)
   217a0:	e0fff717 	ldw	r3,-36(fp)
   217a4:	1885883a 	add	r2,r3,r2
   217a8:	e0bff715 	stw	r2,-36(fp)
   217ac:	e0bff617 	ldw	r2,-40(fp)
   217b0:	10800044 	addi	r2,r2,1
   217b4:	e0bff615 	stw	r2,-40(fp)
   217b8:	e0fffa17 	ldw	r3,-24(fp)
   217bc:	e0bff517 	ldw	r2,-44(fp)
   217c0:	1004913a 	slli	r2,r2,4
   217c4:	1885883a 	add	r2,r3,r2
   217c8:	10800f04 	addi	r2,r2,60
   217cc:	10800017 	ldw	r2,0(r2)
   217d0:	e0fff617 	ldw	r3,-40(fp)
   217d4:	18bf9b16 	blt	r3,r2,21644 <alt_flash_cfi_write+0xc4>
   217d8:	e0bff517 	ldw	r2,-44(fp)
   217dc:	10800044 	addi	r2,r2,1
   217e0:	e0bff515 	stw	r2,-44(fp)
   217e4:	e0bffa17 	ldw	r2,-24(fp)
   217e8:	10800c17 	ldw	r2,48(r2)
   217ec:	e0fff517 	ldw	r3,-44(fp)
   217f0:	18bf7416 	blt	r3,r2,215c4 <alt_flash_cfi_write+0x44>
   217f4:	e0bffa17 	ldw	r2,-24(fp)
   217f8:	10c00a17 	ldw	r3,40(r2)
   217fc:	e0bff917 	ldw	r2,-28(fp)
   21800:	1887883a 	add	r3,r3,r2
   21804:	e0bff817 	ldw	r2,-32(fp)
   21808:	1809883a 	mov	r4,r3
   2180c:	100b883a 	mov	r5,r2
   21810:	002b8a80 	call	2b8a8 <alt_dcache_flush>
   21814:	e0bff417 	ldw	r2,-48(fp)
   21818:	e037883a 	mov	sp,fp
   2181c:	dfc00117 	ldw	ra,4(sp)
   21820:	df000017 	ldw	fp,0(sp)
   21824:	dec00204 	addi	sp,sp,8
   21828:	f800283a 	ret

0002182c <alt_flash_cfi_get_info>:
   2182c:	defffa04 	addi	sp,sp,-24
   21830:	df000515 	stw	fp,20(sp)
   21834:	df000504 	addi	fp,sp,20
   21838:	e13ffd15 	stw	r4,-12(fp)
   2183c:	e17ffe15 	stw	r5,-8(fp)
   21840:	e1bfff15 	stw	r6,-4(fp)
   21844:	e03ffb15 	stw	zero,-20(fp)
   21848:	e0bffd17 	ldw	r2,-12(fp)
   2184c:	e0bffc15 	stw	r2,-16(fp)
   21850:	e0bffc17 	ldw	r2,-16(fp)
   21854:	10c00c17 	ldw	r3,48(r2)
   21858:	e0bfff17 	ldw	r2,-4(fp)
   2185c:	10c00015 	stw	r3,0(r2)
   21860:	e0bffc17 	ldw	r2,-16(fp)
   21864:	10800c17 	ldw	r2,48(r2)
   21868:	1000031e 	bne	r2,zero,21878 <alt_flash_cfi_get_info+0x4c>
   2186c:	00bffec4 	movi	r2,-5
   21870:	e0bffb15 	stw	r2,-20(fp)
   21874:	00000b06 	br	218a4 <alt_flash_cfi_get_info+0x78>
   21878:	e0bffc17 	ldw	r2,-16(fp)
   2187c:	10800c17 	ldw	r2,48(r2)
   21880:	10800250 	cmplti	r2,r2,9
   21884:	1000031e 	bne	r2,zero,21894 <alt_flash_cfi_get_info+0x68>
   21888:	00bffd04 	movi	r2,-12
   2188c:	e0bffb15 	stw	r2,-20(fp)
   21890:	00000406 	br	218a4 <alt_flash_cfi_get_info+0x78>
   21894:	e0bffc17 	ldw	r2,-16(fp)
   21898:	10c00d04 	addi	r3,r2,52
   2189c:	e0bffe17 	ldw	r2,-8(fp)
   218a0:	10c00015 	stw	r3,0(r2)
   218a4:	e0bffb17 	ldw	r2,-20(fp)
   218a8:	e037883a 	mov	sp,fp
   218ac:	df000017 	ldw	fp,0(sp)
   218b0:	dec00104 	addi	sp,sp,4
   218b4:	f800283a 	ret

000218b8 <alt_flash_cfi_read>:
   218b8:	defff904 	addi	sp,sp,-28
   218bc:	dfc00615 	stw	ra,24(sp)
   218c0:	df000515 	stw	fp,20(sp)
   218c4:	df000504 	addi	fp,sp,20
   218c8:	e13ffc15 	stw	r4,-16(fp)
   218cc:	e17ffd15 	stw	r5,-12(fp)
   218d0:	e1bffe15 	stw	r6,-8(fp)
   218d4:	e1ffff15 	stw	r7,-4(fp)
   218d8:	e0bffc17 	ldw	r2,-16(fp)
   218dc:	e0bffb15 	stw	r2,-20(fp)
   218e0:	e0bffb17 	ldw	r2,-20(fp)
   218e4:	10c00a17 	ldw	r3,40(r2)
   218e8:	e0bffd17 	ldw	r2,-12(fp)
   218ec:	1887883a 	add	r3,r3,r2
   218f0:	e0bfff17 	ldw	r2,-4(fp)
   218f4:	e13ffe17 	ldw	r4,-8(fp)
   218f8:	180b883a 	mov	r5,r3
   218fc:	100d883a 	mov	r6,r2
   21900:	0016e680 	call	16e68 <memcpy>
   21904:	0005883a 	mov	r2,zero
   21908:	e037883a 	mov	sp,fp
   2190c:	dfc00117 	ldw	ra,4(sp)
   21910:	df000017 	ldw	fp,0(sp)
   21914:	dec00204 	addi	sp,sp,8
   21918:	f800283a 	ret

0002191c <alt_write_value_to_flash>:
   2191c:	defffa04 	addi	sp,sp,-24
   21920:	df000515 	stw	fp,20(sp)
   21924:	df000504 	addi	fp,sp,20
   21928:	e13ffd15 	stw	r4,-12(fp)
   2192c:	e17ffe15 	stw	r5,-8(fp)
   21930:	e1bfff15 	stw	r6,-4(fp)
   21934:	e0bffd17 	ldw	r2,-12(fp)
   21938:	10802e17 	ldw	r2,184(r2)
   2193c:	10800058 	cmpnei	r2,r2,1
   21940:	1000091e 	bne	r2,zero,21968 <alt_write_value_to_flash+0x4c>
   21944:	e0bffd17 	ldw	r2,-12(fp)
   21948:	10c00a17 	ldw	r3,40(r2)
   2194c:	e0bffe17 	ldw	r2,-8(fp)
   21950:	1885883a 	add	r2,r3,r2
   21954:	e0ffff17 	ldw	r3,-4(fp)
   21958:	18c00003 	ldbu	r3,0(r3)
   2195c:	18c03fcc 	andi	r3,r3,255
   21960:	10c00025 	stbio	r3,0(r2)
   21964:	00003e06 	br	21a60 <alt_write_value_to_flash+0x144>
   21968:	e0bffd17 	ldw	r2,-12(fp)
   2196c:	10802e17 	ldw	r2,184(r2)
   21970:	10800098 	cmpnei	r2,r2,2
   21974:	1000141e 	bne	r2,zero,219c8 <alt_write_value_to_flash+0xac>
   21978:	e0bfff17 	ldw	r2,-4(fp)
   2197c:	10800003 	ldbu	r2,0(r2)
   21980:	10803fcc 	andi	r2,r2,255
   21984:	e0bffb0d 	sth	r2,-20(fp)
   21988:	e0bfff17 	ldw	r2,-4(fp)
   2198c:	10800044 	addi	r2,r2,1
   21990:	10800003 	ldbu	r2,0(r2)
   21994:	10803fcc 	andi	r2,r2,255
   21998:	1004923a 	slli	r2,r2,8
   2199c:	1007883a 	mov	r3,r2
   219a0:	e0bffb0b 	ldhu	r2,-20(fp)
   219a4:	1884b03a 	or	r2,r3,r2
   219a8:	e0bffb0d 	sth	r2,-20(fp)
   219ac:	e0bffd17 	ldw	r2,-12(fp)
   219b0:	10c00a17 	ldw	r3,40(r2)
   219b4:	e0bffe17 	ldw	r2,-8(fp)
   219b8:	1885883a 	add	r2,r3,r2
   219bc:	e0fffb0b 	ldhu	r3,-20(fp)
   219c0:	10c0002d 	sthio	r3,0(r2)
   219c4:	00002606 	br	21a60 <alt_write_value_to_flash+0x144>
   219c8:	e0bffd17 	ldw	r2,-12(fp)
   219cc:	10802e17 	ldw	r2,184(r2)
   219d0:	10800118 	cmpnei	r2,r2,4
   219d4:	1000221e 	bne	r2,zero,21a60 <alt_write_value_to_flash+0x144>
   219d8:	e0bfff17 	ldw	r2,-4(fp)
   219dc:	10800003 	ldbu	r2,0(r2)
   219e0:	10803fcc 	andi	r2,r2,255
   219e4:	e0bffc15 	stw	r2,-16(fp)
   219e8:	e0bfff17 	ldw	r2,-4(fp)
   219ec:	10800044 	addi	r2,r2,1
   219f0:	10800003 	ldbu	r2,0(r2)
   219f4:	10803fcc 	andi	r2,r2,255
   219f8:	1004923a 	slli	r2,r2,8
   219fc:	e0fffc17 	ldw	r3,-16(fp)
   21a00:	1884b03a 	or	r2,r3,r2
   21a04:	e0bffc15 	stw	r2,-16(fp)
   21a08:	e0bfff17 	ldw	r2,-4(fp)
   21a0c:	10800084 	addi	r2,r2,2
   21a10:	10800003 	ldbu	r2,0(r2)
   21a14:	10803fcc 	andi	r2,r2,255
   21a18:	1004943a 	slli	r2,r2,16
   21a1c:	e0fffc17 	ldw	r3,-16(fp)
   21a20:	1884b03a 	or	r2,r3,r2
   21a24:	e0bffc15 	stw	r2,-16(fp)
   21a28:	e0bfff17 	ldw	r2,-4(fp)
   21a2c:	108000c4 	addi	r2,r2,3
   21a30:	10800003 	ldbu	r2,0(r2)
   21a34:	10803fcc 	andi	r2,r2,255
   21a38:	1004963a 	slli	r2,r2,24
   21a3c:	e0fffc17 	ldw	r3,-16(fp)
   21a40:	1884b03a 	or	r2,r3,r2
   21a44:	e0bffc15 	stw	r2,-16(fp)
   21a48:	e0bffd17 	ldw	r2,-12(fp)
   21a4c:	10c00a17 	ldw	r3,40(r2)
   21a50:	e0bffe17 	ldw	r2,-8(fp)
   21a54:	1885883a 	add	r2,r3,r2
   21a58:	e0fffc17 	ldw	r3,-16(fp)
   21a5c:	10c00035 	stwio	r3,0(r2)
   21a60:	0001883a 	nop
   21a64:	e037883a 	mov	sp,fp
   21a68:	df000017 	ldw	fp,0(sp)
   21a6c:	dec00104 	addi	sp,sp,4
   21a70:	f800283a 	ret

00021a74 <alt_flash_program_block>:
   21a74:	defff304 	addi	sp,sp,-52
   21a78:	dfc00c15 	stw	ra,48(sp)
   21a7c:	df000b15 	stw	fp,44(sp)
   21a80:	df000b04 	addi	fp,sp,44
   21a84:	e13ffc15 	stw	r4,-16(fp)
   21a88:	e17ffd15 	stw	r5,-12(fp)
   21a8c:	e1bffe15 	stw	r6,-8(fp)
   21a90:	e1ffff15 	stw	r7,-4(fp)
   21a94:	e03ff515 	stw	zero,-44(fp)
   21a98:	e0bffc17 	ldw	r2,-16(fp)
   21a9c:	10c00a17 	ldw	r3,40(r2)
   21aa0:	e0bffd17 	ldw	r2,-12(fp)
   21aa4:	1885883a 	add	r2,r3,r2
   21aa8:	e0fffc17 	ldw	r3,-16(fp)
   21aac:	18c02e17 	ldw	r3,184(r3)
   21ab0:	10c9283a 	div	r4,r2,r3
   21ab4:	20c7383a 	mul	r3,r4,r3
   21ab8:	10c5c83a 	sub	r2,r2,r3
   21abc:	e0bff815 	stw	r2,-32(fp)
   21ac0:	e0bff817 	ldw	r2,-32(fp)
   21ac4:	10003b26 	beq	r2,zero,21bb4 <alt_flash_program_block+0x140>
   21ac8:	e0bffc17 	ldw	r2,-16(fp)
   21acc:	10c02e17 	ldw	r3,184(r2)
   21ad0:	e0bff817 	ldw	r2,-32(fp)
   21ad4:	1885c83a 	sub	r2,r3,r2
   21ad8:	e0bff915 	stw	r2,-28(fp)
   21adc:	e03ff615 	stw	zero,-40(fp)
   21ae0:	00001206 	br	21b2c <alt_flash_program_block+0xb8>
   21ae4:	e0bffc17 	ldw	r2,-16(fp)
   21ae8:	10c00a17 	ldw	r3,40(r2)
   21aec:	e13ffd17 	ldw	r4,-12(fp)
   21af0:	e0bff817 	ldw	r2,-32(fp)
   21af4:	2089c83a 	sub	r4,r4,r2
   21af8:	e0bff617 	ldw	r2,-40(fp)
   21afc:	2085883a 	add	r2,r4,r2
   21b00:	1885883a 	add	r2,r3,r2
   21b04:	10800023 	ldbuio	r2,0(r2)
   21b08:	10803fcc 	andi	r2,r2,255
   21b0c:	1007883a 	mov	r3,r2
   21b10:	e13ffb04 	addi	r4,fp,-20
   21b14:	e0bff617 	ldw	r2,-40(fp)
   21b18:	2085883a 	add	r2,r4,r2
   21b1c:	10c00005 	stb	r3,0(r2)
   21b20:	e0bff617 	ldw	r2,-40(fp)
   21b24:	10800044 	addi	r2,r2,1
   21b28:	e0bff615 	stw	r2,-40(fp)
   21b2c:	e0fff617 	ldw	r3,-40(fp)
   21b30:	e0bff817 	ldw	r2,-32(fp)
   21b34:	18bfeb16 	blt	r3,r2,21ae4 <alt_flash_program_block+0x70>
   21b38:	e03ff615 	stw	zero,-40(fp)
   21b3c:	00000d06 	br	21b74 <alt_flash_program_block+0x100>
   21b40:	e0fff817 	ldw	r3,-32(fp)
   21b44:	e0bff617 	ldw	r2,-40(fp)
   21b48:	1885883a 	add	r2,r3,r2
   21b4c:	e0fff617 	ldw	r3,-40(fp)
   21b50:	e13ffe17 	ldw	r4,-8(fp)
   21b54:	20c7883a 	add	r3,r4,r3
   21b58:	18c00003 	ldbu	r3,0(r3)
   21b5c:	e13ffb04 	addi	r4,fp,-20
   21b60:	2085883a 	add	r2,r4,r2
   21b64:	10c00005 	stb	r3,0(r2)
   21b68:	e0bff617 	ldw	r2,-40(fp)
   21b6c:	10800044 	addi	r2,r2,1
   21b70:	e0bff615 	stw	r2,-40(fp)
   21b74:	e0fff617 	ldw	r3,-40(fp)
   21b78:	e0bff917 	ldw	r2,-28(fp)
   21b7c:	18bff016 	blt	r3,r2,21b40 <alt_flash_program_block+0xcc>
   21b80:	e0fffd17 	ldw	r3,-12(fp)
   21b84:	e0bff817 	ldw	r2,-32(fp)
   21b88:	1887c83a 	sub	r3,r3,r2
   21b8c:	e0bffb04 	addi	r2,fp,-20
   21b90:	e1c00217 	ldw	r7,8(fp)
   21b94:	e13ffc17 	ldw	r4,-16(fp)
   21b98:	180b883a 	mov	r5,r3
   21b9c:	100d883a 	mov	r6,r2
   21ba0:	383ee83a 	callr	r7
   21ba4:	e0bff515 	stw	r2,-44(fp)
   21ba8:	e0bff917 	ldw	r2,-28(fp)
   21bac:	e0bff615 	stw	r2,-40(fp)
   21bb0:	00000106 	br	21bb8 <alt_flash_program_block+0x144>
   21bb4:	e03ff615 	stw	zero,-40(fp)
   21bb8:	e0fffd17 	ldw	r3,-12(fp)
   21bbc:	e0bfff17 	ldw	r2,-4(fp)
   21bc0:	1885883a 	add	r2,r3,r2
   21bc4:	e0fffc17 	ldw	r3,-16(fp)
   21bc8:	18c02e17 	ldw	r3,184(r3)
   21bcc:	10c9283a 	div	r4,r2,r3
   21bd0:	20c7383a 	mul	r3,r4,r3
   21bd4:	10c5c83a 	sub	r2,r2,r3
   21bd8:	e0bffa15 	stw	r2,-24(fp)
   21bdc:	00001106 	br	21c24 <alt_flash_program_block+0x1b0>
   21be0:	e0fffd17 	ldw	r3,-12(fp)
   21be4:	e0bff617 	ldw	r2,-40(fp)
   21be8:	1887883a 	add	r3,r3,r2
   21bec:	e0bff617 	ldw	r2,-40(fp)
   21bf0:	e13ffe17 	ldw	r4,-8(fp)
   21bf4:	2085883a 	add	r2,r4,r2
   21bf8:	e1c00217 	ldw	r7,8(fp)
   21bfc:	e13ffc17 	ldw	r4,-16(fp)
   21c00:	180b883a 	mov	r5,r3
   21c04:	100d883a 	mov	r6,r2
   21c08:	383ee83a 	callr	r7
   21c0c:	e0bff515 	stw	r2,-44(fp)
   21c10:	e0bffc17 	ldw	r2,-16(fp)
   21c14:	10802e17 	ldw	r2,184(r2)
   21c18:	e0fff617 	ldw	r3,-40(fp)
   21c1c:	1885883a 	add	r2,r3,r2
   21c20:	e0bff615 	stw	r2,-40(fp)
   21c24:	e0bff517 	ldw	r2,-44(fp)
   21c28:	1000051e 	bne	r2,zero,21c40 <alt_flash_program_block+0x1cc>
   21c2c:	e0ffff17 	ldw	r3,-4(fp)
   21c30:	e0bffa17 	ldw	r2,-24(fp)
   21c34:	1885c83a 	sub	r2,r3,r2
   21c38:	e0fff617 	ldw	r3,-40(fp)
   21c3c:	18bfe816 	blt	r3,r2,21be0 <alt_flash_program_block+0x16c>
   21c40:	e0bffa17 	ldw	r2,-24(fp)
   21c44:	10003b26 	beq	r2,zero,21d34 <alt_flash_program_block+0x2c0>
   21c48:	e0bff517 	ldw	r2,-44(fp)
   21c4c:	1000391e 	bne	r2,zero,21d34 <alt_flash_program_block+0x2c0>
   21c50:	e0bffc17 	ldw	r2,-16(fp)
   21c54:	10c02e17 	ldw	r3,184(r2)
   21c58:	e0bffa17 	ldw	r2,-24(fp)
   21c5c:	1885c83a 	sub	r2,r3,r2
   21c60:	e0bff815 	stw	r2,-32(fp)
   21c64:	e03ff715 	stw	zero,-36(fp)
   21c68:	00000d06 	br	21ca0 <alt_flash_program_block+0x22c>
   21c6c:	e0fff617 	ldw	r3,-40(fp)
   21c70:	e0bff717 	ldw	r2,-36(fp)
   21c74:	1885883a 	add	r2,r3,r2
   21c78:	e0fffe17 	ldw	r3,-8(fp)
   21c7c:	1885883a 	add	r2,r3,r2
   21c80:	10c00003 	ldbu	r3,0(r2)
   21c84:	e13ffb04 	addi	r4,fp,-20
   21c88:	e0bff717 	ldw	r2,-36(fp)
   21c8c:	2085883a 	add	r2,r4,r2
   21c90:	10c00005 	stb	r3,0(r2)
   21c94:	e0bff717 	ldw	r2,-36(fp)
   21c98:	10800044 	addi	r2,r2,1
   21c9c:	e0bff715 	stw	r2,-36(fp)
   21ca0:	e0fff717 	ldw	r3,-36(fp)
   21ca4:	e0bffa17 	ldw	r2,-24(fp)
   21ca8:	18bff016 	blt	r3,r2,21c6c <alt_flash_program_block+0x1f8>
   21cac:	e03ff715 	stw	zero,-36(fp)
   21cb0:	00001306 	br	21d00 <alt_flash_program_block+0x28c>
   21cb4:	e0fffa17 	ldw	r3,-24(fp)
   21cb8:	e0bff717 	ldw	r2,-36(fp)
   21cbc:	1885883a 	add	r2,r3,r2
   21cc0:	e0fffc17 	ldw	r3,-16(fp)
   21cc4:	19000a17 	ldw	r4,40(r3)
   21cc8:	e17ffd17 	ldw	r5,-12(fp)
   21ccc:	e0ffff17 	ldw	r3,-4(fp)
   21cd0:	28cb883a 	add	r5,r5,r3
   21cd4:	e0fff717 	ldw	r3,-36(fp)
   21cd8:	28c7883a 	add	r3,r5,r3
   21cdc:	20c7883a 	add	r3,r4,r3
   21ce0:	18c00023 	ldbuio	r3,0(r3)
   21ce4:	18c03fcc 	andi	r3,r3,255
   21ce8:	e13ffb04 	addi	r4,fp,-20
   21cec:	2085883a 	add	r2,r4,r2
   21cf0:	10c00005 	stb	r3,0(r2)
   21cf4:	e0bff717 	ldw	r2,-36(fp)
   21cf8:	10800044 	addi	r2,r2,1
   21cfc:	e0bff715 	stw	r2,-36(fp)
   21d00:	e0fff717 	ldw	r3,-36(fp)
   21d04:	e0bff817 	ldw	r2,-32(fp)
   21d08:	18bfea16 	blt	r3,r2,21cb4 <alt_flash_program_block+0x240>
   21d0c:	e0fffd17 	ldw	r3,-12(fp)
   21d10:	e0bff617 	ldw	r2,-40(fp)
   21d14:	1887883a 	add	r3,r3,r2
   21d18:	e0bffb04 	addi	r2,fp,-20
   21d1c:	e1c00217 	ldw	r7,8(fp)
   21d20:	e13ffc17 	ldw	r4,-16(fp)
   21d24:	180b883a 	mov	r5,r3
   21d28:	100d883a 	mov	r6,r2
   21d2c:	383ee83a 	callr	r7
   21d30:	e0bff515 	stw	r2,-44(fp)
   21d34:	e0bff517 	ldw	r2,-44(fp)
   21d38:	e037883a 	mov	sp,fp
   21d3c:	dfc00117 	ldw	ra,4(sp)
   21d40:	df000017 	ldw	fp,0(sp)
   21d44:	dec00204 	addi	sp,sp,8
   21d48:	f800283a 	ret

00021d4c <alt_read_query_entry_8bit>:
   21d4c:	defffd04 	addi	sp,sp,-12
   21d50:	df000215 	stw	fp,8(sp)
   21d54:	df000204 	addi	fp,sp,8
   21d58:	e13ffe15 	stw	r4,-8(fp)
   21d5c:	e17fff15 	stw	r5,-4(fp)
   21d60:	e0bffe17 	ldw	r2,-8(fp)
   21d64:	10c00a17 	ldw	r3,40(r2)
   21d68:	e0bfff17 	ldw	r2,-4(fp)
   21d6c:	1885883a 	add	r2,r3,r2
   21d70:	10800023 	ldbuio	r2,0(r2)
   21d74:	10803fcc 	andi	r2,r2,255
   21d78:	e037883a 	mov	sp,fp
   21d7c:	df000017 	ldw	fp,0(sp)
   21d80:	dec00104 	addi	sp,sp,4
   21d84:	f800283a 	ret

00021d88 <alt_read_query_entry_16bit>:
   21d88:	defffd04 	addi	sp,sp,-12
   21d8c:	df000215 	stw	fp,8(sp)
   21d90:	df000204 	addi	fp,sp,8
   21d94:	e13ffe15 	stw	r4,-8(fp)
   21d98:	e17fff15 	stw	r5,-4(fp)
   21d9c:	e0bffe17 	ldw	r2,-8(fp)
   21da0:	10c00a17 	ldw	r3,40(r2)
   21da4:	e0bfff17 	ldw	r2,-4(fp)
   21da8:	1085883a 	add	r2,r2,r2
   21dac:	1885883a 	add	r2,r3,r2
   21db0:	1080002b 	ldhuio	r2,0(r2)
   21db4:	10bfffcc 	andi	r2,r2,65535
   21db8:	e037883a 	mov	sp,fp
   21dbc:	df000017 	ldw	fp,0(sp)
   21dc0:	dec00104 	addi	sp,sp,4
   21dc4:	f800283a 	ret

00021dc8 <alt_read_query_entry_32bit>:
   21dc8:	defffd04 	addi	sp,sp,-12
   21dcc:	df000215 	stw	fp,8(sp)
   21dd0:	df000204 	addi	fp,sp,8
   21dd4:	e13ffe15 	stw	r4,-8(fp)
   21dd8:	e17fff15 	stw	r5,-4(fp)
   21ddc:	e0bffe17 	ldw	r2,-8(fp)
   21de0:	10c00a17 	ldw	r3,40(r2)
   21de4:	e0bfff17 	ldw	r2,-4(fp)
   21de8:	1085883a 	add	r2,r2,r2
   21dec:	1085883a 	add	r2,r2,r2
   21df0:	1885883a 	add	r2,r3,r2
   21df4:	10800037 	ldwio	r2,0(r2)
   21df8:	e037883a 	mov	sp,fp
   21dfc:	df000017 	ldw	fp,0(sp)
   21e00:	dec00104 	addi	sp,sp,4
   21e04:	f800283a 	ret

00021e08 <alt_write_flash_command_8bit_device_8bit_mode>:
   21e08:	defffc04 	addi	sp,sp,-16
   21e0c:	df000315 	stw	fp,12(sp)
   21e10:	df000304 	addi	fp,sp,12
   21e14:	e13ffd15 	stw	r4,-12(fp)
   21e18:	e17ffe15 	stw	r5,-8(fp)
   21e1c:	3005883a 	mov	r2,r6
   21e20:	e0bfff05 	stb	r2,-4(fp)
   21e24:	e0bffe17 	ldw	r2,-8(fp)
   21e28:	e0fffd17 	ldw	r3,-12(fp)
   21e2c:	1885883a 	add	r2,r3,r2
   21e30:	e0ffff03 	ldbu	r3,-4(fp)
   21e34:	10c00025 	stbio	r3,0(r2)
   21e38:	0001883a 	nop
   21e3c:	e037883a 	mov	sp,fp
   21e40:	df000017 	ldw	fp,0(sp)
   21e44:	dec00104 	addi	sp,sp,4
   21e48:	f800283a 	ret

00021e4c <alt_write_flash_command_16bit_device_8bit_mode>:
   21e4c:	defffc04 	addi	sp,sp,-16
   21e50:	df000315 	stw	fp,12(sp)
   21e54:	df000304 	addi	fp,sp,12
   21e58:	e13ffd15 	stw	r4,-12(fp)
   21e5c:	e17ffe15 	stw	r5,-8(fp)
   21e60:	3005883a 	mov	r2,r6
   21e64:	e0bfff05 	stb	r2,-4(fp)
   21e68:	e0bffe17 	ldw	r2,-8(fp)
   21e6c:	1080004c 	andi	r2,r2,1
   21e70:	10000726 	beq	r2,zero,21e90 <alt_write_flash_command_16bit_device_8bit_mode+0x44>
   21e74:	e0bffe17 	ldw	r2,-8(fp)
   21e78:	1085883a 	add	r2,r2,r2
   21e7c:	e0fffd17 	ldw	r3,-12(fp)
   21e80:	1885883a 	add	r2,r3,r2
   21e84:	e0ffff03 	ldbu	r3,-4(fp)
   21e88:	10c00025 	stbio	r3,0(r2)
   21e8c:	00000706 	br	21eac <alt_write_flash_command_16bit_device_8bit_mode+0x60>
   21e90:	e0bffe17 	ldw	r2,-8(fp)
   21e94:	1085883a 	add	r2,r2,r2
   21e98:	10800044 	addi	r2,r2,1
   21e9c:	e0fffd17 	ldw	r3,-12(fp)
   21ea0:	1885883a 	add	r2,r3,r2
   21ea4:	e0ffff03 	ldbu	r3,-4(fp)
   21ea8:	10c00025 	stbio	r3,0(r2)
   21eac:	0001883a 	nop
   21eb0:	e037883a 	mov	sp,fp
   21eb4:	df000017 	ldw	fp,0(sp)
   21eb8:	dec00104 	addi	sp,sp,4
   21ebc:	f800283a 	ret

00021ec0 <alt_write_flash_command_32bit_device_8bit_mode>:
   21ec0:	defffc04 	addi	sp,sp,-16
   21ec4:	df000315 	stw	fp,12(sp)
   21ec8:	df000304 	addi	fp,sp,12
   21ecc:	e13ffd15 	stw	r4,-12(fp)
   21ed0:	e17ffe15 	stw	r5,-8(fp)
   21ed4:	3005883a 	mov	r2,r6
   21ed8:	e0bfff05 	stb	r2,-4(fp)
   21edc:	e0bffe17 	ldw	r2,-8(fp)
   21ee0:	1085883a 	add	r2,r2,r2
   21ee4:	1085883a 	add	r2,r2,r2
   21ee8:	e0fffd17 	ldw	r3,-12(fp)
   21eec:	1885883a 	add	r2,r3,r2
   21ef0:	e0ffff03 	ldbu	r3,-4(fp)
   21ef4:	10c00025 	stbio	r3,0(r2)
   21ef8:	0001883a 	nop
   21efc:	e037883a 	mov	sp,fp
   21f00:	df000017 	ldw	fp,0(sp)
   21f04:	dec00104 	addi	sp,sp,4
   21f08:	f800283a 	ret

00021f0c <alt_write_flash_command_16bit_device_16bit_mode>:
   21f0c:	defffc04 	addi	sp,sp,-16
   21f10:	df000315 	stw	fp,12(sp)
   21f14:	df000304 	addi	fp,sp,12
   21f18:	e13ffd15 	stw	r4,-12(fp)
   21f1c:	e17ffe15 	stw	r5,-8(fp)
   21f20:	3005883a 	mov	r2,r6
   21f24:	e0bfff05 	stb	r2,-4(fp)
   21f28:	e0bffe17 	ldw	r2,-8(fp)
   21f2c:	1085883a 	add	r2,r2,r2
   21f30:	e0fffd17 	ldw	r3,-12(fp)
   21f34:	1885883a 	add	r2,r3,r2
   21f38:	e0ffff03 	ldbu	r3,-4(fp)
   21f3c:	10c0002d 	sthio	r3,0(r2)
   21f40:	0001883a 	nop
   21f44:	e037883a 	mov	sp,fp
   21f48:	df000017 	ldw	fp,0(sp)
   21f4c:	dec00104 	addi	sp,sp,4
   21f50:	f800283a 	ret

00021f54 <alt_write_flash_command_32bit_device_16bit_mode>:
   21f54:	defffc04 	addi	sp,sp,-16
   21f58:	df000315 	stw	fp,12(sp)
   21f5c:	df000304 	addi	fp,sp,12
   21f60:	e13ffd15 	stw	r4,-12(fp)
   21f64:	e17ffe15 	stw	r5,-8(fp)
   21f68:	3005883a 	mov	r2,r6
   21f6c:	e0bfff05 	stb	r2,-4(fp)
   21f70:	e0bffe17 	ldw	r2,-8(fp)
   21f74:	1085883a 	add	r2,r2,r2
   21f78:	1085883a 	add	r2,r2,r2
   21f7c:	e0fffd17 	ldw	r3,-12(fp)
   21f80:	1885883a 	add	r2,r3,r2
   21f84:	e0ffff03 	ldbu	r3,-4(fp)
   21f88:	10c0002d 	sthio	r3,0(r2)
   21f8c:	0001883a 	nop
   21f90:	e037883a 	mov	sp,fp
   21f94:	df000017 	ldw	fp,0(sp)
   21f98:	dec00104 	addi	sp,sp,4
   21f9c:	f800283a 	ret

00021fa0 <alt_write_flash_command_32bit_device_32bit_mode>:
   21fa0:	defffc04 	addi	sp,sp,-16
   21fa4:	df000315 	stw	fp,12(sp)
   21fa8:	df000304 	addi	fp,sp,12
   21fac:	e13ffd15 	stw	r4,-12(fp)
   21fb0:	e17ffe15 	stw	r5,-8(fp)
   21fb4:	3005883a 	mov	r2,r6
   21fb8:	e0bfff05 	stb	r2,-4(fp)
   21fbc:	e0bffe17 	ldw	r2,-8(fp)
   21fc0:	1085883a 	add	r2,r2,r2
   21fc4:	1085883a 	add	r2,r2,r2
   21fc8:	e0fffd17 	ldw	r3,-12(fp)
   21fcc:	1885883a 	add	r2,r3,r2
   21fd0:	e0ffff03 	ldbu	r3,-4(fp)
   21fd4:	10c00035 	stwio	r3,0(r2)
   21fd8:	0001883a 	nop
   21fdc:	e037883a 	mov	sp,fp
   21fe0:	df000017 	ldw	fp,0(sp)
   21fe4:	dec00104 	addi	sp,sp,4
   21fe8:	f800283a 	ret

00021fec <alt_write_native_8bit>:
   21fec:	defffd04 	addi	sp,sp,-12
   21ff0:	df000215 	stw	fp,8(sp)
   21ff4:	df000204 	addi	fp,sp,8
   21ff8:	e13ffe15 	stw	r4,-8(fp)
   21ffc:	e17fff15 	stw	r5,-4(fp)
   22000:	e0bfff17 	ldw	r2,-4(fp)
   22004:	10c03fcc 	andi	r3,r2,255
   22008:	e0bffe17 	ldw	r2,-8(fp)
   2200c:	10c00025 	stbio	r3,0(r2)
   22010:	0001883a 	nop
   22014:	e037883a 	mov	sp,fp
   22018:	df000017 	ldw	fp,0(sp)
   2201c:	dec00104 	addi	sp,sp,4
   22020:	f800283a 	ret

00022024 <alt_write_native_16bit>:
   22024:	defffd04 	addi	sp,sp,-12
   22028:	df000215 	stw	fp,8(sp)
   2202c:	df000204 	addi	fp,sp,8
   22030:	e13ffe15 	stw	r4,-8(fp)
   22034:	e17fff15 	stw	r5,-4(fp)
   22038:	e0bfff17 	ldw	r2,-4(fp)
   2203c:	10ffffcc 	andi	r3,r2,65535
   22040:	e0bffe17 	ldw	r2,-8(fp)
   22044:	10c0002d 	sthio	r3,0(r2)
   22048:	0001883a 	nop
   2204c:	e037883a 	mov	sp,fp
   22050:	df000017 	ldw	fp,0(sp)
   22054:	dec00104 	addi	sp,sp,4
   22058:	f800283a 	ret

0002205c <alt_write_native_32bit>:
   2205c:	defffd04 	addi	sp,sp,-12
   22060:	df000215 	stw	fp,8(sp)
   22064:	df000204 	addi	fp,sp,8
   22068:	e13ffe15 	stw	r4,-8(fp)
   2206c:	e17fff15 	stw	r5,-4(fp)
   22070:	e0ffff17 	ldw	r3,-4(fp)
   22074:	e0bffe17 	ldw	r2,-8(fp)
   22078:	10c00035 	stwio	r3,0(r2)
   2207c:	0001883a 	nop
   22080:	e037883a 	mov	sp,fp
   22084:	df000017 	ldw	fp,0(sp)
   22088:	dec00104 	addi	sp,sp,4
   2208c:	f800283a 	ret

00022090 <alt_set_flash_width_func>:
   22090:	defffd04 	addi	sp,sp,-12
   22094:	df000215 	stw	fp,8(sp)
   22098:	df000204 	addi	fp,sp,8
   2209c:	e13fff15 	stw	r4,-4(fp)
   220a0:	e03ffe15 	stw	zero,-8(fp)
   220a4:	e0bfff17 	ldw	r2,-4(fp)
   220a8:	10802e17 	ldw	r2,184(r2)
   220ac:	10c000a0 	cmpeqi	r3,r2,2
   220b0:	1800231e 	bne	r3,zero,22140 <alt_set_flash_width_func+0xb0>
   220b4:	10c00120 	cmpeqi	r3,r2,4
   220b8:	1800371e 	bne	r3,zero,22198 <alt_set_flash_width_func+0x108>
   220bc:	10800060 	cmpeqi	r2,r2,1
   220c0:	10003e26 	beq	r2,zero,221bc <alt_set_flash_width_func+0x12c>
   220c4:	e0bfff17 	ldw	r2,-4(fp)
   220c8:	00c000b4 	movhi	r3,2
   220cc:	18c7fb04 	addi	r3,r3,8172
   220d0:	10c03515 	stw	r3,212(r2)
   220d4:	e0bfff17 	ldw	r2,-4(fp)
   220d8:	10802f17 	ldw	r2,188(r2)
   220dc:	10800058 	cmpnei	r2,r2,1
   220e0:	1000051e 	bne	r2,zero,220f8 <alt_set_flash_width_func+0x68>
   220e4:	e0bfff17 	ldw	r2,-4(fp)
   220e8:	00c000b4 	movhi	r3,2
   220ec:	18c78204 	addi	r3,r3,7688
   220f0:	10c03315 	stw	r3,204(r2)
   220f4:	00003406 	br	221c8 <alt_set_flash_width_func+0x138>
   220f8:	e0bfff17 	ldw	r2,-4(fp)
   220fc:	10802f17 	ldw	r2,188(r2)
   22100:	10800098 	cmpnei	r2,r2,2
   22104:	1000051e 	bne	r2,zero,2211c <alt_set_flash_width_func+0x8c>
   22108:	e0bfff17 	ldw	r2,-4(fp)
   2210c:	00c000b4 	movhi	r3,2
   22110:	18c79304 	addi	r3,r3,7756
   22114:	10c03315 	stw	r3,204(r2)
   22118:	00002b06 	br	221c8 <alt_set_flash_width_func+0x138>
   2211c:	e0bfff17 	ldw	r2,-4(fp)
   22120:	10802f17 	ldw	r2,188(r2)
   22124:	10800118 	cmpnei	r2,r2,4
   22128:	1000271e 	bne	r2,zero,221c8 <alt_set_flash_width_func+0x138>
   2212c:	e0bfff17 	ldw	r2,-4(fp)
   22130:	00c000b4 	movhi	r3,2
   22134:	18c7b004 	addi	r3,r3,7872
   22138:	10c03315 	stw	r3,204(r2)
   2213c:	00002206 	br	221c8 <alt_set_flash_width_func+0x138>
   22140:	e0bfff17 	ldw	r2,-4(fp)
   22144:	00c000b4 	movhi	r3,2
   22148:	18c80904 	addi	r3,r3,8228
   2214c:	10c03515 	stw	r3,212(r2)
   22150:	e0bfff17 	ldw	r2,-4(fp)
   22154:	10802f17 	ldw	r2,188(r2)
   22158:	10800098 	cmpnei	r2,r2,2
   2215c:	1000051e 	bne	r2,zero,22174 <alt_set_flash_width_func+0xe4>
   22160:	e0bfff17 	ldw	r2,-4(fp)
   22164:	00c000b4 	movhi	r3,2
   22168:	18c7c304 	addi	r3,r3,7948
   2216c:	10c03315 	stw	r3,204(r2)
   22170:	00001706 	br	221d0 <alt_set_flash_width_func+0x140>
   22174:	e0bfff17 	ldw	r2,-4(fp)
   22178:	10802f17 	ldw	r2,188(r2)
   2217c:	10800118 	cmpnei	r2,r2,4
   22180:	1000131e 	bne	r2,zero,221d0 <alt_set_flash_width_func+0x140>
   22184:	e0bfff17 	ldw	r2,-4(fp)
   22188:	00c000b4 	movhi	r3,2
   2218c:	18c7d504 	addi	r3,r3,8020
   22190:	10c03315 	stw	r3,204(r2)
   22194:	00000e06 	br	221d0 <alt_set_flash_width_func+0x140>
   22198:	e0bfff17 	ldw	r2,-4(fp)
   2219c:	00c000b4 	movhi	r3,2
   221a0:	18c81704 	addi	r3,r3,8284
   221a4:	10c03515 	stw	r3,212(r2)
   221a8:	e0bfff17 	ldw	r2,-4(fp)
   221ac:	00c000b4 	movhi	r3,2
   221b0:	18c7e804 	addi	r3,r3,8096
   221b4:	10c03315 	stw	r3,204(r2)
   221b8:	00000606 	br	221d4 <alt_set_flash_width_func+0x144>
   221bc:	00bffcc4 	movi	r2,-13
   221c0:	e0bffe15 	stw	r2,-8(fp)
   221c4:	00000306 	br	221d4 <alt_set_flash_width_func+0x144>
   221c8:	0001883a 	nop
   221cc:	00000106 	br	221d4 <alt_set_flash_width_func+0x144>
   221d0:	0001883a 	nop
   221d4:	e0bffe17 	ldw	r2,-8(fp)
   221d8:	1000191e 	bne	r2,zero,22240 <alt_set_flash_width_func+0x1b0>
   221dc:	e0bfff17 	ldw	r2,-4(fp)
   221e0:	10802f17 	ldw	r2,188(r2)
   221e4:	10c000a0 	cmpeqi	r3,r2,2
   221e8:	1800091e 	bne	r3,zero,22210 <alt_set_flash_width_func+0x180>
   221ec:	10c00120 	cmpeqi	r3,r2,4
   221f0:	18000c1e 	bne	r3,zero,22224 <alt_set_flash_width_func+0x194>
   221f4:	10800060 	cmpeqi	r2,r2,1
   221f8:	10000f26 	beq	r2,zero,22238 <alt_set_flash_width_func+0x1a8>
   221fc:	e0bfff17 	ldw	r2,-4(fp)
   22200:	00c000b4 	movhi	r3,2
   22204:	18c75304 	addi	r3,r3,7500
   22208:	10c03415 	stw	r3,208(r2)
   2220c:	00000c06 	br	22240 <alt_set_flash_width_func+0x1b0>
   22210:	e0bfff17 	ldw	r2,-4(fp)
   22214:	00c000b4 	movhi	r3,2
   22218:	18c76204 	addi	r3,r3,7560
   2221c:	10c03415 	stw	r3,208(r2)
   22220:	00000706 	br	22240 <alt_set_flash_width_func+0x1b0>
   22224:	e0bfff17 	ldw	r2,-4(fp)
   22228:	00c000b4 	movhi	r3,2
   2222c:	18c77204 	addi	r3,r3,7624
   22230:	10c03415 	stw	r3,208(r2)
   22234:	00000206 	br	22240 <alt_set_flash_width_func+0x1b0>
   22238:	00bffcc4 	movi	r2,-13
   2223c:	e0bffe15 	stw	r2,-8(fp)
   22240:	e0bffe17 	ldw	r2,-8(fp)
   22244:	e037883a 	mov	sp,fp
   22248:	df000017 	ldw	fp,0(sp)
   2224c:	dec00104 	addi	sp,sp,4
   22250:	f800283a 	ret

00022254 <alt_set_flash_algorithm_func>:
   22254:	defffd04 	addi	sp,sp,-12
   22258:	df000215 	stw	fp,8(sp)
   2225c:	df000204 	addi	fp,sp,8
   22260:	e13fff15 	stw	r4,-4(fp)
   22264:	e03ffe15 	stw	zero,-8(fp)
   22268:	e0bfff17 	ldw	r2,-4(fp)
   2226c:	10802d17 	ldw	r2,180(r2)
   22270:	10c000a0 	cmpeqi	r3,r2,2
   22274:	1800051e 	bne	r3,zero,2228c <alt_set_flash_algorithm_func+0x38>
   22278:	10c000e0 	cmpeqi	r3,r2,3
   2227c:	18000c1e 	bne	r3,zero,222b0 <alt_set_flash_algorithm_func+0x5c>
   22280:	10800060 	cmpeqi	r2,r2,1
   22284:	10000a1e 	bne	r2,zero,222b0 <alt_set_flash_algorithm_func+0x5c>
   22288:	00001206 	br	222d4 <alt_set_flash_algorithm_func+0x80>
   2228c:	e0bfff17 	ldw	r2,-4(fp)
   22290:	00c000f4 	movhi	r3,3
   22294:	18f00604 	addi	r3,r3,-16360
   22298:	10c00815 	stw	r3,32(r2)
   2229c:	e0bfff17 	ldw	r2,-4(fp)
   222a0:	00c000f4 	movhi	r3,3
   222a4:	18efec04 	addi	r3,r3,-16464
   222a8:	10c00915 	stw	r3,36(r2)
   222ac:	00000b06 	br	222dc <alt_set_flash_algorithm_func+0x88>
   222b0:	e0bfff17 	ldw	r2,-4(fp)
   222b4:	00c000f4 	movhi	r3,3
   222b8:	18f12404 	addi	r3,r3,-15216
   222bc:	10c00815 	stw	r3,32(r2)
   222c0:	e0bfff17 	ldw	r2,-4(fp)
   222c4:	00c000f4 	movhi	r3,3
   222c8:	18f10404 	addi	r3,r3,-15344
   222cc:	10c00915 	stw	r3,36(r2)
   222d0:	00000206 	br	222dc <alt_set_flash_algorithm_func+0x88>
   222d4:	00bffec4 	movi	r2,-5
   222d8:	e0bffe15 	stw	r2,-8(fp)
   222dc:	e0bffe17 	ldw	r2,-8(fp)
   222e0:	e037883a 	mov	sp,fp
   222e4:	df000017 	ldw	fp,0(sp)
   222e8:	dec00104 	addi	sp,sp,4
   222ec:	f800283a 	ret

000222f0 <alt_read_16bit_query_entry>:
   222f0:	defffb04 	addi	sp,sp,-20
   222f4:	dfc00415 	stw	ra,16(sp)
   222f8:	df000315 	stw	fp,12(sp)
   222fc:	df000304 	addi	fp,sp,12
   22300:	e13ffe15 	stw	r4,-8(fp)
   22304:	e17fff15 	stw	r5,-4(fp)
   22308:	e0bffe17 	ldw	r2,-8(fp)
   2230c:	10803417 	ldw	r2,208(r2)
   22310:	e13ffe17 	ldw	r4,-8(fp)
   22314:	e17fff17 	ldw	r5,-4(fp)
   22318:	103ee83a 	callr	r2
   2231c:	10803fcc 	andi	r2,r2,255
   22320:	e0bffd0d 	sth	r2,-12(fp)
   22324:	e0bffe17 	ldw	r2,-8(fp)
   22328:	10c03417 	ldw	r3,208(r2)
   2232c:	e0bfff17 	ldw	r2,-4(fp)
   22330:	10800044 	addi	r2,r2,1
   22334:	e13ffe17 	ldw	r4,-8(fp)
   22338:	100b883a 	mov	r5,r2
   2233c:	183ee83a 	callr	r3
   22340:	10803fcc 	andi	r2,r2,255
   22344:	1004923a 	slli	r2,r2,8
   22348:	1007883a 	mov	r3,r2
   2234c:	e0bffd0b 	ldhu	r2,-12(fp)
   22350:	1884b03a 	or	r2,r3,r2
   22354:	e0bffd0d 	sth	r2,-12(fp)
   22358:	e0bffd0b 	ldhu	r2,-12(fp)
   2235c:	e037883a 	mov	sp,fp
   22360:	dfc00117 	ldw	ra,4(sp)
   22364:	df000017 	ldw	fp,0(sp)
   22368:	dec00204 	addi	sp,sp,8
   2236c:	f800283a 	ret

00022370 <alt_read_cfi_table>:
   22370:	defff304 	addi	sp,sp,-52
   22374:	dfc00c15 	stw	ra,48(sp)
   22378:	df000b15 	stw	fp,44(sp)
   2237c:	df000b04 	addi	fp,sp,44
   22380:	e13fff15 	stw	r4,-4(fp)
   22384:	e03ff715 	stw	zero,-36(fp)
   22388:	e03ff815 	stw	zero,-32(fp)
   2238c:	e03ff915 	stw	zero,-28(fp)
   22390:	e13fff17 	ldw	r4,-4(fp)
   22394:	00230a80 	call	230a8 <alt_check_primary_table>
   22398:	e0bff715 	stw	r2,-36(fp)
   2239c:	e0bff717 	ldw	r2,-36(fp)
   223a0:	10015f1e 	bne	r2,zero,22920 <alt_read_cfi_table+0x5b0>
   223a4:	e0bfff17 	ldw	r2,-4(fp)
   223a8:	10803417 	ldw	r2,208(r2)
   223ac:	e13fff17 	ldw	r4,-4(fp)
   223b0:	014004c4 	movi	r5,19
   223b4:	103ee83a 	callr	r2
   223b8:	10c03fcc 	andi	r3,r2,255
   223bc:	e0bfff17 	ldw	r2,-4(fp)
   223c0:	10c02d15 	stw	r3,180(r2)
   223c4:	e0bfff17 	ldw	r2,-4(fp)
   223c8:	10803417 	ldw	r2,208(r2)
   223cc:	e13fff17 	ldw	r4,-4(fp)
   223d0:	014007c4 	movi	r5,31
   223d4:	103ee83a 	callr	r2
   223d8:	10803fcc 	andi	r2,r2,255
   223dc:	e0bffa15 	stw	r2,-24(fp)
   223e0:	e0bfff17 	ldw	r2,-4(fp)
   223e4:	10803417 	ldw	r2,208(r2)
   223e8:	e13fff17 	ldw	r4,-4(fp)
   223ec:	014008c4 	movi	r5,35
   223f0:	103ee83a 	callr	r2
   223f4:	10803fcc 	andi	r2,r2,255
   223f8:	e0bffb15 	stw	r2,-20(fp)
   223fc:	e0bffa17 	ldw	r2,-24(fp)
   22400:	10000226 	beq	r2,zero,2240c <alt_read_cfi_table+0x9c>
   22404:	e0bffb17 	ldw	r2,-20(fp)
   22408:	1000041e 	bne	r2,zero,2241c <alt_read_cfi_table+0xac>
   2240c:	e0bfff17 	ldw	r2,-4(fp)
   22410:	00c0fa04 	movi	r3,1000
   22414:	10c03015 	stw	r3,192(r2)
   22418:	00000706 	br	22438 <alt_read_cfi_table+0xc8>
   2241c:	00c00044 	movi	r3,1
   22420:	e0bffa17 	ldw	r2,-24(fp)
   22424:	1886983a 	sll	r3,r3,r2
   22428:	e0bffb17 	ldw	r2,-20(fp)
   2242c:	1886983a 	sll	r3,r3,r2
   22430:	e0bfff17 	ldw	r2,-4(fp)
   22434:	10c03015 	stw	r3,192(r2)
   22438:	e0bfff17 	ldw	r2,-4(fp)
   2243c:	10803417 	ldw	r2,208(r2)
   22440:	e13fff17 	ldw	r4,-4(fp)
   22444:	01400844 	movi	r5,33
   22448:	103ee83a 	callr	r2
   2244c:	10803fcc 	andi	r2,r2,255
   22450:	e0bffa15 	stw	r2,-24(fp)
   22454:	e0bfff17 	ldw	r2,-4(fp)
   22458:	10803417 	ldw	r2,208(r2)
   2245c:	e13fff17 	ldw	r4,-4(fp)
   22460:	01400944 	movi	r5,37
   22464:	103ee83a 	callr	r2
   22468:	10803fcc 	andi	r2,r2,255
   2246c:	e0bffb15 	stw	r2,-20(fp)
   22470:	e0bffa17 	ldw	r2,-24(fp)
   22474:	10000226 	beq	r2,zero,22480 <alt_read_cfi_table+0x110>
   22478:	e0bffb17 	ldw	r2,-20(fp)
   2247c:	1000051e 	bne	r2,zero,22494 <alt_read_cfi_table+0x124>
   22480:	e0bfff17 	ldw	r2,-4(fp)
   22484:	00c04c74 	movhi	r3,305
   22488:	18cb4004 	addi	r3,r3,11520
   2248c:	10c03115 	stw	r3,196(r2)
   22490:	00000806 	br	224b4 <alt_read_cfi_table+0x144>
   22494:	00c00044 	movi	r3,1
   22498:	e0bffa17 	ldw	r2,-24(fp)
   2249c:	1886983a 	sll	r3,r3,r2
   224a0:	e0bffb17 	ldw	r2,-20(fp)
   224a4:	1884983a 	sll	r2,r3,r2
   224a8:	10c0fa24 	muli	r3,r2,1000
   224ac:	e0bfff17 	ldw	r2,-4(fp)
   224b0:	10c03115 	stw	r3,196(r2)
   224b4:	e0bfff17 	ldw	r2,-4(fp)
   224b8:	10803417 	ldw	r2,208(r2)
   224bc:	e13fff17 	ldw	r4,-4(fp)
   224c0:	014009c4 	movi	r5,39
   224c4:	103ee83a 	callr	r2
   224c8:	10803fcc 	andi	r2,r2,255
   224cc:	00c00044 	movi	r3,1
   224d0:	1884983a 	sll	r2,r3,r2
   224d4:	e0bffc15 	stw	r2,-16(fp)
   224d8:	e0bfff17 	ldw	r2,-4(fp)
   224dc:	10803417 	ldw	r2,208(r2)
   224e0:	e13fff17 	ldw	r4,-4(fp)
   224e4:	01400b04 	movi	r5,44
   224e8:	103ee83a 	callr	r2
   224ec:	10c03fcc 	andi	r3,r2,255
   224f0:	e0bfff17 	ldw	r2,-4(fp)
   224f4:	10c00c15 	stw	r3,48(r2)
   224f8:	e0bfff17 	ldw	r2,-4(fp)
   224fc:	10800c17 	ldw	r2,48(r2)
   22500:	10800250 	cmplti	r2,r2,9
   22504:	1000031e 	bne	r2,zero,22514 <alt_read_cfi_table+0x1a4>
   22508:	00bffd04 	movi	r2,-12
   2250c:	e0bff715 	stw	r2,-36(fp)
   22510:	00006006 	br	22694 <alt_read_cfi_table+0x324>
   22514:	e03ff515 	stw	zero,-44(fp)
   22518:	00005506 	br	22670 <alt_read_cfi_table+0x300>
   2251c:	e0bff517 	ldw	r2,-44(fp)
   22520:	1085883a 	add	r2,r2,r2
   22524:	1085883a 	add	r2,r2,r2
   22528:	10800b44 	addi	r2,r2,45
   2252c:	e13fff17 	ldw	r4,-4(fp)
   22530:	100b883a 	mov	r5,r2
   22534:	00222f00 	call	222f0 <alt_read_16bit_query_entry>
   22538:	10ffffcc 	andi	r3,r2,65535
   2253c:	e13fff17 	ldw	r4,-4(fp)
   22540:	e0bff517 	ldw	r2,-44(fp)
   22544:	1004913a 	slli	r2,r2,4
   22548:	2085883a 	add	r2,r4,r2
   2254c:	10800f04 	addi	r2,r2,60
   22550:	10c00015 	stw	r3,0(r2)
   22554:	e0ffff17 	ldw	r3,-4(fp)
   22558:	e0bff517 	ldw	r2,-44(fp)
   2255c:	1004913a 	slli	r2,r2,4
   22560:	1885883a 	add	r2,r3,r2
   22564:	10800f04 	addi	r2,r2,60
   22568:	10800017 	ldw	r2,0(r2)
   2256c:	10c00044 	addi	r3,r2,1
   22570:	e13fff17 	ldw	r4,-4(fp)
   22574:	e0bff517 	ldw	r2,-44(fp)
   22578:	1004913a 	slli	r2,r2,4
   2257c:	2085883a 	add	r2,r4,r2
   22580:	10800f04 	addi	r2,r2,60
   22584:	10c00015 	stw	r3,0(r2)
   22588:	e0bff517 	ldw	r2,-44(fp)
   2258c:	1085883a 	add	r2,r2,r2
   22590:	1085883a 	add	r2,r2,r2
   22594:	10800bc4 	addi	r2,r2,47
   22598:	e13fff17 	ldw	r4,-4(fp)
   2259c:	100b883a 	mov	r5,r2
   225a0:	00222f00 	call	222f0 <alt_read_16bit_query_entry>
   225a4:	10ffffcc 	andi	r3,r2,65535
   225a8:	e13fff17 	ldw	r4,-4(fp)
   225ac:	e0bff517 	ldw	r2,-44(fp)
   225b0:	10800104 	addi	r2,r2,4
   225b4:	1004913a 	slli	r2,r2,4
   225b8:	2085883a 	add	r2,r4,r2
   225bc:	10c00015 	stw	r3,0(r2)
   225c0:	e0ffff17 	ldw	r3,-4(fp)
   225c4:	e0bff517 	ldw	r2,-44(fp)
   225c8:	10800104 	addi	r2,r2,4
   225cc:	1004913a 	slli	r2,r2,4
   225d0:	1885883a 	add	r2,r3,r2
   225d4:	10800017 	ldw	r2,0(r2)
   225d8:	1006923a 	slli	r3,r2,8
   225dc:	e13fff17 	ldw	r4,-4(fp)
   225e0:	e0bff517 	ldw	r2,-44(fp)
   225e4:	10800104 	addi	r2,r2,4
   225e8:	1004913a 	slli	r2,r2,4
   225ec:	2085883a 	add	r2,r4,r2
   225f0:	10c00015 	stw	r3,0(r2)
   225f4:	e0ffff17 	ldw	r3,-4(fp)
   225f8:	e0bff517 	ldw	r2,-44(fp)
   225fc:	1004913a 	slli	r2,r2,4
   22600:	1885883a 	add	r2,r3,r2
   22604:	10800f04 	addi	r2,r2,60
   22608:	10c00017 	ldw	r3,0(r2)
   2260c:	e13fff17 	ldw	r4,-4(fp)
   22610:	e0bff517 	ldw	r2,-44(fp)
   22614:	10800104 	addi	r2,r2,4
   22618:	1004913a 	slli	r2,r2,4
   2261c:	2085883a 	add	r2,r4,r2
   22620:	10800017 	ldw	r2,0(r2)
   22624:	1887383a 	mul	r3,r3,r2
   22628:	e13fff17 	ldw	r4,-4(fp)
   2262c:	e0bff517 	ldw	r2,-44(fp)
   22630:	1004913a 	slli	r2,r2,4
   22634:	2085883a 	add	r2,r4,r2
   22638:	10800e04 	addi	r2,r2,56
   2263c:	10c00015 	stw	r3,0(r2)
   22640:	e0ffff17 	ldw	r3,-4(fp)
   22644:	e0bff517 	ldw	r2,-44(fp)
   22648:	1004913a 	slli	r2,r2,4
   2264c:	1885883a 	add	r2,r3,r2
   22650:	10800e04 	addi	r2,r2,56
   22654:	10800017 	ldw	r2,0(r2)
   22658:	e0fff817 	ldw	r3,-32(fp)
   2265c:	1885883a 	add	r2,r3,r2
   22660:	e0bff815 	stw	r2,-32(fp)
   22664:	e0bff517 	ldw	r2,-44(fp)
   22668:	10800044 	addi	r2,r2,1
   2266c:	e0bff515 	stw	r2,-44(fp)
   22670:	e0bfff17 	ldw	r2,-4(fp)
   22674:	10800c17 	ldw	r2,48(r2)
   22678:	e0fff517 	ldw	r3,-44(fp)
   2267c:	18bfa716 	blt	r3,r2,2251c <alt_read_cfi_table+0x1ac>
   22680:	e0fff817 	ldw	r3,-32(fp)
   22684:	e0bffc17 	ldw	r2,-16(fp)
   22688:	18800226 	beq	r3,r2,22694 <alt_read_cfi_table+0x324>
   2268c:	00bffb44 	movi	r2,-19
   22690:	e0bff715 	stw	r2,-36(fp)
   22694:	e0bfff17 	ldw	r2,-4(fp)
   22698:	10c03417 	ldw	r3,208(r2)
   2269c:	e0bfff17 	ldw	r2,-4(fp)
   226a0:	10803217 	ldw	r2,200(r2)
   226a4:	108003c4 	addi	r2,r2,15
   226a8:	e13fff17 	ldw	r4,-4(fp)
   226ac:	100b883a 	mov	r5,r2
   226b0:	183ee83a 	callr	r3
   226b4:	e0bffd05 	stb	r2,-12(fp)
   226b8:	e0bfff17 	ldw	r2,-4(fp)
   226bc:	10802d17 	ldw	r2,180(r2)
   226c0:	10800098 	cmpnei	r2,r2,2
   226c4:	1000601e 	bne	r2,zero,22848 <alt_read_cfi_table+0x4d8>
   226c8:	e0bffd03 	ldbu	r2,-12(fp)
   226cc:	108000d8 	cmpnei	r2,r2,3
   226d0:	10005d1e 	bne	r2,zero,22848 <alt_read_cfi_table+0x4d8>
   226d4:	e0bfff17 	ldw	r2,-4(fp)
   226d8:	10800c17 	ldw	r2,48(r2)
   226dc:	10bfffc4 	addi	r2,r2,-1
   226e0:	e0bff515 	stw	r2,-44(fp)
   226e4:	e03ff615 	stw	zero,-40(fp)
   226e8:	00005406 	br	2283c <alt_read_cfi_table+0x4cc>
   226ec:	e0ffff17 	ldw	r3,-4(fp)
   226f0:	e0bff517 	ldw	r2,-44(fp)
   226f4:	1004913a 	slli	r2,r2,4
   226f8:	1885883a 	add	r2,r3,r2
   226fc:	10800e04 	addi	r2,r2,56
   22700:	10800017 	ldw	r2,0(r2)
   22704:	e0bffe15 	stw	r2,-8(fp)
   22708:	e0ffff17 	ldw	r3,-4(fp)
   2270c:	e0bff617 	ldw	r2,-40(fp)
   22710:	1004913a 	slli	r2,r2,4
   22714:	1885883a 	add	r2,r3,r2
   22718:	10800e04 	addi	r2,r2,56
   2271c:	10c00017 	ldw	r3,0(r2)
   22720:	e13fff17 	ldw	r4,-4(fp)
   22724:	e0bff517 	ldw	r2,-44(fp)
   22728:	1004913a 	slli	r2,r2,4
   2272c:	2085883a 	add	r2,r4,r2
   22730:	10800e04 	addi	r2,r2,56
   22734:	10c00015 	stw	r3,0(r2)
   22738:	e0ffff17 	ldw	r3,-4(fp)
   2273c:	e0bff617 	ldw	r2,-40(fp)
   22740:	1004913a 	slli	r2,r2,4
   22744:	1885883a 	add	r2,r3,r2
   22748:	10800e04 	addi	r2,r2,56
   2274c:	e0fffe17 	ldw	r3,-8(fp)
   22750:	10c00015 	stw	r3,0(r2)
   22754:	e0ffff17 	ldw	r3,-4(fp)
   22758:	e0bff517 	ldw	r2,-44(fp)
   2275c:	10800104 	addi	r2,r2,4
   22760:	1004913a 	slli	r2,r2,4
   22764:	1885883a 	add	r2,r3,r2
   22768:	10800017 	ldw	r2,0(r2)
   2276c:	e0bffe15 	stw	r2,-8(fp)
   22770:	e0ffff17 	ldw	r3,-4(fp)
   22774:	e0bff617 	ldw	r2,-40(fp)
   22778:	10800104 	addi	r2,r2,4
   2277c:	1004913a 	slli	r2,r2,4
   22780:	1885883a 	add	r2,r3,r2
   22784:	10c00017 	ldw	r3,0(r2)
   22788:	e13fff17 	ldw	r4,-4(fp)
   2278c:	e0bff517 	ldw	r2,-44(fp)
   22790:	10800104 	addi	r2,r2,4
   22794:	1004913a 	slli	r2,r2,4
   22798:	2085883a 	add	r2,r4,r2
   2279c:	10c00015 	stw	r3,0(r2)
   227a0:	e0ffff17 	ldw	r3,-4(fp)
   227a4:	e0bff617 	ldw	r2,-40(fp)
   227a8:	10800104 	addi	r2,r2,4
   227ac:	1004913a 	slli	r2,r2,4
   227b0:	1885883a 	add	r2,r3,r2
   227b4:	e0fffe17 	ldw	r3,-8(fp)
   227b8:	10c00015 	stw	r3,0(r2)
   227bc:	e0ffff17 	ldw	r3,-4(fp)
   227c0:	e0bff517 	ldw	r2,-44(fp)
   227c4:	1004913a 	slli	r2,r2,4
   227c8:	1885883a 	add	r2,r3,r2
   227cc:	10800f04 	addi	r2,r2,60
   227d0:	10800017 	ldw	r2,0(r2)
   227d4:	e0bffe15 	stw	r2,-8(fp)
   227d8:	e0ffff17 	ldw	r3,-4(fp)
   227dc:	e0bff617 	ldw	r2,-40(fp)
   227e0:	1004913a 	slli	r2,r2,4
   227e4:	1885883a 	add	r2,r3,r2
   227e8:	10800f04 	addi	r2,r2,60
   227ec:	10c00017 	ldw	r3,0(r2)
   227f0:	e13fff17 	ldw	r4,-4(fp)
   227f4:	e0bff517 	ldw	r2,-44(fp)
   227f8:	1004913a 	slli	r2,r2,4
   227fc:	2085883a 	add	r2,r4,r2
   22800:	10800f04 	addi	r2,r2,60
   22804:	10c00015 	stw	r3,0(r2)
   22808:	e0ffff17 	ldw	r3,-4(fp)
   2280c:	e0bff617 	ldw	r2,-40(fp)
   22810:	1004913a 	slli	r2,r2,4
   22814:	1885883a 	add	r2,r3,r2
   22818:	10800f04 	addi	r2,r2,60
   2281c:	e0fffe17 	ldw	r3,-8(fp)
   22820:	10c00015 	stw	r3,0(r2)
   22824:	e0bff517 	ldw	r2,-44(fp)
   22828:	10bfffc4 	addi	r2,r2,-1
   2282c:	e0bff515 	stw	r2,-44(fp)
   22830:	e0bff617 	ldw	r2,-40(fp)
   22834:	10800044 	addi	r2,r2,1
   22838:	e0bff615 	stw	r2,-40(fp)
   2283c:	e0bff617 	ldw	r2,-40(fp)
   22840:	e0fff517 	ldw	r3,-44(fp)
   22844:	18bfa90e 	bge	r3,r2,226ec <alt_read_cfi_table+0x37c>
   22848:	e03ff515 	stw	zero,-44(fp)
   2284c:	00001306 	br	2289c <alt_read_cfi_table+0x52c>
   22850:	e0ffff17 	ldw	r3,-4(fp)
   22854:	e0bff517 	ldw	r2,-44(fp)
   22858:	1004913a 	slli	r2,r2,4
   2285c:	1885883a 	add	r2,r3,r2
   22860:	10800d04 	addi	r2,r2,52
   22864:	e0fff917 	ldw	r3,-28(fp)
   22868:	10c00015 	stw	r3,0(r2)
   2286c:	e0ffff17 	ldw	r3,-4(fp)
   22870:	e0bff517 	ldw	r2,-44(fp)
   22874:	1004913a 	slli	r2,r2,4
   22878:	1885883a 	add	r2,r3,r2
   2287c:	10800e04 	addi	r2,r2,56
   22880:	10800017 	ldw	r2,0(r2)
   22884:	e0fff917 	ldw	r3,-28(fp)
   22888:	1885883a 	add	r2,r3,r2
   2288c:	e0bff915 	stw	r2,-28(fp)
   22890:	e0bff517 	ldw	r2,-44(fp)
   22894:	10800044 	addi	r2,r2,1
   22898:	e0bff515 	stw	r2,-44(fp)
   2289c:	e0bfff17 	ldw	r2,-4(fp)
   228a0:	10800c17 	ldw	r2,48(r2)
   228a4:	e0fff517 	ldw	r3,-44(fp)
   228a8:	18bfe916 	blt	r3,r2,22850 <alt_read_cfi_table+0x4e0>
   228ac:	e0bfff17 	ldw	r2,-4(fp)
   228b0:	10802d17 	ldw	r2,180(r2)
   228b4:	10c000a0 	cmpeqi	r3,r2,2
   228b8:	1800051e 	bne	r3,zero,228d0 <alt_read_cfi_table+0x560>
   228bc:	10c000e0 	cmpeqi	r3,r2,3
   228c0:	18000c1e 	bne	r3,zero,228f4 <alt_read_cfi_table+0x584>
   228c4:	10800060 	cmpeqi	r2,r2,1
   228c8:	10000a1e 	bne	r2,zero,228f4 <alt_read_cfi_table+0x584>
   228cc:	00001206 	br	22918 <alt_read_cfi_table+0x5a8>
   228d0:	e0bfff17 	ldw	r2,-4(fp)
   228d4:	10c03317 	ldw	r3,204(r2)
   228d8:	e0bfff17 	ldw	r2,-4(fp)
   228dc:	10800a17 	ldw	r2,40(r2)
   228e0:	1009883a 	mov	r4,r2
   228e4:	01401544 	movi	r5,85
   228e8:	01803c04 	movi	r6,240
   228ec:	183ee83a 	callr	r3
   228f0:	00000b06 	br	22920 <alt_read_cfi_table+0x5b0>
   228f4:	e0bfff17 	ldw	r2,-4(fp)
   228f8:	10c03317 	ldw	r3,204(r2)
   228fc:	e0bfff17 	ldw	r2,-4(fp)
   22900:	10800a17 	ldw	r2,40(r2)
   22904:	1009883a 	mov	r4,r2
   22908:	01401544 	movi	r5,85
   2290c:	01803fc4 	movi	r6,255
   22910:	183ee83a 	callr	r3
   22914:	00000206 	br	22920 <alt_read_cfi_table+0x5b0>
   22918:	00bffec4 	movi	r2,-5
   2291c:	e0bff715 	stw	r2,-36(fp)
   22920:	e0bff717 	ldw	r2,-36(fp)
   22924:	e037883a 	mov	sp,fp
   22928:	dfc00117 	ldw	ra,4(sp)
   2292c:	df000017 	ldw	fp,0(sp)
   22930:	dec00204 	addi	sp,sp,8
   22934:	f800283a 	ret

00022938 <alt_read_cfi_width>:
   22938:	defff704 	addi	sp,sp,-36
   2293c:	dfc00815 	stw	ra,32(sp)
   22940:	df000715 	stw	fp,28(sp)
   22944:	df000704 	addi	fp,sp,28
   22948:	e13fff15 	stw	r4,-4(fp)
   2294c:	e03ffa15 	stw	zero,-24(fp)
   22950:	e0bfff17 	ldw	r2,-4(fp)
   22954:	10800a17 	ldw	r2,40(r2)
   22958:	1009883a 	mov	r4,r2
   2295c:	01401544 	movi	r5,85
   22960:	01802604 	movi	r6,152
   22964:	0021e080 	call	21e08 <alt_write_flash_command_8bit_device_8bit_mode>
   22968:	e03ff915 	stw	zero,-28(fp)
   2296c:	00000f06 	br	229ac <alt_read_cfi_width+0x74>
   22970:	e0bfff17 	ldw	r2,-4(fp)
   22974:	10c00a17 	ldw	r3,40(r2)
   22978:	e0bff917 	ldw	r2,-28(fp)
   2297c:	10800404 	addi	r2,r2,16
   22980:	1885883a 	add	r2,r3,r2
   22984:	10800023 	ldbuio	r2,0(r2)
   22988:	10803fcc 	andi	r2,r2,255
   2298c:	1007883a 	mov	r3,r2
   22990:	e13ffb84 	addi	r4,fp,-18
   22994:	e0bff917 	ldw	r2,-28(fp)
   22998:	2085883a 	add	r2,r4,r2
   2299c:	10c00005 	stb	r3,0(r2)
   229a0:	e0bff917 	ldw	r2,-28(fp)
   229a4:	10800044 	addi	r2,r2,1
   229a8:	e0bff915 	stw	r2,-28(fp)
   229ac:	e0bff917 	ldw	r2,-28(fp)
   229b0:	108000d0 	cmplti	r2,r2,3
   229b4:	103fee1e 	bne	r2,zero,22970 <alt_read_cfi_width+0x38>
   229b8:	e0bffb83 	ldbu	r2,-18(fp)
   229bc:	10803fcc 	andi	r2,r2,255
   229c0:	10801458 	cmpnei	r2,r2,81
   229c4:	10001d1e 	bne	r2,zero,22a3c <alt_read_cfi_width+0x104>
   229c8:	e0bffbc3 	ldbu	r2,-17(fp)
   229cc:	10803fcc 	andi	r2,r2,255
   229d0:	10801498 	cmpnei	r2,r2,82
   229d4:	1000191e 	bne	r2,zero,22a3c <alt_read_cfi_width+0x104>
   229d8:	e0bffc03 	ldbu	r2,-16(fp)
   229dc:	10803fcc 	andi	r2,r2,255
   229e0:	10801658 	cmpnei	r2,r2,89
   229e4:	1000151e 	bne	r2,zero,22a3c <alt_read_cfi_width+0x104>
   229e8:	e0bfff17 	ldw	r2,-4(fp)
   229ec:	00c00044 	movi	r3,1
   229f0:	10c02e15 	stw	r3,184(r2)
   229f4:	e0bfff17 	ldw	r2,-4(fp)
   229f8:	00c00044 	movi	r3,1
   229fc:	10c02f15 	stw	r3,188(r2)
   22a00:	e0bfff17 	ldw	r2,-4(fp)
   22a04:	10800a17 	ldw	r2,40(r2)
   22a08:	10800a04 	addi	r2,r2,40
   22a0c:	1080002b 	ldhuio	r2,0(r2)
   22a10:	10bfffcc 	andi	r2,r2,65535
   22a14:	e0bffb0d 	sth	r2,-20(fp)
   22a18:	e0bffb0b 	ldhu	r2,-20(fp)
   22a1c:	10800044 	addi	r2,r2,1
   22a20:	e0bffb0d 	sth	r2,-20(fp)
   22a24:	e0bffb0b 	ldhu	r2,-20(fp)
   22a28:	1080004c 	andi	r2,r2,1
   22a2c:	1001981e 	bne	r2,zero,23090 <alt_read_cfi_width+0x758>
   22a30:	00bffb44 	movi	r2,-19
   22a34:	e0bffa15 	stw	r2,-24(fp)
   22a38:	00019506 	br	23090 <alt_read_cfi_width+0x758>
   22a3c:	e0bfff17 	ldw	r2,-4(fp)
   22a40:	10800a17 	ldw	r2,40(r2)
   22a44:	1009883a 	mov	r4,r2
   22a48:	01401544 	movi	r5,85
   22a4c:	01802604 	movi	r6,152
   22a50:	0021e4c0 	call	21e4c <alt_write_flash_command_16bit_device_8bit_mode>
   22a54:	e03ff915 	stw	zero,-28(fp)
   22a58:	00000f06 	br	22a98 <alt_read_cfi_width+0x160>
   22a5c:	e0bfff17 	ldw	r2,-4(fp)
   22a60:	10c00a17 	ldw	r3,40(r2)
   22a64:	e0bff917 	ldw	r2,-28(fp)
   22a68:	10800804 	addi	r2,r2,32
   22a6c:	1885883a 	add	r2,r3,r2
   22a70:	10800023 	ldbuio	r2,0(r2)
   22a74:	10803fcc 	andi	r2,r2,255
   22a78:	1007883a 	mov	r3,r2
   22a7c:	e13ffb84 	addi	r4,fp,-18
   22a80:	e0bff917 	ldw	r2,-28(fp)
   22a84:	2085883a 	add	r2,r4,r2
   22a88:	10c00005 	stb	r3,0(r2)
   22a8c:	e0bff917 	ldw	r2,-28(fp)
   22a90:	10800044 	addi	r2,r2,1
   22a94:	e0bff915 	stw	r2,-28(fp)
   22a98:	e0bff917 	ldw	r2,-28(fp)
   22a9c:	10800190 	cmplti	r2,r2,6
   22aa0:	103fee1e 	bne	r2,zero,22a5c <alt_read_cfi_width+0x124>
   22aa4:	e0bffb83 	ldbu	r2,-18(fp)
   22aa8:	10803fcc 	andi	r2,r2,255
   22aac:	10801458 	cmpnei	r2,r2,81
   22ab0:	1000291e 	bne	r2,zero,22b58 <alt_read_cfi_width+0x220>
   22ab4:	e0bffbc3 	ldbu	r2,-17(fp)
   22ab8:	10803fcc 	andi	r2,r2,255
   22abc:	10801458 	cmpnei	r2,r2,81
   22ac0:	1000251e 	bne	r2,zero,22b58 <alt_read_cfi_width+0x220>
   22ac4:	e0bffc03 	ldbu	r2,-16(fp)
   22ac8:	10803fcc 	andi	r2,r2,255
   22acc:	10801498 	cmpnei	r2,r2,82
   22ad0:	1000211e 	bne	r2,zero,22b58 <alt_read_cfi_width+0x220>
   22ad4:	e0bffc43 	ldbu	r2,-15(fp)
   22ad8:	10803fcc 	andi	r2,r2,255
   22adc:	10801498 	cmpnei	r2,r2,82
   22ae0:	10001d1e 	bne	r2,zero,22b58 <alt_read_cfi_width+0x220>
   22ae4:	e0bffc83 	ldbu	r2,-14(fp)
   22ae8:	10803fcc 	andi	r2,r2,255
   22aec:	10801658 	cmpnei	r2,r2,89
   22af0:	1000191e 	bne	r2,zero,22b58 <alt_read_cfi_width+0x220>
   22af4:	e0bffcc3 	ldbu	r2,-13(fp)
   22af8:	10803fcc 	andi	r2,r2,255
   22afc:	10801658 	cmpnei	r2,r2,89
   22b00:	1000151e 	bne	r2,zero,22b58 <alt_read_cfi_width+0x220>
   22b04:	e0bfff17 	ldw	r2,-4(fp)
   22b08:	00c00044 	movi	r3,1
   22b0c:	10c02e15 	stw	r3,184(r2)
   22b10:	e0bfff17 	ldw	r2,-4(fp)
   22b14:	00c00084 	movi	r3,2
   22b18:	10c02f15 	stw	r3,188(r2)
   22b1c:	e0bfff17 	ldw	r2,-4(fp)
   22b20:	10800a17 	ldw	r2,40(r2)
   22b24:	10801404 	addi	r2,r2,80
   22b28:	1080002b 	ldhuio	r2,0(r2)
   22b2c:	10bfffcc 	andi	r2,r2,65535
   22b30:	e0bffb0d 	sth	r2,-20(fp)
   22b34:	e0bffb0b 	ldhu	r2,-20(fp)
   22b38:	10800044 	addi	r2,r2,1
   22b3c:	e0bffb0d 	sth	r2,-20(fp)
   22b40:	e0bffb0b 	ldhu	r2,-20(fp)
   22b44:	1080004c 	andi	r2,r2,1
   22b48:	1001511e 	bne	r2,zero,23090 <alt_read_cfi_width+0x758>
   22b4c:	00bffb44 	movi	r2,-19
   22b50:	e0bffa15 	stw	r2,-24(fp)
   22b54:	00014e06 	br	23090 <alt_read_cfi_width+0x758>
   22b58:	e0bfff17 	ldw	r2,-4(fp)
   22b5c:	10800a17 	ldw	r2,40(r2)
   22b60:	1009883a 	mov	r4,r2
   22b64:	01401544 	movi	r5,85
   22b68:	01802604 	movi	r6,152
   22b6c:	0021f0c0 	call	21f0c <alt_write_flash_command_16bit_device_16bit_mode>
   22b70:	e03ff915 	stw	zero,-28(fp)
   22b74:	00000f06 	br	22bb4 <alt_read_cfi_width+0x27c>
   22b78:	e0bfff17 	ldw	r2,-4(fp)
   22b7c:	10c00a17 	ldw	r3,40(r2)
   22b80:	e0bff917 	ldw	r2,-28(fp)
   22b84:	10800804 	addi	r2,r2,32
   22b88:	1885883a 	add	r2,r3,r2
   22b8c:	10800023 	ldbuio	r2,0(r2)
   22b90:	10803fcc 	andi	r2,r2,255
   22b94:	1007883a 	mov	r3,r2
   22b98:	e13ffb84 	addi	r4,fp,-18
   22b9c:	e0bff917 	ldw	r2,-28(fp)
   22ba0:	2085883a 	add	r2,r4,r2
   22ba4:	10c00005 	stb	r3,0(r2)
   22ba8:	e0bff917 	ldw	r2,-28(fp)
   22bac:	10800044 	addi	r2,r2,1
   22bb0:	e0bff915 	stw	r2,-28(fp)
   22bb4:	e0bff917 	ldw	r2,-28(fp)
   22bb8:	10800190 	cmplti	r2,r2,6
   22bbc:	103fee1e 	bne	r2,zero,22b78 <alt_read_cfi_width+0x240>
   22bc0:	e0bffb83 	ldbu	r2,-18(fp)
   22bc4:	10803fcc 	andi	r2,r2,255
   22bc8:	10801458 	cmpnei	r2,r2,81
   22bcc:	1000261e 	bne	r2,zero,22c68 <alt_read_cfi_width+0x330>
   22bd0:	e0bffbc3 	ldbu	r2,-17(fp)
   22bd4:	10803fcc 	andi	r2,r2,255
   22bd8:	1000231e 	bne	r2,zero,22c68 <alt_read_cfi_width+0x330>
   22bdc:	e0bffc03 	ldbu	r2,-16(fp)
   22be0:	10803fcc 	andi	r2,r2,255
   22be4:	10801498 	cmpnei	r2,r2,82
   22be8:	10001f1e 	bne	r2,zero,22c68 <alt_read_cfi_width+0x330>
   22bec:	e0bffc43 	ldbu	r2,-15(fp)
   22bf0:	10803fcc 	andi	r2,r2,255
   22bf4:	10001c1e 	bne	r2,zero,22c68 <alt_read_cfi_width+0x330>
   22bf8:	e0bffc83 	ldbu	r2,-14(fp)
   22bfc:	10803fcc 	andi	r2,r2,255
   22c00:	10801658 	cmpnei	r2,r2,89
   22c04:	1000181e 	bne	r2,zero,22c68 <alt_read_cfi_width+0x330>
   22c08:	e0bffcc3 	ldbu	r2,-13(fp)
   22c0c:	10803fcc 	andi	r2,r2,255
   22c10:	1000151e 	bne	r2,zero,22c68 <alt_read_cfi_width+0x330>
   22c14:	e0bfff17 	ldw	r2,-4(fp)
   22c18:	00c00084 	movi	r3,2
   22c1c:	10c02e15 	stw	r3,184(r2)
   22c20:	e0bfff17 	ldw	r2,-4(fp)
   22c24:	00c00084 	movi	r3,2
   22c28:	10c02f15 	stw	r3,188(r2)
   22c2c:	e0bfff17 	ldw	r2,-4(fp)
   22c30:	10800a17 	ldw	r2,40(r2)
   22c34:	10801404 	addi	r2,r2,80
   22c38:	1080002b 	ldhuio	r2,0(r2)
   22c3c:	10bfffcc 	andi	r2,r2,65535
   22c40:	e0bffb0d 	sth	r2,-20(fp)
   22c44:	e0bffb0b 	ldhu	r2,-20(fp)
   22c48:	10800044 	addi	r2,r2,1
   22c4c:	e0bffb0d 	sth	r2,-20(fp)
   22c50:	e0bffb0b 	ldhu	r2,-20(fp)
   22c54:	1080008c 	andi	r2,r2,2
   22c58:	10010d1e 	bne	r2,zero,23090 <alt_read_cfi_width+0x758>
   22c5c:	00bffb44 	movi	r2,-19
   22c60:	e0bffa15 	stw	r2,-24(fp)
   22c64:	00010a06 	br	23090 <alt_read_cfi_width+0x758>
   22c68:	e0bfff17 	ldw	r2,-4(fp)
   22c6c:	10800a17 	ldw	r2,40(r2)
   22c70:	1009883a 	mov	r4,r2
   22c74:	01401544 	movi	r5,85
   22c78:	01802604 	movi	r6,152
   22c7c:	0021fa00 	call	21fa0 <alt_write_flash_command_32bit_device_32bit_mode>
   22c80:	e03ff915 	stw	zero,-28(fp)
   22c84:	00000f06 	br	22cc4 <alt_read_cfi_width+0x38c>
   22c88:	e0bfff17 	ldw	r2,-4(fp)
   22c8c:	10c00a17 	ldw	r3,40(r2)
   22c90:	e0bff917 	ldw	r2,-28(fp)
   22c94:	10801004 	addi	r2,r2,64
   22c98:	1885883a 	add	r2,r3,r2
   22c9c:	10800023 	ldbuio	r2,0(r2)
   22ca0:	10803fcc 	andi	r2,r2,255
   22ca4:	1007883a 	mov	r3,r2
   22ca8:	e13ffb84 	addi	r4,fp,-18
   22cac:	e0bff917 	ldw	r2,-28(fp)
   22cb0:	2085883a 	add	r2,r4,r2
   22cb4:	10c00005 	stb	r3,0(r2)
   22cb8:	e0bff917 	ldw	r2,-28(fp)
   22cbc:	10800044 	addi	r2,r2,1
   22cc0:	e0bff915 	stw	r2,-28(fp)
   22cc4:	e0bff917 	ldw	r2,-28(fp)
   22cc8:	10800310 	cmplti	r2,r2,12
   22ccc:	103fee1e 	bne	r2,zero,22c88 <alt_read_cfi_width+0x350>
   22cd0:	e0bffb83 	ldbu	r2,-18(fp)
   22cd4:	10803fcc 	andi	r2,r2,255
   22cd8:	10801458 	cmpnei	r2,r2,81
   22cdc:	1000371e 	bne	r2,zero,22dbc <alt_read_cfi_width+0x484>
   22ce0:	e0bffbc3 	ldbu	r2,-17(fp)
   22ce4:	10803fcc 	andi	r2,r2,255
   22ce8:	1000341e 	bne	r2,zero,22dbc <alt_read_cfi_width+0x484>
   22cec:	e0bffc03 	ldbu	r2,-16(fp)
   22cf0:	10803fcc 	andi	r2,r2,255
   22cf4:	1000311e 	bne	r2,zero,22dbc <alt_read_cfi_width+0x484>
   22cf8:	e0bffc43 	ldbu	r2,-15(fp)
   22cfc:	10803fcc 	andi	r2,r2,255
   22d00:	10002e1e 	bne	r2,zero,22dbc <alt_read_cfi_width+0x484>
   22d04:	e0bffc83 	ldbu	r2,-14(fp)
   22d08:	10803fcc 	andi	r2,r2,255
   22d0c:	10801498 	cmpnei	r2,r2,82
   22d10:	10002a1e 	bne	r2,zero,22dbc <alt_read_cfi_width+0x484>
   22d14:	e0bffcc3 	ldbu	r2,-13(fp)
   22d18:	10803fcc 	andi	r2,r2,255
   22d1c:	1000271e 	bne	r2,zero,22dbc <alt_read_cfi_width+0x484>
   22d20:	e0bffd03 	ldbu	r2,-12(fp)
   22d24:	10803fcc 	andi	r2,r2,255
   22d28:	1000241e 	bne	r2,zero,22dbc <alt_read_cfi_width+0x484>
   22d2c:	e0bffd43 	ldbu	r2,-11(fp)
   22d30:	10803fcc 	andi	r2,r2,255
   22d34:	1000211e 	bne	r2,zero,22dbc <alt_read_cfi_width+0x484>
   22d38:	e0bffd83 	ldbu	r2,-10(fp)
   22d3c:	10803fcc 	andi	r2,r2,255
   22d40:	10801658 	cmpnei	r2,r2,89
   22d44:	10001d1e 	bne	r2,zero,22dbc <alt_read_cfi_width+0x484>
   22d48:	e0bffdc3 	ldbu	r2,-9(fp)
   22d4c:	10803fcc 	andi	r2,r2,255
   22d50:	10001a1e 	bne	r2,zero,22dbc <alt_read_cfi_width+0x484>
   22d54:	e0bffe03 	ldbu	r2,-8(fp)
   22d58:	10803fcc 	andi	r2,r2,255
   22d5c:	1000171e 	bne	r2,zero,22dbc <alt_read_cfi_width+0x484>
   22d60:	e0bffe43 	ldbu	r2,-7(fp)
   22d64:	10803fcc 	andi	r2,r2,255
   22d68:	1000141e 	bne	r2,zero,22dbc <alt_read_cfi_width+0x484>
   22d6c:	e0bfff17 	ldw	r2,-4(fp)
   22d70:	00c00104 	movi	r3,4
   22d74:	10c02e15 	stw	r3,184(r2)
   22d78:	e0bfff17 	ldw	r2,-4(fp)
   22d7c:	00c00104 	movi	r3,4
   22d80:	10c02f15 	stw	r3,188(r2)
   22d84:	e0bfff17 	ldw	r2,-4(fp)
   22d88:	10800a17 	ldw	r2,40(r2)
   22d8c:	10802804 	addi	r2,r2,160
   22d90:	10800037 	ldwio	r2,0(r2)
   22d94:	e0bffb0d 	sth	r2,-20(fp)
   22d98:	e0bffb0b 	ldhu	r2,-20(fp)
   22d9c:	10800044 	addi	r2,r2,1
   22da0:	e0bffb0d 	sth	r2,-20(fp)
   22da4:	e0bffb0b 	ldhu	r2,-20(fp)
   22da8:	1080010c 	andi	r2,r2,4
   22dac:	1000b81e 	bne	r2,zero,23090 <alt_read_cfi_width+0x758>
   22db0:	00bffb44 	movi	r2,-19
   22db4:	e0bffa15 	stw	r2,-24(fp)
   22db8:	0000b506 	br	23090 <alt_read_cfi_width+0x758>
   22dbc:	e0bfff17 	ldw	r2,-4(fp)
   22dc0:	10800a17 	ldw	r2,40(r2)
   22dc4:	1009883a 	mov	r4,r2
   22dc8:	01401544 	movi	r5,85
   22dcc:	01802604 	movi	r6,152
   22dd0:	0021f540 	call	21f54 <alt_write_flash_command_32bit_device_16bit_mode>
   22dd4:	e03ff915 	stw	zero,-28(fp)
   22dd8:	00000f06 	br	22e18 <alt_read_cfi_width+0x4e0>
   22ddc:	e0bfff17 	ldw	r2,-4(fp)
   22de0:	10c00a17 	ldw	r3,40(r2)
   22de4:	e0bff917 	ldw	r2,-28(fp)
   22de8:	10801004 	addi	r2,r2,64
   22dec:	1885883a 	add	r2,r3,r2
   22df0:	10800023 	ldbuio	r2,0(r2)
   22df4:	10803fcc 	andi	r2,r2,255
   22df8:	1007883a 	mov	r3,r2
   22dfc:	e13ffb84 	addi	r4,fp,-18
   22e00:	e0bff917 	ldw	r2,-28(fp)
   22e04:	2085883a 	add	r2,r4,r2
   22e08:	10c00005 	stb	r3,0(r2)
   22e0c:	e0bff917 	ldw	r2,-28(fp)
   22e10:	10800044 	addi	r2,r2,1
   22e14:	e0bff915 	stw	r2,-28(fp)
   22e18:	e0bff917 	ldw	r2,-28(fp)
   22e1c:	10800310 	cmplti	r2,r2,12
   22e20:	103fee1e 	bne	r2,zero,22ddc <alt_read_cfi_width+0x4a4>
   22e24:	e0bffb83 	ldbu	r2,-18(fp)
   22e28:	10803fcc 	andi	r2,r2,255
   22e2c:	10801458 	cmpnei	r2,r2,81
   22e30:	10003a1e 	bne	r2,zero,22f1c <alt_read_cfi_width+0x5e4>
   22e34:	e0bffbc3 	ldbu	r2,-17(fp)
   22e38:	10803fcc 	andi	r2,r2,255
   22e3c:	1000371e 	bne	r2,zero,22f1c <alt_read_cfi_width+0x5e4>
   22e40:	e0bffc03 	ldbu	r2,-16(fp)
   22e44:	10803fcc 	andi	r2,r2,255
   22e48:	10801458 	cmpnei	r2,r2,81
   22e4c:	1000331e 	bne	r2,zero,22f1c <alt_read_cfi_width+0x5e4>
   22e50:	e0bffc43 	ldbu	r2,-15(fp)
   22e54:	10803fcc 	andi	r2,r2,255
   22e58:	1000301e 	bne	r2,zero,22f1c <alt_read_cfi_width+0x5e4>
   22e5c:	e0bffc83 	ldbu	r2,-14(fp)
   22e60:	10803fcc 	andi	r2,r2,255
   22e64:	10801498 	cmpnei	r2,r2,82
   22e68:	10002c1e 	bne	r2,zero,22f1c <alt_read_cfi_width+0x5e4>
   22e6c:	e0bffcc3 	ldbu	r2,-13(fp)
   22e70:	10803fcc 	andi	r2,r2,255
   22e74:	1000291e 	bne	r2,zero,22f1c <alt_read_cfi_width+0x5e4>
   22e78:	e0bffd03 	ldbu	r2,-12(fp)
   22e7c:	10803fcc 	andi	r2,r2,255
   22e80:	10801498 	cmpnei	r2,r2,82
   22e84:	1000251e 	bne	r2,zero,22f1c <alt_read_cfi_width+0x5e4>
   22e88:	e0bffd43 	ldbu	r2,-11(fp)
   22e8c:	10803fcc 	andi	r2,r2,255
   22e90:	1000221e 	bne	r2,zero,22f1c <alt_read_cfi_width+0x5e4>
   22e94:	e0bffd83 	ldbu	r2,-10(fp)
   22e98:	10803fcc 	andi	r2,r2,255
   22e9c:	10801658 	cmpnei	r2,r2,89
   22ea0:	10001e1e 	bne	r2,zero,22f1c <alt_read_cfi_width+0x5e4>
   22ea4:	e0bffdc3 	ldbu	r2,-9(fp)
   22ea8:	10803fcc 	andi	r2,r2,255
   22eac:	10001b1e 	bne	r2,zero,22f1c <alt_read_cfi_width+0x5e4>
   22eb0:	e0bffe03 	ldbu	r2,-8(fp)
   22eb4:	10803fcc 	andi	r2,r2,255
   22eb8:	10801658 	cmpnei	r2,r2,89
   22ebc:	1000171e 	bne	r2,zero,22f1c <alt_read_cfi_width+0x5e4>
   22ec0:	e0bffe43 	ldbu	r2,-7(fp)
   22ec4:	10803fcc 	andi	r2,r2,255
   22ec8:	1000141e 	bne	r2,zero,22f1c <alt_read_cfi_width+0x5e4>
   22ecc:	e0bfff17 	ldw	r2,-4(fp)
   22ed0:	00c00084 	movi	r3,2
   22ed4:	10c02e15 	stw	r3,184(r2)
   22ed8:	e0bfff17 	ldw	r2,-4(fp)
   22edc:	00c00104 	movi	r3,4
   22ee0:	10c02f15 	stw	r3,188(r2)
   22ee4:	e0bfff17 	ldw	r2,-4(fp)
   22ee8:	10800a17 	ldw	r2,40(r2)
   22eec:	10802804 	addi	r2,r2,160
   22ef0:	10800037 	ldwio	r2,0(r2)
   22ef4:	e0bffb0d 	sth	r2,-20(fp)
   22ef8:	e0bffb0b 	ldhu	r2,-20(fp)
   22efc:	10800044 	addi	r2,r2,1
   22f00:	e0bffb0d 	sth	r2,-20(fp)
   22f04:	e0bffb0b 	ldhu	r2,-20(fp)
   22f08:	1080010c 	andi	r2,r2,4
   22f0c:	1000601e 	bne	r2,zero,23090 <alt_read_cfi_width+0x758>
   22f10:	00bffb44 	movi	r2,-19
   22f14:	e0bffa15 	stw	r2,-24(fp)
   22f18:	00005d06 	br	23090 <alt_read_cfi_width+0x758>
   22f1c:	e0bfff17 	ldw	r2,-4(fp)
   22f20:	10800a17 	ldw	r2,40(r2)
   22f24:	1009883a 	mov	r4,r2
   22f28:	01401544 	movi	r5,85
   22f2c:	01802604 	movi	r6,152
   22f30:	0021ec00 	call	21ec0 <alt_write_flash_command_32bit_device_8bit_mode>
   22f34:	e03ff915 	stw	zero,-28(fp)
   22f38:	00000f06 	br	22f78 <alt_read_cfi_width+0x640>
   22f3c:	e0bfff17 	ldw	r2,-4(fp)
   22f40:	10c00a17 	ldw	r3,40(r2)
   22f44:	e0bff917 	ldw	r2,-28(fp)
   22f48:	10801004 	addi	r2,r2,64
   22f4c:	1885883a 	add	r2,r3,r2
   22f50:	10800023 	ldbuio	r2,0(r2)
   22f54:	10803fcc 	andi	r2,r2,255
   22f58:	1007883a 	mov	r3,r2
   22f5c:	e13ffb84 	addi	r4,fp,-18
   22f60:	e0bff917 	ldw	r2,-28(fp)
   22f64:	2085883a 	add	r2,r4,r2
   22f68:	10c00005 	stb	r3,0(r2)
   22f6c:	e0bff917 	ldw	r2,-28(fp)
   22f70:	10800044 	addi	r2,r2,1
   22f74:	e0bff915 	stw	r2,-28(fp)
   22f78:	e0bff917 	ldw	r2,-28(fp)
   22f7c:	10800310 	cmplti	r2,r2,12
   22f80:	103fee1e 	bne	r2,zero,22f3c <alt_read_cfi_width+0x604>
   22f84:	e0bffb83 	ldbu	r2,-18(fp)
   22f88:	10803fcc 	andi	r2,r2,255
   22f8c:	10801458 	cmpnei	r2,r2,81
   22f90:	10003f1e 	bne	r2,zero,23090 <alt_read_cfi_width+0x758>
   22f94:	e0bffbc3 	ldbu	r2,-17(fp)
   22f98:	10803fcc 	andi	r2,r2,255
   22f9c:	10801458 	cmpnei	r2,r2,81
   22fa0:	10003b1e 	bne	r2,zero,23090 <alt_read_cfi_width+0x758>
   22fa4:	e0bffc03 	ldbu	r2,-16(fp)
   22fa8:	10803fcc 	andi	r2,r2,255
   22fac:	10801458 	cmpnei	r2,r2,81
   22fb0:	1000371e 	bne	r2,zero,23090 <alt_read_cfi_width+0x758>
   22fb4:	e0bffc43 	ldbu	r2,-15(fp)
   22fb8:	10803fcc 	andi	r2,r2,255
   22fbc:	10801458 	cmpnei	r2,r2,81
   22fc0:	1000331e 	bne	r2,zero,23090 <alt_read_cfi_width+0x758>
   22fc4:	e0bffc83 	ldbu	r2,-14(fp)
   22fc8:	10803fcc 	andi	r2,r2,255
   22fcc:	10801498 	cmpnei	r2,r2,82
   22fd0:	10002f1e 	bne	r2,zero,23090 <alt_read_cfi_width+0x758>
   22fd4:	e0bffcc3 	ldbu	r2,-13(fp)
   22fd8:	10803fcc 	andi	r2,r2,255
   22fdc:	10801498 	cmpnei	r2,r2,82
   22fe0:	10002b1e 	bne	r2,zero,23090 <alt_read_cfi_width+0x758>
   22fe4:	e0bffd03 	ldbu	r2,-12(fp)
   22fe8:	10803fcc 	andi	r2,r2,255
   22fec:	10801498 	cmpnei	r2,r2,82
   22ff0:	1000271e 	bne	r2,zero,23090 <alt_read_cfi_width+0x758>
   22ff4:	e0bffd43 	ldbu	r2,-11(fp)
   22ff8:	10803fcc 	andi	r2,r2,255
   22ffc:	10801498 	cmpnei	r2,r2,82
   23000:	1000231e 	bne	r2,zero,23090 <alt_read_cfi_width+0x758>
   23004:	e0bffd83 	ldbu	r2,-10(fp)
   23008:	10803fcc 	andi	r2,r2,255
   2300c:	10801658 	cmpnei	r2,r2,89
   23010:	10001f1e 	bne	r2,zero,23090 <alt_read_cfi_width+0x758>
   23014:	e0bffdc3 	ldbu	r2,-9(fp)
   23018:	10803fcc 	andi	r2,r2,255
   2301c:	10801658 	cmpnei	r2,r2,89
   23020:	10001b1e 	bne	r2,zero,23090 <alt_read_cfi_width+0x758>
   23024:	e0bffe03 	ldbu	r2,-8(fp)
   23028:	10803fcc 	andi	r2,r2,255
   2302c:	10801658 	cmpnei	r2,r2,89
   23030:	1000171e 	bne	r2,zero,23090 <alt_read_cfi_width+0x758>
   23034:	e0bffe43 	ldbu	r2,-7(fp)
   23038:	10803fcc 	andi	r2,r2,255
   2303c:	10801658 	cmpnei	r2,r2,89
   23040:	1000131e 	bne	r2,zero,23090 <alt_read_cfi_width+0x758>
   23044:	e0bfff17 	ldw	r2,-4(fp)
   23048:	00c00044 	movi	r3,1
   2304c:	10c02e15 	stw	r3,184(r2)
   23050:	e0bfff17 	ldw	r2,-4(fp)
   23054:	00c00104 	movi	r3,4
   23058:	10c02f15 	stw	r3,188(r2)
   2305c:	e0bfff17 	ldw	r2,-4(fp)
   23060:	10800a17 	ldw	r2,40(r2)
   23064:	10802804 	addi	r2,r2,160
   23068:	10800037 	ldwio	r2,0(r2)
   2306c:	e0bffb0d 	sth	r2,-20(fp)
   23070:	e0bffb0b 	ldhu	r2,-20(fp)
   23074:	10800044 	addi	r2,r2,1
   23078:	e0bffb0d 	sth	r2,-20(fp)
   2307c:	e0bffb0b 	ldhu	r2,-20(fp)
   23080:	1080010c 	andi	r2,r2,4
   23084:	1000021e 	bne	r2,zero,23090 <alt_read_cfi_width+0x758>
   23088:	00bffb44 	movi	r2,-19
   2308c:	e0bffa15 	stw	r2,-24(fp)
   23090:	e0bffa17 	ldw	r2,-24(fp)
   23094:	e037883a 	mov	sp,fp
   23098:	dfc00117 	ldw	ra,4(sp)
   2309c:	df000017 	ldw	fp,0(sp)
   230a0:	dec00204 	addi	sp,sp,8
   230a4:	f800283a 	ret

000230a8 <alt_check_primary_table>:
   230a8:	defffa04 	addi	sp,sp,-24
   230ac:	dfc00515 	stw	ra,20(sp)
   230b0:	df000415 	stw	fp,16(sp)
   230b4:	df000404 	addi	fp,sp,16
   230b8:	e13fff15 	stw	r4,-4(fp)
   230bc:	e03ffd15 	stw	zero,-12(fp)
   230c0:	e13fff17 	ldw	r4,-4(fp)
   230c4:	01400544 	movi	r5,21
   230c8:	00222f00 	call	222f0 <alt_read_16bit_query_entry>
   230cc:	10ffffcc 	andi	r3,r2,65535
   230d0:	e0bfff17 	ldw	r2,-4(fp)
   230d4:	10c03215 	stw	r3,200(r2)
   230d8:	e03ffc15 	stw	zero,-16(fp)
   230dc:	00001006 	br	23120 <alt_check_primary_table+0x78>
   230e0:	e0bfff17 	ldw	r2,-4(fp)
   230e4:	10c03417 	ldw	r3,208(r2)
   230e8:	e0bfff17 	ldw	r2,-4(fp)
   230ec:	11003217 	ldw	r4,200(r2)
   230f0:	e0bffc17 	ldw	r2,-16(fp)
   230f4:	2085883a 	add	r2,r4,r2
   230f8:	e13fff17 	ldw	r4,-4(fp)
   230fc:	100b883a 	mov	r5,r2
   23100:	183ee83a 	callr	r3
   23104:	e13ffe04 	addi	r4,fp,-8
   23108:	e0fffc17 	ldw	r3,-16(fp)
   2310c:	20c7883a 	add	r3,r4,r3
   23110:	18800005 	stb	r2,0(r3)
   23114:	e0bffc17 	ldw	r2,-16(fp)
   23118:	10800044 	addi	r2,r2,1
   2311c:	e0bffc15 	stw	r2,-16(fp)
   23120:	e0bffc17 	ldw	r2,-16(fp)
   23124:	108000d0 	cmplti	r2,r2,3
   23128:	103fed1e 	bne	r2,zero,230e0 <alt_check_primary_table+0x38>
   2312c:	e0bffe03 	ldbu	r2,-8(fp)
   23130:	10803fcc 	andi	r2,r2,255
   23134:	10801418 	cmpnei	r2,r2,80
   23138:	1000081e 	bne	r2,zero,2315c <alt_check_primary_table+0xb4>
   2313c:	e0bffe43 	ldbu	r2,-7(fp)
   23140:	10803fcc 	andi	r2,r2,255
   23144:	10801498 	cmpnei	r2,r2,82
   23148:	1000041e 	bne	r2,zero,2315c <alt_check_primary_table+0xb4>
   2314c:	e0bffe83 	ldbu	r2,-6(fp)
   23150:	10803fcc 	andi	r2,r2,255
   23154:	10801260 	cmpeqi	r2,r2,73
   23158:	1000021e 	bne	r2,zero,23164 <alt_check_primary_table+0xbc>
   2315c:	00bffb44 	movi	r2,-19
   23160:	e0bffd15 	stw	r2,-12(fp)
   23164:	e0bffd17 	ldw	r2,-12(fp)
   23168:	e037883a 	mov	sp,fp
   2316c:	dfc00117 	ldw	ra,4(sp)
   23170:	df000017 	ldw	fp,0(sp)
   23174:	dec00204 	addi	sp,sp,8
   23178:	f800283a 	ret

0002317c <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
   2317c:	defffa04 	addi	sp,sp,-24
   23180:	dfc00515 	stw	ra,20(sp)
   23184:	df000415 	stw	fp,16(sp)
   23188:	df000404 	addi	fp,sp,16
   2318c:	e13ffd15 	stw	r4,-12(fp)
   23190:	e17ffe15 	stw	r5,-8(fp)
   23194:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
   23198:	e0bffd17 	ldw	r2,-12(fp)
   2319c:	10800017 	ldw	r2,0(r2)
   231a0:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
   231a4:	e0bffc17 	ldw	r2,-16(fp)
   231a8:	10c00a04 	addi	r3,r2,40
      fd->fd_flags);
   231ac:	e0bffd17 	ldw	r2,-12(fp)
int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
   231b0:	10800217 	ldw	r2,8(r2)
   231b4:	1809883a 	mov	r4,r3
   231b8:	e17ffe17 	ldw	r5,-8(fp)
   231bc:	e1bfff17 	ldw	r6,-4(fp)
   231c0:	100f883a 	mov	r7,r2
   231c4:	00237a40 	call	237a4 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
   231c8:	e037883a 	mov	sp,fp
   231cc:	dfc00117 	ldw	ra,4(sp)
   231d0:	df000017 	ldw	fp,0(sp)
   231d4:	dec00204 	addi	sp,sp,8
   231d8:	f800283a 	ret

000231dc <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
   231dc:	defffa04 	addi	sp,sp,-24
   231e0:	dfc00515 	stw	ra,20(sp)
   231e4:	df000415 	stw	fp,16(sp)
   231e8:	df000404 	addi	fp,sp,16
   231ec:	e13ffd15 	stw	r4,-12(fp)
   231f0:	e17ffe15 	stw	r5,-8(fp)
   231f4:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
   231f8:	e0bffd17 	ldw	r2,-12(fp)
   231fc:	10800017 	ldw	r2,0(r2)
   23200:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
   23204:	e0bffc17 	ldw	r2,-16(fp)
   23208:	10c00a04 	addi	r3,r2,40
      fd->fd_flags);
   2320c:	e0bffd17 	ldw	r2,-12(fp)
int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
   23210:	10800217 	ldw	r2,8(r2)
   23214:	1809883a 	mov	r4,r3
   23218:	e17ffe17 	ldw	r5,-8(fp)
   2321c:	e1bfff17 	ldw	r6,-4(fp)
   23220:	100f883a 	mov	r7,r2
   23224:	00239e80 	call	239e8 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
   23228:	e037883a 	mov	sp,fp
   2322c:	dfc00117 	ldw	ra,4(sp)
   23230:	df000017 	ldw	fp,0(sp)
   23234:	dec00204 	addi	sp,sp,8
   23238:	f800283a 	ret

0002323c <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
   2323c:	defffc04 	addi	sp,sp,-16
   23240:	dfc00315 	stw	ra,12(sp)
   23244:	df000215 	stw	fp,8(sp)
   23248:	df000204 	addi	fp,sp,8
   2324c:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
   23250:	e0bfff17 	ldw	r2,-4(fp)
   23254:	10800017 	ldw	r2,0(r2)
   23258:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
   2325c:	e0bffe17 	ldw	r2,-8(fp)
   23260:	10c00a04 	addi	r3,r2,40
   23264:	e0bfff17 	ldw	r2,-4(fp)
   23268:	10800217 	ldw	r2,8(r2)
   2326c:	1809883a 	mov	r4,r3
   23270:	100b883a 	mov	r5,r2
   23274:	00236480 	call	23648 <altera_avalon_jtag_uart_close>
}
   23278:	e037883a 	mov	sp,fp
   2327c:	dfc00117 	ldw	ra,4(sp)
   23280:	df000017 	ldw	fp,0(sp)
   23284:	dec00204 	addi	sp,sp,8
   23288:	f800283a 	ret

0002328c <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
   2328c:	defffa04 	addi	sp,sp,-24
   23290:	dfc00515 	stw	ra,20(sp)
   23294:	df000415 	stw	fp,16(sp)
   23298:	df000404 	addi	fp,sp,16
   2329c:	e13ffd15 	stw	r4,-12(fp)
   232a0:	e17ffe15 	stw	r5,-8(fp)
   232a4:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
   232a8:	e0bffd17 	ldw	r2,-12(fp)
   232ac:	10800017 	ldw	r2,0(r2)
   232b0:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
   232b4:	e0bffc17 	ldw	r2,-16(fp)
   232b8:	10800a04 	addi	r2,r2,40
   232bc:	1009883a 	mov	r4,r2
   232c0:	e17ffe17 	ldw	r5,-8(fp)
   232c4:	e1bfff17 	ldw	r6,-4(fp)
   232c8:	00236b00 	call	236b0 <altera_avalon_jtag_uart_ioctl>
}
   232cc:	e037883a 	mov	sp,fp
   232d0:	dfc00117 	ldw	ra,4(sp)
   232d4:	df000017 	ldw	fp,0(sp)
   232d8:	dec00204 	addi	sp,sp,8
   232dc:	f800283a 	ret

000232e0 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
   232e0:	defffa04 	addi	sp,sp,-24
   232e4:	dfc00515 	stw	ra,20(sp)
   232e8:	df000415 	stw	fp,16(sp)
   232ec:	df000404 	addi	fp,sp,16
   232f0:	e13ffd15 	stw	r4,-12(fp)
   232f4:	e17ffe15 	stw	r5,-8(fp)
   232f8:	e1bfff15 	stw	r6,-4(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
   232fc:	e0bffd17 	ldw	r2,-12(fp)
   23300:	00c00044 	movi	r3,1
   23304:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
   23308:	e0bffd17 	ldw	r2,-12(fp)
   2330c:	10800017 	ldw	r2,0(r2)
   23310:	10800104 	addi	r2,r2,4
   23314:	e0fffd17 	ldw	r3,-12(fp)
   23318:	18c00817 	ldw	r3,32(r3)
   2331c:	10c00035 	stwio	r3,0(r2)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
   23320:	e0fffe17 	ldw	r3,-8(fp)
   23324:	e0bfff17 	ldw	r2,-4(fp)
   23328:	d8000015 	stw	zero,0(sp)
   2332c:	1809883a 	mov	r4,r3
   23330:	100b883a 	mov	r5,r2
   23334:	018000b4 	movhi	r6,2
   23338:	318ce804 	addi	r6,r6,13216
   2333c:	e1fffd17 	ldw	r7,-12(fp)
   23340:	002b6280 	call	2b628 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
   23344:	e0bffd17 	ldw	r2,-12(fp)
   23348:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
   2334c:	e0bffd17 	ldw	r2,-12(fp)
   23350:	10c00204 	addi	r3,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
   23354:	008000f4 	movhi	r2,3
   23358:	1099e104 	addi	r2,r2,26500
   2335c:	10800017 	ldw	r2,0(r2)
   23360:	1809883a 	mov	r4,r3
   23364:	100b883a 	mov	r5,r2
   23368:	018000b4 	movhi	r6,2
   2336c:	318d6904 	addi	r6,r6,13732
   23370:	e1fffd17 	ldw	r7,-12(fp)
   23374:	002055c0 	call	2055c <alt_alarm_start>
   23378:	1000040e 	bge	r2,zero,2338c <altera_avalon_jtag_uart_init+0xac>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
   2337c:	e0bffd17 	ldw	r2,-12(fp)
   23380:	00e00034 	movhi	r3,32768
   23384:	18ffffc4 	addi	r3,r3,-1
   23388:	10c00115 	stw	r3,4(r2)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
   2338c:	e037883a 	mov	sp,fp
   23390:	dfc00117 	ldw	ra,4(sp)
   23394:	df000017 	ldw	fp,0(sp)
   23398:	dec00204 	addi	sp,sp,8
   2339c:	f800283a 	ret

000233a0 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
   233a0:	defff804 	addi	sp,sp,-32
   233a4:	df000715 	stw	fp,28(sp)
   233a8:	df000704 	addi	fp,sp,28
   233ac:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
   233b0:	e0bfff17 	ldw	r2,-4(fp)
   233b4:	e0bffb15 	stw	r2,-20(fp)
  unsigned int base = sp->base;
   233b8:	e0bffb17 	ldw	r2,-20(fp)
   233bc:	10800017 	ldw	r2,0(r2)
   233c0:	e0bffc15 	stw	r2,-16(fp)
   233c4:	00000106 	br	233cc <altera_avalon_jtag_uart_irq+0x2c>
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
   233c8:	0001883a 	nop
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
   233cc:	e0bffc17 	ldw	r2,-16(fp)
   233d0:	10800104 	addi	r2,r2,4
   233d4:	10800037 	ldwio	r2,0(r2)
   233d8:	e0bffd15 	stw	r2,-12(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
   233dc:	e0bffd17 	ldw	r2,-12(fp)
   233e0:	1080c00c 	andi	r2,r2,768
   233e4:	10006a26 	beq	r2,zero,23590 <altera_avalon_jtag_uart_irq+0x1f0>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
   233e8:	e0bffd17 	ldw	r2,-12(fp)
   233ec:	1080400c 	andi	r2,r2,256
   233f0:	10003326 	beq	r2,zero,234c0 <altera_avalon_jtag_uart_irq+0x120>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
   233f4:	00800074 	movhi	r2,1
   233f8:	e0bff915 	stw	r2,-28(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   233fc:	e0bffb17 	ldw	r2,-20(fp)
   23400:	10800a17 	ldw	r2,40(r2)
   23404:	10800044 	addi	r2,r2,1
   23408:	1081ffcc 	andi	r2,r2,2047
   2340c:	e0bffe15 	stw	r2,-8(fp)
        if (next == sp->rx_out)
   23410:	e0bffb17 	ldw	r2,-20(fp)
   23414:	10c00b17 	ldw	r3,44(r2)
   23418:	e0bffe17 	ldw	r2,-8(fp)
   2341c:	18801426 	beq	r3,r2,23470 <altera_avalon_jtag_uart_irq+0xd0>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
   23420:	e0bffc17 	ldw	r2,-16(fp)
   23424:	10800037 	ldwio	r2,0(r2)
   23428:	e0bff915 	stw	r2,-28(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
   2342c:	e0bff917 	ldw	r2,-28(fp)
   23430:	10a0000c 	andi	r2,r2,32768
   23434:	10001026 	beq	r2,zero,23478 <altera_avalon_jtag_uart_irq+0xd8>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
   23438:	e0bffb17 	ldw	r2,-20(fp)
   2343c:	10800a17 	ldw	r2,40(r2)
   23440:	e0fff917 	ldw	r3,-28(fp)
   23444:	e13ffb17 	ldw	r4,-20(fp)
   23448:	2085883a 	add	r2,r4,r2
   2344c:	10800e04 	addi	r2,r2,56
   23450:	10c00005 	stb	r3,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   23454:	e0bffb17 	ldw	r2,-20(fp)
   23458:	10800a17 	ldw	r2,40(r2)
   2345c:	10800044 	addi	r2,r2,1
   23460:	10c1ffcc 	andi	r3,r2,2047
   23464:	e0bffb17 	ldw	r2,-20(fp)
   23468:	10c00a15 	stw	r3,40(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }
   2346c:	003fe306 	br	233fc <altera_avalon_jtag_uart_irq+0x5c>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
   23470:	0001883a 	nop
   23474:	00000106 	br	2347c <altera_avalon_jtag_uart_irq+0xdc>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
   23478:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
   2347c:	e0bff917 	ldw	r2,-28(fp)
   23480:	10bfffec 	andhi	r2,r2,65535
   23484:	10000e26 	beq	r2,zero,234c0 <altera_avalon_jtag_uart_irq+0x120>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
   23488:	e0bffb17 	ldw	r2,-20(fp)
   2348c:	10c00817 	ldw	r3,32(r2)
   23490:	00bfff84 	movi	r2,-2
   23494:	1886703a 	and	r3,r3,r2
   23498:	e0bffb17 	ldw	r2,-20(fp)
   2349c:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
   234a0:	e0bffc17 	ldw	r2,-16(fp)
   234a4:	10800104 	addi	r2,r2,4
   234a8:	e0fffb17 	ldw	r3,-20(fp)
   234ac:	18c00817 	ldw	r3,32(r3)
   234b0:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
   234b4:	e0bffc17 	ldw	r2,-16(fp)
   234b8:	10800104 	addi	r2,r2,4
   234bc:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
   234c0:	e0bffd17 	ldw	r2,-12(fp)
   234c4:	1080800c 	andi	r2,r2,512
   234c8:	103fbf26 	beq	r2,zero,233c8 <altera_avalon_jtag_uart_irq+0x28>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
   234cc:	e0bffd17 	ldw	r2,-12(fp)
   234d0:	1004d43a 	srli	r2,r2,16
   234d4:	e0bffa15 	stw	r2,-24(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
   234d8:	00001406 	br	2352c <altera_avalon_jtag_uart_irq+0x18c>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
   234dc:	e0bffc17 	ldw	r2,-16(fp)
   234e0:	e0fffb17 	ldw	r3,-20(fp)
   234e4:	18c00d17 	ldw	r3,52(r3)
   234e8:	e13ffb17 	ldw	r4,-20(fp)
   234ec:	20c7883a 	add	r3,r4,r3
   234f0:	18c20e04 	addi	r3,r3,2104
   234f4:	18c00003 	ldbu	r3,0(r3)
   234f8:	18c03fcc 	andi	r3,r3,255
   234fc:	18c0201c 	xori	r3,r3,128
   23500:	18ffe004 	addi	r3,r3,-128
   23504:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   23508:	e0bffb17 	ldw	r2,-20(fp)
   2350c:	10800d17 	ldw	r2,52(r2)
   23510:	10800044 	addi	r2,r2,1
   23514:	10c1ffcc 	andi	r3,r2,2047
   23518:	e0bffb17 	ldw	r2,-20(fp)
   2351c:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
   23520:	e0bffa17 	ldw	r2,-24(fp)
   23524:	10bfffc4 	addi	r2,r2,-1
   23528:	e0bffa15 	stw	r2,-24(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
   2352c:	e0bffa17 	ldw	r2,-24(fp)
   23530:	10000526 	beq	r2,zero,23548 <altera_avalon_jtag_uart_irq+0x1a8>
   23534:	e0bffb17 	ldw	r2,-20(fp)
   23538:	10c00d17 	ldw	r3,52(r2)
   2353c:	e0bffb17 	ldw	r2,-20(fp)
   23540:	10800c17 	ldw	r2,48(r2)
   23544:	18bfe51e 	bne	r3,r2,234dc <altera_avalon_jtag_uart_irq+0x13c>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
   23548:	e0bffa17 	ldw	r2,-24(fp)
   2354c:	103f9e26 	beq	r2,zero,233c8 <altera_avalon_jtag_uart_irq+0x28>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
   23550:	e0bffb17 	ldw	r2,-20(fp)
   23554:	10c00817 	ldw	r3,32(r2)
   23558:	00bfff44 	movi	r2,-3
   2355c:	1886703a 	and	r3,r3,r2
   23560:	e0bffb17 	ldw	r2,-20(fp)
   23564:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
   23568:	e0bffb17 	ldw	r2,-20(fp)
   2356c:	10800017 	ldw	r2,0(r2)
   23570:	10800104 	addi	r2,r2,4
   23574:	e0fffb17 	ldw	r3,-20(fp)
   23578:	18c00817 	ldw	r3,32(r3)
   2357c:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
   23580:	e0bffc17 	ldw	r2,-16(fp)
   23584:	10800104 	addi	r2,r2,4
   23588:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
   2358c:	003f8e06 	br	233c8 <altera_avalon_jtag_uart_irq+0x28>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
   23590:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
   23594:	e037883a 	mov	sp,fp
   23598:	df000017 	ldw	fp,0(sp)
   2359c:	dec00104 	addi	sp,sp,4
   235a0:	f800283a 	ret

000235a4 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
   235a4:	defffc04 	addi	sp,sp,-16
   235a8:	df000315 	stw	fp,12(sp)
   235ac:	df000304 	addi	fp,sp,12
   235b0:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
   235b4:	e0bfff17 	ldw	r2,-4(fp)
   235b8:	e0bffd15 	stw	r2,-12(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
   235bc:	e0bffd17 	ldw	r2,-12(fp)
   235c0:	10800017 	ldw	r2,0(r2)
   235c4:	10800104 	addi	r2,r2,4
   235c8:	10800037 	ldwio	r2,0(r2)
   235cc:	e0bffe15 	stw	r2,-8(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
   235d0:	e0bffe17 	ldw	r2,-8(fp)
   235d4:	1081000c 	andi	r2,r2,1024
   235d8:	10000a26 	beq	r2,zero,23604 <altera_avalon_jtag_uart_timeout+0x60>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
   235dc:	e0bffd17 	ldw	r2,-12(fp)
   235e0:	10800017 	ldw	r2,0(r2)
   235e4:	10800104 	addi	r2,r2,4
   235e8:	e0fffd17 	ldw	r3,-12(fp)
   235ec:	18c00817 	ldw	r3,32(r3)
   235f0:	18c10014 	ori	r3,r3,1024
   235f4:	10c00035 	stwio	r3,0(r2)
    sp->host_inactive = 0;
   235f8:	e0bffd17 	ldw	r2,-12(fp)
   235fc:	10000915 	stw	zero,36(r2)
   23600:	00000a06 	br	2362c <altera_avalon_jtag_uart_timeout+0x88>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
   23604:	e0bffd17 	ldw	r2,-12(fp)
   23608:	10800917 	ldw	r2,36(r2)
   2360c:	00e00034 	movhi	r3,32768
   23610:	18ffff04 	addi	r3,r3,-4
   23614:	18800536 	bltu	r3,r2,2362c <altera_avalon_jtag_uart_timeout+0x88>
    sp->host_inactive++;
   23618:	e0bffd17 	ldw	r2,-12(fp)
   2361c:	10800917 	ldw	r2,36(r2)
   23620:	10c00044 	addi	r3,r2,1
   23624:	e0bffd17 	ldw	r2,-12(fp)
   23628:	10c00915 	stw	r3,36(r2)
   2362c:	008000f4 	movhi	r2,3
   23630:	1099e104 	addi	r2,r2,26500
   23634:	10800017 	ldw	r2,0(r2)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
   23638:	e037883a 	mov	sp,fp
   2363c:	df000017 	ldw	fp,0(sp)
   23640:	dec00104 	addi	sp,sp,4
   23644:	f800283a 	ret

00023648 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
   23648:	defffd04 	addi	sp,sp,-12
   2364c:	df000215 	stw	fp,8(sp)
   23650:	df000204 	addi	fp,sp,8
   23654:	e13ffe15 	stw	r4,-8(fp)
   23658:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
   2365c:	00000506 	br	23674 <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
   23660:	e0bfff17 	ldw	r2,-4(fp)
   23664:	1090000c 	andi	r2,r2,16384
   23668:	10000226 	beq	r2,zero,23674 <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
   2366c:	00bffd44 	movi	r2,-11
   23670:	00000b06 	br	236a0 <altera_avalon_jtag_uart_close+0x58>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
   23674:	e0bffe17 	ldw	r2,-8(fp)
   23678:	10c00d17 	ldw	r3,52(r2)
   2367c:	e0bffe17 	ldw	r2,-8(fp)
   23680:	10800c17 	ldw	r2,48(r2)
   23684:	18800526 	beq	r3,r2,2369c <altera_avalon_jtag_uart_close+0x54>
   23688:	e0bffe17 	ldw	r2,-8(fp)
   2368c:	10c00917 	ldw	r3,36(r2)
   23690:	e0bffe17 	ldw	r2,-8(fp)
   23694:	10800117 	ldw	r2,4(r2)
   23698:	18bff136 	bltu	r3,r2,23660 <altera_avalon_jtag_uart_close+0x18>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
   2369c:	0005883a 	mov	r2,zero
}
   236a0:	e037883a 	mov	sp,fp
   236a4:	df000017 	ldw	fp,0(sp)
   236a8:	dec00104 	addi	sp,sp,4
   236ac:	f800283a 	ret

000236b0 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
   236b0:	defffa04 	addi	sp,sp,-24
   236b4:	df000515 	stw	fp,20(sp)
   236b8:	df000504 	addi	fp,sp,20
   236bc:	e13ffd15 	stw	r4,-12(fp)
   236c0:	e17ffe15 	stw	r5,-8(fp)
   236c4:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
   236c8:	00bff9c4 	movi	r2,-25
   236cc:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
   236d0:	e0bffe17 	ldw	r2,-8(fp)
   236d4:	10da8060 	cmpeqi	r3,r2,27137
   236d8:	1800031e 	bne	r3,zero,236e8 <altera_avalon_jtag_uart_ioctl+0x38>
   236dc:	109a80a0 	cmpeqi	r2,r2,27138
   236e0:	1000181e 	bne	r2,zero,23744 <altera_avalon_jtag_uart_ioctl+0x94>
   236e4:	00002606 	br	23780 <altera_avalon_jtag_uart_ioctl+0xd0>
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
   236e8:	e0bffd17 	ldw	r2,-12(fp)
   236ec:	10c00117 	ldw	r3,4(r2)
   236f0:	00a00034 	movhi	r2,32768
   236f4:	10bfffc4 	addi	r2,r2,-1
   236f8:	18802226 	beq	r3,r2,23784 <altera_avalon_jtag_uart_ioctl+0xd4>
    {
      int timeout = *((int *)arg);
   236fc:	e0bfff17 	ldw	r2,-4(fp)
   23700:	10800017 	ldw	r2,0(r2)
   23704:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
   23708:	e0bffc17 	ldw	r2,-16(fp)
   2370c:	10800090 	cmplti	r2,r2,2
   23710:	1000061e 	bne	r2,zero,2372c <altera_avalon_jtag_uart_ioctl+0x7c>
   23714:	e0fffc17 	ldw	r3,-16(fp)
   23718:	00a00034 	movhi	r2,32768
   2371c:	10bfffc4 	addi	r2,r2,-1
   23720:	18800226 	beq	r3,r2,2372c <altera_avalon_jtag_uart_ioctl+0x7c>
   23724:	e0bffc17 	ldw	r2,-16(fp)
   23728:	00000206 	br	23734 <altera_avalon_jtag_uart_ioctl+0x84>
   2372c:	00a00034 	movhi	r2,32768
   23730:	10bfff84 	addi	r2,r2,-2
   23734:	e0fffd17 	ldw	r3,-12(fp)
   23738:	18800115 	stw	r2,4(r3)
      rc = 0;
   2373c:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
   23740:	00001006 	br	23784 <altera_avalon_jtag_uart_ioctl+0xd4>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
   23744:	e0bffd17 	ldw	r2,-12(fp)
   23748:	10c00117 	ldw	r3,4(r2)
   2374c:	00a00034 	movhi	r2,32768
   23750:	10bfffc4 	addi	r2,r2,-1
   23754:	18800d26 	beq	r3,r2,2378c <altera_avalon_jtag_uart_ioctl+0xdc>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
   23758:	e0bffd17 	ldw	r2,-12(fp)
   2375c:	10c00917 	ldw	r3,36(r2)
   23760:	e0bffd17 	ldw	r2,-12(fp)
   23764:	10800117 	ldw	r2,4(r2)
   23768:	1885803a 	cmpltu	r2,r3,r2
   2376c:	10c03fcc 	andi	r3,r2,255
   23770:	e0bfff17 	ldw	r2,-4(fp)
   23774:	10c00015 	stw	r3,0(r2)
      rc = 0;
   23778:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
   2377c:	00000306 	br	2378c <altera_avalon_jtag_uart_ioctl+0xdc>

  default:
    break;
   23780:	00000306 	br	23790 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
   23784:	0001883a 	nop
   23788:	00000106 	br	23790 <altera_avalon_jtag_uart_ioctl+0xe0>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
   2378c:	0001883a 	nop

  default:
    break;
  }

  return rc;
   23790:	e0bffb17 	ldw	r2,-20(fp)
}
   23794:	e037883a 	mov	sp,fp
   23798:	df000017 	ldw	fp,0(sp)
   2379c:	dec00104 	addi	sp,sp,4
   237a0:	f800283a 	ret

000237a4 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
   237a4:	defff204 	addi	sp,sp,-56
   237a8:	dfc00d15 	stw	ra,52(sp)
   237ac:	df000c15 	stw	fp,48(sp)
   237b0:	df000c04 	addi	fp,sp,48
   237b4:	e13ffc15 	stw	r4,-16(fp)
   237b8:	e17ffd15 	stw	r5,-12(fp)
   237bc:	e1bffe15 	stw	r6,-8(fp)
   237c0:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
   237c4:	e0bffd17 	ldw	r2,-12(fp)
   237c8:	e0bff415 	stw	r2,-48(fp)
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
   237cc:	00004706 	br	238ec <altera_avalon_jtag_uart_read+0x148>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
   237d0:	e0bffc17 	ldw	r2,-16(fp)
   237d4:	10800a17 	ldw	r2,40(r2)
   237d8:	e0bff615 	stw	r2,-40(fp)
      out = sp->rx_out;
   237dc:	e0bffc17 	ldw	r2,-16(fp)
   237e0:	10800b17 	ldw	r2,44(r2)
   237e4:	e0bff715 	stw	r2,-36(fp)

      if (in >= out)
   237e8:	e0fff617 	ldw	r3,-40(fp)
   237ec:	e0bff717 	ldw	r2,-36(fp)
   237f0:	18800536 	bltu	r3,r2,23808 <altera_avalon_jtag_uart_read+0x64>
        n = in - out;
   237f4:	e0fff617 	ldw	r3,-40(fp)
   237f8:	e0bff717 	ldw	r2,-36(fp)
   237fc:	1885c83a 	sub	r2,r3,r2
   23800:	e0bff515 	stw	r2,-44(fp)
   23804:	00000406 	br	23818 <altera_avalon_jtag_uart_read+0x74>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
   23808:	00c20004 	movi	r3,2048
   2380c:	e0bff717 	ldw	r2,-36(fp)
   23810:	1885c83a 	sub	r2,r3,r2
   23814:	e0bff515 	stw	r2,-44(fp)

      if (n == 0)
   23818:	e0bff517 	ldw	r2,-44(fp)
   2381c:	10001e26 	beq	r2,zero,23898 <altera_avalon_jtag_uart_read+0xf4>
        break; /* No more data available */

      if (n > space)
   23820:	e0fffe17 	ldw	r3,-8(fp)
   23824:	e0bff517 	ldw	r2,-44(fp)
   23828:	1880022e 	bgeu	r3,r2,23834 <altera_avalon_jtag_uart_read+0x90>
        n = space;
   2382c:	e0bffe17 	ldw	r2,-8(fp)
   23830:	e0bff515 	stw	r2,-44(fp)

      memcpy(ptr, sp->rx_buf + out, n);
   23834:	e0bff717 	ldw	r2,-36(fp)
   23838:	10800e04 	addi	r2,r2,56
   2383c:	e0fffc17 	ldw	r3,-16(fp)
   23840:	1885883a 	add	r2,r3,r2
   23844:	e13ff417 	ldw	r4,-48(fp)
   23848:	100b883a 	mov	r5,r2
   2384c:	e1bff517 	ldw	r6,-44(fp)
   23850:	0016e680 	call	16e68 <memcpy>
      ptr   += n;
   23854:	e0fff417 	ldw	r3,-48(fp)
   23858:	e0bff517 	ldw	r2,-44(fp)
   2385c:	1885883a 	add	r2,r3,r2
   23860:	e0bff415 	stw	r2,-48(fp)
      space -= n;
   23864:	e0fffe17 	ldw	r3,-8(fp)
   23868:	e0bff517 	ldw	r2,-44(fp)
   2386c:	1885c83a 	sub	r2,r3,r2
   23870:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   23874:	e0fff717 	ldw	r3,-36(fp)
   23878:	e0bff517 	ldw	r2,-44(fp)
   2387c:	1885883a 	add	r2,r3,r2
   23880:	10c1ffcc 	andi	r3,r2,2047
   23884:	e0bffc17 	ldw	r2,-16(fp)
   23888:	10c00b15 	stw	r3,44(r2)
    }
    while (space > 0);
   2388c:	e0bffe17 	ldw	r2,-8(fp)
   23890:	00bfcf16 	blt	zero,r2,237d0 <altera_avalon_jtag_uart_read+0x2c>
   23894:	00000106 	br	2389c <altera_avalon_jtag_uart_read+0xf8>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
   23898:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
   2389c:	e0fff417 	ldw	r3,-48(fp)
   238a0:	e0bffd17 	ldw	r2,-12(fp)
   238a4:	1880141e 	bne	r3,r2,238f8 <altera_avalon_jtag_uart_read+0x154>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
   238a8:	e0bfff17 	ldw	r2,-4(fp)
   238ac:	1090000c 	andi	r2,r2,16384
   238b0:	1000131e 	bne	r2,zero,23900 <altera_avalon_jtag_uart_read+0x15c>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
   238b4:	0001883a 	nop
   238b8:	e0bffc17 	ldw	r2,-16(fp)
   238bc:	10c00a17 	ldw	r3,40(r2)
   238c0:	e0bff617 	ldw	r2,-40(fp)
   238c4:	1880051e 	bne	r3,r2,238dc <altera_avalon_jtag_uart_read+0x138>
   238c8:	e0bffc17 	ldw	r2,-16(fp)
   238cc:	10c00917 	ldw	r3,36(r2)
   238d0:	e0bffc17 	ldw	r2,-16(fp)
   238d4:	10800117 	ldw	r2,4(r2)
   238d8:	18bff736 	bltu	r3,r2,238b8 <altera_avalon_jtag_uart_read+0x114>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
   238dc:	e0bffc17 	ldw	r2,-16(fp)
   238e0:	10c00a17 	ldw	r3,40(r2)
   238e4:	e0bff617 	ldw	r2,-40(fp)
   238e8:	18800726 	beq	r3,r2,23908 <altera_avalon_jtag_uart_read+0x164>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
   238ec:	e0bffe17 	ldw	r2,-8(fp)
   238f0:	00bfb716 	blt	zero,r2,237d0 <altera_avalon_jtag_uart_read+0x2c>
   238f4:	00000506 	br	2390c <altera_avalon_jtag_uart_read+0x168>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
   238f8:	0001883a 	nop
   238fc:	00000306 	br	2390c <altera_avalon_jtag_uart_read+0x168>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
   23900:	0001883a 	nop
   23904:	00000106 	br	2390c <altera_avalon_jtag_uart_read+0x168>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
   23908:	0001883a 	nop
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);

  if (ptr != buffer)
   2390c:	e0fff417 	ldw	r3,-48(fp)
   23910:	e0bffd17 	ldw	r2,-12(fp)
   23914:	18802226 	beq	r3,r2,239a0 <altera_avalon_jtag_uart_read+0x1fc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   23918:	0005303a 	rdctl	r2,status
   2391c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   23920:	e0fff917 	ldw	r3,-28(fp)
   23924:	00bfff84 	movi	r2,-2
   23928:	1884703a 	and	r2,r3,r2
   2392c:	1001703a 	wrctl	status,r2
  
  return context;
   23930:	e0bff917 	ldw	r2,-28(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
   23934:	e0bff815 	stw	r2,-32(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
   23938:	e0bffc17 	ldw	r2,-16(fp)
   2393c:	10800817 	ldw	r2,32(r2)
   23940:	10c00054 	ori	r3,r2,1
   23944:	e0bffc17 	ldw	r2,-16(fp)
   23948:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
   2394c:	e0bffc17 	ldw	r2,-16(fp)
   23950:	10800017 	ldw	r2,0(r2)
   23954:	10800104 	addi	r2,r2,4
   23958:	e0fffc17 	ldw	r3,-16(fp)
   2395c:	18c00817 	ldw	r3,32(r3)
   23960:	10c00035 	stwio	r3,0(r2)
   23964:	e0bff817 	ldw	r2,-32(fp)
   23968:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   2396c:	0005303a 	rdctl	r2,status
   23970:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   23974:	e0fffb17 	ldw	r3,-20(fp)
   23978:	00bfff84 	movi	r2,-2
   2397c:	1884703a 	and	r2,r3,r2
   23980:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   23984:	e0bffa17 	ldw	r2,-24(fp)
   23988:	1080004c 	andi	r2,r2,1
   2398c:	e0fffb17 	ldw	r3,-20(fp)
   23990:	1884b03a 	or	r2,r3,r2
   23994:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
   23998:	e0bffb17 	ldw	r2,-20(fp)
   2399c:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
   239a0:	e0fff417 	ldw	r3,-48(fp)
   239a4:	e0bffd17 	ldw	r2,-12(fp)
   239a8:	18800426 	beq	r3,r2,239bc <altera_avalon_jtag_uart_read+0x218>
    return ptr - buffer;
   239ac:	e0fff417 	ldw	r3,-48(fp)
   239b0:	e0bffd17 	ldw	r2,-12(fp)
   239b4:	1885c83a 	sub	r2,r3,r2
   239b8:	00000606 	br	239d4 <altera_avalon_jtag_uart_read+0x230>
  else if (flags & O_NONBLOCK)
   239bc:	e0bfff17 	ldw	r2,-4(fp)
   239c0:	1090000c 	andi	r2,r2,16384
   239c4:	10000226 	beq	r2,zero,239d0 <altera_avalon_jtag_uart_read+0x22c>
    return -EWOULDBLOCK;
   239c8:	00bffd44 	movi	r2,-11
   239cc:	00000106 	br	239d4 <altera_avalon_jtag_uart_read+0x230>
  else
    return -EIO;
   239d0:	00bffec4 	movi	r2,-5
}
   239d4:	e037883a 	mov	sp,fp
   239d8:	dfc00117 	ldw	ra,4(sp)
   239dc:	df000017 	ldw	fp,0(sp)
   239e0:	dec00204 	addi	sp,sp,8
   239e4:	f800283a 	ret

000239e8 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
   239e8:	defff204 	addi	sp,sp,-56
   239ec:	dfc00d15 	stw	ra,52(sp)
   239f0:	df000c15 	stw	fp,48(sp)
   239f4:	df000c04 	addi	fp,sp,48
   239f8:	e13ffc15 	stw	r4,-16(fp)
   239fc:	e17ffd15 	stw	r5,-12(fp)
   23a00:	e1bffe15 	stw	r6,-8(fp)
   23a04:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
   23a08:	e03ff415 	stw	zero,-48(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
   23a0c:	e0bffd17 	ldw	r2,-12(fp)
   23a10:	e0bff615 	stw	r2,-40(fp)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
   23a14:	00003706 	br	23af4 <altera_avalon_jtag_uart_write+0x10c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
   23a18:	e0bffc17 	ldw	r2,-16(fp)
   23a1c:	10800c17 	ldw	r2,48(r2)
   23a20:	e0bff715 	stw	r2,-36(fp)
      out = sp->tx_out;
   23a24:	e0bffc17 	ldw	r2,-16(fp)
   23a28:	10800d17 	ldw	r2,52(r2)
   23a2c:	e0bff415 	stw	r2,-48(fp)

      if (in < out)
   23a30:	e0fff717 	ldw	r3,-36(fp)
   23a34:	e0bff417 	ldw	r2,-48(fp)
   23a38:	1880062e 	bgeu	r3,r2,23a54 <altera_avalon_jtag_uart_write+0x6c>
        n = out - 1 - in;
   23a3c:	e0fff417 	ldw	r3,-48(fp)
   23a40:	e0bff717 	ldw	r2,-36(fp)
   23a44:	1885c83a 	sub	r2,r3,r2
   23a48:	10bfffc4 	addi	r2,r2,-1
   23a4c:	e0bff515 	stw	r2,-44(fp)
   23a50:	00000b06 	br	23a80 <altera_avalon_jtag_uart_write+0x98>
      else if (out > 0)
   23a54:	e0bff417 	ldw	r2,-48(fp)
   23a58:	10000526 	beq	r2,zero,23a70 <altera_avalon_jtag_uart_write+0x88>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
   23a5c:	00c20004 	movi	r3,2048
   23a60:	e0bff717 	ldw	r2,-36(fp)
   23a64:	1885c83a 	sub	r2,r3,r2
   23a68:	e0bff515 	stw	r2,-44(fp)
   23a6c:	00000406 	br	23a80 <altera_avalon_jtag_uart_write+0x98>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
   23a70:	00c1ffc4 	movi	r3,2047
   23a74:	e0bff717 	ldw	r2,-36(fp)
   23a78:	1885c83a 	sub	r2,r3,r2
   23a7c:	e0bff515 	stw	r2,-44(fp)

      if (n == 0)
   23a80:	e0bff517 	ldw	r2,-44(fp)
   23a84:	10001e26 	beq	r2,zero,23b00 <altera_avalon_jtag_uart_write+0x118>
        break;

      if (n > count)
   23a88:	e0fffe17 	ldw	r3,-8(fp)
   23a8c:	e0bff517 	ldw	r2,-44(fp)
   23a90:	1880022e 	bgeu	r3,r2,23a9c <altera_avalon_jtag_uart_write+0xb4>
        n = count;
   23a94:	e0bffe17 	ldw	r2,-8(fp)
   23a98:	e0bff515 	stw	r2,-44(fp)

      memcpy(sp->tx_buf + in, ptr, n);
   23a9c:	e0bff717 	ldw	r2,-36(fp)
   23aa0:	10820e04 	addi	r2,r2,2104
   23aa4:	e0fffc17 	ldw	r3,-16(fp)
   23aa8:	1885883a 	add	r2,r3,r2
   23aac:	1009883a 	mov	r4,r2
   23ab0:	e17ffd17 	ldw	r5,-12(fp)
   23ab4:	e1bff517 	ldw	r6,-44(fp)
   23ab8:	0016e680 	call	16e68 <memcpy>
      ptr   += n;
   23abc:	e0fffd17 	ldw	r3,-12(fp)
   23ac0:	e0bff517 	ldw	r2,-44(fp)
   23ac4:	1885883a 	add	r2,r3,r2
   23ac8:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
   23acc:	e0fffe17 	ldw	r3,-8(fp)
   23ad0:	e0bff517 	ldw	r2,-44(fp)
   23ad4:	1885c83a 	sub	r2,r3,r2
   23ad8:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   23adc:	e0fff717 	ldw	r3,-36(fp)
   23ae0:	e0bff517 	ldw	r2,-44(fp)
   23ae4:	1885883a 	add	r2,r3,r2
   23ae8:	10c1ffcc 	andi	r3,r2,2047
   23aec:	e0bffc17 	ldw	r2,-16(fp)
   23af0:	10c00c15 	stw	r3,48(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
   23af4:	e0bffe17 	ldw	r2,-8(fp)
   23af8:	00bfc716 	blt	zero,r2,23a18 <altera_avalon_jtag_uart_write+0x30>
   23afc:	00000106 	br	23b04 <altera_avalon_jtag_uart_write+0x11c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
   23b00:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   23b04:	0005303a 	rdctl	r2,status
   23b08:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   23b0c:	e0fff917 	ldw	r3,-28(fp)
   23b10:	00bfff84 	movi	r2,-2
   23b14:	1884703a 	and	r2,r3,r2
   23b18:	1001703a 	wrctl	status,r2
  
  return context;
   23b1c:	e0bff917 	ldw	r2,-28(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
   23b20:	e0bff815 	stw	r2,-32(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
   23b24:	e0bffc17 	ldw	r2,-16(fp)
   23b28:	10800817 	ldw	r2,32(r2)
   23b2c:	10c00094 	ori	r3,r2,2
   23b30:	e0bffc17 	ldw	r2,-16(fp)
   23b34:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
   23b38:	e0bffc17 	ldw	r2,-16(fp)
   23b3c:	10800017 	ldw	r2,0(r2)
   23b40:	10800104 	addi	r2,r2,4
   23b44:	e0fffc17 	ldw	r3,-16(fp)
   23b48:	18c00817 	ldw	r3,32(r3)
   23b4c:	10c00035 	stwio	r3,0(r2)
   23b50:	e0bff817 	ldw	r2,-32(fp)
   23b54:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   23b58:	0005303a 	rdctl	r2,status
   23b5c:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   23b60:	e0fffb17 	ldw	r3,-20(fp)
   23b64:	00bfff84 	movi	r2,-2
   23b68:	1884703a 	and	r2,r3,r2
   23b6c:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   23b70:	e0bffa17 	ldw	r2,-24(fp)
   23b74:	1080004c 	andi	r2,r2,1
   23b78:	e0fffb17 	ldw	r3,-20(fp)
   23b7c:	1884b03a 	or	r2,r3,r2
   23b80:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
   23b84:	e0bffb17 	ldw	r2,-20(fp)
   23b88:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
   23b8c:	e0bffe17 	ldw	r2,-8(fp)
   23b90:	0080110e 	bge	zero,r2,23bd8 <altera_avalon_jtag_uart_write+0x1f0>
    {
      if (flags & O_NONBLOCK)
   23b94:	e0bfff17 	ldw	r2,-4(fp)
   23b98:	1090000c 	andi	r2,r2,16384
   23b9c:	1000111e 	bne	r2,zero,23be4 <altera_avalon_jtag_uart_write+0x1fc>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
   23ba0:	0001883a 	nop
   23ba4:	e0bffc17 	ldw	r2,-16(fp)
   23ba8:	10c00d17 	ldw	r3,52(r2)
   23bac:	e0bff417 	ldw	r2,-48(fp)
   23bb0:	1880051e 	bne	r3,r2,23bc8 <altera_avalon_jtag_uart_write+0x1e0>
   23bb4:	e0bffc17 	ldw	r2,-16(fp)
   23bb8:	10c00917 	ldw	r3,36(r2)
   23bbc:	e0bffc17 	ldw	r2,-16(fp)
   23bc0:	10800117 	ldw	r2,4(r2)
   23bc4:	18bff736 	bltu	r3,r2,23ba4 <altera_avalon_jtag_uart_write+0x1bc>
        ;
#endif /* __ucosii__ */

      if (out == sp->tx_out)
   23bc8:	e0bffc17 	ldw	r2,-16(fp)
   23bcc:	10c00d17 	ldw	r3,52(r2)
   23bd0:	e0bff417 	ldw	r2,-48(fp)
   23bd4:	18800526 	beq	r3,r2,23bec <altera_avalon_jtag_uart_write+0x204>
         break;
    }
  }
  while (count > 0);
   23bd8:	e0bffe17 	ldw	r2,-8(fp)
   23bdc:	00bfc516 	blt	zero,r2,23af4 <altera_avalon_jtag_uart_write+0x10c>
   23be0:	00000306 	br	23bf0 <altera_avalon_jtag_uart_write+0x208>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
   23be4:	0001883a 	nop
   23be8:	00000106 	br	23bf0 <altera_avalon_jtag_uart_write+0x208>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if (out == sp->tx_out)
         break;
   23bec:	0001883a 	nop
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
   23bf0:	e0fffd17 	ldw	r3,-12(fp)
   23bf4:	e0bff617 	ldw	r2,-40(fp)
   23bf8:	18800426 	beq	r3,r2,23c0c <altera_avalon_jtag_uart_write+0x224>
    return ptr - start;
   23bfc:	e0fffd17 	ldw	r3,-12(fp)
   23c00:	e0bff617 	ldw	r2,-40(fp)
   23c04:	1885c83a 	sub	r2,r3,r2
   23c08:	00000606 	br	23c24 <altera_avalon_jtag_uart_write+0x23c>
  else if (flags & O_NONBLOCK)
   23c0c:	e0bfff17 	ldw	r2,-4(fp)
   23c10:	1090000c 	andi	r2,r2,16384
   23c14:	10000226 	beq	r2,zero,23c20 <altera_avalon_jtag_uart_write+0x238>
    return -EWOULDBLOCK;
   23c18:	00bffd44 	movi	r2,-11
   23c1c:	00000106 	br	23c24 <altera_avalon_jtag_uart_write+0x23c>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
   23c20:	00bffec4 	movi	r2,-5
}
   23c24:	e037883a 	mov	sp,fp
   23c28:	dfc00117 	ldw	ra,4(sp)
   23c2c:	df000017 	ldw	fp,0(sp)
   23c30:	dec00204 	addi	sp,sp,8
   23c34:	f800283a 	ret

00023c38 <lcd_write_command>:

/* --------------------------------------------------------------------- */

static void lcd_write_command(altera_avalon_lcd_16207_state* sp, 
  unsigned char command)
{
   23c38:	defffa04 	addi	sp,sp,-24
   23c3c:	dfc00515 	stw	ra,20(sp)
   23c40:	df000415 	stw	fp,16(sp)
   23c44:	df000404 	addi	fp,sp,16
   23c48:	e13ffe15 	stw	r4,-8(fp)
   23c4c:	2805883a 	mov	r2,r5
   23c50:	e0bfff05 	stb	r2,-4(fp)
  unsigned int base = sp->base;
   23c54:	e0bffe17 	ldw	r2,-8(fp)
   23c58:	10800017 	ldw	r2,0(r2)
   23c5c:	e0bffd15 	stw	r2,-12(fp)
  /* We impose a timeout on the driver in case the LCD panel isn't connected.
   * The first time we call this function the timeout is approx 25ms 
   * (assuming 5 cycles per loop and a 200MHz clock).  Obviously systems
   * with slower clocks, or debug builds, or slower memory will take longer.
   */
  int i = 1000000;
   23c60:	008003f4 	movhi	r2,15
   23c64:	10909004 	addi	r2,r2,16960
   23c68:	e0bffc15 	stw	r2,-16(fp)

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
   23c6c:	e0bffe17 	ldw	r2,-8(fp)
   23c70:	10800803 	ldbu	r2,32(r2)
   23c74:	10803fcc 	andi	r2,r2,255
   23c78:	1080201c 	xori	r2,r2,128
   23c7c:	10bfe004 	addi	r2,r2,-128
   23c80:	10000a26 	beq	r2,zero,23cac <lcd_write_command+0x74>
    return;
   23c84:	00001406 	br	23cd8 <lcd_write_command+0xa0>

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
    if (--i == 0)
   23c88:	e0bffc17 	ldw	r2,-16(fp)
   23c8c:	10bfffc4 	addi	r2,r2,-1
   23c90:	e0bffc15 	stw	r2,-16(fp)
   23c94:	e0bffc17 	ldw	r2,-16(fp)
   23c98:	1000051e 	bne	r2,zero,23cb0 <lcd_write_command+0x78>
    {
      sp->broken = 1;
   23c9c:	e0bffe17 	ldw	r2,-8(fp)
   23ca0:	00c00044 	movi	r3,1
   23ca4:	10c00805 	stb	r3,32(r2)
      return;
   23ca8:	00000b06 	br	23cd8 <lcd_write_command+0xa0>
  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
   23cac:	0001883a 	nop
   23cb0:	e0bffd17 	ldw	r2,-12(fp)
   23cb4:	10800104 	addi	r2,r2,4
   23cb8:	10800037 	ldwio	r2,0(r2)
   23cbc:	1080200c 	andi	r2,r2,128
   23cc0:	103ff11e 	bne	r2,zero,23c88 <lcd_write_command+0x50>
    }

  /* Despite what it says in the datasheet, the LCD isn't ready to accept
   * a write immediately after it returns BUSY=0.  Wait for 100us more.
   */
  usleep(100);
   23cc4:	01001904 	movi	r4,100
   23cc8:	00211c40 	call	211c4 <usleep>

  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, command);
   23ccc:	e0bffd17 	ldw	r2,-12(fp)
   23cd0:	e0ffff03 	ldbu	r3,-4(fp)
   23cd4:	10c00035 	stwio	r3,0(r2)
}
   23cd8:	e037883a 	mov	sp,fp
   23cdc:	dfc00117 	ldw	ra,4(sp)
   23ce0:	df000017 	ldw	fp,0(sp)
   23ce4:	dec00204 	addi	sp,sp,8
   23ce8:	f800283a 	ret

00023cec <lcd_write_data>:

/* --------------------------------------------------------------------- */

static void lcd_write_data(altera_avalon_lcd_16207_state* sp, 
  unsigned char data)
{
   23cec:	defffa04 	addi	sp,sp,-24
   23cf0:	dfc00515 	stw	ra,20(sp)
   23cf4:	df000415 	stw	fp,16(sp)
   23cf8:	df000404 	addi	fp,sp,16
   23cfc:	e13ffe15 	stw	r4,-8(fp)
   23d00:	2805883a 	mov	r2,r5
   23d04:	e0bfff05 	stb	r2,-4(fp)
  unsigned int base = sp->base;
   23d08:	e0bffe17 	ldw	r2,-8(fp)
   23d0c:	10800017 	ldw	r2,0(r2)
   23d10:	e0bffd15 	stw	r2,-12(fp)
  /* We impose a timeout on the driver in case the LCD panel isn't connected.
   * The first time we call this function the timeout is approx 25ms 
   * (assuming 5 cycles per loop and a 200MHz clock).  Obviously systems
   * with slower clocks, or debug builds, or slower memory will take longer.
   */
  int i = 1000000;
   23d14:	008003f4 	movhi	r2,15
   23d18:	10909004 	addi	r2,r2,16960
   23d1c:	e0bffc15 	stw	r2,-16(fp)

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
   23d20:	e0bffe17 	ldw	r2,-8(fp)
   23d24:	10800803 	ldbu	r2,32(r2)
   23d28:	10803fcc 	andi	r2,r2,255
   23d2c:	1080201c 	xori	r2,r2,128
   23d30:	10bfe004 	addi	r2,r2,-128
   23d34:	10000a26 	beq	r2,zero,23d60 <lcd_write_data+0x74>
    return;
   23d38:	00001b06 	br	23da8 <lcd_write_data+0xbc>

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
    if (--i == 0)
   23d3c:	e0bffc17 	ldw	r2,-16(fp)
   23d40:	10bfffc4 	addi	r2,r2,-1
   23d44:	e0bffc15 	stw	r2,-16(fp)
   23d48:	e0bffc17 	ldw	r2,-16(fp)
   23d4c:	1000051e 	bne	r2,zero,23d64 <lcd_write_data+0x78>
    {
      sp->broken = 1;
   23d50:	e0bffe17 	ldw	r2,-8(fp)
   23d54:	00c00044 	movi	r3,1
   23d58:	10c00805 	stb	r3,32(r2)
      return;
   23d5c:	00001206 	br	23da8 <lcd_write_data+0xbc>
  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
   23d60:	0001883a 	nop
   23d64:	e0bffd17 	ldw	r2,-12(fp)
   23d68:	10800104 	addi	r2,r2,4
   23d6c:	10800037 	ldwio	r2,0(r2)
   23d70:	1080200c 	andi	r2,r2,128
   23d74:	103ff11e 	bne	r2,zero,23d3c <lcd_write_data+0x50>
    }

  /* Despite what it says in the datasheet, the LCD isn't ready to accept
   * a write immediately after it returns BUSY=0.  Wait for 100us more.
   */
  usleep(100);
   23d78:	01001904 	movi	r4,100
   23d7c:	00211c40 	call	211c4 <usleep>

  IOWR_ALTERA_AVALON_LCD_16207_DATA(base, data);
   23d80:	e0bffd17 	ldw	r2,-12(fp)
   23d84:	10800204 	addi	r2,r2,8
   23d88:	e0ffff03 	ldbu	r3,-4(fp)
   23d8c:	10c00035 	stwio	r3,0(r2)

  sp->address++;
   23d90:	e0bffe17 	ldw	r2,-8(fp)
   23d94:	108008c3 	ldbu	r2,35(r2)
   23d98:	10800044 	addi	r2,r2,1
   23d9c:	1007883a 	mov	r3,r2
   23da0:	e0bffe17 	ldw	r2,-8(fp)
   23da4:	10c008c5 	stb	r3,35(r2)
}
   23da8:	e037883a 	mov	sp,fp
   23dac:	dfc00117 	ldw	ra,4(sp)
   23db0:	df000017 	ldw	fp,0(sp)
   23db4:	dec00204 	addi	sp,sp,8
   23db8:	f800283a 	ret

00023dbc <lcd_clear_screen>:

/* --------------------------------------------------------------------- */

static void lcd_clear_screen(altera_avalon_lcd_16207_state* sp)
{
   23dbc:	defffc04 	addi	sp,sp,-16
   23dc0:	dfc00315 	stw	ra,12(sp)
   23dc4:	df000215 	stw	fp,8(sp)
   23dc8:	df000204 	addi	fp,sp,8
   23dcc:	e13fff15 	stw	r4,-4(fp)
  int y;

  lcd_write_command(sp, LCD_CMD_CLEAR);
   23dd0:	e13fff17 	ldw	r4,-4(fp)
   23dd4:	01400044 	movi	r5,1
   23dd8:	0023c380 	call	23c38 <lcd_write_command>

  sp->x = 0;
   23ddc:	e0bfff17 	ldw	r2,-4(fp)
   23de0:	10000845 	stb	zero,33(r2)
  sp->y = 0;
   23de4:	e0bfff17 	ldw	r2,-4(fp)
   23de8:	10000885 	stb	zero,34(r2)
  sp->address = 0;
   23dec:	e0bfff17 	ldw	r2,-4(fp)
   23df0:	100008c5 	stb	zero,35(r2)

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   23df4:	e03ffe15 	stw	zero,-8(fp)
   23df8:	00001b06 	br	23e68 <lcd_clear_screen+0xac>
  {
    memset(sp->line[y].data, ' ', sizeof(sp->line[0].data));
   23dfc:	e0bffe17 	ldw	r2,-8(fp)
   23e00:	108018e4 	muli	r2,r2,99
   23e04:	10801004 	addi	r2,r2,64
   23e08:	e0ffff17 	ldw	r3,-4(fp)
   23e0c:	1885883a 	add	r2,r3,r2
   23e10:	1009883a 	mov	r4,r2
   23e14:	01400804 	movi	r5,32
   23e18:	01801444 	movi	r6,81
   23e1c:	0016f600 	call	16f60 <memset>
    memset(sp->line[y].visible, ' ', sizeof(sp->line[0].visible));
   23e20:	e0bffe17 	ldw	r2,-8(fp)
   23e24:	108018e4 	muli	r2,r2,99
   23e28:	10800c04 	addi	r2,r2,48
   23e2c:	e0ffff17 	ldw	r3,-4(fp)
   23e30:	1885883a 	add	r2,r3,r2
   23e34:	1009883a 	mov	r4,r2
   23e38:	01400804 	movi	r5,32
   23e3c:	01800404 	movi	r6,16
   23e40:	0016f600 	call	16f60 <memset>
    sp->line[y].width = 0;
   23e44:	e0ffff17 	ldw	r3,-4(fp)
   23e48:	e0bffe17 	ldw	r2,-8(fp)
   23e4c:	108018e4 	muli	r2,r2,99
   23e50:	1885883a 	add	r2,r3,r2
   23e54:	10802404 	addi	r2,r2,144
   23e58:	10000045 	stb	zero,1(r2)

  sp->x = 0;
  sp->y = 0;
  sp->address = 0;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   23e5c:	e0bffe17 	ldw	r2,-8(fp)
   23e60:	10800044 	addi	r2,r2,1
   23e64:	e0bffe15 	stw	r2,-8(fp)
   23e68:	e0bffe17 	ldw	r2,-8(fp)
   23e6c:	10800090 	cmplti	r2,r2,2
   23e70:	103fe21e 	bne	r2,zero,23dfc <lcd_clear_screen+0x40>
  {
    memset(sp->line[y].data, ' ', sizeof(sp->line[0].data));
    memset(sp->line[y].visible, ' ', sizeof(sp->line[0].visible));
    sp->line[y].width = 0;
  }
}
   23e74:	e037883a 	mov	sp,fp
   23e78:	dfc00117 	ldw	ra,4(sp)
   23e7c:	df000017 	ldw	fp,0(sp)
   23e80:	dec00204 	addi	sp,sp,8
   23e84:	f800283a 	ret

00023e88 <lcd_repaint_screen>:

/* --------------------------------------------------------------------- */

static void lcd_repaint_screen(altera_avalon_lcd_16207_state* sp)
{
   23e88:	defff704 	addi	sp,sp,-36
   23e8c:	dfc00815 	stw	ra,32(sp)
   23e90:	df000715 	stw	fp,28(sp)
   23e94:	df000704 	addi	fp,sp,28
   23e98:	e13fff15 	stw	r4,-4(fp)
  /* scrollpos controls how much the lines have scrolled round.  The speed
   * each line scrolls at is controlled by its speed variable - while
   * scrolline lines will wrap at the position set by width
   */

  int scrollpos = sp->scrollpos;
   23e9c:	e0bfff17 	ldw	r2,-4(fp)
   23ea0:	10800943 	ldbu	r2,37(r2)
   23ea4:	10803fcc 	andi	r2,r2,255
   23ea8:	e0bffc15 	stw	r2,-16(fp)

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   23eac:	e03ff915 	stw	zero,-28(fp)
   23eb0:	00006806 	br	24054 <lcd_repaint_screen+0x1cc>
  {
    int width  = sp->line[y].width;
   23eb4:	e0ffff17 	ldw	r3,-4(fp)
   23eb8:	e0bff917 	ldw	r2,-28(fp)
   23ebc:	108018e4 	muli	r2,r2,99
   23ec0:	1885883a 	add	r2,r3,r2
   23ec4:	10802404 	addi	r2,r2,144
   23ec8:	10800043 	ldbu	r2,1(r2)
   23ecc:	10803fcc 	andi	r2,r2,255
   23ed0:	1080201c 	xori	r2,r2,128
   23ed4:	10bfe004 	addi	r2,r2,-128
   23ed8:	e0bffd15 	stw	r2,-12(fp)
    int offset = (scrollpos * sp->line[y].speed) >> 8;
   23edc:	e0ffff17 	ldw	r3,-4(fp)
   23ee0:	e0bff917 	ldw	r2,-28(fp)
   23ee4:	108018e4 	muli	r2,r2,99
   23ee8:	1885883a 	add	r2,r3,r2
   23eec:	10802404 	addi	r2,r2,144
   23ef0:	10800083 	ldbu	r2,2(r2)
   23ef4:	10c03fcc 	andi	r3,r2,255
   23ef8:	e0bffc17 	ldw	r2,-16(fp)
   23efc:	1885383a 	mul	r2,r3,r2
   23f00:	1005d23a 	srai	r2,r2,8
   23f04:	e0bffb15 	stw	r2,-20(fp)
    if (offset >= width)
   23f08:	e0fffb17 	ldw	r3,-20(fp)
   23f0c:	e0bffd17 	ldw	r2,-12(fp)
   23f10:	18800116 	blt	r3,r2,23f18 <lcd_repaint_screen+0x90>
      offset = 0;
   23f14:	e03ffb15 	stw	zero,-20(fp)

    for (x = 0 ; x < ALT_LCD_WIDTH ; x++)
   23f18:	e03ffa15 	stw	zero,-24(fp)
   23f1c:	00004706 	br	2403c <lcd_repaint_screen+0x1b4>
    {
      char c = sp->line[y].data[(x + offset) % width];
   23f20:	e0fffa17 	ldw	r3,-24(fp)
   23f24:	e0bffb17 	ldw	r2,-20(fp)
   23f28:	1885883a 	add	r2,r3,r2
   23f2c:	e0fffd17 	ldw	r3,-12(fp)
   23f30:	10c9283a 	div	r4,r2,r3
   23f34:	e0fffd17 	ldw	r3,-12(fp)
   23f38:	20c7383a 	mul	r3,r4,r3
   23f3c:	10c5c83a 	sub	r2,r2,r3
   23f40:	e13fff17 	ldw	r4,-4(fp)
   23f44:	e0fff917 	ldw	r3,-28(fp)
   23f48:	18c018e4 	muli	r3,r3,99
   23f4c:	20c7883a 	add	r3,r4,r3
   23f50:	1885883a 	add	r2,r3,r2
   23f54:	10801004 	addi	r2,r2,64
   23f58:	10800003 	ldbu	r2,0(r2)
   23f5c:	e0bffe05 	stb	r2,-8(fp)

      /* Writing data takes 40us, so don't do it unless required */
      if (sp->line[y].visible[x] != c)
   23f60:	e0ffff17 	ldw	r3,-4(fp)
   23f64:	e0bff917 	ldw	r2,-28(fp)
   23f68:	108018e4 	muli	r2,r2,99
   23f6c:	1887883a 	add	r3,r3,r2
   23f70:	e0bffa17 	ldw	r2,-24(fp)
   23f74:	1885883a 	add	r2,r3,r2
   23f78:	10800c04 	addi	r2,r2,48
   23f7c:	10800003 	ldbu	r2,0(r2)
   23f80:	10c03fcc 	andi	r3,r2,255
   23f84:	18c0201c 	xori	r3,r3,128
   23f88:	18ffe004 	addi	r3,r3,-128
   23f8c:	e0bffe07 	ldb	r2,-8(fp)
   23f90:	18802726 	beq	r3,r2,24030 <lcd_repaint_screen+0x1a8>
      {
        unsigned char address = x + colstart[y];
   23f94:	e0fff917 	ldw	r3,-28(fp)
   23f98:	d0a01804 	addi	r2,gp,-32672
   23f9c:	1885883a 	add	r2,r3,r2
   23fa0:	10800003 	ldbu	r2,0(r2)
   23fa4:	1007883a 	mov	r3,r2
   23fa8:	e0bffa17 	ldw	r2,-24(fp)
   23fac:	1885883a 	add	r2,r3,r2
   23fb0:	e0bffe45 	stb	r2,-7(fp)

        if (address != sp->address)
   23fb4:	e0fffe43 	ldbu	r3,-7(fp)
   23fb8:	e0bfff17 	ldw	r2,-4(fp)
   23fbc:	108008c3 	ldbu	r2,35(r2)
   23fc0:	10803fcc 	andi	r2,r2,255
   23fc4:	1080201c 	xori	r2,r2,128
   23fc8:	10bfe004 	addi	r2,r2,-128
   23fcc:	18800a26 	beq	r3,r2,23ff8 <lcd_repaint_screen+0x170>
        {
          lcd_write_command(sp, LCD_CMD_WRITE_DATA | address);
   23fd0:	e0fffe43 	ldbu	r3,-7(fp)
   23fd4:	00bfe004 	movi	r2,-128
   23fd8:	1884b03a 	or	r2,r3,r2
   23fdc:	10803fcc 	andi	r2,r2,255
   23fe0:	e13fff17 	ldw	r4,-4(fp)
   23fe4:	100b883a 	mov	r5,r2
   23fe8:	0023c380 	call	23c38 <lcd_write_command>
          sp->address = address;
   23fec:	e0fffe43 	ldbu	r3,-7(fp)
   23ff0:	e0bfff17 	ldw	r2,-4(fp)
   23ff4:	10c008c5 	stb	r3,35(r2)
        }

        lcd_write_data(sp, c);
   23ff8:	e0bffe03 	ldbu	r2,-8(fp)
   23ffc:	10803fcc 	andi	r2,r2,255
   24000:	e13fff17 	ldw	r4,-4(fp)
   24004:	100b883a 	mov	r5,r2
   24008:	0023cec0 	call	23cec <lcd_write_data>
        sp->line[y].visible[x] = c;
   2400c:	e0ffff17 	ldw	r3,-4(fp)
   24010:	e0bff917 	ldw	r2,-28(fp)
   24014:	108018e4 	muli	r2,r2,99
   24018:	1887883a 	add	r3,r3,r2
   2401c:	e0bffa17 	ldw	r2,-24(fp)
   24020:	1885883a 	add	r2,r3,r2
   24024:	10800c04 	addi	r2,r2,48
   24028:	e0fffe03 	ldbu	r3,-8(fp)
   2402c:	10c00005 	stb	r3,0(r2)
    int width  = sp->line[y].width;
    int offset = (scrollpos * sp->line[y].speed) >> 8;
    if (offset >= width)
      offset = 0;

    for (x = 0 ; x < ALT_LCD_WIDTH ; x++)
   24030:	e0bffa17 	ldw	r2,-24(fp)
   24034:	10800044 	addi	r2,r2,1
   24038:	e0bffa15 	stw	r2,-24(fp)
   2403c:	e0bffa17 	ldw	r2,-24(fp)
   24040:	10800410 	cmplti	r2,r2,16
   24044:	103fb61e 	bne	r2,zero,23f20 <lcd_repaint_screen+0x98>
   * scrolline lines will wrap at the position set by width
   */

  int scrollpos = sp->scrollpos;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   24048:	e0bff917 	ldw	r2,-28(fp)
   2404c:	10800044 	addi	r2,r2,1
   24050:	e0bff915 	stw	r2,-28(fp)
   24054:	e0bff917 	ldw	r2,-28(fp)
   24058:	10800090 	cmplti	r2,r2,2
   2405c:	103f951e 	bne	r2,zero,23eb4 <lcd_repaint_screen+0x2c>
        lcd_write_data(sp, c);
        sp->line[y].visible[x] = c;
      }
    }
  }
}
   24060:	e037883a 	mov	sp,fp
   24064:	dfc00117 	ldw	ra,4(sp)
   24068:	df000017 	ldw	fp,0(sp)
   2406c:	dec00204 	addi	sp,sp,8
   24070:	f800283a 	ret

00024074 <lcd_scroll_up>:

/* --------------------------------------------------------------------- */

static void lcd_scroll_up(altera_avalon_lcd_16207_state* sp)
{
   24074:	defffc04 	addi	sp,sp,-16
   24078:	dfc00315 	stw	ra,12(sp)
   2407c:	df000215 	stw	fp,8(sp)
   24080:	df000204 	addi	fp,sp,8
   24084:	e13fff15 	stw	r4,-4(fp)
  int y;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   24088:	e03ffe15 	stw	zero,-8(fp)
   2408c:	00001e06 	br	24108 <lcd_scroll_up+0x94>
  {
    if (y < ALT_LCD_HEIGHT-1)
   24090:	e0bffe17 	ldw	r2,-8(fp)
   24094:	00801016 	blt	zero,r2,240d8 <lcd_scroll_up+0x64>
      memcpy(sp->line[y].data, sp->line[y+1].data, ALT_LCD_VIRTUAL_WIDTH);
   24098:	e0bffe17 	ldw	r2,-8(fp)
   2409c:	108018e4 	muli	r2,r2,99
   240a0:	10801004 	addi	r2,r2,64
   240a4:	e0ffff17 	ldw	r3,-4(fp)
   240a8:	1887883a 	add	r3,r3,r2
   240ac:	e0bffe17 	ldw	r2,-8(fp)
   240b0:	10800044 	addi	r2,r2,1
   240b4:	108018e4 	muli	r2,r2,99
   240b8:	10801004 	addi	r2,r2,64
   240bc:	e13fff17 	ldw	r4,-4(fp)
   240c0:	2085883a 	add	r2,r4,r2
   240c4:	1809883a 	mov	r4,r3
   240c8:	100b883a 	mov	r5,r2
   240cc:	01801404 	movi	r6,80
   240d0:	0016e680 	call	16e68 <memcpy>
   240d4:	00000906 	br	240fc <lcd_scroll_up+0x88>
    else
      memset(sp->line[y].data, ' ', ALT_LCD_VIRTUAL_WIDTH);
   240d8:	e0bffe17 	ldw	r2,-8(fp)
   240dc:	108018e4 	muli	r2,r2,99
   240e0:	10801004 	addi	r2,r2,64
   240e4:	e0ffff17 	ldw	r3,-4(fp)
   240e8:	1885883a 	add	r2,r3,r2
   240ec:	1009883a 	mov	r4,r2
   240f0:	01400804 	movi	r5,32
   240f4:	01801404 	movi	r6,80
   240f8:	0016f600 	call	16f60 <memset>

static void lcd_scroll_up(altera_avalon_lcd_16207_state* sp)
{
  int y;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   240fc:	e0bffe17 	ldw	r2,-8(fp)
   24100:	10800044 	addi	r2,r2,1
   24104:	e0bffe15 	stw	r2,-8(fp)
   24108:	e0bffe17 	ldw	r2,-8(fp)
   2410c:	10800090 	cmplti	r2,r2,2
   24110:	103fdf1e 	bne	r2,zero,24090 <lcd_scroll_up+0x1c>
      memcpy(sp->line[y].data, sp->line[y+1].data, ALT_LCD_VIRTUAL_WIDTH);
    else
      memset(sp->line[y].data, ' ', ALT_LCD_VIRTUAL_WIDTH);
  }

  sp->y--;
   24114:	e0bfff17 	ldw	r2,-4(fp)
   24118:	10800883 	ldbu	r2,34(r2)
   2411c:	10bfffc4 	addi	r2,r2,-1
   24120:	1007883a 	mov	r3,r2
   24124:	e0bfff17 	ldw	r2,-4(fp)
   24128:	10c00885 	stb	r3,34(r2)
}
   2412c:	e037883a 	mov	sp,fp
   24130:	dfc00117 	ldw	ra,4(sp)
   24134:	df000017 	ldw	fp,0(sp)
   24138:	dec00204 	addi	sp,sp,8
   2413c:	f800283a 	ret

00024140 <lcd_handle_escape>:

/* --------------------------------------------------------------------- */

static void lcd_handle_escape(altera_avalon_lcd_16207_state* sp, char c)
{
   24140:	defff904 	addi	sp,sp,-28
   24144:	dfc00615 	stw	ra,24(sp)
   24148:	df000515 	stw	fp,20(sp)
   2414c:	df000504 	addi	fp,sp,20
   24150:	e13ffe15 	stw	r4,-8(fp)
   24154:	2805883a 	mov	r2,r5
   24158:	e0bfff05 	stb	r2,-4(fp)
  int parm1 = 0, parm2 = 0;
   2415c:	e03ffb15 	stw	zero,-20(fp)
   24160:	e03ffc15 	stw	zero,-16(fp)

  if (sp->escape[0] == '[')
   24164:	e0bffe17 	ldw	r2,-8(fp)
   24168:	10800a03 	ldbu	r2,40(r2)
   2416c:	10803fcc 	andi	r2,r2,255
   24170:	1080201c 	xori	r2,r2,128
   24174:	10bfe004 	addi	r2,r2,-128
   24178:	108016d8 	cmpnei	r2,r2,91
   2417c:	1000441e 	bne	r2,zero,24290 <lcd_handle_escape+0x150>
  {
    char * ptr = sp->escape+1;
   24180:	e0bffe17 	ldw	r2,-8(fp)
   24184:	10800a44 	addi	r2,r2,41
   24188:	e0bffd15 	stw	r2,-12(fp)
    while (isdigit(*ptr))
   2418c:	00000d06 	br	241c4 <lcd_handle_escape+0x84>
      parm1 = (parm1 * 10) + (*ptr++ - '0');
   24190:	e0bffb17 	ldw	r2,-20(fp)
   24194:	10c002a4 	muli	r3,r2,10
   24198:	e0bffd17 	ldw	r2,-12(fp)
   2419c:	10800003 	ldbu	r2,0(r2)
   241a0:	10803fcc 	andi	r2,r2,255
   241a4:	1080201c 	xori	r2,r2,128
   241a8:	10bfe004 	addi	r2,r2,-128
   241ac:	10bff404 	addi	r2,r2,-48
   241b0:	1885883a 	add	r2,r3,r2
   241b4:	e0bffb15 	stw	r2,-20(fp)
   241b8:	e0bffd17 	ldw	r2,-12(fp)
   241bc:	10800044 	addi	r2,r2,1
   241c0:	e0bffd15 	stw	r2,-12(fp)
  int parm1 = 0, parm2 = 0;

  if (sp->escape[0] == '[')
  {
    char * ptr = sp->escape+1;
    while (isdigit(*ptr))
   241c4:	008000f4 	movhi	r2,3
   241c8:	10910a04 	addi	r2,r2,17448
   241cc:	10c00017 	ldw	r3,0(r2)
   241d0:	e0bffd17 	ldw	r2,-12(fp)
   241d4:	10800003 	ldbu	r2,0(r2)
   241d8:	10803fcc 	andi	r2,r2,255
   241dc:	1080201c 	xori	r2,r2,128
   241e0:	10bfe004 	addi	r2,r2,-128
   241e4:	1885883a 	add	r2,r3,r2
   241e8:	10800003 	ldbu	r2,0(r2)
   241ec:	10803fcc 	andi	r2,r2,255
   241f0:	1080010c 	andi	r2,r2,4
   241f4:	103fe61e 	bne	r2,zero,24190 <lcd_handle_escape+0x50>
      parm1 = (parm1 * 10) + (*ptr++ - '0');

    if (*ptr == ';')
   241f8:	e0bffd17 	ldw	r2,-12(fp)
   241fc:	10800003 	ldbu	r2,0(r2)
   24200:	10803fcc 	andi	r2,r2,255
   24204:	1080201c 	xori	r2,r2,128
   24208:	10bfe004 	addi	r2,r2,-128
   2420c:	10800ed8 	cmpnei	r2,r2,59
   24210:	1000211e 	bne	r2,zero,24298 <lcd_handle_escape+0x158>
    {
      ptr++;
   24214:	e0bffd17 	ldw	r2,-12(fp)
   24218:	10800044 	addi	r2,r2,1
   2421c:	e0bffd15 	stw	r2,-12(fp)
      while (isdigit(*ptr))
   24220:	00000d06 	br	24258 <lcd_handle_escape+0x118>
        parm2 = (parm2 * 10) + (*ptr++ - '0');
   24224:	e0bffc17 	ldw	r2,-16(fp)
   24228:	10c002a4 	muli	r3,r2,10
   2422c:	e0bffd17 	ldw	r2,-12(fp)
   24230:	10800003 	ldbu	r2,0(r2)
   24234:	10803fcc 	andi	r2,r2,255
   24238:	1080201c 	xori	r2,r2,128
   2423c:	10bfe004 	addi	r2,r2,-128
   24240:	10bff404 	addi	r2,r2,-48
   24244:	1885883a 	add	r2,r3,r2
   24248:	e0bffc15 	stw	r2,-16(fp)
   2424c:	e0bffd17 	ldw	r2,-12(fp)
   24250:	10800044 	addi	r2,r2,1
   24254:	e0bffd15 	stw	r2,-12(fp)
      parm1 = (parm1 * 10) + (*ptr++ - '0');

    if (*ptr == ';')
    {
      ptr++;
      while (isdigit(*ptr))
   24258:	008000f4 	movhi	r2,3
   2425c:	10910a04 	addi	r2,r2,17448
   24260:	10c00017 	ldw	r3,0(r2)
   24264:	e0bffd17 	ldw	r2,-12(fp)
   24268:	10800003 	ldbu	r2,0(r2)
   2426c:	10803fcc 	andi	r2,r2,255
   24270:	1080201c 	xori	r2,r2,128
   24274:	10bfe004 	addi	r2,r2,-128
   24278:	1885883a 	add	r2,r3,r2
   2427c:	10800003 	ldbu	r2,0(r2)
   24280:	10803fcc 	andi	r2,r2,255
   24284:	1080010c 	andi	r2,r2,4
   24288:	103fe61e 	bne	r2,zero,24224 <lcd_handle_escape+0xe4>
   2428c:	00000206 	br	24298 <lcd_handle_escape+0x158>
        parm2 = (parm2 * 10) + (*ptr++ - '0');
    }
  }
  else
    parm1 = -1;
   24290:	00bfffc4 	movi	r2,-1
   24294:	e0bffb15 	stw	r2,-20(fp)

  switch (c)
   24298:	e0bfff07 	ldb	r2,-4(fp)
   2429c:	10c012a0 	cmpeqi	r3,r2,74
   242a0:	18002a1e 	bne	r3,zero,2434c <lcd_handle_escape+0x20c>
   242a4:	10c012c8 	cmpgei	r3,r2,75
   242a8:	1800031e 	bne	r3,zero,242b8 <lcd_handle_escape+0x178>
   242ac:	10801220 	cmpeqi	r2,r2,72
   242b0:	1000051e 	bne	r2,zero,242c8 <lcd_handle_escape+0x188>
   242b4:	00004c06 	br	243e8 <lcd_handle_escape+0x2a8>
   242b8:	10c012e0 	cmpeqi	r3,r2,75
   242bc:	1800291e 	bne	r3,zero,24364 <lcd_handle_escape+0x224>
   242c0:	108019a0 	cmpeqi	r2,r2,102
   242c4:	10004826 	beq	r2,zero,243e8 <lcd_handle_escape+0x2a8>
  {
  case 'H': /* ESC '[' <y> ';' <x> 'H'  : Move cursor to location */
  case 'f': /* Same as above */
    if (parm2 > 0)
   242c8:	e0bffc17 	ldw	r2,-16(fp)
   242cc:	0080050e 	bge	zero,r2,242e4 <lcd_handle_escape+0x1a4>
      sp->x = parm2 - 1;
   242d0:	e0bffc17 	ldw	r2,-16(fp)
   242d4:	10bfffc4 	addi	r2,r2,-1
   242d8:	1007883a 	mov	r3,r2
   242dc:	e0bffe17 	ldw	r2,-8(fp)
   242e0:	10c00845 	stb	r3,33(r2)
    if (parm1 > 0)
   242e4:	e0bffb17 	ldw	r2,-20(fp)
   242e8:	00803a0e 	bge	zero,r2,243d4 <lcd_handle_escape+0x294>
    {
      sp->y = parm1 - 1;
   242ec:	e0bffb17 	ldw	r2,-20(fp)
   242f0:	10bfffc4 	addi	r2,r2,-1
   242f4:	1007883a 	mov	r3,r2
   242f8:	e0bffe17 	ldw	r2,-8(fp)
   242fc:	10c00885 	stb	r3,34(r2)
      if (sp->y > ALT_LCD_HEIGHT * 2)
   24300:	e0bffe17 	ldw	r2,-8(fp)
   24304:	10800883 	ldbu	r2,34(r2)
   24308:	10803fcc 	andi	r2,r2,255
   2430c:	10800170 	cmpltui	r2,r2,5
   24310:	1000071e 	bne	r2,zero,24330 <lcd_handle_escape+0x1f0>
        sp->y = ALT_LCD_HEIGHT * 2;
   24314:	e0bffe17 	ldw	r2,-8(fp)
   24318:	00c00104 	movi	r3,4
   2431c:	10c00885 	stb	r3,34(r2)
      while (sp->y > ALT_LCD_HEIGHT)
   24320:	00000306 	br	24330 <lcd_handle_escape+0x1f0>
        lcd_scroll_up(sp);
   24324:	e13ffe17 	ldw	r4,-8(fp)
   24328:	00240740 	call	24074 <lcd_scroll_up>
   2432c:	00000106 	br	24334 <lcd_handle_escape+0x1f4>
    if (parm1 > 0)
    {
      sp->y = parm1 - 1;
      if (sp->y > ALT_LCD_HEIGHT * 2)
        sp->y = ALT_LCD_HEIGHT * 2;
      while (sp->y > ALT_LCD_HEIGHT)
   24330:	0001883a 	nop
   24334:	e0bffe17 	ldw	r2,-8(fp)
   24338:	10800883 	ldbu	r2,34(r2)
   2433c:	10803fcc 	andi	r2,r2,255
   24340:	108000e8 	cmpgeui	r2,r2,3
   24344:	103ff71e 	bne	r2,zero,24324 <lcd_handle_escape+0x1e4>
        lcd_scroll_up(sp);
    }
    break;
   24348:	00002206 	br	243d4 <lcd_handle_escape+0x294>
    /*   ESC J      is clear to beginning of line    [unimplemented]
     *   ESC [ 0 J  is clear to bottom of screen     [unimplemented]
     *   ESC [ 1 J  is clear to beginning of screen  [unimplemented]
     *   ESC [ 2 J  is clear screen
     */
    if (parm1 == 2)
   2434c:	e0bffb17 	ldw	r2,-20(fp)
   24350:	10800098 	cmpnei	r2,r2,2
   24354:	1000211e 	bne	r2,zero,243dc <lcd_handle_escape+0x29c>
      lcd_clear_screen(sp);
   24358:	e13ffe17 	ldw	r4,-8(fp)
   2435c:	0023dbc0 	call	23dbc <lcd_clear_screen>
    break;
   24360:	00001e06 	br	243dc <lcd_handle_escape+0x29c>
    /*   ESC K      is clear to end of line
     *   ESC [ 0 K  is clear to end of line
     *   ESC [ 1 K  is clear to beginning of line    [unimplemented]
     *   ESC [ 2 K  is clear line                    [unimplemented]
     */
    if (parm1 < 1)
   24364:	e0bffb17 	ldw	r2,-20(fp)
   24368:	00801e16 	blt	zero,r2,243e4 <lcd_handle_escape+0x2a4>
    {
      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
   2436c:	e0bffe17 	ldw	r2,-8(fp)
   24370:	10800843 	ldbu	r2,33(r2)
   24374:	10803fcc 	andi	r2,r2,255
   24378:	10801428 	cmpgeui	r2,r2,80
   2437c:	1000191e 	bne	r2,zero,243e4 <lcd_handle_escape+0x2a4>
        memset(sp->line[sp->y].data + sp->x, ' ', ALT_LCD_VIRTUAL_WIDTH - sp->x);
   24380:	e0bffe17 	ldw	r2,-8(fp)
   24384:	10800883 	ldbu	r2,34(r2)
   24388:	10803fcc 	andi	r2,r2,255
   2438c:	108018e4 	muli	r2,r2,99
   24390:	10801004 	addi	r2,r2,64
   24394:	e0fffe17 	ldw	r3,-8(fp)
   24398:	1887883a 	add	r3,r3,r2
   2439c:	e0bffe17 	ldw	r2,-8(fp)
   243a0:	10800843 	ldbu	r2,33(r2)
   243a4:	10803fcc 	andi	r2,r2,255
   243a8:	1887883a 	add	r3,r3,r2
   243ac:	e0bffe17 	ldw	r2,-8(fp)
   243b0:	10800843 	ldbu	r2,33(r2)
   243b4:	10803fcc 	andi	r2,r2,255
   243b8:	01001404 	movi	r4,80
   243bc:	2085c83a 	sub	r2,r4,r2
   243c0:	1809883a 	mov	r4,r3
   243c4:	01400804 	movi	r5,32
   243c8:	100d883a 	mov	r6,r2
   243cc:	0016f600 	call	16f60 <memset>
    }
    break;
   243d0:	00000406 	br	243e4 <lcd_handle_escape+0x2a4>
      if (sp->y > ALT_LCD_HEIGHT * 2)
        sp->y = ALT_LCD_HEIGHT * 2;
      while (sp->y > ALT_LCD_HEIGHT)
        lcd_scroll_up(sp);
    }
    break;
   243d4:	0001883a 	nop
   243d8:	00000306 	br	243e8 <lcd_handle_escape+0x2a8>
     *   ESC [ 1 J  is clear to beginning of screen  [unimplemented]
     *   ESC [ 2 J  is clear screen
     */
    if (parm1 == 2)
      lcd_clear_screen(sp);
    break;
   243dc:	0001883a 	nop
   243e0:	00000106 	br	243e8 <lcd_handle_escape+0x2a8>
    if (parm1 < 1)
    {
      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
        memset(sp->line[sp->y].data + sp->x, ' ', ALT_LCD_VIRTUAL_WIDTH - sp->x);
    }
    break;
   243e4:	0001883a 	nop
  }
}
   243e8:	e037883a 	mov	sp,fp
   243ec:	dfc00117 	ldw	ra,4(sp)
   243f0:	df000017 	ldw	fp,0(sp)
   243f4:	dec00204 	addi	sp,sp,8
   243f8:	f800283a 	ret

000243fc <altera_avalon_lcd_16207_write>:

/* --------------------------------------------------------------------- */

int altera_avalon_lcd_16207_write(altera_avalon_lcd_16207_state* sp, 
  const char* ptr, int len, int flags)
{
   243fc:	defff304 	addi	sp,sp,-52
   24400:	dfc00c15 	stw	ra,48(sp)
   24404:	df000b15 	stw	fp,44(sp)
   24408:	df000b04 	addi	fp,sp,44
   2440c:	e13ffc15 	stw	r4,-16(fp)
   24410:	e17ffd15 	stw	r5,-12(fp)
   24414:	e1bffe15 	stw	r6,-8(fp)
   24418:	e1ffff15 	stw	r7,-4(fp)
  const char* end = ptr + len;
   2441c:	e0bffe17 	ldw	r2,-8(fp)
   24420:	e0fffd17 	ldw	r3,-12(fp)
   24424:	1885883a 	add	r2,r3,r2
   24428:	e0bff815 	stw	r2,-32(fp)

  ALT_SEM_PEND (sp->write_lock, 0);

  /* Tell the routine which is called off the timer interrupt that the
   * foreground routines are active so it must not repaint the display. */
  sp->active = 1;
   2442c:	e0bffc17 	ldw	r2,-16(fp)
   24430:	00c00044 	movi	r3,1
   24434:	10c009c5 	stb	r3,39(r2)

  for ( ; ptr < end ; ptr++)
   24438:	00009d06 	br	246b0 <altera_avalon_lcd_16207_write+0x2b4>
  {
    char c = *ptr;
   2443c:	e0bffd17 	ldw	r2,-12(fp)
   24440:	10800003 	ldbu	r2,0(r2)
   24444:	e0bff905 	stb	r2,-28(fp)

    if (sp->esccount >= 0)
   24448:	e0bffc17 	ldw	r2,-16(fp)
   2444c:	10800903 	ldbu	r2,36(r2)
   24450:	10803fcc 	andi	r2,r2,255
   24454:	1080201c 	xori	r2,r2,128
   24458:	10bfe004 	addi	r2,r2,-128
   2445c:	10003816 	blt	r2,zero,24540 <altera_avalon_lcd_16207_write+0x144>
    {
      unsigned int esccount = sp->esccount;
   24460:	e0bffc17 	ldw	r2,-16(fp)
   24464:	10800903 	ldbu	r2,36(r2)
   24468:	10803fcc 	andi	r2,r2,255
   2446c:	1080201c 	xori	r2,r2,128
   24470:	10bfe004 	addi	r2,r2,-128
   24474:	e0bffa15 	stw	r2,-24(fp)

      /* Single character escape sequences can end with any character
       * Multi character escape sequences start with '[' and contain
       * digits and semicolons before terminating
       */
      if ((esccount == 0 && c != '[') ||
   24478:	e0bffa17 	ldw	r2,-24(fp)
   2447c:	1000031e 	bne	r2,zero,2448c <altera_avalon_lcd_16207_write+0x90>
   24480:	e0bff907 	ldb	r2,-28(fp)
   24484:	108016d8 	cmpnei	r2,r2,91
   24488:	10000e1e 	bne	r2,zero,244c4 <altera_avalon_lcd_16207_write+0xc8>
   2448c:	e0bffa17 	ldw	r2,-24(fp)
   24490:	10001926 	beq	r2,zero,244f8 <altera_avalon_lcd_16207_write+0xfc>
          (esccount > 0 && !isdigit(c) && c != ';'))
   24494:	008000f4 	movhi	r2,3
   24498:	10910a04 	addi	r2,r2,17448
   2449c:	10c00017 	ldw	r3,0(r2)
   244a0:	e0bff907 	ldb	r2,-28(fp)
   244a4:	1885883a 	add	r2,r3,r2
   244a8:	10800003 	ldbu	r2,0(r2)
   244ac:	10803fcc 	andi	r2,r2,255
   244b0:	1080010c 	andi	r2,r2,4
   244b4:	1000101e 	bne	r2,zero,244f8 <altera_avalon_lcd_16207_write+0xfc>
   244b8:	e0bff907 	ldb	r2,-28(fp)
   244bc:	10800ee0 	cmpeqi	r2,r2,59
   244c0:	10000d1e 	bne	r2,zero,244f8 <altera_avalon_lcd_16207_write+0xfc>
      {
        sp->escape[esccount] = 0;
   244c4:	e0fffc17 	ldw	r3,-16(fp)
   244c8:	e0bffa17 	ldw	r2,-24(fp)
   244cc:	1885883a 	add	r2,r3,r2
   244d0:	10800a04 	addi	r2,r2,40
   244d4:	10000005 	stb	zero,0(r2)

        lcd_handle_escape(sp, c);
   244d8:	e0bff907 	ldb	r2,-28(fp)
   244dc:	e13ffc17 	ldw	r4,-16(fp)
   244e0:	100b883a 	mov	r5,r2
   244e4:	00241400 	call	24140 <lcd_handle_escape>

        sp->esccount = -1;
   244e8:	e0bffc17 	ldw	r2,-16(fp)
   244ec:	00ffffc4 	movi	r3,-1
   244f0:	10c00905 	stb	r3,36(r2)
   244f4:	00006b06 	br	246a4 <altera_avalon_lcd_16207_write+0x2a8>
      }
      else if (sp->esccount < sizeof(sp->escape)-1)
   244f8:	e0bffc17 	ldw	r2,-16(fp)
   244fc:	10800903 	ldbu	r2,36(r2)
   24500:	10803fcc 	andi	r2,r2,255
   24504:	108001e8 	cmpgeui	r2,r2,7
   24508:	1000651e 	bne	r2,zero,246a0 <altera_avalon_lcd_16207_write+0x2a4>
      {
        sp->escape[esccount] = c;
   2450c:	e0fffc17 	ldw	r3,-16(fp)
   24510:	e0bffa17 	ldw	r2,-24(fp)
   24514:	1885883a 	add	r2,r3,r2
   24518:	10800a04 	addi	r2,r2,40
   2451c:	e0fff903 	ldbu	r3,-28(fp)
   24520:	10c00005 	stb	r3,0(r2)
        sp->esccount++;
   24524:	e0bffc17 	ldw	r2,-16(fp)
   24528:	10800903 	ldbu	r2,36(r2)
   2452c:	10800044 	addi	r2,r2,1
   24530:	1007883a 	mov	r3,r2
   24534:	e0bffc17 	ldw	r2,-16(fp)
   24538:	10c00905 	stb	r3,36(r2)
   2453c:	00005806 	br	246a0 <altera_avalon_lcd_16207_write+0x2a4>
      }
    }
    else if (c == 27) /* ESC */
   24540:	e0bff907 	ldb	r2,-28(fp)
   24544:	108006d8 	cmpnei	r2,r2,27
   24548:	1000031e 	bne	r2,zero,24558 <altera_avalon_lcd_16207_write+0x15c>
    {
      sp->esccount = 0;
   2454c:	e0bffc17 	ldw	r2,-16(fp)
   24550:	10000905 	stb	zero,36(r2)
   24554:	00005306 	br	246a4 <altera_avalon_lcd_16207_write+0x2a8>
    }
    else if (c == '\r')
   24558:	e0bff907 	ldb	r2,-28(fp)
   2455c:	10800358 	cmpnei	r2,r2,13
   24560:	1000031e 	bne	r2,zero,24570 <altera_avalon_lcd_16207_write+0x174>
    {
      sp->x = 0;
   24564:	e0bffc17 	ldw	r2,-16(fp)
   24568:	10000845 	stb	zero,33(r2)
   2456c:	00004d06 	br	246a4 <altera_avalon_lcd_16207_write+0x2a8>
    }
    else if (c == '\n')
   24570:	e0bff907 	ldb	r2,-28(fp)
   24574:	10800298 	cmpnei	r2,r2,10
   24578:	1000101e 	bne	r2,zero,245bc <altera_avalon_lcd_16207_write+0x1c0>
    {
      sp->x = 0;
   2457c:	e0bffc17 	ldw	r2,-16(fp)
   24580:	10000845 	stb	zero,33(r2)
      sp->y++;
   24584:	e0bffc17 	ldw	r2,-16(fp)
   24588:	10800883 	ldbu	r2,34(r2)
   2458c:	10800044 	addi	r2,r2,1
   24590:	1007883a 	mov	r3,r2
   24594:	e0bffc17 	ldw	r2,-16(fp)
   24598:	10c00885 	stb	r3,34(r2)

      /* Let the cursor sit at X=0, Y=HEIGHT without scrolling so the user
       * can print two lines of data without losing one.
       */
      if (sp->y > ALT_LCD_HEIGHT)
   2459c:	e0bffc17 	ldw	r2,-16(fp)
   245a0:	10800883 	ldbu	r2,34(r2)
   245a4:	10803fcc 	andi	r2,r2,255
   245a8:	108000f0 	cmpltui	r2,r2,3
   245ac:	10003d1e 	bne	r2,zero,246a4 <altera_avalon_lcd_16207_write+0x2a8>
        lcd_scroll_up(sp);
   245b0:	e13ffc17 	ldw	r4,-16(fp)
   245b4:	00240740 	call	24074 <lcd_scroll_up>
   245b8:	00003a06 	br	246a4 <altera_avalon_lcd_16207_write+0x2a8>
    }
    else if (c == '\b')
   245bc:	e0bff907 	ldb	r2,-28(fp)
   245c0:	10800218 	cmpnei	r2,r2,8
   245c4:	10000b1e 	bne	r2,zero,245f4 <altera_avalon_lcd_16207_write+0x1f8>
    {
      if (sp->x > 0)
   245c8:	e0bffc17 	ldw	r2,-16(fp)
   245cc:	10800843 	ldbu	r2,33(r2)
   245d0:	10803fcc 	andi	r2,r2,255
   245d4:	10003326 	beq	r2,zero,246a4 <altera_avalon_lcd_16207_write+0x2a8>
        sp->x--;
   245d8:	e0bffc17 	ldw	r2,-16(fp)
   245dc:	10800843 	ldbu	r2,33(r2)
   245e0:	10bfffc4 	addi	r2,r2,-1
   245e4:	1007883a 	mov	r3,r2
   245e8:	e0bffc17 	ldw	r2,-16(fp)
   245ec:	10c00845 	stb	r3,33(r2)
   245f0:	00002c06 	br	246a4 <altera_avalon_lcd_16207_write+0x2a8>
    }
    else if (isprint(c))
   245f4:	008000f4 	movhi	r2,3
   245f8:	10910a04 	addi	r2,r2,17448
   245fc:	10c00017 	ldw	r3,0(r2)
   24600:	e0bff907 	ldb	r2,-28(fp)
   24604:	1885883a 	add	r2,r3,r2
   24608:	10800003 	ldbu	r2,0(r2)
   2460c:	10803fcc 	andi	r2,r2,255
   24610:	1080201c 	xori	r2,r2,128
   24614:	10bfe004 	addi	r2,r2,-128
   24618:	108025cc 	andi	r2,r2,151
   2461c:	10002126 	beq	r2,zero,246a4 <altera_avalon_lcd_16207_write+0x2a8>
    {
      /* If we didn't scroll on the last linefeed then we might need to do
       * it now. */
      if (sp->y >= ALT_LCD_HEIGHT)
   24620:	e0bffc17 	ldw	r2,-16(fp)
   24624:	10800883 	ldbu	r2,34(r2)
   24628:	10803fcc 	andi	r2,r2,255
   2462c:	108000b0 	cmpltui	r2,r2,2
   24630:	1000021e 	bne	r2,zero,2463c <altera_avalon_lcd_16207_write+0x240>
        lcd_scroll_up(sp);
   24634:	e13ffc17 	ldw	r4,-16(fp)
   24638:	00240740 	call	24074 <lcd_scroll_up>

      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
   2463c:	e0bffc17 	ldw	r2,-16(fp)
   24640:	10800843 	ldbu	r2,33(r2)
   24644:	10803fcc 	andi	r2,r2,255
   24648:	10801428 	cmpgeui	r2,r2,80
   2464c:	10000d1e 	bne	r2,zero,24684 <altera_avalon_lcd_16207_write+0x288>
        sp->line[sp->y].data[sp->x] = c;
   24650:	e0bffc17 	ldw	r2,-16(fp)
   24654:	10800883 	ldbu	r2,34(r2)
   24658:	10c03fcc 	andi	r3,r2,255
   2465c:	e0bffc17 	ldw	r2,-16(fp)
   24660:	10800843 	ldbu	r2,33(r2)
   24664:	10803fcc 	andi	r2,r2,255
   24668:	e13ffc17 	ldw	r4,-16(fp)
   2466c:	18c018e4 	muli	r3,r3,99
   24670:	20c7883a 	add	r3,r4,r3
   24674:	1885883a 	add	r2,r3,r2
   24678:	10801004 	addi	r2,r2,64
   2467c:	e0fff903 	ldbu	r3,-28(fp)
   24680:	10c00005 	stb	r3,0(r2)

      sp->x++;
   24684:	e0bffc17 	ldw	r2,-16(fp)
   24688:	10800843 	ldbu	r2,33(r2)
   2468c:	10800044 	addi	r2,r2,1
   24690:	1007883a 	mov	r3,r2
   24694:	e0bffc17 	ldw	r2,-16(fp)
   24698:	10c00845 	stb	r3,33(r2)
   2469c:	00000106 	br	246a4 <altera_avalon_lcd_16207_write+0x2a8>
        sp->esccount = -1;
      }
      else if (sp->esccount < sizeof(sp->escape)-1)
      {
        sp->escape[esccount] = c;
        sp->esccount++;
   246a0:	0001883a 	nop

  /* Tell the routine which is called off the timer interrupt that the
   * foreground routines are active so it must not repaint the display. */
  sp->active = 1;

  for ( ; ptr < end ; ptr++)
   246a4:	e0bffd17 	ldw	r2,-12(fp)
   246a8:	10800044 	addi	r2,r2,1
   246ac:	e0bffd15 	stw	r2,-12(fp)
   246b0:	e0fffd17 	ldw	r3,-12(fp)
   246b4:	e0bff817 	ldw	r2,-32(fp)
   246b8:	18bf6036 	bltu	r3,r2,2443c <altera_avalon_lcd_16207_write+0x40>
      sp->x++;
    }
  }

  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
   246bc:	00800404 	movi	r2,16
   246c0:	e0bff615 	stw	r2,-40(fp)
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   246c4:	e03ff515 	stw	zero,-44(fp)
   246c8:	00003706 	br	247a8 <altera_avalon_lcd_16207_write+0x3ac>
  {
    int width;
    for (width = ALT_LCD_VIRTUAL_WIDTH ; width > 0 ; width--)
   246cc:	00801404 	movi	r2,80
   246d0:	e0bff715 	stw	r2,-36(fp)
   246d4:	00001106 	br	2471c <altera_avalon_lcd_16207_write+0x320>
      if (sp->line[y].data[width-1] != ' ')
   246d8:	e0bff717 	ldw	r2,-36(fp)
   246dc:	10bfffc4 	addi	r2,r2,-1
   246e0:	e13ffc17 	ldw	r4,-16(fp)
   246e4:	e0fff517 	ldw	r3,-44(fp)
   246e8:	18c018e4 	muli	r3,r3,99
   246ec:	20c7883a 	add	r3,r4,r3
   246f0:	1885883a 	add	r2,r3,r2
   246f4:	10801004 	addi	r2,r2,64
   246f8:	10800003 	ldbu	r2,0(r2)
   246fc:	10803fcc 	andi	r2,r2,255
   24700:	1080201c 	xori	r2,r2,128
   24704:	10bfe004 	addi	r2,r2,-128
   24708:	10800820 	cmpeqi	r2,r2,32
   2470c:	10000626 	beq	r2,zero,24728 <altera_avalon_lcd_16207_write+0x32c>
  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
  {
    int width;
    for (width = ALT_LCD_VIRTUAL_WIDTH ; width > 0 ; width--)
   24710:	e0bff717 	ldw	r2,-36(fp)
   24714:	10bfffc4 	addi	r2,r2,-1
   24718:	e0bff715 	stw	r2,-36(fp)
   2471c:	e0bff717 	ldw	r2,-36(fp)
   24720:	00bfed16 	blt	zero,r2,246d8 <altera_avalon_lcd_16207_write+0x2dc>
   24724:	00000106 	br	2472c <altera_avalon_lcd_16207_write+0x330>
      if (sp->line[y].data[width-1] != ' ')
        break;
   24728:	0001883a 	nop

    /* The minimum width is the size of the LCD panel.  If the real width
     * is long enough to require scrolling then add an extra space so the
     * end of the message doesn't run into the beginning of it.
     */
    if (width <= ALT_LCD_WIDTH)
   2472c:	e0bff717 	ldw	r2,-36(fp)
   24730:	10800448 	cmpgei	r2,r2,17
   24734:	1000031e 	bne	r2,zero,24744 <altera_avalon_lcd_16207_write+0x348>
      width = ALT_LCD_WIDTH;
   24738:	00800404 	movi	r2,16
   2473c:	e0bff715 	stw	r2,-36(fp)
   24740:	00000306 	br	24750 <altera_avalon_lcd_16207_write+0x354>
    else
      width++;
   24744:	e0bff717 	ldw	r2,-36(fp)
   24748:	10800044 	addi	r2,r2,1
   2474c:	e0bff715 	stw	r2,-36(fp)

    sp->line[y].width = width;
   24750:	e0bff717 	ldw	r2,-36(fp)
   24754:	1007883a 	mov	r3,r2
   24758:	e13ffc17 	ldw	r4,-16(fp)
   2475c:	e0bff517 	ldw	r2,-44(fp)
   24760:	108018e4 	muli	r2,r2,99
   24764:	2085883a 	add	r2,r4,r2
   24768:	10802404 	addi	r2,r2,144
   2476c:	10c00045 	stb	r3,1(r2)
    if (widthmax < width)
   24770:	e0fff617 	ldw	r3,-40(fp)
   24774:	e0bff717 	ldw	r2,-36(fp)
   24778:	1880020e 	bge	r3,r2,24784 <altera_avalon_lcd_16207_write+0x388>
      widthmax = width;
   2477c:	e0bff717 	ldw	r2,-36(fp)
   24780:	e0bff615 	stw	r2,-40(fp)
    sp->line[y].speed = 0; /* By default lines don't scroll */
   24784:	e0fffc17 	ldw	r3,-16(fp)
   24788:	e0bff517 	ldw	r2,-44(fp)
   2478c:	108018e4 	muli	r2,r2,99
   24790:	1885883a 	add	r2,r3,r2
   24794:	10802404 	addi	r2,r2,144
   24798:	10000085 	stb	zero,2(r2)
    }
  }

  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   2479c:	e0bff517 	ldw	r2,-44(fp)
   247a0:	10800044 	addi	r2,r2,1
   247a4:	e0bff515 	stw	r2,-44(fp)
   247a8:	e0bff517 	ldw	r2,-44(fp)
   247ac:	10800090 	cmplti	r2,r2,2
   247b0:	103fc61e 	bne	r2,zero,246cc <altera_avalon_lcd_16207_write+0x2d0>
    if (widthmax < width)
      widthmax = width;
    sp->line[y].speed = 0; /* By default lines don't scroll */
  }

  if (widthmax <= ALT_LCD_WIDTH)
   247b4:	e0bff617 	ldw	r2,-40(fp)
   247b8:	10800448 	cmpgei	r2,r2,17
   247bc:	1000031e 	bne	r2,zero,247cc <altera_avalon_lcd_16207_write+0x3d0>
    sp->scrollmax = 0;
   247c0:	e0bffc17 	ldw	r2,-16(fp)
   247c4:	10000985 	stb	zero,38(r2)
   247c8:	00002d06 	br	24880 <altera_avalon_lcd_16207_write+0x484>
  else
  {
    widthmax *= 2;
   247cc:	e0bff617 	ldw	r2,-40(fp)
   247d0:	1085883a 	add	r2,r2,r2
   247d4:	e0bff615 	stw	r2,-40(fp)
    sp->scrollmax = widthmax;
   247d8:	e0bff617 	ldw	r2,-40(fp)
   247dc:	1007883a 	mov	r3,r2
   247e0:	e0bffc17 	ldw	r2,-16(fp)
   247e4:	10c00985 	stb	r3,38(r2)

    /* Now calculate how fast each of the other lines should go */
    for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   247e8:	e03ff515 	stw	zero,-44(fp)
   247ec:	00002106 	br	24874 <altera_avalon_lcd_16207_write+0x478>
      if (sp->line[y].width > ALT_LCD_WIDTH)
   247f0:	e0fffc17 	ldw	r3,-16(fp)
   247f4:	e0bff517 	ldw	r2,-44(fp)
   247f8:	108018e4 	muli	r2,r2,99
   247fc:	1885883a 	add	r2,r3,r2
   24800:	10802404 	addi	r2,r2,144
   24804:	10800043 	ldbu	r2,1(r2)
   24808:	10803fcc 	andi	r2,r2,255
   2480c:	1080201c 	xori	r2,r2,128
   24810:	10bfe004 	addi	r2,r2,-128
   24814:	10800450 	cmplti	r2,r2,17
   24818:	1000131e 	bne	r2,zero,24868 <altera_avalon_lcd_16207_write+0x46c>
         */
#if 1
        /* This option makes all the lines scroll round at different speeds
         * which are chosen so that all the scrolls finish at the same time.
         */
        sp->line[y].speed = 256 * sp->line[y].width / widthmax;
   2481c:	e0fffc17 	ldw	r3,-16(fp)
   24820:	e0bff517 	ldw	r2,-44(fp)
   24824:	108018e4 	muli	r2,r2,99
   24828:	1885883a 	add	r2,r3,r2
   2482c:	10802404 	addi	r2,r2,144
   24830:	10800043 	ldbu	r2,1(r2)
   24834:	10803fcc 	andi	r2,r2,255
   24838:	1080201c 	xori	r2,r2,128
   2483c:	10bfe004 	addi	r2,r2,-128
   24840:	1006923a 	slli	r3,r2,8
   24844:	e0bff617 	ldw	r2,-40(fp)
   24848:	1885283a 	div	r2,r3,r2
   2484c:	1007883a 	mov	r3,r2
   24850:	e13ffc17 	ldw	r4,-16(fp)
   24854:	e0bff517 	ldw	r2,-44(fp)
   24858:	108018e4 	muli	r2,r2,99
   2485c:	2085883a 	add	r2,r4,r2
   24860:	10802404 	addi	r2,r2,144
   24864:	10c00085 	stb	r3,2(r2)
  {
    widthmax *= 2;
    sp->scrollmax = widthmax;

    /* Now calculate how fast each of the other lines should go */
    for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   24868:	e0bff517 	ldw	r2,-44(fp)
   2486c:	10800044 	addi	r2,r2,1
   24870:	e0bff515 	stw	r2,-44(fp)
   24874:	e0bff517 	ldw	r2,-44(fp)
   24878:	10800090 	cmplti	r2,r2,2
   2487c:	103fdc1e 	bne	r2,zero,247f0 <altera_avalon_lcd_16207_write+0x3f4>
   * (because active was set when the timer interrupt occurred).  If there
   * has been a missed repaint then paint again.  And again.  etc.
   */
  for ( ; ; )
  {
    int old_scrollpos = sp->scrollpos;
   24880:	e0bffc17 	ldw	r2,-16(fp)
   24884:	10800943 	ldbu	r2,37(r2)
   24888:	10803fcc 	andi	r2,r2,255
   2488c:	e0bffb15 	stw	r2,-20(fp)

    lcd_repaint_screen(sp);
   24890:	e13ffc17 	ldw	r4,-16(fp)
   24894:	0023e880 	call	23e88 <lcd_repaint_screen>

    /* Let the timer routines repaint the display again */
    sp->active = 0;
   24898:	e0bffc17 	ldw	r2,-16(fp)
   2489c:	100009c5 	stb	zero,39(r2)

    /* Have the timer routines tried to scroll while we were painting?
     * If not then we can exit */
    if (sp->scrollpos == old_scrollpos)
   248a0:	e0bffc17 	ldw	r2,-16(fp)
   248a4:	10800943 	ldbu	r2,37(r2)
   248a8:	10c03fcc 	andi	r3,r2,255
   248ac:	e0bffb17 	ldw	r2,-20(fp)
   248b0:	18800426 	beq	r3,r2,248c4 <altera_avalon_lcd_16207_write+0x4c8>
      break;

    /* We need to repaint again since the display scrolled while we were
     * painting last time */
    sp->active = 1;
   248b4:	e0bffc17 	ldw	r2,-16(fp)
   248b8:	00c00044 	movi	r3,1
   248bc:	10c009c5 	stb	r3,39(r2)
  }
   248c0:	003fef06 	br	24880 <altera_avalon_lcd_16207_write+0x484>
    sp->active = 0;

    /* Have the timer routines tried to scroll while we were painting?
     * If not then we can exit */
    if (sp->scrollpos == old_scrollpos)
      break;
   248c4:	0001883a 	nop
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->write_lock);

  return len;
   248c8:	e0bffe17 	ldw	r2,-8(fp)
}
   248cc:	e037883a 	mov	sp,fp
   248d0:	dfc00117 	ldw	ra,4(sp)
   248d4:	df000017 	ldw	fp,0(sp)
   248d8:	dec00204 	addi	sp,sp,8
   248dc:	f800283a 	ret

000248e0 <alt_lcd_16207_timeout>:
/*
 * Timeout routine is called every second
 */

static alt_u32 alt_lcd_16207_timeout(void* context) 
{
   248e0:	defffc04 	addi	sp,sp,-16
   248e4:	dfc00315 	stw	ra,12(sp)
   248e8:	df000215 	stw	fp,8(sp)
   248ec:	df000204 	addi	fp,sp,8
   248f0:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_lcd_16207_state* sp = (altera_avalon_lcd_16207_state*)context;
   248f4:	e0bfff17 	ldw	r2,-4(fp)
   248f8:	e0bffe15 	stw	r2,-8(fp)

  /* Update the scrolling position */
  if (sp->scrollpos + 1 >= sp->scrollmax)
   248fc:	e0bffe17 	ldw	r2,-8(fp)
   24900:	10800943 	ldbu	r2,37(r2)
   24904:	10803fcc 	andi	r2,r2,255
   24908:	10c00044 	addi	r3,r2,1
   2490c:	e0bffe17 	ldw	r2,-8(fp)
   24910:	10800983 	ldbu	r2,38(r2)
   24914:	10803fcc 	andi	r2,r2,255
   24918:	18800316 	blt	r3,r2,24928 <alt_lcd_16207_timeout+0x48>
    sp->scrollpos = 0;
   2491c:	e0bffe17 	ldw	r2,-8(fp)
   24920:	10000945 	stb	zero,37(r2)
   24924:	00000606 	br	24940 <alt_lcd_16207_timeout+0x60>
  else
    sp->scrollpos = sp->scrollpos + 1;
   24928:	e0bffe17 	ldw	r2,-8(fp)
   2492c:	10800943 	ldbu	r2,37(r2)
   24930:	10800044 	addi	r2,r2,1
   24934:	1007883a 	mov	r3,r2
   24938:	e0bffe17 	ldw	r2,-8(fp)
   2493c:	10c00945 	stb	r3,37(r2)

  /* Repaint the panel unless the foreground will do it again soon */
  if (sp->scrollmax > 0 && !sp->active)
   24940:	e0bffe17 	ldw	r2,-8(fp)
   24944:	10800983 	ldbu	r2,38(r2)
   24948:	10803fcc 	andi	r2,r2,255
   2494c:	10000826 	beq	r2,zero,24970 <alt_lcd_16207_timeout+0x90>
   24950:	e0bffe17 	ldw	r2,-8(fp)
   24954:	108009c3 	ldbu	r2,39(r2)
   24958:	10803fcc 	andi	r2,r2,255
   2495c:	1080201c 	xori	r2,r2,128
   24960:	10bfe004 	addi	r2,r2,-128
   24964:	1000021e 	bne	r2,zero,24970 <alt_lcd_16207_timeout+0x90>
    lcd_repaint_screen(sp);
   24968:	e13ffe17 	ldw	r4,-8(fp)
   2496c:	0023e880 	call	23e88 <lcd_repaint_screen>

  return sp->period;
   24970:	e0bffe17 	ldw	r2,-8(fp)
   24974:	10800717 	ldw	r2,28(r2)
}
   24978:	e037883a 	mov	sp,fp
   2497c:	dfc00117 	ldw	ra,4(sp)
   24980:	df000017 	ldw	fp,0(sp)
   24984:	dec00204 	addi	sp,sp,8
   24988:	f800283a 	ret

0002498c <altera_avalon_lcd_16207_init>:

/*
 * Called at boot time to initialise the LCD driver
 */
void altera_avalon_lcd_16207_init(altera_avalon_lcd_16207_state* sp)
{
   2498c:	defffc04 	addi	sp,sp,-16
   24990:	dfc00315 	stw	ra,12(sp)
   24994:	df000215 	stw	fp,8(sp)
   24998:	df000204 	addi	fp,sp,8
   2499c:	e13fff15 	stw	r4,-4(fp)
  unsigned int base = sp->base;
   249a0:	e0bfff17 	ldw	r2,-4(fp)
   249a4:	10800017 	ldw	r2,0(r2)
   249a8:	e0bffe15 	stw	r2,-8(fp)

  /* Mark the device as functional */
  sp->broken = 0;
   249ac:	e0bfff17 	ldw	r2,-4(fp)
   249b0:	10000805 	stb	zero,32(r2)
   * the BUSY bit in the status register doesn't work until the display
   * has been reset three times.
   */

  /* Wait for 15 ms then reset */
  usleep(15000);
   249b4:	010ea604 	movi	r4,15000
   249b8:	00211c40 	call	211c4 <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
   249bc:	e0bffe17 	ldw	r2,-8(fp)
   249c0:	00c00c04 	movi	r3,48
   249c4:	10c00035 	stwio	r3,0(r2)

  /* Wait for another 4.1ms and reset again */
  usleep(4100);  
   249c8:	01040104 	movi	r4,4100
   249cc:	00211c40 	call	211c4 <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
   249d0:	e0bffe17 	ldw	r2,-8(fp)
   249d4:	00c00c04 	movi	r3,48
   249d8:	10c00035 	stwio	r3,0(r2)

  /* Wait a further 1 ms and reset a third time */
  usleep(1000);
   249dc:	0100fa04 	movi	r4,1000
   249e0:	00211c40 	call	211c4 <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
   249e4:	e0bffe17 	ldw	r2,-8(fp)
   249e8:	00c00c04 	movi	r3,48
   249ec:	10c00035 	stwio	r3,0(r2)

  /* Setup interface parameters: 8 bit bus, 2 rows, 5x7 font */
  lcd_write_command(sp, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT | LCD_CMD_TWO_LINE);
   249f0:	e13fff17 	ldw	r4,-4(fp)
   249f4:	01400e04 	movi	r5,56
   249f8:	0023c380 	call	23c38 <lcd_write_command>
  
  /* Turn display off */
  lcd_write_command(sp, LCD_CMD_ONOFF);
   249fc:	e13fff17 	ldw	r4,-4(fp)
   24a00:	01400204 	movi	r5,8
   24a04:	0023c380 	call	23c38 <lcd_write_command>

  /* Clear display */
  lcd_clear_screen(sp);
   24a08:	e13fff17 	ldw	r4,-4(fp)
   24a0c:	0023dbc0 	call	23dbc <lcd_clear_screen>
  
  /* Set mode: increment after writing, don't shift display */
  lcd_write_command(sp, LCD_CMD_MODES | LCD_CMD_MODE_INC);
   24a10:	e13fff17 	ldw	r4,-4(fp)
   24a14:	01400184 	movi	r5,6
   24a18:	0023c380 	call	23c38 <lcd_write_command>

  /* Turn display on */
  lcd_write_command(sp, LCD_CMD_ONOFF | LCD_CMD_ENABLE_DISP);
   24a1c:	e13fff17 	ldw	r4,-4(fp)
   24a20:	01400304 	movi	r5,12
   24a24:	0023c380 	call	23c38 <lcd_write_command>

  sp->esccount = -1;
   24a28:	e0bfff17 	ldw	r2,-4(fp)
   24a2c:	00ffffc4 	movi	r3,-1
   24a30:	10c00905 	stb	r3,36(r2)
  memset(sp->escape, 0, sizeof(sp->escape));
   24a34:	e0bfff17 	ldw	r2,-4(fp)
   24a38:	10800a04 	addi	r2,r2,40
   24a3c:	1009883a 	mov	r4,r2
   24a40:	000b883a 	mov	r5,zero
   24a44:	01800204 	movi	r6,8
   24a48:	0016f600 	call	16f60 <memset>

  sp->scrollpos = 0;
   24a4c:	e0bfff17 	ldw	r2,-4(fp)
   24a50:	10000945 	stb	zero,37(r2)
  sp->scrollmax = 0;
   24a54:	e0bfff17 	ldw	r2,-4(fp)
   24a58:	10000985 	stb	zero,38(r2)
  sp->active = 0;
   24a5c:	e0bfff17 	ldw	r2,-4(fp)
   24a60:	100009c5 	stb	zero,39(r2)
   24a64:	008000f4 	movhi	r2,3
   24a68:	1099e104 	addi	r2,r2,26500
   24a6c:	10800017 	ldw	r2,0(r2)

  sp->period = alt_ticks_per_second() / 10; /* Call every 100ms */
   24a70:	1007883a 	mov	r3,r2
   24a74:	00800284 	movi	r2,10
   24a78:	1885203a 	divu	r2,r3,r2
   24a7c:	1007883a 	mov	r3,r2
   24a80:	e0bfff17 	ldw	r2,-4(fp)
   24a84:	10c00715 	stw	r3,28(r2)

  alt_alarm_start(&sp->alarm, sp->period, &alt_lcd_16207_timeout, sp);
   24a88:	e0bfff17 	ldw	r2,-4(fp)
   24a8c:	10c00104 	addi	r3,r2,4
   24a90:	e0bfff17 	ldw	r2,-4(fp)
   24a94:	10800717 	ldw	r2,28(r2)
   24a98:	1809883a 	mov	r4,r3
   24a9c:	100b883a 	mov	r5,r2
   24aa0:	018000b4 	movhi	r6,2
   24aa4:	31923804 	addi	r6,r6,18656
   24aa8:	e1ffff17 	ldw	r7,-4(fp)
   24aac:	002055c0 	call	2055c <alt_alarm_start>
}
   24ab0:	e037883a 	mov	sp,fp
   24ab4:	dfc00117 	ldw	ra,4(sp)
   24ab8:	df000017 	ldw	fp,0(sp)
   24abc:	dec00204 	addi	sp,sp,8
   24ac0:	f800283a 	ret

00024ac4 <altera_avalon_lcd_16207_write_fd>:
extern int altera_avalon_lcd_16207_write(altera_avalon_lcd_16207_state* sp,
  const char* ptr, int count, int flags);

int 
altera_avalon_lcd_16207_write_fd(alt_fd* fd, const char* buffer, int space)
{
   24ac4:	defffa04 	addi	sp,sp,-24
   24ac8:	dfc00515 	stw	ra,20(sp)
   24acc:	df000415 	stw	fp,16(sp)
   24ad0:	df000404 	addi	fp,sp,16
   24ad4:	e13ffd15 	stw	r4,-12(fp)
   24ad8:	e17ffe15 	stw	r5,-8(fp)
   24adc:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_lcd_16207_dev* dev = (altera_avalon_lcd_16207_dev*) fd->dev; 
   24ae0:	e0bffd17 	ldw	r2,-12(fp)
   24ae4:	10800017 	ldw	r2,0(r2)
   24ae8:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_lcd_16207_write(&dev->state, buffer, space,
   24aec:	e0bffc17 	ldw	r2,-16(fp)
   24af0:	10c00a04 	addi	r3,r2,40
      fd->fd_flags);
   24af4:	e0bffd17 	ldw	r2,-12(fp)
int 
altera_avalon_lcd_16207_write_fd(alt_fd* fd, const char* buffer, int space)
{
    altera_avalon_lcd_16207_dev* dev = (altera_avalon_lcd_16207_dev*) fd->dev; 

    return altera_avalon_lcd_16207_write(&dev->state, buffer, space,
   24af8:	10800217 	ldw	r2,8(r2)
   24afc:	1809883a 	mov	r4,r3
   24b00:	e17ffe17 	ldw	r5,-8(fp)
   24b04:	e1bfff17 	ldw	r6,-4(fp)
   24b08:	100f883a 	mov	r7,r2
   24b0c:	00243fc0 	call	243fc <altera_avalon_lcd_16207_write>
      fd->fd_flags);
}
   24b10:	e037883a 	mov	sp,fp
   24b14:	dfc00117 	ldw	ra,4(sp)
   24b18:	df000017 	ldw	fp,0(sp)
   24b1c:	dec00204 	addi	sp,sp,8
   24b20:	f800283a 	ret

00024b24 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   24b24:	defffe04 	addi	sp,sp,-8
   24b28:	dfc00115 	stw	ra,4(sp)
   24b2c:	df000015 	stw	fp,0(sp)
   24b30:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   24b34:	008000f4 	movhi	r2,3
   24b38:	10910004 	addi	r2,r2,17408
   24b3c:	10800017 	ldw	r2,0(r2)
   24b40:	10000526 	beq	r2,zero,24b58 <alt_get_errno+0x34>
   24b44:	008000f4 	movhi	r2,3
   24b48:	10910004 	addi	r2,r2,17408
   24b4c:	10800017 	ldw	r2,0(r2)
   24b50:	103ee83a 	callr	r2
   24b54:	00000206 	br	24b60 <alt_get_errno+0x3c>
   24b58:	008000f4 	movhi	r2,3
   24b5c:	1099dd04 	addi	r2,r2,26484
}
   24b60:	e037883a 	mov	sp,fp
   24b64:	dfc00117 	ldw	ra,4(sp)
   24b68:	df000017 	ldw	fp,0(sp)
   24b6c:	dec00204 	addi	sp,sp,8
   24b70:	f800283a 	ret

00024b74 <alt_avalon_sgdma_do_async_transfer>:
 * - 0 for success, or various errors defined in <errno.h>
 */
int alt_avalon_sgdma_do_async_transfer(
  alt_sgdma_dev *dev,
  alt_sgdma_descriptor *desc)
{
   24b74:	defffc04 	addi	sp,sp,-16
   24b78:	df000315 	stw	fp,12(sp)
   24b7c:	df000304 	addi	fp,sp,12
   24b80:	e13ffe15 	stw	r4,-8(fp)
   24b84:	e17fff15 	stw	r5,-4(fp)
  alt_u32 control;

  /* Return with error immediately if controller is busy */
  if( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
   24b88:	e0bffe17 	ldw	r2,-8(fp)
   24b8c:	10800317 	ldw	r2,12(r2)
   24b90:	10800037 	ldwio	r2,0(r2)
   24b94:	1080040c 	andi	r2,r2,16
   24b98:	10000226 	beq	r2,zero,24ba4 <alt_avalon_sgdma_do_async_transfer+0x30>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    return -EBUSY;
   24b9c:	00bffc04 	movi	r2,-16
   24ba0:	00003906 	br	24c88 <alt_avalon_sgdma_do_async_transfer+0x114>
  }

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
   24ba4:	e0bffe17 	ldw	r2,-8(fp)
   24ba8:	10800317 	ldw	r2,12(r2)
   24bac:	10800404 	addi	r2,r2,16
   24bb0:	e0fffe17 	ldw	r3,-8(fp)
   24bb4:	18c00317 	ldw	r3,12(r3)
   24bb8:	18c00404 	addi	r3,r3,16
   24bbc:	19000037 	ldwio	r4,0(r3)
   24bc0:	00fff7c4 	movi	r3,-33
   24bc4:	20c6703a 	and	r3,r4,r3
   24bc8:	10c00035 	stwio	r3,0(r2)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
   24bcc:	e0bffe17 	ldw	r2,-8(fp)
   24bd0:	10800317 	ldw	r2,12(r2)
   24bd4:	00c03fc4 	movi	r3,255
   24bd8:	10c00035 	stwio	r3,0(r2)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
   24bdc:	e0bffe17 	ldw	r2,-8(fp)
   24be0:	10800317 	ldw	r2,12(r2)
   24be4:	10800804 	addi	r2,r2,32
   24be8:	e0ffff17 	ldw	r3,-4(fp)
   24bec:	10c00035 	stwio	r3,0(r2)
   *  - Stop on an error with any particular descriptor
   *  - Include any control register bits registered with along with
   *    the callback routine (effectively, interrupts are controlled
   *    via the control bits set during callback-register time).
   */
  if(dev->callback) {
   24bf0:	e0bffe17 	ldw	r2,-8(fp)
   24bf4:	10800917 	ldw	r2,36(r2)
   24bf8:	10001126 	beq	r2,zero,24c40 <alt_avalon_sgdma_do_async_transfer+0xcc>
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
   24bfc:	e0bffe17 	ldw	r2,-8(fp)
   24c00:	10800317 	ldw	r2,12(r2)
   24c04:	10800404 	addi	r2,r2,16
   24c08:	10800037 	ldwio	r2,0(r2)
   24c0c:	e0bffd15 	stw	r2,-12(fp)

    control |= (dev->chain_control                          |
   24c10:	e0bffe17 	ldw	r2,-8(fp)
   24c14:	10c00b17 	ldw	r3,44(r2)
   24c18:	e0bffd17 	ldw	r2,-12(fp)
   24c1c:	1884b03a 	or	r2,r3,r2
   24c20:	10801814 	ori	r2,r2,96
   24c24:	e0bffd15 	stw	r2,-12(fp)
                ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK  );

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
   24c28:	e0bffe17 	ldw	r2,-8(fp)
   24c2c:	10800317 	ldw	r2,12(r2)
   24c30:	10800404 	addi	r2,r2,16
   24c34:	e0fffd17 	ldw	r3,-12(fp)
   24c38:	10c00035 	stwio	r3,0(r2)
   24c3c:	00001106 	br	24c84 <alt_avalon_sgdma_do_async_transfer+0x110>
   *   - Run
   *   - Stop on an error with any particular descriptor
   *   - Disable interrupt generation
   */
  else {
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
   24c40:	e0bffe17 	ldw	r2,-8(fp)
   24c44:	10800317 	ldw	r2,12(r2)
   24c48:	10800404 	addi	r2,r2,16
   24c4c:	10800037 	ldwio	r2,0(r2)
   24c50:	e0bffd15 	stw	r2,-12(fp)

    control |= (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
   24c54:	e0bffd17 	ldw	r2,-12(fp)
   24c58:	10801814 	ori	r2,r2,96
   24c5c:	e0bffd15 	stw	r2,-12(fp)
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK );
    control &= ~ALTERA_AVALON_SGDMA_CONTROL_IE_GLOBAL_MSK;
   24c60:	e0fffd17 	ldw	r3,-12(fp)
   24c64:	00bffbc4 	movi	r2,-17
   24c68:	1884703a 	and	r2,r3,r2
   24c6c:	e0bffd15 	stw	r2,-12(fp)

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
   24c70:	e0bffe17 	ldw	r2,-8(fp)
   24c74:	10800317 	ldw	r2,12(r2)
   24c78:	10800404 	addi	r2,r2,16
   24c7c:	e0fffd17 	ldw	r3,-12(fp)
   24c80:	10c00035 	stwio	r3,0(r2)

  /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
  return 0;
   24c84:	0005883a 	mov	r2,zero
}
   24c88:	e037883a 	mov	sp,fp
   24c8c:	df000017 	ldw	fp,0(sp)
   24c90:	dec00104 	addi	sp,sp,4
   24c94:	f800283a 	ret

00024c98 <alt_avalon_sgdma_do_sync_transfer>:
 * - status: Content of SGDMA status register.
 */
alt_u8 alt_avalon_sgdma_do_sync_transfer(
  alt_sgdma_dev *dev,
  alt_sgdma_descriptor *desc)
{
   24c98:	defffc04 	addi	sp,sp,-16
   24c9c:	df000315 	stw	fp,12(sp)
   24ca0:	df000304 	addi	fp,sp,12
   24ca4:	e13ffe15 	stw	r4,-8(fp)
   24ca8:	e17fff15 	stw	r5,-4(fp)
  alt_u8 status;

  /* Wait for any pending transfers to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
   24cac:	0001883a 	nop
   24cb0:	e0bffe17 	ldw	r2,-8(fp)
   24cb4:	10800317 	ldw	r2,12(r2)
   24cb8:	10800037 	ldwio	r2,0(r2)
   24cbc:	1080040c 	andi	r2,r2,16
   24cc0:	103ffb1e 	bne	r2,zero,24cb0 <alt_avalon_sgdma_do_sync_transfer+0x18>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );


  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
   24cc4:	e0bffe17 	ldw	r2,-8(fp)
   24cc8:	10800317 	ldw	r2,12(r2)
   24ccc:	10800404 	addi	r2,r2,16
   24cd0:	e0fffe17 	ldw	r3,-8(fp)
   24cd4:	18c00317 	ldw	r3,12(r3)
   24cd8:	18c00404 	addi	r3,r3,16
   24cdc:	19000037 	ldwio	r4,0(r3)
   24ce0:	00fff7c4 	movi	r3,-33
   24ce4:	20c6703a 	and	r3,r4,r3
   24ce8:	10c00035 	stwio	r3,0(r2)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
   24cec:	e0bffe17 	ldw	r2,-8(fp)
   24cf0:	10800317 	ldw	r2,12(r2)
   24cf4:	00c03fc4 	movi	r3,255
   24cf8:	10c00035 	stwio	r3,0(r2)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
   24cfc:	e0bffe17 	ldw	r2,-8(fp)
   24d00:	10800317 	ldw	r2,12(r2)
   24d04:	10800804 	addi	r2,r2,32
   24d08:	e0ffff17 	ldw	r3,-4(fp)
   24d0c:	10c00035 	stwio	r3,0(r2)
   * Set up SGDMA controller to:
   * - Disable interrupt generation
   * - Run once a valid descriptor is written to controller
   * - Stop on an error with any particular descriptor
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
   24d10:	e0bffe17 	ldw	r2,-8(fp)
   24d14:	10800317 	ldw	r2,12(r2)
   24d18:	10800404 	addi	r2,r2,16
   24d1c:	e0fffe17 	ldw	r3,-8(fp)
   24d20:	18c00317 	ldw	r3,12(r3)
   24d24:	18c00404 	addi	r3,r3,16
   24d28:	18c00037 	ldwio	r3,0(r3)
   24d2c:	18c01814 	ori	r3,r3,96
   24d30:	10c00035 	stwio	r3,0(r2)
    (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK |
     ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK | 
     IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base)) );

  /* Wait for the descriptor (chain) to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
   24d34:	0001883a 	nop
   24d38:	e0bffe17 	ldw	r2,-8(fp)
   24d3c:	10800317 	ldw	r2,12(r2)
   24d40:	10800037 	ldwio	r2,0(r2)
   24d44:	1080040c 	andi	r2,r2,16
   24d48:	103ffb1e 	bne	r2,zero,24d38 <alt_avalon_sgdma_do_sync_transfer+0xa0>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
   24d4c:	e0bffe17 	ldw	r2,-8(fp)
   24d50:	10800317 	ldw	r2,12(r2)
   24d54:	10800404 	addi	r2,r2,16
   24d58:	e0fffe17 	ldw	r3,-8(fp)
   24d5c:	18c00317 	ldw	r3,12(r3)
   24d60:	18c00404 	addi	r3,r3,16
   24d64:	19000037 	ldwio	r4,0(r3)
   24d68:	00fff7c4 	movi	r3,-33
   24d6c:	20c6703a 	and	r3,r4,r3
   24d70:	10c00035 	stwio	r3,0(r2)
    (IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) &
     ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK) );

  /* Get & clear status register contents */
  status = IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base);
   24d74:	e0bffe17 	ldw	r2,-8(fp)
   24d78:	10800317 	ldw	r2,12(r2)
   24d7c:	10800037 	ldwio	r2,0(r2)
   24d80:	e0bffd05 	stb	r2,-12(fp)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
   24d84:	e0bffe17 	ldw	r2,-8(fp)
   24d88:	10800317 	ldw	r2,12(r2)
   24d8c:	00c03fc4 	movi	r3,255
   24d90:	10c00035 	stwio	r3,0(r2)

  return status;
   24d94:	e0bffd03 	ldbu	r2,-12(fp)
}
   24d98:	e037883a 	mov	sp,fp
   24d9c:	df000017 	ldw	fp,0(sp)
   24da0:	dec00104 	addi	sp,sp,4
   24da4:	f800283a 	ret

00024da8 <alt_avalon_sgdma_construct_mem_to_mem_desc>:
  alt_u32              *read_addr,
  alt_u32              *write_addr,
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed)
{
   24da8:	defff404 	addi	sp,sp,-48
   24dac:	dfc00b15 	stw	ra,44(sp)
   24db0:	df000a15 	stw	fp,40(sp)
   24db4:	df000a04 	addi	fp,sp,40
   24db8:	e13ffb15 	stw	r4,-20(fp)
   24dbc:	e17ffc15 	stw	r5,-16(fp)
   24dc0:	e1bffd15 	stw	r6,-12(fp)
   24dc4:	e1fffe15 	stw	r7,-8(fp)
   24dc8:	e0800217 	ldw	r2,8(fp)
   24dcc:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_mem_to_mem_desc_burst(desc, next, read_addr, 
   24dd0:	e0bfff0b 	ldhu	r2,-4(fp)
   24dd4:	d8800015 	stw	r2,0(sp)
   24dd8:	e0800317 	ldw	r2,12(fp)
   24ddc:	d8800115 	stw	r2,4(sp)
   24de0:	e0800417 	ldw	r2,16(fp)
   24de4:	d8800215 	stw	r2,8(sp)
   24de8:	d8000315 	stw	zero,12(sp)
   24dec:	d8000415 	stw	zero,16(sp)
   24df0:	e13ffb17 	ldw	r4,-20(fp)
   24df4:	e17ffc17 	ldw	r5,-16(fp)
   24df8:	e1bffd17 	ldw	r6,-12(fp)
   24dfc:	e1fffe17 	ldw	r7,-8(fp)
   24e00:	0024e180 	call	24e18 <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>
    write_addr, length, read_fixed, write_fixed, 0, 0);
}
   24e04:	e037883a 	mov	sp,fp
   24e08:	dfc00117 	ldw	ra,4(sp)
   24e0c:	df000017 	ldw	fp,0(sp)
   24e10:	dec00204 	addi	sp,sp,8
   24e14:	f800283a 	ret

00024e18 <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>:
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed,
  int                   read_burst,
  int                   write_burst)
{
   24e18:	defff204 	addi	sp,sp,-56
   24e1c:	dfc00d15 	stw	ra,52(sp)
   24e20:	df000c15 	stw	fp,48(sp)
   24e24:	df000c04 	addi	fp,sp,48
   24e28:	e13ffb15 	stw	r4,-20(fp)
   24e2c:	e17ffc15 	stw	r5,-16(fp)
   24e30:	e1bffd15 	stw	r6,-12(fp)
   24e34:	e1fffe15 	stw	r7,-8(fp)
   24e38:	e0800217 	ldw	r2,8(fp)
   24e3c:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
   24e40:	e0bfff0b 	ldhu	r2,-4(fp)
   24e44:	d8800015 	stw	r2,0(sp)
   24e48:	d8000115 	stw	zero,4(sp)
   24e4c:	e0800317 	ldw	r2,12(fp)
   24e50:	d8800215 	stw	r2,8(sp)
   24e54:	e0800417 	ldw	r2,16(fp)
   24e58:	d8800315 	stw	r2,12(sp)
   24e5c:	e0800517 	ldw	r2,20(fp)
   24e60:	d8800415 	stw	r2,16(sp)
   24e64:	e0800617 	ldw	r2,24(fp)
   24e68:	d8800515 	stw	r2,20(sp)
   24e6c:	d8000615 	stw	zero,24(sp)
   24e70:	e13ffb17 	ldw	r4,-20(fp)
   24e74:	e17ffc17 	ldw	r5,-16(fp)
   24e78:	e1bffd17 	ldw	r6,-12(fp)
   24e7c:	e1fffe17 	ldw	r7,-8(fp)
   24e80:	00253840 	call	25384 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    write_fixed,
    read_burst,
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in mem-to-mem mode
}
   24e84:	e037883a 	mov	sp,fp
   24e88:	dfc00117 	ldw	ra,4(sp)
   24e8c:	df000017 	ldw	fp,0(sp)
   24e90:	dec00204 	addi	sp,sp,8
   24e94:	f800283a 	ret

00024e98 <alt_avalon_sgdma_construct_stream_to_mem_desc>:
  alt_sgdma_descriptor *desc,
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed)
{
   24e98:	defff804 	addi	sp,sp,-32
   24e9c:	dfc00715 	stw	ra,28(sp)
   24ea0:	df000615 	stw	fp,24(sp)
   24ea4:	df000604 	addi	fp,sp,24
   24ea8:	e13ffc15 	stw	r4,-16(fp)
   24eac:	e17ffd15 	stw	r5,-12(fp)
   24eb0:	e1bffe15 	stw	r6,-8(fp)
   24eb4:	3805883a 	mov	r2,r7
   24eb8:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_stream_to_mem_desc_burst(desc, next, write_addr, 
   24ebc:	e0bfff0b 	ldhu	r2,-4(fp)
   24ec0:	e0c00217 	ldw	r3,8(fp)
   24ec4:	d8c00015 	stw	r3,0(sp)
   24ec8:	d8000115 	stw	zero,4(sp)
   24ecc:	e13ffc17 	ldw	r4,-16(fp)
   24ed0:	e17ffd17 	ldw	r5,-12(fp)
   24ed4:	e1bffe17 	ldw	r6,-8(fp)
   24ed8:	100f883a 	mov	r7,r2
   24edc:	0024ef40 	call	24ef4 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>
    length_or_eop, write_fixed, 0);
}
   24ee0:	e037883a 	mov	sp,fp
   24ee4:	dfc00117 	ldw	ra,4(sp)
   24ee8:	df000017 	ldw	fp,0(sp)
   24eec:	dec00204 	addi	sp,sp,8
   24ef0:	f800283a 	ret

00024ef4 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>:
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed,
  int                   write_burst)
{
   24ef4:	defff304 	addi	sp,sp,-52
   24ef8:	dfc00c15 	stw	ra,48(sp)
   24efc:	df000b15 	stw	fp,44(sp)
   24f00:	df000b04 	addi	fp,sp,44
   24f04:	e13ffc15 	stw	r4,-16(fp)
   24f08:	e17ffd15 	stw	r5,-12(fp)
   24f0c:	e1bffe15 	stw	r6,-8(fp)
   24f10:	3805883a 	mov	r2,r7
   24f14:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
   24f18:	e0bfff0b 	ldhu	r2,-4(fp)
   24f1c:	d8800015 	stw	r2,0(sp)
   24f20:	d8000115 	stw	zero,4(sp)
   24f24:	d8000215 	stw	zero,8(sp)
   24f28:	e0800217 	ldw	r2,8(fp)
   24f2c:	d8800315 	stw	r2,12(sp)
   24f30:	d8000415 	stw	zero,16(sp)
   24f34:	e0800317 	ldw	r2,12(fp)
   24f38:	d8800515 	stw	r2,20(sp)
   24f3c:	d8000615 	stw	zero,24(sp)
   24f40:	e13ffc17 	ldw	r4,-16(fp)
   24f44:	e17ffd17 	ldw	r5,-12(fp)
   24f48:	000d883a 	mov	r6,zero
   24f4c:	e1fffe17 	ldw	r7,-8(fp)
   24f50:	00253840 	call	25384 <alt_avalon_sgdma_construct_descriptor_burst>
    0x0,            // Read fixed: N/A in stream-to-mem mode
    write_fixed,
    0,              // Read_burst : N/A in stream-to-mem mode
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in stream-to-mem mode
}
   24f54:	e037883a 	mov	sp,fp
   24f58:	dfc00117 	ldw	ra,4(sp)
   24f5c:	df000017 	ldw	fp,0(sp)
   24f60:	dec00204 	addi	sp,sp,8
   24f64:	f800283a 	ret

00024f68 <alt_avalon_sgdma_construct_mem_to_stream_desc>:
  alt_u16               length,
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  alt_u8                atlantic_channel)
{
   24f68:	defff404 	addi	sp,sp,-48
   24f6c:	dfc00b15 	stw	ra,44(sp)
   24f70:	df000a15 	stw	fp,40(sp)
   24f74:	df000a04 	addi	fp,sp,40
   24f78:	e13ffb15 	stw	r4,-20(fp)
   24f7c:	e17ffc15 	stw	r5,-16(fp)
   24f80:	e1bffd15 	stw	r6,-12(fp)
   24f84:	3805883a 	mov	r2,r7
   24f88:	e0c00517 	ldw	r3,20(fp)
   24f8c:	e0bffe0d 	sth	r2,-8(fp)
   24f90:	e0ffff05 	stb	r3,-4(fp)
  alt_avalon_sgdma_construct_mem_to_stream_desc_burst(desc, next, read_addr, 
   24f94:	e0bffe0b 	ldhu	r2,-8(fp)
   24f98:	e0ffff03 	ldbu	r3,-4(fp)
   24f9c:	e1000217 	ldw	r4,8(fp)
   24fa0:	d9000015 	stw	r4,0(sp)
   24fa4:	e1000317 	ldw	r4,12(fp)
   24fa8:	d9000115 	stw	r4,4(sp)
   24fac:	e1000417 	ldw	r4,16(fp)
   24fb0:	d9000215 	stw	r4,8(sp)
   24fb4:	d8000315 	stw	zero,12(sp)
   24fb8:	d8c00415 	stw	r3,16(sp)
   24fbc:	e13ffb17 	ldw	r4,-20(fp)
   24fc0:	e17ffc17 	ldw	r5,-16(fp)
   24fc4:	e1bffd17 	ldw	r6,-12(fp)
   24fc8:	100f883a 	mov	r7,r2
   24fcc:	0024fe40 	call	24fe4 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>
    length, read_fixed, generate_sop, generate_eop, 0, atlantic_channel);

}
   24fd0:	e037883a 	mov	sp,fp
   24fd4:	dfc00117 	ldw	ra,4(sp)
   24fd8:	df000017 	ldw	fp,0(sp)
   24fdc:	dec00204 	addi	sp,sp,8
   24fe0:	f800283a 	ret

00024fe4 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>:
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  int                   read_burst,
  alt_u8                atlantic_channel)
{
   24fe4:	defff204 	addi	sp,sp,-56
   24fe8:	dfc00d15 	stw	ra,52(sp)
   24fec:	df000c15 	stw	fp,48(sp)
   24ff0:	df000c04 	addi	fp,sp,48
   24ff4:	e13ffb15 	stw	r4,-20(fp)
   24ff8:	e17ffc15 	stw	r5,-16(fp)
   24ffc:	e1bffd15 	stw	r6,-12(fp)
   25000:	3805883a 	mov	r2,r7
   25004:	e0c00617 	ldw	r3,24(fp)
   25008:	e0bffe0d 	sth	r2,-8(fp)
   2500c:	e0ffff05 	stb	r3,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
   25010:	e0fffe0b 	ldhu	r3,-8(fp)
   25014:	e0bfff03 	ldbu	r2,-4(fp)
   25018:	d8c00015 	stw	r3,0(sp)
   2501c:	e0c00417 	ldw	r3,16(fp)
   25020:	d8c00115 	stw	r3,4(sp)
   25024:	e0c00217 	ldw	r3,8(fp)
   25028:	d8c00215 	stw	r3,8(sp)
   2502c:	e0c00317 	ldw	r3,12(fp)
   25030:	d8c00315 	stw	r3,12(sp)
   25034:	e0c00517 	ldw	r3,20(fp)
   25038:	d8c00415 	stw	r3,16(sp)
   2503c:	d8000515 	stw	zero,20(sp)
   25040:	d8800615 	stw	r2,24(sp)
   25044:	e13ffb17 	ldw	r4,-20(fp)
   25048:	e17ffc17 	ldw	r5,-16(fp)
   2504c:	e1bffd17 	ldw	r6,-12(fp)
   25050:	000f883a 	mov	r7,zero
   25054:	00253840 	call	25384 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    generate_sop,
    read_burst,
    0,                 // Write_burst : N/A in mem-to-stream mode
    atlantic_channel);
}
   25058:	e037883a 	mov	sp,fp
   2505c:	dfc00117 	ldw	ra,4(sp)
   25060:	df000017 	ldw	fp,0(sp)
   25064:	dec00204 	addi	sp,sp,8
   25068:	f800283a 	ret

0002506c <alt_avalon_sgdma_register_callback>:
void alt_avalon_sgdma_register_callback(
  alt_sgdma_dev *dev,
  alt_avalon_sgdma_callback callback,
  alt_u32 chain_control,
  void *context)
{
   2506c:	defffb04 	addi	sp,sp,-20
   25070:	df000415 	stw	fp,16(sp)
   25074:	df000404 	addi	fp,sp,16
   25078:	e13ffc15 	stw	r4,-16(fp)
   2507c:	e17ffd15 	stw	r5,-12(fp)
   25080:	e1bffe15 	stw	r6,-8(fp)
   25084:	e1ffff15 	stw	r7,-4(fp)
  dev->callback         = callback;
   25088:	e0bffc17 	ldw	r2,-16(fp)
   2508c:	e0fffd17 	ldw	r3,-12(fp)
   25090:	10c00915 	stw	r3,36(r2)
  dev->callback_context = context;
   25094:	e0bffc17 	ldw	r2,-16(fp)
   25098:	e0ffff17 	ldw	r3,-4(fp)
   2509c:	10c00a15 	stw	r3,40(r2)
  dev->chain_control    = chain_control;
   250a0:	e0bffc17 	ldw	r2,-16(fp)
   250a4:	e0fffe17 	ldw	r3,-8(fp)
   250a8:	10c00b15 	stw	r3,44(r2)
}
   250ac:	e037883a 	mov	sp,fp
   250b0:	df000017 	ldw	fp,0(sp)
   250b4:	dec00104 	addi	sp,sp,4
   250b8:	f800283a 	ret

000250bc <alt_avalon_sgdma_start>:
 *
 * Arguments:
 * - *dev: Pointer to SGDMA device (instance) struct.
 */
void alt_avalon_sgdma_start(alt_sgdma_dev *dev)
{
   250bc:	defffd04 	addi	sp,sp,-12
   250c0:	df000215 	stw	fp,8(sp)
   250c4:	df000204 	addi	fp,sp,8
   250c8:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
   250cc:	e0bfff17 	ldw	r2,-4(fp)
   250d0:	10800317 	ldw	r2,12(r2)
   250d4:	10800404 	addi	r2,r2,16
   250d8:	10800037 	ldwio	r2,0(r2)
   250dc:	e0bffe15 	stw	r2,-8(fp)
  control |= ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
   250e0:	e0bffe17 	ldw	r2,-8(fp)
   250e4:	10800814 	ori	r2,r2,32
   250e8:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
   250ec:	e0bfff17 	ldw	r2,-4(fp)
   250f0:	10800317 	ldw	r2,12(r2)
   250f4:	10800404 	addi	r2,r2,16
   250f8:	e0fffe17 	ldw	r3,-8(fp)
   250fc:	10c00035 	stwio	r3,0(r2)
}
   25100:	e037883a 	mov	sp,fp
   25104:	df000017 	ldw	fp,0(sp)
   25108:	dec00104 	addi	sp,sp,4
   2510c:	f800283a 	ret

00025110 <alt_avalon_sgdma_stop>:
 *
 * Arguments:
 * - *dev: Pointer to SGDMA device (instance) struct
 */
void alt_avalon_sgdma_stop(alt_sgdma_dev *dev)
{
   25110:	defffd04 	addi	sp,sp,-12
   25114:	df000215 	stw	fp,8(sp)
   25118:	df000204 	addi	fp,sp,8
   2511c:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
   25120:	e0bfff17 	ldw	r2,-4(fp)
   25124:	10800317 	ldw	r2,12(r2)
   25128:	10800404 	addi	r2,r2,16
   2512c:	10800037 	ldwio	r2,0(r2)
   25130:	e0bffe15 	stw	r2,-8(fp)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
   25134:	e0fffe17 	ldw	r3,-8(fp)
   25138:	00bff7c4 	movi	r2,-33
   2513c:	1884703a 	and	r2,r3,r2
   25140:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
   25144:	e0bfff17 	ldw	r2,-4(fp)
   25148:	10800317 	ldw	r2,12(r2)
   2514c:	10800404 	addi	r2,r2,16
   25150:	e0fffe17 	ldw	r3,-8(fp)
   25154:	10c00035 	stwio	r3,0(r2)
}
   25158:	e037883a 	mov	sp,fp
   2515c:	df000017 	ldw	fp,0(sp)
   25160:	dec00104 	addi	sp,sp,4
   25164:	f800283a 	ret

00025168 <alt_avalon_sgdma_check_descriptor_status>:
 * - 0 if the descriptor is error-free, not "owned by hardware", or
 *   a previously requested transfer has appeared to have completed
 *   normally. Or, various error conditions defined in <errno.h>
 */
int alt_avalon_sgdma_check_descriptor_status(alt_sgdma_descriptor *desc)
{
   25168:	defffe04 	addi	sp,sp,-8
   2516c:	df000115 	stw	fp,4(sp)
   25170:	df000104 	addi	fp,sp,4
   25174:	e13fff15 	stw	r4,-4(fp)
  /* Errors take precedence */
  if( IORD_8DIRECT(&desc->status, 0) &
   25178:	e0bfff17 	ldw	r2,-4(fp)
   2517c:	10800784 	addi	r2,r2,30
   25180:	10800023 	ldbuio	r2,0(r2)
   25184:	10803fcc 	andi	r2,r2,255
   25188:	10801fcc 	andi	r2,r2,127
   2518c:	10000226 	beq	r2,zero,25198 <alt_avalon_sgdma_check_descriptor_status+0x30>
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_OVERFLOW_MSK |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) {
    return -EIO;
   25190:	00bffec4 	movi	r2,-5
   25194:	00000906 	br	251bc <alt_avalon_sgdma_check_descriptor_status+0x54>
  }

  if( IORD_8DIRECT(&desc->control, 0) &
   25198:	e0bfff17 	ldw	r2,-4(fp)
   2519c:	108007c4 	addi	r2,r2,31
   251a0:	10800023 	ldbuio	r2,0(r2)
   251a4:	10803fcc 	andi	r2,r2,255
   251a8:	1080200c 	andi	r2,r2,128
   251ac:	10000226 	beq	r2,zero,251b8 <alt_avalon_sgdma_check_descriptor_status+0x50>
      ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK) {
    return -EINPROGRESS;
   251b0:	00bfe244 	movi	r2,-119
   251b4:	00000106 	br	251bc <alt_avalon_sgdma_check_descriptor_status+0x54>
  }

    return 0;
   251b8:	0005883a 	mov	r2,zero
}
   251bc:	e037883a 	mov	sp,fp
   251c0:	df000017 	ldw	fp,0(sp)
   251c4:	dec00104 	addi	sp,sp,4
   251c8:	f800283a 	ret

000251cc <alt_avalon_sgdma_open>:
 * Returns:
 * - Pointer to SGDMA device instance struct, or null if the device
 *   could not be opened.
 */
alt_sgdma_dev* alt_avalon_sgdma_open (const char* name)
{
   251cc:	defffc04 	addi	sp,sp,-16
   251d0:	dfc00315 	stw	ra,12(sp)
   251d4:	df000215 	stw	fp,8(sp)
   251d8:	df000204 	addi	fp,sp,8
   251dc:	e13fff15 	stw	r4,-4(fp)
  alt_sgdma_dev* dev;

  dev = (alt_sgdma_dev*) alt_find_dev (name, &alt_sgdma_list);
   251e0:	e13fff17 	ldw	r4,-4(fp)
   251e4:	d1601904 	addi	r5,gp,-32668
   251e8:	002ba900 	call	2ba90 <alt_find_dev>
   251ec:	e0bffe15 	stw	r2,-8(fp)

  if (NULL == dev) {
   251f0:	e0bffe17 	ldw	r2,-8(fp)
   251f4:	1000031e 	bne	r2,zero,25204 <alt_avalon_sgdma_open+0x38>
    ALT_ERRNO = ENODEV;
   251f8:	0024b240 	call	24b24 <alt_get_errno>
   251fc:	00c004c4 	movi	r3,19
   25200:	10c00015 	stw	r3,0(r2)
  }

  return dev;
   25204:	e0bffe17 	ldw	r2,-8(fp)
}
   25208:	e037883a 	mov	sp,fp
   2520c:	dfc00117 	ldw	ra,4(sp)
   25210:	df000017 	ldw	fp,0(sp)
   25214:	dec00204 	addi	sp,sp,8
   25218:	f800283a 	ret

0002521c <alt_avalon_sgdma_construct_descriptor>:
  alt_u16               length_or_eop,
  int                   generate_eop,
  int                   read_fixed,
  int                   write_fixed_or_sop,
  alt_u8                atlantic_channel)
{
   2521c:	defff104 	addi	sp,sp,-60
   25220:	dfc00e15 	stw	ra,56(sp)
   25224:	df000d15 	stw	fp,52(sp)
   25228:	df000d04 	addi	fp,sp,52
   2522c:	e13ffa15 	stw	r4,-24(fp)
   25230:	e17ffb15 	stw	r5,-20(fp)
   25234:	e1bffc15 	stw	r6,-16(fp)
   25238:	e1fffd15 	stw	r7,-12(fp)
   2523c:	e0c00217 	ldw	r3,8(fp)
   25240:	e0800617 	ldw	r2,24(fp)
   25244:	e0fffe0d 	sth	r3,-8(fp)
   25248:	e0bfff05 	stb	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(desc, next, read_addr, 
   2524c:	e0fffe0b 	ldhu	r3,-8(fp)
   25250:	e0bfff03 	ldbu	r2,-4(fp)
   25254:	d8c00015 	stw	r3,0(sp)
   25258:	e0c00317 	ldw	r3,12(fp)
   2525c:	d8c00115 	stw	r3,4(sp)
   25260:	e0c00417 	ldw	r3,16(fp)
   25264:	d8c00215 	stw	r3,8(sp)
   25268:	e0c00517 	ldw	r3,20(fp)
   2526c:	d8c00315 	stw	r3,12(sp)
   25270:	d8000415 	stw	zero,16(sp)
   25274:	d8000515 	stw	zero,20(sp)
   25278:	d8800615 	stw	r2,24(sp)
   2527c:	e13ffa17 	ldw	r4,-24(fp)
   25280:	e17ffb17 	ldw	r5,-20(fp)
   25284:	e1bffc17 	ldw	r6,-16(fp)
   25288:	e1fffd17 	ldw	r7,-12(fp)
   2528c:	00253840 	call	25384 <alt_avalon_sgdma_construct_descriptor_burst>
    write_addr, length_or_eop, generate_eop, read_fixed, write_fixed_or_sop, 
    0, 0, atlantic_channel);
}
   25290:	e037883a 	mov	sp,fp
   25294:	dfc00117 	ldw	ra,4(sp)
   25298:	df000017 	ldw	fp,0(sp)
   2529c:	dec00204 	addi	sp,sp,8
   252a0:	f800283a 	ret

000252a4 <alt_avalon_sgdma_enable_desc_poll>:
 *
 * Returns:
 * - None
 */
void alt_avalon_sgdma_enable_desc_poll(alt_sgdma_dev *dev, alt_u32 frequency)
{
   252a4:	defffc04 	addi	sp,sp,-16
   252a8:	df000315 	stw	fp,12(sp)
   252ac:	df000304 	addi	fp,sp,12
   252b0:	e13ffe15 	stw	r4,-8(fp)
   252b4:	e17fff15 	stw	r5,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
   252b8:	e0bffe17 	ldw	r2,-8(fp)
   252bc:	10800317 	ldw	r2,12(r2)
   252c0:	10800404 	addi	r2,r2,16
   252c4:	10800037 	ldwio	r2,0(r2)
   252c8:	e0bffd15 	stw	r2,-12(fp)
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
   252cc:	e0fffd17 	ldw	r3,-12(fp)
   252d0:	00a00434 	movhi	r2,32784
   252d4:	10bfffc4 	addi	r2,r2,-1
   252d8:	1884703a 	and	r2,r3,r2
   252dc:	e0bffd15 	stw	r2,-12(fp)
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
   252e0:	e0bfff17 	ldw	r2,-4(fp)
   252e4:	1004953a 	slli	r2,r2,20
   252e8:	10dffc2c 	andhi	r3,r2,32752

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
   252ec:	e0bffd17 	ldw	r2,-12(fp)
   252f0:	1884b03a 	or	r2,r3,r2
   252f4:	10800134 	orhi	r2,r2,4
   252f8:	e0bffd15 	stw	r2,-12(fp)
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
            ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
   252fc:	e0bffe17 	ldw	r2,-8(fp)
   25300:	10800317 	ldw	r2,12(r2)
   25304:	10800404 	addi	r2,r2,16
   25308:	e0fffd17 	ldw	r3,-12(fp)
   2530c:	10c00035 	stwio	r3,0(r2)
  
  return;
   25310:	0001883a 	nop
}
   25314:	e037883a 	mov	sp,fp
   25318:	df000017 	ldw	fp,0(sp)
   2531c:	dec00104 	addi	sp,sp,4
   25320:	f800283a 	ret

00025324 <alt_avalon_sgdma_disable_desc_poll>:
 *
 * Returns:
 * - None
 */
void alt_avalon_sgdma_disable_desc_poll(alt_sgdma_dev *dev)
{
   25324:	defffd04 	addi	sp,sp,-12
   25328:	df000215 	stw	fp,8(sp)
   2532c:	df000204 	addi	fp,sp,8
   25330:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
   25334:	e0bfff17 	ldw	r2,-4(fp)
   25338:	10800317 	ldw	r2,12(r2)
   2533c:	10800404 	addi	r2,r2,16
   25340:	10800037 	ldwio	r2,0(r2)
   25344:	e0bffe15 	stw	r2,-8(fp)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK;
   25348:	e0fffe17 	ldw	r3,-8(fp)
   2534c:	00bfff34 	movhi	r2,65532
   25350:	10bfffc4 	addi	r2,r2,-1
   25354:	1884703a 	and	r2,r3,r2
   25358:	e0bffe15 	stw	r2,-8(fp)

  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
   2535c:	e0bfff17 	ldw	r2,-4(fp)
   25360:	10800317 	ldw	r2,12(r2)
   25364:	10800404 	addi	r2,r2,16
   25368:	e0fffe17 	ldw	r3,-8(fp)
   2536c:	10c00035 	stwio	r3,0(r2)
  
  return;
   25370:	0001883a 	nop
}
   25374:	e037883a 	mov	sp,fp
   25378:	df000017 	ldw	fp,0(sp)
   2537c:	dec00104 	addi	sp,sp,4
   25380:	f800283a 	ret

00025384 <alt_avalon_sgdma_construct_descriptor_burst>:
  int                   read_fixed,
  int                   write_fixed_or_sop,
  int                   read_burst,
  int                   write_burst,
  alt_u8                atlantic_channel)
{
   25384:	defff804 	addi	sp,sp,-32
   25388:	dfc00715 	stw	ra,28(sp)
   2538c:	df000615 	stw	fp,24(sp)
   25390:	df000604 	addi	fp,sp,24
   25394:	e13ffa15 	stw	r4,-24(fp)
   25398:	e17ffb15 	stw	r5,-20(fp)
   2539c:	e1bffc15 	stw	r6,-16(fp)
   253a0:	e1fffd15 	stw	r7,-12(fp)
   253a4:	e0c00217 	ldw	r3,8(fp)
   253a8:	e0800817 	ldw	r2,32(fp)
   253ac:	e0fffe0d 	sth	r3,-8(fp)
   253b0:	e0bfff05 	stb	r2,-4(fp)
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
   253b4:	e0bffb17 	ldw	r2,-20(fp)
   253b8:	108007c4 	addi	r2,r2,31
   253bc:	e0fffb17 	ldw	r3,-20(fp)
   253c0:	18c007c3 	ldbu	r3,31(r3)
   253c4:	19003fcc 	andi	r4,r3,255
   253c8:	00ffdfc4 	movi	r3,-129
   253cc:	20c6703a 	and	r3,r4,r3
   253d0:	10c00025 	stbio	r3,0(r2)
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
   253d4:	e0bffa17 	ldw	r2,-24(fp)
   253d8:	e0fffc17 	ldw	r3,-16(fp)
   253dc:	18c03fcc 	andi	r3,r3,255
   253e0:	11000003 	ldbu	r4,0(r2)
   253e4:	2008703a 	and	r4,r4,zero
   253e8:	20c6b03a 	or	r3,r4,r3
   253ec:	10c00005 	stb	r3,0(r2)
   253f0:	e0fffc17 	ldw	r3,-16(fp)
   253f4:	1806d23a 	srli	r3,r3,8
   253f8:	18c03fcc 	andi	r3,r3,255
   253fc:	11000043 	ldbu	r4,1(r2)
   25400:	2008703a 	and	r4,r4,zero
   25404:	20c6b03a 	or	r3,r4,r3
   25408:	10c00045 	stb	r3,1(r2)
   2540c:	e0fffc17 	ldw	r3,-16(fp)
   25410:	1806d43a 	srli	r3,r3,16
   25414:	18c03fcc 	andi	r3,r3,255
   25418:	11000083 	ldbu	r4,2(r2)
   2541c:	2008703a 	and	r4,r4,zero
   25420:	20c6b03a 	or	r3,r4,r3
   25424:	10c00085 	stb	r3,2(r2)
   25428:	e0fffc17 	ldw	r3,-16(fp)
   2542c:	1806d63a 	srli	r3,r3,24
   25430:	110000c3 	ldbu	r4,3(r2)
   25434:	2008703a 	and	r4,r4,zero
   25438:	20c6b03a 	or	r3,r4,r3
   2543c:	10c000c5 	stb	r3,3(r2)
  desc->write_addr               = write_addr;
   25440:	e0bffa17 	ldw	r2,-24(fp)
   25444:	e0fffd17 	ldw	r3,-12(fp)
   25448:	18c03fcc 	andi	r3,r3,255
   2544c:	11000203 	ldbu	r4,8(r2)
   25450:	2008703a 	and	r4,r4,zero
   25454:	20c6b03a 	or	r3,r4,r3
   25458:	10c00205 	stb	r3,8(r2)
   2545c:	e0fffd17 	ldw	r3,-12(fp)
   25460:	1806d23a 	srli	r3,r3,8
   25464:	18c03fcc 	andi	r3,r3,255
   25468:	11000243 	ldbu	r4,9(r2)
   2546c:	2008703a 	and	r4,r4,zero
   25470:	20c6b03a 	or	r3,r4,r3
   25474:	10c00245 	stb	r3,9(r2)
   25478:	e0fffd17 	ldw	r3,-12(fp)
   2547c:	1806d43a 	srli	r3,r3,16
   25480:	18c03fcc 	andi	r3,r3,255
   25484:	11000283 	ldbu	r4,10(r2)
   25488:	2008703a 	and	r4,r4,zero
   2548c:	20c6b03a 	or	r3,r4,r3
   25490:	10c00285 	stb	r3,10(r2)
   25494:	e0fffd17 	ldw	r3,-12(fp)
   25498:	1806d63a 	srli	r3,r3,24
   2549c:	110002c3 	ldbu	r4,11(r2)
   254a0:	2008703a 	and	r4,r4,zero
   254a4:	20c6b03a 	or	r3,r4,r3
   254a8:	10c002c5 	stb	r3,11(r2)
  desc->next                     = (alt_u32 *) next;
   254ac:	e0bffa17 	ldw	r2,-24(fp)
   254b0:	e0fffb17 	ldw	r3,-20(fp)
   254b4:	18c03fcc 	andi	r3,r3,255
   254b8:	11000403 	ldbu	r4,16(r2)
   254bc:	2008703a 	and	r4,r4,zero
   254c0:	20c6b03a 	or	r3,r4,r3
   254c4:	10c00405 	stb	r3,16(r2)
   254c8:	e0fffb17 	ldw	r3,-20(fp)
   254cc:	1806d23a 	srli	r3,r3,8
   254d0:	18c03fcc 	andi	r3,r3,255
   254d4:	11000443 	ldbu	r4,17(r2)
   254d8:	2008703a 	and	r4,r4,zero
   254dc:	20c6b03a 	or	r3,r4,r3
   254e0:	10c00445 	stb	r3,17(r2)
   254e4:	e0fffb17 	ldw	r3,-20(fp)
   254e8:	1806d43a 	srli	r3,r3,16
   254ec:	18c03fcc 	andi	r3,r3,255
   254f0:	11000483 	ldbu	r4,18(r2)
   254f4:	2008703a 	and	r4,r4,zero
   254f8:	20c6b03a 	or	r3,r4,r3
   254fc:	10c00485 	stb	r3,18(r2)
   25500:	e0fffb17 	ldw	r3,-20(fp)
   25504:	1806d63a 	srli	r3,r3,24
   25508:	110004c3 	ldbu	r4,19(r2)
   2550c:	2008703a 	and	r4,r4,zero
   25510:	20c6b03a 	or	r3,r4,r3
   25514:	10c004c5 	stb	r3,19(r2)
  desc->read_addr_pad            = 0x0;
   25518:	e0bffa17 	ldw	r2,-24(fp)
   2551c:	10c00103 	ldbu	r3,4(r2)
   25520:	1806703a 	and	r3,r3,zero
   25524:	10c00105 	stb	r3,4(r2)
   25528:	10c00143 	ldbu	r3,5(r2)
   2552c:	1806703a 	and	r3,r3,zero
   25530:	10c00145 	stb	r3,5(r2)
   25534:	10c00183 	ldbu	r3,6(r2)
   25538:	1806703a 	and	r3,r3,zero
   2553c:	10c00185 	stb	r3,6(r2)
   25540:	10c001c3 	ldbu	r3,7(r2)
   25544:	1806703a 	and	r3,r3,zero
   25548:	10c001c5 	stb	r3,7(r2)
  desc->write_addr_pad           = 0x0;
   2554c:	e0bffa17 	ldw	r2,-24(fp)
   25550:	10c00303 	ldbu	r3,12(r2)
   25554:	1806703a 	and	r3,r3,zero
   25558:	10c00305 	stb	r3,12(r2)
   2555c:	10c00343 	ldbu	r3,13(r2)
   25560:	1806703a 	and	r3,r3,zero
   25564:	10c00345 	stb	r3,13(r2)
   25568:	10c00383 	ldbu	r3,14(r2)
   2556c:	1806703a 	and	r3,r3,zero
   25570:	10c00385 	stb	r3,14(r2)
   25574:	10c003c3 	ldbu	r3,15(r2)
   25578:	1806703a 	and	r3,r3,zero
   2557c:	10c003c5 	stb	r3,15(r2)
  desc->next_pad                 = 0x0;
   25580:	e0bffa17 	ldw	r2,-24(fp)
   25584:	10c00503 	ldbu	r3,20(r2)
   25588:	1806703a 	and	r3,r3,zero
   2558c:	10c00505 	stb	r3,20(r2)
   25590:	10c00543 	ldbu	r3,21(r2)
   25594:	1806703a 	and	r3,r3,zero
   25598:	10c00545 	stb	r3,21(r2)
   2559c:	10c00583 	ldbu	r3,22(r2)
   255a0:	1806703a 	and	r3,r3,zero
   255a4:	10c00585 	stb	r3,22(r2)
   255a8:	10c005c3 	ldbu	r3,23(r2)
   255ac:	1806703a 	and	r3,r3,zero
   255b0:	10c005c5 	stb	r3,23(r2)
  desc->bytes_to_transfer        = length_or_eop;
   255b4:	e0bffa17 	ldw	r2,-24(fp)
   255b8:	e0fffe0b 	ldhu	r3,-8(fp)
   255bc:	18c03fcc 	andi	r3,r3,255
   255c0:	11000603 	ldbu	r4,24(r2)
   255c4:	2008703a 	and	r4,r4,zero
   255c8:	20c6b03a 	or	r3,r4,r3
   255cc:	10c00605 	stb	r3,24(r2)
   255d0:	e0fffe0b 	ldhu	r3,-8(fp)
   255d4:	1806d23a 	srli	r3,r3,8
   255d8:	18ffffcc 	andi	r3,r3,65535
   255dc:	11000643 	ldbu	r4,25(r2)
   255e0:	2008703a 	and	r4,r4,zero
   255e4:	20c6b03a 	or	r3,r4,r3
   255e8:	10c00645 	stb	r3,25(r2)
  desc->actual_bytes_transferred = 0;
   255ec:	e0bffa17 	ldw	r2,-24(fp)
   255f0:	10c00703 	ldbu	r3,28(r2)
   255f4:	1806703a 	and	r3,r3,zero
   255f8:	10c00705 	stb	r3,28(r2)
   255fc:	10c00743 	ldbu	r3,29(r2)
   25600:	1806703a 	and	r3,r3,zero
   25604:	10c00745 	stb	r3,29(r2)
  desc->status                   = 0x0;
   25608:	e0bffa17 	ldw	r2,-24(fp)
   2560c:	10000785 	stb	zero,30(r2)

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
   25610:	e0800617 	ldw	r2,24(fp)
   25614:	1007883a 	mov	r3,r2
   25618:	e0bffa17 	ldw	r2,-24(fp)
   2561c:	10c00685 	stb	r3,26(r2)
  desc->write_burst              = write_burst;
   25620:	e0800717 	ldw	r2,28(fp)
   25624:	1007883a 	mov	r3,r2
   25628:	e0bffa17 	ldw	r2,-24(fp)
   2562c:	10c006c5 	stb	r3,27(r2)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
   25630:	e0800317 	ldw	r2,12(fp)
   25634:	10000226 	beq	r2,zero,25640 <alt_avalon_sgdma_construct_descriptor_burst+0x2bc>
   25638:	00ffe044 	movi	r3,-127
   2563c:	00000106 	br	25644 <alt_avalon_sgdma_construct_descriptor_burst+0x2c0>
   25640:	00ffe004 	movi	r3,-128
   25644:	e0800417 	ldw	r2,16(fp)
   25648:	10000226 	beq	r2,zero,25654 <alt_avalon_sgdma_construct_descriptor_burst+0x2d0>
   2564c:	00800084 	movi	r2,2
   25650:	00000106 	br	25658 <alt_avalon_sgdma_construct_descriptor_burst+0x2d4>
   25654:	0005883a 	mov	r2,zero
   25658:	1884b03a 	or	r2,r3,r2
   2565c:	1007883a 	mov	r3,r2
   25660:	e0800517 	ldw	r2,20(fp)
   25664:	10000226 	beq	r2,zero,25670 <alt_avalon_sgdma_construct_descriptor_burst+0x2ec>
   25668:	00800104 	movi	r2,4
   2566c:	00000106 	br	25674 <alt_avalon_sgdma_construct_descriptor_burst+0x2f0>
   25670:	0005883a 	mov	r2,zero
   25674:	1884b03a 	or	r2,r3,r2
   25678:	1007883a 	mov	r3,r2
   2567c:	e0bfff03 	ldbu	r2,-4(fp)
   25680:	10000426 	beq	r2,zero,25694 <alt_avalon_sgdma_construct_descriptor_burst+0x310>
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_GENERATE_EOP_MSK : 0x0)        |
    (read_fixed ?
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_READ_FIXED_ADDRESS_MSK : 0x0)  |
    (write_fixed_or_sop ?
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_WRITE_FIXED_ADDRESS_MSK : 0x0) |
    (atlantic_channel ? ( (atlantic_channel & 0x0F) << 3) : 0)
   25684:	e0bfff03 	ldbu	r2,-4(fp)
   25688:	108003cc 	andi	r2,r2,15
   2568c:	100490fa 	slli	r2,r2,3
   25690:	00000106 	br	25698 <alt_avalon_sgdma_construct_descriptor_burst+0x314>
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
   25694:	0005883a 	mov	r2,zero
   25698:	1884b03a 	or	r2,r3,r2
   2569c:	1007883a 	mov	r3,r2
   256a0:	e0bffa17 	ldw	r2,-24(fp)
   256a4:	10c007c5 	stb	r3,31(r2)
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to
   */
  alt_remap_uncached(desc, sizeof(alt_sgdma_descriptor));
   256a8:	e13ffa17 	ldw	r4,-24(fp)
   256ac:	01400804 	movi	r5,32
   256b0:	0020e5c0 	call	20e5c <alt_remap_uncached>
}
   256b4:	e037883a 	mov	sp,fp
   256b8:	dfc00117 	ldw	ra,4(sp)
   256bc:	df000017 	ldw	fp,0(sp)
   256c0:	dec00204 	addi	sp,sp,8
   256c4:	f800283a 	ret

000256c8 <alt_avalon_sgdma_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_sgdma_irq(void *context)
#else
static void alt_avalon_sgdma_irq(void *context, alt_u32 id)
#endif
{
   256c8:	defff804 	addi	sp,sp,-32
   256cc:	dfc00715 	stw	ra,28(sp)
   256d0:	df000615 	stw	fp,24(sp)
   256d4:	df000604 	addi	fp,sp,24
   256d8:	e13fff15 	stw	r4,-4(fp)
  alt_sgdma_dev *dev = (alt_sgdma_dev *) context;
   256dc:	e0bfff17 	ldw	r2,-4(fp)
   256e0:	e0bffa15 	stw	r2,-24(fp)
   * Note: This is explicitly done before calling user interrupt-handling
   * code rather than after; if user ISR code initiates another SGDMA
   * transfer which completes quickly, reading the control register after
   * the callback routine may result in a lost interrupt.
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
   256e4:	e0bffa17 	ldw	r2,-24(fp)
   256e8:	10800317 	ldw	r2,12(r2)
   256ec:	10800404 	addi	r2,r2,16
   256f0:	e0fffa17 	ldw	r3,-24(fp)
   256f4:	18c00317 	ldw	r3,12(r3)
   256f8:	18c00404 	addi	r3,r3,16
   256fc:	18c00037 	ldwio	r3,0(r3)
   25700:	18e00034 	orhi	r3,r3,32768
   25704:	10c00035 	stwio	r3,0(r2)
    IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) | 0x80000000);
  
  /* Dummy read to ensure IRQ is negated before the ISR returns */
  IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
   25708:	e0bffa17 	ldw	r2,-24(fp)
   2570c:	10800317 	ldw	r2,12(r2)
   25710:	10800404 	addi	r2,r2,16
   25714:	10800037 	ldwio	r2,0(r2)
   * Other interrupts are explicitly disabled if callbacks
   * are registered because there is no guarantee that they are 
   * preemption-safe. This allows the driver to support 
   * interrupt preemption.
   */
  if(dev->callback) {
   25718:	e0bffa17 	ldw	r2,-24(fp)
   2571c:	10800917 	ldw	r2,36(r2)
   25720:	10001d26 	beq	r2,zero,25798 <alt_avalon_sgdma_irq+0xd0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   25724:	0005303a 	rdctl	r2,status
   25728:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   2572c:	e0fffc17 	ldw	r3,-16(fp)
   25730:	00bfff84 	movi	r2,-2
   25734:	1884703a 	and	r2,r3,r2
   25738:	1001703a 	wrctl	status,r2
  
  return context;
   2573c:	e0bffc17 	ldw	r2,-16(fp)
    cpu_sr = alt_irq_disable_all();
   25740:	e0bffb15 	stw	r2,-20(fp)
    (dev->callback)(dev->callback_context);
   25744:	e0bffa17 	ldw	r2,-24(fp)
   25748:	10c00917 	ldw	r3,36(r2)
   2574c:	e0bffa17 	ldw	r2,-24(fp)
   25750:	10800a17 	ldw	r2,40(r2)
   25754:	1009883a 	mov	r4,r2
   25758:	183ee83a 	callr	r3
   2575c:	e0bffb17 	ldw	r2,-20(fp)
   25760:	e0bffd15 	stw	r2,-12(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   25764:	0005303a 	rdctl	r2,status
   25768:	e0bffe15 	stw	r2,-8(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   2576c:	e0fffe17 	ldw	r3,-8(fp)
   25770:	00bfff84 	movi	r2,-2
   25774:	1884703a 	and	r2,r3,r2
   25778:	e0bffe15 	stw	r2,-8(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   2577c:	e0bffd17 	ldw	r2,-12(fp)
   25780:	1080004c 	andi	r2,r2,1
   25784:	e0fffe17 	ldw	r3,-8(fp)
   25788:	1884b03a 	or	r2,r3,r2
   2578c:	e0bffe15 	stw	r2,-8(fp)
  
  NIOS2_WRITE_STATUS (status);
   25790:	e0bffe17 	ldw	r2,-8(fp)
   25794:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(cpu_sr);
  }
}
   25798:	e037883a 	mov	sp,fp
   2579c:	dfc00117 	ldw	ra,4(sp)
   257a0:	df000017 	ldw	fp,0(sp)
   257a4:	dec00204 	addi	sp,sp,8
   257a8:	f800283a 	ret

000257ac <alt_avalon_sgdma_init>:
 * This routine disables interrupts, future descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_avalon_sgdma_init (alt_sgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
   257ac:	defffa04 	addi	sp,sp,-24
   257b0:	dfc00515 	stw	ra,20(sp)
   257b4:	df000415 	stw	fp,16(sp)
   257b8:	df000404 	addi	fp,sp,16
   257bc:	e13ffd15 	stw	r4,-12(fp)
   257c0:	e17ffe15 	stw	r5,-8(fp)
   257c4:	e1bfff15 	stw	r6,-4(fp)

  /* 
   * Halt any current transactions (reset the device)
   * SW reset is written twice per SGDMA documentation 
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
   257c8:	e0bffd17 	ldw	r2,-12(fp)
   257cc:	10800317 	ldw	r2,12(r2)
   257d0:	10800404 	addi	r2,r2,16
   257d4:	00c00074 	movhi	r3,1
   257d8:	10c00035 	stwio	r3,0(r2)
    ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
   257dc:	e0bffd17 	ldw	r2,-12(fp)
   257e0:	10800317 	ldw	r2,12(r2)
   257e4:	10800404 	addi	r2,r2,16
   257e8:	00c00074 	movhi	r3,1
   257ec:	10c00035 	stwio	r3,0(r2)

  /*
   * Disable interrupts, halt future descriptor processing,
   * and clear status register content
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 0x0);
   257f0:	e0bffd17 	ldw	r2,-12(fp)
   257f4:	10800317 	ldw	r2,12(r2)
   257f8:	10800404 	addi	r2,r2,16
   257fc:	0007883a 	mov	r3,zero
   25800:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
   25804:	e0bffd17 	ldw	r2,-12(fp)
   25808:	10800317 	ldw	r2,12(r2)
   2580c:	00c03fc4 	movi	r3,255
   25810:	10c00035 	stwio	r3,0(r2)

  /* Register this instance of the SGDMA controller with HAL */
  alt_dev_llist_insert((alt_dev_llist*) dev, &alt_sgdma_list);
   25814:	e13ffd17 	ldw	r4,-12(fp)
   25818:	d1601904 	addi	r5,gp,-32668
   2581c:	002b9380 	call	2b938 <alt_dev_llist_insert>

  /* Install IRQ handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(ic_id, irq, alt_avalon_sgdma_irq, dev, 0x0);
   25820:	d8000015 	stw	zero,0(sp)
   25824:	e13ffe17 	ldw	r4,-8(fp)
   25828:	e17fff17 	ldw	r5,-4(fp)
   2582c:	018000b4 	movhi	r6,2
   25830:	3195b204 	addi	r6,r6,22216
   25834:	e1fffd17 	ldw	r7,-12(fp)
   25838:	002b6280 	call	2b628 <alt_ic_isr_register>
#else
  alt_irq_register(irq, dev, alt_avalon_sgdma_irq);
#endif  
}
   2583c:	e037883a 	mov	sp,fp
   25840:	dfc00117 	ldw	ra,4(sp)
   25844:	df000017 	ldw	fp,0(sp)
   25848:	dec00204 	addi	sp,sp,8
   2584c:	f800283a 	ret

00025850 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
   25850:	defff904 	addi	sp,sp,-28
   25854:	dfc00615 	stw	ra,24(sp)
   25858:	df000515 	stw	fp,20(sp)
   2585c:	df000504 	addi	fp,sp,20
   25860:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
   25864:	0007883a 	mov	r3,zero
   25868:	e0bfff17 	ldw	r2,-4(fp)
   2586c:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
   25870:	e0bfff17 	ldw	r2,-4(fp)
   25874:	10800104 	addi	r2,r2,4
   25878:	10800037 	ldwio	r2,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   2587c:	0005303a 	rdctl	r2,status
   25880:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   25884:	e0fffc17 	ldw	r3,-16(fp)
   25888:	00bfff84 	movi	r2,-2
   2588c:	1884703a 	and	r2,r3,r2
   25890:	1001703a 	wrctl	status,r2
  
  return context;
   25894:	e0bffc17 	ldw	r2,-16(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
   25898:	e0bffb15 	stw	r2,-20(fp)
  alt_tick ();
   2589c:	00210680 	call	21068 <alt_tick>
   258a0:	e0bffb17 	ldw	r2,-20(fp)
   258a4:	e0bffd15 	stw	r2,-12(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   258a8:	0005303a 	rdctl	r2,status
   258ac:	e0bffe15 	stw	r2,-8(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   258b0:	e0fffe17 	ldw	r3,-8(fp)
   258b4:	00bfff84 	movi	r2,-2
   258b8:	1884703a 	and	r2,r3,r2
   258bc:	e0bffe15 	stw	r2,-8(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   258c0:	e0bffd17 	ldw	r2,-12(fp)
   258c4:	1080004c 	andi	r2,r2,1
   258c8:	e0fffe17 	ldw	r3,-8(fp)
   258cc:	1884b03a 	or	r2,r3,r2
   258d0:	e0bffe15 	stw	r2,-8(fp)
  
  NIOS2_WRITE_STATUS (status);
   258d4:	e0bffe17 	ldw	r2,-8(fp)
   258d8:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
   258dc:	e037883a 	mov	sp,fp
   258e0:	dfc00117 	ldw	ra,4(sp)
   258e4:	df000017 	ldw	fp,0(sp)
   258e8:	dec00204 	addi	sp,sp,8
   258ec:	f800283a 	ret

000258f0 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
   258f0:	defff804 	addi	sp,sp,-32
   258f4:	dfc00715 	stw	ra,28(sp)
   258f8:	df000615 	stw	fp,24(sp)
   258fc:	df000604 	addi	fp,sp,24
   25900:	e13ffc15 	stw	r4,-16(fp)
   25904:	e17ffd15 	stw	r5,-12(fp)
   25908:	e1bffe15 	stw	r6,-8(fp)
   2590c:	e1ffff15 	stw	r7,-4(fp)
   25910:	e0bfff17 	ldw	r2,-4(fp)
   25914:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
   25918:	008000f4 	movhi	r2,3
   2591c:	1099e104 	addi	r2,r2,26500
   25920:	10800017 	ldw	r2,0(r2)
   25924:	1000041e 	bne	r2,zero,25938 <alt_avalon_timer_sc_init+0x48>
  {
    _alt_tick_rate = nticks;
   25928:	008000f4 	movhi	r2,3
   2592c:	1099e104 	addi	r2,r2,26500
   25930:	e0fffb17 	ldw	r3,-20(fp)
   25934:	10c00015 	stw	r3,0(r2)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
   25938:	e0bffc17 	ldw	r2,-16(fp)
   2593c:	10800104 	addi	r2,r2,4
   25940:	00c001c4 	movi	r3,7
   25944:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
   25948:	d8000015 	stw	zero,0(sp)
   2594c:	e13ffd17 	ldw	r4,-12(fp)
   25950:	e17ffe17 	ldw	r5,-8(fp)
   25954:	018000b4 	movhi	r6,2
   25958:	31961404 	addi	r6,r6,22608
   2595c:	e1fffc17 	ldw	r7,-16(fp)
   25960:	002b6280 	call	2b628 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
   25964:	e037883a 	mov	sp,fp
   25968:	dfc00117 	ldw	ra,4(sp)
   2596c:	df000017 	ldw	fp,0(sp)
   25970:	dec00204 	addi	sp,sp,8
   25974:	f800283a 	ret

00025978 <no_printf>:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

void no_printf (char *fmt, ...) {}
   25978:	defffb04 	addi	sp,sp,-20
   2597c:	df000115 	stw	fp,4(sp)
   25980:	df000104 	addi	fp,sp,4
   25984:	e1400115 	stw	r5,4(fp)
   25988:	e1800215 	stw	r6,8(fp)
   2598c:	e1c00315 	stw	r7,12(fp)
   25990:	e13fff15 	stw	r4,-4(fp)
   25994:	e037883a 	mov	sp,fp
   25998:	df000017 	ldw	fp,0(sp)
   2599c:	dec00404 	addi	sp,sp,16
   259a0:	f800283a 	ret

000259a4 <tse_mac_initTransInfo2>:

alt_32 tse_mac_initTransInfo2( tse_mac_trans_info *mi,
                                        alt_u32 mac_base,
                                        alt_32 tx_sgdma,
                                        alt_32 rx_sgdma,
                                        alt_32 cfgflags) {
   259a4:	defffb04 	addi	sp,sp,-20
   259a8:	df000415 	stw	fp,16(sp)
   259ac:	df000404 	addi	fp,sp,16
   259b0:	e13ffc15 	stw	r4,-16(fp)
   259b4:	e17ffd15 	stw	r5,-12(fp)
   259b8:	e1bffe15 	stw	r6,-8(fp)
   259bc:	e1ffff15 	stw	r7,-4(fp)
                                              
        mi->base     = (np_tse_mac*)mac_base;
   259c0:	e0fffd17 	ldw	r3,-12(fp)
   259c4:	e0bffc17 	ldw	r2,-16(fp)
   259c8:	10c00015 	stw	r3,0(r2)
        mi->tx_sgdma = (alt_sgdma_dev *)tx_sgdma;
   259cc:	e0fffe17 	ldw	r3,-8(fp)
   259d0:	e0bffc17 	ldw	r2,-16(fp)
   259d4:	10c00115 	stw	r3,4(r2)
        mi->rx_sgdma = (alt_sgdma_dev *)rx_sgdma;
   259d8:	e0ffff17 	ldw	r3,-4(fp)
   259dc:	e0bffc17 	ldw	r2,-16(fp)
   259e0:	10c00215 	stw	r3,8(r2)
        mi->cfgflags = cfgflags;     
   259e4:	e0c00117 	ldw	r3,4(fp)
   259e8:	e0bffc17 	ldw	r2,-16(fp)
   259ec:	10c00415 	stw	r3,16(r2)
        return SUCCESS;
   259f0:	0005883a 	mov	r2,zero
}
   259f4:	e037883a 	mov	sp,fp
   259f8:	df000017 	ldw	fp,0(sp)
   259fc:	dec00104 	addi	sp,sp,4
   25a00:	f800283a 	ret

00025a04 <tse_mac_sTxWrite>:
  * @param txDesc           Pointer to the transmit SGDMA descriptor
  * @return actual bytes transferred if ok, else error (-1)
  */
alt_32 tse_mac_sTxWrite( tse_mac_trans_info *mi, 
                       alt_sgdma_descriptor *txDesc)   
{ 
   25a04:	defffa04 	addi	sp,sp,-24
   25a08:	dfc00515 	stw	ra,20(sp)
   25a0c:	df000415 	stw	fp,16(sp)
   25a10:	df000404 	addi	fp,sp,16
   25a14:	e13ffe15 	stw	r4,-8(fp)
   25a18:	e17fff15 	stw	r5,-4(fp)

  alt_32 timeout;
  alt_u8 result = 0;
   25a1c:	e03ffd05 	stb	zero,-12(fp)
  alt_u16 actualBytesTransferred;
    
  // Make sure DMA controller is not busy from a former command
  // and TX is able to accept data
  timeout = 0;
   25a20:	e03ffc15 	stw	zero,-16(fp)
  //tse_dprintf("\nWaiting while tx SGDMA is busy......... ");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->tx_sgdma->base) & 
   25a24:	00000e06 	br	25a60 <tse_mac_sTxWrite+0x5c>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
           if(timeout++ == ALTERA_TSE_SGDMA_BUSY_TIME_OUT_CNT) {
   25a28:	e0fffc17 	ldw	r3,-16(fp)
   25a2c:	008003f4 	movhi	r2,15
   25a30:	10909004 	addi	r2,r2,16960
   25a34:	1885003a 	cmpeq	r2,r3,r2
   25a38:	e0fffc17 	ldw	r3,-16(fp)
   25a3c:	18c00044 	addi	r3,r3,1
   25a40:	e0fffc15 	stw	r3,-16(fp)
   25a44:	10803fcc 	andi	r2,r2,255
   25a48:	10000526 	beq	r2,zero,25a60 <tse_mac_sTxWrite+0x5c>
            tse_dprintf(4, "WARNING : TX SGDMA Timeout\n");
   25a4c:	010000f4 	movhi	r4,3
   25a50:	2100c004 	addi	r4,r4,768
   25a54:	00172f80 	call	172f8 <puts>
            return ENP_RESOURCE;  // avoid being stuck here
   25a58:	00bffa84 	movi	r2,-22
   25a5c:	00001c06 	br	25ad0 <tse_mac_sTxWrite+0xcc>
    
  // Make sure DMA controller is not busy from a former command
  // and TX is able to accept data
  timeout = 0;
  //tse_dprintf("\nWaiting while tx SGDMA is busy......... ");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->tx_sgdma->base) & 
   25a60:	e0bffe17 	ldw	r2,-8(fp)
   25a64:	10800117 	ldw	r2,4(r2)
   25a68:	10800317 	ldw	r2,12(r2)
   25a6c:	10800037 	ldwio	r2,0(r2)
   25a70:	1080040c 	andi	r2,r2,16
   25a74:	103fec1e 	bne	r2,zero,25a28 <tse_mac_sTxWrite+0x24>
           }
  }

  // Set up the SGDMA
  // Clear the status and control bits of the SGDMA descriptor
  IOWR_ALTERA_AVALON_SGDMA_CONTROL (mi->tx_sgdma->base, 0);
   25a78:	e0bffe17 	ldw	r2,-8(fp)
   25a7c:	10800117 	ldw	r2,4(r2)
   25a80:	10800317 	ldw	r2,12(r2)
   25a84:	10800404 	addi	r2,r2,16
   25a88:	0007883a 	mov	r3,zero
   25a8c:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS (mi->tx_sgdma->base, 0xFF);
   25a90:	e0bffe17 	ldw	r2,-8(fp)
   25a94:	10800117 	ldw	r2,4(r2)
   25a98:	10800317 	ldw	r2,12(r2)
   25a9c:	00c03fc4 	movi	r3,255
   25aa0:	10c00035 	stwio	r3,0(r2)
  
  // Start SGDMA (blocking call)
  result = alt_avalon_sgdma_do_sync_transfer(
                mi->tx_sgdma, 
   25aa4:	e0bffe17 	ldw	r2,-8(fp)
  // Clear the status and control bits of the SGDMA descriptor
  IOWR_ALTERA_AVALON_SGDMA_CONTROL (mi->tx_sgdma->base, 0);
  IOWR_ALTERA_AVALON_SGDMA_STATUS (mi->tx_sgdma->base, 0xFF);
  
  // Start SGDMA (blocking call)
  result = alt_avalon_sgdma_do_sync_transfer(
   25aa8:	10800117 	ldw	r2,4(r2)
   25aac:	1009883a 	mov	r4,r2
   25ab0:	e17fff17 	ldw	r5,-4(fp)
   25ab4:	0024c980 	call	24c98 <alt_avalon_sgdma_do_sync_transfer>
   25ab8:	e0bffd05 	stb	r2,-12(fp)
                mi->tx_sgdma, 
                (alt_sgdma_descriptor *) &txDesc[0]);
  
  /* perform cache save read to obtain actual bytes transferred for current sgdma descriptor */
  actualBytesTransferred = IORD_ALTERA_TSE_SGDMA_DESC_ACTUAL_BYTES_TRANSFERRED(&txDesc[0]);
   25abc:	e0bfff17 	ldw	r2,-4(fp)
   25ac0:	10800704 	addi	r2,r2,28
   25ac4:	10800037 	ldwio	r2,0(r2)
   25ac8:	e0bffd8d 	sth	r2,-10(fp)

  return actualBytesTransferred;
   25acc:	e0bffd8b 	ldhu	r2,-10(fp)
}
   25ad0:	e037883a 	mov	sp,fp
   25ad4:	dfc00117 	ldw	ra,4(sp)
   25ad8:	df000017 	ldw	fp,0(sp)
   25adc:	dec00204 	addi	sp,sp,8
   25ae0:	f800283a 	ret

00025ae4 <tse_mac_aRxRead>:
  *        the actual bytes transferred for current descriptor
  */
alt_32 tse_mac_aRxRead( 
  tse_mac_trans_info *mi,       
  alt_sgdma_descriptor *rxDesc)  
{
   25ae4:	defffa04 	addi	sp,sp,-24
   25ae8:	dfc00515 	stw	ra,20(sp)
   25aec:	df000415 	stw	fp,16(sp)
   25af0:	df000404 	addi	fp,sp,16
   25af4:	e13ffe15 	stw	r4,-8(fp)
   25af8:	e17fff15 	stw	r5,-4(fp)
  alt_32 timeout;
  
  alt_u8 result = 0;
   25afc:	e03ffd05 	stb	zero,-12(fp)
         
  // Make sure SGDMA controller is not busy from a former command
  timeout = 0;
   25b00:	e03ffc15 	stw	zero,-16(fp)
//  tse_dprintf("\nWaiting while rx SGDMA is busy.........");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->rx_sgdma->base) & 
   25b04:	00000e06 	br	25b40 <tse_mac_aRxRead+0x5c>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    if(timeout++ == ALTERA_TSE_SGDMA_BUSY_TIME_OUT_CNT) {
   25b08:	e0fffc17 	ldw	r3,-16(fp)
   25b0c:	008003f4 	movhi	r2,15
   25b10:	10909004 	addi	r2,r2,16960
   25b14:	1885003a 	cmpeq	r2,r3,r2
   25b18:	e0fffc17 	ldw	r3,-16(fp)
   25b1c:	18c00044 	addi	r3,r3,1
   25b20:	e0fffc15 	stw	r3,-16(fp)
   25b24:	10803fcc 	andi	r2,r2,255
   25b28:	10000526 	beq	r2,zero,25b40 <tse_mac_aRxRead+0x5c>
        tse_dprintf(4, "WARNING : RX SGDMA Timeout\n");
   25b2c:	010000f4 	movhi	r4,3
   25b30:	2100c704 	addi	r4,r4,796
   25b34:	00172f80 	call	172f8 <puts>
        return ENP_RESOURCE;  // avoid being stuck here
   25b38:	00bffa84 	movi	r2,-22
   25b3c:	00000d06 	br	25b74 <tse_mac_aRxRead+0x90>
  alt_u8 result = 0;
         
  // Make sure SGDMA controller is not busy from a former command
  timeout = 0;
//  tse_dprintf("\nWaiting while rx SGDMA is busy.........");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->rx_sgdma->base) & 
   25b40:	e0bffe17 	ldw	r2,-8(fp)
   25b44:	10800217 	ldw	r2,8(r2)
   25b48:	10800317 	ldw	r2,12(r2)
   25b4c:	10800037 	ldwio	r2,0(r2)
   25b50:	1080040c 	andi	r2,r2,16
   25b54:	103fec1e 	bne	r2,zero,25b08 <tse_mac_aRxRead+0x24>
  }

 
  // SGDMA operation invoked for RX (non-blocking call)
  result = alt_avalon_sgdma_do_async_transfer(
                mi->rx_sgdma, 
   25b58:	e0bffe17 	ldw	r2,-8(fp)
    }
  }

 
  // SGDMA operation invoked for RX (non-blocking call)
  result = alt_avalon_sgdma_do_async_transfer(
   25b5c:	10800217 	ldw	r2,8(r2)
   25b60:	1009883a 	mov	r4,r2
   25b64:	e17fff17 	ldw	r5,-4(fp)
   25b68:	0024b740 	call	24b74 <alt_avalon_sgdma_do_async_transfer>
   25b6c:	e0bffd05 	stb	r2,-12(fp)
                mi->rx_sgdma, 
                (alt_sgdma_descriptor *) &rxDesc[0]);

 
  return SUCCESS;
   25b70:	0005883a 	mov	r2,zero
}
   25b74:	e037883a 	mov	sp,fp
   25b78:	dfc00117 	ldw	ra,4(sp)
   25b7c:	df000017 	ldw	fp,0(sp)
   25b80:	dec00204 	addi	sp,sp,8
   25b84:	f800283a 	ret

00025b88 <tse_mac_SwReset>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
*/
alt_32 tse_mac_SwReset(np_tse_mac *pmac) 
{
   25b88:	defffc04 	addi	sp,sp,-16
   25b8c:	df000315 	stw	fp,12(sp)
   25b90:	df000304 	addi	fp,sp,12
   25b94:	e13fff15 	stw	r4,-4(fp)
	alt_32 timeout;
	alt_32 cc;
        
    cc = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
   25b98:	e0bfff17 	ldw	r2,-4(fp)
   25b9c:	10800204 	addi	r2,r2,8
   25ba0:	10800037 	ldwio	r2,0(r2)
   25ba4:	e0bffe15 	stw	r2,-8(fp)
    
    // set reset and Gig-Speed bits to make sure we have an incoming clock on
    // tx side. If there is a 10/100 PHY, we will still have a valid clock on
    // tx_clk no matter what setting we have here, but on a Gig phy the
    // MII clock may be missing.
    IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,(ALTERA_TSEMAC_CMD_SW_RESET_MSK | ALTERA_TSEMAC_CMD_ETH_SPEED_MSK));
   25ba8:	e0bfff17 	ldw	r2,-4(fp)
   25bac:	10800204 	addi	r2,r2,8
   25bb0:	00c80204 	movi	r3,8200
   25bb4:	10c00035 	stwio	r3,0(r2)

    
    // wait for completion with fallback in case there is no PHY or it is
    // not connected and hence might not provide any clocks at all.
    timeout=0;
   25bb8:	e03ffd15 	stw	zero,-12(fp)
    while( (IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac) & ALTERA_TSEMAC_CMD_SW_RESET_MSK) != 0 && timeout < ALTERA_TSE_SW_RESET_TIME_OUT_CNT) timeout++;
   25bbc:	00000306 	br	25bcc <tse_mac_SwReset+0x44>
   25bc0:	e0bffd17 	ldw	r2,-12(fp)
   25bc4:	10800044 	addi	r2,r2,1
   25bc8:	e0bffd15 	stw	r2,-12(fp)
   25bcc:	e0bfff17 	ldw	r2,-4(fp)
   25bd0:	10800204 	addi	r2,r2,8
   25bd4:	10800037 	ldwio	r2,0(r2)
   25bd8:	1088000c 	andi	r2,r2,8192
   25bdc:	10000326 	beq	r2,zero,25bec <tse_mac_SwReset+0x64>
   25be0:	e0bffd17 	ldw	r2,-12(fp)
   25be4:	1089c410 	cmplti	r2,r2,10000
   25be8:	103ff51e 	bne	r2,zero,25bc0 <tse_mac_SwReset+0x38>
   
    IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,cc); // Restore
   25bec:	e0bfff17 	ldw	r2,-4(fp)
   25bf0:	10800204 	addi	r2,r2,8
   25bf4:	e0fffe17 	ldw	r3,-8(fp)
   25bf8:	10c00035 	stwio	r3,0(r2)
    return SUCCESS;
   25bfc:	0005883a 	mov	r2,zero
}
   25c00:	e037883a 	mov	sp,fp
   25c04:	df000017 	ldw	fp,0(sp)
   25c08:	dec00104 	addi	sp,sp,4
   25c0c:	f800283a 	ret

00025c10 <tse_mac_setMIImode>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
*/
alt_32 tse_mac_setMIImode(np_tse_mac *pmac)
{
   25c10:	defffd04 	addi	sp,sp,-12
   25c14:	df000215 	stw	fp,8(sp)
   25c18:	df000204 	addi	fp,sp,8
   25c1c:	e13fff15 	stw	r4,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
   25c20:	e0bfff17 	ldw	r2,-4(fp)
   25c24:	10800204 	addi	r2,r2,8
   25c28:	10800037 	ldwio	r2,0(r2)
   25c2c:	e0bffe15 	stw	r2,-8(fp)
  helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK; 
   25c30:	e0fffe17 	ldw	r3,-8(fp)
   25c34:	00bffdc4 	movi	r2,-9
   25c38:	1884703a 	and	r2,r3,r2
   25c3c:	e0bffe15 	stw	r2,-8(fp)
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,helpvar);
   25c40:	e0bfff17 	ldw	r2,-4(fp)
   25c44:	10800204 	addi	r2,r2,8
   25c48:	e0fffe17 	ldw	r3,-8(fp)
   25c4c:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
   25c50:	0005883a 	mov	r2,zero
}
   25c54:	e037883a 	mov	sp,fp
   25c58:	df000017 	ldw	fp,0(sp)
   25c5c:	dec00104 	addi	sp,sp,4
   25c60:	f800283a 	ret

00025c64 <tse_mac_setGMIImode>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
 */
alt_32 tse_mac_setGMIImode(np_tse_mac *pmac)
{
   25c64:	defffd04 	addi	sp,sp,-12
   25c68:	df000215 	stw	fp,8(sp)
   25c6c:	df000204 	addi	fp,sp,8
   25c70:	e13fff15 	stw	r4,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
   25c74:	e0bfff17 	ldw	r2,-4(fp)
   25c78:	10800204 	addi	r2,r2,8
   25c7c:	10800037 	ldwio	r2,0(r2)
   25c80:	e0bffe15 	stw	r2,-8(fp)
  helpvar |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
   25c84:	e0bffe17 	ldw	r2,-8(fp)
   25c88:	10800214 	ori	r2,r2,8
   25c8c:	e0bffe15 	stw	r2,-8(fp)

  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,helpvar);
   25c90:	e0bfff17 	ldw	r2,-4(fp)
   25c94:	10800204 	addi	r2,r2,8
   25c98:	e0fffe17 	ldw	r3,-8(fp)
   25c9c:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
   25ca0:	0005883a 	mov	r2,zero
}
   25ca4:	e037883a 	mov	sp,fp
   25ca8:	df000017 	ldw	fp,0(sp)
   25cac:	dec00104 	addi	sp,sp,4
   25cb0:	f800283a 	ret

00025cb4 <alt_tse_phy_add_profile>:
 * @param  phy  pointer to alt_tse_phy_profile structure describing PHY registers
 * @return      index of PHY added in PHY profile on success, else return ALTERA_TSE_MALLOC_FAILED if memory allocation failed
 * PHY which are currently supported by default :  Marvell 88E1111, Marvell Quad PHY 88E1145, National DP83865, and National DP83848C
 */
alt_32 alt_tse_phy_add_profile(alt_tse_phy_profile *phy)
{
   25cb4:	defffb04 	addi	sp,sp,-20
   25cb8:	dfc00415 	stw	ra,16(sp)
   25cbc:	df000315 	stw	fp,12(sp)
   25cc0:	dc000215 	stw	r16,8(sp)
   25cc4:	df000204 	addi	fp,sp,8
   25cc8:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
    
    /* search PHY profile for same ID */
    for(i = 0; i < phy_profile_count; i++)
   25ccc:	e03ffe15 	stw	zero,-8(fp)
   25cd0:	00002906 	br	25d78 <alt_tse_phy_add_profile+0xc4>
    {
        if(pphy_profiles[i]->oui == phy->oui && pphy_profiles[i]->model_number == phy->model_number)
   25cd4:	00c00134 	movhi	r3,4
   25cd8:	18d1bc04 	addi	r3,r3,18160
   25cdc:	e0bffe17 	ldw	r2,-8(fp)
   25ce0:	1085883a 	add	r2,r2,r2
   25ce4:	1085883a 	add	r2,r2,r2
   25ce8:	1885883a 	add	r2,r3,r2
   25cec:	10800017 	ldw	r2,0(r2)
   25cf0:	10c01417 	ldw	r3,80(r2)
   25cf4:	e0bfff17 	ldw	r2,-4(fp)
   25cf8:	10801417 	ldw	r2,80(r2)
   25cfc:	18801b1e 	bne	r3,r2,25d6c <alt_tse_phy_add_profile+0xb8>
   25d00:	00c00134 	movhi	r3,4
   25d04:	18d1bc04 	addi	r3,r3,18160
   25d08:	e0bffe17 	ldw	r2,-8(fp)
   25d0c:	1085883a 	add	r2,r2,r2
   25d10:	1085883a 	add	r2,r2,r2
   25d14:	1885883a 	add	r2,r3,r2
   25d18:	10800017 	ldw	r2,0(r2)
   25d1c:	10c01503 	ldbu	r3,84(r2)
   25d20:	e0bfff17 	ldw	r2,-4(fp)
   25d24:	10801503 	ldbu	r2,84(r2)
   25d28:	18c03fcc 	andi	r3,r3,255
   25d2c:	10803fcc 	andi	r2,r2,255
   25d30:	18800e1e 	bne	r3,r2,25d6c <alt_tse_phy_add_profile+0xb8>
        {
            tse_dprintf(4, "WARNING : PHY OUI 0x%06x, PHY Model Number 0x%02x already exist in PHY profile\n", (int) phy->oui, phy->model_number);
   25d34:	e0bfff17 	ldw	r2,-4(fp)
   25d38:	10801417 	ldw	r2,80(r2)
   25d3c:	1007883a 	mov	r3,r2
   25d40:	e0bfff17 	ldw	r2,-4(fp)
   25d44:	10801503 	ldbu	r2,84(r2)
   25d48:	10803fcc 	andi	r2,r2,255
   25d4c:	010000f4 	movhi	r4,3
   25d50:	2100ce04 	addi	r4,r4,824
   25d54:	180b883a 	mov	r5,r3
   25d58:	100d883a 	mov	r6,r2
   25d5c:	00170680 	call	17068 <printf>
            tse_dprintf(4, "In case of same PHY OUI and PHY Model Number in profile, first added PHY setting will be used\n");
   25d60:	010000f4 	movhi	r4,3
   25d64:	2100e204 	addi	r4,r4,904
   25d68:	00172f80 	call	172f8 <puts>
alt_32 alt_tse_phy_add_profile(alt_tse_phy_profile *phy)
{
	alt_32 i;
    
    /* search PHY profile for same ID */
    for(i = 0; i < phy_profile_count; i++)
   25d6c:	e0bffe17 	ldw	r2,-8(fp)
   25d70:	10800044 	addi	r2,r2,1
   25d74:	e0bffe15 	stw	r2,-8(fp)
   25d78:	d0a8f703 	ldbu	r2,-23588(gp)
   25d7c:	10803fcc 	andi	r2,r2,255
   25d80:	e0fffe17 	ldw	r3,-8(fp)
   25d84:	18bfd316 	blt	r3,r2,25cd4 <alt_tse_phy_add_profile+0x20>
            tse_dprintf(4, "In case of same PHY OUI and PHY Model Number in profile, first added PHY setting will be used\n");
        }
    }

    /* Allocate memory space to store the profile */    
    pphy_profiles[phy_profile_count] = (alt_tse_phy_profile *) malloc(sizeof(alt_tse_phy_profile));
   25d88:	d0a8f703 	ldbu	r2,-23588(gp)
   25d8c:	14003fcc 	andi	r16,r2,255
   25d90:	01001904 	movi	r4,100
   25d94:	002cae80 	call	2cae8 <malloc>
   25d98:	1007883a 	mov	r3,r2
   25d9c:	01000134 	movhi	r4,4
   25da0:	2111bc04 	addi	r4,r4,18160
   25da4:	8405883a 	add	r2,r16,r16
   25da8:	1085883a 	add	r2,r2,r2
   25dac:	2085883a 	add	r2,r4,r2
   25db0:	10c00015 	stw	r3,0(r2)
    if(!pphy_profiles[phy_profile_count]) {
   25db4:	d0a8f703 	ldbu	r2,-23588(gp)
   25db8:	10803fcc 	andi	r2,r2,255
   25dbc:	00c00134 	movhi	r3,4
   25dc0:	18d1bc04 	addi	r3,r3,18160
   25dc4:	1085883a 	add	r2,r2,r2
   25dc8:	1085883a 	add	r2,r2,r2
   25dcc:	1885883a 	add	r2,r3,r2
   25dd0:	10800017 	ldw	r2,0(r2)
   25dd4:	1000081e 	bne	r2,zero,25df8 <alt_tse_phy_add_profile+0x144>
        tse_dprintf(1, "ERROR   : Unable to allocate memory for pphy_profile[%d]\n", phy_profile_count);
   25dd8:	d0a8f703 	ldbu	r2,-23588(gp)
   25ddc:	10803fcc 	andi	r2,r2,255
   25de0:	010000f4 	movhi	r4,3
   25de4:	2100fa04 	addi	r4,r4,1000
   25de8:	100b883a 	mov	r5,r2
   25dec:	00170680 	call	17068 <printf>
        return ALTERA_TSE_MALLOC_FAILED;
   25df0:	00bfffc4 	movi	r2,-1
   25df4:	00002206 	br	25e80 <alt_tse_phy_add_profile+0x1cc>
    }

    /* Store PHY information */
    *pphy_profiles[phy_profile_count] = *phy;
   25df8:	d0a8f703 	ldbu	r2,-23588(gp)
   25dfc:	10803fcc 	andi	r2,r2,255
   25e00:	00c00134 	movhi	r3,4
   25e04:	18d1bc04 	addi	r3,r3,18160
   25e08:	1085883a 	add	r2,r2,r2
   25e0c:	1085883a 	add	r2,r2,r2
   25e10:	1885883a 	add	r2,r3,r2
   25e14:	10c00017 	ldw	r3,0(r2)
   25e18:	e0bfff17 	ldw	r2,-4(fp)
   25e1c:	1809883a 	mov	r4,r3
   25e20:	1007883a 	mov	r3,r2
   25e24:	00801904 	movi	r2,100
   25e28:	180b883a 	mov	r5,r3
   25e2c:	100d883a 	mov	r6,r2
   25e30:	0016e680 	call	16e68 <memcpy>
    strcpy(pphy_profiles[phy_profile_count]->name, phy->name);
   25e34:	d0a8f703 	ldbu	r2,-23588(gp)
   25e38:	10803fcc 	andi	r2,r2,255
   25e3c:	00c00134 	movhi	r3,4
   25e40:	18d1bc04 	addi	r3,r3,18160
   25e44:	1085883a 	add	r2,r2,r2
   25e48:	1085883a 	add	r2,r2,r2
   25e4c:	1885883a 	add	r2,r3,r2
   25e50:	10800017 	ldw	r2,0(r2)
   25e54:	1007883a 	mov	r3,r2
   25e58:	e0bfff17 	ldw	r2,-4(fp)
   25e5c:	1809883a 	mov	r4,r3
   25e60:	100b883a 	mov	r5,r2
   25e64:	002cb8c0 	call	2cb8c <strcpy>
    
    phy_profile_count++;
   25e68:	d0a8f703 	ldbu	r2,-23588(gp)
   25e6c:	10800044 	addi	r2,r2,1
   25e70:	d0a8f705 	stb	r2,-23588(gp)
    
    return phy_profile_count - 1;
   25e74:	d0a8f703 	ldbu	r2,-23588(gp)
   25e78:	10803fcc 	andi	r2,r2,255
   25e7c:	10bfffc4 	addi	r2,r2,-1
}
   25e80:	e037883a 	mov	sp,fp
   25e84:	dfc00217 	ldw	ra,8(sp)
   25e88:	df000117 	ldw	fp,4(sp)
   25e8c:	dc000017 	ldw	r16,0(sp)
   25e90:	dec00304 	addi	sp,sp,12
   25e94:	f800283a 	ret

00025e98 <alt_tse_system_add_sys>:
alt_32 alt_tse_system_add_sys(
	alt_tse_system_mac					*psys_mac,
	alt_tse_system_sgdma				*psys_sgdma,
	alt_tse_system_desc_mem				*psys_mem,
	alt_tse_system_shared_fifo			*psys_shared_fifo,
	alt_tse_system_phy 					*psys_phy ) {
   25e98:	defff204 	addi	sp,sp,-56
   25e9c:	dfc00d15 	stw	ra,52(sp)
   25ea0:	df000c15 	stw	fp,48(sp)
   25ea4:	dc000b15 	stw	r16,44(sp)
   25ea8:	df000b04 	addi	fp,sp,44
   25eac:	e13ffc15 	stw	r4,-16(fp)
   25eb0:	e17ffd15 	stw	r5,-12(fp)
   25eb4:	e1bffe15 	stw	r6,-8(fp)
   25eb8:	e1ffff15 	stw	r7,-4(fp)

	int i;
	int loop_end;
	
	alt_tse_system_mac					*pmac	= psys_mac;
   25ebc:	e0bffc17 	ldw	r2,-16(fp)
   25ec0:	e0bffb15 	stw	r2,-20(fp)
	alt_tse_system_sgdma				*psgdma	= psys_sgdma;
   25ec4:	e0bffd17 	ldw	r2,-12(fp)
   25ec8:	e0bff715 	stw	r2,-36(fp)
	alt_tse_system_desc_mem				*pmem	= psys_mem;
   25ecc:	e0bffe17 	ldw	r2,-8(fp)
   25ed0:	e0bff815 	stw	r2,-32(fp)
	alt_tse_system_shared_fifo			*pfifo	= psys_shared_fifo;
   25ed4:	e0bfff17 	ldw	r2,-4(fp)
   25ed8:	e0bff915 	stw	r2,-28(fp)
	alt_tse_system_phy 					*pphy	= psys_phy;
   25edc:	e0800317 	ldw	r2,12(fp)
   25ee0:	e0bffa15 	stw	r2,-24(fp)
	
	static alt_8 tse_system_count = 0;
	
	/* Determine number of loop */
	/* Run at least one for non-multi-channel MAC */
	if(pmac->tse_num_of_channel == 0) {
   25ee4:	e0bffb17 	ldw	r2,-20(fp)
   25ee8:	10800303 	ldbu	r2,12(r2)
   25eec:	10803fcc 	andi	r2,r2,255
   25ef0:	1000031e 	bne	r2,zero,25f00 <alt_tse_system_add_sys+0x68>
		loop_end = 1;
   25ef4:	00800044 	movi	r2,1
   25ef8:	e0bff615 	stw	r2,-40(fp)
   25efc:	00000e06 	br	25f38 <alt_tse_system_add_sys+0xa0>
	}
	else if(pmac->tse_num_of_channel > 0) {
   25f00:	e0bffb17 	ldw	r2,-20(fp)
   25f04:	10800303 	ldbu	r2,12(r2)
   25f08:	10803fcc 	andi	r2,r2,255
   25f0c:	10000526 	beq	r2,zero,25f24 <alt_tse_system_add_sys+0x8c>
		loop_end = pmac->tse_num_of_channel; 
   25f10:	e0bffb17 	ldw	r2,-20(fp)
   25f14:	10800303 	ldbu	r2,12(r2)
   25f18:	10803fcc 	andi	r2,r2,255
   25f1c:	e0bff615 	stw	r2,-40(fp)
   25f20:	00000506 	br	25f38 <alt_tse_system_add_sys+0xa0>
	}
	else {
		tse_dprintf(2, "ERROR   : Invalid number of channel specified!\n");
   25f24:	010000f4 	movhi	r4,3
   25f28:	21010904 	addi	r4,r4,1060
   25f2c:	00172f80 	call	172f8 <puts>
		return ALTERA_TSE_SYSTEM_DEF_ERROR;
   25f30:	00bfffc4 	movi	r2,-1
   25f34:	00025106 	br	2687c <alt_tse_system_add_sys+0x9e4>
	}

	for(i = 0; i < loop_end; i++) {
   25f38:	e03ff515 	stw	zero,-44(fp)
   25f3c:	00024b06 	br	2686c <alt_tse_system_add_sys+0x9d4>
		
		/* Make sure the boundary of array is not exceeded */
		if(tse_system_count >= MAXNETS) {
   25f40:	d0a8f7c3 	ldbu	r2,-23585(gp)
   25f44:	10803fcc 	andi	r2,r2,255
   25f48:	1080201c 	xori	r2,r2,128
   25f4c:	10bfe004 	addi	r2,r2,-128
   25f50:	10800210 	cmplti	r2,r2,8
   25f54:	10000c1e 	bne	r2,zero,25f88 <alt_tse_system_add_sys+0xf0>
			tse_dprintf(2, "ERROR   : Number of TSE System added exceed the size of array!\n");
   25f58:	010000f4 	movhi	r4,3
   25f5c:	21011504 	addi	r4,r4,1108
   25f60:	00172f80 	call	172f8 <puts>
			tse_dprintf(2, "ERROR   : Size of array = %d, Number of TSE System = %d\n", MAXNETS, tse_system_count);
   25f64:	d0a8f7c3 	ldbu	r2,-23585(gp)
   25f68:	10803fcc 	andi	r2,r2,255
   25f6c:	1080201c 	xori	r2,r2,128
   25f70:	10bfe004 	addi	r2,r2,-128
   25f74:	010000f4 	movhi	r4,3
   25f78:	21012504 	addi	r4,r4,1172
   25f7c:	01400204 	movi	r5,8
   25f80:	100d883a 	mov	r6,r2
   25f84:	00170680 	call	17068 <printf>
		}

		/* Add MAC info to alt_tse_system_info structure */
		if(pmac == 0) {
   25f88:	e0bffb17 	ldw	r2,-20(fp)
   25f8c:	1000081e 	bne	r2,zero,25fb0 <alt_tse_system_add_sys+0x118>
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
   25f90:	010000f4 	movhi	r4,3
   25f94:	21013404 	addi	r4,r4,1232
   25f98:	00172f80 	call	172f8 <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_system_add_sys()\n");
   25f9c:	010000f4 	movhi	r4,3
   25fa0:	21013e04 	addi	r4,r4,1272
   25fa4:	00172f80 	call	172f8 <puts>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
   25fa8:	00bfffc4 	movi	r2,-1
   25fac:	00023306 	br	2687c <alt_tse_system_add_sys+0x9e4>
		}		
		
		tse_mac_device[tse_system_count].tse_mac_base 					= pmac->tse_mac_base + (i * 0x400);
   25fb0:	d0a8f7c3 	ldbu	r2,-23585(gp)
   25fb4:	10803fcc 	andi	r2,r2,255
   25fb8:	1080201c 	xori	r2,r2,128
   25fbc:	10bfe004 	addi	r2,r2,-128
   25fc0:	e0fffb17 	ldw	r3,-20(fp)
   25fc4:	19000017 	ldw	r4,0(r3)
   25fc8:	e0fff517 	ldw	r3,-44(fp)
   25fcc:	180692ba 	slli	r3,r3,10
   25fd0:	20c7883a 	add	r3,r4,r3
   25fd4:	010000f4 	movhi	r4,3
   25fd8:	21086204 	addi	r4,r4,8584
   25fdc:	10801224 	muli	r2,r2,72
   25fe0:	2085883a 	add	r2,r4,r2
   25fe4:	10c00015 	stw	r3,0(r2)
		tse_mac_device[tse_system_count].tse_tx_depth 					= pmac->tse_tx_depth;
   25fe8:	d0a8f7c3 	ldbu	r2,-23585(gp)
   25fec:	10803fcc 	andi	r2,r2,255
   25ff0:	1080201c 	xori	r2,r2,128
   25ff4:	10bfe004 	addi	r2,r2,-128
   25ff8:	e0fffb17 	ldw	r3,-20(fp)
   25ffc:	18c0010b 	ldhu	r3,4(r3)
   26000:	010000f4 	movhi	r4,3
   26004:	21086204 	addi	r4,r4,8584
   26008:	10801224 	muli	r2,r2,72
   2600c:	2085883a 	add	r2,r4,r2
   26010:	10800104 	addi	r2,r2,4
   26014:	10c0000d 	sth	r3,0(r2)
		tse_mac_device[tse_system_count].tse_rx_depth 					= pmac->tse_rx_depth;
   26018:	d0a8f7c3 	ldbu	r2,-23585(gp)
   2601c:	10803fcc 	andi	r2,r2,255
   26020:	1080201c 	xori	r2,r2,128
   26024:	10bfe004 	addi	r2,r2,-128
   26028:	e0fffb17 	ldw	r3,-20(fp)
   2602c:	18c0018b 	ldhu	r3,6(r3)
   26030:	010000f4 	movhi	r4,3
   26034:	21086204 	addi	r4,r4,8584
   26038:	10801224 	muli	r2,r2,72
   2603c:	2085883a 	add	r2,r4,r2
   26040:	10800104 	addi	r2,r2,4
   26044:	10c0008d 	sth	r3,2(r2)
		tse_mac_device[tse_system_count].tse_use_mdio 					= pmac->tse_use_mdio;
   26048:	d0a8f7c3 	ldbu	r2,-23585(gp)
   2604c:	10803fcc 	andi	r2,r2,255
   26050:	1080201c 	xori	r2,r2,128
   26054:	10bfe004 	addi	r2,r2,-128
   26058:	e0fffb17 	ldw	r3,-20(fp)
   2605c:	18c00203 	ldbu	r3,8(r3)
   26060:	010000f4 	movhi	r4,3
   26064:	21086204 	addi	r4,r4,8584
   26068:	10801224 	muli	r2,r2,72
   2606c:	2085883a 	add	r2,r4,r2
   26070:	10800204 	addi	r2,r2,8
   26074:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_en_maclite 				= pmac->tse_en_maclite;
   26078:	d0a8f7c3 	ldbu	r2,-23585(gp)
   2607c:	10803fcc 	andi	r2,r2,255
   26080:	1080201c 	xori	r2,r2,128
   26084:	10bfe004 	addi	r2,r2,-128
   26088:	e0fffb17 	ldw	r3,-20(fp)
   2608c:	18c00243 	ldbu	r3,9(r3)
   26090:	010000f4 	movhi	r4,3
   26094:	21086204 	addi	r4,r4,8584
   26098:	10801224 	muli	r2,r2,72
   2609c:	2085883a 	add	r2,r4,r2
   260a0:	10800204 	addi	r2,r2,8
   260a4:	10c00045 	stb	r3,1(r2)
		tse_mac_device[tse_system_count].tse_maclite_gige 				= pmac->tse_maclite_gige;
   260a8:	d0a8f7c3 	ldbu	r2,-23585(gp)
   260ac:	10803fcc 	andi	r2,r2,255
   260b0:	1080201c 	xori	r2,r2,128
   260b4:	10bfe004 	addi	r2,r2,-128
   260b8:	e0fffb17 	ldw	r3,-20(fp)
   260bc:	18c00283 	ldbu	r3,10(r3)
   260c0:	010000f4 	movhi	r4,3
   260c4:	21086204 	addi	r4,r4,8584
   260c8:	10801224 	muli	r2,r2,72
   260cc:	2085883a 	add	r2,r4,r2
   260d0:	10800204 	addi	r2,r2,8
   260d4:	10c00085 	stb	r3,2(r2)
		tse_mac_device[tse_system_count].tse_multichannel_mac 			= pmac->tse_multichannel_mac;
   260d8:	d0a8f7c3 	ldbu	r2,-23585(gp)
   260dc:	10803fcc 	andi	r2,r2,255
   260e0:	1080201c 	xori	r2,r2,128
   260e4:	10bfe004 	addi	r2,r2,-128
   260e8:	e0fffb17 	ldw	r3,-20(fp)
   260ec:	18c002c3 	ldbu	r3,11(r3)
   260f0:	010000f4 	movhi	r4,3
   260f4:	21086204 	addi	r4,r4,8584
   260f8:	10801224 	muli	r2,r2,72
   260fc:	2085883a 	add	r2,r4,r2
   26100:	10800204 	addi	r2,r2,8
   26104:	10c000c5 	stb	r3,3(r2)
		tse_mac_device[tse_system_count].tse_num_of_channel 			= pmac->tse_num_of_channel;
   26108:	d0a8f7c3 	ldbu	r2,-23585(gp)
   2610c:	10803fcc 	andi	r2,r2,255
   26110:	1080201c 	xori	r2,r2,128
   26114:	10bfe004 	addi	r2,r2,-128
   26118:	e0fffb17 	ldw	r3,-20(fp)
   2611c:	18c00303 	ldbu	r3,12(r3)
   26120:	010000f4 	movhi	r4,3
   26124:	21086204 	addi	r4,r4,8584
   26128:	10801224 	muli	r2,r2,72
   2612c:	2085883a 	add	r2,r4,r2
   26130:	10800304 	addi	r2,r2,12
   26134:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_mdio_shared 				= pmac->tse_mdio_shared;
   26138:	d0a8f7c3 	ldbu	r2,-23585(gp)
   2613c:	10803fcc 	andi	r2,r2,255
   26140:	1080201c 	xori	r2,r2,128
   26144:	10bfe004 	addi	r2,r2,-128
   26148:	e0fffb17 	ldw	r3,-20(fp)
   2614c:	18c00343 	ldbu	r3,13(r3)
   26150:	010000f4 	movhi	r4,3
   26154:	21086204 	addi	r4,r4,8584
   26158:	10801224 	muli	r2,r2,72
   2615c:	2085883a 	add	r2,r4,r2
   26160:	10800304 	addi	r2,r2,12
   26164:	10c00045 	stb	r3,1(r2)
		tse_mac_device[tse_system_count].tse_number_of_mac_mdio_shared	= pmac->tse_number_of_mac_mdio_shared;
   26168:	d0a8f7c3 	ldbu	r2,-23585(gp)
   2616c:	10803fcc 	andi	r2,r2,255
   26170:	1080201c 	xori	r2,r2,128
   26174:	10bfe004 	addi	r2,r2,-128
   26178:	e0fffb17 	ldw	r3,-20(fp)
   2617c:	18c00383 	ldbu	r3,14(r3)
   26180:	010000f4 	movhi	r4,3
   26184:	21086204 	addi	r4,r4,8584
   26188:	10801224 	muli	r2,r2,72
   2618c:	2085883a 	add	r2,r4,r2
   26190:	10800304 	addi	r2,r2,12
   26194:	10c00085 	stb	r3,2(r2)
		tse_mac_device[tse_system_count].tse_pcs_ena 					= pmac->tse_pcs_ena;
   26198:	d0a8f7c3 	ldbu	r2,-23585(gp)
   2619c:	10803fcc 	andi	r2,r2,255
   261a0:	1080201c 	xori	r2,r2,128
   261a4:	10bfe004 	addi	r2,r2,-128
   261a8:	e0fffb17 	ldw	r3,-20(fp)
   261ac:	18c003c3 	ldbu	r3,15(r3)
   261b0:	010000f4 	movhi	r4,3
   261b4:	21086204 	addi	r4,r4,8584
   261b8:	10801224 	muli	r2,r2,72
   261bc:	2085883a 	add	r2,r4,r2
   261c0:	10800304 	addi	r2,r2,12
   261c4:	10c000c5 	stb	r3,3(r2)
		tse_mac_device[tse_system_count].tse_pcs_sgmii 					= pmac->tse_pcs_sgmii;
   261c8:	d0a8f7c3 	ldbu	r2,-23585(gp)
   261cc:	10803fcc 	andi	r2,r2,255
   261d0:	1080201c 	xori	r2,r2,128
   261d4:	10bfe004 	addi	r2,r2,-128
   261d8:	e0fffb17 	ldw	r3,-20(fp)
   261dc:	18c00403 	ldbu	r3,16(r3)
   261e0:	010000f4 	movhi	r4,3
   261e4:	21086204 	addi	r4,r4,8584
   261e8:	10801224 	muli	r2,r2,72
   261ec:	2085883a 	add	r2,r4,r2
   261f0:	10800404 	addi	r2,r2,16
   261f4:	10c00005 	stb	r3,0(r2)
		
		/* Add SGDMA info to alt_tse_system_info structure */
		if(psgdma == 0) {
   261f8:	e0bff717 	ldw	r2,-36(fp)
   261fc:	10000d1e 	bne	r2,zero,26234 <alt_tse_system_add_sys+0x39c>
			tse_dprintf(2, "ERROR   : SGDMA system structure == NULL\n");
   26200:	010000f4 	movhi	r4,3
   26204:	21015004 	addi	r4,r4,1344
   26208:	00172f80 	call	172f8 <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_system_add_sys() for tse_mac_device[%d]\n", tse_system_count);
   2620c:	d0a8f7c3 	ldbu	r2,-23585(gp)
   26210:	10803fcc 	andi	r2,r2,255
   26214:	1080201c 	xori	r2,r2,128
   26218:	10bfe004 	addi	r2,r2,-128
   2621c:	010000f4 	movhi	r4,3
   26220:	21015b04 	addi	r4,r4,1388
   26224:	100b883a 	mov	r5,r2
   26228:	00170680 	call	17068 <printf>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
   2622c:	00bfffc4 	movi	r2,-1
   26230:	00019206 	br	2687c <alt_tse_system_add_sys+0x9e4>
		}
		
		tse_mac_device[tse_system_count].tse_sgdma_tx = (char *) malloc(strlen(psgdma->tse_sgdma_tx) + 1);
   26234:	d0a8f7c3 	ldbu	r2,-23585(gp)
   26238:	14003fcc 	andi	r16,r2,255
   2623c:	8400201c 	xori	r16,r16,128
   26240:	843fe004 	addi	r16,r16,-128
   26244:	e0bff717 	ldw	r2,-36(fp)
   26248:	10800017 	ldw	r2,0(r2)
   2624c:	1009883a 	mov	r4,r2
   26250:	00173b00 	call	173b0 <strlen>
   26254:	10800044 	addi	r2,r2,1
   26258:	1009883a 	mov	r4,r2
   2625c:	002cae80 	call	2cae8 <malloc>
   26260:	1007883a 	mov	r3,r2
   26264:	010000f4 	movhi	r4,3
   26268:	21086204 	addi	r4,r4,8584
   2626c:	80801224 	muli	r2,r16,72
   26270:	2085883a 	add	r2,r4,r2
   26274:	10800504 	addi	r2,r2,20
   26278:	10c00015 	stw	r3,0(r2)
	    if(!tse_mac_device[tse_system_count].tse_sgdma_tx) {
   2627c:	d0a8f7c3 	ldbu	r2,-23585(gp)
   26280:	10803fcc 	andi	r2,r2,255
   26284:	1080201c 	xori	r2,r2,128
   26288:	10bfe004 	addi	r2,r2,-128
   2628c:	00c000f4 	movhi	r3,3
   26290:	18c86204 	addi	r3,r3,8584
   26294:	10801224 	muli	r2,r2,72
   26298:	1885883a 	add	r2,r3,r2
   2629c:	10800504 	addi	r2,r2,20
   262a0:	10800017 	ldw	r2,0(r2)
   262a4:	10000a1e 	bne	r2,zero,262d0 <alt_tse_system_add_sys+0x438>
	        tse_dprintf(1, "ERROR   : Unable to allocate memory for tse_mac_device[%d].tse_sgdma_tx\n", tse_system_count);
   262a8:	d0a8f7c3 	ldbu	r2,-23585(gp)
   262ac:	10803fcc 	andi	r2,r2,255
   262b0:	1080201c 	xori	r2,r2,128
   262b4:	10bfe004 	addi	r2,r2,-128
   262b8:	010000f4 	movhi	r4,3
   262bc:	21017304 	addi	r4,r4,1484
   262c0:	100b883a 	mov	r5,r2
   262c4:	00170680 	call	17068 <printf>
	        return ALTERA_TSE_MALLOC_FAILED;
   262c8:	00bfffc4 	movi	r2,-1
   262cc:	00016b06 	br	2687c <alt_tse_system_add_sys+0x9e4>
	    }   
		strcpy(tse_mac_device[tse_system_count].tse_sgdma_tx, psgdma->tse_sgdma_tx);
   262d0:	d0a8f7c3 	ldbu	r2,-23585(gp)
   262d4:	10803fcc 	andi	r2,r2,255
   262d8:	1080201c 	xori	r2,r2,128
   262dc:	10bfe004 	addi	r2,r2,-128
   262e0:	00c000f4 	movhi	r3,3
   262e4:	18c86204 	addi	r3,r3,8584
   262e8:	10801224 	muli	r2,r2,72
   262ec:	1885883a 	add	r2,r3,r2
   262f0:	10800504 	addi	r2,r2,20
   262f4:	10c00017 	ldw	r3,0(r2)
   262f8:	e0bff717 	ldw	r2,-36(fp)
   262fc:	10800017 	ldw	r2,0(r2)
   26300:	1809883a 	mov	r4,r3
   26304:	100b883a 	mov	r5,r2
   26308:	002cb8c0 	call	2cb8c <strcpy>
		
		tse_mac_device[tse_system_count].tse_sgdma_rx = (char *) malloc(strlen(psgdma->tse_sgdma_rx) + 1);
   2630c:	d0a8f7c3 	ldbu	r2,-23585(gp)
   26310:	14003fcc 	andi	r16,r2,255
   26314:	8400201c 	xori	r16,r16,128
   26318:	843fe004 	addi	r16,r16,-128
   2631c:	e0bff717 	ldw	r2,-36(fp)
   26320:	10800117 	ldw	r2,4(r2)
   26324:	1009883a 	mov	r4,r2
   26328:	00173b00 	call	173b0 <strlen>
   2632c:	10800044 	addi	r2,r2,1
   26330:	1009883a 	mov	r4,r2
   26334:	002cae80 	call	2cae8 <malloc>
   26338:	1007883a 	mov	r3,r2
   2633c:	010000f4 	movhi	r4,3
   26340:	21086204 	addi	r4,r4,8584
   26344:	80801224 	muli	r2,r16,72
   26348:	2085883a 	add	r2,r4,r2
   2634c:	10800604 	addi	r2,r2,24
   26350:	10c00015 	stw	r3,0(r2)
	    if(!tse_mac_device[tse_system_count].tse_sgdma_rx) {
   26354:	d0a8f7c3 	ldbu	r2,-23585(gp)
   26358:	10803fcc 	andi	r2,r2,255
   2635c:	1080201c 	xori	r2,r2,128
   26360:	10bfe004 	addi	r2,r2,-128
   26364:	00c000f4 	movhi	r3,3
   26368:	18c86204 	addi	r3,r3,8584
   2636c:	10801224 	muli	r2,r2,72
   26370:	1885883a 	add	r2,r3,r2
   26374:	10800604 	addi	r2,r2,24
   26378:	10800017 	ldw	r2,0(r2)
   2637c:	10000a1e 	bne	r2,zero,263a8 <alt_tse_system_add_sys+0x510>
	        tse_dprintf(1, "ERROR   : Unable to allocate memory for tse_mac_device[%d].tse_sgdma_rx\n", tse_system_count);
   26380:	d0a8f7c3 	ldbu	r2,-23585(gp)
   26384:	10803fcc 	andi	r2,r2,255
   26388:	1080201c 	xori	r2,r2,128
   2638c:	10bfe004 	addi	r2,r2,-128
   26390:	010000f4 	movhi	r4,3
   26394:	21018604 	addi	r4,r4,1560
   26398:	100b883a 	mov	r5,r2
   2639c:	00170680 	call	17068 <printf>
	        return ALTERA_TSE_MALLOC_FAILED;
   263a0:	00bfffc4 	movi	r2,-1
   263a4:	00013506 	br	2687c <alt_tse_system_add_sys+0x9e4>
	    }
	    strcpy(tse_mac_device[tse_system_count].tse_sgdma_rx, psgdma->tse_sgdma_rx);
   263a8:	d0a8f7c3 	ldbu	r2,-23585(gp)
   263ac:	10803fcc 	andi	r2,r2,255
   263b0:	1080201c 	xori	r2,r2,128
   263b4:	10bfe004 	addi	r2,r2,-128
   263b8:	00c000f4 	movhi	r3,3
   263bc:	18c86204 	addi	r3,r3,8584
   263c0:	10801224 	muli	r2,r2,72
   263c4:	1885883a 	add	r2,r3,r2
   263c8:	10800604 	addi	r2,r2,24
   263cc:	10c00017 	ldw	r3,0(r2)
   263d0:	e0bff717 	ldw	r2,-36(fp)
   263d4:	10800117 	ldw	r2,4(r2)
   263d8:	1809883a 	mov	r4,r3
   263dc:	100b883a 	mov	r5,r2
   263e0:	002cb8c0 	call	2cb8c <strcpy>
	    
		tse_mac_device[tse_system_count].tse_sgdma_rx_irq = psgdma->tse_sgdma_rx_irq;
   263e4:	d0a8f7c3 	ldbu	r2,-23585(gp)
   263e8:	10803fcc 	andi	r2,r2,255
   263ec:	1080201c 	xori	r2,r2,128
   263f0:	10bfe004 	addi	r2,r2,-128
   263f4:	e0fff717 	ldw	r3,-36(fp)
   263f8:	18c0020b 	ldhu	r3,8(r3)
   263fc:	010000f4 	movhi	r4,3
   26400:	21086204 	addi	r4,r4,8584
   26404:	10801224 	muli	r2,r2,72
   26408:	2085883a 	add	r2,r4,r2
   2640c:	10800704 	addi	r2,r2,28
   26410:	10c0000d 	sth	r3,0(r2)
		
		/* Add descriptor memory info to alt_tse_system_info structure */
		if(pmem == 0) {
   26414:	e0bff817 	ldw	r2,-32(fp)
   26418:	1000151e 	bne	r2,zero,26470 <alt_tse_system_add_sys+0x5d8>
			tse_mac_device[tse_system_count].ext_desc_mem	= TSE_INT_DESC_MEM;
   2641c:	d0a8f7c3 	ldbu	r2,-23585(gp)
   26420:	10803fcc 	andi	r2,r2,255
   26424:	1080201c 	xori	r2,r2,128
   26428:	10bfe004 	addi	r2,r2,-128
   2642c:	00c000f4 	movhi	r3,3
   26430:	18c86204 	addi	r3,r3,8584
   26434:	10801224 	muli	r2,r2,72
   26438:	1885883a 	add	r2,r3,r2
   2643c:	10800704 	addi	r2,r2,28
   26440:	10000085 	stb	zero,2(r2)
			tse_mac_device[tse_system_count].desc_mem_base	= TSE_INT_DESC_MEM;
   26444:	d0a8f7c3 	ldbu	r2,-23585(gp)
   26448:	10803fcc 	andi	r2,r2,255
   2644c:	1080201c 	xori	r2,r2,128
   26450:	10bfe004 	addi	r2,r2,-128
   26454:	00c000f4 	movhi	r3,3
   26458:	18c86204 	addi	r3,r3,8584
   2645c:	10801224 	muli	r2,r2,72
   26460:	1885883a 	add	r2,r3,r2
   26464:	10800804 	addi	r2,r2,32
   26468:	10000015 	stw	zero,0(r2)
   2646c:	00001806 	br	264d0 <alt_tse_system_add_sys+0x638>
		}
		else {
			tse_mac_device[tse_system_count].ext_desc_mem	= pmem->ext_desc_mem;
   26470:	d0a8f7c3 	ldbu	r2,-23585(gp)
   26474:	10803fcc 	andi	r2,r2,255
   26478:	1080201c 	xori	r2,r2,128
   2647c:	10bfe004 	addi	r2,r2,-128
   26480:	e0fff817 	ldw	r3,-32(fp)
   26484:	18c00003 	ldbu	r3,0(r3)
   26488:	010000f4 	movhi	r4,3
   2648c:	21086204 	addi	r4,r4,8584
   26490:	10801224 	muli	r2,r2,72
   26494:	2085883a 	add	r2,r4,r2
   26498:	10800704 	addi	r2,r2,28
   2649c:	10c00085 	stb	r3,2(r2)
			tse_mac_device[tse_system_count].desc_mem_base	= pmem->desc_mem_base;
   264a0:	d0a8f7c3 	ldbu	r2,-23585(gp)
   264a4:	10803fcc 	andi	r2,r2,255
   264a8:	1080201c 	xori	r2,r2,128
   264ac:	10bfe004 	addi	r2,r2,-128
   264b0:	e0fff817 	ldw	r3,-32(fp)
   264b4:	18c00117 	ldw	r3,4(r3)
   264b8:	010000f4 	movhi	r4,3
   264bc:	21086204 	addi	r4,r4,8584
   264c0:	10801224 	muli	r2,r2,72
   264c4:	2085883a 	add	r2,r4,r2
   264c8:	10800804 	addi	r2,r2,32
   264cc:	10c00015 	stw	r3,0(r2)
		}
		
		/* Add shared fifo info to alt_tse_system_info structure */
		if(pfifo == 0) {
   264d0:	e0bff917 	ldw	r2,-28(fp)
   264d4:	1000471e 	bne	r2,zero,265f4 <alt_tse_system_add_sys+0x75c>
			tse_mac_device[tse_system_count].use_shared_fifo                = TSE_NO_SHARED_FIFO;
   264d8:	d0a8f7c3 	ldbu	r2,-23585(gp)
   264dc:	10803fcc 	andi	r2,r2,255
   264e0:	1080201c 	xori	r2,r2,128
   264e4:	10bfe004 	addi	r2,r2,-128
   264e8:	00c000f4 	movhi	r3,3
   264ec:	18c86204 	addi	r3,r3,8584
   264f0:	10801224 	muli	r2,r2,72
   264f4:	1885883a 	add	r2,r3,r2
   264f8:	10800904 	addi	r2,r2,36
   264fc:	10000005 	stb	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_ctrl_base	= TSE_NO_SHARED_FIFO;
   26500:	d0a8f7c3 	ldbu	r2,-23585(gp)
   26504:	10803fcc 	andi	r2,r2,255
   26508:	1080201c 	xori	r2,r2,128
   2650c:	10bfe004 	addi	r2,r2,-128
   26510:	00c000f4 	movhi	r3,3
   26514:	18c86204 	addi	r3,r3,8584
   26518:	10801224 	muli	r2,r2,72
   2651c:	1885883a 	add	r2,r3,r2
   26520:	10800a04 	addi	r2,r2,40
   26524:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_stat_base	= TSE_NO_SHARED_FIFO;
   26528:	d0a8f7c3 	ldbu	r2,-23585(gp)
   2652c:	10803fcc 	andi	r2,r2,255
   26530:	1080201c 	xori	r2,r2,128
   26534:	10bfe004 	addi	r2,r2,-128
   26538:	00c000f4 	movhi	r3,3
   2653c:	18c86204 	addi	r3,r3,8584
   26540:	10801224 	muli	r2,r2,72
   26544:	1885883a 	add	r2,r3,r2
   26548:	10800b04 	addi	r2,r2,44
   2654c:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_depth       = TSE_NO_SHARED_FIFO;
   26550:	d0a8f7c3 	ldbu	r2,-23585(gp)
   26554:	10803fcc 	andi	r2,r2,255
   26558:	1080201c 	xori	r2,r2,128
   2655c:	10bfe004 	addi	r2,r2,-128
   26560:	00c000f4 	movhi	r3,3
   26564:	18c86204 	addi	r3,r3,8584
   26568:	10801224 	muli	r2,r2,72
   2656c:	1885883a 	add	r2,r3,r2
   26570:	10800c04 	addi	r2,r2,48
   26574:	10000015 	stw	zero,0(r2)
			
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_ctrl_base	= TSE_NO_SHARED_FIFO;
   26578:	d0a8f7c3 	ldbu	r2,-23585(gp)
   2657c:	10803fcc 	andi	r2,r2,255
   26580:	1080201c 	xori	r2,r2,128
   26584:	10bfe004 	addi	r2,r2,-128
   26588:	00c000f4 	movhi	r3,3
   2658c:	18c86204 	addi	r3,r3,8584
   26590:	10801224 	muli	r2,r2,72
   26594:	1885883a 	add	r2,r3,r2
   26598:	10800d04 	addi	r2,r2,52
   2659c:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_stat_base	= TSE_NO_SHARED_FIFO;
   265a0:	d0a8f7c3 	ldbu	r2,-23585(gp)
   265a4:	10803fcc 	andi	r2,r2,255
   265a8:	1080201c 	xori	r2,r2,128
   265ac:	10bfe004 	addi	r2,r2,-128
   265b0:	00c000f4 	movhi	r3,3
   265b4:	18c86204 	addi	r3,r3,8584
   265b8:	10801224 	muli	r2,r2,72
   265bc:	1885883a 	add	r2,r3,r2
   265c0:	10800e04 	addi	r2,r2,56
   265c4:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_depth       = TSE_NO_SHARED_FIFO;
   265c8:	d0a8f7c3 	ldbu	r2,-23585(gp)
   265cc:	10803fcc 	andi	r2,r2,255
   265d0:	1080201c 	xori	r2,r2,128
   265d4:	10bfe004 	addi	r2,r2,-128
   265d8:	00c000f4 	movhi	r3,3
   265dc:	18c86204 	addi	r3,r3,8584
   265e0:	10801224 	muli	r2,r2,72
   265e4:	1885883a 	add	r2,r3,r2
   265e8:	10800f04 	addi	r2,r2,60
   265ec:	10000015 	stw	zero,0(r2)
   265f0:	00005406 	br	26744 <alt_tse_system_add_sys+0x8ac>
		}
		else {
			tse_mac_device[tse_system_count].use_shared_fifo                = pfifo->use_shared_fifo;
   265f4:	d0a8f7c3 	ldbu	r2,-23585(gp)
   265f8:	10803fcc 	andi	r2,r2,255
   265fc:	1080201c 	xori	r2,r2,128
   26600:	10bfe004 	addi	r2,r2,-128
   26604:	e0fff917 	ldw	r3,-28(fp)
   26608:	18c00003 	ldbu	r3,0(r3)
   2660c:	010000f4 	movhi	r4,3
   26610:	21086204 	addi	r4,r4,8584
   26614:	10801224 	muli	r2,r2,72
   26618:	2085883a 	add	r2,r4,r2
   2661c:	10800904 	addi	r2,r2,36
   26620:	10c00005 	stb	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_ctrl_base	= pfifo->tse_shared_fifo_tx_ctrl_base;
   26624:	d0a8f7c3 	ldbu	r2,-23585(gp)
   26628:	10803fcc 	andi	r2,r2,255
   2662c:	1080201c 	xori	r2,r2,128
   26630:	10bfe004 	addi	r2,r2,-128
   26634:	e0fff917 	ldw	r3,-28(fp)
   26638:	18c00117 	ldw	r3,4(r3)
   2663c:	010000f4 	movhi	r4,3
   26640:	21086204 	addi	r4,r4,8584
   26644:	10801224 	muli	r2,r2,72
   26648:	2085883a 	add	r2,r4,r2
   2664c:	10800a04 	addi	r2,r2,40
   26650:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_stat_base	= pfifo->tse_shared_fifo_tx_stat_base;
   26654:	d0a8f7c3 	ldbu	r2,-23585(gp)
   26658:	10803fcc 	andi	r2,r2,255
   2665c:	1080201c 	xori	r2,r2,128
   26660:	10bfe004 	addi	r2,r2,-128
   26664:	e0fff917 	ldw	r3,-28(fp)
   26668:	18c00217 	ldw	r3,8(r3)
   2666c:	010000f4 	movhi	r4,3
   26670:	21086204 	addi	r4,r4,8584
   26674:	10801224 	muli	r2,r2,72
   26678:	2085883a 	add	r2,r4,r2
   2667c:	10800b04 	addi	r2,r2,44
   26680:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_depth       = pfifo->tse_shared_fifo_tx_depth;
   26684:	d0a8f7c3 	ldbu	r2,-23585(gp)
   26688:	10803fcc 	andi	r2,r2,255
   2668c:	1080201c 	xori	r2,r2,128
   26690:	10bfe004 	addi	r2,r2,-128
   26694:	e0fff917 	ldw	r3,-28(fp)
   26698:	18c00317 	ldw	r3,12(r3)
   2669c:	010000f4 	movhi	r4,3
   266a0:	21086204 	addi	r4,r4,8584
   266a4:	10801224 	muli	r2,r2,72
   266a8:	2085883a 	add	r2,r4,r2
   266ac:	10800c04 	addi	r2,r2,48
   266b0:	10c00015 	stw	r3,0(r2)
			
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_ctrl_base	= pfifo->tse_shared_fifo_rx_ctrl_base;
   266b4:	d0a8f7c3 	ldbu	r2,-23585(gp)
   266b8:	10803fcc 	andi	r2,r2,255
   266bc:	1080201c 	xori	r2,r2,128
   266c0:	10bfe004 	addi	r2,r2,-128
   266c4:	e0fff917 	ldw	r3,-28(fp)
   266c8:	18c00417 	ldw	r3,16(r3)
   266cc:	010000f4 	movhi	r4,3
   266d0:	21086204 	addi	r4,r4,8584
   266d4:	10801224 	muli	r2,r2,72
   266d8:	2085883a 	add	r2,r4,r2
   266dc:	10800d04 	addi	r2,r2,52
   266e0:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_stat_base	= pfifo->tse_shared_fifo_rx_stat_base;
   266e4:	d0a8f7c3 	ldbu	r2,-23585(gp)
   266e8:	10803fcc 	andi	r2,r2,255
   266ec:	1080201c 	xori	r2,r2,128
   266f0:	10bfe004 	addi	r2,r2,-128
   266f4:	e0fff917 	ldw	r3,-28(fp)
   266f8:	18c00517 	ldw	r3,20(r3)
   266fc:	010000f4 	movhi	r4,3
   26700:	21086204 	addi	r4,r4,8584
   26704:	10801224 	muli	r2,r2,72
   26708:	2085883a 	add	r2,r4,r2
   2670c:	10800e04 	addi	r2,r2,56
   26710:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_depth       = pfifo->tse_shared_fifo_rx_depth;
   26714:	d0a8f7c3 	ldbu	r2,-23585(gp)
   26718:	10803fcc 	andi	r2,r2,255
   2671c:	1080201c 	xori	r2,r2,128
   26720:	10bfe004 	addi	r2,r2,-128
   26724:	e0fff917 	ldw	r3,-28(fp)
   26728:	18c00617 	ldw	r3,24(r3)
   2672c:	010000f4 	movhi	r4,3
   26730:	21086204 	addi	r4,r4,8584
   26734:	10801224 	muli	r2,r2,72
   26738:	2085883a 	add	r2,r4,r2
   2673c:	10800f04 	addi	r2,r2,60
   26740:	10c00015 	stw	r3,0(r2)
		}
		
		/* Add PHY info to alt_tse_system_info structure */
		if(pphy == 0) {
   26744:	e0bffa17 	ldw	r2,-24(fp)
   26748:	1000161e 	bne	r2,zero,267a4 <alt_tse_system_add_sys+0x90c>
			tse_mac_device[tse_system_count].tse_phy_mdio_address	= TSE_PHY_AUTO_ADDRESS;
   2674c:	d0a8f7c3 	ldbu	r2,-23585(gp)
   26750:	10803fcc 	andi	r2,r2,255
   26754:	1080201c 	xori	r2,r2,128
   26758:	10bfe004 	addi	r2,r2,-128
   2675c:	00c000f4 	movhi	r3,3
   26760:	18c86204 	addi	r3,r3,8584
   26764:	10801224 	muli	r2,r2,72
   26768:	1885883a 	add	r2,r3,r2
   2676c:	10801004 	addi	r2,r2,64
   26770:	00ffffc4 	movi	r3,-1
   26774:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_phy_cfg 			= 0;
   26778:	d0a8f7c3 	ldbu	r2,-23585(gp)
   2677c:	10803fcc 	andi	r2,r2,255
   26780:	1080201c 	xori	r2,r2,128
   26784:	10bfe004 	addi	r2,r2,-128
   26788:	00c000f4 	movhi	r3,3
   2678c:	18c86204 	addi	r3,r3,8584
   26790:	10801224 	muli	r2,r2,72
   26794:	1885883a 	add	r2,r3,r2
   26798:	10801104 	addi	r2,r2,68
   2679c:	10000015 	stw	zero,0(r2)
   267a0:	00001806 	br	26804 <alt_tse_system_add_sys+0x96c>
		}
		else {
			tse_mac_device[tse_system_count].tse_phy_mdio_address	= pphy->tse_phy_mdio_address;
   267a4:	d0a8f7c3 	ldbu	r2,-23585(gp)
   267a8:	10803fcc 	andi	r2,r2,255
   267ac:	1080201c 	xori	r2,r2,128
   267b0:	10bfe004 	addi	r2,r2,-128
   267b4:	e0fffa17 	ldw	r3,-24(fp)
   267b8:	18c00017 	ldw	r3,0(r3)
   267bc:	010000f4 	movhi	r4,3
   267c0:	21086204 	addi	r4,r4,8584
   267c4:	10801224 	muli	r2,r2,72
   267c8:	2085883a 	add	r2,r4,r2
   267cc:	10801004 	addi	r2,r2,64
   267d0:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_phy_cfg 			= pphy->tse_phy_cfg;
   267d4:	d0a8f7c3 	ldbu	r2,-23585(gp)
   267d8:	10803fcc 	andi	r2,r2,255
   267dc:	1080201c 	xori	r2,r2,128
   267e0:	10bfe004 	addi	r2,r2,-128
   267e4:	e0fffa17 	ldw	r3,-24(fp)
   267e8:	18c00117 	ldw	r3,4(r3)
   267ec:	010000f4 	movhi	r4,3
   267f0:	21086204 	addi	r4,r4,8584
   267f4:	10801224 	muli	r2,r2,72
   267f8:	2085883a 	add	r2,r4,r2
   267fc:	10801104 	addi	r2,r2,68
   26800:	10c00015 	stw	r3,0(r2)
		}
		
		/* Point to next structure */
		psgdma++;
   26804:	e0bff717 	ldw	r2,-36(fp)
   26808:	10800304 	addi	r2,r2,12
   2680c:	e0bff715 	stw	r2,-36(fp)
		if(pmem) pmem++;
   26810:	e0bff817 	ldw	r2,-32(fp)
   26814:	10000326 	beq	r2,zero,26824 <alt_tse_system_add_sys+0x98c>
   26818:	e0bff817 	ldw	r2,-32(fp)
   2681c:	10800204 	addi	r2,r2,8
   26820:	e0bff815 	stw	r2,-32(fp)
		if(pfifo) pfifo++;
   26824:	e0bff917 	ldw	r2,-28(fp)
   26828:	10000326 	beq	r2,zero,26838 <alt_tse_system_add_sys+0x9a0>
   2682c:	e0bff917 	ldw	r2,-28(fp)
   26830:	10800704 	addi	r2,r2,28
   26834:	e0bff915 	stw	r2,-28(fp)
		if(pphy) pphy++;
   26838:	e0bffa17 	ldw	r2,-24(fp)
   2683c:	10000326 	beq	r2,zero,2684c <alt_tse_system_add_sys+0x9b4>
   26840:	e0bffa17 	ldw	r2,-24(fp)
   26844:	10800204 	addi	r2,r2,8
   26848:	e0bffa15 	stw	r2,-24(fp)
		
		tse_system_count++;
   2684c:	d0a8f7c3 	ldbu	r2,-23585(gp)
   26850:	10800044 	addi	r2,r2,1
   26854:	d0a8f7c5 	stb	r2,-23585(gp)
		max_mac_system = tse_system_count;
   26858:	d0a8f7c3 	ldbu	r2,-23585(gp)
   2685c:	d0a01b05 	stb	r2,-32660(gp)
	else {
		tse_dprintf(2, "ERROR   : Invalid number of channel specified!\n");
		return ALTERA_TSE_SYSTEM_DEF_ERROR;
	}

	for(i = 0; i < loop_end; i++) {
   26860:	e0bff517 	ldw	r2,-44(fp)
   26864:	10800044 	addi	r2,r2,1
   26868:	e0bff515 	stw	r2,-44(fp)
   2686c:	e0fff517 	ldw	r3,-44(fp)
   26870:	e0bff617 	ldw	r2,-40(fp)
   26874:	18bdb216 	blt	r3,r2,25f40 <alt_tse_system_add_sys+0xa8>
		
		tse_system_count++;
		max_mac_system = tse_system_count;
	}
	
	return SUCCESS;
   26878:	0005883a 	mov	r2,zero
	
}
   2687c:	e037883a 	mov	sp,fp
   26880:	dfc00217 	ldw	ra,8(sp)
   26884:	df000117 	ldw	fp,4(sp)
   26888:	dc000017 	ldw	r16,0(sp)
   2688c:	dec00304 	addi	sp,sp,12
   26890:	f800283a 	ret

00026894 <alt_tse_sys_enable_mdio_sharing>:
 * @param		number_of_mac  number of MAC sharing MDIO block
 * @return      SUCCESS on success
 * 				ALTERA_TSE_SYSTEM_DEF_ERROR if definition of system incorrect or pointer == NULL
 * Multi-channel MAC not supported
 */
alt_32 alt_tse_sys_enable_mdio_sharing(alt_tse_system_mac **psys_mac_list, alt_u8 number_of_mac) {
   26894:	defff904 	addi	sp,sp,-28
   26898:	dfc00615 	stw	ra,24(sp)
   2689c:	df000515 	stw	fp,20(sp)
   268a0:	df000504 	addi	fp,sp,20
   268a4:	e13ffe15 	stw	r4,-8(fp)
   268a8:	2805883a 	mov	r2,r5
   268ac:	e0bfff05 	stb	r2,-4(fp)
	alt_32 i;
	alt_32 j;
	
	alt_tse_system_mac *psys_mac;
	
	for(i = 0; i < number_of_mac; i++) {
   268b0:	e03ffb15 	stw	zero,-20(fp)
   268b4:	00004706 	br	269d4 <alt_tse_sys_enable_mdio_sharing+0x140>
		psys_mac = psys_mac_list[i];
   268b8:	e0bffb17 	ldw	r2,-20(fp)
   268bc:	1085883a 	add	r2,r2,r2
   268c0:	1085883a 	add	r2,r2,r2
   268c4:	e0fffe17 	ldw	r3,-8(fp)
   268c8:	1885883a 	add	r2,r3,r2
   268cc:	10800017 	ldw	r2,0(r2)
   268d0:	e0bffd15 	stw	r2,-12(fp)
		
		if(psys_mac == 0) {
   268d4:	e0bffd17 	ldw	r2,-12(fp)
   268d8:	1000081e 	bne	r2,zero,268fc <alt_tse_sys_enable_mdio_sharing+0x68>
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
   268dc:	010000f4 	movhi	r4,3
   268e0:	21013404 	addi	r4,r4,1232
   268e4:	00172f80 	call	172f8 <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_sys_enable_mdio_sharing()\n");
   268e8:	010000f4 	movhi	r4,3
   268ec:	21019904 	addi	r4,r4,1636
   268f0:	00172f80 	call	172f8 <puts>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
   268f4:	00bfffc4 	movi	r2,-1
   268f8:	00003a06 	br	269e4 <alt_tse_sys_enable_mdio_sharing+0x150>
		}
		
		for(j = 0; j < max_mac_system; j++) {
   268fc:	e03ffc15 	stw	zero,-16(fp)
   26900:	00002d06 	br	269b8 <alt_tse_sys_enable_mdio_sharing+0x124>
			
			if(psys_mac->tse_mac_base == tse_mac_device[j].tse_mac_base) {
   26904:	e0bffd17 	ldw	r2,-12(fp)
   26908:	10c00017 	ldw	r3,0(r2)
   2690c:	010000f4 	movhi	r4,3
   26910:	21086204 	addi	r4,r4,8584
   26914:	e0bffc17 	ldw	r2,-16(fp)
   26918:	10801224 	muli	r2,r2,72
   2691c:	2085883a 	add	r2,r4,r2
   26920:	10800017 	ldw	r2,0(r2)
   26924:	1880211e 	bne	r3,r2,269ac <alt_tse_sys_enable_mdio_sharing+0x118>
				if(tse_mac_device[j].tse_multichannel_mac) {
   26928:	00c000f4 	movhi	r3,3
   2692c:	18c86204 	addi	r3,r3,8584
   26930:	e0bffc17 	ldw	r2,-16(fp)
   26934:	10801224 	muli	r2,r2,72
   26938:	1885883a 	add	r2,r3,r2
   2693c:	10800204 	addi	r2,r2,8
   26940:	108000c3 	ldbu	r2,3(r2)
   26944:	10803fcc 	andi	r2,r2,255
   26948:	10000826 	beq	r2,zero,2696c <alt_tse_sys_enable_mdio_sharing+0xd8>
					tse_dprintf(2, "ERROR   : MDIO sharing supported by default for Multi-channel MAC\n");
   2694c:	010000f4 	movhi	r4,3
   26950:	2101ad04 	addi	r4,r4,1716
   26954:	00172f80 	call	172f8 <puts>
					tse_dprintf(2, "ERROR   : Do not include Multi-channel MAC in the MAC List\n");
   26958:	010000f4 	movhi	r4,3
   2695c:	2101be04 	addi	r4,r4,1784
   26960:	00172f80 	call	172f8 <puts>
					return ALTERA_TSE_SYSTEM_DEF_ERROR;
   26964:	00bfffc4 	movi	r2,-1
   26968:	00001e06 	br	269e4 <alt_tse_sys_enable_mdio_sharing+0x150>
				}
				
				tse_mac_device[j].tse_mdio_shared = 1;
   2696c:	00c000f4 	movhi	r3,3
   26970:	18c86204 	addi	r3,r3,8584
   26974:	e0bffc17 	ldw	r2,-16(fp)
   26978:	10801224 	muli	r2,r2,72
   2697c:	1885883a 	add	r2,r3,r2
   26980:	10800304 	addi	r2,r2,12
   26984:	00c00044 	movi	r3,1
   26988:	10c00045 	stb	r3,1(r2)
				tse_mac_device[j].tse_number_of_mac_mdio_shared = number_of_mac;
   2698c:	00c000f4 	movhi	r3,3
   26990:	18c86204 	addi	r3,r3,8584
   26994:	e0bffc17 	ldw	r2,-16(fp)
   26998:	10801224 	muli	r2,r2,72
   2699c:	1885883a 	add	r2,r3,r2
   269a0:	10800304 	addi	r2,r2,12
   269a4:	e0ffff03 	ldbu	r3,-4(fp)
   269a8:	10c00085 	stb	r3,2(r2)
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_sys_enable_mdio_sharing()\n");
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
		}
		
		for(j = 0; j < max_mac_system; j++) {
   269ac:	e0bffc17 	ldw	r2,-16(fp)
   269b0:	10800044 	addi	r2,r2,1
   269b4:	e0bffc15 	stw	r2,-16(fp)
   269b8:	d0a01b03 	ldbu	r2,-32660(gp)
   269bc:	10803fcc 	andi	r2,r2,255
   269c0:	e0fffc17 	ldw	r3,-16(fp)
   269c4:	18bfcf16 	blt	r3,r2,26904 <alt_tse_sys_enable_mdio_sharing+0x70>
	alt_32 i;
	alt_32 j;
	
	alt_tse_system_mac *psys_mac;
	
	for(i = 0; i < number_of_mac; i++) {
   269c8:	e0bffb17 	ldw	r2,-20(fp)
   269cc:	10800044 	addi	r2,r2,1
   269d0:	e0bffb15 	stw	r2,-20(fp)
   269d4:	e0bfff03 	ldbu	r2,-4(fp)
   269d8:	e0fffb17 	ldw	r3,-20(fp)
   269dc:	18bfb616 	blt	r3,r2,268b8 <alt_tse_sys_enable_mdio_sharing+0x24>
				tse_mac_device[j].tse_number_of_mac_mdio_shared = number_of_mac;
			}
		}	
	}
	
	return SUCCESS;
   269e0:	0005883a 	mov	r2,zero
}
   269e4:	e037883a 	mov	sp,fp
   269e8:	dfc00117 	ldw	ra,4(sp)
   269ec:	df000017 	ldw	fp,0(sp)
   269f0:	dec00204 	addi	sp,sp,8
   269f4:	f800283a 	ret

000269f8 <alt_tse_mac_get_common_speed>:
/* @Function Description: Get the common speed supported by all PHYs connected to the MAC within the same group
 * @API Type:           Public
 * @param pmac          Pointer to the TSE MAC Control Interface Base address
 * @return              common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if no common speed found
 */
alt_32 alt_tse_mac_get_common_speed(np_tse_mac *pmac) {
   269f8:	defffc04 	addi	sp,sp,-16
   269fc:	dfc00315 	stw	ra,12(sp)
   26a00:	df000215 	stw	fp,8(sp)
   26a04:	df000204 	addi	fp,sp,8
   26a08:	e13fff15 	stw	r4,-4(fp)
    alt_tse_mac_group *pmac_group = alt_tse_get_mac_info(pmac)->pmac_group;
   26a0c:	e13fff17 	ldw	r4,-4(fp)
   26a10:	0026be00 	call	26be0 <alt_tse_get_mac_info>
   26a14:	10800317 	ldw	r2,12(r2)
   26a18:	e0bffe15 	stw	r2,-8(fp)
    return alt_tse_phy_get_common_speed(pmac_group);
   26a1c:	e13ffe17 	ldw	r4,-8(fp)
   26a20:	0029d780 	call	29d78 <alt_tse_phy_get_common_speed>
}
   26a24:	e037883a 	mov	sp,fp
   26a28:	dfc00117 	ldw	ra,4(sp)
   26a2c:	df000017 	ldw	fp,0(sp)
   26a30:	dec00204 	addi	sp,sp,8
   26a34:	f800283a 	ret

00026a38 <alt_tse_mac_set_common_speed>:
 * @API Type:               Public
 * @param pmac              Pointer to the TSE MAC Control Interface Base address
 *        common_speed      common speed supported by all PHYs
 * @return                  common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if invalid common speed specified
 */
alt_32 alt_tse_mac_set_common_speed(np_tse_mac *pmac, alt_32 common_speed) {
   26a38:	defffb04 	addi	sp,sp,-20
   26a3c:	dfc00415 	stw	ra,16(sp)
   26a40:	df000315 	stw	fp,12(sp)
   26a44:	df000304 	addi	fp,sp,12
   26a48:	e13ffe15 	stw	r4,-8(fp)
   26a4c:	e17fff15 	stw	r5,-4(fp)
    alt_tse_mac_group *pmac_group = alt_tse_get_mac_info(pmac)->pmac_group;
   26a50:	e13ffe17 	ldw	r4,-8(fp)
   26a54:	0026be00 	call	26be0 <alt_tse_get_mac_info>
   26a58:	10800317 	ldw	r2,12(r2)
   26a5c:	e0bffd15 	stw	r2,-12(fp)
    return alt_tse_phy_set_common_speed(pmac_group, common_speed);
   26a60:	e13ffd17 	ldw	r4,-12(fp)
   26a64:	e17fff17 	ldw	r5,-4(fp)
   26a68:	002a0a00 	call	2a0a0 <alt_tse_phy_set_common_speed>
}
   26a6c:	e037883a 	mov	sp,fp
   26a70:	dfc00117 	ldw	ra,4(sp)
   26a74:	df000017 	ldw	fp,0(sp)
   26a78:	dec00204 	addi	sp,sp,8
   26a7c:	f800283a 	ret

00026a80 <alt_tse_get_system_index>:
/* @Function Description: Get the index of alt_tse_system_info structure in tse_mac_device[]
 * @API Type:        Internal
 * @param psys_info  Pointer to the alt_tse_system_info structure
 * @return           Index of alt_tse_system_info structure in tse_mac_device[]
 */
alt_32 alt_tse_get_system_index(alt_tse_system_info *psys_info) {
   26a80:	defffd04 	addi	sp,sp,-12
   26a84:	df000215 	stw	fp,8(sp)
   26a88:	df000204 	addi	fp,sp,8
   26a8c:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
    
    for(i = 0; i < max_mac_system; i++) {
   26a90:	e03ffe15 	stw	zero,-8(fp)
   26a94:	00000c06 	br	26ac8 <alt_tse_get_system_index+0x48>
        if(psys_info == &tse_mac_device[i]) {
   26a98:	e0bffe17 	ldw	r2,-8(fp)
   26a9c:	10c01224 	muli	r3,r2,72
   26aa0:	008000f4 	movhi	r2,3
   26aa4:	10886204 	addi	r2,r2,8584
   26aa8:	1887883a 	add	r3,r3,r2
   26aac:	e0bfff17 	ldw	r2,-4(fp)
   26ab0:	1880021e 	bne	r3,r2,26abc <alt_tse_get_system_index+0x3c>
            return i;
   26ab4:	e0bffe17 	ldw	r2,-8(fp)
   26ab8:	00000806 	br	26adc <alt_tse_get_system_index+0x5c>
 * @return           Index of alt_tse_system_info structure in tse_mac_device[]
 */
alt_32 alt_tse_get_system_index(alt_tse_system_info *psys_info) {
	alt_32 i;
    
    for(i = 0; i < max_mac_system; i++) {
   26abc:	e0bffe17 	ldw	r2,-8(fp)
   26ac0:	10800044 	addi	r2,r2,1
   26ac4:	e0bffe15 	stw	r2,-8(fp)
   26ac8:	d0a01b03 	ldbu	r2,-32660(gp)
   26acc:	10803fcc 	andi	r2,r2,255
   26ad0:	e0fffe17 	ldw	r3,-8(fp)
   26ad4:	18bff016 	blt	r3,r2,26a98 <alt_tse_get_system_index+0x18>
        if(psys_info == &tse_mac_device[i]) {
            return i;
        }
    }
    return ALTERA_TSE_NO_INDEX_FOUND;
   26ad8:	00bfffc4 	movi	r2,-1
}
   26adc:	e037883a 	mov	sp,fp
   26ae0:	df000017 	ldw	fp,0(sp)
   26ae4:	dec00104 	addi	sp,sp,4
   26ae8:	f800283a 	ret

00026aec <alt_tse_get_mac_group_index>:
/* @Function Description: Get the index of alt_tse_mac_group structure in pmac_groups[]
 * @API Type:         Internal
 * @param pmac_group  Pointer to the alt_tse_mac_group structure
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
   26aec:	defffd04 	addi	sp,sp,-12
   26af0:	df000215 	stw	fp,8(sp)
   26af4:	df000204 	addi	fp,sp,8
   26af8:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
   26afc:	e03ffe15 	stw	zero,-8(fp)
   26b00:	00000e06 	br	26b3c <alt_tse_get_mac_group_index+0x50>
        if(pmac_group == pmac_groups[i]) {
   26b04:	00c00134 	movhi	r3,4
   26b08:	18d1b404 	addi	r3,r3,18128
   26b0c:	e0bffe17 	ldw	r2,-8(fp)
   26b10:	1085883a 	add	r2,r2,r2
   26b14:	1085883a 	add	r2,r2,r2
   26b18:	1885883a 	add	r2,r3,r2
   26b1c:	10c00017 	ldw	r3,0(r2)
   26b20:	e0bfff17 	ldw	r2,-4(fp)
   26b24:	1880021e 	bne	r3,r2,26b30 <alt_tse_get_mac_group_index+0x44>
            return i;
   26b28:	e0bffe17 	ldw	r2,-8(fp)
   26b2c:	00000806 	br	26b50 <alt_tse_get_mac_group_index+0x64>
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
   26b30:	e0bffe17 	ldw	r2,-8(fp)
   26b34:	10800044 	addi	r2,r2,1
   26b38:	e0bffe15 	stw	r2,-8(fp)
   26b3c:	d0a8f743 	ldbu	r2,-23587(gp)
   26b40:	10803fcc 	andi	r2,r2,255
   26b44:	e0fffe17 	ldw	r3,-8(fp)
   26b48:	18bfee16 	blt	r3,r2,26b04 <alt_tse_get_mac_group_index+0x18>
        if(pmac_group == pmac_groups[i]) {
            return i;
        }
    }
    return ALTERA_TSE_NO_INDEX_FOUND;
   26b4c:	00bfffc4 	movi	r2,-1
}
   26b50:	e037883a 	mov	sp,fp
   26b54:	df000017 	ldw	fp,0(sp)
   26b58:	dec00104 	addi	sp,sp,4
   26b5c:	f800283a 	ret

00026b60 <alt_tse_get_mac_info_index>:
/* @Function Description: Get the index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 * @API Type:         Internal
 * @param pmac_group  Pointer to the alt_tse_mac_info structure
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
   26b60:	defffd04 	addi	sp,sp,-12
   26b64:	df000215 	stw	fp,8(sp)
   26b68:	df000204 	addi	fp,sp,8
   26b6c:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   26b70:	e03ffe15 	stw	zero,-8(fp)
   26b74:	00000f06 	br	26bb4 <alt_tse_get_mac_info_index+0x54>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
   26b78:	e0bfff17 	ldw	r2,-4(fp)
   26b7c:	10c00317 	ldw	r3,12(r2)
   26b80:	e0bffe17 	ldw	r2,-8(fp)
   26b84:	10800044 	addi	r2,r2,1
   26b88:	1085883a 	add	r2,r2,r2
   26b8c:	1085883a 	add	r2,r2,r2
   26b90:	1885883a 	add	r2,r3,r2
   26b94:	10c00017 	ldw	r3,0(r2)
   26b98:	e0bfff17 	ldw	r2,-4(fp)
   26b9c:	1880021e 	bne	r3,r2,26ba8 <alt_tse_get_mac_info_index+0x48>
            return i;
   26ba0:	e0bffe17 	ldw	r2,-8(fp)
   26ba4:	00000a06 	br	26bd0 <alt_tse_get_mac_info_index+0x70>
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   26ba8:	e0bffe17 	ldw	r2,-8(fp)
   26bac:	10800044 	addi	r2,r2,1
   26bb0:	e0bffe15 	stw	r2,-8(fp)
   26bb4:	e0bfff17 	ldw	r2,-4(fp)
   26bb8:	10800317 	ldw	r2,12(r2)
   26bbc:	10800003 	ldbu	r2,0(r2)
   26bc0:	10803fcc 	andi	r2,r2,255
   26bc4:	e0fffe17 	ldw	r3,-8(fp)
   26bc8:	18bfeb16 	blt	r3,r2,26b78 <alt_tse_get_mac_info_index+0x18>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
            return i;
        }
    }
    
    return ALTERA_TSE_NO_INDEX_FOUND;
   26bcc:	00bfffc4 	movi	r2,-1
}
   26bd0:	e037883a 	mov	sp,fp
   26bd4:	df000017 	ldw	fp,0(sp)
   26bd8:	dec00104 	addi	sp,sp,4
   26bdc:	f800283a 	ret

00026be0 <alt_tse_get_mac_info>:
/* @Function Description: Get the pointer of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 * @API Type:         Internal
 * @param pmac        Pointer to the TSE MAC Control Interface Base address
 * @return            Pointer to alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_tse_mac_info *alt_tse_get_mac_info(np_tse_mac *pmac) {
   26be0:	defffa04 	addi	sp,sp,-24
   26be4:	df000515 	stw	fp,20(sp)
   26be8:	df000504 	addi	fp,sp,20
   26bec:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
	alt_32 j;
    alt_tse_mac_group *pmac_group = 0;
   26bf0:	e03ffd15 	stw	zero,-12(fp)
    alt_tse_mac_info *pmac_info = 0;
   26bf4:	e03ffe15 	stw	zero,-8(fp)
    
    for(i = 0; i < mac_group_count; i++) {
   26bf8:	e03ffb15 	stw	zero,-20(fp)
   26bfc:	00002506 	br	26c94 <alt_tse_get_mac_info+0xb4>
        pmac_group = pmac_groups[i];
   26c00:	00c00134 	movhi	r3,4
   26c04:	18d1b404 	addi	r3,r3,18128
   26c08:	e0bffb17 	ldw	r2,-20(fp)
   26c0c:	1085883a 	add	r2,r2,r2
   26c10:	1085883a 	add	r2,r2,r2
   26c14:	1885883a 	add	r2,r3,r2
   26c18:	10800017 	ldw	r2,0(r2)
   26c1c:	e0bffd15 	stw	r2,-12(fp)
        for(j = 0; j < pmac_group->channel; j++) {
   26c20:	e03ffc15 	stw	zero,-16(fp)
   26c24:	00001306 	br	26c74 <alt_tse_get_mac_info+0x94>
            pmac_info = pmac_group->pmac_info[j];
   26c28:	e0fffd17 	ldw	r3,-12(fp)
   26c2c:	e0bffc17 	ldw	r2,-16(fp)
   26c30:	10800044 	addi	r2,r2,1
   26c34:	1085883a 	add	r2,r2,r2
   26c38:	1085883a 	add	r2,r2,r2
   26c3c:	1885883a 	add	r2,r3,r2
   26c40:	10800017 	ldw	r2,0(r2)
   26c44:	e0bffe15 	stw	r2,-8(fp)
            if(((np_tse_mac *) pmac_info->psys_info->tse_mac_base) == pmac) {
   26c48:	e0bffe17 	ldw	r2,-8(fp)
   26c4c:	10800217 	ldw	r2,8(r2)
   26c50:	10800017 	ldw	r2,0(r2)
   26c54:	1007883a 	mov	r3,r2
   26c58:	e0bfff17 	ldw	r2,-4(fp)
   26c5c:	1880021e 	bne	r3,r2,26c68 <alt_tse_get_mac_info+0x88>
                return pmac_info;
   26c60:	e0bffe17 	ldw	r2,-8(fp)
   26c64:	00001006 	br	26ca8 <alt_tse_get_mac_info+0xc8>
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
        pmac_group = pmac_groups[i];
        for(j = 0; j < pmac_group->channel; j++) {
   26c68:	e0bffc17 	ldw	r2,-16(fp)
   26c6c:	10800044 	addi	r2,r2,1
   26c70:	e0bffc15 	stw	r2,-16(fp)
   26c74:	e0bffd17 	ldw	r2,-12(fp)
   26c78:	10800003 	ldbu	r2,0(r2)
   26c7c:	10803fcc 	andi	r2,r2,255
   26c80:	e0fffc17 	ldw	r3,-16(fp)
   26c84:	18bfe816 	blt	r3,r2,26c28 <alt_tse_get_mac_info+0x48>
	alt_32 i;
	alt_32 j;
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
   26c88:	e0bffb17 	ldw	r2,-20(fp)
   26c8c:	10800044 	addi	r2,r2,1
   26c90:	e0bffb15 	stw	r2,-20(fp)
   26c94:	d0a8f743 	ldbu	r2,-23587(gp)
   26c98:	10803fcc 	andi	r2,r2,255
   26c9c:	e0fffb17 	ldw	r3,-20(fp)
   26ca0:	18bfd716 	blt	r3,r2,26c00 <alt_tse_get_mac_info+0x20>
                return pmac_info;
            }
        }        
    }
    
    return 0;
   26ca4:	0005883a 	mov	r2,zero
}
   26ca8:	e037883a 	mov	sp,fp
   26cac:	df000017 	ldw	fp,0(sp)
   26cb0:	dec00104 	addi	sp,sp,4
   26cb4:	f800283a 	ret

00026cb8 <alt_tse_mac_set_speed>:
 * @param pmac  Pointer to the TSE MAC Control Interface Base address
 * @param speed 2 = 1000 Mbps, 1 = 100 Mbps, 0 = 10 Mbps
 * @return ENP_PARAM if invalid speed specified, else return SUCCESS
 */
alt_32 alt_tse_mac_set_speed(np_tse_mac *pmac, alt_u8 speed)
{
   26cb8:	defffc04 	addi	sp,sp,-16
   26cbc:	df000315 	stw	fp,12(sp)
   26cc0:	df000304 	addi	fp,sp,12
   26cc4:	e13ffe15 	stw	r4,-8(fp)
   26cc8:	2805883a 	mov	r2,r5
   26ccc:	e0bfff05 	stb	r2,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
   26cd0:	e0bffe17 	ldw	r2,-8(fp)
   26cd4:	10800204 	addi	r2,r2,8
   26cd8:	10800037 	ldwio	r2,0(r2)
   26cdc:	e0bffd15 	stw	r2,-12(fp)
  
  /* 1000 Mbps */
  if(speed == TSE_PHY_SPEED_1000) {
   26ce0:	e0bfff03 	ldbu	r2,-4(fp)
   26ce4:	10800098 	cmpnei	r2,r2,2
   26ce8:	1000091e 	bne	r2,zero,26d10 <alt_tse_mac_set_speed+0x58>
    helpvar |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
   26cec:	e0bffd17 	ldw	r2,-12(fp)
   26cf0:	10800214 	ori	r2,r2,8
   26cf4:	e0bffd15 	stw	r2,-12(fp)
	helpvar &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
   26cf8:	e0fffd17 	ldw	r3,-12(fp)
   26cfc:	00bf8034 	movhi	r2,65024
   26d00:	10bfffc4 	addi	r2,r2,-1
   26d04:	1884703a 	and	r2,r3,r2
   26d08:	e0bffd15 	stw	r2,-12(fp)
   26d0c:	00001906 	br	26d74 <alt_tse_mac_set_speed+0xbc>
  }
  /* 100 Mbps */
  else if(speed == TSE_PHY_SPEED_100) {
   26d10:	e0bfff03 	ldbu	r2,-4(fp)
   26d14:	10800058 	cmpnei	r2,r2,1
   26d18:	10000a1e 	bne	r2,zero,26d44 <alt_tse_mac_set_speed+0x8c>
    helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
   26d1c:	e0fffd17 	ldw	r3,-12(fp)
   26d20:	00bffdc4 	movi	r2,-9
   26d24:	1884703a 	and	r2,r3,r2
   26d28:	e0bffd15 	stw	r2,-12(fp)
	helpvar &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
   26d2c:	e0fffd17 	ldw	r3,-12(fp)
   26d30:	00bf8034 	movhi	r2,65024
   26d34:	10bfffc4 	addi	r2,r2,-1
   26d38:	1884703a 	and	r2,r3,r2
   26d3c:	e0bffd15 	stw	r2,-12(fp)
   26d40:	00000c06 	br	26d74 <alt_tse_mac_set_speed+0xbc>
  }
  /* 10 Mbps */
  else if(speed == TSE_PHY_SPEED_10) {
   26d44:	e0bfff03 	ldbu	r2,-4(fp)
   26d48:	1000081e 	bne	r2,zero,26d6c <alt_tse_mac_set_speed+0xb4>
    helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
   26d4c:	e0fffd17 	ldw	r3,-12(fp)
   26d50:	00bffdc4 	movi	r2,-9
   26d54:	1884703a 	and	r2,r3,r2
   26d58:	e0bffd15 	stw	r2,-12(fp)
	helpvar |= ALTERA_TSEMAC_CMD_ENA_10_MSK;
   26d5c:	e0bffd17 	ldw	r2,-12(fp)
   26d60:	10808034 	orhi	r2,r2,512
   26d64:	e0bffd15 	stw	r2,-12(fp)
   26d68:	00000206 	br	26d74 <alt_tse_mac_set_speed+0xbc>
  }  
  else {
    return ENP_PARAM;
   26d6c:	00bffd84 	movi	r2,-10
   26d70:	00000506 	br	26d88 <alt_tse_mac_set_speed+0xd0>
  }
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac, helpvar);
   26d74:	e0bffe17 	ldw	r2,-8(fp)
   26d78:	10800204 	addi	r2,r2,8
   26d7c:	e0fffd17 	ldw	r3,-12(fp)
   26d80:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
   26d84:	0005883a 	mov	r2,zero
}
   26d88:	e037883a 	mov	sp,fp
   26d8c:	df000017 	ldw	fp,0(sp)
   26d90:	dec00104 	addi	sp,sp,4
   26d94:	f800283a 	ret

00026d98 <alt_tse_mac_set_duplex>:
 * @param pmac  Pointer to the TSE MAC Control Interface Base address
 * @param duplex 1 = Full Duplex, 0 = Half Duplex
 * @return ENP_PARAM if invalid duplex specified, else return SUCCESS
 */
alt_32 alt_tse_mac_set_duplex(np_tse_mac *pmac, alt_u8 duplex)
{
   26d98:	defffc04 	addi	sp,sp,-16
   26d9c:	df000315 	stw	fp,12(sp)
   26da0:	df000304 	addi	fp,sp,12
   26da4:	e13ffe15 	stw	r4,-8(fp)
   26da8:	2805883a 	mov	r2,r5
   26dac:	e0bfff05 	stb	r2,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
   26db0:	e0bffe17 	ldw	r2,-8(fp)
   26db4:	10800204 	addi	r2,r2,8
   26db8:	10800037 	ldwio	r2,0(r2)
   26dbc:	e0bffd15 	stw	r2,-12(fp)
  
  /* Half Duplex */
  if(duplex == TSE_PHY_DUPLEX_HALF) {
   26dc0:	e0bfff03 	ldbu	r2,-4(fp)
   26dc4:	1000041e 	bne	r2,zero,26dd8 <alt_tse_mac_set_duplex+0x40>
    helpvar |= ALTERA_TSEMAC_CMD_HD_ENA_MSK;
   26dc8:	e0bffd17 	ldw	r2,-12(fp)
   26dcc:	10810014 	ori	r2,r2,1024
   26dd0:	e0bffd15 	stw	r2,-12(fp)
   26dd4:	00000a06 	br	26e00 <alt_tse_mac_set_duplex+0x68>
  } 
  /* Full Duplex */
  else if(duplex == TSE_PHY_DUPLEX_FULL) {
   26dd8:	e0bfff03 	ldbu	r2,-4(fp)
   26ddc:	10800058 	cmpnei	r2,r2,1
   26de0:	1000051e 	bne	r2,zero,26df8 <alt_tse_mac_set_duplex+0x60>
    helpvar &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
   26de4:	e0fffd17 	ldw	r3,-12(fp)
   26de8:	00beffc4 	movi	r2,-1025
   26dec:	1884703a 	and	r2,r3,r2
   26df0:	e0bffd15 	stw	r2,-12(fp)
   26df4:	00000206 	br	26e00 <alt_tse_mac_set_duplex+0x68>
  }
  else {
    return ENP_PARAM;
   26df8:	00bffd84 	movi	r2,-10
   26dfc:	00000506 	br	26e14 <alt_tse_mac_set_duplex+0x7c>
  }
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac, helpvar);
   26e00:	e0bffe17 	ldw	r2,-8(fp)
   26e04:	10800204 	addi	r2,r2,8
   26e08:	e0fffd17 	ldw	r3,-12(fp)
   26e0c:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
   26e10:	0005883a 	mov	r2,zero

}
   26e14:	e037883a 	mov	sp,fp
   26e18:	df000017 	ldw	fp,0(sp)
   26e1c:	dec00104 	addi	sp,sp,4
   26e20:	f800283a 	ret

00026e24 <getPHYSpeed>:
  	(((speed == TSE_PHY_SPEED_1000) ? 1 : 0) << 1) |   \
	(((speed == TSE_PHY_SPEED_100) ? 1 : 0) << 2) |     \
	(((speed == TSE_PHY_SPEED_10) ? 1 : 0) << 3) |      \
	((speed == TSE_PHY_SPEED_INVALID) ? ALT_TSE_E_INVALID_SPEED : 0))
  
alt_32 getPHYSpeed(np_tse_mac *pmac) {
   26e24:	defff404 	addi	sp,sp,-48
   26e28:	dfc00b15 	stw	ra,44(sp)
   26e2c:	df000a15 	stw	fp,40(sp)
   26e30:	df000a04 	addi	fp,sp,40
   26e34:	e13fff15 	stw	r4,-4(fp)

	alt_u8 speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
   26e38:	00800044 	movi	r2,1
   26e3c:	e0bff705 	stb	r2,-36(fp)
	alt_u8 duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;     /* 1 = full ; 0 = half*/
   26e40:	00800044 	movi	r2,1
   26e44:	e0bff745 	stb	r2,-35(fp)
	alt_32 result = ALT_TSE_SPEED_DUPLEX(speed, duplex);
   26e48:	e0bff743 	ldbu	r2,-35(fp)
   26e4c:	10c0004c 	andi	r3,r2,1
   26e50:	e0bff703 	ldbu	r2,-36(fp)
   26e54:	10800098 	cmpnei	r2,r2,2
   26e58:	1000021e 	bne	r2,zero,26e64 <getPHYSpeed+0x40>
   26e5c:	00800084 	movi	r2,2
   26e60:	00000106 	br	26e68 <getPHYSpeed+0x44>
   26e64:	0005883a 	mov	r2,zero
   26e68:	1886b03a 	or	r3,r3,r2
   26e6c:	e0bff703 	ldbu	r2,-36(fp)
   26e70:	10800058 	cmpnei	r2,r2,1
   26e74:	1000021e 	bne	r2,zero,26e80 <getPHYSpeed+0x5c>
   26e78:	00800104 	movi	r2,4
   26e7c:	00000106 	br	26e84 <getPHYSpeed+0x60>
   26e80:	0005883a 	mov	r2,zero
   26e84:	1886b03a 	or	r3,r3,r2
   26e88:	e0bff703 	ldbu	r2,-36(fp)
   26e8c:	1000021e 	bne	r2,zero,26e98 <getPHYSpeed+0x74>
   26e90:	00800204 	movi	r2,8
   26e94:	00000106 	br	26e9c <getPHYSpeed+0x78>
   26e98:	0005883a 	mov	r2,zero
   26e9c:	1886b03a 	or	r3,r3,r2
   26ea0:	e0bff703 	ldbu	r2,-36(fp)
   26ea4:	108000d8 	cmpnei	r2,r2,3
   26ea8:	1000021e 	bne	r2,zero,26eb4 <getPHYSpeed+0x90>
   26eac:	00800074 	movhi	r2,1
   26eb0:	00000106 	br	26eb8 <getPHYSpeed+0x94>
   26eb4:	0005883a 	mov	r2,zero
   26eb8:	1884b03a 	or	r2,r3,r2
   26ebc:	e0bff815 	stw	r2,-32(fp)
    
    alt_tse_phy_info *pphy = 0;
   26ec0:	e03ff915 	stw	zero,-28(fp)
    alt_tse_mac_info *pmac_info = 0;
   26ec4:	e03ffa15 	stw	zero,-24(fp)
    alt_tse_mac_group *pmac_group = 0;
   26ec8:	e03ffb15 	stw	zero,-20(fp)
    alt_tse_system_info *psys = 0;
   26ecc:	e03ffc15 	stw	zero,-16(fp)
    
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
   26ed0:	e03ffd05 	stb	zero,-12(fp)
    alt_8 mac_group_index = 0;
   26ed4:	e03ffd45 	stb	zero,-11(fp)
    
    /* initialized PHYs only once */
    static alt_u8 is_init = 0;
    if(is_init == 0) {
   26ed8:	d0a8f783 	ldbu	r2,-23586(gp)
   26edc:	10803fcc 	andi	r2,r2,255
   26ee0:	1000031e 	bne	r2,zero,26ef0 <getPHYSpeed+0xcc>
        alt_tse_phy_init();
   26ee4:	0028df80 	call	28df8 <alt_tse_phy_init>
        is_init = 1;
   26ee8:	00800044 	movi	r2,1
   26eec:	d0a8f785 	stb	r2,-23586(gp)
    }
    
    /* Look for pmac_group and pmac_info structure based on pmac or iface */
    pmac_info = alt_tse_get_mac_info(pmac);
   26ef0:	e13fff17 	ldw	r4,-4(fp)
   26ef4:	0026be00 	call	26be0 <alt_tse_get_mac_info>
   26ef8:	e0bffa15 	stw	r2,-24(fp)
    
    if(pmac_info == 0) {
   26efc:	e0bffa17 	ldw	r2,-24(fp)
   26f00:	1000491e 	bne	r2,zero,27028 <getPHYSpeed+0x204>
        speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
   26f04:	00800044 	movi	r2,1
   26f08:	e0bff705 	stb	r2,-36(fp)
        duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
   26f0c:	00800044 	movi	r2,1
   26f10:	e0bff745 	stb	r2,-35(fp)
        result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PMAC_FOUND;
   26f14:	e0bff743 	ldbu	r2,-35(fp)
   26f18:	10c0004c 	andi	r3,r2,1
   26f1c:	e0bff703 	ldbu	r2,-36(fp)
   26f20:	10800098 	cmpnei	r2,r2,2
   26f24:	1000021e 	bne	r2,zero,26f30 <getPHYSpeed+0x10c>
   26f28:	00800084 	movi	r2,2
   26f2c:	00000106 	br	26f34 <getPHYSpeed+0x110>
   26f30:	0005883a 	mov	r2,zero
   26f34:	1886b03a 	or	r3,r3,r2
   26f38:	e0bff703 	ldbu	r2,-36(fp)
   26f3c:	10800058 	cmpnei	r2,r2,1
   26f40:	1000021e 	bne	r2,zero,26f4c <getPHYSpeed+0x128>
   26f44:	00800104 	movi	r2,4
   26f48:	00000106 	br	26f50 <getPHYSpeed+0x12c>
   26f4c:	0005883a 	mov	r2,zero
   26f50:	1886b03a 	or	r3,r3,r2
   26f54:	e0bff703 	ldbu	r2,-36(fp)
   26f58:	1000021e 	bne	r2,zero,26f64 <getPHYSpeed+0x140>
   26f5c:	00800204 	movi	r2,8
   26f60:	00000106 	br	26f68 <getPHYSpeed+0x144>
   26f64:	0005883a 	mov	r2,zero
   26f68:	1886b03a 	or	r3,r3,r2
   26f6c:	e0bff703 	ldbu	r2,-36(fp)
   26f70:	108000d8 	cmpnei	r2,r2,3
   26f74:	1000021e 	bne	r2,zero,26f80 <getPHYSpeed+0x15c>
   26f78:	00800074 	movhi	r2,1
   26f7c:	00000106 	br	26f84 <getPHYSpeed+0x160>
   26f80:	0005883a 	mov	r2,zero
   26f84:	1884b03a 	or	r2,r3,r2
   26f88:	10802034 	orhi	r2,r2,128
   26f8c:	e0bff815 	stw	r2,-32(fp)
        tse_dprintf(2, "ERROR   : [getPHYSpeed] pmac not found from list of pmac_info[]! Speed = %s Mbps, Duplex = %s\n", speed == TSE_PHY_SPEED_1000 ? "1000" :
   26f90:	e0bff703 	ldbu	r2,-36(fp)
   26f94:	108000a0 	cmpeqi	r2,r2,2
   26f98:	10000f1e 	bne	r2,zero,26fd8 <getPHYSpeed+0x1b4>
   26f9c:	e0bff703 	ldbu	r2,-36(fp)
   26fa0:	10800060 	cmpeqi	r2,r2,1
   26fa4:	1000081e 	bne	r2,zero,26fc8 <getPHYSpeed+0x1a4>
   26fa8:	e0bff703 	ldbu	r2,-36(fp)
   26fac:	1000031e 	bne	r2,zero,26fbc <getPHYSpeed+0x198>
   26fb0:	008000f4 	movhi	r2,3
   26fb4:	1081cd04 	addi	r2,r2,1844
   26fb8:	00000206 	br	26fc4 <getPHYSpeed+0x1a0>
   26fbc:	008000f4 	movhi	r2,3
   26fc0:	1081ce04 	addi	r2,r2,1848
   26fc4:	00000206 	br	26fd0 <getPHYSpeed+0x1ac>
   26fc8:	008000f4 	movhi	r2,3
   26fcc:	1081d004 	addi	r2,r2,1856
   26fd0:	1007883a 	mov	r3,r2
   26fd4:	00000206 	br	26fe0 <getPHYSpeed+0x1bc>
   26fd8:	00c000f4 	movhi	r3,3
   26fdc:	18c1d104 	addi	r3,r3,1860
   26fe0:	e0bff743 	ldbu	r2,-35(fp)
   26fe4:	10800058 	cmpnei	r2,r2,1
   26fe8:	1000031e 	bne	r2,zero,26ff8 <getPHYSpeed+0x1d4>
   26fec:	008000f4 	movhi	r2,3
   26ff0:	1081d304 	addi	r2,r2,1868
   26ff4:	00000206 	br	27000 <getPHYSpeed+0x1dc>
   26ff8:	008000f4 	movhi	r2,3
   26ffc:	1081d504 	addi	r2,r2,1876
   27000:	010000f4 	movhi	r4,3
   27004:	2101d704 	addi	r4,r4,1884
   27008:	180b883a 	mov	r5,r3
   2700c:	100d883a 	mov	r6,r2
   27010:	00170680 	call	17068 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
        tse_dprintf(2, "ERROR   : [getPHYSpeed] Please define tse_mac_device[] correctly\n");
   27014:	010000f4 	movhi	r4,3
   27018:	2101ef04 	addi	r4,r4,1980
   2701c:	00172f80 	call	172f8 <puts>
        return result;
   27020:	e0bff817 	ldw	r2,-32(fp)
   27024:	00021706 	br	27884 <getPHYSpeed+0xa60>
    }
    
    pphy = pmac_info->pphy_info;
   27028:	e0bffa17 	ldw	r2,-24(fp)
   2702c:	10800117 	ldw	r2,4(r2)
   27030:	e0bff915 	stw	r2,-28(fp)
    pmac_group = pmac_info->pmac_group;
   27034:	e0bffa17 	ldw	r2,-24(fp)
   27038:	10800317 	ldw	r2,12(r2)
   2703c:	e0bffb15 	stw	r2,-20(fp)
    psys = pmac_info->psys_info;
   27040:	e0bffa17 	ldw	r2,-24(fp)
   27044:	10800217 	ldw	r2,8(r2)
   27048:	e0bffc15 	stw	r2,-16(fp)
    
    mac_info_index = alt_tse_get_mac_info_index(pmac_info);
   2704c:	e13ffa17 	ldw	r4,-24(fp)
   27050:	0026b600 	call	26b60 <alt_tse_get_mac_info_index>
   27054:	e0bffd05 	stb	r2,-12(fp)
    mac_group_index = alt_tse_get_mac_group_index(pmac_group);
   27058:	e13ffb17 	ldw	r4,-20(fp)
   2705c:	0026aec0 	call	26aec <alt_tse_get_mac_group_index>
   27060:	e0bffd45 	stb	r2,-11(fp)
         
    /* MDIO is not used */
    if (pmac_group->pmac_info[0]->psys_info->tse_use_mdio == 0)
   27064:	e0bffb17 	ldw	r2,-20(fp)
   27068:	10800117 	ldw	r2,4(r2)
   2706c:	10800217 	ldw	r2,8(r2)
   27070:	10800203 	ldbu	r2,8(r2)
   27074:	10803fcc 	andi	r2,r2,255
   27078:	10005a1e 	bne	r2,zero,271e4 <getPHYSpeed+0x3c0>
    {
        speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
   2707c:	00800044 	movi	r2,1
   27080:	e0bff705 	stb	r2,-36(fp)
        duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
   27084:	00800044 	movi	r2,1
   27088:	e0bff745 	stb	r2,-35(fp)
        result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_MDIO;
   2708c:	e0bff743 	ldbu	r2,-35(fp)
   27090:	10c0004c 	andi	r3,r2,1
   27094:	e0bff703 	ldbu	r2,-36(fp)
   27098:	10800098 	cmpnei	r2,r2,2
   2709c:	1000021e 	bne	r2,zero,270a8 <getPHYSpeed+0x284>
   270a0:	00800084 	movi	r2,2
   270a4:	00000106 	br	270ac <getPHYSpeed+0x288>
   270a8:	0005883a 	mov	r2,zero
   270ac:	1886b03a 	or	r3,r3,r2
   270b0:	e0bff703 	ldbu	r2,-36(fp)
   270b4:	10800058 	cmpnei	r2,r2,1
   270b8:	1000021e 	bne	r2,zero,270c4 <getPHYSpeed+0x2a0>
   270bc:	00800104 	movi	r2,4
   270c0:	00000106 	br	270c8 <getPHYSpeed+0x2a4>
   270c4:	0005883a 	mov	r2,zero
   270c8:	1886b03a 	or	r3,r3,r2
   270cc:	e0bff703 	ldbu	r2,-36(fp)
   270d0:	1000021e 	bne	r2,zero,270dc <getPHYSpeed+0x2b8>
   270d4:	00800204 	movi	r2,8
   270d8:	00000106 	br	270e0 <getPHYSpeed+0x2bc>
   270dc:	0005883a 	mov	r2,zero
   270e0:	1886b03a 	or	r3,r3,r2
   270e4:	e0bff703 	ldbu	r2,-36(fp)
   270e8:	108000d8 	cmpnei	r2,r2,3
   270ec:	1000021e 	bne	r2,zero,270f8 <getPHYSpeed+0x2d4>
   270f0:	00800074 	movhi	r2,1
   270f4:	00000106 	br	270fc <getPHYSpeed+0x2d8>
   270f8:	0005883a 	mov	r2,zero
   270fc:	1884b03a 	or	r2,r3,r2
   27100:	10801034 	orhi	r2,r2,64
   27104:	e0bff815 	stw	r2,-32(fp)
        usleep(ALTERA_NOMDIO_TIMEOUT_THRESHOLD);
   27108:	010003f4 	movhi	r4,15
   2710c:	21109004 	addi	r4,r4,16960
   27110:	00211c40 	call	211c4 <usleep>
        if(psys->tse_phy_cfg) {
   27114:	e0bffc17 	ldw	r2,-16(fp)
   27118:	10801117 	ldw	r2,68(r2)
   2711c:	10000d26 	beq	r2,zero,27154 <getPHYSpeed+0x330>
        	tse_dprintf(4, "WARNING : PHY[%d.%d] - MDIO not enabled! Running user configuration...\n", mac_group_index, mac_info_index);
   27120:	e0fffd47 	ldb	r3,-11(fp)
   27124:	e0bffd07 	ldb	r2,-12(fp)
   27128:	010000f4 	movhi	r4,3
   2712c:	21020004 	addi	r4,r4,2048
   27130:	180b883a 	mov	r5,r3
   27134:	100d883a 	mov	r6,r2
   27138:	00170680 	call	17068 <printf>
        	result = psys->tse_phy_cfg(pmac);
   2713c:	e0bffc17 	ldw	r2,-16(fp)
   27140:	10801117 	ldw	r2,68(r2)
   27144:	e13fff17 	ldw	r4,-4(fp)
   27148:	103ee83a 	callr	r2
   2714c:	e0bff815 	stw	r2,-32(fp)
   27150:	00002206 	br	271dc <getPHYSpeed+0x3b8>
        }
        else {
        	tse_dprintf(4, "WARNING : MAC Group[%d] - MDIO not enabled! Speed = %s, Duplex = %s\n", mac_group_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
   27154:	e17ffd47 	ldb	r5,-11(fp)
   27158:	e0bff703 	ldbu	r2,-36(fp)
   2715c:	108000a0 	cmpeqi	r2,r2,2
   27160:	10000f1e 	bne	r2,zero,271a0 <getPHYSpeed+0x37c>
   27164:	e0bff703 	ldbu	r2,-36(fp)
   27168:	10800060 	cmpeqi	r2,r2,1
   2716c:	1000081e 	bne	r2,zero,27190 <getPHYSpeed+0x36c>
   27170:	e0bff703 	ldbu	r2,-36(fp)
   27174:	1000031e 	bne	r2,zero,27184 <getPHYSpeed+0x360>
   27178:	008000f4 	movhi	r2,3
   2717c:	1081cd04 	addi	r2,r2,1844
   27180:	00000206 	br	2718c <getPHYSpeed+0x368>
   27184:	008000f4 	movhi	r2,3
   27188:	1081ce04 	addi	r2,r2,1848
   2718c:	00000206 	br	27198 <getPHYSpeed+0x374>
   27190:	008000f4 	movhi	r2,3
   27194:	1081d004 	addi	r2,r2,1856
   27198:	1007883a 	mov	r3,r2
   2719c:	00000206 	br	271a8 <getPHYSpeed+0x384>
   271a0:	00c000f4 	movhi	r3,3
   271a4:	18c1d104 	addi	r3,r3,1860
   271a8:	e0bff743 	ldbu	r2,-35(fp)
   271ac:	10800058 	cmpnei	r2,r2,1
   271b0:	1000031e 	bne	r2,zero,271c0 <getPHYSpeed+0x39c>
   271b4:	008000f4 	movhi	r2,3
   271b8:	1081d304 	addi	r2,r2,1868
   271bc:	00000206 	br	271c8 <getPHYSpeed+0x3a4>
   271c0:	008000f4 	movhi	r2,3
   271c4:	1081d504 	addi	r2,r2,1876
   271c8:	010000f4 	movhi	r4,3
   271cc:	21021204 	addi	r4,r4,2120
   271d0:	180d883a 	mov	r6,r3
   271d4:	100f883a 	mov	r7,r2
   271d8:	00170680 	call	17068 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
        }
        return result;
   271dc:	e0bff817 	ldw	r2,-32(fp)
   271e0:	0001a806 	br	27884 <getPHYSpeed+0xa60>

    /* Not running simulation */
    #ifndef ALT_SIM_OPTIMIZE
	
		/* These variables declaration are here to avoid "warning: unused variable" message when compile for simulation */
		np_tse_mac *pmac_group_base = (np_tse_mac *) pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   271e4:	e0bffb17 	ldw	r2,-20(fp)
   271e8:	10800117 	ldw	r2,4(r2)
   271ec:	10800217 	ldw	r2,8(r2)
   271f0:	10800017 	ldw	r2,0(r2)
   271f4:	e0bffe15 	stw	r2,-8(fp)
    
        /* if no PHY connected to the MAC */
        if(pphy == 0) {
   271f8:	e0bff917 	ldw	r2,-28(fp)
   271fc:	1000471e 	bne	r2,zero,2731c <getPHYSpeed+0x4f8>
            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
   27200:	00800044 	movi	r2,1
   27204:	e0bff705 	stb	r2,-36(fp)
            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
   27208:	00800044 	movi	r2,1
   2720c:	e0bff745 	stb	r2,-35(fp)
            result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PHY;
   27210:	e0bff743 	ldbu	r2,-35(fp)
   27214:	10c0004c 	andi	r3,r2,1
   27218:	e0bff703 	ldbu	r2,-36(fp)
   2721c:	10800098 	cmpnei	r2,r2,2
   27220:	1000021e 	bne	r2,zero,2722c <getPHYSpeed+0x408>
   27224:	00800084 	movi	r2,2
   27228:	00000106 	br	27230 <getPHYSpeed+0x40c>
   2722c:	0005883a 	mov	r2,zero
   27230:	1886b03a 	or	r3,r3,r2
   27234:	e0bff703 	ldbu	r2,-36(fp)
   27238:	10800058 	cmpnei	r2,r2,1
   2723c:	1000021e 	bne	r2,zero,27248 <getPHYSpeed+0x424>
   27240:	00800104 	movi	r2,4
   27244:	00000106 	br	2724c <getPHYSpeed+0x428>
   27248:	0005883a 	mov	r2,zero
   2724c:	1886b03a 	or	r3,r3,r2
   27250:	e0bff703 	ldbu	r2,-36(fp)
   27254:	1000021e 	bne	r2,zero,27260 <getPHYSpeed+0x43c>
   27258:	00800204 	movi	r2,8
   2725c:	00000106 	br	27264 <getPHYSpeed+0x440>
   27260:	0005883a 	mov	r2,zero
   27264:	1886b03a 	or	r3,r3,r2
   27268:	e0bff703 	ldbu	r2,-36(fp)
   2726c:	108000d8 	cmpnei	r2,r2,3
   27270:	1000021e 	bne	r2,zero,2727c <getPHYSpeed+0x458>
   27274:	00800074 	movhi	r2,1
   27278:	00000106 	br	27280 <getPHYSpeed+0x45c>
   2727c:	0005883a 	mov	r2,zero
   27280:	1884b03a 	or	r2,r3,r2
   27284:	10800834 	orhi	r2,r2,32
   27288:	e0bff815 	stw	r2,-32(fp)
            tse_dprintf(2, "ERROR   : PHY[%d.%d] - No PHY connected! Speed = %s, Duplex = %s\n", mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
   2728c:	e17ffd47 	ldb	r5,-11(fp)
   27290:	e1bffd07 	ldb	r6,-12(fp)
   27294:	e0bff703 	ldbu	r2,-36(fp)
   27298:	108000a0 	cmpeqi	r2,r2,2
   2729c:	10000e1e 	bne	r2,zero,272d8 <getPHYSpeed+0x4b4>
   272a0:	e0bff703 	ldbu	r2,-36(fp)
   272a4:	10800060 	cmpeqi	r2,r2,1
   272a8:	1000081e 	bne	r2,zero,272cc <getPHYSpeed+0x4a8>
   272ac:	e0bff703 	ldbu	r2,-36(fp)
   272b0:	1000031e 	bne	r2,zero,272c0 <getPHYSpeed+0x49c>
   272b4:	008000f4 	movhi	r2,3
   272b8:	1081cd04 	addi	r2,r2,1844
   272bc:	00000206 	br	272c8 <getPHYSpeed+0x4a4>
   272c0:	008000f4 	movhi	r2,3
   272c4:	1081ce04 	addi	r2,r2,1848
   272c8:	00000206 	br	272d4 <getPHYSpeed+0x4b0>
   272cc:	008000f4 	movhi	r2,3
   272d0:	1081d004 	addi	r2,r2,1856
   272d4:	00000206 	br	272e0 <getPHYSpeed+0x4bc>
   272d8:	008000f4 	movhi	r2,3
   272dc:	1081d104 	addi	r2,r2,1860
   272e0:	e0fff743 	ldbu	r3,-35(fp)
   272e4:	18c00058 	cmpnei	r3,r3,1
   272e8:	1800031e 	bne	r3,zero,272f8 <getPHYSpeed+0x4d4>
   272ec:	00c000f4 	movhi	r3,3
   272f0:	18c1d304 	addi	r3,r3,1868
   272f4:	00000206 	br	27300 <getPHYSpeed+0x4dc>
   272f8:	00c000f4 	movhi	r3,3
   272fc:	18c1d504 	addi	r3,r3,1876
   27300:	d8c00015 	stw	r3,0(sp)
   27304:	010000f4 	movhi	r4,3
   27308:	21022404 	addi	r4,r4,2192
   2730c:	100f883a 	mov	r7,r2
   27310:	00170680 	call	17068 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
            return result;
   27314:	e0bff817 	ldw	r2,-32(fp)
   27318:	00015a06 	br	27884 <getPHYSpeed+0xa60>
        }

		/* Small MAC */
		if(pmac_info->mac_type == ALTERA_TSE_MACLITE_10_100) {
   2731c:	e0bffa17 	ldw	r2,-24(fp)
   27320:	10800003 	ldbu	r2,0(r2)
   27324:	10803fcc 	andi	r2,r2,255
   27328:	10800058 	cmpnei	r2,r2,1
   2732c:	1000081e 	bne	r2,zero,27350 <getPHYSpeed+0x52c>
			alt_tse_phy_set_adv_1000(pphy, 0);
   27330:	e13ff917 	ldw	r4,-28(fp)
   27334:	000b883a 	mov	r5,zero
   27338:	00297cc0 	call	297cc <alt_tse_phy_set_adv_1000>
			alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
   2733c:	e13ff917 	ldw	r4,-28(fp)
   27340:	01400134 	movhi	r5,4
   27344:	29742404 	addi	r5,r5,-12144
   27348:	0028f100 	call	28f10 <alt_tse_phy_restart_an>
   2734c:	00000f06 	br	2738c <getPHYSpeed+0x568>
		}
		else if(pmac_info->mac_type == ALTERA_TSE_MACLITE_1000) {
   27350:	e0bffa17 	ldw	r2,-24(fp)
   27354:	10800003 	ldbu	r2,0(r2)
   27358:	10803fcc 	andi	r2,r2,255
   2735c:	10800098 	cmpnei	r2,r2,2
   27360:	10000a1e 	bne	r2,zero,2738c <getPHYSpeed+0x568>
			alt_tse_phy_set_adv_100(pphy, 0);
   27364:	e13ff917 	ldw	r4,-28(fp)
   27368:	000b883a 	mov	r5,zero
   2736c:	00299880 	call	29988 <alt_tse_phy_set_adv_100>
			alt_tse_phy_set_adv_10(pphy, 0);
   27370:	e13ff917 	ldw	r4,-28(fp)
   27374:	000b883a 	mov	r5,zero
   27378:	0029bd00 	call	29bd0 <alt_tse_phy_set_adv_10>
			alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
   2737c:	e13ff917 	ldw	r4,-28(fp)
   27380:	01400134 	movhi	r5,4
   27384:	29742404 	addi	r5,r5,-12144
   27388:	0028f100 	call	28f10 <alt_tse_phy_restart_an>
		}
		
		/* check link connection for this PHY */
		if(alt_tse_phy_check_link(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD) == TSE_PHY_AN_NOT_COMPLETE) {
   2738c:	e13ff917 	ldw	r4,-28(fp)
   27390:	01400134 	movhi	r5,4
   27394:	29742404 	addi	r5,r5,-12144
   27398:	00290d40 	call	290d4 <alt_tse_phy_check_link>
   2739c:	10bfffd8 	cmpnei	r2,r2,-1
   273a0:	1000471e 	bne	r2,zero,274c0 <getPHYSpeed+0x69c>
			speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
   273a4:	00800044 	movi	r2,1
   273a8:	e0bff705 	stb	r2,-36(fp)
			duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
   273ac:	00800044 	movi	r2,1
   273b0:	e0bff745 	stb	r2,-35(fp)
			result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_AN_NOT_COMPLETE;
   273b4:	e0bff743 	ldbu	r2,-35(fp)
   273b8:	10c0004c 	andi	r3,r2,1
   273bc:	e0bff703 	ldbu	r2,-36(fp)
   273c0:	10800098 	cmpnei	r2,r2,2
   273c4:	1000021e 	bne	r2,zero,273d0 <getPHYSpeed+0x5ac>
   273c8:	00800084 	movi	r2,2
   273cc:	00000106 	br	273d4 <getPHYSpeed+0x5b0>
   273d0:	0005883a 	mov	r2,zero
   273d4:	1886b03a 	or	r3,r3,r2
   273d8:	e0bff703 	ldbu	r2,-36(fp)
   273dc:	10800058 	cmpnei	r2,r2,1
   273e0:	1000021e 	bne	r2,zero,273ec <getPHYSpeed+0x5c8>
   273e4:	00800104 	movi	r2,4
   273e8:	00000106 	br	273f0 <getPHYSpeed+0x5cc>
   273ec:	0005883a 	mov	r2,zero
   273f0:	1886b03a 	or	r3,r3,r2
   273f4:	e0bff703 	ldbu	r2,-36(fp)
   273f8:	1000021e 	bne	r2,zero,27404 <getPHYSpeed+0x5e0>
   273fc:	00800204 	movi	r2,8
   27400:	00000106 	br	27408 <getPHYSpeed+0x5e4>
   27404:	0005883a 	mov	r2,zero
   27408:	1886b03a 	or	r3,r3,r2
   2740c:	e0bff703 	ldbu	r2,-36(fp)
   27410:	108000d8 	cmpnei	r2,r2,3
   27414:	1000021e 	bne	r2,zero,27420 <getPHYSpeed+0x5fc>
   27418:	00800074 	movhi	r2,1
   2741c:	00000106 	br	27424 <getPHYSpeed+0x600>
   27420:	0005883a 	mov	r2,zero
   27424:	1884b03a 	or	r2,r3,r2
   27428:	10800234 	orhi	r2,r2,8
   2742c:	e0bff815 	stw	r2,-32(fp)
			tse_dprintf(3, "WARNING : PHY[%d.%d] - Auto-Negotiation not completed! Speed = %s, Duplex = %s\n", mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
   27430:	e17ffd47 	ldb	r5,-11(fp)
   27434:	e1bffd07 	ldb	r6,-12(fp)
   27438:	e0bff703 	ldbu	r2,-36(fp)
   2743c:	108000a0 	cmpeqi	r2,r2,2
   27440:	10000e1e 	bne	r2,zero,2747c <getPHYSpeed+0x658>
   27444:	e0bff703 	ldbu	r2,-36(fp)
   27448:	10800060 	cmpeqi	r2,r2,1
   2744c:	1000081e 	bne	r2,zero,27470 <getPHYSpeed+0x64c>
   27450:	e0bff703 	ldbu	r2,-36(fp)
   27454:	1000031e 	bne	r2,zero,27464 <getPHYSpeed+0x640>
   27458:	008000f4 	movhi	r2,3
   2745c:	1081cd04 	addi	r2,r2,1844
   27460:	00000206 	br	2746c <getPHYSpeed+0x648>
   27464:	008000f4 	movhi	r2,3
   27468:	1081ce04 	addi	r2,r2,1848
   2746c:	00000206 	br	27478 <getPHYSpeed+0x654>
   27470:	008000f4 	movhi	r2,3
   27474:	1081d004 	addi	r2,r2,1856
   27478:	00000206 	br	27484 <getPHYSpeed+0x660>
   2747c:	008000f4 	movhi	r2,3
   27480:	1081d104 	addi	r2,r2,1860
   27484:	e0fff743 	ldbu	r3,-35(fp)
   27488:	18c00058 	cmpnei	r3,r3,1
   2748c:	1800031e 	bne	r3,zero,2749c <getPHYSpeed+0x678>
   27490:	00c000f4 	movhi	r3,3
   27494:	18c1d304 	addi	r3,r3,1868
   27498:	00000206 	br	274a4 <getPHYSpeed+0x680>
   2749c:	00c000f4 	movhi	r3,3
   274a0:	18c1d504 	addi	r3,r3,1876
   274a4:	d8c00015 	stw	r3,0(sp)
   274a8:	010000f4 	movhi	r4,3
   274ac:	21023504 	addi	r4,r4,2260
   274b0:	100f883a 	mov	r7,r2
   274b4:	00170680 	call	17068 <printf>
																			 speed == TSE_PHY_SPEED_100 ? "100" :
																			 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
																			 duplex == 1 ? "Full" : "Half");
			return result;
   274b8:	e0bff817 	ldw	r2,-32(fp)
   274bc:	0000f106 	br	27884 <getPHYSpeed+0xa60>
		}

        IOWR(&pmac_group_base->MDIO_ADDR1, 0, pphy->mdio_address);
   274c0:	e0bffe17 	ldw	r2,-8(fp)
   274c4:	10801004 	addi	r2,r2,64
   274c8:	e0fff917 	ldw	r3,-28(fp)
   274cc:	18c00003 	ldbu	r3,0(r3)
   274d0:	18c03fcc 	andi	r3,r3,255
   274d4:	10c00035 	stwio	r3,0(r2)
        /* To enable PHY loopback */
        #if ENABLE_PHY_LOOPBACK
            tse_dprintf(5, "INFO    : PHY[%d.%d] - Putting PHY in loopback\n", mac_group_index, mac_info_index);
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 1);   // enable PHY loopback
		#else
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 0);   // disable PHY loopback
   274d8:	d8000015 	stw	zero,0(sp)
   274dc:	e13ff917 	ldw	r4,-28(fp)
   274e0:	000b883a 	mov	r5,zero
   274e4:	01800384 	movi	r6,14
   274e8:	01c00044 	movi	r7,1
   274ec:	00279380 	call	27938 <alt_tse_phy_wr_mdio_reg>
        #endif
       
        /* if PHY not found in profile */
        if(pphy->pphy_profile == 0) {
   274f0:	e0bff917 	ldw	r2,-28(fp)
   274f4:	10800517 	ldw	r2,20(r2)
   274f8:	10002b1e 	bne	r2,zero,275a8 <getPHYSpeed+0x784>
            tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not found in PHY profile\n", mac_group_index, mac_info_index);
   274fc:	e0fffd47 	ldb	r3,-11(fp)
   27500:	e0bffd07 	ldb	r2,-12(fp)
   27504:	010000f4 	movhi	r4,3
   27508:	21024904 	addi	r4,r4,2340
   2750c:	180b883a 	mov	r5,r3
   27510:	100d883a 	mov	r6,r2
   27514:	00170680 	call	17068 <printf>
            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
   27518:	00800044 	movi	r2,1
   2751c:	e0bff705 	stb	r2,-36(fp)
            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
   27520:	00800044 	movi	r2,1
   27524:	e0bff745 	stb	r2,-35(fp)
			result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PHY_PROFILE;
   27528:	e0bff743 	ldbu	r2,-35(fp)
   2752c:	10c0004c 	andi	r3,r2,1
   27530:	e0bff703 	ldbu	r2,-36(fp)
   27534:	10800098 	cmpnei	r2,r2,2
   27538:	1000021e 	bne	r2,zero,27544 <getPHYSpeed+0x720>
   2753c:	00800084 	movi	r2,2
   27540:	00000106 	br	27548 <getPHYSpeed+0x724>
   27544:	0005883a 	mov	r2,zero
   27548:	1886b03a 	or	r3,r3,r2
   2754c:	e0bff703 	ldbu	r2,-36(fp)
   27550:	10800058 	cmpnei	r2,r2,1
   27554:	1000021e 	bne	r2,zero,27560 <getPHYSpeed+0x73c>
   27558:	00800104 	movi	r2,4
   2755c:	00000106 	br	27564 <getPHYSpeed+0x740>
   27560:	0005883a 	mov	r2,zero
   27564:	1886b03a 	or	r3,r3,r2
   27568:	e0bff703 	ldbu	r2,-36(fp)
   2756c:	1000021e 	bne	r2,zero,27578 <getPHYSpeed+0x754>
   27570:	00800204 	movi	r2,8
   27574:	00000106 	br	2757c <getPHYSpeed+0x758>
   27578:	0005883a 	mov	r2,zero
   2757c:	1886b03a 	or	r3,r3,r2
   27580:	e0bff703 	ldbu	r2,-36(fp)
   27584:	108000d8 	cmpnei	r2,r2,3
   27588:	1000021e 	bne	r2,zero,27594 <getPHYSpeed+0x770>
   2758c:	00800074 	movhi	r2,1
   27590:	00000106 	br	27598 <getPHYSpeed+0x774>
   27594:	0005883a 	mov	r2,zero
   27598:	1884b03a 	or	r2,r3,r2
   2759c:	10800134 	orhi	r2,r2,4
   275a0:	e0bff815 	stw	r2,-32(fp)
   275a4:	00009406 	br	277f8 <getPHYSpeed+0x9d4>
        }
        // retrieve duplex information from PHY
		else
		{
			if(pphy->pphy_profile->link_status_read)
   275a8:	e0bff917 	ldw	r2,-28(fp)
   275ac:	10800517 	ldw	r2,20(r2)
   275b0:	10801817 	ldw	r2,96(r2)
   275b4:	10002626 	beq	r2,zero,27650 <getPHYSpeed+0x82c>
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
   275b8:	e0bff917 	ldw	r2,-28(fp)
   275bc:	10800517 	ldw	r2,20(r2)
   275c0:	10801817 	ldw	r2,96(r2)
   275c4:	e13ffe17 	ldw	r4,-8(fp)
   275c8:	103ee83a 	callr	r2
   275cc:	e0bff815 	stw	r2,-32(fp)
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
   275d0:	e0bff817 	ldw	r2,-32(fp)
   275d4:	1080008c 	andi	r2,r2,2
   275d8:	10000c1e 	bne	r2,zero,2760c <getPHYSpeed+0x7e8>
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
   275dc:	e0bff817 	ldw	r2,-32(fp)
   275e0:	1080010c 	andi	r2,r2,4
		else
		{
			if(pphy->pphy_profile->link_status_read)
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
   275e4:	1000071e 	bne	r2,zero,27604 <getPHYSpeed+0x7e0>
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
						(result & 0x08) ? TSE_PHY_SPEED_10  : TSE_PHY_SPEED_INVALID;
   275e8:	e0bff817 	ldw	r2,-32(fp)
   275ec:	1080020c 	andi	r2,r2,8
		else
		{
			if(pphy->pphy_profile->link_status_read)
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
   275f0:	10000226 	beq	r2,zero,275fc <getPHYSpeed+0x7d8>
   275f4:	0005883a 	mov	r2,zero
   275f8:	00000106 	br	27600 <getPHYSpeed+0x7dc>
   275fc:	008000c4 	movi	r2,3
   27600:	00000106 	br	27608 <getPHYSpeed+0x7e4>
   27604:	00800044 	movi	r2,1
   27608:	00000106 	br	27610 <getPHYSpeed+0x7ec>
   2760c:	00800084 	movi	r2,2
   27610:	e0bff705 	stb	r2,-36(fp)
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
						(result & 0x08) ? TSE_PHY_SPEED_10  : TSE_PHY_SPEED_INVALID;
				duplex = (result & 0x01) ? TSE_PHY_DUPLEX_FULL : TSE_PHY_DUPLEX_HALF;
   27614:	e0bff817 	ldw	r2,-32(fp)
   27618:	1080004c 	andi	r2,r2,1
   2761c:	1004c03a 	cmpne	r2,r2,zero
   27620:	e0bff745 	stb	r2,-35(fp)
				
				if(result & ALT_TSE_E_INVALID_SPEED)
   27624:	e0bff817 	ldw	r2,-32(fp)
   27628:	1080006c 	andhi	r2,r2,1
   2762c:	10007226 	beq	r2,zero,277f8 <getPHYSpeed+0x9d4>
				{
					tse_dprintf(3, "WARNING : PHY[%d.%d] - Invalid speed read from PHY\n", mac_group_index, mac_info_index);
   27630:	e0fffd47 	ldb	r3,-11(fp)
   27634:	e0bffd07 	ldb	r2,-12(fp)
   27638:	010000f4 	movhi	r4,3
   2763c:	21025704 	addi	r4,r4,2396
   27640:	180b883a 	mov	r5,r3
   27644:	100d883a 	mov	r6,r2
   27648:	00170680 	call	17068 <printf>
   2764c:	00006a06 	br	277f8 <getPHYSpeed+0x9d4>
				}
			}
			else if(pphy->pphy_profile->status_reg_location == 0)
   27650:	e0bff917 	ldw	r2,-28(fp)
   27654:	10800517 	ldw	r2,20(r2)
   27658:	10801583 	ldbu	r2,86(r2)
   2765c:	10803fcc 	andi	r2,r2,255
   27660:	10002b1e 	bne	r2,zero,27710 <getPHYSpeed+0x8ec>
	        {
	            tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY Specific Status register information not provided in profile\n", mac_group_index, mac_info_index);
   27664:	e0fffd47 	ldb	r3,-11(fp)
   27668:	e0bffd07 	ldb	r2,-12(fp)
   2766c:	010000f4 	movhi	r4,3
   27670:	21026404 	addi	r4,r4,2448
   27674:	180b883a 	mov	r5,r3
   27678:	100d883a 	mov	r6,r2
   2767c:	00170680 	call	17068 <printf>
	            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
   27680:	00800044 	movi	r2,1
   27684:	e0bff705 	stb	r2,-36(fp)
	            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
   27688:	00800044 	movi	r2,1
   2768c:	e0bff745 	stb	r2,-35(fp)
				result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_PROFILE_INCORRECT_DEFINED;
   27690:	e0bff743 	ldbu	r2,-35(fp)
   27694:	10c0004c 	andi	r3,r2,1
   27698:	e0bff703 	ldbu	r2,-36(fp)
   2769c:	10800098 	cmpnei	r2,r2,2
   276a0:	1000021e 	bne	r2,zero,276ac <getPHYSpeed+0x888>
   276a4:	00800084 	movi	r2,2
   276a8:	00000106 	br	276b0 <getPHYSpeed+0x88c>
   276ac:	0005883a 	mov	r2,zero
   276b0:	1886b03a 	or	r3,r3,r2
   276b4:	e0bff703 	ldbu	r2,-36(fp)
   276b8:	10800058 	cmpnei	r2,r2,1
   276bc:	1000021e 	bne	r2,zero,276c8 <getPHYSpeed+0x8a4>
   276c0:	00800104 	movi	r2,4
   276c4:	00000106 	br	276cc <getPHYSpeed+0x8a8>
   276c8:	0005883a 	mov	r2,zero
   276cc:	1886b03a 	or	r3,r3,r2
   276d0:	e0bff703 	ldbu	r2,-36(fp)
   276d4:	1000021e 	bne	r2,zero,276e0 <getPHYSpeed+0x8bc>
   276d8:	00800204 	movi	r2,8
   276dc:	00000106 	br	276e4 <getPHYSpeed+0x8c0>
   276e0:	0005883a 	mov	r2,zero
   276e4:	1886b03a 	or	r3,r3,r2
   276e8:	e0bff703 	ldbu	r2,-36(fp)
   276ec:	108000d8 	cmpnei	r2,r2,3
   276f0:	1000021e 	bne	r2,zero,276fc <getPHYSpeed+0x8d8>
   276f4:	00800074 	movhi	r2,1
   276f8:	00000106 	br	27700 <getPHYSpeed+0x8dc>
   276fc:	0005883a 	mov	r2,zero
   27700:	1884b03a 	or	r2,r3,r2
   27704:	108000b4 	orhi	r2,r2,2
   27708:	e0bff815 	stw	r2,-32(fp)
   2770c:	00003a06 	br	277f8 <getPHYSpeed+0x9d4>
	        }
	        else
	        {
	            /* extract connection speed and duplex information */
	        	speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 2);
   27710:	e0bff917 	ldw	r2,-28(fp)
   27714:	10800517 	ldw	r2,20(r2)
   27718:	10801583 	ldbu	r2,86(r2)
   2771c:	10c03fcc 	andi	r3,r2,255
   27720:	e0bff917 	ldw	r2,-28(fp)
   27724:	10800517 	ldw	r2,20(r2)
   27728:	108015c3 	ldbu	r2,87(r2)
   2772c:	10803fcc 	andi	r2,r2,255
   27730:	e13ff917 	ldw	r4,-28(fp)
   27734:	180b883a 	mov	r5,r3
   27738:	100d883a 	mov	r6,r2
   2773c:	01c00084 	movi	r7,2
   27740:	0027a640 	call	27a64 <alt_tse_phy_rd_mdio_reg>
   27744:	e0bff705 	stb	r2,-36(fp)
	            duplex = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->duplex_bit_location, 1);
   27748:	e0bff917 	ldw	r2,-28(fp)
   2774c:	10800517 	ldw	r2,20(r2)
   27750:	10801583 	ldbu	r2,86(r2)
   27754:	10c03fcc 	andi	r3,r2,255
   27758:	e0bff917 	ldw	r2,-28(fp)
   2775c:	10800517 	ldw	r2,20(r2)
   27760:	10801603 	ldbu	r2,88(r2)
   27764:	10803fcc 	andi	r2,r2,255
   27768:	e13ff917 	ldw	r4,-28(fp)
   2776c:	180b883a 	mov	r5,r3
   27770:	100d883a 	mov	r6,r2
   27774:	01c00044 	movi	r7,1
   27778:	0027a640 	call	27a64 <alt_tse_phy_rd_mdio_reg>
   2777c:	e0bff745 	stb	r2,-35(fp)
				
				result = ALT_TSE_SPEED_DUPLEX(speed, duplex);
   27780:	e0bff743 	ldbu	r2,-35(fp)
   27784:	10c0004c 	andi	r3,r2,1
   27788:	e0bff703 	ldbu	r2,-36(fp)
   2778c:	10800098 	cmpnei	r2,r2,2
   27790:	1000021e 	bne	r2,zero,2779c <getPHYSpeed+0x978>
   27794:	00800084 	movi	r2,2
   27798:	00000106 	br	277a0 <getPHYSpeed+0x97c>
   2779c:	0005883a 	mov	r2,zero
   277a0:	1886b03a 	or	r3,r3,r2
   277a4:	e0bff703 	ldbu	r2,-36(fp)
   277a8:	10800058 	cmpnei	r2,r2,1
   277ac:	1000021e 	bne	r2,zero,277b8 <getPHYSpeed+0x994>
   277b0:	00800104 	movi	r2,4
   277b4:	00000106 	br	277bc <getPHYSpeed+0x998>
   277b8:	0005883a 	mov	r2,zero
   277bc:	1886b03a 	or	r3,r3,r2
   277c0:	e0bff703 	ldbu	r2,-36(fp)
   277c4:	1000021e 	bne	r2,zero,277d0 <getPHYSpeed+0x9ac>
   277c8:	00800204 	movi	r2,8
   277cc:	00000106 	br	277d4 <getPHYSpeed+0x9b0>
   277d0:	0005883a 	mov	r2,zero
   277d4:	1886b03a 	or	r3,r3,r2
   277d8:	e0bff703 	ldbu	r2,-36(fp)
   277dc:	108000d8 	cmpnei	r2,r2,3
   277e0:	1000021e 	bne	r2,zero,277ec <getPHYSpeed+0x9c8>
   277e4:	00800074 	movhi	r2,1
   277e8:	00000106 	br	277f0 <getPHYSpeed+0x9cc>
   277ec:	0005883a 	mov	r2,zero
   277f0:	1884b03a 	or	r2,r3,r2
   277f4:	e0bff815 	stw	r2,-32(fp)
        /* for simulation purpose, default to gigabit mode */
        speed = 1;
        duplex = 1;
    #endif

    tse_dprintf(5, "INFO    : PHY[%d.%d] - Speed = %s, Duplex = %s\n",  mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
   277f8:	e17ffd47 	ldb	r5,-11(fp)
   277fc:	e1bffd07 	ldb	r6,-12(fp)
   27800:	e0bff703 	ldbu	r2,-36(fp)
   27804:	108000a0 	cmpeqi	r2,r2,2
   27808:	10000e1e 	bne	r2,zero,27844 <getPHYSpeed+0xa20>
   2780c:	e0bff703 	ldbu	r2,-36(fp)
   27810:	10800060 	cmpeqi	r2,r2,1
   27814:	1000081e 	bne	r2,zero,27838 <getPHYSpeed+0xa14>
   27818:	e0bff703 	ldbu	r2,-36(fp)
   2781c:	1000031e 	bne	r2,zero,2782c <getPHYSpeed+0xa08>
   27820:	008000f4 	movhi	r2,3
   27824:	1081cd04 	addi	r2,r2,1844
   27828:	00000206 	br	27834 <getPHYSpeed+0xa10>
   2782c:	008000f4 	movhi	r2,3
   27830:	1081ce04 	addi	r2,r2,1848
   27834:	00000206 	br	27840 <getPHYSpeed+0xa1c>
   27838:	008000f4 	movhi	r2,3
   2783c:	1081d004 	addi	r2,r2,1856
   27840:	00000206 	br	2784c <getPHYSpeed+0xa28>
   27844:	008000f4 	movhi	r2,3
   27848:	1081d104 	addi	r2,r2,1860
   2784c:	e0fff743 	ldbu	r3,-35(fp)
   27850:	18c00058 	cmpnei	r3,r3,1
   27854:	1800031e 	bne	r3,zero,27864 <getPHYSpeed+0xa40>
   27858:	00c000f4 	movhi	r3,3
   2785c:	18c1d304 	addi	r3,r3,1868
   27860:	00000206 	br	2786c <getPHYSpeed+0xa48>
   27864:	00c000f4 	movhi	r3,3
   27868:	18c1d504 	addi	r3,r3,1876
   2786c:	d8c00015 	stw	r3,0(sp)
   27870:	010000f4 	movhi	r4,3
   27874:	21027b04 	addi	r4,r4,2540
   27878:	100f883a 	mov	r7,r2
   2787c:	00170680 	call	17068 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");

    return result;
   27880:	e0bff817 	ldw	r2,-32(fp)
}
   27884:	e037883a 	mov	sp,fp
   27888:	dfc00117 	ldw	ra,4(sp)
   2788c:	df000017 	ldw	fp,0(sp)
   27890:	dec00204 	addi	sp,sp,8
   27894:	f800283a 	ret

00027898 <alt_tse_phy_rd_mdio_addr>:
/* @Function Description: Read MDIO address from the MDIO address1 register of first MAC within MAC group
 * @API Type:    Internal
 * @param pmac   Pointer to the alt_tse_phy_info structure
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_rd_mdio_addr(alt_tse_phy_info *pphy) {
   27898:	defffd04 	addi	sp,sp,-12
   2789c:	df000215 	stw	fp,8(sp)
   278a0:	df000204 	addi	fp,sp,8
   278a4:	e13fff15 	stw	r4,-4(fp)
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   278a8:	e0bfff17 	ldw	r2,-4(fp)
   278ac:	10800617 	ldw	r2,24(r2)
   278b0:	10800317 	ldw	r2,12(r2)
   278b4:	10800117 	ldw	r2,4(r2)
   278b8:	10800217 	ldw	r2,8(r2)
   278bc:	10800017 	ldw	r2,0(r2)
   278c0:	e0bffe15 	stw	r2,-8(fp)
    return IORD(&pmac_group_base->MDIO_ADDR1, 0);
   278c4:	e0bffe17 	ldw	r2,-8(fp)
   278c8:	10801004 	addi	r2,r2,64
   278cc:	10800037 	ldwio	r2,0(r2)
}
   278d0:	e037883a 	mov	sp,fp
   278d4:	df000017 	ldw	fp,0(sp)
   278d8:	dec00104 	addi	sp,sp,4
   278dc:	f800283a 	ret

000278e0 <alt_tse_phy_wr_mdio_addr>:
 * @API Type:           Internal
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
   278e0:	defffc04 	addi	sp,sp,-16
   278e4:	df000315 	stw	fp,12(sp)
   278e8:	df000304 	addi	fp,sp,12
   278ec:	e13ffe15 	stw	r4,-8(fp)
   278f0:	2805883a 	mov	r2,r5
   278f4:	e0bfff05 	stb	r2,-4(fp)
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   278f8:	e0bffe17 	ldw	r2,-8(fp)
   278fc:	10800617 	ldw	r2,24(r2)
   27900:	10800317 	ldw	r2,12(r2)
   27904:	10800117 	ldw	r2,4(r2)
   27908:	10800217 	ldw	r2,8(r2)
   2790c:	10800017 	ldw	r2,0(r2)
   27910:	e0bffd15 	stw	r2,-12(fp)
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdio_address);
   27914:	e0bffd17 	ldw	r2,-12(fp)
   27918:	10801004 	addi	r2,r2,64
   2791c:	e0ffff03 	ldbu	r3,-4(fp)
   27920:	10c00035 	stwio	r3,0(r2)
    
    return SUCCESS;
   27924:	0005883a 	mov	r2,zero
}
   27928:	e037883a 	mov	sp,fp
   2792c:	df000017 	ldw	fp,0(sp)
   27930:	dec00104 	addi	sp,sp,4
   27934:	f800283a 	ret

00027938 <alt_tse_phy_wr_mdio_reg>:
  * @param  bit_length       number of bits to be written to the register.
  * @param  data             data to be written to the register at specific bit location of register.
  * @return SUCCESS 
  */
alt_32 alt_tse_phy_wr_mdio_reg(alt_tse_phy_info *pphy, alt_u8 reg_num, alt_u8 lsb_num, alt_u8 bit_length, alt_u16 data)
{
   27938:	defff604 	addi	sp,sp,-40
   2793c:	df000915 	stw	fp,36(sp)
   27940:	df000904 	addi	fp,sp,36
   27944:	e13ffb15 	stw	r4,-20(fp)
   27948:	2809883a 	mov	r4,r5
   2794c:	3007883a 	mov	r3,r6
   27950:	3805883a 	mov	r2,r7
   27954:	e1400117 	ldw	r5,4(fp)
   27958:	e13ffc05 	stb	r4,-16(fp)
   2795c:	e0fffd05 	stb	r3,-12(fp)
   27960:	e0bffe05 	stb	r2,-8(fp)
   27964:	e17fff0d 	sth	r5,-4(fp)
    
    alt_u16 temp_data;
    alt_u16 bit_mask;
    alt_32 i;
    np_tse_mac *pmac = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   27968:	e0bffb17 	ldw	r2,-20(fp)
   2796c:	10800617 	ldw	r2,24(r2)
   27970:	10800317 	ldw	r2,12(r2)
   27974:	10800117 	ldw	r2,4(r2)
   27978:	10800217 	ldw	r2,8(r2)
   2797c:	10800017 	ldw	r2,0(r2)
   27980:	e0bff915 	stw	r2,-28(fp)
    
    bit_mask = 0x00;
   27984:	e03ff70d 	sth	zero,-36(fp)
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
   27988:	e03ff815 	stw	zero,-32(fp)
   2798c:	00000906 	br	279b4 <alt_tse_phy_wr_mdio_reg+0x7c>
    {
        bit_mask <<= 1;
   27990:	e0bff70b 	ldhu	r2,-36(fp)
   27994:	1085883a 	add	r2,r2,r2
   27998:	e0bff70d 	sth	r2,-36(fp)
        bit_mask |= 0x01;        
   2799c:	e0bff70b 	ldhu	r2,-36(fp)
   279a0:	10800054 	ori	r2,r2,1
   279a4:	e0bff70d 	sth	r2,-36(fp)
    
    bit_mask = 0x00;
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
   279a8:	e0bff817 	ldw	r2,-32(fp)
   279ac:	10800044 	addi	r2,r2,1
   279b0:	e0bff815 	stw	r2,-32(fp)
   279b4:	e0bffe03 	ldbu	r2,-8(fp)
   279b8:	e0fff817 	ldw	r3,-32(fp)
   279bc:	18bff416 	blt	r3,r2,27990 <alt_tse_phy_wr_mdio_reg+0x58>
        bit_mask <<= 1;
        bit_mask |= 0x01;        
    }
    
    /* shifting mask to left by bit_num */
    bit_mask <<= lsb_num;
   279c0:	e0fff70b 	ldhu	r3,-36(fp)
   279c4:	e0bffd03 	ldbu	r2,-12(fp)
   279c8:	1884983a 	sll	r2,r3,r2
   279cc:	e0bff70d 	sth	r2,-36(fp)

    /* read register data */
    temp_data = IORD(&pmac->mdio1, reg_num);
   279d0:	e0bff917 	ldw	r2,-28(fp)
   279d4:	10c0a004 	addi	r3,r2,640
   279d8:	e0bffc03 	ldbu	r2,-16(fp)
   279dc:	1085883a 	add	r2,r2,r2
   279e0:	1085883a 	add	r2,r2,r2
   279e4:	1885883a 	add	r2,r3,r2
   279e8:	10800037 	ldwio	r2,0(r2)
   279ec:	e0bffa0d 	sth	r2,-24(fp)
    
    /* clear bits to be written */
    temp_data &= ~bit_mask;
   279f0:	e0bff70b 	ldhu	r2,-36(fp)
   279f4:	0084303a 	nor	r2,zero,r2
   279f8:	1007883a 	mov	r3,r2
   279fc:	e0bffa0b 	ldhu	r2,-24(fp)
   27a00:	1884703a 	and	r2,r3,r2
   27a04:	e0bffa0d 	sth	r2,-24(fp)
    
    /* OR-ed together corresponding bits data */
    temp_data |= ((data << lsb_num) & bit_mask);    
   27a08:	e0ffff0b 	ldhu	r3,-4(fp)
   27a0c:	e0bffd03 	ldbu	r2,-12(fp)
   27a10:	1884983a 	sll	r2,r3,r2
   27a14:	1007883a 	mov	r3,r2
   27a18:	e0bff70b 	ldhu	r2,-36(fp)
   27a1c:	1884703a 	and	r2,r3,r2
   27a20:	1007883a 	mov	r3,r2
   27a24:	e0bffa0b 	ldhu	r2,-24(fp)
   27a28:	1884b03a 	or	r2,r3,r2
   27a2c:	e0bffa0d 	sth	r2,-24(fp)
    
    /* write data to MDIO register */
    IOWR(&pmac->mdio1, reg_num, temp_data);
   27a30:	e0bff917 	ldw	r2,-28(fp)
   27a34:	10c0a004 	addi	r3,r2,640
   27a38:	e0bffc03 	ldbu	r2,-16(fp)
   27a3c:	1085883a 	add	r2,r2,r2
   27a40:	1085883a 	add	r2,r2,r2
   27a44:	1885883a 	add	r2,r3,r2
   27a48:	e0fffa0b 	ldhu	r3,-24(fp)
   27a4c:	10c00035 	stwio	r3,0(r2)
    
    return SUCCESS;
   27a50:	0005883a 	mov	r2,zero
    
}
   27a54:	e037883a 	mov	sp,fp
   27a58:	df000017 	ldw	fp,0(sp)
   27a5c:	dec00104 	addi	sp,sp,4
   27a60:	f800283a 	ret

00027a64 <alt_tse_phy_rd_mdio_reg>:
 * @param  bit_length       number of bits to be read from the register.
 * @return data read from MDIO register 
 */

alt_u32 alt_tse_phy_rd_mdio_reg(alt_tse_phy_info *pphy, alt_u8 reg_num, alt_u8 lsb_num, alt_u8 bit_length)
{
   27a64:	defff704 	addi	sp,sp,-36
   27a68:	df000815 	stw	fp,32(sp)
   27a6c:	df000804 	addi	fp,sp,32
   27a70:	e13ffc15 	stw	r4,-16(fp)
   27a74:	2809883a 	mov	r4,r5
   27a78:	3007883a 	mov	r3,r6
   27a7c:	3805883a 	mov	r2,r7
   27a80:	e13ffd05 	stb	r4,-12(fp)
   27a84:	e0fffe05 	stb	r3,-8(fp)
   27a88:	e0bfff05 	stb	r2,-4(fp)
    alt_u16 temp_data;
    alt_u32 bit_mask;
    alt_32 i;
    np_tse_mac *pmac = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   27a8c:	e0bffc17 	ldw	r2,-16(fp)
   27a90:	10800617 	ldw	r2,24(r2)
   27a94:	10800317 	ldw	r2,12(r2)
   27a98:	10800117 	ldw	r2,4(r2)
   27a9c:	10800217 	ldw	r2,8(r2)
   27aa0:	10800017 	ldw	r2,0(r2)
   27aa4:	e0bffa15 	stw	r2,-24(fp)
    
    bit_mask = 0x00;
   27aa8:	e03ff815 	stw	zero,-32(fp)
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
   27aac:	e03ff915 	stw	zero,-28(fp)
   27ab0:	00000906 	br	27ad8 <alt_tse_phy_rd_mdio_reg+0x74>
    {
        bit_mask <<= 1;
   27ab4:	e0bff817 	ldw	r2,-32(fp)
   27ab8:	1085883a 	add	r2,r2,r2
   27abc:	e0bff815 	stw	r2,-32(fp)
        bit_mask |= 0x01;        
   27ac0:	e0bff817 	ldw	r2,-32(fp)
   27ac4:	10800054 	ori	r2,r2,1
   27ac8:	e0bff815 	stw	r2,-32(fp)
    
    bit_mask = 0x00;
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
   27acc:	e0bff917 	ldw	r2,-28(fp)
   27ad0:	10800044 	addi	r2,r2,1
   27ad4:	e0bff915 	stw	r2,-28(fp)
   27ad8:	e0bfff03 	ldbu	r2,-4(fp)
   27adc:	e0fff917 	ldw	r3,-28(fp)
   27ae0:	18bff416 	blt	r3,r2,27ab4 <alt_tse_phy_rd_mdio_reg+0x50>
        bit_mask <<= 1;
        bit_mask |= 0x01;        
    }
    
    /* read register data */
    temp_data = IORD(&pmac->mdio1, reg_num);
   27ae4:	e0bffa17 	ldw	r2,-24(fp)
   27ae8:	10c0a004 	addi	r3,r2,640
   27aec:	e0bffd03 	ldbu	r2,-12(fp)
   27af0:	1085883a 	add	r2,r2,r2
   27af4:	1085883a 	add	r2,r2,r2
   27af8:	1885883a 	add	r2,r3,r2
   27afc:	10800037 	ldwio	r2,0(r2)
   27b00:	e0bffb0d 	sth	r2,-20(fp)
    
    /* shifting read data */
    temp_data >>= lsb_num;
   27b04:	e0fffb0b 	ldhu	r3,-20(fp)
   27b08:	e0bffe03 	ldbu	r2,-8(fp)
   27b0c:	1885d83a 	sra	r2,r3,r2
   27b10:	e0bffb0d 	sth	r2,-20(fp)
    
    return (temp_data & bit_mask);
   27b14:	e0fffb0b 	ldhu	r3,-20(fp)
   27b18:	e0bff817 	ldw	r2,-32(fp)
   27b1c:	1884703a 	and	r2,r3,r2
}
   27b20:	e037883a 	mov	sp,fp
   27b24:	df000017 	ldw	fp,0(sp)
   27b28:	dec00104 	addi	sp,sp,4
   27b2c:	f800283a 	ret

00027b30 <alt_tse_phy_add_profile_default>:
 * @param pmac  N/A
 * @return      Number of PHY in profile
 * 
 * User might add their own PHY by calling alt_tse_phy_add_profile()
 */
alt_32 alt_tse_phy_add_profile_default() {
   27b30:	deff9a04 	addi	sp,sp,-408
   27b34:	dfc06515 	stw	ra,404(sp)
   27b38:	df006415 	stw	fp,400(sp)
   27b3c:	df006404 	addi	fp,sp,400
        
    /* ------------------------------ */
    /* Marvell PHY on PHYWORKX board  */
    /* ------------------------------ */
    
    alt_tse_phy_profile MV88E1111 = {"Marvell 88E1111",      /* Marvell 88E1111                                  */
   27b40:	e0ff9c04 	addi	r3,fp,-400
   27b44:	00801904 	movi	r2,100
   27b48:	1809883a 	mov	r4,r3
   27b4c:	000b883a 	mov	r5,zero
   27b50:	100d883a 	mov	r6,r2
   27b54:	0016f600 	call	16f60 <memset>
   27b58:	009d9cb4 	movhi	r2,30322
   27b5c:	10985344 	addi	r2,r2,24909
   27b60:	e0bf9c15 	stw	r2,-400(fp)
   27b64:	00881b34 	movhi	r2,8300
   27b68:	109b1944 	addi	r2,r2,27749
   27b6c:	e0bf9d15 	stw	r2,-396(fp)
   27b70:	008c5174 	movhi	r2,12613
   27b74:	108e0e04 	addi	r2,r2,14392
   27b78:	e0bf9e15 	stw	r2,-392(fp)
   27b7c:	00800c74 	movhi	r2,49
   27b80:	108c4c44 	addi	r2,r2,12593
   27b84:	e0bf9f15 	stw	r2,-388(fp)
   27b88:	e0ffa004 	addi	r3,fp,-384
   27b8c:	00801004 	movi	r2,64
   27b90:	1809883a 	mov	r4,r3
   27b94:	000b883a 	mov	r5,zero
   27b98:	100d883a 	mov	r6,r2
   27b9c:	0016f600 	call	16f60 <memset>
   27ba0:	009410c4 	movi	r2,20547
   27ba4:	e0bfb015 	stw	r2,-320(fp)
   27ba8:	00800304 	movi	r2,12
   27bac:	e0bfb105 	stb	r2,-316(fp)
   27bb0:	00800084 	movi	r2,2
   27bb4:	e0bfb145 	stb	r2,-315(fp)
   27bb8:	00800444 	movi	r2,17
   27bbc:	e0bfb185 	stb	r2,-314(fp)
   27bc0:	00800384 	movi	r2,14
   27bc4:	e0bfb1c5 	stb	r2,-313(fp)
   27bc8:	00800344 	movi	r2,13
   27bcc:	e0bfb205 	stb	r2,-312(fp)
   27bd0:	00800284 	movi	r2,10
   27bd4:	e0bfb245 	stb	r2,-311(fp)
   27bd8:	008000f4 	movhi	r2,3
   27bdc:	10a95604 	addi	r2,r2,-23208
   27be0:	e0bfb315 	stw	r2,-308(fp)
    
    /* ---------------------------------- */
    /* Marvell Quad PHY on PHYWORKX board */
    /* ---------------------------------- */
    
    alt_tse_phy_profile MV88E1145 = {"Marvell Quad PHY 88E1145",      /* Marvell 88E1145                                  */
   27be4:	e0ffb504 	addi	r3,fp,-300
   27be8:	00801904 	movi	r2,100
   27bec:	1809883a 	mov	r4,r3
   27bf0:	000b883a 	mov	r5,zero
   27bf4:	100d883a 	mov	r6,r2
   27bf8:	0016f600 	call	16f60 <memset>
   27bfc:	009d9cb4 	movhi	r2,30322
   27c00:	10985344 	addi	r2,r2,24909
   27c04:	e0bfb515 	stw	r2,-300(fp)
   27c08:	00881b34 	movhi	r2,8300
   27c0c:	109b1944 	addi	r2,r2,27749
   27c10:	e0bfb615 	stw	r2,-296(fp)
   27c14:	00991874 	movhi	r2,25697
   27c18:	109d5444 	addi	r2,r2,30033
   27c1c:	e0bfb715 	stw	r2,-292(fp)
   27c20:	00965234 	movhi	r2,22856
   27c24:	10940804 	addi	r2,r2,20512
   27c28:	e0bfb815 	stw	r2,-288(fp)
   27c2c:	00914e34 	movhi	r2,17720
   27c30:	108e0804 	addi	r2,r2,14368
   27c34:	e0bfb915 	stw	r2,-284(fp)
   27c38:	008d4d34 	movhi	r2,13620
   27c3c:	108c4c44 	addi	r2,r2,12593
   27c40:	e0bfba15 	stw	r2,-280(fp)
   27c44:	e03fbb15 	stw	zero,-276(fp)
   27c48:	e03fbc15 	stw	zero,-272(fp)
   27c4c:	e03fbd15 	stw	zero,-268(fp)
   27c50:	e03fbe15 	stw	zero,-264(fp)
   27c54:	e03fbf15 	stw	zero,-260(fp)
   27c58:	e03fc015 	stw	zero,-256(fp)
   27c5c:	e03fc115 	stw	zero,-252(fp)
   27c60:	e03fc215 	stw	zero,-248(fp)
   27c64:	e03fc315 	stw	zero,-244(fp)
   27c68:	e03fc415 	stw	zero,-240(fp)
   27c6c:	e03fc515 	stw	zero,-236(fp)
   27c70:	e03fc615 	stw	zero,-232(fp)
   27c74:	e03fc715 	stw	zero,-228(fp)
   27c78:	e03fc815 	stw	zero,-224(fp)
   27c7c:	009410c4 	movi	r2,20547
   27c80:	e0bfc915 	stw	r2,-220(fp)
   27c84:	00800344 	movi	r2,13
   27c88:	e0bfca05 	stb	r2,-216(fp)
   27c8c:	00800084 	movi	r2,2
   27c90:	e0bfca45 	stb	r2,-215(fp)
   27c94:	00800444 	movi	r2,17
   27c98:	e0bfca85 	stb	r2,-214(fp)
   27c9c:	00800384 	movi	r2,14
   27ca0:	e0bfcac5 	stb	r2,-213(fp)
   27ca4:	00800344 	movi	r2,13
   27ca8:	e0bfcb05 	stb	r2,-212(fp)
   27cac:	00800284 	movi	r2,10
   27cb0:	e0bfcb45 	stb	r2,-211(fp)
   27cb4:	008000f4 	movhi	r2,3
   27cb8:	10a95604 	addi	r2,r2,-23208
   27cbc:	e0bfcc15 	stw	r2,-208(fp)
                      
    /* ------------------------------ */
    /* National PHY on PHYWORKX board */
    /* ------------------------------ */  
    
    alt_tse_phy_profile DP83865 = {"National DP83865",     /* National DP83865                                 */
   27cc0:	e0ffce04 	addi	r3,fp,-200
   27cc4:	00801904 	movi	r2,100
   27cc8:	1809883a 	mov	r4,r3
   27ccc:	000b883a 	mov	r5,zero
   27cd0:	100d883a 	mov	r6,r2
   27cd4:	0016f600 	call	16f60 <memset>
   27cd8:	009a5d34 	movhi	r2,26996
   27cdc:	10985384 	addi	r2,r2,24910
   27ce0:	e0bfce15 	stw	r2,-200(fp)
   27ce4:	009b1874 	movhi	r2,27745
   27ce8:	109b9bc4 	addi	r2,r2,28271
   27cec:	e0bfcf15 	stw	r2,-196(fp)
   27cf0:	008e1434 	movhi	r2,14416
   27cf4:	10910804 	addi	r2,r2,17440
   27cf8:	e0bfd015 	stw	r2,-192(fp)
   27cfc:	008d4db4 	movhi	r2,13622
   27d00:	108e0cc4 	addi	r2,r2,14387
   27d04:	e0bfd115 	stw	r2,-188(fp)
   27d08:	e03fd215 	stw	zero,-184(fp)
   27d0c:	e0ffd304 	addi	r3,fp,-180
   27d10:	00800f04 	movi	r2,60
   27d14:	1809883a 	mov	r4,r3
   27d18:	000b883a 	mov	r5,zero
   27d1c:	100d883a 	mov	r6,r2
   27d20:	0016f600 	call	16f60 <memset>
   27d24:	00800234 	movhi	r2,8
   27d28:	108005c4 	addi	r2,r2,23
   27d2c:	e0bfe215 	stw	r2,-120(fp)
   27d30:	008001c4 	movi	r2,7
   27d34:	e0bfe305 	stb	r2,-116(fp)
   27d38:	00800284 	movi	r2,10
   27d3c:	e0bfe345 	stb	r2,-115(fp)
   27d40:	00800444 	movi	r2,17
   27d44:	e0bfe385 	stb	r2,-114(fp)
   27d48:	008000c4 	movi	r2,3
   27d4c:	e0bfe3c5 	stb	r2,-113(fp)
   27d50:	00800044 	movi	r2,1
   27d54:	e0bfe405 	stb	r2,-112(fp)
   27d58:	00800084 	movi	r2,2
   27d5c:	e0bfe445 	stb	r2,-111(fp)
                      
    /* -------------------------------------- */
    /* National 10/100 PHY on PHYWORKX board  */
    /* -------------------------------------- */ 
                      
    alt_tse_phy_profile DP83848C = {"National DP83848C",  /* National DP83848C                                          */
   27d60:	008000f4 	movhi	r2,3
   27d64:	10828704 	addi	r2,r2,2588
   27d68:	e13fe704 	addi	r4,fp,-100
   27d6c:	1007883a 	mov	r3,r2
   27d70:	00801904 	movi	r2,100
   27d74:	180b883a 	mov	r5,r3
   27d78:	100d883a 	mov	r6,r2
   27d7c:	0016e680 	call	16e68 <memcpy>
						   0,                              /* No function pointer configure National DP83848C            */
						   &DP83848C_link_status_read      /* Function pointer to read from PHY specific status register */           
                          };
                      
    /* add supported PHY to profile */                          
    alt_tse_phy_add_profile(&MV88E1111);
   27d80:	e13f9c04 	addi	r4,fp,-400
   27d84:	0025cb40 	call	25cb4 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&MV88E1145);
   27d88:	e0bfb504 	addi	r2,fp,-300
   27d8c:	1009883a 	mov	r4,r2
   27d90:	0025cb40 	call	25cb4 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&DP83865);
   27d94:	e0bfce04 	addi	r2,fp,-200
   27d98:	1009883a 	mov	r4,r2
   27d9c:	0025cb40 	call	25cb4 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&DP83848C);
   27da0:	e0bfe704 	addi	r2,fp,-100
   27da4:	1009883a 	mov	r4,r2
   27da8:	0025cb40 	call	25cb4 <alt_tse_phy_add_profile>
    
    
    return phy_profile_count;
   27dac:	d0a8f703 	ldbu	r2,-23588(gp)
   27db0:	10803fcc 	andi	r2,r2,255
}
   27db4:	e037883a 	mov	sp,fp
   27db8:	dfc00117 	ldw	ra,4(sp)
   27dbc:	df000017 	ldw	fp,0(sp)
   27dc0:	dec00204 	addi	sp,sp,8
   27dc4:	f800283a 	ret

00027dc8 <alt_tse_phy_print_profile>:
/* @Function Description: Display PHYs available in profile
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      Number of PHY in profile
 */
alt_32 alt_tse_phy_print_profile() {
   27dc8:	defffd04 	addi	sp,sp,-12
   27dcc:	dfc00215 	stw	ra,8(sp)
   27dd0:	df000115 	stw	fp,4(sp)
   27dd4:	df000104 	addi	fp,sp,4
   
	alt_8 i;
    /* display PHY in profile */
    tse_dprintf(6, "List of PHY profiles supported (Total profiles = %d)...\n", phy_profile_count);
   27dd8:	d0a8f703 	ldbu	r2,-23588(gp)
   27ddc:	10803fcc 	andi	r2,r2,255
   27de0:	010000f4 	movhi	r4,3
   27de4:	2102a004 	addi	r4,r4,2688
   27de8:	100b883a 	mov	r5,r2
   27dec:	00259780 	call	25978 <no_printf>
    
    for(i = 0; i < phy_profile_count; i++)
   27df0:	e03fff05 	stb	zero,-4(fp)
   27df4:	00006d06 	br	27fac <alt_tse_phy_print_profile+0x1e4>
    {
        tse_dprintf(6, "Profile No.%2d   :\n", i);
   27df8:	e0bfff07 	ldb	r2,-4(fp)
   27dfc:	010000f4 	movhi	r4,3
   27e00:	2102af04 	addi	r4,r4,2748
   27e04:	100b883a 	mov	r5,r2
   27e08:	00259780 	call	25978 <no_printf>
        tse_dprintf(6, "PHY Name        : %s\n", pphy_profiles[i]->name);
   27e0c:	e0bfff07 	ldb	r2,-4(fp)
   27e10:	00c00134 	movhi	r3,4
   27e14:	18d1bc04 	addi	r3,r3,18160
   27e18:	1085883a 	add	r2,r2,r2
   27e1c:	1085883a 	add	r2,r2,r2
   27e20:	1885883a 	add	r2,r3,r2
   27e24:	10800017 	ldw	r2,0(r2)
   27e28:	010000f4 	movhi	r4,3
   27e2c:	2102b404 	addi	r4,r4,2768
   27e30:	100b883a 	mov	r5,r2
   27e34:	00259780 	call	25978 <no_printf>
   
        tse_dprintf(6, "PHY OUI         : 0x%06x\n", (int)pphy_profiles[i]->oui);
   27e38:	e0bfff07 	ldb	r2,-4(fp)
   27e3c:	00c00134 	movhi	r3,4
   27e40:	18d1bc04 	addi	r3,r3,18160
   27e44:	1085883a 	add	r2,r2,r2
   27e48:	1085883a 	add	r2,r2,r2
   27e4c:	1885883a 	add	r2,r3,r2
   27e50:	10800017 	ldw	r2,0(r2)
   27e54:	10801417 	ldw	r2,80(r2)
   27e58:	010000f4 	movhi	r4,3
   27e5c:	2102ba04 	addi	r4,r4,2792
   27e60:	100b883a 	mov	r5,r2
   27e64:	00259780 	call	25978 <no_printf>
        tse_dprintf(6, "PHY Model Num.  : 0x%02x\n", pphy_profiles[i]->model_number);
   27e68:	e0bfff07 	ldb	r2,-4(fp)
   27e6c:	00c00134 	movhi	r3,4
   27e70:	18d1bc04 	addi	r3,r3,18160
   27e74:	1085883a 	add	r2,r2,r2
   27e78:	1085883a 	add	r2,r2,r2
   27e7c:	1885883a 	add	r2,r3,r2
   27e80:	10800017 	ldw	r2,0(r2)
   27e84:	10801503 	ldbu	r2,84(r2)
   27e88:	10803fcc 	andi	r2,r2,255
   27e8c:	010000f4 	movhi	r4,3
   27e90:	2102c104 	addi	r4,r4,2820
   27e94:	100b883a 	mov	r5,r2
   27e98:	00259780 	call	25978 <no_printf>
        tse_dprintf(6, "PHY Rev. Num.   : 0x%02x\n", pphy_profiles[i]->revision_number);
   27e9c:	e0bfff07 	ldb	r2,-4(fp)
   27ea0:	00c00134 	movhi	r3,4
   27ea4:	18d1bc04 	addi	r3,r3,18160
   27ea8:	1085883a 	add	r2,r2,r2
   27eac:	1085883a 	add	r2,r2,r2
   27eb0:	1885883a 	add	r2,r3,r2
   27eb4:	10800017 	ldw	r2,0(r2)
   27eb8:	10801543 	ldbu	r2,85(r2)
   27ebc:	10803fcc 	andi	r2,r2,255
   27ec0:	010000f4 	movhi	r4,3
   27ec4:	2102c804 	addi	r4,r4,2848
   27ec8:	100b883a 	mov	r5,r2
   27ecc:	00259780 	call	25978 <no_printf>
        
        tse_dprintf(6, "Status Register : 0x%02x\n", pphy_profiles[i]->status_reg_location); 
   27ed0:	e0bfff07 	ldb	r2,-4(fp)
   27ed4:	00c00134 	movhi	r3,4
   27ed8:	18d1bc04 	addi	r3,r3,18160
   27edc:	1085883a 	add	r2,r2,r2
   27ee0:	1085883a 	add	r2,r2,r2
   27ee4:	1885883a 	add	r2,r3,r2
   27ee8:	10800017 	ldw	r2,0(r2)
   27eec:	10801583 	ldbu	r2,86(r2)
   27ef0:	10803fcc 	andi	r2,r2,255
   27ef4:	010000f4 	movhi	r4,3
   27ef8:	2102cf04 	addi	r4,r4,2876
   27efc:	100b883a 	mov	r5,r2
   27f00:	00259780 	call	25978 <no_printf>
        
        tse_dprintf(6, "Speed Bit       : %d\n", pphy_profiles[i]->speed_lsb_location);
   27f04:	e0bfff07 	ldb	r2,-4(fp)
   27f08:	00c00134 	movhi	r3,4
   27f0c:	18d1bc04 	addi	r3,r3,18160
   27f10:	1085883a 	add	r2,r2,r2
   27f14:	1085883a 	add	r2,r2,r2
   27f18:	1885883a 	add	r2,r3,r2
   27f1c:	10800017 	ldw	r2,0(r2)
   27f20:	108015c3 	ldbu	r2,87(r2)
   27f24:	10803fcc 	andi	r2,r2,255
   27f28:	010000f4 	movhi	r4,3
   27f2c:	2102d604 	addi	r4,r4,2904
   27f30:	100b883a 	mov	r5,r2
   27f34:	00259780 	call	25978 <no_printf>
        
        tse_dprintf(6, "Duplex Bit      : %d\n", pphy_profiles[i]->duplex_bit_location);
   27f38:	e0bfff07 	ldb	r2,-4(fp)
   27f3c:	00c00134 	movhi	r3,4
   27f40:	18d1bc04 	addi	r3,r3,18160
   27f44:	1085883a 	add	r2,r2,r2
   27f48:	1085883a 	add	r2,r2,r2
   27f4c:	1885883a 	add	r2,r3,r2
   27f50:	10800017 	ldw	r2,0(r2)
   27f54:	10801603 	ldbu	r2,88(r2)
   27f58:	10803fcc 	andi	r2,r2,255
   27f5c:	010000f4 	movhi	r4,3
   27f60:	2102dc04 	addi	r4,r4,2928
   27f64:	100b883a 	mov	r5,r2
   27f68:	00259780 	call	25978 <no_printf>
        
        tse_dprintf(6, "Link Bit        : %d\n\n", pphy_profiles[i]->link_bit_location);
   27f6c:	e0bfff07 	ldb	r2,-4(fp)
   27f70:	00c00134 	movhi	r3,4
   27f74:	18d1bc04 	addi	r3,r3,18160
   27f78:	1085883a 	add	r2,r2,r2
   27f7c:	1085883a 	add	r2,r2,r2
   27f80:	1885883a 	add	r2,r3,r2
   27f84:	10800017 	ldw	r2,0(r2)
   27f88:	10801643 	ldbu	r2,89(r2)
   27f8c:	10803fcc 	andi	r2,r2,255
   27f90:	010000f4 	movhi	r4,3
   27f94:	2102e204 	addi	r4,r4,2952
   27f98:	100b883a 	mov	r5,r2
   27f9c:	00259780 	call	25978 <no_printf>
   
	alt_8 i;
    /* display PHY in profile */
    tse_dprintf(6, "List of PHY profiles supported (Total profiles = %d)...\n", phy_profile_count);
    
    for(i = 0; i < phy_profile_count; i++)
   27fa0:	e0bfff03 	ldbu	r2,-4(fp)
   27fa4:	10800044 	addi	r2,r2,1
   27fa8:	e0bfff05 	stb	r2,-4(fp)
   27fac:	e0ffff07 	ldb	r3,-4(fp)
   27fb0:	d0a8f703 	ldbu	r2,-23588(gp)
   27fb4:	10803fcc 	andi	r2,r2,255
   27fb8:	18bf8f16 	blt	r3,r2,27df8 <alt_tse_phy_print_profile+0x30>
        
        tse_dprintf(6, "Link Bit        : %d\n\n", pphy_profiles[i]->link_bit_location);
 
    }
    
    return phy_profile_count;
   27fbc:	d0a8f703 	ldbu	r2,-23588(gp)
   27fc0:	10803fcc 	andi	r2,r2,255
}
   27fc4:	e037883a 	mov	sp,fp
   27fc8:	dfc00117 	ldw	ra,4(sp)
   27fcc:	df000017 	ldw	fp,0(sp)
   27fd0:	dec00204 	addi	sp,sp,8
   27fd4:	f800283a 	ret

00027fd8 <alt_tse_mac_group_init>:
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      return SUCCESS
 *              return ALTERA_TSE_SYSTEM_DEF_ERROR if alt_tse_system_info structure definition error
 */
alt_32 alt_tse_mac_group_init() {
   27fd8:	defffa04 	addi	sp,sp,-24
   27fdc:	dfc00515 	stw	ra,20(sp)
   27fe0:	df000415 	stw	fp,16(sp)
   27fe4:	df000404 	addi	fp,sp,16
    
	alt_8 i;
	alt_8 j;
    
    alt_tse_mac_group *pmac_group = 0;
   27fe8:	e03ffd15 	stw	zero,-12(fp)
    alt_tse_mac_info *pmac_info = 0;
   27fec:	e03ffe15 	stw	zero,-8(fp)
    alt_tse_system_info *psys = 0;
   27ff0:	e03fff15 	stw	zero,-4(fp)

    /* reset number of MAC group */
    mac_group_count = 0;
   27ff4:	d028f745 	stb	zero,-23587(gp)
    
    /* loop through every alt_tse_system_info structure */
    for(i = 0; i < max_mac_system; i++) {
   27ff8:	e03ffc05 	stb	zero,-16(fp)
   27ffc:	00019306 	br	2864c <alt_tse_mac_group_init+0x674>
        psys = &tse_mac_device[i];
   28000:	e0bffc07 	ldb	r2,-16(fp)
   28004:	10c01224 	muli	r3,r2,72
   28008:	008000f4 	movhi	r2,3
   2800c:	10886204 	addi	r2,r2,8584
   28010:	1885883a 	add	r2,r3,r2
   28014:	e0bfff15 	stw	r2,-4(fp)

        if((psys->tse_sgdma_tx != 0) && (psys->tse_sgdma_rx != 0)) {    	
   28018:	e0bfff17 	ldw	r2,-4(fp)
   2801c:	10800517 	ldw	r2,20(r2)
   28020:	10018726 	beq	r2,zero,28640 <alt_tse_mac_group_init+0x668>
   28024:	e0bfff17 	ldw	r2,-4(fp)
   28028:	10800617 	ldw	r2,24(r2)
   2802c:	10018426 	beq	r2,zero,28640 <alt_tse_mac_group_init+0x668>
            tse_dprintf(5, "INFO    : TSE MAC %d found at address 0x%08x\n", mac_group_count, (int) psys->tse_mac_base);
   28030:	d0a8f743 	ldbu	r2,-23587(gp)
   28034:	10c03fcc 	andi	r3,r2,255
   28038:	e0bfff17 	ldw	r2,-4(fp)
   2803c:	10800017 	ldw	r2,0(r2)
   28040:	010000f4 	movhi	r4,3
   28044:	2102e804 	addi	r4,r4,2976
   28048:	180b883a 	mov	r5,r3
   2804c:	100d883a 	mov	r6,r2
   28050:	00170680 	call	17068 <printf>
            
            /* Allocate memory for the structure */
            pmac_group = (alt_tse_mac_group *) malloc(sizeof(alt_tse_mac_group));
   28054:	01000904 	movi	r4,36
   28058:	002cae80 	call	2cae8 <malloc>
   2805c:	e0bffd15 	stw	r2,-12(fp)
            if(!pmac_group) {
   28060:	e0bffd17 	ldw	r2,-12(fp)
   28064:	1000081e 	bne	r2,zero,28088 <alt_tse_mac_group_init+0xb0>
                tse_dprintf(1, "ERROR   : Unable to allocate memory for MAC Group[%d]\n", mac_group_count);
   28068:	d0a8f743 	ldbu	r2,-23587(gp)
   2806c:	10803fcc 	andi	r2,r2,255
   28070:	010000f4 	movhi	r4,3
   28074:	2102f404 	addi	r4,r4,3024
   28078:	100b883a 	mov	r5,r2
   2807c:	00170680 	call	17068 <printf>
                return ALTERA_TSE_MALLOC_FAILED;
   28080:	00bfffc4 	movi	r2,-1
   28084:	00017606 	br	28660 <alt_tse_mac_group_init+0x688>
            }
           
            /* Non-multi-channel MAC considered as 1 channel */
            if(psys->tse_multichannel_mac) {
   28088:	e0bfff17 	ldw	r2,-4(fp)
   2808c:	108002c3 	ldbu	r2,11(r2)
   28090:	10803fcc 	andi	r2,r2,255
   28094:	10001226 	beq	r2,zero,280e0 <alt_tse_mac_group_init+0x108>
                pmac_group->channel = psys->tse_num_of_channel;
   28098:	e0bfff17 	ldw	r2,-4(fp)
   2809c:	10c00303 	ldbu	r3,12(r2)
   280a0:	e0bffd17 	ldw	r2,-12(fp)
   280a4:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = Yes\n");
   280a8:	010000f4 	movhi	r4,3
   280ac:	21030204 	addi	r4,r4,3080
   280b0:	00259780 	call	25978 <no_printf>
                tse_dprintf(6, "INFO    : Number of channel        = %d\n", pmac_group->channel);
   280b4:	e0bffd17 	ldw	r2,-12(fp)
   280b8:	10800003 	ldbu	r2,0(r2)
   280bc:	10803fcc 	andi	r2,r2,255
   280c0:	010000f4 	movhi	r4,3
   280c4:	21030d04 	addi	r4,r4,3124
   280c8:	100b883a 	mov	r5,r2
   280cc:	00259780 	call	25978 <no_printf>
            	tse_dprintf(6, "INFO    : MDIO Shared              = Yes\n");
   280d0:	010000f4 	movhi	r4,3
   280d4:	21031804 	addi	r4,r4,3168
   280d8:	00259780 	call	25978 <no_printf>
   280dc:	00001f06 	br	2815c <alt_tse_mac_group_init+0x184>
            }
            else if(psys->tse_mdio_shared) {
   280e0:	e0bfff17 	ldw	r2,-4(fp)
   280e4:	10800343 	ldbu	r2,13(r2)
   280e8:	10803fcc 	andi	r2,r2,255
   280ec:	10001226 	beq	r2,zero,28138 <alt_tse_mac_group_init+0x160>
                pmac_group->channel = psys->tse_number_of_mac_mdio_shared;
   280f0:	e0bfff17 	ldw	r2,-4(fp)
   280f4:	10c00383 	ldbu	r3,14(r2)
   280f8:	e0bffd17 	ldw	r2,-12(fp)
   280fc:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
   28100:	010000f4 	movhi	r4,3
   28104:	21032304 	addi	r4,r4,3212
   28108:	00259780 	call	25978 <no_printf>
                tse_dprintf(6, "INFO    : MDIO Shared              = Yes\n");
   2810c:	010000f4 	movhi	r4,3
   28110:	21031804 	addi	r4,r4,3168
   28114:	00259780 	call	25978 <no_printf>
                tse_dprintf(6, "INFO    : Number of MAC Share MDIO = %d\n", pmac_group->channel);
   28118:	e0bffd17 	ldw	r2,-12(fp)
   2811c:	10800003 	ldbu	r2,0(r2)
   28120:	10803fcc 	andi	r2,r2,255
   28124:	010000f4 	movhi	r4,3
   28128:	21032e04 	addi	r4,r4,3256
   2812c:	100b883a 	mov	r5,r2
   28130:	00259780 	call	25978 <no_printf>
   28134:	00000906 	br	2815c <alt_tse_mac_group_init+0x184>
            }
            else {
                pmac_group->channel = 1;
   28138:	e0bffd17 	ldw	r2,-12(fp)
   2813c:	00c00044 	movi	r3,1
   28140:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
   28144:	010000f4 	movhi	r4,3
   28148:	21032304 	addi	r4,r4,3212
   2814c:	00259780 	call	25978 <no_printf>
                tse_dprintf(6, "INFO    : MDIO Shared              = No\n");
   28150:	010000f4 	movhi	r4,3
   28154:	21033904 	addi	r4,r4,3300
   28158:	00259780 	call	25978 <no_printf>
            }
            
            for(j = 0; j < pmac_group->channel; j++) {
   2815c:	e03ffc45 	stb	zero,-15(fp)
   28160:	00012006 	br	285e4 <alt_tse_mac_group_init+0x60c>
                /* Allocate memory for the structure */
                pmac_info = (alt_tse_mac_info *) malloc(sizeof(alt_tse_mac_info));
   28164:	01000404 	movi	r4,16
   28168:	002cae80 	call	2cae8 <malloc>
   2816c:	e0bffe15 	stw	r2,-8(fp)
                if(!pmac_info) {
   28170:	e0bffe17 	ldw	r2,-8(fp)
   28174:	10000a1e 	bne	r2,zero,281a0 <alt_tse_mac_group_init+0x1c8>
                    tse_dprintf(1, "ERROR   : Unable to allocate memory for MAC Group[%d]->pmac_info[%d]\n", mac_group_count, j);
   28178:	d0a8f743 	ldbu	r2,-23587(gp)
   2817c:	10c03fcc 	andi	r3,r2,255
   28180:	e0bffc47 	ldb	r2,-15(fp)
   28184:	010000f4 	movhi	r4,3
   28188:	21034404 	addi	r4,r4,3344
   2818c:	180b883a 	mov	r5,r3
   28190:	100d883a 	mov	r6,r2
   28194:	00170680 	call	17068 <printf>
                    return ALTERA_TSE_MALLOC_FAILED;
   28198:	00bfffc4 	movi	r2,-1
   2819c:	00013006 	br	28660 <alt_tse_mac_group_init+0x688>
                }
                
                pmac_info->pmac_group = pmac_group;
   281a0:	e0bffe17 	ldw	r2,-8(fp)
   281a4:	e0fffd17 	ldw	r3,-12(fp)
   281a8:	10c00315 	stw	r3,12(r2)
                
                pmac_info->pphy_info = 0;
   281ac:	e0bffe17 	ldw	r2,-8(fp)
   281b0:	10000115 	stw	zero,4(r2)
                
                pmac_info->psys_info = &tse_mac_device[i + j];
   281b4:	e0fffc07 	ldb	r3,-16(fp)
   281b8:	e0bffc47 	ldb	r2,-15(fp)
   281bc:	1885883a 	add	r2,r3,r2
   281c0:	10c01224 	muli	r3,r2,72
   281c4:	008000f4 	movhi	r2,3
   281c8:	10886204 	addi	r2,r2,8584
   281cc:	1887883a 	add	r3,r3,r2
   281d0:	e0bffe17 	ldw	r2,-8(fp)
   281d4:	10c00215 	stw	r3,8(r2)
                
                /* check to make sure the alt_tse_system_info defined correctly or has been defined */
                if((pmac_info->psys_info->tse_sgdma_tx == 0) || (pmac_info->psys_info->tse_sgdma_rx == 0)){                	
   281d8:	e0bffe17 	ldw	r2,-8(fp)
   281dc:	10800217 	ldw	r2,8(r2)
   281e0:	10800517 	ldw	r2,20(r2)
   281e4:	10000426 	beq	r2,zero,281f8 <alt_tse_mac_group_init+0x220>
   281e8:	e0bffe17 	ldw	r2,-8(fp)
   281ec:	10800217 	ldw	r2,8(r2)
   281f0:	10800617 	ldw	r2,24(r2)
   281f4:	1000091e 	bne	r2,zero,2821c <alt_tse_mac_group_init+0x244>
                    tse_dprintf(2, "ERROR   : tse_mac_device[%d] does not defined correctly!\n", i + j);
   281f8:	e0fffc07 	ldb	r3,-16(fp)
   281fc:	e0bffc47 	ldb	r2,-15(fp)
   28200:	1885883a 	add	r2,r3,r2
   28204:	010000f4 	movhi	r4,3
   28208:	21035604 	addi	r4,r4,3416
   2820c:	100b883a 	mov	r5,r2
   28210:	00170680 	call	17068 <printf>
                    return ALTERA_TSE_SYSTEM_DEF_ERROR;
   28214:	00bfffc4 	movi	r2,-1
   28218:	00011106 	br	28660 <alt_tse_mac_group_init+0x688>
                }
                
                /* MAC type detection */
                if(pmac_info->psys_info->tse_en_maclite) {
   2821c:	e0bffe17 	ldw	r2,-8(fp)
   28220:	10800217 	ldw	r2,8(r2)
   28224:	10800243 	ldbu	r2,9(r2)
   28228:	10803fcc 	andi	r2,r2,255
   2822c:	10000d26 	beq	r2,zero,28264 <alt_tse_mac_group_init+0x28c>
                    if(pmac_info->psys_info->tse_maclite_gige) {
   28230:	e0bffe17 	ldw	r2,-8(fp)
   28234:	10800217 	ldw	r2,8(r2)
   28238:	10800283 	ldbu	r2,10(r2)
   2823c:	10803fcc 	andi	r2,r2,255
   28240:	10000426 	beq	r2,zero,28254 <alt_tse_mac_group_init+0x27c>
                        pmac_info->mac_type = ALTERA_TSE_MACLITE_1000;
   28244:	e0bffe17 	ldw	r2,-8(fp)
   28248:	00c00084 	movi	r3,2
   2824c:	10c00005 	stb	r3,0(r2)
   28250:	00000606 	br	2826c <alt_tse_mac_group_init+0x294>
                    }
                    else {
                        pmac_info->mac_type = ALTERA_TSE_MACLITE_10_100;
   28254:	e0bffe17 	ldw	r2,-8(fp)
   28258:	00c00044 	movi	r3,1
   2825c:	10c00005 	stb	r3,0(r2)
   28260:	00000206 	br	2826c <alt_tse_mac_group_init+0x294>
                    }
                }
                else {
                    pmac_info->mac_type = ALTERA_TSE_FULL_MAC;                    
   28264:	e0bffe17 	ldw	r2,-8(fp)
   28268:	10000005 	stb	zero,0(r2)
                }
                
                if((pmac_info->psys_info->tse_mdio_shared) && (!pmac_info->psys_info->tse_multichannel_mac)){
   2826c:	e0bffe17 	ldw	r2,-8(fp)
   28270:	10800217 	ldw	r2,8(r2)
   28274:	10800343 	ldbu	r2,13(r2)
   28278:	10803fcc 	andi	r2,r2,255
   2827c:	10006526 	beq	r2,zero,28414 <alt_tse_mac_group_init+0x43c>
   28280:	e0bffe17 	ldw	r2,-8(fp)
   28284:	10800217 	ldw	r2,8(r2)
   28288:	108002c3 	ldbu	r2,11(r2)
   2828c:	10803fcc 	andi	r2,r2,255
   28290:	1000601e 	bne	r2,zero,28414 <alt_tse_mac_group_init+0x43c>
                	tse_dprintf(6, "INFO    : MAC %2d Address           = 0x%08x\n", j, (int) pmac_info->psys_info->tse_mac_base);
   28294:	e0fffc47 	ldb	r3,-15(fp)
   28298:	e0bffe17 	ldw	r2,-8(fp)
   2829c:	10800217 	ldw	r2,8(r2)
   282a0:	10800017 	ldw	r2,0(r2)
   282a4:	010000f4 	movhi	r4,3
   282a8:	21036504 	addi	r4,r4,3476
   282ac:	180b883a 	mov	r5,r3
   282b0:	100d883a 	mov	r6,r2
   282b4:	00259780 	call	25978 <no_printf>
                    tse_dprintf(6, "INFO    : MAC %2d Device            = tse_mac_device[%d]\n", j, i + j);
   282b8:	e0fffc47 	ldb	r3,-15(fp)
   282bc:	e13ffc07 	ldb	r4,-16(fp)
   282c0:	e0bffc47 	ldb	r2,-15(fp)
   282c4:	2085883a 	add	r2,r4,r2
   282c8:	010000f4 	movhi	r4,3
   282cc:	21037104 	addi	r4,r4,3524
   282d0:	180b883a 	mov	r5,r3
   282d4:	100d883a 	mov	r6,r2
   282d8:	00259780 	call	25978 <no_printf>
                    
                	switch(pmac_info->mac_type) {
   282dc:	e0bffe17 	ldw	r2,-8(fp)
   282e0:	10800003 	ldbu	r2,0(r2)
   282e4:	10803fcc 	andi	r2,r2,255
   282e8:	10c00060 	cmpeqi	r3,r2,1
   282ec:	18000c1e 	bne	r3,zero,28320 <alt_tse_mac_group_init+0x348>
   282f0:	10c000a0 	cmpeqi	r3,r2,2
   282f4:	1800021e 	bne	r3,zero,28300 <alt_tse_mac_group_init+0x328>
   282f8:	10001126 	beq	r2,zero,28340 <alt_tse_mac_group_init+0x368>
   282fc:	00001806 	br	28360 <alt_tse_mac_group_init+0x388>
                        case ALTERA_TSE_MACLITE_1000:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "1000 Mbps Small MAC");
   28300:	e0bffc47 	ldb	r2,-15(fp)
   28304:	010000f4 	movhi	r4,3
   28308:	21038004 	addi	r4,r4,3584
   2830c:	100b883a 	mov	r5,r2
   28310:	018000f4 	movhi	r6,3
   28314:	31838b04 	addi	r6,r6,3628
   28318:	00259780 	call	25978 <no_printf>
                            break;
   2831c:	00001706 	br	2837c <alt_tse_mac_group_init+0x3a4>
                        case ALTERA_TSE_MACLITE_10_100:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "10/100 Mbps Small MAC");
   28320:	e0bffc47 	ldb	r2,-15(fp)
   28324:	010000f4 	movhi	r4,3
   28328:	21038004 	addi	r4,r4,3584
   2832c:	100b883a 	mov	r5,r2
   28330:	018000f4 	movhi	r6,3
   28334:	31839004 	addi	r6,r6,3648
   28338:	00259780 	call	25978 <no_printf>
                            break;
   2833c:	00000f06 	br	2837c <alt_tse_mac_group_init+0x3a4>
                        case ALTERA_TSE_FULL_MAC:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "10/100/1000 Ethernet MAC");
   28340:	e0bffc47 	ldb	r2,-15(fp)
   28344:	010000f4 	movhi	r4,3
   28348:	21038004 	addi	r4,r4,3584
   2834c:	100b883a 	mov	r5,r2
   28350:	018000f4 	movhi	r6,3
   28354:	31839604 	addi	r6,r6,3672
   28358:	00259780 	call	25978 <no_printf>
                            break;
   2835c:	00000706 	br	2837c <alt_tse_mac_group_init+0x3a4>
                        default :
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "Unknown");
   28360:	e0bffc47 	ldb	r2,-15(fp)
   28364:	010000f4 	movhi	r4,3
   28368:	21038004 	addi	r4,r4,3584
   2836c:	100b883a 	mov	r5,r2
   28370:	018000f4 	movhi	r6,3
   28374:	3181ce04 	addi	r6,r6,1848
   28378:	00259780 	call	25978 <no_printf>
                    }
                    
                    if(pmac_info->psys_info->tse_pcs_ena) {
   2837c:	e0bffe17 	ldw	r2,-8(fp)
   28380:	10800217 	ldw	r2,8(r2)
   28384:	108003c3 	ldbu	r2,15(r2)
   28388:	10803fcc 	andi	r2,r2,255
   2838c:	10008a26 	beq	r2,zero,285b8 <alt_tse_mac_group_init+0x5e0>
                        tse_dprintf(6, "INFO    : PCS %2d Enable            = %s\n", j, pmac_info->psys_info->tse_pcs_ena ? "Yes" : "No");
   28390:	e0fffc47 	ldb	r3,-15(fp)
   28394:	e0bffe17 	ldw	r2,-8(fp)
   28398:	10800217 	ldw	r2,8(r2)
   2839c:	108003c3 	ldbu	r2,15(r2)
   283a0:	10803fcc 	andi	r2,r2,255
   283a4:	10000326 	beq	r2,zero,283b4 <alt_tse_mac_group_init+0x3dc>
   283a8:	008000f4 	movhi	r2,3
   283ac:	10839d04 	addi	r2,r2,3700
   283b0:	00000206 	br	283bc <alt_tse_mac_group_init+0x3e4>
   283b4:	008000f4 	movhi	r2,3
   283b8:	10839e04 	addi	r2,r2,3704
   283bc:	010000f4 	movhi	r4,3
   283c0:	21039f04 	addi	r4,r4,3708
   283c4:	180b883a 	mov	r5,r3
   283c8:	100d883a 	mov	r6,r2
   283cc:	00259780 	call	25978 <no_printf>
                        tse_dprintf(6, "INFO    : PCS %2d SGMII Enable      = %s\n", j, pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");                        
   283d0:	e0fffc47 	ldb	r3,-15(fp)
   283d4:	e0bffe17 	ldw	r2,-8(fp)
   283d8:	10800217 	ldw	r2,8(r2)
   283dc:	10800403 	ldbu	r2,16(r2)
   283e0:	10803fcc 	andi	r2,r2,255
   283e4:	10000326 	beq	r2,zero,283f4 <alt_tse_mac_group_init+0x41c>
   283e8:	008000f4 	movhi	r2,3
   283ec:	10839d04 	addi	r2,r2,3700
   283f0:	00000206 	br	283fc <alt_tse_mac_group_init+0x424>
   283f4:	008000f4 	movhi	r2,3
   283f8:	10839e04 	addi	r2,r2,3704
   283fc:	010000f4 	movhi	r4,3
   28400:	2103aa04 	addi	r4,r4,3752
   28404:	180b883a 	mov	r5,r3
   28408:	100d883a 	mov	r6,r2
   2840c:	00259780 	call	25978 <no_printf>
                            break;
                        default :
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "Unknown");
                    }
                    
                    if(pmac_info->psys_info->tse_pcs_ena) {
   28410:	00006906 	br	285b8 <alt_tse_mac_group_init+0x5e0>
                        tse_dprintf(6, "INFO    : PCS %2d SGMII Enable      = %s\n", j, pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");                        
                    }
                }
                else {
                	/* display only once for all MAC, except shared MDIO MACs */
	                if(j == 0) {
   28414:	e0bffc47 	ldb	r2,-15(fp)
   28418:	1000411e 	bne	r2,zero,28520 <alt_tse_mac_group_init+0x548>
	                    switch(pmac_info->mac_type) {
   2841c:	e0bffe17 	ldw	r2,-8(fp)
   28420:	10800003 	ldbu	r2,0(r2)
   28424:	10803fcc 	andi	r2,r2,255
   28428:	10c00060 	cmpeqi	r3,r2,1
   2842c:	18000a1e 	bne	r3,zero,28458 <alt_tse_mac_group_init+0x480>
   28430:	10c000a0 	cmpeqi	r3,r2,2
   28434:	1800021e 	bne	r3,zero,28440 <alt_tse_mac_group_init+0x468>
   28438:	10000d26 	beq	r2,zero,28470 <alt_tse_mac_group_init+0x498>
   2843c:	00001206 	br	28488 <alt_tse_mac_group_init+0x4b0>
	                        case ALTERA_TSE_MACLITE_1000:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "1000 Mbps Small MAC");
   28440:	010000f4 	movhi	r4,3
   28444:	2103b504 	addi	r4,r4,3796
   28448:	014000f4 	movhi	r5,3
   2844c:	29438b04 	addi	r5,r5,3628
   28450:	00259780 	call	25978 <no_printf>
	                            break;
   28454:	00001106 	br	2849c <alt_tse_mac_group_init+0x4c4>
	                        case ALTERA_TSE_MACLITE_10_100:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "10/100 Mbps Small MAC");
   28458:	010000f4 	movhi	r4,3
   2845c:	2103b504 	addi	r4,r4,3796
   28460:	014000f4 	movhi	r5,3
   28464:	29439004 	addi	r5,r5,3648
   28468:	00259780 	call	25978 <no_printf>
	                            break;
   2846c:	00000b06 	br	2849c <alt_tse_mac_group_init+0x4c4>
	                        case ALTERA_TSE_FULL_MAC:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "10/100/1000 Ethernet MAC");
   28470:	010000f4 	movhi	r4,3
   28474:	2103b504 	addi	r4,r4,3796
   28478:	014000f4 	movhi	r5,3
   2847c:	29439604 	addi	r5,r5,3672
   28480:	00259780 	call	25978 <no_printf>
	                            break;
   28484:	00000506 	br	2849c <alt_tse_mac_group_init+0x4c4>
	                        default :
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "Unknown");
   28488:	010000f4 	movhi	r4,3
   2848c:	2103b504 	addi	r4,r4,3796
   28490:	014000f4 	movhi	r5,3
   28494:	2941ce04 	addi	r5,r5,1848
   28498:	00259780 	call	25978 <no_printf>
	                    }
	                    
	                    if(pmac_info->psys_info->tse_pcs_ena) {
   2849c:	e0bffe17 	ldw	r2,-8(fp)
   284a0:	10800217 	ldw	r2,8(r2)
   284a4:	108003c3 	ldbu	r2,15(r2)
   284a8:	10803fcc 	andi	r2,r2,255
   284ac:	10001c26 	beq	r2,zero,28520 <alt_tse_mac_group_init+0x548>
	                        tse_dprintf(6, "INFO    : PCS Enable               = %s\n", pmac_info->psys_info->tse_pcs_ena ? "Yes" : "No");
   284b0:	e0bffe17 	ldw	r2,-8(fp)
   284b4:	10800217 	ldw	r2,8(r2)
   284b8:	108003c3 	ldbu	r2,15(r2)
   284bc:	10803fcc 	andi	r2,r2,255
   284c0:	10000326 	beq	r2,zero,284d0 <alt_tse_mac_group_init+0x4f8>
   284c4:	008000f4 	movhi	r2,3
   284c8:	10839d04 	addi	r2,r2,3700
   284cc:	00000206 	br	284d8 <alt_tse_mac_group_init+0x500>
   284d0:	008000f4 	movhi	r2,3
   284d4:	10839e04 	addi	r2,r2,3704
   284d8:	010000f4 	movhi	r4,3
   284dc:	2103c004 	addi	r4,r4,3840
   284e0:	100b883a 	mov	r5,r2
   284e4:	00259780 	call	25978 <no_printf>
	                        tse_dprintf(6, "INFO    : PCS SGMII Enable         = %s\n", pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");	                        
   284e8:	e0bffe17 	ldw	r2,-8(fp)
   284ec:	10800217 	ldw	r2,8(r2)
   284f0:	10800403 	ldbu	r2,16(r2)
   284f4:	10803fcc 	andi	r2,r2,255
   284f8:	10000326 	beq	r2,zero,28508 <alt_tse_mac_group_init+0x530>
   284fc:	008000f4 	movhi	r2,3
   28500:	10839d04 	addi	r2,r2,3700
   28504:	00000206 	br	28510 <alt_tse_mac_group_init+0x538>
   28508:	008000f4 	movhi	r2,3
   2850c:	10839e04 	addi	r2,r2,3704
   28510:	010000f4 	movhi	r4,3
   28514:	2103cb04 	addi	r4,r4,3884
   28518:	100b883a 	mov	r5,r2
   2851c:	00259780 	call	25978 <no_printf>
	                    }
	                }
	                
                	if(pmac_info->psys_info->tse_multichannel_mac) {
   28520:	e0bffe17 	ldw	r2,-8(fp)
   28524:	10800217 	ldw	r2,8(r2)
   28528:	108002c3 	ldbu	r2,11(r2)
   2852c:	10803fcc 	andi	r2,r2,255
   28530:	10001326 	beq	r2,zero,28580 <alt_tse_mac_group_init+0x5a8>
                		tse_dprintf(6, "INFO    : Channel %2d Address       = 0x%08x\n", j, (int) pmac_info->psys_info->tse_mac_base);
   28534:	e0fffc47 	ldb	r3,-15(fp)
   28538:	e0bffe17 	ldw	r2,-8(fp)
   2853c:	10800217 	ldw	r2,8(r2)
   28540:	10800017 	ldw	r2,0(r2)
   28544:	010000f4 	movhi	r4,3
   28548:	2103d604 	addi	r4,r4,3928
   2854c:	180b883a 	mov	r5,r3
   28550:	100d883a 	mov	r6,r2
   28554:	00259780 	call	25978 <no_printf>
	                    tse_dprintf(6, "INFO    : Channel %2d Device        = tse_mac_device[%d]\n", j, i + j);
   28558:	e0fffc47 	ldb	r3,-15(fp)
   2855c:	e13ffc07 	ldb	r4,-16(fp)
   28560:	e0bffc47 	ldb	r2,-15(fp)
   28564:	2085883a 	add	r2,r4,r2
   28568:	010000f4 	movhi	r4,3
   2856c:	2103e204 	addi	r4,r4,3976
   28570:	180b883a 	mov	r5,r3
   28574:	100d883a 	mov	r6,r2
   28578:	00259780 	call	25978 <no_printf>
   2857c:	00000e06 	br	285b8 <alt_tse_mac_group_init+0x5e0>
	            	}                
	                else {
	                    tse_dprintf(6, "INFO    : MAC Address              = 0x%08x\n", (int) pmac_info->psys_info->tse_mac_base);
   28580:	e0bffe17 	ldw	r2,-8(fp)
   28584:	10800217 	ldw	r2,8(r2)
   28588:	10800017 	ldw	r2,0(r2)
   2858c:	010000f4 	movhi	r4,3
   28590:	2103f104 	addi	r4,r4,4036
   28594:	100b883a 	mov	r5,r2
   28598:	00259780 	call	25978 <no_printf>
	                    tse_dprintf(6, "INFO    : MAC Device               = tse_mac_device[%d]\n", i + j);
   2859c:	e0fffc07 	ldb	r3,-16(fp)
   285a0:	e0bffc47 	ldb	r2,-15(fp)
   285a4:	1885883a 	add	r2,r3,r2
   285a8:	010000f4 	movhi	r4,3
   285ac:	2103fd04 	addi	r4,r4,4084
   285b0:	100b883a 	mov	r5,r2
   285b4:	00259780 	call	25978 <no_printf>
	                }
                }
                
                /* store the pointer in MAC group variable for the detected channel */
                pmac_group->pmac_info[j] = pmac_info;
   285b8:	e0bffc47 	ldb	r2,-15(fp)
   285bc:	e0fffd17 	ldw	r3,-12(fp)
   285c0:	10800044 	addi	r2,r2,1
   285c4:	1085883a 	add	r2,r2,r2
   285c8:	1085883a 	add	r2,r2,r2
   285cc:	1885883a 	add	r2,r3,r2
   285d0:	e0fffe17 	ldw	r3,-8(fp)
   285d4:	10c00015 	stw	r3,0(r2)
                pmac_group->channel = 1;
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
                tse_dprintf(6, "INFO    : MDIO Shared              = No\n");
            }
            
            for(j = 0; j < pmac_group->channel; j++) {
   285d8:	e0bffc43 	ldbu	r2,-15(fp)
   285dc:	10800044 	addi	r2,r2,1
   285e0:	e0bffc45 	stb	r2,-15(fp)
   285e4:	e0fffc47 	ldb	r3,-15(fp)
   285e8:	e0bffd17 	ldw	r2,-12(fp)
   285ec:	10800003 	ldbu	r2,0(r2)
   285f0:	10803fcc 	andi	r2,r2,255
   285f4:	18bedb16 	blt	r3,r2,28164 <alt_tse_mac_group_init+0x18c>
                /* store the pointer in MAC group variable for the detected channel */
                pmac_group->pmac_info[j] = pmac_info;
            }
            
            /* store the pointer in global variable */
            pmac_groups[mac_group_count] = pmac_group;
   285f8:	d0a8f743 	ldbu	r2,-23587(gp)
   285fc:	10803fcc 	andi	r2,r2,255
   28600:	00c00134 	movhi	r3,4
   28604:	18d1b404 	addi	r3,r3,18128
   28608:	1085883a 	add	r2,r2,r2
   2860c:	1085883a 	add	r2,r2,r2
   28610:	1885883a 	add	r2,r3,r2
   28614:	e0fffd17 	ldw	r3,-12(fp)
   28618:	10c00015 	stw	r3,0(r2)
            
            mac_group_count++;
   2861c:	d0a8f743 	ldbu	r2,-23587(gp)
   28620:	10800044 	addi	r2,r2,1
   28624:	d0a8f745 	stb	r2,-23587(gp)

            /* skip for subsequent Multi-channel MAC */
            i += (pmac_group->channel - 1);
   28628:	e0bffd17 	ldw	r2,-12(fp)
   2862c:	10c00003 	ldbu	r3,0(r2)
   28630:	e0bffc03 	ldbu	r2,-16(fp)
   28634:	1885883a 	add	r2,r3,r2
   28638:	10bfffc4 	addi	r2,r2,-1
   2863c:	e0bffc05 	stb	r2,-16(fp)

    /* reset number of MAC group */
    mac_group_count = 0;
    
    /* loop through every alt_tse_system_info structure */
    for(i = 0; i < max_mac_system; i++) {
   28640:	e0bffc03 	ldbu	r2,-16(fp)
   28644:	10800044 	addi	r2,r2,1
   28648:	e0bffc05 	stb	r2,-16(fp)
   2864c:	e0fffc07 	ldb	r3,-16(fp)
   28650:	d0a01b03 	ldbu	r2,-32660(gp)
   28654:	10803fcc 	andi	r2,r2,255
   28658:	18be6916 	blt	r3,r2,28000 <alt_tse_mac_group_init+0x28>
            /* skip for subsequent Multi-channel MAC */
            i += (pmac_group->channel - 1);
                        
        }
    }
    return SUCCESS;
   2865c:	0005883a 	mov	r2,zero
}
   28660:	e037883a 	mov	sp,fp
   28664:	dfc00117 	ldw	ra,4(sp)
   28668:	df000017 	ldw	fp,0(sp)
   2866c:	dec00204 	addi	sp,sp,8
   28670:	f800283a 	ret

00028674 <alt_tse_mac_get_phy>:
/* @Function Description: Store information of all the PHYs connected to MAC to phy_list
 * @API Type:         Internal
 * @param pmac_group  Pointer to the TSE MAC grouping structure
 * @return            Number of PHY not in profile, return ALTERA_TSE_MALLOC_FAILED if memory allocation failed
 */
alt_32 alt_tse_mac_get_phy(alt_tse_mac_group *pmac_group) {
   28674:	deffed04 	addi	sp,sp,-76
   28678:	dfc01215 	stw	ra,72(sp)
   2867c:	df001115 	stw	fp,68(sp)
   28680:	df001104 	addi	fp,sp,68
   28684:	e13fff15 	stw	r4,-4(fp)
    
	alt_32 phyid; 
	alt_32 phyid2 = 0;
   28688:	e03ff515 	stw	zero,-44(fp)
    alt_u8 revision_number;

    alt_32 i;

    alt_u8 is_phy_in_profile;
    alt_32 return_value = 0;
   2868c:	e03ff315 	stw	zero,-52(fp)
    
    alt_8 phy_info_count = 0;
   28690:	e03ff405 	stb	zero,-48(fp)
    
    alt_tse_phy_info *pphy = 0;
   28694:	e03ff615 	stw	zero,-40(fp)
    alt_tse_mac_info *pmac_info = 0;
   28698:	e03ff715 	stw	zero,-36(fp)
    alt_tse_system_info *psys = 0;
   2869c:	e03ff815 	stw	zero,-32(fp)
    
    np_tse_mac *pmac_group_base = (np_tse_mac *) pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   286a0:	e0bfff17 	ldw	r2,-4(fp)
   286a4:	10800117 	ldw	r2,4(r2)
   286a8:	10800217 	ldw	r2,8(r2)
   286ac:	10800017 	ldw	r2,0(r2)
   286b0:	e0bff915 	stw	r2,-28(fp)
            
    /* Record previous MDIO address, to be restored at the end of function */
    alt_32 mdioadd_prev = IORD(&pmac_group_base->MDIO_ADDR1, 0);
   286b4:	e0bff917 	ldw	r2,-28(fp)
   286b8:	10801004 	addi	r2,r2,64
   286bc:	10800037 	ldwio	r2,0(r2)
   286c0:	e0bffa15 	stw	r2,-24(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
   286c4:	e13fff17 	ldw	r4,-4(fp)
   286c8:	0026aec0 	call	26aec <alt_tse_get_mac_group_index>
   286cc:	e0bffb05 	stb	r2,-20(fp)
    
    /* loop all valid PHY address to look for connected PHY */
    for (phyadd = 0x00; phyadd < 0x20; phyadd++)
   286d0:	e03ff005 	stb	zero,-64(fp)
   286d4:	0000ca06 	br	28a00 <alt_tse_mac_get_phy+0x38c>
    {        
        IOWR(&pmac_group_base->MDIO_ADDR1, 0, phyadd);
   286d8:	e0bff917 	ldw	r2,-28(fp)
   286dc:	10801004 	addi	r2,r2,64
   286e0:	e0fff003 	ldbu	r3,-64(fp)
   286e4:	10c00035 	stwio	r3,0(r2)
        phyid = IORD(&pmac_group_base->mdio1.PHY_ID1,0);     // read PHY ID
   286e8:	e0bff917 	ldw	r2,-28(fp)
   286ec:	1080a204 	addi	r2,r2,648
   286f0:	10800037 	ldwio	r2,0(r2)
   286f4:	e0bffc15 	stw	r2,-16(fp)
        phyid2 = IORD(&pmac_group_base->mdio1.PHY_ID2,0);     // read PHY ID
   286f8:	e0bff917 	ldw	r2,-28(fp)
   286fc:	1080a304 	addi	r2,r2,652
   28700:	10800037 	ldwio	r2,0(r2)
   28704:	e0bff515 	stw	r2,-44(fp)
        
        /* PHY found */
        if (phyid != phyid2)
   28708:	e0fffc17 	ldw	r3,-16(fp)
   2870c:	e0bff517 	ldw	r2,-44(fp)
   28710:	1880b826 	beq	r3,r2,289f4 <alt_tse_mac_get_phy+0x380>
        {
            pphy = (alt_tse_phy_info *) malloc(sizeof(alt_tse_phy_info));
   28714:	01000704 	movi	r4,28
   28718:	002cae80 	call	2cae8 <malloc>
   2871c:	e0bff615 	stw	r2,-40(fp)
            if(!pphy) {
   28720:	e0bff617 	ldw	r2,-40(fp)
   28724:	1000091e 	bne	r2,zero,2874c <alt_tse_mac_get_phy+0xd8>
                tse_dprintf(1, "ERROR   : Unable to allocate memory for phy_info[%d.%d]\n", mac_group_index, phy_info_count);
   28728:	e0fffb07 	ldb	r3,-20(fp)
   2872c:	e0bff407 	ldb	r2,-48(fp)
   28730:	010000f4 	movhi	r4,3
   28734:	21040c04 	addi	r4,r4,4144
   28738:	180b883a 	mov	r5,r3
   2873c:	100d883a 	mov	r6,r2
   28740:	00170680 	call	17068 <printf>
                return ALTERA_TSE_MALLOC_FAILED;
   28744:	00bfffc4 	movi	r2,-1
   28748:	0000cc06 	br	28a7c <alt_tse_mac_get_phy+0x408>
            }
            
            /* store PHY address */
            pphy->mdio_address = phyadd;
   2874c:	e0bff617 	ldw	r2,-40(fp)
   28750:	e0fff003 	ldbu	r3,-64(fp)
   28754:	10c00005 	stb	r3,0(r2)

            /* get oui, model number, and revision number from PHYID and PHYID2 */
            oui = (phyid << 6) | ((phyid2 >> 10) & 0x3f);
   28758:	e0bffc17 	ldw	r2,-16(fp)
   2875c:	100691ba 	slli	r3,r2,6
   28760:	e0bff517 	ldw	r2,-44(fp)
   28764:	1005d2ba 	srai	r2,r2,10
   28768:	10800fcc 	andi	r2,r2,63
   2876c:	1884b03a 	or	r2,r3,r2
   28770:	e0bffd15 	stw	r2,-12(fp)
            model_number = (phyid2 >> 4) & 0x3f;
   28774:	e0bff517 	ldw	r2,-44(fp)
   28778:	1005d13a 	srai	r2,r2,4
   2877c:	10800fcc 	andi	r2,r2,63
   28780:	e0bffe05 	stb	r2,-8(fp)
            revision_number = phyid2 & 0x0f;
   28784:	e0bff517 	ldw	r2,-44(fp)
   28788:	108003cc 	andi	r2,r2,15
   2878c:	e0bffe45 	stb	r2,-7(fp)
			
            /* map the PHY with PHY in profile */
            is_phy_in_profile = 0;
   28790:	e03ff205 	stb	zero,-56(fp)
            for(i = 0; i < phy_profile_count; i++) {
   28794:	e03ff115 	stw	zero,-60(fp)
   28798:	00003306 	br	28868 <alt_tse_mac_get_phy+0x1f4>
                
                /* if PHY match with PHY in profile */
                if((pphy_profiles[i]->oui == oui) && (pphy_profiles[i]->model_number == model_number))
   2879c:	00c00134 	movhi	r3,4
   287a0:	18d1bc04 	addi	r3,r3,18160
   287a4:	e0bff117 	ldw	r2,-60(fp)
   287a8:	1085883a 	add	r2,r2,r2
   287ac:	1085883a 	add	r2,r2,r2
   287b0:	1885883a 	add	r2,r3,r2
   287b4:	10800017 	ldw	r2,0(r2)
   287b8:	10c01417 	ldw	r3,80(r2)
   287bc:	e0bffd17 	ldw	r2,-12(fp)
   287c0:	1880261e 	bne	r3,r2,2885c <alt_tse_mac_get_phy+0x1e8>
   287c4:	00c00134 	movhi	r3,4
   287c8:	18d1bc04 	addi	r3,r3,18160
   287cc:	e0bff117 	ldw	r2,-60(fp)
   287d0:	1085883a 	add	r2,r2,r2
   287d4:	1085883a 	add	r2,r2,r2
   287d8:	1885883a 	add	r2,r3,r2
   287dc:	10800017 	ldw	r2,0(r2)
   287e0:	10801503 	ldbu	r2,84(r2)
   287e4:	10c03fcc 	andi	r3,r2,255
   287e8:	e0bffe03 	ldbu	r2,-8(fp)
   287ec:	18801b1e 	bne	r3,r2,2885c <alt_tse_mac_get_phy+0x1e8>
                {
                    pphy->pphy_profile = pphy_profiles[i];
   287f0:	00c00134 	movhi	r3,4
   287f4:	18d1bc04 	addi	r3,r3,18160
   287f8:	e0bff117 	ldw	r2,-60(fp)
   287fc:	1085883a 	add	r2,r2,r2
   28800:	1085883a 	add	r2,r2,r2
   28804:	1885883a 	add	r2,r3,r2
   28808:	10c00017 	ldw	r3,0(r2)
   2880c:	e0bff617 	ldw	r2,-40(fp)
   28810:	10c00515 	stw	r3,20(r2)
                    
                    /* PHY found, add it to phy_list */
                    tse_dprintf(5, "INFO    : PHY %s found at PHY address 0x%02x of MAC Group[%d]\n", pphy_profiles[i]->name, phyadd, mac_group_index);
   28814:	00c00134 	movhi	r3,4
   28818:	18d1bc04 	addi	r3,r3,18160
   2881c:	e0bff117 	ldw	r2,-60(fp)
   28820:	1085883a 	add	r2,r2,r2
   28824:	1085883a 	add	r2,r2,r2
   28828:	1885883a 	add	r2,r3,r2
   2882c:	10800017 	ldw	r2,0(r2)
   28830:	100b883a 	mov	r5,r2
   28834:	e0fff003 	ldbu	r3,-64(fp)
   28838:	e0bffb07 	ldb	r2,-20(fp)
   2883c:	010000f4 	movhi	r4,3
   28840:	21041b04 	addi	r4,r4,4204
   28844:	180d883a 	mov	r6,r3
   28848:	100f883a 	mov	r7,r2
   2884c:	00170680 	call	17068 <printf>
                    is_phy_in_profile = 1;
   28850:	00800044 	movi	r2,1
   28854:	e0bff205 	stb	r2,-56(fp)
                    break;
   28858:	00000706 	br	28878 <alt_tse_mac_get_phy+0x204>
            model_number = (phyid2 >> 4) & 0x3f;
            revision_number = phyid2 & 0x0f;
			
            /* map the PHY with PHY in profile */
            is_phy_in_profile = 0;
            for(i = 0; i < phy_profile_count; i++) {
   2885c:	e0bff117 	ldw	r2,-60(fp)
   28860:	10800044 	addi	r2,r2,1
   28864:	e0bff115 	stw	r2,-60(fp)
   28868:	d0a8f703 	ldbu	r2,-23588(gp)
   2886c:	10803fcc 	andi	r2,r2,255
   28870:	e0fff117 	ldw	r3,-60(fp)
   28874:	18bfc916 	blt	r3,r2,2879c <alt_tse_mac_get_phy+0x128>
                    is_phy_in_profile = 1;
                    break;
                }
            }
            /* PHY not found in PHY profile */
            if(is_phy_in_profile == 0) {
   28878:	e0bff203 	ldbu	r2,-56(fp)
   2887c:	10000f1e 	bne	r2,zero,288bc <alt_tse_mac_get_phy+0x248>
                pphy->pphy_profile = 0;
   28880:	e0bff617 	ldw	r2,-40(fp)
   28884:	10000515 	stw	zero,20(r2)
                tse_dprintf(3, "WARNING : Unknown PHY found at PHY address 0x%02x of MAC Group[%d]\n", phyadd, mac_group_index);
   28888:	e0fff003 	ldbu	r3,-64(fp)
   2888c:	e0bffb07 	ldb	r2,-20(fp)
   28890:	010000f4 	movhi	r4,3
   28894:	21042b04 	addi	r4,r4,4268
   28898:	180b883a 	mov	r5,r3
   2889c:	100d883a 	mov	r6,r2
   288a0:	00170680 	call	17068 <printf>
                tse_dprintf(3, "WARNING : Please add PHY information to PHY profile\n");
   288a4:	010000f4 	movhi	r4,3
   288a8:	21043c04 	addi	r4,r4,4336
   288ac:	00172f80 	call	172f8 <puts>
                return_value++;
   288b0:	e0bff317 	ldw	r2,-52(fp)
   288b4:	10800044 	addi	r2,r2,1
   288b8:	e0bff315 	stw	r2,-52(fp)
            }
            
            tse_dprintf(6, "INFO    : PHY OUI             =  0x%06x\n", (int) oui);
   288bc:	e0bffd17 	ldw	r2,-12(fp)
   288c0:	010000f4 	movhi	r4,3
   288c4:	21044904 	addi	r4,r4,4388
   288c8:	100b883a 	mov	r5,r2
   288cc:	00259780 	call	25978 <no_printf>
            tse_dprintf(6, "INFO    : PHY Model Number    =  0x%02x\n", model_number);
   288d0:	e0bffe03 	ldbu	r2,-8(fp)
   288d4:	010000f4 	movhi	r4,3
   288d8:	21045404 	addi	r4,r4,4432
   288dc:	100b883a 	mov	r5,r2
   288e0:	00259780 	call	25978 <no_printf>
            tse_dprintf(6, "INFO    : PHY Revision Number =  0x%01x\n", revision_number);
   288e4:	e0bffe43 	ldbu	r2,-7(fp)
   288e8:	010000f4 	movhi	r4,3
   288ec:	21045f04 	addi	r4,r4,4476
   288f0:	100b883a 	mov	r5,r2
   288f4:	00259780 	call	25978 <no_printf>
            
            /* map the detected PHY to connected MAC */
            if(alt_tse_mac_associate_phy(pmac_group, pphy) == TSE_PHY_MAP_SUCCESS) {
   288f8:	e13fff17 	ldw	r4,-4(fp)
   288fc:	e17ff617 	ldw	r5,-40(fp)
   28900:	0028a900 	call	28a90 <alt_tse_mac_associate_phy>
   28904:	1000351e 	bne	r2,zero,289dc <alt_tse_mac_get_phy+0x368>
            	
            	pmac_info = pphy->pmac_info;
   28908:	e0bff617 	ldw	r2,-40(fp)
   2890c:	10800617 	ldw	r2,24(r2)
   28910:	e0bff715 	stw	r2,-36(fp)
            	psys = pmac_info->psys_info;
   28914:	e0bff717 	ldw	r2,-36(fp)
   28918:	10800217 	ldw	r2,8(r2)
   2891c:	e0bff815 	stw	r2,-32(fp)
            	
            	/* Disable PHY loopback to allow Auto-Negotiation completed */
    	        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 0);   // disable PHY loopback
   28920:	d8000015 	stw	zero,0(sp)
   28924:	e13ff617 	ldw	r4,-40(fp)
   28928:	000b883a 	mov	r5,zero
   2892c:	01800384 	movi	r6,14
   28930:	01c00044 	movi	r7,1
   28934:	00279380 	call	27938 <alt_tse_phy_wr_mdio_reg>
				
				/* Reset auto-negotiation advertisement */
				alt_tse_phy_set_adv_1000(pphy, 1);
   28938:	e13ff617 	ldw	r4,-40(fp)
   2893c:	01400044 	movi	r5,1
   28940:	00297cc0 	call	297cc <alt_tse_phy_set_adv_1000>
				alt_tse_phy_set_adv_100(pphy, 1);
   28944:	e13ff617 	ldw	r4,-40(fp)
   28948:	01400044 	movi	r5,1
   2894c:	00299880 	call	29988 <alt_tse_phy_set_adv_100>
				alt_tse_phy_set_adv_10(pphy, 1);
   28950:	e13ff617 	ldw	r4,-40(fp)
   28954:	01400044 	movi	r5,1
   28958:	0029bd00 	call	29bd0 <alt_tse_phy_set_adv_10>
            	            	
	            /* check link connection for this PHY */
	            alt_tse_phy_restart_an(pphy, ALTERA_CHECKLINK_TIMEOUT_THRESHOLD);
   2895c:	e13ff617 	ldw	r4,-40(fp)
   28960:	014003f4 	movhi	r5,15
   28964:	29509004 	addi	r5,r5,16960
   28968:	0028f100 	call	28f10 <alt_tse_phy_restart_an>
	            
	            /* Perform additional setting if there is any */
	            /* Profile specific */
	            if(pphy->pphy_profile) {
   2896c:	e0bff617 	ldw	r2,-40(fp)
   28970:	10800517 	ldw	r2,20(r2)
   28974:	10000f26 	beq	r2,zero,289b4 <alt_tse_mac_get_phy+0x340>
		            if(pphy->pphy_profile->phy_cfg) {
   28978:	e0bff617 	ldw	r2,-40(fp)
   2897c:	10800517 	ldw	r2,20(r2)
   28980:	10801717 	ldw	r2,92(r2)
   28984:	10000b26 	beq	r2,zero,289b4 <alt_tse_mac_get_phy+0x340>
		                tse_dprintf(6, "INFO    : Applying additional PHY configuration of %s\n", pphy->pphy_profile->name);
   28988:	e0bff617 	ldw	r2,-40(fp)
   2898c:	10800517 	ldw	r2,20(r2)
   28990:	010000f4 	movhi	r4,3
   28994:	21046a04 	addi	r4,r4,4520
   28998:	100b883a 	mov	r5,r2
   2899c:	00259780 	call	25978 <no_printf>
		                pphy->pphy_profile->phy_cfg(pmac_group_base);
   289a0:	e0bff617 	ldw	r2,-40(fp)
   289a4:	10800517 	ldw	r2,20(r2)
   289a8:	10801717 	ldw	r2,92(r2)
   289ac:	e13ff917 	ldw	r4,-28(fp)
   289b0:	103ee83a 	callr	r2
		            }
	            }
	            
	            /* Initialize PHY, call user's function pointer in alt_tse_system_info structure */
	            /* Individual PHY specific */
            	if(psys->tse_phy_cfg) {
   289b4:	e0bff817 	ldw	r2,-32(fp)
   289b8:	10801117 	ldw	r2,68(r2)
   289bc:	10000726 	beq	r2,zero,289dc <alt_tse_mac_get_phy+0x368>
            		tse_dprintf(6, "INFO    : Applying additional user PHY configuration\n");
   289c0:	010000f4 	movhi	r4,3
   289c4:	21047804 	addi	r4,r4,4576
   289c8:	00259780 	call	25978 <no_printf>
            		psys->tse_phy_cfg(pmac_group_base);
   289cc:	e0bff817 	ldw	r2,-32(fp)
   289d0:	10801117 	ldw	r2,68(r2)
   289d4:	e13ff917 	ldw	r4,-28(fp)
   289d8:	103ee83a 	callr	r2
            	}
            }
            
            tse_dprintf(6, "\n");
   289dc:	010000f4 	movhi	r4,3
   289e0:	21048604 	addi	r4,r4,4632
   289e4:	00259780 	call	25978 <no_printf>
	            
            phy_info_count++;
   289e8:	e0bff403 	ldbu	r2,-48(fp)
   289ec:	10800044 	addi	r2,r2,1
   289f0:	e0bff405 	stb	r2,-48(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    
    /* loop all valid PHY address to look for connected PHY */
    for (phyadd = 0x00; phyadd < 0x20; phyadd++)
   289f4:	e0bff003 	ldbu	r2,-64(fp)
   289f8:	10800044 	addi	r2,r2,1
   289fc:	e0bff005 	stb	r2,-64(fp)
   28a00:	e0bff003 	ldbu	r2,-64(fp)
   28a04:	10800830 	cmpltui	r2,r2,32
   28a08:	103f331e 	bne	r2,zero,286d8 <alt_tse_mac_get_phy+0x64>
            phy_info_count++;
        }
    }
    
    /* check to verify the number of connected PHY match the number of channel */
    if(pmac_group->channel != phy_info_count) {
   28a0c:	e0bfff17 	ldw	r2,-4(fp)
   28a10:	10800003 	ldbu	r2,0(r2)
   28a14:	10c03fcc 	andi	r3,r2,255
   28a18:	e0bff407 	ldb	r2,-48(fp)
   28a1c:	18801226 	beq	r3,r2,28a68 <alt_tse_mac_get_phy+0x3f4>
        if(phy_info_count == 0) {
   28a20:	e0bff407 	ldb	r2,-48(fp)
   28a24:	1000061e 	bne	r2,zero,28a40 <alt_tse_mac_get_phy+0x3cc>
            tse_dprintf(2, "ERROR   : MAC Group[%d] - No PHY connected!\n", mac_group_index);
   28a28:	e0bffb07 	ldb	r2,-20(fp)
   28a2c:	010000f4 	movhi	r4,3
   28a30:	21048704 	addi	r4,r4,4636
   28a34:	100b883a 	mov	r5,r2
   28a38:	00170680 	call	17068 <printf>
   28a3c:	00000a06 	br	28a68 <alt_tse_mac_get_phy+0x3f4>
        }
        else {
            tse_dprintf(3, "WARNING : MAC Group[%d] - Number of PHY connected is not equal to the number of channel, Number of PHY : %d, Channel : %d\n", mac_group_index, phy_info_count, pmac_group->channel);
   28a40:	e17ffb07 	ldb	r5,-20(fp)
   28a44:	e0fff407 	ldb	r3,-48(fp)
   28a48:	e0bfff17 	ldw	r2,-4(fp)
   28a4c:	10800003 	ldbu	r2,0(r2)
   28a50:	10803fcc 	andi	r2,r2,255
   28a54:	010000f4 	movhi	r4,3
   28a58:	21049304 	addi	r4,r4,4684
   28a5c:	180d883a 	mov	r6,r3
   28a60:	100f883a 	mov	r7,r2
   28a64:	00170680 	call	17068 <printf>
        }
    }
    
    /* Restore previous MDIO address */
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
   28a68:	e0bff917 	ldw	r2,-28(fp)
   28a6c:	10801004 	addi	r2,r2,64
   28a70:	e0fffa17 	ldw	r3,-24(fp)
   28a74:	10c00035 	stwio	r3,0(r2)
    
    return return_value;
   28a78:	e0bff317 	ldw	r2,-52(fp)
}
   28a7c:	e037883a 	mov	sp,fp
   28a80:	dfc00117 	ldw	ra,4(sp)
   28a84:	df000017 	ldw	fp,0(sp)
   28a88:	dec00204 	addi	sp,sp,8
   28a8c:	f800283a 	ret

00028a90 <alt_tse_mac_associate_phy>:
 * @param pmac_group  Pointer to the TSE MAC grouping structure
 * @param pphy        Pointer to the TSE PHY info structure which hold information of PHY
 * @return            return TSE_PHY_MAP_ERROR if mapping error
 *                    return TSE_PHY_MAP_SUCCESS otherwise
 */
alt_32 alt_tse_mac_associate_phy(alt_tse_mac_group *pmac_group, alt_tse_phy_info *pphy) {
   28a90:	defff604 	addi	sp,sp,-40
   28a94:	dfc00915 	stw	ra,36(sp)
   28a98:	df000815 	stw	fp,32(sp)
   28a9c:	df000804 	addi	fp,sp,32
   28aa0:	e13ffe15 	stw	r4,-8(fp)
   28aa4:	e17fff15 	stw	r5,-4(fp)
    
	alt_32 i;
	alt_32 return_value = TSE_PHY_MAP_SUCCESS;
   28aa8:	e03ff915 	stw	zero,-28(fp)
    
	alt_u8 is_mapped;

    alt_tse_system_info *psys = 0;
   28aac:	e03ffb15 	stw	zero,-20(fp)
    alt_tse_mac_info *pmac_info = 0;
   28ab0:	e03ffc15 	stw	zero,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
   28ab4:	e03ffd05 	stb	zero,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
   28ab8:	e13ffe17 	ldw	r4,-8(fp)
   28abc:	0026aec0 	call	26aec <alt_tse_get_mac_group_index>
   28ac0:	e0bffd45 	stb	r2,-11(fp)
    alt_8 sys_info_index = 0;
   28ac4:	e03ffd85 	stb	zero,-10(fp)
    
    is_mapped = 0;
   28ac8:	e03ffa05 	stb	zero,-24(fp)
    
    for(i = 0; i < pmac_group->channel; i++) {
   28acc:	e03ff815 	stw	zero,-32(fp)
   28ad0:	00002b06 	br	28b80 <alt_tse_mac_associate_phy+0xf0>
        pmac_info = pmac_group->pmac_info[i];
   28ad4:	e0fffe17 	ldw	r3,-8(fp)
   28ad8:	e0bff817 	ldw	r2,-32(fp)
   28adc:	10800044 	addi	r2,r2,1
   28ae0:	1085883a 	add	r2,r2,r2
   28ae4:	1085883a 	add	r2,r2,r2
   28ae8:	1885883a 	add	r2,r3,r2
   28aec:	10800017 	ldw	r2,0(r2)
   28af0:	e0bffc15 	stw	r2,-16(fp)
        psys = pmac_info->psys_info;
   28af4:	e0bffc17 	ldw	r2,-16(fp)
   28af8:	10800217 	ldw	r2,8(r2)
   28afc:	e0bffb15 	stw	r2,-20(fp)
       
        /* map according to the PHY address in alt_tse_system_info.h */
        if(psys->tse_phy_mdio_address == pphy->mdio_address) {
   28b00:	e0bffb17 	ldw	r2,-20(fp)
   28b04:	10c01017 	ldw	r3,64(r2)
   28b08:	e0bfff17 	ldw	r2,-4(fp)
   28b0c:	10800003 	ldbu	r2,0(r2)
   28b10:	10803fcc 	andi	r2,r2,255
   28b14:	1880171e 	bne	r3,r2,28b74 <alt_tse_mac_associate_phy+0xe4>
        	mac_info_index = alt_tse_get_mac_info_index(pmac_info);
   28b18:	e13ffc17 	ldw	r4,-16(fp)
   28b1c:	0026b600 	call	26b60 <alt_tse_get_mac_info_index>
   28b20:	e0bffd05 	stb	r2,-12(fp)
	        sys_info_index = alt_tse_get_system_index(psys);
   28b24:	e13ffb17 	ldw	r4,-20(fp)
   28b28:	0026a800 	call	26a80 <alt_tse_get_system_index>
   28b2c:	e0bffd85 	stb	r2,-10(fp)
	        
            pmac_info->pphy_info = pphy;
   28b30:	e0bffc17 	ldw	r2,-16(fp)
   28b34:	e0ffff17 	ldw	r3,-4(fp)
   28b38:	10c00115 	stw	r3,4(r2)
            pphy->pmac_info = pmac_info;
   28b3c:	e0bfff17 	ldw	r2,-4(fp)
   28b40:	e0fffc17 	ldw	r3,-16(fp)
   28b44:	10c00615 	stw	r3,24(r2)
            tse_dprintf(5, "INFO    : PHY[%d.%d] - Explicitly mapped to tse_mac_device[%d]\n", mac_group_index, mac_info_index, sys_info_index);
   28b48:	e17ffd47 	ldb	r5,-11(fp)
   28b4c:	e0fffd07 	ldb	r3,-12(fp)
   28b50:	e0bffd87 	ldb	r2,-10(fp)
   28b54:	010000f4 	movhi	r4,3
   28b58:	2104b204 	addi	r4,r4,4808
   28b5c:	180d883a 	mov	r6,r3
   28b60:	100f883a 	mov	r7,r2
   28b64:	00170680 	call	17068 <printf>
            is_mapped = 1;
   28b68:	00800044 	movi	r2,1
   28b6c:	e0bffa05 	stb	r2,-24(fp)
            break;
   28b70:	00000806 	br	28b94 <alt_tse_mac_associate_phy+0x104>
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    alt_8 sys_info_index = 0;
    
    is_mapped = 0;
    
    for(i = 0; i < pmac_group->channel; i++) {
   28b74:	e0bff817 	ldw	r2,-32(fp)
   28b78:	10800044 	addi	r2,r2,1
   28b7c:	e0bff815 	stw	r2,-32(fp)
   28b80:	e0bffe17 	ldw	r2,-8(fp)
   28b84:	10800003 	ldbu	r2,0(r2)
   28b88:	10803fcc 	andi	r2,r2,255
   28b8c:	e0fff817 	ldw	r3,-32(fp)
   28b90:	18bfd016 	blt	r3,r2,28ad4 <alt_tse_mac_associate_phy+0x44>
            break;
        }
    }
    
    /* if not yet map, it will automatically mapped to the first TSE device encountered with tse_phy_mdio_address = TSE_PHY_AUTO_ADDRESS */
    if(is_mapped == 0) {
   28b94:	e0bffa03 	ldbu	r2,-24(fp)
   28b98:	10003c1e 	bne	r2,zero,28c8c <alt_tse_mac_associate_phy+0x1fc>
        for(i = 0; i < pmac_group->channel; i++) {
   28b9c:	e03ff815 	stw	zero,-32(fp)
   28ba0:	00003506 	br	28c78 <alt_tse_mac_associate_phy+0x1e8>
            pmac_info = pmac_group->pmac_info[i];
   28ba4:	e0fffe17 	ldw	r3,-8(fp)
   28ba8:	e0bff817 	ldw	r2,-32(fp)
   28bac:	10800044 	addi	r2,r2,1
   28bb0:	1085883a 	add	r2,r2,r2
   28bb4:	1085883a 	add	r2,r2,r2
   28bb8:	1885883a 	add	r2,r3,r2
   28bbc:	10800017 	ldw	r2,0(r2)
   28bc0:	e0bffc15 	stw	r2,-16(fp)
            psys = pmac_info->psys_info;
   28bc4:	e0bffc17 	ldw	r2,-16(fp)
   28bc8:	10800217 	ldw	r2,8(r2)
   28bcc:	e0bffb15 	stw	r2,-20(fp)
            
            /* alt_tse_system_info structure definition error */
            if((psys->tse_sgdma_tx == 0) || (psys->tse_sgdma_rx == 0)){
   28bd0:	e0bffb17 	ldw	r2,-20(fp)
   28bd4:	10800517 	ldw	r2,20(r2)
   28bd8:	10002326 	beq	r2,zero,28c68 <alt_tse_mac_associate_phy+0x1d8>
   28bdc:	e0bffb17 	ldw	r2,-20(fp)
   28be0:	10800617 	ldw	r2,24(r2)
   28be4:	10002026 	beq	r2,zero,28c68 <alt_tse_mac_associate_phy+0x1d8>
            	continue;
            }
            
            if(psys->tse_phy_mdio_address == TSE_PHY_AUTO_ADDRESS) {
   28be8:	e0bffb17 	ldw	r2,-20(fp)
   28bec:	10801017 	ldw	r2,64(r2)
   28bf0:	10bfffd8 	cmpnei	r2,r2,-1
   28bf4:	10001d1e 	bne	r2,zero,28c6c <alt_tse_mac_associate_phy+0x1dc>
                mac_info_index = alt_tse_get_mac_info_index(pmac_info);
   28bf8:	e13ffc17 	ldw	r4,-16(fp)
   28bfc:	0026b600 	call	26b60 <alt_tse_get_mac_info_index>
   28c00:	e0bffd05 	stb	r2,-12(fp)
                sys_info_index = alt_tse_get_system_index(psys);
   28c04:	e13ffb17 	ldw	r4,-20(fp)
   28c08:	0026a800 	call	26a80 <alt_tse_get_system_index>
   28c0c:	e0bffd85 	stb	r2,-10(fp)
                
                pmac_info->pphy_info = pphy;
   28c10:	e0bffc17 	ldw	r2,-16(fp)
   28c14:	e0ffff17 	ldw	r3,-4(fp)
   28c18:	10c00115 	stw	r3,4(r2)
                pphy->pmac_info = pmac_info;
   28c1c:	e0bfff17 	ldw	r2,-4(fp)
   28c20:	e0fffc17 	ldw	r3,-16(fp)
   28c24:	10c00615 	stw	r3,24(r2)
                psys->tse_phy_mdio_address = pphy->mdio_address;
   28c28:	e0bfff17 	ldw	r2,-4(fp)
   28c2c:	10800003 	ldbu	r2,0(r2)
   28c30:	10c03fcc 	andi	r3,r2,255
   28c34:	e0bffb17 	ldw	r2,-20(fp)
   28c38:	10c01015 	stw	r3,64(r2)
                tse_dprintf(5, "INFO    : PHY[%d.%d] - Automatically mapped to tse_mac_device[%d]\n", mac_group_index, mac_info_index, sys_info_index);
   28c3c:	e17ffd47 	ldb	r5,-11(fp)
   28c40:	e0fffd07 	ldb	r3,-12(fp)
   28c44:	e0bffd87 	ldb	r2,-10(fp)
   28c48:	010000f4 	movhi	r4,3
   28c4c:	2104c204 	addi	r4,r4,4872
   28c50:	180d883a 	mov	r6,r3
   28c54:	100f883a 	mov	r7,r2
   28c58:	00170680 	call	17068 <printf>
                is_mapped = 1;
   28c5c:	00800044 	movi	r2,1
   28c60:	e0bffa05 	stb	r2,-24(fp)
                break;
   28c64:	00000906 	br	28c8c <alt_tse_mac_associate_phy+0x1fc>
            pmac_info = pmac_group->pmac_info[i];
            psys = pmac_info->psys_info;
            
            /* alt_tse_system_info structure definition error */
            if((psys->tse_sgdma_tx == 0) || (psys->tse_sgdma_rx == 0)){
            	continue;
   28c68:	0001883a 	nop
        }
    }
    
    /* if not yet map, it will automatically mapped to the first TSE device encountered with tse_phy_mdio_address = TSE_PHY_AUTO_ADDRESS */
    if(is_mapped == 0) {
        for(i = 0; i < pmac_group->channel; i++) {
   28c6c:	e0bff817 	ldw	r2,-32(fp)
   28c70:	10800044 	addi	r2,r2,1
   28c74:	e0bff815 	stw	r2,-32(fp)
   28c78:	e0bffe17 	ldw	r2,-8(fp)
   28c7c:	10800003 	ldbu	r2,0(r2)
   28c80:	10803fcc 	andi	r2,r2,255
   28c84:	e0fff817 	ldw	r3,-32(fp)
   28c88:	18bfc616 	blt	r3,r2,28ba4 <alt_tse_mac_associate_phy+0x114>
            }
        }
    }
    
    /* Still cannot find any matched MAC-PHY */
    if(is_mapped == 0) {
   28c8c:	e0bffa03 	ldbu	r2,-24(fp)
   28c90:	1000091e 	bne	r2,zero,28cb8 <alt_tse_mac_associate_phy+0x228>
    	pphy->pmac_info = 0;
   28c94:	e0bfff17 	ldw	r2,-4(fp)
   28c98:	10000615 	stw	zero,24(r2)
        tse_dprintf(2, "WARNING : PHY[%d.X] - Mapping of PHY to MAC failed! Make sure the PHY address is defined correctly in tse_mac_device[] structure, and number of PHYs connected is equivalent to number of channel\n", mac_group_index);
   28c9c:	e0bffd47 	ldb	r2,-11(fp)
   28ca0:	010000f4 	movhi	r4,3
   28ca4:	2104d304 	addi	r4,r4,4940
   28ca8:	100b883a 	mov	r5,r2
   28cac:	00170680 	call	17068 <printf>
        return_value = TSE_PHY_MAP_ERROR;
   28cb0:	00bfffc4 	movi	r2,-1
   28cb4:	e0bff915 	stw	r2,-28(fp)
    }
    
    return return_value;
   28cb8:	e0bff917 	ldw	r2,-28(fp)
}
   28cbc:	e037883a 	mov	sp,fp
   28cc0:	dfc00117 	ldw	ra,4(sp)
   28cc4:	df000017 	ldw	fp,0(sp)
   28cc8:	dec00204 	addi	sp,sp,8
   28ccc:	f800283a 	ret

00028cd0 <alt_tse_phy_cfg_pcs>:
/* @Function Description: Configure operating mode of Altera PCS if available
 * @API Type:           Internal
 * @param pmac_info     pointer to MAC info variable
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_cfg_pcs(alt_tse_mac_info *pmac_info) {
   28cd0:	defff804 	addi	sp,sp,-32
   28cd4:	dfc00715 	stw	ra,28(sp)
   28cd8:	df000615 	stw	fp,24(sp)
   28cdc:	df000604 	addi	fp,sp,24
   28ce0:	e13fff15 	stw	r4,-4(fp)
    
    alt_tse_system_info *psys = pmac_info->psys_info;
   28ce4:	e0bfff17 	ldw	r2,-4(fp)
   28ce8:	10800217 	ldw	r2,8(r2)
   28cec:	e0bffa15 	stw	r2,-24(fp)
    np_tse_mac *pmac = (np_tse_mac *) psys->tse_mac_base;
   28cf0:	e0bffa17 	ldw	r2,-24(fp)
   28cf4:	10800017 	ldw	r2,0(r2)
   28cf8:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
   28cfc:	e0bfff17 	ldw	r2,-4(fp)
   28d00:	10800317 	ldw	r2,12(r2)
   28d04:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
   28d08:	e13fff17 	ldw	r4,-4(fp)
   28d0c:	0026b600 	call	26b60 <alt_tse_get_mac_info_index>
   28d10:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
   28d14:	e13ffc17 	ldw	r4,-16(fp)
   28d18:	0026aec0 	call	26aec <alt_tse_get_mac_group_index>
   28d1c:	e0bffd45 	stb	r2,-11(fp)

    if(psys->tse_pcs_ena) {
   28d20:	e0bffa17 	ldw	r2,-24(fp)
   28d24:	108003c3 	ldbu	r2,15(r2)
   28d28:	10803fcc 	andi	r2,r2,255
   28d2c:	10002c26 	beq	r2,zero,28de0 <alt_tse_phy_cfg_pcs+0x110>
        tse_dprintf(5, "INFO    : PCS[%d.%d] - Configuring PCS operating mode\n", mac_group_index, mac_info_index);
   28d30:	e0fffd47 	ldb	r3,-11(fp)
   28d34:	e0bffd07 	ldb	r2,-12(fp)
   28d38:	010000f4 	movhi	r4,3
   28d3c:	21050404 	addi	r4,r4,5136
   28d40:	180b883a 	mov	r5,r3
   28d44:	100d883a 	mov	r6,r2
   28d48:	00170680 	call	17068 <printf>
        
        alt_32 data = IORD(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE); 
   28d4c:	e0bffb17 	ldw	r2,-20(fp)
   28d50:	10808004 	addi	r2,r2,512
   28d54:	10801404 	addi	r2,r2,80
   28d58:	10800037 	ldwio	r2,0(r2)
   28d5c:	e0bffe15 	stw	r2,-8(fp)
        
        if(psys->tse_pcs_sgmii) {
   28d60:	e0bffa17 	ldw	r2,-24(fp)
   28d64:	10800403 	ldbu	r2,16(r2)
   28d68:	10803fcc 	andi	r2,r2,255
   28d6c:	10000e26 	beq	r2,zero,28da8 <alt_tse_phy_cfg_pcs+0xd8>
            tse_dprintf(5, "INFO    : PCS[%d.%d] - PCS SGMII mode enabled\n", mac_group_index, mac_info_index);
   28d70:	e0fffd47 	ldb	r3,-11(fp)
   28d74:	e0bffd07 	ldb	r2,-12(fp)
   28d78:	010000f4 	movhi	r4,3
   28d7c:	21051204 	addi	r4,r4,5192
   28d80:	180b883a 	mov	r5,r3
   28d84:	100d883a 	mov	r6,r2
   28d88:	00170680 	call	17068 <printf>
            IOWR(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE, data | 0x03);
   28d8c:	e0bffb17 	ldw	r2,-20(fp)
   28d90:	10808004 	addi	r2,r2,512
   28d94:	10801404 	addi	r2,r2,80
   28d98:	e0fffe17 	ldw	r3,-8(fp)
   28d9c:	18c000d4 	ori	r3,r3,3
   28da0:	10c00035 	stwio	r3,0(r2)
   28da4:	00000e06 	br	28de0 <alt_tse_phy_cfg_pcs+0x110>
            }
        else {
            tse_dprintf(5, "INFO    : PCS[%d.%d] - PCS SGMII mode disabled\n", mac_group_index, mac_info_index);
   28da8:	e0fffd47 	ldb	r3,-11(fp)
   28dac:	e0bffd07 	ldb	r2,-12(fp)
   28db0:	010000f4 	movhi	r4,3
   28db4:	21051e04 	addi	r4,r4,5240
   28db8:	180b883a 	mov	r5,r3
   28dbc:	100d883a 	mov	r6,r2
   28dc0:	00170680 	call	17068 <printf>
            IOWR(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE, data & ~0x03);
   28dc4:	e0bffb17 	ldw	r2,-20(fp)
   28dc8:	10808004 	addi	r2,r2,512
   28dcc:	10801404 	addi	r2,r2,80
   28dd0:	e13ffe17 	ldw	r4,-8(fp)
   28dd4:	00ffff04 	movi	r3,-4
   28dd8:	20c6703a 	and	r3,r4,r3
   28ddc:	10c00035 	stwio	r3,0(r2)
        }
    }
    
    return SUCCESS;
   28de0:	0005883a 	mov	r2,zero
}
   28de4:	e037883a 	mov	sp,fp
   28de8:	dfc00117 	ldw	ra,4(sp)
   28dec:	df000017 	ldw	fp,0(sp)
   28df0:	dec00204 	addi	sp,sp,8
   28df4:	f800283a 	ret

00028df8 <alt_tse_phy_init>:
/* @Function Description: Detect and initialize all the PHYs connected
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      SUCCESS
 */
alt_32 alt_tse_phy_init() {
   28df8:	defffb04 	addi	sp,sp,-20
   28dfc:	dfc00415 	stw	ra,16(sp)
   28e00:	df000315 	stw	fp,12(sp)
   28e04:	df000304 	addi	fp,sp,12
	alt_8 i = 0;
   28e08:	e03ffd05 	stb	zero,-12(fp)
	alt_8 j = 0;
   28e0c:	e03ffd45 	stb	zero,-11(fp)
    
    alt_tse_mac_group *pmac_group = 0;
   28e10:	e03ffe15 	stw	zero,-8(fp)
    alt_tse_mac_info *pmac_info = 0;
   28e14:	e03fff15 	stw	zero,-4(fp)
    
    /* add supported PHYs */
    alt_tse_phy_add_profile_default();
   28e18:	0027b300 	call	27b30 <alt_tse_phy_add_profile_default>
    
    /* display PHY in profile */
    alt_tse_phy_print_profile();
   28e1c:	0027dc80 	call	27dc8 <alt_tse_phy_print_profile>
    
    alt_tse_mac_group_init();
   28e20:	0027fd80 	call	27fd8 <alt_tse_mac_group_init>
        
    /* initialize for each TSE MAC */
    /* run once only for multi-channel MAC */
    for(i = 0; i < mac_group_count; i++) {
   28e24:	e03ffd05 	stb	zero,-12(fp)
   28e28:	00002f06 	br	28ee8 <alt_tse_phy_init+0xf0>
        pmac_group = pmac_groups[i];
   28e2c:	e0bffd07 	ldb	r2,-12(fp)
   28e30:	00c00134 	movhi	r3,4
   28e34:	18d1b404 	addi	r3,r3,18128
   28e38:	1085883a 	add	r2,r2,r2
   28e3c:	1085883a 	add	r2,r2,r2
   28e40:	1885883a 	add	r2,r3,r2
   28e44:	10800017 	ldw	r2,0(r2)
   28e48:	e0bffe15 	stw	r2,-8(fp)
        
        if(pmac_group->pmac_info[0]->psys_info->tse_use_mdio) {
   28e4c:	e0bffe17 	ldw	r2,-8(fp)
   28e50:	10800117 	ldw	r2,4(r2)
   28e54:	10800217 	ldw	r2,8(r2)
   28e58:	10800203 	ldbu	r2,8(r2)
   28e5c:	10803fcc 	andi	r2,r2,255
   28e60:	10000326 	beq	r2,zero,28e70 <alt_tse_phy_init+0x78>
            
        	/* get connected PHYs */
            alt_tse_mac_get_phy(pmac_group);
   28e64:	e13ffe17 	ldw	r4,-8(fp)
   28e68:	00286740 	call	28674 <alt_tse_mac_get_phy>
   28e6c:	00000706 	br	28e8c <alt_tse_phy_init+0x94>
        }
        else {
            tse_dprintf(3, "WARNING : MAC Groups[%d]->pmac_info[%d] MDIO is not used, unable to run PHY detection\n", i, j);
   28e70:	e0fffd07 	ldb	r3,-12(fp)
   28e74:	e0bffd47 	ldb	r2,-11(fp)
   28e78:	010000f4 	movhi	r4,3
   28e7c:	21052a04 	addi	r4,r4,5288
   28e80:	180b883a 	mov	r5,r3
   28e84:	100d883a 	mov	r6,r2
   28e88:	00170680 	call	17068 <printf>
        }
        
        /* Configure PCS mode if MAC+PCS system is used */
        for(j = 0; j < pmac_group->channel; j++) {
   28e8c:	e03ffd45 	stb	zero,-11(fp)
   28e90:	00000d06 	br	28ec8 <alt_tse_phy_init+0xd0>
            pmac_info = pmac_group->pmac_info[j];
   28e94:	e0bffd47 	ldb	r2,-11(fp)
   28e98:	e0fffe17 	ldw	r3,-8(fp)
   28e9c:	10800044 	addi	r2,r2,1
   28ea0:	1085883a 	add	r2,r2,r2
   28ea4:	1085883a 	add	r2,r2,r2
   28ea8:	1885883a 	add	r2,r3,r2
   28eac:	10800017 	ldw	r2,0(r2)
   28eb0:	e0bfff15 	stw	r2,-4(fp)
            
            alt_tse_phy_cfg_pcs(pmac_info);
   28eb4:	e13fff17 	ldw	r4,-4(fp)
   28eb8:	0028cd00 	call	28cd0 <alt_tse_phy_cfg_pcs>
        else {
            tse_dprintf(3, "WARNING : MAC Groups[%d]->pmac_info[%d] MDIO is not used, unable to run PHY detection\n", i, j);
        }
        
        /* Configure PCS mode if MAC+PCS system is used */
        for(j = 0; j < pmac_group->channel; j++) {
   28ebc:	e0bffd43 	ldbu	r2,-11(fp)
   28ec0:	10800044 	addi	r2,r2,1
   28ec4:	e0bffd45 	stb	r2,-11(fp)
   28ec8:	e0fffd47 	ldb	r3,-11(fp)
   28ecc:	e0bffe17 	ldw	r2,-8(fp)
   28ed0:	10800003 	ldbu	r2,0(r2)
   28ed4:	10803fcc 	andi	r2,r2,255
   28ed8:	18bfee16 	blt	r3,r2,28e94 <alt_tse_phy_init+0x9c>
    
    alt_tse_mac_group_init();
        
    /* initialize for each TSE MAC */
    /* run once only for multi-channel MAC */
    for(i = 0; i < mac_group_count; i++) {
   28edc:	e0bffd03 	ldbu	r2,-12(fp)
   28ee0:	10800044 	addi	r2,r2,1
   28ee4:	e0bffd05 	stb	r2,-12(fp)
   28ee8:	e0fffd07 	ldb	r3,-12(fp)
   28eec:	d0a8f743 	ldbu	r2,-23587(gp)
   28ef0:	10803fcc 	andi	r2,r2,255
   28ef4:	18bfcd16 	blt	r3,r2,28e2c <alt_tse_phy_init+0x34>
            
            alt_tse_phy_cfg_pcs(pmac_info);
        }
    }
                
    return SUCCESS;
   28ef8:	0005883a 	mov	r2,zero
}
   28efc:	e037883a 	mov	sp,fp
   28f00:	dfc00117 	ldw	ra,4(sp)
   28f04:	df000017 	ldw	fp,0(sp)
   28f08:	dec00204 	addi	sp,sp,8
   28f0c:	f800283a 	ret

00028f10 <alt_tse_phy_restart_an>:
 *        timeout_threshold     timeout value of Auto-Negotiation
 * @return                      return TSE_PHY_AN_COMPLETE if success
 *                              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 *                              return TSE_PHY_AN_NOT_CAPABLE if the PHY not capable for AN
 */
alt_32 alt_tse_phy_restart_an(alt_tse_phy_info *pphy, alt_u32 timeout_threshold) {
   28f10:	defff704 	addi	sp,sp,-36
   28f14:	dfc00815 	stw	ra,32(sp)
   28f18:	df000715 	stw	fp,28(sp)
   28f1c:	df000704 	addi	fp,sp,28
   28f20:	e13ffe15 	stw	r4,-8(fp)
   28f24:	e17fff15 	stw	r5,-4(fp)
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
   28f28:	e0bffe17 	ldw	r2,-8(fp)
   28f2c:	10800617 	ldw	r2,24(r2)
   28f30:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
   28f34:	e0bffb17 	ldw	r2,-20(fp)
   28f38:	10800317 	ldw	r2,12(r2)
   28f3c:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
   28f40:	e13ffb17 	ldw	r4,-20(fp)
   28f44:	0026b600 	call	26b60 <alt_tse_get_mac_info_index>
   28f48:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
   28f4c:	e13ffc17 	ldw	r4,-16(fp)
   28f50:	0026aec0 	call	26aec <alt_tse_get_mac_group_index>
   28f54:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
   28f58:	e13ffe17 	ldw	r4,-8(fp)
   28f5c:	00278980 	call	27898 <alt_tse_phy_rd_mdio_addr>
   28f60:	e0bffd85 	stb	r2,-10(fp)
    
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
   28f64:	e0bffe17 	ldw	r2,-8(fp)
   28f68:	10800003 	ldbu	r2,0(r2)
   28f6c:	10803fcc 	andi	r2,r2,255
   28f70:	e13ffe17 	ldw	r4,-8(fp)
   28f74:	100b883a 	mov	r5,r2
   28f78:	00278e00 	call	278e0 <alt_tse_phy_wr_mdio_addr>
    
    if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
   28f7c:	e13ffe17 	ldw	r4,-8(fp)
   28f80:	01400044 	movi	r5,1
   28f84:	018000c4 	movi	r6,3
   28f88:	01c00044 	movi	r7,1
   28f8c:	0027a640 	call	27a64 <alt_tse_phy_rd_mdio_reg>
   28f90:	10000d1e 	bne	r2,zero,28fc8 <alt_tse_phy_restart_an+0xb8>
        tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not capable for Auto-Negotiation\n", mac_group_index, mac_info_index);
   28f94:	e0fffd47 	ldb	r3,-11(fp)
   28f98:	e0bffd07 	ldb	r2,-12(fp)
   28f9c:	010000f4 	movhi	r4,3
   28fa0:	21054004 	addi	r4,r4,5376
   28fa4:	180b883a 	mov	r5,r3
   28fa8:	100d883a 	mov	r6,r2
   28fac:	00170680 	call	17068 <printf>
        
		/* Restore previous MDIO address */
		alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
   28fb0:	e0bffd83 	ldbu	r2,-10(fp)
   28fb4:	e13ffe17 	ldw	r4,-8(fp)
   28fb8:	100b883a 	mov	r5,r2
   28fbc:	00278e00 	call	278e0 <alt_tse_phy_wr_mdio_addr>
		
		return TSE_PHY_AN_NOT_CAPABLE;
   28fc0:	00bfff84 	movi	r2,-2
   28fc4:	00003e06 	br	290c0 <alt_tse_phy_restart_an+0x1b0>
    }
    
    /* enable Auto-Negotiation */    
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_AN_ENA, 1, 1);
   28fc8:	00800044 	movi	r2,1
   28fcc:	d8800015 	stw	r2,0(sp)
   28fd0:	e13ffe17 	ldw	r4,-8(fp)
   28fd4:	000b883a 	mov	r5,zero
   28fd8:	01800304 	movi	r6,12
   28fdc:	01c00044 	movi	r7,1
   28fe0:	00279380 	call	27938 <alt_tse_phy_wr_mdio_reg>
    
    /* send PHY reset command */
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_RESTART_AN, 1, 1);
   28fe4:	00800044 	movi	r2,1
   28fe8:	d8800015 	stw	r2,0(sp)
   28fec:	e13ffe17 	ldw	r4,-8(fp)
   28ff0:	000b883a 	mov	r5,zero
   28ff4:	01800244 	movi	r6,9
   28ff8:	01c00044 	movi	r7,1
   28ffc:	00279380 	call	27938 <alt_tse_phy_wr_mdio_reg>
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Restart Auto-Negotiation, checking PHY link...\n", mac_group_index, mac_info_index);
   29000:	e0fffd47 	ldb	r3,-11(fp)
   29004:	e0bffd07 	ldb	r2,-12(fp)
   29008:	010000f4 	movhi	r4,3
   2900c:	21055004 	addi	r4,r4,5440
   29010:	180b883a 	mov	r5,r3
   29014:	100d883a 	mov	r6,r2
   29018:	00170680 	call	17068 <printf>
    
    alt_32 timeout = 0;
   2901c:	e03ffa15 	stw	zero,-24(fp)
    while(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0 ){ 
   29020:	00001506 	br	29078 <alt_tse_phy_restart_an+0x168>
        if(timeout++ > timeout_threshold) {
   29024:	e0bffa17 	ldw	r2,-24(fp)
   29028:	e0ffff17 	ldw	r3,-4(fp)
   2902c:	1885803a 	cmpltu	r2,r3,r2
   29030:	e0fffa17 	ldw	r3,-24(fp)
   29034:	18c00044 	addi	r3,r3,1
   29038:	e0fffa15 	stw	r3,-24(fp)
   2903c:	10803fcc 	andi	r2,r2,255
   29040:	10000d26 	beq	r2,zero,29078 <alt_tse_phy_restart_an+0x168>
           tse_dprintf(4, "WARNING : PHY[%d.%d] - Auto-Negotiation FAILED\n", mac_group_index, mac_info_index);
   29044:	e0fffd47 	ldb	r3,-11(fp)
   29048:	e0bffd07 	ldb	r2,-12(fp)
   2904c:	010000f4 	movhi	r4,3
   29050:	21056204 	addi	r4,r4,5512
   29054:	180b883a 	mov	r5,r3
   29058:	100d883a 	mov	r6,r2
   2905c:	00170680 	call	17068 <printf>
		   
		   /* Restore previous MDIO address */
           alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
   29060:	e0bffd83 	ldbu	r2,-10(fp)
   29064:	e13ffe17 	ldw	r4,-8(fp)
   29068:	100b883a 	mov	r5,r2
   2906c:	00278e00 	call	278e0 <alt_tse_phy_wr_mdio_addr>
           
		   return TSE_PHY_AN_NOT_COMPLETE;
   29070:	00bfffc4 	movi	r2,-1
   29074:	00001206 	br	290c0 <alt_tse_phy_restart_an+0x1b0>
    /* send PHY reset command */
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_RESTART_AN, 1, 1);
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Restart Auto-Negotiation, checking PHY link...\n", mac_group_index, mac_info_index);
    
    alt_32 timeout = 0;
    while(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0 ){ 
   29078:	e13ffe17 	ldw	r4,-8(fp)
   2907c:	01400044 	movi	r5,1
   29080:	01800144 	movi	r6,5
   29084:	01c00044 	movi	r7,1
   29088:	0027a640 	call	27a64 <alt_tse_phy_rd_mdio_reg>
   2908c:	103fe526 	beq	r2,zero,29024 <alt_tse_phy_restart_an+0x114>
           alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
           
		   return TSE_PHY_AN_NOT_COMPLETE;
        }
    }
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Auto-Negotiation PASSED\n", mac_group_index, mac_info_index);
   29090:	e0fffd47 	ldb	r3,-11(fp)
   29094:	e0bffd07 	ldb	r2,-12(fp)
   29098:	010000f4 	movhi	r4,3
   2909c:	21056e04 	addi	r4,r4,5560
   290a0:	180b883a 	mov	r5,r3
   290a4:	100d883a 	mov	r6,r2
   290a8:	00170680 	call	17068 <printf>
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
   290ac:	e0bffd83 	ldbu	r2,-10(fp)
   290b0:	e13ffe17 	ldw	r4,-8(fp)
   290b4:	100b883a 	mov	r5,r2
   290b8:	00278e00 	call	278e0 <alt_tse_phy_wr_mdio_addr>
    
    return TSE_PHY_AN_COMPLETE;
   290bc:	0005883a 	mov	r2,zero
}
   290c0:	e037883a 	mov	sp,fp
   290c4:	dfc00117 	ldw	ra,4(sp)
   290c8:	df000017 	ldw	fp,0(sp)
   290cc:	dec00204 	addi	sp,sp,8
   290d0:	f800283a 	ret

000290d4 <alt_tse_phy_check_link>:
 * @param pphy                  Pointer to the alt_tse_phy_info structure
 *        timeout_threshold     timeout value of Auto-Negotiation
 * @return                      return TSE_PHY_AN_COMPLETE if success
 *                              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 */
alt_32 alt_tse_phy_check_link(alt_tse_phy_info *pphy, alt_u32 timeout_threshold) {
   290d4:	defff904 	addi	sp,sp,-28
   290d8:	dfc00615 	stw	ra,24(sp)
   290dc:	df000515 	stw	fp,20(sp)
   290e0:	df000504 	addi	fp,sp,20
   290e4:	e13ffe15 	stw	r4,-8(fp)
   290e8:	e17fff15 	stw	r5,-4(fp)

    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
   290ec:	e0bffe17 	ldw	r2,-8(fp)
   290f0:	10800617 	ldw	r2,24(r2)
   290f4:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
   290f8:	e0bffb17 	ldw	r2,-20(fp)
   290fc:	10800317 	ldw	r2,12(r2)
   29100:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
   29104:	e13ffb17 	ldw	r4,-20(fp)
   29108:	0026b600 	call	26b60 <alt_tse_get_mac_info_index>
   2910c:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group); 
   29110:	e13ffc17 	ldw	r4,-16(fp)
   29114:	0026aec0 	call	26aec <alt_tse_get_mac_group_index>
   29118:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
   2911c:	e13ffe17 	ldw	r4,-8(fp)
   29120:	00278980 	call	27898 <alt_tse_phy_rd_mdio_addr>
   29124:	e0bffd85 	stb	r2,-10(fp)
    
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
   29128:	e0bffe17 	ldw	r2,-8(fp)
   2912c:	10800003 	ldbu	r2,0(r2)
   29130:	10803fcc 	andi	r2,r2,255
   29134:	e13ffe17 	ldw	r4,-8(fp)
   29138:	100b883a 	mov	r5,r2
   2913c:	00278e00 	call	278e0 <alt_tse_phy_wr_mdio_addr>
    /* Issue a PHY reset here and wait for the link
     * autonegotiation complete again... this takes several SECONDS(!)
     * so be very careful not to do it frequently
     * perform this when PHY is configured in loopback or has no link yet.
     */
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Checking link...\n", mac_group_index, mac_info_index);
   29140:	e0fffd47 	ldb	r3,-11(fp)
   29144:	e0bffd07 	ldb	r2,-12(fp)
   29148:	010000f4 	movhi	r4,3
   2914c:	21057a04 	addi	r4,r4,5608
   29150:	180b883a 	mov	r5,r3
   29154:	100d883a 	mov	r6,r2
   29158:	00170680 	call	17068 <printf>
    if( ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1)) != 0) ||
   2915c:	e13ffe17 	ldw	r4,-8(fp)
   29160:	000b883a 	mov	r5,zero
   29164:	01800384 	movi	r6,14
   29168:	01c00044 	movi	r7,1
   2916c:	0027a640 	call	27a64 <alt_tse_phy_rd_mdio_reg>
   29170:	1000061e 	bne	r2,zero,2918c <alt_tse_phy_check_link+0xb8>
        ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1)) == 0) ) {                 
   29174:	e13ffe17 	ldw	r4,-8(fp)
   29178:	01400044 	movi	r5,1
   2917c:	01800144 	movi	r6,5
   29180:	01c00044 	movi	r7,1
   29184:	0027a640 	call	27a64 <alt_tse_phy_rd_mdio_reg>
     * autonegotiation complete again... this takes several SECONDS(!)
     * so be very careful not to do it frequently
     * perform this when PHY is configured in loopback or has no link yet.
     */
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Checking link...\n", mac_group_index, mac_info_index);
    if( ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1)) != 0) ||
   29188:	1000191e 	bne	r2,zero,291f0 <alt_tse_phy_check_link+0x11c>
        ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1)) == 0) ) {                 
        
        tse_dprintf(5, "INFO    : PHY[%d.%d] - Link not yet established, restart auto-negotiation...\n", mac_group_index, mac_info_index);
   2918c:	e0fffd47 	ldb	r3,-11(fp)
   29190:	e0bffd07 	ldb	r2,-12(fp)
   29194:	010000f4 	movhi	r4,3
   29198:	21058504 	addi	r4,r4,5652
   2919c:	180b883a 	mov	r5,r3
   291a0:	100d883a 	mov	r6,r2
   291a4:	00170680 	call	17068 <printf>
        /* restart Auto-Negotiation */
        /* if Auto-Negotiation still cannot complete, then go to next PHY */
        if(alt_tse_phy_restart_an(pphy, timeout_threshold) == TSE_PHY_AN_NOT_COMPLETE) {
   291a8:	e13ffe17 	ldw	r4,-8(fp)
   291ac:	e17fff17 	ldw	r5,-4(fp)
   291b0:	0028f100 	call	28f10 <alt_tse_phy_restart_an>
   291b4:	10bfffd8 	cmpnei	r2,r2,-1
   291b8:	10000d1e 	bne	r2,zero,291f0 <alt_tse_phy_check_link+0x11c>
            tse_dprintf(3, "WARNING : PHY[%d.%d] - Link could not established\n", mac_group_index, mac_info_index);
   291bc:	e0fffd47 	ldb	r3,-11(fp)
   291c0:	e0bffd07 	ldb	r2,-12(fp)
   291c4:	010000f4 	movhi	r4,3
   291c8:	21059904 	addi	r4,r4,5732
   291cc:	180b883a 	mov	r5,r3
   291d0:	100d883a 	mov	r6,r2
   291d4:	00170680 	call	17068 <printf>
			
			/* Restore previous MDIO address */
			alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
   291d8:	e0bffd83 	ldbu	r2,-10(fp)
   291dc:	e13ffe17 	ldw	r4,-8(fp)
   291e0:	100b883a 	mov	r5,r2
   291e4:	00278e00 	call	278e0 <alt_tse_phy_wr_mdio_addr>
	
            return TSE_PHY_AN_NOT_COMPLETE;
   291e8:	00bfffc4 	movi	r2,-1
   291ec:	00000c06 	br	29220 <alt_tse_phy_check_link+0x14c>
        }            
    }
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Link established\n", mac_group_index, mac_info_index);
   291f0:	e0fffd47 	ldb	r3,-11(fp)
   291f4:	e0bffd07 	ldb	r2,-12(fp)
   291f8:	010000f4 	movhi	r4,3
   291fc:	2105a604 	addi	r4,r4,5784
   29200:	180b883a 	mov	r5,r3
   29204:	100d883a 	mov	r6,r2
   29208:	00170680 	call	17068 <printf>
            
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
   2920c:	e0bffd83 	ldbu	r2,-10(fp)
   29210:	e13ffe17 	ldw	r4,-8(fp)
   29214:	100b883a 	mov	r5,r2
   29218:	00278e00 	call	278e0 <alt_tse_phy_wr_mdio_addr>
    
    return TSE_PHY_AN_COMPLETE; 
   2921c:	0005883a 	mov	r2,zero
}
   29220:	e037883a 	mov	sp,fp
   29224:	dfc00117 	ldw	ra,4(sp)
   29228:	df000017 	ldw	fp,0(sp)
   2922c:	dec00204 	addi	sp,sp,8
   29230:	f800283a 	ret

00029234 <alt_tse_phy_get_cap>:
 * @param pmac  Pointer to the alt_tse_phy_info structure
 * @return      return TSE_PHY_AN_COMPLETE if success
 *              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 *              return TSE_PHY_AN_NOT_CAPABLE if the PHY not capable for AN
 */
alt_32 alt_tse_phy_get_cap(alt_tse_phy_info *pphy) {
   29234:	defff904 	addi	sp,sp,-28
   29238:	dfc00615 	stw	ra,24(sp)
   2923c:	df000515 	stw	fp,20(sp)
   29240:	df000504 	addi	fp,sp,20
   29244:	e13fff15 	stw	r4,-4(fp)
	alt_32 return_value = TSE_PHY_AN_COMPLETE;
   29248:	e03ffb15 	stw	zero,-20(fp)
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
   2924c:	e0bfff17 	ldw	r2,-4(fp)
   29250:	10800617 	ldw	r2,24(r2)
   29254:	e0bffc15 	stw	r2,-16(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
   29258:	e0bffc17 	ldw	r2,-16(fp)
   2925c:	10800317 	ldw	r2,12(r2)
   29260:	e0bffd15 	stw	r2,-12(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
   29264:	e13ffc17 	ldw	r4,-16(fp)
   29268:	0026b600 	call	26b60 <alt_tse_get_mac_info_index>
   2926c:	e0bffe05 	stb	r2,-8(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);    
   29270:	e13ffd17 	ldw	r4,-12(fp)
   29274:	0026aec0 	call	26aec <alt_tse_get_mac_group_index>
   29278:	e0bffe45 	stb	r2,-7(fp)
        
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
   2927c:	e13fff17 	ldw	r4,-4(fp)
   29280:	00278980 	call	27898 <alt_tse_phy_rd_mdio_addr>
   29284:	e0bffe85 	stb	r2,-6(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
   29288:	e0bfff17 	ldw	r2,-4(fp)
   2928c:	10800003 	ldbu	r2,0(r2)
   29290:	10803fcc 	andi	r2,r2,255
   29294:	e13fff17 	ldw	r4,-4(fp)
   29298:	100b883a 	mov	r5,r2
   2929c:	00278e00 	call	278e0 <alt_tse_phy_wr_mdio_addr>
            
    if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
   292a0:	e13fff17 	ldw	r4,-4(fp)
   292a4:	01400044 	movi	r5,1
   292a8:	018000c4 	movi	r6,3
   292ac:	01c00044 	movi	r7,1
   292b0:	0027a640 	call	27a64 <alt_tse_phy_rd_mdio_reg>
   292b4:	10000d1e 	bne	r2,zero,292ec <alt_tse_phy_get_cap+0xb8>
        tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not capable for Auto-Negotiation\n", mac_group_index, mac_info_index);
   292b8:	e0fffe47 	ldb	r3,-7(fp)
   292bc:	e0bffe07 	ldb	r2,-8(fp)
   292c0:	010000f4 	movhi	r4,3
   292c4:	21054004 	addi	r4,r4,5376
   292c8:	180b883a 	mov	r5,r3
   292cc:	100d883a 	mov	r6,r2
   292d0:	00170680 	call	17068 <printf>
        
        /* Restore previous MDIO address */
        alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
   292d4:	e0bffe83 	ldbu	r2,-6(fp)
   292d8:	e13fff17 	ldw	r4,-4(fp)
   292dc:	100b883a 	mov	r5,r2
   292e0:	00278e00 	call	278e0 <alt_tse_phy_wr_mdio_addr>
        
        return TSE_PHY_AN_NOT_CAPABLE;
   292e4:	00bfff84 	movi	r2,-2
   292e8:	00013306 	br	297b8 <alt_tse_phy_get_cap+0x584>
    }
    
    /* check whether link has been established */
    alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
   292ec:	e13fff17 	ldw	r4,-4(fp)
   292f0:	01400134 	movhi	r5,4
   292f4:	29742404 	addi	r5,r5,-12144
   292f8:	0028f100 	call	28f10 <alt_tse_phy_restart_an>
    
    if(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0) {
   292fc:	e13fff17 	ldw	r4,-4(fp)
   29300:	01400044 	movi	r5,1
   29304:	01800144 	movi	r6,5
   29308:	01c00044 	movi	r7,1
   2930c:	0027a640 	call	27a64 <alt_tse_phy_rd_mdio_reg>
   29310:	1000021e 	bne	r2,zero,2931c <alt_tse_phy_get_cap+0xe8>
        return_value = TSE_PHY_AN_NOT_COMPLETE;
   29314:	00bfffc4 	movi	r2,-1
   29318:	e0bffb15 	stw	r2,-20(fp)
    }
    
    /* get PHY capabilities */
    pphy->link_capability.cap_1000_base_x_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_FULL, 1);
   2931c:	e13fff17 	ldw	r4,-4(fp)
   29320:	014003c4 	movi	r5,15
   29324:	018003c4 	movi	r6,15
   29328:	01c00044 	movi	r7,1
   2932c:	0027a640 	call	27a64 <alt_tse_phy_rd_mdio_reg>
   29330:	1007883a 	mov	r3,r2
   29334:	e0bfff17 	ldw	r2,-4(fp)
   29338:	10c00045 	stb	r3,1(r2)
    pphy->link_capability.cap_1000_base_x_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_HALF, 1);
   2933c:	e13fff17 	ldw	r4,-4(fp)
   29340:	014003c4 	movi	r5,15
   29344:	01800384 	movi	r6,14
   29348:	01c00044 	movi	r7,1
   2934c:	0027a640 	call	27a64 <alt_tse_phy_rd_mdio_reg>
   29350:	1007883a 	mov	r3,r2
   29354:	e0bfff17 	ldw	r2,-4(fp)
   29358:	10c00085 	stb	r3,2(r2)
    pphy->link_capability.cap_1000_base_t_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_FULL, 1);
   2935c:	e13fff17 	ldw	r4,-4(fp)
   29360:	014003c4 	movi	r5,15
   29364:	01800344 	movi	r6,13
   29368:	01c00044 	movi	r7,1
   2936c:	0027a640 	call	27a64 <alt_tse_phy_rd_mdio_reg>
   29370:	1007883a 	mov	r3,r2
   29374:	e0bfff17 	ldw	r2,-4(fp)
   29378:	10c000c5 	stb	r3,3(r2)
    pphy->link_capability.cap_1000_base_t_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_HALF, 1);
   2937c:	e13fff17 	ldw	r4,-4(fp)
   29380:	014003c4 	movi	r5,15
   29384:	01800304 	movi	r6,12
   29388:	01c00044 	movi	r7,1
   2938c:	0027a640 	call	27a64 <alt_tse_phy_rd_mdio_reg>
   29390:	1007883a 	mov	r3,r2
   29394:	e0bfff17 	ldw	r2,-4(fp)
   29398:	10c00105 	stb	r3,4(r2)
    
    pphy->link_capability.cap_100_base_t4      = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T4, 1);
   2939c:	e13fff17 	ldw	r4,-4(fp)
   293a0:	01400044 	movi	r5,1
   293a4:	018003c4 	movi	r6,15
   293a8:	01c00044 	movi	r7,1
   293ac:	0027a640 	call	27a64 <alt_tse_phy_rd_mdio_reg>
   293b0:	1007883a 	mov	r3,r2
   293b4:	e0bfff17 	ldw	r2,-4(fp)
   293b8:	10c00145 	stb	r3,5(r2)
    pphy->link_capability.cap_100_base_x_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_FULL, 1);
   293bc:	e13fff17 	ldw	r4,-4(fp)
   293c0:	01400044 	movi	r5,1
   293c4:	01800384 	movi	r6,14
   293c8:	01c00044 	movi	r7,1
   293cc:	0027a640 	call	27a64 <alt_tse_phy_rd_mdio_reg>
   293d0:	1007883a 	mov	r3,r2
   293d4:	e0bfff17 	ldw	r2,-4(fp)
   293d8:	10c00185 	stb	r3,6(r2)
    pphy->link_capability.cap_100_base_x_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_HALF, 1);
   293dc:	e13fff17 	ldw	r4,-4(fp)
   293e0:	01400044 	movi	r5,1
   293e4:	01800344 	movi	r6,13
   293e8:	01c00044 	movi	r7,1
   293ec:	0027a640 	call	27a64 <alt_tse_phy_rd_mdio_reg>
   293f0:	1007883a 	mov	r3,r2
   293f4:	e0bfff17 	ldw	r2,-4(fp)
   293f8:	10c001c5 	stb	r3,7(r2)
    pphy->link_capability.cap_100_base_t2_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_FULL, 1);
   293fc:	e13fff17 	ldw	r4,-4(fp)
   29400:	01400044 	movi	r5,1
   29404:	01800284 	movi	r6,10
   29408:	01c00044 	movi	r7,1
   2940c:	0027a640 	call	27a64 <alt_tse_phy_rd_mdio_reg>
   29410:	1007883a 	mov	r3,r2
   29414:	e0bfff17 	ldw	r2,-4(fp)
   29418:	10c00205 	stb	r3,8(r2)
    pphy->link_capability.cap_100_base_t2_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_HALF, 1);
   2941c:	e13fff17 	ldw	r4,-4(fp)
   29420:	01400044 	movi	r5,1
   29424:	01800244 	movi	r6,9
   29428:	01c00044 	movi	r7,1
   2942c:	0027a640 	call	27a64 <alt_tse_phy_rd_mdio_reg>
   29430:	1007883a 	mov	r3,r2
   29434:	e0bfff17 	ldw	r2,-4(fp)
   29438:	10c00245 	stb	r3,9(r2)
    pphy->link_capability.cap_10_base_t_full   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_FULL, 1);
   2943c:	e13fff17 	ldw	r4,-4(fp)
   29440:	01400044 	movi	r5,1
   29444:	01800304 	movi	r6,12
   29448:	01c00044 	movi	r7,1
   2944c:	0027a640 	call	27a64 <alt_tse_phy_rd_mdio_reg>
   29450:	1007883a 	mov	r3,r2
   29454:	e0bfff17 	ldw	r2,-4(fp)
   29458:	10c00285 	stb	r3,10(r2)
    pphy->link_capability.cap_10_base_t_half   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_HALF, 1);
   2945c:	e13fff17 	ldw	r4,-4(fp)
   29460:	01400044 	movi	r5,1
   29464:	018002c4 	movi	r6,11
   29468:	01c00044 	movi	r7,1
   2946c:	0027a640 	call	27a64 <alt_tse_phy_rd_mdio_reg>
   29470:	1007883a 	mov	r3,r2
   29474:	e0bfff17 	ldw	r2,-4(fp)
   29478:	10c002c5 	stb	r3,11(r2)
    
    /* get link partner capability */
    pphy->link_capability.lp_1000_base_t_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_FULL_ADV, 1);
   2947c:	e13fff17 	ldw	r4,-4(fp)
   29480:	01400284 	movi	r5,10
   29484:	018002c4 	movi	r6,11
   29488:	01c00044 	movi	r7,1
   2948c:	0027a640 	call	27a64 <alt_tse_phy_rd_mdio_reg>
   29490:	1007883a 	mov	r3,r2
   29494:	e0bfff17 	ldw	r2,-4(fp)
   29498:	10c00305 	stb	r3,12(r2)
    pphy->link_capability.lp_1000_base_t_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_HALF_ADV, 1);
   2949c:	e13fff17 	ldw	r4,-4(fp)
   294a0:	01400284 	movi	r5,10
   294a4:	01800284 	movi	r6,10
   294a8:	01c00044 	movi	r7,1
   294ac:	0027a640 	call	27a64 <alt_tse_phy_rd_mdio_reg>
   294b0:	1007883a 	mov	r3,r2
   294b4:	e0bfff17 	ldw	r2,-4(fp)
   294b8:	10c00345 	stb	r3,13(r2)
    
    pphy->link_capability.lp_100_base_t4       = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1);
   294bc:	e13fff17 	ldw	r4,-4(fp)
   294c0:	01400144 	movi	r5,5
   294c4:	01800244 	movi	r6,9
   294c8:	01c00044 	movi	r7,1
   294cc:	0027a640 	call	27a64 <alt_tse_phy_rd_mdio_reg>
   294d0:	1007883a 	mov	r3,r2
   294d4:	e0bfff17 	ldw	r2,-4(fp)
   294d8:	10c00385 	stb	r3,14(r2)
    pphy->link_capability.lp_100_base_tx_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1);
   294dc:	e13fff17 	ldw	r4,-4(fp)
   294e0:	01400144 	movi	r5,5
   294e4:	01800204 	movi	r6,8
   294e8:	01c00044 	movi	r7,1
   294ec:	0027a640 	call	27a64 <alt_tse_phy_rd_mdio_reg>
   294f0:	1007883a 	mov	r3,r2
   294f4:	e0bfff17 	ldw	r2,-4(fp)
   294f8:	10c003c5 	stb	r3,15(r2)
    pphy->link_capability.lp_100_base_tx_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1);
   294fc:	e13fff17 	ldw	r4,-4(fp)
   29500:	01400144 	movi	r5,5
   29504:	018001c4 	movi	r6,7
   29508:	01c00044 	movi	r7,1
   2950c:	0027a640 	call	27a64 <alt_tse_phy_rd_mdio_reg>
   29510:	1007883a 	mov	r3,r2
   29514:	e0bfff17 	ldw	r2,-4(fp)
   29518:	10c00405 	stb	r3,16(r2)
    pphy->link_capability.lp_10_base_tx_full   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1);
   2951c:	e13fff17 	ldw	r4,-4(fp)
   29520:	01400144 	movi	r5,5
   29524:	01800184 	movi	r6,6
   29528:	01c00044 	movi	r7,1
   2952c:	0027a640 	call	27a64 <alt_tse_phy_rd_mdio_reg>
   29530:	1007883a 	mov	r3,r2
   29534:	e0bfff17 	ldw	r2,-4(fp)
   29538:	10c00445 	stb	r3,17(r2)
    pphy->link_capability.lp_10_base_tx_half   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1);
   2953c:	e13fff17 	ldw	r4,-4(fp)
   29540:	01400144 	movi	r5,5
   29544:	01800144 	movi	r6,5
   29548:	01c00044 	movi	r7,1
   2954c:	0027a640 	call	27a64 <alt_tse_phy_rd_mdio_reg>
   29550:	1007883a 	mov	r3,r2
   29554:	e0bfff17 	ldw	r2,-4(fp)
   29558:	10c00485 	stb	r3,18(r2)
    
    tse_dprintf(6, "INFO    : PHY[%d.%d] - Capability of PHY :\n", mac_group_index, mac_info_index);
   2955c:	e0fffe47 	ldb	r3,-7(fp)
   29560:	e0bffe07 	ldb	r2,-8(fp)
   29564:	010000f4 	movhi	r4,3
   29568:	2105b104 	addi	r4,r4,5828
   2956c:	180b883a 	mov	r5,r3
   29570:	100d883a 	mov	r6,r2
   29574:	00259780 	call	25978 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-X Full Duplex = %d\n", pphy->link_capability.cap_1000_base_x_full);
   29578:	e0bfff17 	ldw	r2,-4(fp)
   2957c:	10800043 	ldbu	r2,1(r2)
   29580:	10803fcc 	andi	r2,r2,255
   29584:	010000f4 	movhi	r4,3
   29588:	2105bc04 	addi	r4,r4,5872
   2958c:	100b883a 	mov	r5,r2
   29590:	00259780 	call	25978 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-X Half Duplex = %d\n", pphy->link_capability.cap_1000_base_x_half);
   29594:	e0bfff17 	ldw	r2,-4(fp)
   29598:	10800083 	ldbu	r2,2(r2)
   2959c:	10803fcc 	andi	r2,r2,255
   295a0:	010000f4 	movhi	r4,3
   295a4:	2105c604 	addi	r4,r4,5912
   295a8:	100b883a 	mov	r5,r2
   295ac:	00259780 	call	25978 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Full Duplex = %d\n", pphy->link_capability.cap_1000_base_t_full);
   295b0:	e0bfff17 	ldw	r2,-4(fp)
   295b4:	108000c3 	ldbu	r2,3(r2)
   295b8:	10803fcc 	andi	r2,r2,255
   295bc:	010000f4 	movhi	r4,3
   295c0:	2105d004 	addi	r4,r4,5952
   295c4:	100b883a 	mov	r5,r2
   295c8:	00259780 	call	25978 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Half Duplex = %d\n", pphy->link_capability.cap_1000_base_t_half);
   295cc:	e0bfff17 	ldw	r2,-4(fp)
   295d0:	10800103 	ldbu	r2,4(r2)
   295d4:	10803fcc 	andi	r2,r2,255
   295d8:	010000f4 	movhi	r4,3
   295dc:	2105da04 	addi	r4,r4,5992
   295e0:	100b883a 	mov	r5,r2
   295e4:	00259780 	call	25978 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T4             = %d\n", pphy->link_capability.cap_100_base_t4);
   295e8:	e0bfff17 	ldw	r2,-4(fp)
   295ec:	10800143 	ldbu	r2,5(r2)
   295f0:	10803fcc 	andi	r2,r2,255
   295f4:	010000f4 	movhi	r4,3
   295f8:	2105e404 	addi	r4,r4,6032
   295fc:	100b883a 	mov	r5,r2
   29600:	00259780 	call	25978 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-X Full Duplex  = %d\n", pphy->link_capability.cap_100_base_x_full);
   29604:	e0bfff17 	ldw	r2,-4(fp)
   29608:	10800183 	ldbu	r2,6(r2)
   2960c:	10803fcc 	andi	r2,r2,255
   29610:	010000f4 	movhi	r4,3
   29614:	2105ee04 	addi	r4,r4,6072
   29618:	100b883a 	mov	r5,r2
   2961c:	00259780 	call	25978 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-X Half Duplex  = %d\n", pphy->link_capability.cap_100_base_x_half);
   29620:	e0bfff17 	ldw	r2,-4(fp)
   29624:	108001c3 	ldbu	r2,7(r2)
   29628:	10803fcc 	andi	r2,r2,255
   2962c:	010000f4 	movhi	r4,3
   29630:	2105f804 	addi	r4,r4,6112
   29634:	100b883a 	mov	r5,r2
   29638:	00259780 	call	25978 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T2 Full Duplex = %d\n", pphy->link_capability.cap_100_base_t2_full);
   2963c:	e0bfff17 	ldw	r2,-4(fp)
   29640:	10800203 	ldbu	r2,8(r2)
   29644:	10803fcc 	andi	r2,r2,255
   29648:	010000f4 	movhi	r4,3
   2964c:	21060204 	addi	r4,r4,6152
   29650:	100b883a 	mov	r5,r2
   29654:	00259780 	call	25978 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T2 Half Duplex = %d\n", pphy->link_capability.cap_100_base_t2_half);
   29658:	e0bfff17 	ldw	r2,-4(fp)
   2965c:	10800243 	ldbu	r2,9(r2)
   29660:	10803fcc 	andi	r2,r2,255
   29664:	010000f4 	movhi	r4,3
   29668:	21060c04 	addi	r4,r4,6192
   2966c:	100b883a 	mov	r5,r2
   29670:	00259780 	call	25978 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-T Full Duplex   = %d\n", pphy->link_capability.cap_10_base_t_full);
   29674:	e0bfff17 	ldw	r2,-4(fp)
   29678:	10800283 	ldbu	r2,10(r2)
   2967c:	10803fcc 	andi	r2,r2,255
   29680:	010000f4 	movhi	r4,3
   29684:	21061604 	addi	r4,r4,6232
   29688:	100b883a 	mov	r5,r2
   2968c:	00259780 	call	25978 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-T Half Duplex   = %d\n", pphy->link_capability.cap_10_base_t_half);
   29690:	e0bfff17 	ldw	r2,-4(fp)
   29694:	108002c3 	ldbu	r2,11(r2)
   29698:	10803fcc 	andi	r2,r2,255
   2969c:	010000f4 	movhi	r4,3
   296a0:	21062004 	addi	r4,r4,6272
   296a4:	100b883a 	mov	r5,r2
   296a8:	00259780 	call	25978 <no_printf>
    tse_dprintf(6, "\n");
   296ac:	010000f4 	movhi	r4,3
   296b0:	21048604 	addi	r4,r4,4632
   296b4:	00259780 	call	25978 <no_printf>
    
    tse_dprintf(6, "INFO    : PHY[%d.%d] - Link Partner Capability :\n", mac_group_index, mac_info_index);
   296b8:	e0fffe47 	ldb	r3,-7(fp)
   296bc:	e0bffe07 	ldb	r2,-8(fp)
   296c0:	010000f4 	movhi	r4,3
   296c4:	21062a04 	addi	r4,r4,6312
   296c8:	180b883a 	mov	r5,r3
   296cc:	100d883a 	mov	r6,r2
   296d0:	00259780 	call	25978 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Full Duplex = %d\n", pphy->link_capability.lp_1000_base_t_full);
   296d4:	e0bfff17 	ldw	r2,-4(fp)
   296d8:	10800303 	ldbu	r2,12(r2)
   296dc:	10803fcc 	andi	r2,r2,255
   296e0:	010000f4 	movhi	r4,3
   296e4:	2105d004 	addi	r4,r4,5952
   296e8:	100b883a 	mov	r5,r2
   296ec:	00259780 	call	25978 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Half Duplex = %d\n", pphy->link_capability.lp_1000_base_t_half);
   296f0:	e0bfff17 	ldw	r2,-4(fp)
   296f4:	10800343 	ldbu	r2,13(r2)
   296f8:	10803fcc 	andi	r2,r2,255
   296fc:	010000f4 	movhi	r4,3
   29700:	2105da04 	addi	r4,r4,5992
   29704:	100b883a 	mov	r5,r2
   29708:	00259780 	call	25978 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T4             = %d\n", pphy->link_capability.lp_100_base_t4);
   2970c:	e0bfff17 	ldw	r2,-4(fp)
   29710:	10800383 	ldbu	r2,14(r2)
   29714:	10803fcc 	andi	r2,r2,255
   29718:	010000f4 	movhi	r4,3
   2971c:	2105e404 	addi	r4,r4,6032
   29720:	100b883a 	mov	r5,r2
   29724:	00259780 	call	25978 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-TX Full Duplex = %d\n", pphy->link_capability.lp_100_base_tx_full);
   29728:	e0bfff17 	ldw	r2,-4(fp)
   2972c:	108003c3 	ldbu	r2,15(r2)
   29730:	10803fcc 	andi	r2,r2,255
   29734:	010000f4 	movhi	r4,3
   29738:	21063704 	addi	r4,r4,6364
   2973c:	100b883a 	mov	r5,r2
   29740:	00259780 	call	25978 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-TX Half Duplex = %d\n", pphy->link_capability.lp_100_base_tx_half);
   29744:	e0bfff17 	ldw	r2,-4(fp)
   29748:	10800403 	ldbu	r2,16(r2)
   2974c:	10803fcc 	andi	r2,r2,255
   29750:	010000f4 	movhi	r4,3
   29754:	21064104 	addi	r4,r4,6404
   29758:	100b883a 	mov	r5,r2
   2975c:	00259780 	call	25978 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-TX Full Duplex  = %d\n", pphy->link_capability.lp_10_base_tx_full);
   29760:	e0bfff17 	ldw	r2,-4(fp)
   29764:	10800443 	ldbu	r2,17(r2)
   29768:	10803fcc 	andi	r2,r2,255
   2976c:	010000f4 	movhi	r4,3
   29770:	21064b04 	addi	r4,r4,6444
   29774:	100b883a 	mov	r5,r2
   29778:	00259780 	call	25978 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-TX Half Duplex  = %d\n", pphy->link_capability.lp_10_base_tx_half);
   2977c:	e0bfff17 	ldw	r2,-4(fp)
   29780:	10800483 	ldbu	r2,18(r2)
   29784:	10803fcc 	andi	r2,r2,255
   29788:	010000f4 	movhi	r4,3
   2978c:	21065504 	addi	r4,r4,6484
   29790:	100b883a 	mov	r5,r2
   29794:	00259780 	call	25978 <no_printf>
    tse_dprintf(6, "\n");
   29798:	010000f4 	movhi	r4,3
   2979c:	21048604 	addi	r4,r4,4632
   297a0:	00259780 	call	25978 <no_printf>
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
   297a4:	e0bffe83 	ldbu	r2,-6(fp)
   297a8:	e13fff17 	ldw	r4,-4(fp)
   297ac:	100b883a 	mov	r5,r2
   297b0:	00278e00 	call	278e0 <alt_tse_phy_wr_mdio_addr>
    
    return return_value;
   297b4:	e0bffb17 	ldw	r2,-20(fp)
    
}
   297b8:	e037883a 	mov	sp,fp
   297bc:	dfc00117 	ldw	ra,4(sp)
   297c0:	df000017 	ldw	fp,0(sp)
   297c4:	dec00204 	addi	sp,sp,8
   297c8:	f800283a 	ret

000297cc <alt_tse_phy_set_adv_1000>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_1000(alt_tse_phy_info *pphy, alt_u8 enable) {
   297cc:	defff804 	addi	sp,sp,-32
   297d0:	dfc00715 	stw	ra,28(sp)
   297d4:	df000615 	stw	fp,24(sp)
   297d8:	df000604 	addi	fp,sp,24
   297dc:	e13ffe15 	stw	r4,-8(fp)
   297e0:	2805883a 	mov	r2,r5
   297e4:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
   297e8:	e0bffe17 	ldw	r2,-8(fp)
   297ec:	10800617 	ldw	r2,24(r2)
   297f0:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
   297f4:	e0bffb17 	ldw	r2,-20(fp)
   297f8:	10800317 	ldw	r2,12(r2)
   297fc:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
   29800:	e13ffb17 	ldw	r4,-20(fp)
   29804:	0026b600 	call	26b60 <alt_tse_get_mac_info_index>
   29808:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
   2980c:	e13ffc17 	ldw	r4,-16(fp)
   29810:	0026aec0 	call	26aec <alt_tse_get_mac_group_index>
   29814:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
   29818:	e13ffe17 	ldw	r4,-8(fp)
   2981c:	00278980 	call	27898 <alt_tse_phy_rd_mdio_addr>
   29820:	e0bffd85 	stb	r2,-10(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
   29824:	e0bffe17 	ldw	r2,-8(fp)
   29828:	10800003 	ldbu	r2,0(r2)
   2982c:	10803fcc 	andi	r2,r2,255
   29830:	e13ffe17 	ldw	r4,-8(fp)
   29834:	100b883a 	mov	r5,r2
   29838:	00278e00 	call	278e0 <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
   2983c:	e0bfff03 	ldbu	r2,-4(fp)
   29840:	10002b26 	beq	r2,zero,298f0 <alt_tse_phy_set_adv_1000+0x124>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_FULL, 1); 
   29844:	e13ffe17 	ldw	r4,-8(fp)
   29848:	014003c4 	movi	r5,15
   2984c:	01800344 	movi	r6,13
   29850:	01c00044 	movi	r7,1
   29854:	0027a640 	call	27a64 <alt_tse_phy_rd_mdio_reg>
   29858:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_FULL_ADV, 1, cap);
   2985c:	e0bffdc3 	ldbu	r2,-9(fp)
   29860:	d8800015 	stw	r2,0(sp)
   29864:	e13ffe17 	ldw	r4,-8(fp)
   29868:	01400244 	movi	r5,9
   2986c:	01800244 	movi	r6,9
   29870:	01c00044 	movi	r7,1
   29874:	00279380 	call	27938 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
   29878:	e17ffd47 	ldb	r5,-11(fp)
   2987c:	e0fffd07 	ldb	r3,-12(fp)
   29880:	e0bffdc3 	ldbu	r2,-9(fp)
   29884:	010000f4 	movhi	r4,3
   29888:	21065f04 	addi	r4,r4,6524
   2988c:	180d883a 	mov	r6,r3
   29890:	100f883a 	mov	r7,r2
   29894:	00259780 	call	25978 <no_printf>
        
        /* 1000 Mbps Half duplex not supported by TSE MAC */
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_HALF, 1);
   29898:	e13ffe17 	ldw	r4,-8(fp)
   2989c:	014003c4 	movi	r5,15
   298a0:	01800304 	movi	r6,12
   298a4:	01c00044 	movi	r7,1
   298a8:	0027a640 	call	27a64 <alt_tse_phy_rd_mdio_reg>
   298ac:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_HALF_ADV, 1, cap);
   298b0:	e0bffdc3 	ldbu	r2,-9(fp)
   298b4:	d8800015 	stw	r2,0(sp)
   298b8:	e13ffe17 	ldw	r4,-8(fp)
   298bc:	01400244 	movi	r5,9
   298c0:	01800204 	movi	r6,8
   298c4:	01c00044 	movi	r7,1
   298c8:	00279380 	call	27938 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
   298cc:	e17ffd47 	ldb	r5,-11(fp)
   298d0:	e0fffd07 	ldb	r3,-12(fp)
   298d4:	e0bffdc3 	ldbu	r2,-9(fp)
   298d8:	010000f4 	movhi	r4,3
   298dc:	21067204 	addi	r4,r4,6600
   298e0:	180d883a 	mov	r6,r3
   298e4:	100f883a 	mov	r7,r2
   298e8:	00259780 	call	25978 <no_printf>
   298ec:	00001c06 	br	29960 <alt_tse_phy_set_adv_1000+0x194>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_FULL_ADV, 1, 0);
   298f0:	d8000015 	stw	zero,0(sp)
   298f4:	e13ffe17 	ldw	r4,-8(fp)
   298f8:	01400244 	movi	r5,9
   298fc:	01800244 	movi	r6,9
   29900:	01c00044 	movi	r7,1
   29904:	00279380 	call	27938 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
   29908:	e0fffd47 	ldb	r3,-11(fp)
   2990c:	e0bffd07 	ldb	r2,-12(fp)
   29910:	010000f4 	movhi	r4,3
   29914:	21065f04 	addi	r4,r4,6524
   29918:	180b883a 	mov	r5,r3
   2991c:	100d883a 	mov	r6,r2
   29920:	000f883a 	mov	r7,zero
   29924:	00259780 	call	25978 <no_printf>
        
        /* 1000 Mbps Half duplex not supported by TSE MAC */
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_HALF_ADV, 1, 0);
   29928:	d8000015 	stw	zero,0(sp)
   2992c:	e13ffe17 	ldw	r4,-8(fp)
   29930:	01400244 	movi	r5,9
   29934:	01800204 	movi	r6,8
   29938:	01c00044 	movi	r7,1
   2993c:	00279380 	call	27938 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement 1000 Base-T half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
   29940:	e0fffd47 	ldb	r3,-11(fp)
   29944:	e0bffd07 	ldb	r2,-12(fp)
   29948:	010000f4 	movhi	r4,3
   2994c:	21068504 	addi	r4,r4,6676
   29950:	180b883a 	mov	r5,r3
   29954:	100d883a 	mov	r6,r2
   29958:	000f883a 	mov	r7,zero
   2995c:	00259780 	call	25978 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);    
   29960:	e0bffd83 	ldbu	r2,-10(fp)
   29964:	e13ffe17 	ldw	r4,-8(fp)
   29968:	100b883a 	mov	r5,r2
   2996c:	00278e00 	call	278e0 <alt_tse_phy_wr_mdio_addr>

    return SUCCESS;
   29970:	0005883a 	mov	r2,zero
}
   29974:	e037883a 	mov	sp,fp
   29978:	dfc00117 	ldw	ra,4(sp)
   2997c:	df000017 	ldw	fp,0(sp)
   29980:	dec00204 	addi	sp,sp,8
   29984:	f800283a 	ret

00029988 <alt_tse_phy_set_adv_100>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_100(alt_tse_phy_info *pphy, alt_u8 enable) {
   29988:	defff804 	addi	sp,sp,-32
   2998c:	dfc00715 	stw	ra,28(sp)
   29990:	df000615 	stw	fp,24(sp)
   29994:	df000604 	addi	fp,sp,24
   29998:	e13ffe15 	stw	r4,-8(fp)
   2999c:	2805883a 	mov	r2,r5
   299a0:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
   299a4:	e0bffe17 	ldw	r2,-8(fp)
   299a8:	10800617 	ldw	r2,24(r2)
   299ac:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
   299b0:	e0bffb17 	ldw	r2,-20(fp)
   299b4:	10800317 	ldw	r2,12(r2)
   299b8:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
   299bc:	e13ffb17 	ldw	r4,-20(fp)
   299c0:	0026b600 	call	26b60 <alt_tse_get_mac_info_index>
   299c4:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
   299c8:	e13ffc17 	ldw	r4,-16(fp)
   299cc:	0026aec0 	call	26aec <alt_tse_get_mac_group_index>
   299d0:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
   299d4:	e13ffe17 	ldw	r4,-8(fp)
   299d8:	00278980 	call	27898 <alt_tse_phy_rd_mdio_addr>
   299dc:	e0bffd85 	stb	r2,-10(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
   299e0:	e0bffe17 	ldw	r2,-8(fp)
   299e4:	10800003 	ldbu	r2,0(r2)
   299e8:	10803fcc 	andi	r2,r2,255
   299ec:	e13ffe17 	ldw	r4,-8(fp)
   299f0:	100b883a 	mov	r5,r2
   299f4:	00278e00 	call	278e0 <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
   299f8:	e0bfff03 	ldbu	r2,-4(fp)
   299fc:	10004026 	beq	r2,zero,29b00 <alt_tse_phy_set_adv_100+0x178>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T4, 1);
   29a00:	e13ffe17 	ldw	r4,-8(fp)
   29a04:	01400044 	movi	r5,1
   29a08:	018003c4 	movi	r6,15
   29a0c:	01c00044 	movi	r7,1
   29a10:	0027a640 	call	27a64 <alt_tse_phy_rd_mdio_reg>
   29a14:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1, cap);
   29a18:	e0bffdc3 	ldbu	r2,-9(fp)
   29a1c:	d8800015 	stw	r2,0(sp)
   29a20:	e13ffe17 	ldw	r4,-8(fp)
   29a24:	01400104 	movi	r5,4
   29a28:	01800244 	movi	r6,9
   29a2c:	01c00044 	movi	r7,1
   29a30:	00279380 	call	27938 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-T4 set to %d\n", mac_group_index, mac_info_index, cap);
   29a34:	e17ffd47 	ldb	r5,-11(fp)
   29a38:	e0fffd07 	ldb	r3,-12(fp)
   29a3c:	e0bffdc3 	ldbu	r2,-9(fp)
   29a40:	010000f4 	movhi	r4,3
   29a44:	21069704 	addi	r4,r4,6748
   29a48:	180d883a 	mov	r6,r3
   29a4c:	100f883a 	mov	r7,r2
   29a50:	00259780 	call	25978 <no_printf>
        
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_FULL, 1);
   29a54:	e13ffe17 	ldw	r4,-8(fp)
   29a58:	01400044 	movi	r5,1
   29a5c:	01800384 	movi	r6,14
   29a60:	01c00044 	movi	r7,1
   29a64:	0027a640 	call	27a64 <alt_tse_phy_rd_mdio_reg>
   29a68:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1, cap);
   29a6c:	e0bffdc3 	ldbu	r2,-9(fp)
   29a70:	d8800015 	stw	r2,0(sp)
   29a74:	e13ffe17 	ldw	r4,-8(fp)
   29a78:	01400104 	movi	r5,4
   29a7c:	01800204 	movi	r6,8
   29a80:	01c00044 	movi	r7,1
   29a84:	00279380 	call	27938 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
   29a88:	e17ffd47 	ldb	r5,-11(fp)
   29a8c:	e0fffd07 	ldb	r3,-12(fp)
   29a90:	e0bffdc3 	ldbu	r2,-9(fp)
   29a94:	010000f4 	movhi	r4,3
   29a98:	2106a704 	addi	r4,r4,6812
   29a9c:	180d883a 	mov	r6,r3
   29aa0:	100f883a 	mov	r7,r2
   29aa4:	00259780 	call	25978 <no_printf>
        
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_HALF, 1);
   29aa8:	e13ffe17 	ldw	r4,-8(fp)
   29aac:	01400044 	movi	r5,1
   29ab0:	01800344 	movi	r6,13
   29ab4:	01c00044 	movi	r7,1
   29ab8:	0027a640 	call	27a64 <alt_tse_phy_rd_mdio_reg>
   29abc:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1, cap);
   29ac0:	e0bffdc3 	ldbu	r2,-9(fp)
   29ac4:	d8800015 	stw	r2,0(sp)
   29ac8:	e13ffe17 	ldw	r4,-8(fp)
   29acc:	01400104 	movi	r5,4
   29ad0:	018001c4 	movi	r6,7
   29ad4:	01c00044 	movi	r7,1
   29ad8:	00279380 	call	27938 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
   29adc:	e17ffd47 	ldb	r5,-11(fp)
   29ae0:	e0fffd07 	ldb	r3,-12(fp)
   29ae4:	e0bffdc3 	ldbu	r2,-9(fp)
   29ae8:	010000f4 	movhi	r4,3
   29aec:	2106ba04 	addi	r4,r4,6888
   29af0:	180d883a 	mov	r6,r3
   29af4:	100f883a 	mov	r7,r2
   29af8:	00259780 	call	25978 <no_printf>
   29afc:	00002a06 	br	29ba8 <alt_tse_phy_set_adv_100+0x220>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1, 0);
   29b00:	d8000015 	stw	zero,0(sp)
   29b04:	e13ffe17 	ldw	r4,-8(fp)
   29b08:	01400104 	movi	r5,4
   29b0c:	01800244 	movi	r6,9
   29b10:	01c00044 	movi	r7,1
   29b14:	00279380 	call	27938 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-T4 set to %d\n", mac_group_index, mac_info_index, 0);
   29b18:	e0fffd47 	ldb	r3,-11(fp)
   29b1c:	e0bffd07 	ldb	r2,-12(fp)
   29b20:	010000f4 	movhi	r4,3
   29b24:	21069704 	addi	r4,r4,6748
   29b28:	180b883a 	mov	r5,r3
   29b2c:	100d883a 	mov	r6,r2
   29b30:	000f883a 	mov	r7,zero
   29b34:	00259780 	call	25978 <no_printf>
        
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1, 0);
   29b38:	d8000015 	stw	zero,0(sp)
   29b3c:	e13ffe17 	ldw	r4,-8(fp)
   29b40:	01400104 	movi	r5,4
   29b44:	01800204 	movi	r6,8
   29b48:	01c00044 	movi	r7,1
   29b4c:	00279380 	call	27938 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
   29b50:	e0fffd47 	ldb	r3,-11(fp)
   29b54:	e0bffd07 	ldb	r2,-12(fp)
   29b58:	010000f4 	movhi	r4,3
   29b5c:	2106a704 	addi	r4,r4,6812
   29b60:	180b883a 	mov	r5,r3
   29b64:	100d883a 	mov	r6,r2
   29b68:	000f883a 	mov	r7,zero
   29b6c:	00259780 	call	25978 <no_printf>
        
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1, 0);
   29b70:	d8000015 	stw	zero,0(sp)
   29b74:	e13ffe17 	ldw	r4,-8(fp)
   29b78:	01400104 	movi	r5,4
   29b7c:	018001c4 	movi	r6,7
   29b80:	01c00044 	movi	r7,1
   29b84:	00279380 	call	27938 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
   29b88:	e0fffd47 	ldb	r3,-11(fp)
   29b8c:	e0bffd07 	ldb	r2,-12(fp)
   29b90:	010000f4 	movhi	r4,3
   29b94:	2106ba04 	addi	r4,r4,6888
   29b98:	180b883a 	mov	r5,r3
   29b9c:	100d883a 	mov	r6,r2
   29ba0:	000f883a 	mov	r7,zero
   29ba4:	00259780 	call	25978 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);  
   29ba8:	e0bffd83 	ldbu	r2,-10(fp)
   29bac:	e13ffe17 	ldw	r4,-8(fp)
   29bb0:	100b883a 	mov	r5,r2
   29bb4:	00278e00 	call	278e0 <alt_tse_phy_wr_mdio_addr>
    
    return SUCCESS;
   29bb8:	0005883a 	mov	r2,zero
}
   29bbc:	e037883a 	mov	sp,fp
   29bc0:	dfc00117 	ldw	ra,4(sp)
   29bc4:	df000017 	ldw	fp,0(sp)
   29bc8:	dec00204 	addi	sp,sp,8
   29bcc:	f800283a 	ret

00029bd0 <alt_tse_phy_set_adv_10>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_10(alt_tse_phy_info *pphy, alt_u8 enable) {
   29bd0:	defff504 	addi	sp,sp,-44
   29bd4:	dfc00a15 	stw	ra,40(sp)
   29bd8:	df000915 	stw	fp,36(sp)
   29bdc:	df000904 	addi	fp,sp,36
   29be0:	e13ffe15 	stw	r4,-8(fp)
   29be4:	2805883a 	mov	r2,r5
   29be8:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
   29bec:	e0bffe17 	ldw	r2,-8(fp)
   29bf0:	10800617 	ldw	r2,24(r2)
   29bf4:	e0bff815 	stw	r2,-32(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
   29bf8:	e0bff817 	ldw	r2,-32(fp)
   29bfc:	10800317 	ldw	r2,12(r2)
   29c00:	e0bff915 	stw	r2,-28(fp)
    
    /* get index of the pointers in pointer array list */
    int mac_info_index = alt_tse_get_mac_info_index(pmac_info);
   29c04:	e13ff817 	ldw	r4,-32(fp)
   29c08:	0026b600 	call	26b60 <alt_tse_get_mac_info_index>
   29c0c:	e0bffa15 	stw	r2,-24(fp)
    int mac_group_index = alt_tse_get_mac_group_index(pmac_group);
   29c10:	e13ff917 	ldw	r4,-28(fp)
   29c14:	0026aec0 	call	26aec <alt_tse_get_mac_group_index>
   29c18:	e0bffb15 	stw	r2,-20(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    int mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
   29c1c:	e13ffe17 	ldw	r4,-8(fp)
   29c20:	00278980 	call	27898 <alt_tse_phy_rd_mdio_addr>
   29c24:	e0bffc15 	stw	r2,-16(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
   29c28:	e0bffe17 	ldw	r2,-8(fp)
   29c2c:	10800003 	ldbu	r2,0(r2)
   29c30:	10803fcc 	andi	r2,r2,255
   29c34:	e13ffe17 	ldw	r4,-8(fp)
   29c38:	100b883a 	mov	r5,r2
   29c3c:	00278e00 	call	278e0 <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
   29c40:	e0bfff03 	ldbu	r2,-4(fp)
   29c44:	10002926 	beq	r2,zero,29cec <alt_tse_phy_set_adv_10+0x11c>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_FULL, 1);
   29c48:	e13ffe17 	ldw	r4,-8(fp)
   29c4c:	01400044 	movi	r5,1
   29c50:	01800304 	movi	r6,12
   29c54:	01c00044 	movi	r7,1
   29c58:	0027a640 	call	27a64 <alt_tse_phy_rd_mdio_reg>
   29c5c:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1, cap);
   29c60:	e0bffd03 	ldbu	r2,-12(fp)
   29c64:	d8800015 	stw	r2,0(sp)
   29c68:	e13ffe17 	ldw	r4,-8(fp)
   29c6c:	01400104 	movi	r5,4
   29c70:	01800184 	movi	r6,6
   29c74:	01c00044 	movi	r7,1
   29c78:	00279380 	call	27938 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
   29c7c:	e0bffd03 	ldbu	r2,-12(fp)
   29c80:	010000f4 	movhi	r4,3
   29c84:	2106cd04 	addi	r4,r4,6964
   29c88:	e17ffb17 	ldw	r5,-20(fp)
   29c8c:	e1bffa17 	ldw	r6,-24(fp)
   29c90:	100f883a 	mov	r7,r2
   29c94:	00259780 	call	25978 <no_printf>
    
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_HALF, 1);
   29c98:	e13ffe17 	ldw	r4,-8(fp)
   29c9c:	01400044 	movi	r5,1
   29ca0:	018002c4 	movi	r6,11
   29ca4:	01c00044 	movi	r7,1
   29ca8:	0027a640 	call	27a64 <alt_tse_phy_rd_mdio_reg>
   29cac:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1, cap);
   29cb0:	e0bffd03 	ldbu	r2,-12(fp)
   29cb4:	d8800015 	stw	r2,0(sp)
   29cb8:	e13ffe17 	ldw	r4,-8(fp)
   29cbc:	01400104 	movi	r5,4
   29cc0:	01800144 	movi	r6,5
   29cc4:	01c00044 	movi	r7,1
   29cc8:	00279380 	call	27938 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
   29ccc:	e0bffd03 	ldbu	r2,-12(fp)
   29cd0:	010000f4 	movhi	r4,3
   29cd4:	2106e004 	addi	r4,r4,7040
   29cd8:	e17ffb17 	ldw	r5,-20(fp)
   29cdc:	e1bffa17 	ldw	r6,-24(fp)
   29ce0:	100f883a 	mov	r7,r2
   29ce4:	00259780 	call	25978 <no_printf>
   29ce8:	00001806 	br	29d4c <alt_tse_phy_set_adv_10+0x17c>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1, 0);
   29cec:	d8000015 	stw	zero,0(sp)
   29cf0:	e13ffe17 	ldw	r4,-8(fp)
   29cf4:	01400104 	movi	r5,4
   29cf8:	01800184 	movi	r6,6
   29cfc:	01c00044 	movi	r7,1
   29d00:	00279380 	call	27938 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
   29d04:	010000f4 	movhi	r4,3
   29d08:	2106cd04 	addi	r4,r4,6964
   29d0c:	e17ffb17 	ldw	r5,-20(fp)
   29d10:	e1bffa17 	ldw	r6,-24(fp)
   29d14:	000f883a 	mov	r7,zero
   29d18:	00259780 	call	25978 <no_printf>
    
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1, 0);
   29d1c:	d8000015 	stw	zero,0(sp)
   29d20:	e13ffe17 	ldw	r4,-8(fp)
   29d24:	01400104 	movi	r5,4
   29d28:	01800144 	movi	r6,5
   29d2c:	01c00044 	movi	r7,1
   29d30:	00279380 	call	27938 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
   29d34:	010000f4 	movhi	r4,3
   29d38:	2106e004 	addi	r4,r4,7040
   29d3c:	e17ffb17 	ldw	r5,-20(fp)
   29d40:	e1bffa17 	ldw	r6,-24(fp)
   29d44:	000f883a 	mov	r7,zero
   29d48:	00259780 	call	25978 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
   29d4c:	e0bffc17 	ldw	r2,-16(fp)
   29d50:	10803fcc 	andi	r2,r2,255
   29d54:	e13ffe17 	ldw	r4,-8(fp)
   29d58:	100b883a 	mov	r5,r2
   29d5c:	00278e00 	call	278e0 <alt_tse_phy_wr_mdio_addr>
    
    return SUCCESS;
   29d60:	0005883a 	mov	r2,zero
}
   29d64:	e037883a 	mov	sp,fp
   29d68:	dfc00117 	ldw	ra,4(sp)
   29d6c:	df000017 	ldw	fp,0(sp)
   29d70:	dec00204 	addi	sp,sp,8
   29d74:	f800283a 	ret

00029d78 <alt_tse_phy_get_common_speed>:
/* @Function Description: Get the common speed supported by all PHYs connected to the MAC within the same group
 * @API Type:           Internal
 * @param pmac_group    Pointer to the TSE MAC Group structure which group all the MACs that should use the same speed
 * @return              common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if no common speed found
 */
alt_32 alt_tse_phy_get_common_speed(alt_tse_mac_group *pmac_group) {
   29d78:	defff604 	addi	sp,sp,-40
   29d7c:	dfc00915 	stw	ra,36(sp)
   29d80:	df000815 	stw	fp,32(sp)
   29d84:	df000804 	addi	fp,sp,32
   29d88:	e13fff15 	stw	r4,-4(fp)
    
	alt_32 i;
	alt_u8 common_1000 = 1;
   29d8c:	00800044 	movi	r2,1
   29d90:	e0bff905 	stb	r2,-28(fp)
	alt_u8 common_100 = 1;
   29d94:	00800044 	movi	r2,1
   29d98:	e0bff945 	stb	r2,-27(fp)
	alt_u8 common_10 = 1;
   29d9c:	00800044 	movi	r2,1
   29da0:	e0bff985 	stb	r2,-26(fp)
    
	alt_32 common_speed;
    
	alt_u8 none_an_complete = 1;
   29da4:	00800044 	movi	r2,1
   29da8:	e0bffb05 	stb	r2,-20(fp)
    
    alt_tse_mac_info *pmac_info = 0;
   29dac:	e03ffc15 	stw	zero,-16(fp)
    alt_tse_phy_info *pphy = 0;
   29db0:	e03ffd15 	stw	zero,-12(fp)
    
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
   29db4:	e13fff17 	ldw	r4,-4(fp)
   29db8:	0026aec0 	call	26aec <alt_tse_get_mac_group_index>
   29dbc:	e0bffe05 	stb	r2,-8(fp)
    
    /* reset Auto-Negotiation advertisement */
    for(i = 0; i < pmac_group->channel; i++) {
   29dc0:	e03ff815 	stw	zero,-32(fp)
   29dc4:	00001c06 	br	29e38 <alt_tse_phy_get_common_speed+0xc0>
        pmac_info = pmac_group->pmac_info[i];
   29dc8:	e0ffff17 	ldw	r3,-4(fp)
   29dcc:	e0bff817 	ldw	r2,-32(fp)
   29dd0:	10800044 	addi	r2,r2,1
   29dd4:	1085883a 	add	r2,r2,r2
   29dd8:	1085883a 	add	r2,r2,r2
   29ddc:	1885883a 	add	r2,r3,r2
   29de0:	10800017 	ldw	r2,0(r2)
   29de4:	e0bffc15 	stw	r2,-16(fp)
        pphy = pmac_info->pphy_info;
   29de8:	e0bffc17 	ldw	r2,-16(fp)
   29dec:	10800117 	ldw	r2,4(r2)
   29df0:	e0bffd15 	stw	r2,-12(fp)
        
        /* run only if PHY connected */
        if(pphy) {
   29df4:	e0bffd17 	ldw	r2,-12(fp)
   29df8:	10000926 	beq	r2,zero,29e20 <alt_tse_phy_get_common_speed+0xa8>
            alt_tse_phy_set_adv_1000(pphy, 1);
   29dfc:	e13ffd17 	ldw	r4,-12(fp)
   29e00:	01400044 	movi	r5,1
   29e04:	00297cc0 	call	297cc <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
   29e08:	e13ffd17 	ldw	r4,-12(fp)
   29e0c:	01400044 	movi	r5,1
   29e10:	00299880 	call	29988 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
   29e14:	e13ffd17 	ldw	r4,-12(fp)
   29e18:	01400044 	movi	r5,1
   29e1c:	0029bd00 	call	29bd0 <alt_tse_phy_set_adv_10>
        }
        tse_dprintf(6, "\n");
   29e20:	010000f4 	movhi	r4,3
   29e24:	21048604 	addi	r4,r4,4632
   29e28:	00259780 	call	25978 <no_printf>
    alt_tse_phy_info *pphy = 0;
    
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    
    /* reset Auto-Negotiation advertisement */
    for(i = 0; i < pmac_group->channel; i++) {
   29e2c:	e0bff817 	ldw	r2,-32(fp)
   29e30:	10800044 	addi	r2,r2,1
   29e34:	e0bff815 	stw	r2,-32(fp)
   29e38:	e0bfff17 	ldw	r2,-4(fp)
   29e3c:	10800003 	ldbu	r2,0(r2)
   29e40:	10803fcc 	andi	r2,r2,255
   29e44:	e0fff817 	ldw	r3,-32(fp)
   29e48:	18bfdf16 	blt	r3,r2,29dc8 <alt_tse_phy_get_common_speed+0x50>
        }
        tse_dprintf(6, "\n");
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
   29e4c:	e03ff815 	stw	zero,-32(fp)
   29e50:	00005606 	br	29fac <alt_tse_phy_get_common_speed+0x234>

        pmac_info = pmac_group->pmac_info[i];
   29e54:	e0ffff17 	ldw	r3,-4(fp)
   29e58:	e0bff817 	ldw	r2,-32(fp)
   29e5c:	10800044 	addi	r2,r2,1
   29e60:	1085883a 	add	r2,r2,r2
   29e64:	1085883a 	add	r2,r2,r2
   29e68:	1885883a 	add	r2,r3,r2
   29e6c:	10800017 	ldw	r2,0(r2)
   29e70:	e0bffc15 	stw	r2,-16(fp)
        pphy = pmac_info->pphy_info;
   29e74:	e0bffc17 	ldw	r2,-16(fp)
   29e78:	10800117 	ldw	r2,4(r2)
   29e7c:	e0bffd15 	stw	r2,-12(fp)
        
        /* if no PHY connected */
        if(!pphy) {
   29e80:	e0bffd17 	ldw	r2,-12(fp)
   29e84:	10004326 	beq	r2,zero,29f94 <alt_tse_phy_get_common_speed+0x21c>
            continue;
        }
        
        /* get PHY capability */
        /* skip for PHY with Auto-Negotiation not completed */
        if(alt_tse_phy_get_cap(pphy) != TSE_PHY_AN_COMPLETE) {
   29e88:	e13ffd17 	ldw	r4,-12(fp)
   29e8c:	00292340 	call	29234 <alt_tse_phy_get_cap>
   29e90:	1000421e 	bne	r2,zero,29f9c <alt_tse_phy_get_common_speed+0x224>
            continue;
        }
        
        none_an_complete = 0;
   29e94:	e03ffb05 	stb	zero,-20(fp)
        
        /* Small MAC */
        if(pmac_info->mac_type == ALTERA_TSE_MACLITE_10_100) {
   29e98:	e0bffc17 	ldw	r2,-16(fp)
   29e9c:	10800003 	ldbu	r2,0(r2)
   29ea0:	10803fcc 	andi	r2,r2,255
   29ea4:	10800058 	cmpnei	r2,r2,1
   29ea8:	1000021e 	bne	r2,zero,29eb4 <alt_tse_phy_get_common_speed+0x13c>
            common_1000 = 0;
   29eac:	e03ff905 	stb	zero,-28(fp)
   29eb0:	00000706 	br	29ed0 <alt_tse_phy_get_common_speed+0x158>
        }
        else if(pmac_info->mac_type == ALTERA_TSE_MACLITE_1000) {
   29eb4:	e0bffc17 	ldw	r2,-16(fp)
   29eb8:	10800003 	ldbu	r2,0(r2)
   29ebc:	10803fcc 	andi	r2,r2,255
   29ec0:	10800098 	cmpnei	r2,r2,2
   29ec4:	1000021e 	bne	r2,zero,29ed0 <alt_tse_phy_get_common_speed+0x158>
            common_100 = 0;
   29ec8:	e03ff945 	stb	zero,-27(fp)
            common_10 = 0;            
   29ecc:	e03ff985 	stb	zero,-26(fp)
        }
        
        /* get common capabilities for all PHYs and link partners */
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
   29ed0:	e0bffd17 	ldw	r2,-12(fp)
   29ed4:	10c000c3 	ldbu	r3,3(r2)
   29ed8:	e0bffd17 	ldw	r2,-12(fp)
   29edc:	10800303 	ldbu	r2,12(r2)
   29ee0:	1884703a 	and	r2,r3,r2
   29ee4:	1007883a 	mov	r3,r2
   29ee8:	e0bff903 	ldbu	r2,-28(fp)
   29eec:	1884703a 	and	r2,r3,r2
   29ef0:	e0bff905 	stb	r2,-28(fp)
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
   29ef4:	e0bffd17 	ldw	r2,-12(fp)
   29ef8:	10c00183 	ldbu	r3,6(r2)
   29efc:	e0bffd17 	ldw	r2,-12(fp)
   29f00:	108003c3 	ldbu	r2,15(r2)
   29f04:	1884703a 	and	r2,r3,r2
   29f08:	1007883a 	mov	r3,r2
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
   29f0c:	e0bffd17 	ldw	r2,-12(fp)
   29f10:	110001c3 	ldbu	r4,7(r2)
   29f14:	e0bffd17 	ldw	r2,-12(fp)
   29f18:	10800403 	ldbu	r2,16(r2)
        }
        
        /* get common capabilities for all PHYs and link partners */
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
   29f1c:	2084703a 	and	r2,r4,r2
   29f20:	1884b03a 	or	r2,r3,r2
   29f24:	1007883a 	mov	r3,r2
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
                        (pphy->link_capability.cap_100_base_t4 & pphy->link_capability.lp_100_base_t4));
   29f28:	e0bffd17 	ldw	r2,-12(fp)
   29f2c:	11000143 	ldbu	r4,5(r2)
   29f30:	e0bffd17 	ldw	r2,-12(fp)
   29f34:	10800383 	ldbu	r2,14(r2)
        }
        
        /* get common capabilities for all PHYs and link partners */
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
   29f38:	2084703a 	and	r2,r4,r2
   29f3c:	1884b03a 	or	r2,r3,r2
   29f40:	1007883a 	mov	r3,r2
   29f44:	e0bff943 	ldbu	r2,-27(fp)
   29f48:	1884703a 	and	r2,r3,r2
   29f4c:	e0bff945 	stb	r2,-27(fp)
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
                        (pphy->link_capability.cap_100_base_t4 & pphy->link_capability.lp_100_base_t4));
        common_10 &= ((pphy->link_capability.cap_10_base_t_full & pphy->link_capability.lp_10_base_tx_full) |
   29f50:	e0bffd17 	ldw	r2,-12(fp)
   29f54:	10c00283 	ldbu	r3,10(r2)
   29f58:	e0bffd17 	ldw	r2,-12(fp)
   29f5c:	10800443 	ldbu	r2,17(r2)
   29f60:	1884703a 	and	r2,r3,r2
   29f64:	1007883a 	mov	r3,r2
                        (pphy->link_capability.cap_10_base_t_half & pphy->link_capability.lp_10_base_tx_half));
   29f68:	e0bffd17 	ldw	r2,-12(fp)
   29f6c:	110002c3 	ldbu	r4,11(r2)
   29f70:	e0bffd17 	ldw	r2,-12(fp)
   29f74:	10800483 	ldbu	r2,18(r2)
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
                        (pphy->link_capability.cap_100_base_t4 & pphy->link_capability.lp_100_base_t4));
        common_10 &= ((pphy->link_capability.cap_10_base_t_full & pphy->link_capability.lp_10_base_tx_full) |
   29f78:	2084703a 	and	r2,r4,r2
   29f7c:	1884b03a 	or	r2,r3,r2
   29f80:	1007883a 	mov	r3,r2
   29f84:	e0bff983 	ldbu	r2,-26(fp)
   29f88:	1884703a 	and	r2,r3,r2
   29f8c:	e0bff985 	stb	r2,-26(fp)
   29f90:	00000306 	br	29fa0 <alt_tse_phy_get_common_speed+0x228>
        pmac_info = pmac_group->pmac_info[i];
        pphy = pmac_info->pphy_info;
        
        /* if no PHY connected */
        if(!pphy) {
            continue;
   29f94:	0001883a 	nop
   29f98:	00000106 	br	29fa0 <alt_tse_phy_get_common_speed+0x228>
        }
        
        /* get PHY capability */
        /* skip for PHY with Auto-Negotiation not completed */
        if(alt_tse_phy_get_cap(pphy) != TSE_PHY_AN_COMPLETE) {
            continue;
   29f9c:	0001883a 	nop
        }
        tse_dprintf(6, "\n");
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
   29fa0:	e0bff817 	ldw	r2,-32(fp)
   29fa4:	10800044 	addi	r2,r2,1
   29fa8:	e0bff815 	stw	r2,-32(fp)
   29fac:	e0bfff17 	ldw	r2,-4(fp)
   29fb0:	10800003 	ldbu	r2,0(r2)
   29fb4:	10803fcc 	andi	r2,r2,255
   29fb8:	e0fff817 	ldw	r3,-32(fp)
   29fbc:	18bfa516 	blt	r3,r2,29e54 <alt_tse_phy_get_common_speed+0xdc>
                        (pphy->link_capability.cap_10_base_t_half & pphy->link_capability.lp_10_base_tx_half));

    }
    
    /* get common speed based on capabilities */
    if(none_an_complete == 1) {
   29fc0:	e0bffb03 	ldbu	r2,-20(fp)
   29fc4:	10800058 	cmpnei	r2,r2,1
   29fc8:	1000081e 	bne	r2,zero,29fec <alt_tse_phy_get_common_speed+0x274>
        common_speed = TSE_PHY_SPEED_NO_COMMON;
   29fcc:	00bfffc4 	movi	r2,-1
   29fd0:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(2, "ERROR   : MAC Group[%d] - None of the PHYs Auto-Negotiation completed!\n", mac_group_index);
   29fd4:	e0bffe07 	ldb	r2,-8(fp)
   29fd8:	010000f4 	movhi	r4,3
   29fdc:	2106f304 	addi	r4,r4,7116
   29fe0:	100b883a 	mov	r5,r2
   29fe4:	00170680 	call	17068 <printf>
   29fe8:	00002706 	br	2a088 <alt_tse_phy_get_common_speed+0x310>
    }
    else if(common_1000) {
   29fec:	e0bff903 	ldbu	r2,-28(fp)
   29ff0:	10000926 	beq	r2,zero,2a018 <alt_tse_phy_get_common_speed+0x2a0>
        common_speed = TSE_PHY_SPEED_1000;
   29ff4:	00800084 	movi	r2,2
   29ff8:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 1000);
   29ffc:	e0bffe07 	ldb	r2,-8(fp)
   2a000:	010000f4 	movhi	r4,3
   2a004:	21070504 	addi	r4,r4,7188
   2a008:	100b883a 	mov	r5,r2
   2a00c:	0180fa04 	movi	r6,1000
   2a010:	00170680 	call	17068 <printf>
   2a014:	00001c06 	br	2a088 <alt_tse_phy_get_common_speed+0x310>
    }
    else if(common_100) {
   2a018:	e0bff943 	ldbu	r2,-27(fp)
   2a01c:	10000926 	beq	r2,zero,2a044 <alt_tse_phy_get_common_speed+0x2cc>
        common_speed = TSE_PHY_SPEED_100;
   2a020:	00800044 	movi	r2,1
   2a024:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 100);
   2a028:	e0bffe07 	ldb	r2,-8(fp)
   2a02c:	010000f4 	movhi	r4,3
   2a030:	21070504 	addi	r4,r4,7188
   2a034:	100b883a 	mov	r5,r2
   2a038:	01801904 	movi	r6,100
   2a03c:	00170680 	call	17068 <printf>
   2a040:	00001106 	br	2a088 <alt_tse_phy_get_common_speed+0x310>
    }
    else if(common_10) {
   2a044:	e0bff983 	ldbu	r2,-26(fp)
   2a048:	10000826 	beq	r2,zero,2a06c <alt_tse_phy_get_common_speed+0x2f4>
        common_speed = TSE_PHY_SPEED_10;
   2a04c:	e03ffa15 	stw	zero,-24(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 10);
   2a050:	e0bffe07 	ldb	r2,-8(fp)
   2a054:	010000f4 	movhi	r4,3
   2a058:	21070504 	addi	r4,r4,7188
   2a05c:	100b883a 	mov	r5,r2
   2a060:	01800284 	movi	r6,10
   2a064:	00170680 	call	17068 <printf>
   2a068:	00000706 	br	2a088 <alt_tse_phy_get_common_speed+0x310>
    }
    else {
        common_speed = TSE_PHY_SPEED_NO_COMMON;
   2a06c:	00bfffc4 	movi	r2,-1
   2a070:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(2, "ERROR   : MAC Group[%d] - No common speed at all!\n", mac_group_index);    }
   2a074:	e0bffe07 	ldb	r2,-8(fp)
   2a078:	010000f4 	movhi	r4,3
   2a07c:	21071204 	addi	r4,r4,7240
   2a080:	100b883a 	mov	r5,r2
   2a084:	00170680 	call	17068 <printf>

    return common_speed;
   2a088:	e0bffa17 	ldw	r2,-24(fp)
}
   2a08c:	e037883a 	mov	sp,fp
   2a090:	dfc00117 	ldw	ra,4(sp)
   2a094:	df000017 	ldw	fp,0(sp)
   2a098:	dec00204 	addi	sp,sp,8
   2a09c:	f800283a 	ret

0002a0a0 <alt_tse_phy_set_common_speed>:
 * @API Type:               Internal
 * @param pmac_group        Pointer to the TSE MAC Group structure which group all the MACs that should use the same speed
 *        common_speed      common speed supported by all PHYs
 * @return      common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if invalid common speed specified
 */
alt_32 alt_tse_phy_set_common_speed(alt_tse_mac_group *pmac_group, alt_32 common_speed) {
   2a0a0:	defff004 	addi	sp,sp,-64
   2a0a4:	dfc00f15 	stw	ra,60(sp)
   2a0a8:	df000e15 	stw	fp,56(sp)
   2a0ac:	dc400d15 	stw	r17,52(sp)
   2a0b0:	dc000c15 	stw	r16,48(sp)
   2a0b4:	df000c04 	addi	fp,sp,48
   2a0b8:	e13ffe15 	stw	r4,-8(fp)
   2a0bc:	e17fff15 	stw	r5,-4(fp)
	alt_u8 speed;
	alt_u8 duplex;
    
	alt_u8 gb_capable;
    
    alt_tse_phy_info *pphy = 0;
   2a0c0:	e03ff715 	stw	zero,-36(fp)
    alt_tse_mac_info *pmac_info = 0;
   2a0c4:	e03ff815 	stw	zero,-32(fp)
    alt_tse_system_info *psys = 0;
   2a0c8:	e03ff915 	stw	zero,-28(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
   2a0cc:	e03ffa05 	stb	zero,-24(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
   2a0d0:	e13ffe17 	ldw	r4,-8(fp)
   2a0d4:	0026aec0 	call	26aec <alt_tse_get_mac_group_index>
   2a0d8:	e0bffa45 	stb	r2,-23(fp)
         
    /* Record previous MDIO address, to be restored at the end of function */
    np_tse_mac *pmac_group_base = (np_tse_mac *)pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   2a0dc:	e0bffe17 	ldw	r2,-8(fp)
   2a0e0:	10800117 	ldw	r2,4(r2)
   2a0e4:	10800217 	ldw	r2,8(r2)
   2a0e8:	10800017 	ldw	r2,0(r2)
   2a0ec:	e0bffb15 	stw	r2,-20(fp)
    alt_32 mdioadd_prev = IORD(&pmac_group_base->MDIO_ADDR1, 0);
   2a0f0:	e0bffb17 	ldw	r2,-20(fp)
   2a0f4:	10801004 	addi	r2,r2,64
   2a0f8:	10800037 	ldwio	r2,0(r2)
   2a0fc:	e0bffc15 	stw	r2,-16(fp)
    
    if((common_speed < TSE_PHY_SPEED_10) || (common_speed > TSE_PHY_SPEED_1000)) {
   2a100:	e0bfff17 	ldw	r2,-4(fp)
   2a104:	10000316 	blt	r2,zero,2a114 <alt_tse_phy_set_common_speed+0x74>
   2a108:	e0bfff17 	ldw	r2,-4(fp)
   2a10c:	108000d0 	cmplti	r2,r2,3
   2a110:	10000c1e 	bne	r2,zero,2a144 <alt_tse_phy_set_common_speed+0xa4>
        tse_dprintf(2, "ERROR   : MAC Group[%d] - Invalid common speed specified! common speed = %d\n", mac_group_index, (int)common_speed);
   2a114:	e0bffa47 	ldb	r2,-23(fp)
   2a118:	010000f4 	movhi	r4,3
   2a11c:	21071f04 	addi	r4,r4,7292
   2a120:	100b883a 	mov	r5,r2
   2a124:	e1bfff17 	ldw	r6,-4(fp)
   2a128:	00170680 	call	17068 <printf>
		/* Restore previous MDIO address */
		IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
   2a12c:	e0bffb17 	ldw	r2,-20(fp)
   2a130:	10801004 	addi	r2,r2,64
   2a134:	e0fffc17 	ldw	r3,-16(fp)
   2a138:	10c00035 	stwio	r3,0(r2)
        return TSE_PHY_SPEED_NO_COMMON;
   2a13c:	00bfffc4 	movi	r2,-1
   2a140:	0000fe06 	br	2a53c <alt_tse_phy_set_common_speed+0x49c>
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
   2a144:	e03ff515 	stw	zero,-44(fp)
   2a148:	0000dc06 	br	2a4bc <alt_tse_phy_set_common_speed+0x41c>
        pmac_info = pmac_group->pmac_info[i];
   2a14c:	e0fffe17 	ldw	r3,-8(fp)
   2a150:	e0bff517 	ldw	r2,-44(fp)
   2a154:	10800044 	addi	r2,r2,1
   2a158:	1085883a 	add	r2,r2,r2
   2a15c:	1085883a 	add	r2,r2,r2
   2a160:	1885883a 	add	r2,r3,r2
   2a164:	10800017 	ldw	r2,0(r2)
   2a168:	e0bff815 	stw	r2,-32(fp)
        mac_info_index = alt_tse_get_mac_info_index(pmac_info);
   2a16c:	e13ff817 	ldw	r4,-32(fp)
   2a170:	0026b600 	call	26b60 <alt_tse_get_mac_info_index>
   2a174:	e0bffa05 	stb	r2,-24(fp)

        pphy = pmac_info->pphy_info;
   2a178:	e0bff817 	ldw	r2,-32(fp)
   2a17c:	10800117 	ldw	r2,4(r2)
   2a180:	e0bff715 	stw	r2,-36(fp)
        
        /* if no PHY connected */
        if(!pphy) {
   2a184:	e0bff717 	ldw	r2,-36(fp)
   2a188:	1000c826 	beq	r2,zero,2a4ac <alt_tse_phy_set_common_speed+0x40c>
            continue;
        }
        
        psys = pmac_info->psys_info; 
   2a18c:	e0bff817 	ldw	r2,-32(fp)
   2a190:	10800217 	ldw	r2,8(r2)
   2a194:	e0bff915 	stw	r2,-28(fp)
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
   2a198:	e0bff717 	ldw	r2,-36(fp)
   2a19c:	10800003 	ldbu	r2,0(r2)
   2a1a0:	10803fcc 	andi	r2,r2,255
   2a1a4:	e13ff717 	ldw	r4,-36(fp)
   2a1a8:	100b883a 	mov	r5,r2
   2a1ac:	00278e00 	call	278e0 <alt_tse_phy_wr_mdio_addr>

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
   2a1b0:	e0bff717 	ldw	r2,-36(fp)
   2a1b4:	108000c3 	ldbu	r2,3(r2)
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
   2a1b8:	10803fcc 	andi	r2,r2,255
   2a1bc:	10000c1e 	bne	r2,zero,2a1f0 <alt_tse_phy_set_common_speed+0x150>
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
   2a1c0:	e0bff717 	ldw	r2,-36(fp)
   2a1c4:	10800103 	ldbu	r2,4(r2)
   2a1c8:	10803fcc 	andi	r2,r2,255
   2a1cc:	1000081e 	bne	r2,zero,2a1f0 <alt_tse_phy_set_common_speed+0x150>
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
   2a1d0:	e0bff717 	ldw	r2,-36(fp)
   2a1d4:	10800043 	ldbu	r2,1(r2)
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
   2a1d8:	10803fcc 	andi	r2,r2,255
   2a1dc:	1000041e 	bne	r2,zero,2a1f0 <alt_tse_phy_set_common_speed+0x150>
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
   2a1e0:	e0bff717 	ldw	r2,-36(fp)
   2a1e4:	10800083 	ldbu	r2,2(r2)
   2a1e8:	10803fcc 	andi	r2,r2,255
   2a1ec:	10000226 	beq	r2,zero,2a1f8 <alt_tse_phy_set_common_speed+0x158>
   2a1f0:	00800044 	movi	r2,1
   2a1f4:	00000106 	br	2a1fc <alt_tse_phy_set_common_speed+0x15c>
   2a1f8:	0005883a 	mov	r2,zero
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
   2a1fc:	e0bffd05 	stb	r2,-12(fp)
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
        
        /* if PHY does not supports 1000 Mbps, and common speed is 1000 Mbps */
        if((!gb_capable) && (common_speed == TSE_PHY_SPEED_1000)) {
   2a200:	e0bffd03 	ldbu	r2,-12(fp)
   2a204:	1000101e 	bne	r2,zero,2a248 <alt_tse_phy_set_common_speed+0x1a8>
   2a208:	e0bfff17 	ldw	r2,-4(fp)
   2a20c:	10800098 	cmpnei	r2,r2,2
   2a210:	10000d1e 	bne	r2,zero,2a248 <alt_tse_phy_set_common_speed+0x1a8>
            tse_dprintf(2, "ERROR   : PHY[%d.%d] - PHY does not support 1000 Mbps, please specify valid common speed\n", mac_group_index, mac_info_index);
   2a214:	e0fffa47 	ldb	r3,-23(fp)
   2a218:	e0bffa07 	ldb	r2,-24(fp)
   2a21c:	010000f4 	movhi	r4,3
   2a220:	21073304 	addi	r4,r4,7372
   2a224:	180b883a 	mov	r5,r3
   2a228:	100d883a 	mov	r6,r2
   2a22c:	00170680 	call	17068 <printf>
			/* Restore previous MDIO address */
			IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
   2a230:	e0bffb17 	ldw	r2,-20(fp)
   2a234:	10801004 	addi	r2,r2,64
   2a238:	e0fffc17 	ldw	r3,-16(fp)
   2a23c:	10c00035 	stwio	r3,0(r2)
            return TSE_PHY_SPEED_NO_COMMON;
   2a240:	00bfffc4 	movi	r2,-1
   2a244:	0000bd06 	br	2a53c <alt_tse_phy_set_common_speed+0x49c>
        }
        
        /* if PHY is not Auto-Negotiation capable */
        if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
   2a248:	e13ff717 	ldw	r4,-36(fp)
   2a24c:	01400044 	movi	r5,1
   2a250:	018000c4 	movi	r6,3
   2a254:	01c00044 	movi	r7,1
   2a258:	0027a640 	call	27a64 <alt_tse_phy_rd_mdio_reg>
   2a25c:	1000141e 	bne	r2,zero,2a2b0 <alt_tse_phy_set_common_speed+0x210>
            
            /* if PHY supports 1000 Mbps, write msb of speed */
            if(gb_capable) {
   2a260:	e0bffd03 	ldbu	r2,-12(fp)
   2a264:	10000926 	beq	r2,zero,2a28c <alt_tse_phy_set_common_speed+0x1ec>
                alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_SPEED_MSB, 1, common_speed >> 1);
   2a268:	e0bfff17 	ldw	r2,-4(fp)
   2a26c:	1005d07a 	srai	r2,r2,1
   2a270:	10bfffcc 	andi	r2,r2,65535
   2a274:	d8800015 	stw	r2,0(sp)
   2a278:	e13ff717 	ldw	r4,-36(fp)
   2a27c:	000b883a 	mov	r5,zero
   2a280:	01800184 	movi	r6,6
   2a284:	01c00044 	movi	r7,1
   2a288:	00279380 	call	27938 <alt_tse_phy_wr_mdio_reg>
            }
            /* write lsb of speed */
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_SPEED_LSB, 1, common_speed);
   2a28c:	e0bfff17 	ldw	r2,-4(fp)
   2a290:	10bfffcc 	andi	r2,r2,65535
   2a294:	d8800015 	stw	r2,0(sp)
   2a298:	e13ff717 	ldw	r4,-36(fp)
   2a29c:	000b883a 	mov	r5,zero
   2a2a0:	01800344 	movi	r6,13
   2a2a4:	01c00044 	movi	r7,1
   2a2a8:	00279380 	call	27938 <alt_tse_phy_wr_mdio_reg>
            
            /* continue to next PHY */
            continue;
   2a2ac:	00008006 	br	2a4b0 <alt_tse_phy_set_common_speed+0x410>
        }
        
        /* set Auto-Negotiation advertisement based on common speed */
        if(common_speed == TSE_PHY_SPEED_1000) {
   2a2b0:	e0bfff17 	ldw	r2,-4(fp)
   2a2b4:	10800098 	cmpnei	r2,r2,2
   2a2b8:	10000a1e 	bne	r2,zero,2a2e4 <alt_tse_phy_set_common_speed+0x244>
            alt_tse_phy_set_adv_1000(pphy, 1);
   2a2bc:	e13ff717 	ldw	r4,-36(fp)
   2a2c0:	01400044 	movi	r5,1
   2a2c4:	00297cc0 	call	297cc <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
   2a2c8:	e13ff717 	ldw	r4,-36(fp)
   2a2cc:	01400044 	movi	r5,1
   2a2d0:	00299880 	call	29988 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
   2a2d4:	e13ff717 	ldw	r4,-36(fp)
   2a2d8:	01400044 	movi	r5,1
   2a2dc:	0029bd00 	call	29bd0 <alt_tse_phy_set_adv_10>
   2a2e0:	00002206 	br	2a36c <alt_tse_phy_set_common_speed+0x2cc>
        }
        else if(common_speed == TSE_PHY_SPEED_100) {
   2a2e4:	e0bfff17 	ldw	r2,-4(fp)
   2a2e8:	10800058 	cmpnei	r2,r2,1
   2a2ec:	10000a1e 	bne	r2,zero,2a318 <alt_tse_phy_set_common_speed+0x278>
            alt_tse_phy_set_adv_1000(pphy, 0);
   2a2f0:	e13ff717 	ldw	r4,-36(fp)
   2a2f4:	000b883a 	mov	r5,zero
   2a2f8:	00297cc0 	call	297cc <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
   2a2fc:	e13ff717 	ldw	r4,-36(fp)
   2a300:	01400044 	movi	r5,1
   2a304:	00299880 	call	29988 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
   2a308:	e13ff717 	ldw	r4,-36(fp)
   2a30c:	01400044 	movi	r5,1
   2a310:	0029bd00 	call	29bd0 <alt_tse_phy_set_adv_10>
   2a314:	00001506 	br	2a36c <alt_tse_phy_set_common_speed+0x2cc>
        }    
        else if(common_speed == TSE_PHY_SPEED_10) {
   2a318:	e0bfff17 	ldw	r2,-4(fp)
   2a31c:	10000a1e 	bne	r2,zero,2a348 <alt_tse_phy_set_common_speed+0x2a8>
            alt_tse_phy_set_adv_1000(pphy, 0);
   2a320:	e13ff717 	ldw	r4,-36(fp)
   2a324:	000b883a 	mov	r5,zero
   2a328:	00297cc0 	call	297cc <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 0);
   2a32c:	e13ff717 	ldw	r4,-36(fp)
   2a330:	000b883a 	mov	r5,zero
   2a334:	00299880 	call	29988 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
   2a338:	e13ff717 	ldw	r4,-36(fp)
   2a33c:	01400044 	movi	r5,1
   2a340:	0029bd00 	call	29bd0 <alt_tse_phy_set_adv_10>
   2a344:	00000906 	br	2a36c <alt_tse_phy_set_common_speed+0x2cc>
        }
        else {
            alt_tse_phy_set_adv_1000(pphy, 0);
   2a348:	e13ff717 	ldw	r4,-36(fp)
   2a34c:	000b883a 	mov	r5,zero
   2a350:	00297cc0 	call	297cc <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 0);
   2a354:	e13ff717 	ldw	r4,-36(fp)
   2a358:	000b883a 	mov	r5,zero
   2a35c:	00299880 	call	29988 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 0);
   2a360:	e13ff717 	ldw	r4,-36(fp)
   2a364:	000b883a 	mov	r5,zero
   2a368:	0029bd00 	call	29bd0 <alt_tse_phy_set_adv_10>
        }
        
        /* if PHY Auto-Negotiation is completed */
        if(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 1) {
   2a36c:	e13ff717 	ldw	r4,-36(fp)
   2a370:	01400044 	movi	r5,1
   2a374:	01800144 	movi	r6,5
   2a378:	01c00044 	movi	r7,1
   2a37c:	0027a640 	call	27a64 <alt_tse_phy_rd_mdio_reg>
   2a380:	10800058 	cmpnei	r2,r2,1
   2a384:	10003b1e 	bne	r2,zero,2a474 <alt_tse_phy_set_common_speed+0x3d4>
            
            /* read both msb and lsb of speed bits if PHY support 1000 Mbps */
            if(gb_capable) {
   2a388:	e0bffd03 	ldbu	r2,-12(fp)
   2a38c:	10000f26 	beq	r2,zero,2a3cc <alt_tse_phy_set_common_speed+0x32c>
        
                /* get speed information after Auto-Negotiation */
                speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 2);
   2a390:	e0bff717 	ldw	r2,-36(fp)
   2a394:	10800517 	ldw	r2,20(r2)
   2a398:	10801583 	ldbu	r2,86(r2)
   2a39c:	10c03fcc 	andi	r3,r2,255
   2a3a0:	e0bff717 	ldw	r2,-36(fp)
   2a3a4:	10800517 	ldw	r2,20(r2)
   2a3a8:	108015c3 	ldbu	r2,87(r2)
   2a3ac:	10803fcc 	andi	r2,r2,255
   2a3b0:	e13ff717 	ldw	r4,-36(fp)
   2a3b4:	180b883a 	mov	r5,r3
   2a3b8:	100d883a 	mov	r6,r2
   2a3bc:	01c00084 	movi	r7,2
   2a3c0:	0027a640 	call	27a64 <alt_tse_phy_rd_mdio_reg>
   2a3c4:	e0bff605 	stb	r2,-40(fp)
   2a3c8:	00000e06 	br	2a404 <alt_tse_phy_set_common_speed+0x364>
            }
            
            /* read lsb of speed only if PHY support only 10/100 Mbps */
            else {
                /* get speed and link information after Auto-Negotiation */
                speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 1);
   2a3cc:	e0bff717 	ldw	r2,-36(fp)
   2a3d0:	10800517 	ldw	r2,20(r2)
   2a3d4:	10801583 	ldbu	r2,86(r2)
   2a3d8:	10c03fcc 	andi	r3,r2,255
   2a3dc:	e0bff717 	ldw	r2,-36(fp)
   2a3e0:	10800517 	ldw	r2,20(r2)
   2a3e4:	108015c3 	ldbu	r2,87(r2)
   2a3e8:	10803fcc 	andi	r2,r2,255
   2a3ec:	e13ff717 	ldw	r4,-36(fp)
   2a3f0:	180b883a 	mov	r5,r3
   2a3f4:	100d883a 	mov	r6,r2
   2a3f8:	01c00044 	movi	r7,1
   2a3fc:	0027a640 	call	27a64 <alt_tse_phy_rd_mdio_reg>
   2a400:	e0bff605 	stb	r2,-40(fp)
            }
            
            /* if current speed != common speed, then restart Auto-Negotiation */
            if(speed != common_speed) {
   2a404:	e0fff603 	ldbu	r3,-40(fp)
   2a408:	e0bfff17 	ldw	r2,-4(fp)
   2a40c:	18800426 	beq	r3,r2,2a420 <alt_tse_phy_set_common_speed+0x380>
                alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
   2a410:	e13ff717 	ldw	r4,-36(fp)
   2a414:	01400134 	movhi	r5,4
   2a418:	29742404 	addi	r5,r5,-12144
   2a41c:	0028f100 	call	28f10 <alt_tse_phy_restart_an>
            }
            
            /* get speed information after Auto-Negotiation */
            duplex = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->duplex_bit_location, 1);
   2a420:	e0bff717 	ldw	r2,-36(fp)
   2a424:	10800517 	ldw	r2,20(r2)
   2a428:	10801583 	ldbu	r2,86(r2)
   2a42c:	10c03fcc 	andi	r3,r2,255
   2a430:	e0bff717 	ldw	r2,-36(fp)
   2a434:	10800517 	ldw	r2,20(r2)
   2a438:	10801603 	ldbu	r2,88(r2)
   2a43c:	10803fcc 	andi	r2,r2,255
   2a440:	e13ff717 	ldw	r4,-36(fp)
   2a444:	180b883a 	mov	r5,r3
   2a448:	100d883a 	mov	r6,r2
   2a44c:	01c00044 	movi	r7,1
   2a450:	0027a640 	call	27a64 <alt_tse_phy_rd_mdio_reg>
   2a454:	e0bffd45 	stb	r2,-11(fp)
            
            /* Set MAC duplex register */
            alt_tse_mac_set_duplex((np_tse_mac *)psys->tse_mac_base, duplex);
   2a458:	e0bff917 	ldw	r2,-28(fp)
   2a45c:	10800017 	ldw	r2,0(r2)
   2a460:	1007883a 	mov	r3,r2
   2a464:	e0bffd43 	ldbu	r2,-11(fp)
   2a468:	1809883a 	mov	r4,r3
   2a46c:	100b883a 	mov	r5,r2
   2a470:	0026d980 	call	26d98 <alt_tse_mac_set_duplex>
            
        }
        tse_dprintf(5, "INFO    : PHY[%d.%d] - PHY STATUS = 0x%04x\n\n", mac_group_index, mac_info_index, (int) alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, 0, 16));        
   2a474:	e47ffa47 	ldb	r17,-23(fp)
   2a478:	e43ffa07 	ldb	r16,-24(fp)
   2a47c:	e13ff717 	ldw	r4,-36(fp)
   2a480:	01400044 	movi	r5,1
   2a484:	000d883a 	mov	r6,zero
   2a488:	01c00404 	movi	r7,16
   2a48c:	0027a640 	call	27a64 <alt_tse_phy_rd_mdio_reg>
   2a490:	010000f4 	movhi	r4,3
   2a494:	21074a04 	addi	r4,r4,7464
   2a498:	880b883a 	mov	r5,r17
   2a49c:	800d883a 	mov	r6,r16
   2a4a0:	100f883a 	mov	r7,r2
   2a4a4:	00170680 	call	17068 <printf>
   2a4a8:	00000106 	br	2a4b0 <alt_tse_phy_set_common_speed+0x410>

        pphy = pmac_info->pphy_info;
        
        /* if no PHY connected */
        if(!pphy) {
            continue;
   2a4ac:	0001883a 	nop
		IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
        return TSE_PHY_SPEED_NO_COMMON;
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
   2a4b0:	e0bff517 	ldw	r2,-44(fp)
   2a4b4:	10800044 	addi	r2,r2,1
   2a4b8:	e0bff515 	stw	r2,-44(fp)
   2a4bc:	e0bffe17 	ldw	r2,-8(fp)
   2a4c0:	10800003 	ldbu	r2,0(r2)
   2a4c4:	10803fcc 	andi	r2,r2,255
   2a4c8:	e0fff517 	ldw	r3,-44(fp)
   2a4cc:	18bf1f16 	blt	r3,r2,2a14c <alt_tse_phy_set_common_speed+0xac>
            alt_tse_mac_set_duplex((np_tse_mac *)psys->tse_mac_base, duplex);
            
        }
        tse_dprintf(5, "INFO    : PHY[%d.%d] - PHY STATUS = 0x%04x\n\n", mac_group_index, mac_info_index, (int) alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, 0, 16));        
    }
    tse_dprintf(5, "INFO    : MAC Group[%d] - All PHYs set to common speed : %d Mbps\n", mac_group_index, (common_speed == TSE_PHY_SPEED_1000) ? 1000 : ((common_speed == TSE_PHY_SPEED_100) ? 100 : 10));
   2a4d0:	e0fffa47 	ldb	r3,-23(fp)
   2a4d4:	e0bfff17 	ldw	r2,-4(fp)
   2a4d8:	108000a0 	cmpeqi	r2,r2,2
   2a4dc:	1000071e 	bne	r2,zero,2a4fc <alt_tse_phy_set_common_speed+0x45c>
   2a4e0:	e0bfff17 	ldw	r2,-4(fp)
   2a4e4:	10800058 	cmpnei	r2,r2,1
   2a4e8:	1000021e 	bne	r2,zero,2a4f4 <alt_tse_phy_set_common_speed+0x454>
   2a4ec:	00801904 	movi	r2,100
   2a4f0:	00000106 	br	2a4f8 <alt_tse_phy_set_common_speed+0x458>
   2a4f4:	00800284 	movi	r2,10
   2a4f8:	00000106 	br	2a500 <alt_tse_phy_set_common_speed+0x460>
   2a4fc:	0080fa04 	movi	r2,1000
   2a500:	010000f4 	movhi	r4,3
   2a504:	21075604 	addi	r4,r4,7512
   2a508:	180b883a 	mov	r5,r3
   2a50c:	100d883a 	mov	r6,r2
   2a510:	00170680 	call	17068 <printf>

    /* Set MAC speed register */
    alt_tse_mac_set_speed(pmac_group_base, common_speed);
   2a514:	e0bfff17 	ldw	r2,-4(fp)
   2a518:	10803fcc 	andi	r2,r2,255
   2a51c:	e13ffb17 	ldw	r4,-20(fp)
   2a520:	100b883a 	mov	r5,r2
   2a524:	0026cb80 	call	26cb8 <alt_tse_mac_set_speed>
    
    /* Restore previous MDIO address */
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
   2a528:	e0bffb17 	ldw	r2,-20(fp)
   2a52c:	10801004 	addi	r2,r2,64
   2a530:	e0fffc17 	ldw	r3,-16(fp)
   2a534:	10c00035 	stwio	r3,0(r2)
        
    return common_speed;
   2a538:	e0bfff17 	ldw	r2,-4(fp)
}
   2a53c:	e037883a 	mov	sp,fp
   2a540:	dfc00317 	ldw	ra,12(sp)
   2a544:	df000217 	ldw	fp,8(sp)
   2a548:	dc400117 	ldw	r17,4(sp)
   2a54c:	dc000017 	ldw	r16,0(sp)
   2a550:	dec00404 	addi	sp,sp,16
   2a554:	f800283a 	ret

0002a558 <marvell_phy_cfg>:

/* @Function Description: Additional configuration for Marvell PHY
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address of MAC group
 */
alt_32 marvell_phy_cfg(np_tse_mac *pmac) {
   2a558:	defffc04 	addi	sp,sp,-16
   2a55c:	dfc00315 	stw	ra,12(sp)
   2a560:	df000215 	stw	fp,8(sp)
   2a564:	df000204 	addi	fp,sp,8
   2a568:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat;
    
    /* If there is no link yet, we enable auto crossover and reset the PHY */
    if((IORD(&pmac->mdio1.STATUS, 0) & PCS_ST_an_done) == 0) {
   2a56c:	e0bfff17 	ldw	r2,-4(fp)
   2a570:	1080a104 	addi	r2,r2,644
   2a574:	10800037 	ldwio	r2,0(r2)
   2a578:	1080080c 	andi	r2,r2,32
   2a57c:	1000161e 	bne	r2,zero,2a5d8 <marvell_phy_cfg+0x80>
        tse_dprintf(5, "MARVELL : Enabling auto crossover\n");
   2a580:	010000f4 	movhi	r4,3
   2a584:	21076704 	addi	r4,r4,7580
   2a588:	00172f80 	call	172f8 <puts>
        IOWR(&pmac->mdio1.CONTROL, 16, 0x0078);
   2a58c:	e0bfff17 	ldw	r2,-4(fp)
   2a590:	1080a004 	addi	r2,r2,640
   2a594:	10801004 	addi	r2,r2,64
   2a598:	00c01e04 	movi	r3,120
   2a59c:	10c00035 	stwio	r3,0(r2)
        tse_dprintf(5, "MARVELL : PHY reset\n");
   2a5a0:	010000f4 	movhi	r4,3
   2a5a4:	21077004 	addi	r4,r4,7616
   2a5a8:	00172f80 	call	172f8 <puts>
        dat = IORD(&pmac->mdio1.CONTROL, 0); 
   2a5ac:	e0bfff17 	ldw	r2,-4(fp)
   2a5b0:	1080a004 	addi	r2,r2,640
   2a5b4:	10800037 	ldwio	r2,0(r2)
   2a5b8:	e0bffe0d 	sth	r2,-8(fp)
        IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);        
   2a5bc:	e0bfff17 	ldw	r2,-4(fp)
   2a5c0:	1080a004 	addi	r2,r2,640
   2a5c4:	e13ffe0b 	ldhu	r4,-8(fp)
   2a5c8:	00e00004 	movi	r3,-32768
   2a5cc:	20c6b03a 	or	r3,r4,r3
   2a5d0:	18ffffcc 	andi	r3,r3,65535
   2a5d4:	10c00035 	stwio	r3,0(r2)
    }
    
    return 0;
   2a5d8:	0005883a 	mov	r2,zero
}
   2a5dc:	e037883a 	mov	sp,fp
   2a5e0:	dfc00117 	ldw	ra,4(sp)
   2a5e4:	df000017 	ldw	fp,0(sp)
   2a5e8:	dec00204 	addi	sp,sp,8
   2a5ec:	f800283a 	ret

0002a5f0 <marvell_cfg_gmii>:

/* @Function Description: Change operating mode of Marvell PHY to GMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_gmii(np_tse_mac *pmac) {
   2a5f0:	defffc04 	addi	sp,sp,-16
   2a5f4:	dfc00315 	stw	ra,12(sp)
   2a5f8:	df000215 	stw	fp,8(sp)
   2a5fc:	df000204 	addi	fp,sp,8
   2a600:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
   2a604:	e0bfff17 	ldw	r2,-4(fp)
   2a608:	1080bb04 	addi	r2,r2,748
   2a60c:	10800037 	ldwio	r2,0(r2)
   2a610:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
   2a614:	e0fffe0b 	ldhu	r3,-8(fp)
   2a618:	00bffc04 	movi	r2,-16
   2a61c:	1884703a 	and	r2,r3,r2
   2a620:	e0bffe0d 	sth	r2,-8(fp)

    tse_dprintf(5, "MARVELL : Mode changed to GMII to copper mode\n");
   2a624:	010000f4 	movhi	r4,3
   2a628:	21077504 	addi	r4,r4,7636
   2a62c:	00172f80 	call	172f8 <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0xf);
   2a630:	e0bfff17 	ldw	r2,-4(fp)
   2a634:	1080bb04 	addi	r2,r2,748
   2a638:	e0fffe0b 	ldhu	r3,-8(fp)
   2a63c:	18c003d4 	ori	r3,r3,15
   2a640:	18ffffcc 	andi	r3,r3,65535
   2a644:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Disable RGMII Timing Control\n");
   2a648:	010000f4 	movhi	r4,3
   2a64c:	21078104 	addi	r4,r4,7684
   2a650:	00172f80 	call	172f8 <puts>
    dat = IORD(&pmac->mdio1.reg14, 0); 
   2a654:	e0bfff17 	ldw	r2,-4(fp)
   2a658:	1080b404 	addi	r2,r2,720
   2a65c:	10800037 	ldwio	r2,0(r2)
   2a660:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
   2a664:	e0fffe0b 	ldhu	r3,-8(fp)
   2a668:	00bfdf44 	movi	r2,-131
   2a66c:	1884703a 	and	r2,r3,r2
   2a670:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);
   2a674:	e0bfff17 	ldw	r2,-4(fp)
   2a678:	1080b404 	addi	r2,r2,720
   2a67c:	e0fffe0b 	ldhu	r3,-8(fp)
   2a680:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : PHY reset\n");
   2a684:	010000f4 	movhi	r4,3
   2a688:	21077004 	addi	r4,r4,7616
   2a68c:	00172f80 	call	172f8 <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
   2a690:	e0bfff17 	ldw	r2,-4(fp)
   2a694:	1080a004 	addi	r2,r2,640
   2a698:	10800037 	ldwio	r2,0(r2)
   2a69c:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);
   2a6a0:	e0bfff17 	ldw	r2,-4(fp)
   2a6a4:	1080a004 	addi	r2,r2,640
   2a6a8:	e13ffe0b 	ldhu	r4,-8(fp)
   2a6ac:	00e00004 	movi	r3,-32768
   2a6b0:	20c6b03a 	or	r3,r4,r3
   2a6b4:	18ffffcc 	andi	r3,r3,65535
   2a6b8:	10c00035 	stwio	r3,0(r2)
    
    return 1;
   2a6bc:	00800044 	movi	r2,1
}
   2a6c0:	e037883a 	mov	sp,fp
   2a6c4:	dfc00117 	ldw	ra,4(sp)
   2a6c8:	df000017 	ldw	fp,0(sp)
   2a6cc:	dec00204 	addi	sp,sp,8
   2a6d0:	f800283a 	ret

0002a6d4 <marvell_cfg_sgmii>:

/* @Function Description: Change operating mode of Marvell PHY to SGMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_sgmii(np_tse_mac *pmac) {
   2a6d4:	defffc04 	addi	sp,sp,-16
   2a6d8:	dfc00315 	stw	ra,12(sp)
   2a6dc:	df000215 	stw	fp,8(sp)
   2a6e0:	df000204 	addi	fp,sp,8
   2a6e4:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
   2a6e8:	e0bfff17 	ldw	r2,-4(fp)
   2a6ec:	1080bb04 	addi	r2,r2,748
   2a6f0:	10800037 	ldwio	r2,0(r2)
   2a6f4:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
   2a6f8:	e0fffe0b 	ldhu	r3,-8(fp)
   2a6fc:	00bffc04 	movi	r2,-16
   2a700:	1884703a 	and	r2,r3,r2
   2a704:	e0bffe0d 	sth	r2,-8(fp)

    tse_dprintf(5, "MARVELL : Mode changed to SGMII without clock with SGMII Auto-Neg to copper mode\n");
   2a708:	010000f4 	movhi	r4,3
   2a70c:	21078b04 	addi	r4,r4,7724
   2a710:	00172f80 	call	172f8 <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0x4);
   2a714:	e0bfff17 	ldw	r2,-4(fp)
   2a718:	1080bb04 	addi	r2,r2,748
   2a71c:	e0fffe0b 	ldhu	r3,-8(fp)
   2a720:	18c00114 	ori	r3,r3,4
   2a724:	18ffffcc 	andi	r3,r3,65535
   2a728:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Disable RGMII Timing Control\n");
   2a72c:	010000f4 	movhi	r4,3
   2a730:	21078104 	addi	r4,r4,7684
   2a734:	00172f80 	call	172f8 <puts>
    dat = IORD(&pmac->mdio1.reg14, 0); 
   2a738:	e0bfff17 	ldw	r2,-4(fp)
   2a73c:	1080b404 	addi	r2,r2,720
   2a740:	10800037 	ldwio	r2,0(r2)
   2a744:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
   2a748:	e0fffe0b 	ldhu	r3,-8(fp)
   2a74c:	00bfdf44 	movi	r2,-131
   2a750:	1884703a 	and	r2,r3,r2
   2a754:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);
   2a758:	e0bfff17 	ldw	r2,-4(fp)
   2a75c:	1080b404 	addi	r2,r2,720
   2a760:	e0fffe0b 	ldhu	r3,-8(fp)
   2a764:	10c00035 	stwio	r3,0(r2)

    tse_dprintf(5, "MARVELL : PHY reset\n");
   2a768:	010000f4 	movhi	r4,3
   2a76c:	21077004 	addi	r4,r4,7616
   2a770:	00172f80 	call	172f8 <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
   2a774:	e0bfff17 	ldw	r2,-4(fp)
   2a778:	1080a004 	addi	r2,r2,640
   2a77c:	10800037 	ldwio	r2,0(r2)
   2a780:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);
   2a784:	e0bfff17 	ldw	r2,-4(fp)
   2a788:	1080a004 	addi	r2,r2,640
   2a78c:	e13ffe0b 	ldhu	r4,-8(fp)
   2a790:	00e00004 	movi	r3,-32768
   2a794:	20c6b03a 	or	r3,r4,r3
   2a798:	18ffffcc 	andi	r3,r3,65535
   2a79c:	10c00035 	stwio	r3,0(r2)
    
    return 1;
   2a7a0:	00800044 	movi	r2,1
}
   2a7a4:	e037883a 	mov	sp,fp
   2a7a8:	dfc00117 	ldw	ra,4(sp)
   2a7ac:	df000017 	ldw	fp,0(sp)
   2a7b0:	dec00204 	addi	sp,sp,8
   2a7b4:	f800283a 	ret

0002a7b8 <marvell_cfg_rgmii>:

/* @Function Description: Change operating mode of Marvell PHY to RGMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_rgmii(np_tse_mac *pmac) {
   2a7b8:	defffc04 	addi	sp,sp,-16
   2a7bc:	dfc00315 	stw	ra,12(sp)
   2a7c0:	df000215 	stw	fp,8(sp)
   2a7c4:	df000204 	addi	fp,sp,8
   2a7c8:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
   2a7cc:	e0bfff17 	ldw	r2,-4(fp)
   2a7d0:	1080bb04 	addi	r2,r2,748
   2a7d4:	10800037 	ldwio	r2,0(r2)
   2a7d8:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
   2a7dc:	e0fffe0b 	ldhu	r3,-8(fp)
   2a7e0:	00bffc04 	movi	r2,-16
   2a7e4:	1884703a 	and	r2,r3,r2
   2a7e8:	e0bffe0d 	sth	r2,-8(fp)
    
    tse_dprintf(5, "MARVELL : Mode changed to RGMII/Modified MII to Copper mode\n");
   2a7ec:	010000f4 	movhi	r4,3
   2a7f0:	2107a004 	addi	r4,r4,7808
   2a7f4:	00172f80 	call	172f8 <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0xb);
   2a7f8:	e0bfff17 	ldw	r2,-4(fp)
   2a7fc:	1080bb04 	addi	r2,r2,748
   2a800:	e0fffe0b 	ldhu	r3,-8(fp)
   2a804:	18c002d4 	ori	r3,r3,11
   2a808:	18ffffcc 	andi	r3,r3,65535
   2a80c:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Enable RGMII Timing Control\n");
   2a810:	010000f4 	movhi	r4,3
   2a814:	2107af04 	addi	r4,r4,7868
   2a818:	00172f80 	call	172f8 <puts>
    dat = IORD(&pmac->mdio1.reg14, 0);
   2a81c:	e0bfff17 	ldw	r2,-4(fp)
   2a820:	1080b404 	addi	r2,r2,720
   2a824:	10800037 	ldwio	r2,0(r2)
   2a828:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
   2a82c:	e0fffe0b 	ldhu	r3,-8(fp)
   2a830:	00bfdf44 	movi	r2,-131
   2a834:	1884703a 	and	r2,r3,r2
   2a838:	e0bffe0d 	sth	r2,-8(fp)
    dat |= 0x82;
   2a83c:	e0bffe0b 	ldhu	r2,-8(fp)
   2a840:	10802094 	ori	r2,r2,130
   2a844:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);    
   2a848:	e0bfff17 	ldw	r2,-4(fp)
   2a84c:	1080b404 	addi	r2,r2,720
   2a850:	e0fffe0b 	ldhu	r3,-8(fp)
   2a854:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : PHY reset\n");
   2a858:	010000f4 	movhi	r4,3
   2a85c:	21077004 	addi	r4,r4,7616
   2a860:	00172f80 	call	172f8 <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
   2a864:	e0bfff17 	ldw	r2,-4(fp)
   2a868:	1080a004 	addi	r2,r2,640
   2a86c:	10800037 	ldwio	r2,0(r2)
   2a870:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);
   2a874:	e0bfff17 	ldw	r2,-4(fp)
   2a878:	1080a004 	addi	r2,r2,640
   2a87c:	e13ffe0b 	ldhu	r4,-8(fp)
   2a880:	00e00004 	movi	r3,-32768
   2a884:	20c6b03a 	or	r3,r4,r3
   2a888:	18ffffcc 	andi	r3,r3,65535
   2a88c:	10c00035 	stwio	r3,0(r2)
    
    return 1;
   2a890:	00800044 	movi	r2,1
    
}
   2a894:	e037883a 	mov	sp,fp
   2a898:	dfc00117 	ldw	ra,4(sp)
   2a89c:	df000017 	ldw	fp,0(sp)
   2a8a0:	dec00204 	addi	sp,sp,8
   2a8a4:	f800283a 	ret

0002a8a8 <DP83848C_link_status_read>:

/* @Function Description: Read link status from PHY specific status register of DP83848C
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_u32 DP83848C_link_status_read(np_tse_mac *pmac) {
   2a8a8:	defffc04 	addi	sp,sp,-16
   2a8ac:	df000315 	stw	fp,12(sp)
   2a8b0:	df000304 	addi	fp,sp,12
   2a8b4:	e13fff15 	stw	r4,-4(fp)
	alt_u32 link_status = 0;
   2a8b8:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 reg_status = IORD(&pmac->mdio1.reg10, 0);
   2a8bc:	e0bfff17 	ldw	r2,-4(fp)
   2a8c0:	1080b004 	addi	r2,r2,704
   2a8c4:	10800037 	ldwio	r2,0(r2)
   2a8c8:	e0bffe15 	stw	r2,-8(fp)
	
	/* If speed == 10 Mbps */
	if(reg_status & 0x2) {
   2a8cc:	e0bffe17 	ldw	r2,-8(fp)
   2a8d0:	1080008c 	andi	r2,r2,2
   2a8d4:	10000426 	beq	r2,zero,2a8e8 <DP83848C_link_status_read+0x40>
		link_status |= 0x8;
   2a8d8:	e0bffd17 	ldw	r2,-12(fp)
   2a8dc:	10800214 	ori	r2,r2,8
   2a8e0:	e0bffd15 	stw	r2,-12(fp)
   2a8e4:	00000306 	br	2a8f4 <DP83848C_link_status_read+0x4c>
	}
	/* Else speed = 100 Mbps */
	else {
		link_status |= 0x4;
   2a8e8:	e0bffd17 	ldw	r2,-12(fp)
   2a8ec:	10800114 	ori	r2,r2,4
   2a8f0:	e0bffd15 	stw	r2,-12(fp)
	}
	
	/* If duplex == Full */
	if(reg_status & 0x4) {
   2a8f4:	e0bffe17 	ldw	r2,-8(fp)
   2a8f8:	1080010c 	andi	r2,r2,4
   2a8fc:	10000326 	beq	r2,zero,2a90c <DP83848C_link_status_read+0x64>
		link_status |= 0x1;
   2a900:	e0bffd17 	ldw	r2,-12(fp)
   2a904:	10800054 	ori	r2,r2,1
   2a908:	e0bffd15 	stw	r2,-12(fp)
	}
	
	return link_status;
   2a90c:	e0bffd17 	ldw	r2,-12(fp)
}
   2a910:	e037883a 	mov	sp,fp
   2a914:	df000017 	ldw	fp,0(sp)
   2a918:	dec00104 	addi	sp,sp,4
   2a91c:	f800283a 	ret

0002a920 <altera_avalon_uart_read_fd>:
 *
 */

int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
   2a920:	defffa04 	addi	sp,sp,-24
   2a924:	dfc00515 	stw	ra,20(sp)
   2a928:	df000415 	stw	fp,16(sp)
   2a92c:	df000404 	addi	fp,sp,16
   2a930:	e13ffd15 	stw	r4,-12(fp)
   2a934:	e17ffe15 	stw	r5,-8(fp)
   2a938:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
   2a93c:	e0bffd17 	ldw	r2,-12(fp)
   2a940:	10800017 	ldw	r2,0(r2)
   2a944:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_read(&dev->state, buffer, space,
   2a948:	e0bffc17 	ldw	r2,-16(fp)
   2a94c:	10c00a04 	addi	r3,r2,40
      fd->fd_flags);
   2a950:	e0bffd17 	ldw	r2,-12(fp)
int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 

    return altera_avalon_uart_read(&dev->state, buffer, space,
   2a954:	10800217 	ldw	r2,8(r2)
   2a958:	1809883a 	mov	r4,r3
   2a95c:	e17ffe17 	ldw	r5,-8(fp)
   2a960:	e1bfff17 	ldw	r6,-4(fp)
   2a964:	100f883a 	mov	r7,r2
   2a968:	002ae280 	call	2ae28 <altera_avalon_uart_read>
      fd->fd_flags);
}
   2a96c:	e037883a 	mov	sp,fp
   2a970:	dfc00117 	ldw	ra,4(sp)
   2a974:	df000017 	ldw	fp,0(sp)
   2a978:	dec00204 	addi	sp,sp,8
   2a97c:	f800283a 	ret

0002a980 <altera_avalon_uart_write_fd>:

int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
   2a980:	defffa04 	addi	sp,sp,-24
   2a984:	dfc00515 	stw	ra,20(sp)
   2a988:	df000415 	stw	fp,16(sp)
   2a98c:	df000404 	addi	fp,sp,16
   2a990:	e13ffd15 	stw	r4,-12(fp)
   2a994:	e17ffe15 	stw	r5,-8(fp)
   2a998:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
   2a99c:	e0bffd17 	ldw	r2,-12(fp)
   2a9a0:	10800017 	ldw	r2,0(r2)
   2a9a4:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_write(&dev->state, buffer, space,
   2a9a8:	e0bffc17 	ldw	r2,-16(fp)
   2a9ac:	10c00a04 	addi	r3,r2,40
      fd->fd_flags);
   2a9b0:	e0bffd17 	ldw	r2,-12(fp)
int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 

    return altera_avalon_uart_write(&dev->state, buffer, space,
   2a9b4:	10800217 	ldw	r2,8(r2)
   2a9b8:	1809883a 	mov	r4,r3
   2a9bc:	e17ffe17 	ldw	r5,-8(fp)
   2a9c0:	e1bfff17 	ldw	r6,-4(fp)
   2a9c4:	100f883a 	mov	r7,r2
   2a9c8:	002b0d40 	call	2b0d4 <altera_avalon_uart_write>
      fd->fd_flags);
}
   2a9cc:	e037883a 	mov	sp,fp
   2a9d0:	dfc00117 	ldw	ra,4(sp)
   2a9d4:	df000017 	ldw	fp,0(sp)
   2a9d8:	dec00204 	addi	sp,sp,8
   2a9dc:	f800283a 	ret

0002a9e0 <altera_avalon_uart_close_fd>:

#endif /* ALTERA_AVALON_UART_USE_IOCTL */

int 
altera_avalon_uart_close_fd(alt_fd* fd)
{
   2a9e0:	defffc04 	addi	sp,sp,-16
   2a9e4:	dfc00315 	stw	ra,12(sp)
   2a9e8:	df000215 	stw	fp,8(sp)
   2a9ec:	df000204 	addi	fp,sp,8
   2a9f0:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
   2a9f4:	e0bfff17 	ldw	r2,-4(fp)
   2a9f8:	10800017 	ldw	r2,0(r2)
   2a9fc:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_uart_close(&dev->state, fd->fd_flags);
   2aa00:	e0bffe17 	ldw	r2,-8(fp)
   2aa04:	10c00a04 	addi	r3,r2,40
   2aa08:	e0bfff17 	ldw	r2,-4(fp)
   2aa0c:	10800217 	ldw	r2,8(r2)
   2aa10:	1809883a 	mov	r4,r3
   2aa14:	100b883a 	mov	r5,r2
   2aa18:	002ad840 	call	2ad84 <altera_avalon_uart_close>
}
   2aa1c:	e037883a 	mov	sp,fp
   2aa20:	dfc00117 	ldw	ra,4(sp)
   2aa24:	df000017 	ldw	fp,0(sp)
   2aa28:	dec00204 	addi	sp,sp,8
   2aa2c:	f800283a 	ret

0002aa30 <altera_avalon_uart_init>:
  alt_u32 status);

void 
altera_avalon_uart_init(altera_avalon_uart_state* sp, 
  alt_u32 irq_controller_id,  alt_u32 irq)
{
   2aa30:	defff804 	addi	sp,sp,-32
   2aa34:	dfc00715 	stw	ra,28(sp)
   2aa38:	df000615 	stw	fp,24(sp)
   2aa3c:	df000604 	addi	fp,sp,24
   2aa40:	e13ffd15 	stw	r4,-12(fp)
   2aa44:	e17ffe15 	stw	r5,-8(fp)
   2aa48:	e1bfff15 	stw	r6,-4(fp)
  void* base = sp->base;
   2aa4c:	e0bffd17 	ldw	r2,-12(fp)
   2aa50:	10800017 	ldw	r2,0(r2)
   2aa54:	e0bffb15 	stw	r2,-20(fp)
 * HAL.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_no_error (void)
{
  return 0;
   2aa58:	0005883a 	mov	r2,zero
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
   2aa5c:	1000041e 	bne	r2,zero,2aa70 <altera_avalon_uart_init+0x40>
   2aa60:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
   2aa64:	1000021e 	bne	r2,zero,2aa70 <altera_avalon_uart_init+0x40>
   2aa68:	0005883a 	mov	r2,zero
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
   2aa6c:	10000226 	beq	r2,zero,2aa78 <altera_avalon_uart_init+0x48>
   2aa70:	00800044 	movi	r2,1
   2aa74:	00000106 	br	2aa7c <altera_avalon_uart_init+0x4c>
   2aa78:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
   2aa7c:	e0bffc15 	stw	r2,-16(fp)
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);

  if (!error)
   2aa80:	e0bffc17 	ldw	r2,-16(fp)
   2aa84:	10000f1e 	bne	r2,zero,2aac4 <altera_avalon_uart_init+0x94>
  {
    /* enable interrupts at the device */
    sp->ctrl = ALTERA_AVALON_UART_CONTROL_RTS_MSK  |
   2aa88:	e0bffd17 	ldw	r2,-12(fp)
   2aa8c:	00c32004 	movi	r3,3200
   2aa90:	10c00115 	stw	r3,4(r2)
                ALTERA_AVALON_UART_CONTROL_RRDY_MSK |
                ALTERA_AVALON_UART_CONTROL_DCTS_MSK;

    IOWR_ALTERA_AVALON_UART_CONTROL(base, sp->ctrl); 
   2aa94:	e0bffb17 	ldw	r2,-20(fp)
   2aa98:	10800304 	addi	r2,r2,12
   2aa9c:	e0fffd17 	ldw	r3,-12(fp)
   2aaa0:	18c00117 	ldw	r3,4(r3)
   2aaa4:	10c00035 	stwio	r3,0(r2)
  
    /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
    alt_ic_isr_register(irq_controller_id, irq, altera_avalon_uart_irq, sp, 
   2aaa8:	d8000015 	stw	zero,0(sp)
   2aaac:	e13ffe17 	ldw	r4,-8(fp)
   2aab0:	e17fff17 	ldw	r5,-4(fp)
   2aab4:	018000f4 	movhi	r6,3
   2aab8:	31aab604 	addi	r6,r6,-21800
   2aabc:	e1fffd17 	ldw	r7,-12(fp)
   2aac0:	002b6280 	call	2b628 <alt_ic_isr_register>
      0x0);
#else
    alt_irq_register (irq, sp, altera_avalon_uart_irq);
#endif  
  }
}
   2aac4:	e037883a 	mov	sp,fp
   2aac8:	dfc00117 	ldw	ra,4(sp)
   2aacc:	df000017 	ldw	fp,0(sp)
   2aad0:	dec00204 	addi	sp,sp,8
   2aad4:	f800283a 	ret

0002aad8 <altera_avalon_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_uart_irq(void* context)
#else
static void altera_avalon_uart_irq(void* context, alt_u32 id)
#endif
{
   2aad8:	defffa04 	addi	sp,sp,-24
   2aadc:	dfc00515 	stw	ra,20(sp)
   2aae0:	df000415 	stw	fp,16(sp)
   2aae4:	df000404 	addi	fp,sp,16
   2aae8:	e13fff15 	stw	r4,-4(fp)
  alt_u32 status;

  altera_avalon_uart_state* sp = (altera_avalon_uart_state*) context;
   2aaec:	e0bfff17 	ldw	r2,-4(fp)
   2aaf0:	e0bffc15 	stw	r2,-16(fp)
  void* base               = sp->base;
   2aaf4:	e0bffc17 	ldw	r2,-16(fp)
   2aaf8:	10800017 	ldw	r2,0(r2)
   2aafc:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Read the status register in order to determine the cause of the
   * interrupt.
   */

  status = IORD_ALTERA_AVALON_UART_STATUS(base);
   2ab00:	e0bffd17 	ldw	r2,-12(fp)
   2ab04:	10800204 	addi	r2,r2,8
   2ab08:	10800037 	ldwio	r2,0(r2)
   2ab0c:	e0bffe15 	stw	r2,-8(fp)

  /* Clear any error flags set at the device */
  IOWR_ALTERA_AVALON_UART_STATUS(base, 0);
   2ab10:	e0bffd17 	ldw	r2,-12(fp)
   2ab14:	10800204 	addi	r2,r2,8
   2ab18:	0007883a 	mov	r3,zero
   2ab1c:	10c00035 	stwio	r3,0(r2)

  /* Dummy read to ensure IRQ is negated before ISR returns */
  IORD_ALTERA_AVALON_UART_STATUS(base);
   2ab20:	e0bffd17 	ldw	r2,-12(fp)
   2ab24:	10800204 	addi	r2,r2,8
   2ab28:	10800037 	ldwio	r2,0(r2)
  
  /* process a read irq */
  if (status & ALTERA_AVALON_UART_STATUS_RRDY_MSK)
   2ab2c:	e0bffe17 	ldw	r2,-8(fp)
   2ab30:	1080200c 	andi	r2,r2,128
   2ab34:	10000326 	beq	r2,zero,2ab44 <altera_avalon_uart_irq+0x6c>
  {
    altera_avalon_uart_rxirq(sp, status);
   2ab38:	e13ffc17 	ldw	r4,-16(fp)
   2ab3c:	e17ffe17 	ldw	r5,-8(fp)
   2ab40:	002ab700 	call	2ab70 <altera_avalon_uart_rxirq>
  }

  /* process a write irq */
  if (status & (ALTERA_AVALON_UART_STATUS_TRDY_MSK | 
   2ab44:	e0bffe17 	ldw	r2,-8(fp)
   2ab48:	1081100c 	andi	r2,r2,1088
   2ab4c:	10000326 	beq	r2,zero,2ab5c <altera_avalon_uart_irq+0x84>
                  ALTERA_AVALON_UART_STATUS_DCTS_MSK))
  {
    altera_avalon_uart_txirq(sp, status);
   2ab50:	e13ffc17 	ldw	r4,-16(fp)
   2ab54:	e17ffe17 	ldw	r5,-8(fp)
   2ab58:	002ac480 	call	2ac48 <altera_avalon_uart_txirq>
  }
  

}
   2ab5c:	e037883a 	mov	sp,fp
   2ab60:	dfc00117 	ldw	ra,4(sp)
   2ab64:	df000017 	ldw	fp,0(sp)
   2ab68:	dec00204 	addi	sp,sp,8
   2ab6c:	f800283a 	ret

0002ab70 <altera_avalon_uart_rxirq>:
 * the receive circular buffer, and sets the apropriate flags to indicate 
 * that there is data ready to be processed.
 */
static void 
altera_avalon_uart_rxirq(altera_avalon_uart_state* sp, alt_u32 status)
{
   2ab70:	defffc04 	addi	sp,sp,-16
   2ab74:	df000315 	stw	fp,12(sp)
   2ab78:	df000304 	addi	fp,sp,12
   2ab7c:	e13ffe15 	stw	r4,-8(fp)
   2ab80:	e17fff15 	stw	r5,-4(fp)
  alt_u32 next;
  
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
   2ab84:	e0bfff17 	ldw	r2,-4(fp)
   2ab88:	108000cc 	andi	r2,r2,3
   2ab8c:	1000291e 	bne	r2,zero,2ac34 <altera_avalon_uart_rxirq+0xc4>
   * In a multi-threaded environment, set the read event flag to indicate
   * that there is data ready. This is only done if the circular buffer was
   * previously empty.
   */

  if (sp->rx_end == sp->rx_start)
   2ab90:	e0bffe17 	ldw	r2,-8(fp)
   2ab94:	10800317 	ldw	r2,12(r2)
    ALT_FLAG_POST (sp->events, ALT_UART_READ_RDY, OS_FLAG_SET);
  }

  /* Determine which slot to use next in the circular buffer */

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
   2ab98:	e0bffe17 	ldw	r2,-8(fp)
   2ab9c:	10800317 	ldw	r2,12(r2)
   2aba0:	10800044 	addi	r2,r2,1
   2aba4:	10800fcc 	andi	r2,r2,63
   2aba8:	e0bffd15 	stw	r2,-12(fp)

  /* Transfer data from the device to the circular buffer */

  sp->rx_buf[sp->rx_end] = IORD_ALTERA_AVALON_UART_RXDATA(sp->base);
   2abac:	e0bffe17 	ldw	r2,-8(fp)
   2abb0:	10800317 	ldw	r2,12(r2)
   2abb4:	e0fffe17 	ldw	r3,-8(fp)
   2abb8:	18c00017 	ldw	r3,0(r3)
   2abbc:	18c00037 	ldwio	r3,0(r3)
   2abc0:	e13ffe17 	ldw	r4,-8(fp)
   2abc4:	2085883a 	add	r2,r4,r2
   2abc8:	10800704 	addi	r2,r2,28
   2abcc:	10c00005 	stb	r3,0(r2)

  sp->rx_end = next;
   2abd0:	e0bffe17 	ldw	r2,-8(fp)
   2abd4:	e0fffd17 	ldw	r3,-12(fp)
   2abd8:	10c00315 	stw	r3,12(r2)

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
   2abdc:	e0bffe17 	ldw	r2,-8(fp)
   2abe0:	10800317 	ldw	r2,12(r2)
   2abe4:	10800044 	addi	r2,r2,1
   2abe8:	10800fcc 	andi	r2,r2,63
   2abec:	e0bffd15 	stw	r2,-12(fp)
  /*
   * If the cicular buffer was full, disable interrupts. Interrupts will be
   * re-enabled when data is removed from the buffer.
   */

  if (next == sp->rx_start)
   2abf0:	e0bffe17 	ldw	r2,-8(fp)
   2abf4:	10c00217 	ldw	r3,8(r2)
   2abf8:	e0bffd17 	ldw	r2,-12(fp)
   2abfc:	18800e1e 	bne	r3,r2,2ac38 <altera_avalon_uart_rxirq+0xc8>
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
   2ac00:	e0bffe17 	ldw	r2,-8(fp)
   2ac04:	10c00117 	ldw	r3,4(r2)
   2ac08:	00bfdfc4 	movi	r2,-129
   2ac0c:	1886703a 	and	r3,r3,r2
   2ac10:	e0bffe17 	ldw	r2,-8(fp)
   2ac14:	10c00115 	stw	r3,4(r2)
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
   2ac18:	e0bffe17 	ldw	r2,-8(fp)
   2ac1c:	10800017 	ldw	r2,0(r2)
   2ac20:	10800304 	addi	r2,r2,12
   2ac24:	e0fffe17 	ldw	r3,-8(fp)
   2ac28:	18c00117 	ldw	r3,4(r3)
   2ac2c:	10c00035 	stwio	r3,0(r2)
   2ac30:	00000106 	br	2ac38 <altera_avalon_uart_rxirq+0xc8>
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
                  ALTERA_AVALON_UART_STATUS_FE_MSK))
  {
    return;
   2ac34:	0001883a 	nop
  if (next == sp->rx_start)
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
  }   
}
   2ac38:	e037883a 	mov	sp,fp
   2ac3c:	df000017 	ldw	fp,0(sp)
   2ac40:	dec00104 	addi	sp,sp,4
   2ac44:	f800283a 	ret

0002ac48 <altera_avalon_uart_txirq>:
 * buffer to the device, and sets the apropriate flags to indicate that 
 * there is data ready to be processed.
 */
static void 
altera_avalon_uart_txirq(altera_avalon_uart_state* sp, alt_u32 status)
{
   2ac48:	defffd04 	addi	sp,sp,-12
   2ac4c:	df000215 	stw	fp,8(sp)
   2ac50:	df000204 	addi	fp,sp,8
   2ac54:	e13ffe15 	stw	r4,-8(fp)
   2ac58:	e17fff15 	stw	r5,-4(fp)
  /* Transfer data if there is some ready to be transfered */

  if (sp->tx_start != sp->tx_end)
   2ac5c:	e0bffe17 	ldw	r2,-8(fp)
   2ac60:	10c00417 	ldw	r3,16(r2)
   2ac64:	e0bffe17 	ldw	r2,-8(fp)
   2ac68:	10800517 	ldw	r2,20(r2)
   2ac6c:	18803026 	beq	r3,r2,2ad30 <altera_avalon_uart_txirq+0xe8>
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
   2ac70:	e0bffe17 	ldw	r2,-8(fp)
   2ac74:	10800617 	ldw	r2,24(r2)
   2ac78:	1080008c 	andi	r2,r2,2
   2ac7c:	10000326 	beq	r2,zero,2ac8c <altera_avalon_uart_txirq+0x44>
      (status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
   2ac80:	e0bfff17 	ldw	r2,-4(fp)
   2ac84:	1082000c 	andi	r2,r2,2048
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
   2ac88:	10001b26 	beq	r2,zero,2acf8 <altera_avalon_uart_txirq+0xb0>
       * In a multi-threaded environment, set the write event flag to indicate
       * that there is space in the circular buffer. This is only done if the
       * buffer was previously empty.
       */

      if (sp->tx_start == ((sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK))
   2ac8c:	e0bffe17 	ldw	r2,-8(fp)
   2ac90:	10800417 	ldw	r2,16(r2)
                       OS_FLAG_SET);
      }

      /* Write the data to the device */

      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, sp->tx_buf[sp->tx_start]);
   2ac94:	e0bffe17 	ldw	r2,-8(fp)
   2ac98:	10800017 	ldw	r2,0(r2)
   2ac9c:	10800104 	addi	r2,r2,4
   2aca0:	e0fffe17 	ldw	r3,-8(fp)
   2aca4:	18c00417 	ldw	r3,16(r3)
   2aca8:	e13ffe17 	ldw	r4,-8(fp)
   2acac:	20c7883a 	add	r3,r4,r3
   2acb0:	18c01704 	addi	r3,r3,92
   2acb4:	18c00003 	ldbu	r3,0(r3)
   2acb8:	18c03fcc 	andi	r3,r3,255
   2acbc:	10c00035 	stwio	r3,0(r2)

      sp->tx_start = (++sp->tx_start) & ALT_AVALON_UART_BUF_MSK;
   2acc0:	e0bffe17 	ldw	r2,-8(fp)
   2acc4:	10800417 	ldw	r2,16(r2)
   2acc8:	10800044 	addi	r2,r2,1
   2accc:	e0fffe17 	ldw	r3,-8(fp)
   2acd0:	18800415 	stw	r2,16(r3)
   2acd4:	10c00fcc 	andi	r3,r2,63
   2acd8:	e0bffe17 	ldw	r2,-8(fp)
   2acdc:	10c00415 	stw	r3,16(r2)
      /*
       * In case the tranmit interrupt had previously been disabled by 
       * detecting a low value on CTS, it is reenabled here.
       */ 

      sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
   2ace0:	e0bffe17 	ldw	r2,-8(fp)
   2ace4:	10800117 	ldw	r2,4(r2)
   2ace8:	10c01014 	ori	r3,r2,64
   2acec:	e0bffe17 	ldw	r2,-8(fp)
   2acf0:	10c00115 	stw	r3,4(r2)
   2acf4:	00000e06 	br	2ad30 <altera_avalon_uart_txirq+0xe8>
       * the last write to the status register. To avoid this resulting in
       * deadlock, it's necessary to re-check the status register here
       * before throttling.
       */
 
      status = IORD_ALTERA_AVALON_UART_STATUS(sp->base); 
   2acf8:	e0bffe17 	ldw	r2,-8(fp)
   2acfc:	10800017 	ldw	r2,0(r2)
   2ad00:	10800204 	addi	r2,r2,8
   2ad04:	10800037 	ldwio	r2,0(r2)
   2ad08:	e0bfff15 	stw	r2,-4(fp)

      if (!(status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
   2ad0c:	e0bfff17 	ldw	r2,-4(fp)
   2ad10:	1082000c 	andi	r2,r2,2048
   2ad14:	1000061e 	bne	r2,zero,2ad30 <altera_avalon_uart_txirq+0xe8>
      {
        sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
   2ad18:	e0bffe17 	ldw	r2,-8(fp)
   2ad1c:	10c00117 	ldw	r3,4(r2)
   2ad20:	00bfefc4 	movi	r2,-65
   2ad24:	1886703a 	and	r3,r3,r2
   2ad28:	e0bffe17 	ldw	r2,-8(fp)
   2ad2c:	10c00115 	stw	r3,4(r2)
  /*
   * If the circular buffer is empty, disable the interrupt. This will be
   * re-enabled when new data is placed in the buffer.
   */

  if (sp->tx_start == sp->tx_end)
   2ad30:	e0bffe17 	ldw	r2,-8(fp)
   2ad34:	10c00417 	ldw	r3,16(r2)
   2ad38:	e0bffe17 	ldw	r2,-8(fp)
   2ad3c:	10800517 	ldw	r2,20(r2)
   2ad40:	1880061e 	bne	r3,r2,2ad5c <altera_avalon_uart_txirq+0x114>
  {
    sp->ctrl &= ~(ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
   2ad44:	e0bffe17 	ldw	r2,-8(fp)
   2ad48:	10c00117 	ldw	r3,4(r2)
   2ad4c:	00beefc4 	movi	r2,-1089
   2ad50:	1886703a 	and	r3,r3,r2
   2ad54:	e0bffe17 	ldw	r2,-8(fp)
   2ad58:	10c00115 	stw	r3,4(r2)
                    ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
  }

  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
   2ad5c:	e0bffe17 	ldw	r2,-8(fp)
   2ad60:	10800017 	ldw	r2,0(r2)
   2ad64:	10800304 	addi	r2,r2,12
   2ad68:	e0fffe17 	ldw	r3,-8(fp)
   2ad6c:	18c00117 	ldw	r3,4(r3)
   2ad70:	10c00035 	stwio	r3,0(r2)
}
   2ad74:	e037883a 	mov	sp,fp
   2ad78:	df000017 	ldw	fp,0(sp)
   2ad7c:	dec00104 	addi	sp,sp,4
   2ad80:	f800283a 	ret

0002ad84 <altera_avalon_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
   2ad84:	defffd04 	addi	sp,sp,-12
   2ad88:	df000215 	stw	fp,8(sp)
   2ad8c:	df000204 	addi	fp,sp,8
   2ad90:	e13ffe15 	stw	r4,-8(fp)
   2ad94:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
   2ad98:	00000506 	br	2adb0 <altera_avalon_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
   2ad9c:	e0bfff17 	ldw	r2,-4(fp)
   2ada0:	1090000c 	andi	r2,r2,16384
   2ada4:	10000226 	beq	r2,zero,2adb0 <altera_avalon_uart_close+0x2c>
      return -EWOULDBLOCK; 
   2ada8:	00bffd44 	movi	r2,-11
   2adac:	00000606 	br	2adc8 <altera_avalon_uart_close+0x44>
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
   2adb0:	e0bffe17 	ldw	r2,-8(fp)
   2adb4:	10c00417 	ldw	r3,16(r2)
   2adb8:	e0bffe17 	ldw	r2,-8(fp)
   2adbc:	10800517 	ldw	r2,20(r2)
   2adc0:	18bff61e 	bne	r3,r2,2ad9c <altera_avalon_uart_close+0x18>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
   2adc4:	0005883a 	mov	r2,zero
}
   2adc8:	e037883a 	mov	sp,fp
   2adcc:	df000017 	ldw	fp,0(sp)
   2add0:	dec00104 	addi	sp,sp,4
   2add4:	f800283a 	ret

0002add8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   2add8:	defffe04 	addi	sp,sp,-8
   2addc:	dfc00115 	stw	ra,4(sp)
   2ade0:	df000015 	stw	fp,0(sp)
   2ade4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   2ade8:	008000f4 	movhi	r2,3
   2adec:	10910004 	addi	r2,r2,17408
   2adf0:	10800017 	ldw	r2,0(r2)
   2adf4:	10000526 	beq	r2,zero,2ae0c <alt_get_errno+0x34>
   2adf8:	008000f4 	movhi	r2,3
   2adfc:	10910004 	addi	r2,r2,17408
   2ae00:	10800017 	ldw	r2,0(r2)
   2ae04:	103ee83a 	callr	r2
   2ae08:	00000206 	br	2ae14 <alt_get_errno+0x3c>
   2ae0c:	008000f4 	movhi	r2,3
   2ae10:	1099dd04 	addi	r2,r2,26484
}
   2ae14:	e037883a 	mov	sp,fp
   2ae18:	dfc00117 	ldw	ra,4(sp)
   2ae1c:	df000017 	ldw	fp,0(sp)
   2ae20:	dec00204 	addi	sp,sp,8
   2ae24:	f800283a 	ret

0002ae28 <altera_avalon_uart_read>:
 */

int 
altera_avalon_uart_read(altera_avalon_uart_state* sp, char* ptr, int len,
  int flags)
{
   2ae28:	deffef04 	addi	sp,sp,-68
   2ae2c:	dfc01015 	stw	ra,64(sp)
   2ae30:	df000f15 	stw	fp,60(sp)
   2ae34:	df000f04 	addi	fp,sp,60
   2ae38:	e13ffc15 	stw	r4,-16(fp)
   2ae3c:	e17ffd15 	stw	r5,-12(fp)
   2ae40:	e1bffe15 	stw	r6,-8(fp)
   2ae44:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             block;
  alt_u32         next;
  alt_u8          read_would_block = 0;
   2ae48:	e03ff105 	stb	zero,-60(fp)
  int             count = 0;
   2ae4c:	e03ff215 	stw	zero,-56(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  block = !(flags & O_NONBLOCK);
   2ae50:	e0bfff17 	ldw	r2,-4(fp)
   2ae54:	1090000c 	andi	r2,r2,16384
   2ae58:	1005003a 	cmpeq	r2,r2,zero
   2ae5c:	10803fcc 	andi	r2,r2,255
   2ae60:	e0bff315 	stw	r2,-52(fp)
  /*
   * Calculate which slot in the circular buffer is the next one to read
   * data from.
   */

  next = (sp->rx_start + 1) & ALT_AVALON_UART_BUF_MSK;
   2ae64:	e0bffc17 	ldw	r2,-16(fp)
   2ae68:	10800217 	ldw	r2,8(r2)
   2ae6c:	10800044 	addi	r2,r2,1
   2ae70:	10800fcc 	andi	r2,r2,63
   2ae74:	e0bff415 	stw	r2,-48(fp)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
   2ae78:	00001906 	br	2aee0 <altera_avalon_uart_read+0xb8>
    {
      count++;
   2ae7c:	e0bff217 	ldw	r2,-56(fp)
   2ae80:	10800044 	addi	r2,r2,1
   2ae84:	e0bff215 	stw	r2,-56(fp)
      *ptr++ = sp->rx_buf[sp->rx_start];
   2ae88:	e0bffc17 	ldw	r2,-16(fp)
   2ae8c:	10800217 	ldw	r2,8(r2)
   2ae90:	e0fffc17 	ldw	r3,-16(fp)
   2ae94:	1885883a 	add	r2,r3,r2
   2ae98:	10800704 	addi	r2,r2,28
   2ae9c:	10800003 	ldbu	r2,0(r2)
   2aea0:	1007883a 	mov	r3,r2
   2aea4:	e0bffd17 	ldw	r2,-12(fp)
   2aea8:	10c00005 	stb	r3,0(r2)
   2aeac:	e0bffd17 	ldw	r2,-12(fp)
   2aeb0:	10800044 	addi	r2,r2,1
   2aeb4:	e0bffd15 	stw	r2,-12(fp)
      
      sp->rx_start = (++sp->rx_start) & ALT_AVALON_UART_BUF_MSK;
   2aeb8:	e0bffc17 	ldw	r2,-16(fp)
   2aebc:	10800217 	ldw	r2,8(r2)
   2aec0:	10c00044 	addi	r3,r2,1
   2aec4:	e0bffc17 	ldw	r2,-16(fp)
   2aec8:	10c00215 	stw	r3,8(r2)
   2aecc:	e0bffc17 	ldw	r2,-16(fp)
   2aed0:	10800217 	ldw	r2,8(r2)
   2aed4:	10c00fcc 	andi	r3,r2,63
   2aed8:	e0bffc17 	ldw	r2,-16(fp)
   2aedc:	10c00215 	stw	r3,8(r2)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
   2aee0:	e0fff217 	ldw	r3,-56(fp)
   2aee4:	e0bffe17 	ldw	r2,-8(fp)
   2aee8:	1880050e 	bge	r3,r2,2af00 <altera_avalon_uart_read+0xd8>
   2aeec:	e0bffc17 	ldw	r2,-16(fp)
   2aef0:	10c00217 	ldw	r3,8(r2)
   2aef4:	e0bffc17 	ldw	r2,-16(fp)
   2aef8:	10800317 	ldw	r2,12(r2)
   2aefc:	18bfdf1e 	bne	r3,r2,2ae7c <altera_avalon_uart_read+0x54>
    /*
     * If no data has been transferred, the circular buffer is empty, and
     * this is not a non-blocking access, block waiting for data to arrive.
     */

    if (!count && (sp->rx_start == sp->rx_end))
   2af00:	e0bff217 	ldw	r2,-56(fp)
   2af04:	10002f1e 	bne	r2,zero,2afc4 <altera_avalon_uart_read+0x19c>
   2af08:	e0bffc17 	ldw	r2,-16(fp)
   2af0c:	10c00217 	ldw	r3,8(r2)
   2af10:	e0bffc17 	ldw	r2,-16(fp)
   2af14:	10800317 	ldw	r2,12(r2)
   2af18:	18802a1e 	bne	r3,r2,2afc4 <altera_avalon_uart_read+0x19c>
    {
      if (!block)
   2af1c:	e0bff317 	ldw	r2,-52(fp)
   2af20:	1000061e 	bne	r2,zero,2af3c <altera_avalon_uart_read+0x114>
      {
        /* Set errno to indicate the reason we're not returning any data */

        ALT_ERRNO = EWOULDBLOCK;
   2af24:	002add80 	call	2add8 <alt_get_errno>
   2af28:	00c002c4 	movi	r3,11
   2af2c:	10c00015 	stw	r3,0(r2)
        read_would_block = 1;
   2af30:	00800044 	movi	r2,1
   2af34:	e0bff105 	stb	r2,-60(fp)
        break;
   2af38:	00002606 	br	2afd4 <altera_avalon_uart_read+0x1ac>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   2af3c:	0005303a 	rdctl	r2,status
   2af40:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   2af44:	e0fff617 	ldw	r3,-40(fp)
   2af48:	00bfff84 	movi	r2,-2
   2af4c:	1884703a 	and	r2,r3,r2
   2af50:	1001703a 	wrctl	status,r2
  
  return context;
   2af54:	e0bff617 	ldw	r2,-40(fp)
      {
       /* Block waiting for some data to arrive */

       /* First, ensure read interrupts are enabled to avoid deadlock */

       context = alt_irq_disable_all ();
   2af58:	e0bff515 	stw	r2,-44(fp)
       sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
   2af5c:	e0bffc17 	ldw	r2,-16(fp)
   2af60:	10800117 	ldw	r2,4(r2)
   2af64:	10c02014 	ori	r3,r2,128
   2af68:	e0bffc17 	ldw	r2,-16(fp)
   2af6c:	10c00115 	stw	r3,4(r2)
       IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
   2af70:	e0bffc17 	ldw	r2,-16(fp)
   2af74:	10800017 	ldw	r2,0(r2)
   2af78:	10800304 	addi	r2,r2,12
   2af7c:	e0fffc17 	ldw	r3,-16(fp)
   2af80:	18c00117 	ldw	r3,4(r3)
   2af84:	10c00035 	stwio	r3,0(r2)
   2af88:	e0bff517 	ldw	r2,-44(fp)
   2af8c:	e0bff715 	stw	r2,-36(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   2af90:	0005303a 	rdctl	r2,status
   2af94:	e0bff815 	stw	r2,-32(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   2af98:	e0fff817 	ldw	r3,-32(fp)
   2af9c:	00bfff84 	movi	r2,-2
   2afa0:	1884703a 	and	r2,r3,r2
   2afa4:	e0bff815 	stw	r2,-32(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   2afa8:	e0bff717 	ldw	r2,-36(fp)
   2afac:	1080004c 	andi	r2,r2,1
   2afb0:	e0fff817 	ldw	r3,-32(fp)
   2afb4:	1884b03a 	or	r2,r3,r2
   2afb8:	e0bff815 	stw	r2,-32(fp)
  
  NIOS2_WRITE_STATUS (status);
   2afbc:	e0bff817 	ldw	r2,-32(fp)
   2afc0:	1001703a 	wrctl	status,r2
                      OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                      0);
      }
    }
  }
  while (!count && len);
   2afc4:	e0bff217 	ldw	r2,-56(fp)
   2afc8:	1000021e 	bne	r2,zero,2afd4 <altera_avalon_uart_read+0x1ac>
   2afcc:	e0bffe17 	ldw	r2,-8(fp)
   2afd0:	103fc31e 	bne	r2,zero,2aee0 <altera_avalon_uart_read+0xb8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   2afd4:	0005303a 	rdctl	r2,status
   2afd8:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   2afdc:	e0fff917 	ldw	r3,-28(fp)
   2afe0:	00bfff84 	movi	r2,-2
   2afe4:	1884703a 	and	r2,r3,r2
   2afe8:	1001703a 	wrctl	status,r2
  
  return context;
   2afec:	e0bff917 	ldw	r2,-28(fp)
  /*
   * Ensure that interrupts are enabled, so that the circular buffer can
   * re-fill.
   */

  context = alt_irq_disable_all ();
   2aff0:	e0bff515 	stw	r2,-44(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
   2aff4:	e0bffc17 	ldw	r2,-16(fp)
   2aff8:	10800117 	ldw	r2,4(r2)
   2affc:	10c02014 	ori	r3,r2,128
   2b000:	e0bffc17 	ldw	r2,-16(fp)
   2b004:	10c00115 	stw	r3,4(r2)
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
   2b008:	e0bffc17 	ldw	r2,-16(fp)
   2b00c:	10800017 	ldw	r2,0(r2)
   2b010:	10800304 	addi	r2,r2,12
   2b014:	e0fffc17 	ldw	r3,-16(fp)
   2b018:	18c00117 	ldw	r3,4(r3)
   2b01c:	10c00035 	stwio	r3,0(r2)
   2b020:	e0bff517 	ldw	r2,-44(fp)
   2b024:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   2b028:	0005303a 	rdctl	r2,status
   2b02c:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   2b030:	e0fffb17 	ldw	r3,-20(fp)
   2b034:	00bfff84 	movi	r2,-2
   2b038:	1884703a 	and	r2,r3,r2
   2b03c:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   2b040:	e0bffa17 	ldw	r2,-24(fp)
   2b044:	1080004c 	andi	r2,r2,1
   2b048:	e0fffb17 	ldw	r3,-20(fp)
   2b04c:	1884b03a 	or	r2,r3,r2
   2b050:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
   2b054:	e0bffb17 	ldw	r2,-20(fp)
   2b058:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* Return the number of bytes read */
  if(read_would_block) {
   2b05c:	e0bff103 	ldbu	r2,-60(fp)
   2b060:	10000226 	beq	r2,zero,2b06c <altera_avalon_uart_read+0x244>
    return -EWOULDBLOCK;
   2b064:	00bffd44 	movi	r2,-11
   2b068:	00000106 	br	2b070 <altera_avalon_uart_read+0x248>
  }
  else {
    return count;
   2b06c:	e0bff217 	ldw	r2,-56(fp)
  }
}
   2b070:	e037883a 	mov	sp,fp
   2b074:	dfc00117 	ldw	ra,4(sp)
   2b078:	df000017 	ldw	fp,0(sp)
   2b07c:	dec00204 	addi	sp,sp,8
   2b080:	f800283a 	ret

0002b084 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   2b084:	defffe04 	addi	sp,sp,-8
   2b088:	dfc00115 	stw	ra,4(sp)
   2b08c:	df000015 	stw	fp,0(sp)
   2b090:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   2b094:	008000f4 	movhi	r2,3
   2b098:	10910004 	addi	r2,r2,17408
   2b09c:	10800017 	ldw	r2,0(r2)
   2b0a0:	10000526 	beq	r2,zero,2b0b8 <alt_get_errno+0x34>
   2b0a4:	008000f4 	movhi	r2,3
   2b0a8:	10910004 	addi	r2,r2,17408
   2b0ac:	10800017 	ldw	r2,0(r2)
   2b0b0:	103ee83a 	callr	r2
   2b0b4:	00000206 	br	2b0c0 <alt_get_errno+0x3c>
   2b0b8:	008000f4 	movhi	r2,3
   2b0bc:	1099dd04 	addi	r2,r2,26484
}
   2b0c0:	e037883a 	mov	sp,fp
   2b0c4:	dfc00117 	ldw	ra,4(sp)
   2b0c8:	df000017 	ldw	fp,0(sp)
   2b0cc:	dec00204 	addi	sp,sp,8
   2b0d0:	f800283a 	ret

0002b0d4 <altera_avalon_uart_write>:
 */

int
altera_avalon_uart_write(altera_avalon_uart_state* sp, const char* ptr, int len,
  int flags)
{
   2b0d4:	defff004 	addi	sp,sp,-64
   2b0d8:	dfc00f15 	stw	ra,60(sp)
   2b0dc:	df000e15 	stw	fp,56(sp)
   2b0e0:	df000e04 	addi	fp,sp,56
   2b0e4:	e13ffc15 	stw	r4,-16(fp)
   2b0e8:	e17ffd15 	stw	r5,-12(fp)
   2b0ec:	e1bffe15 	stw	r6,-8(fp)
   2b0f0:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             no_block;
  alt_u32         next;
  int             count = len;
   2b0f4:	e0bffe17 	ldw	r2,-8(fp)
   2b0f8:	e0bff215 	stw	r2,-56(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  no_block = (flags & O_NONBLOCK);
   2b0fc:	e0bfff17 	ldw	r2,-4(fp)
   2b100:	1090000c 	andi	r2,r2,16384
   2b104:	e0bff315 	stw	r2,-52(fp)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
   2b108:	00004606 	br	2b224 <altera_avalon_uart_write+0x150>
  {
    /* Determine the next slot in the buffer to access */

    next = (sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK;
   2b10c:	e0bffc17 	ldw	r2,-16(fp)
   2b110:	10800517 	ldw	r2,20(r2)
   2b114:	10800044 	addi	r2,r2,1
   2b118:	10800fcc 	andi	r2,r2,63
   2b11c:	e0bff415 	stw	r2,-48(fp)

    /* block waiting for space if necessary */

    if (next == sp->tx_start)
   2b120:	e0bffc17 	ldw	r2,-16(fp)
   2b124:	10c00417 	ldw	r3,16(r2)
   2b128:	e0bff417 	ldw	r2,-48(fp)
   2b12c:	18802c1e 	bne	r3,r2,2b1e0 <altera_avalon_uart_write+0x10c>
    {
      if (no_block)
   2b130:	e0bff317 	ldw	r2,-52(fp)
   2b134:	10000426 	beq	r2,zero,2b148 <altera_avalon_uart_write+0x74>
      {
        /* Set errno to indicate why this function returned early */
 
        ALT_ERRNO = EWOULDBLOCK;
   2b138:	002b0840 	call	2b084 <alt_get_errno>
   2b13c:	00c002c4 	movi	r3,11
   2b140:	10c00015 	stw	r3,0(r2)
        break;
   2b144:	00003906 	br	2b22c <altera_avalon_uart_write+0x158>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   2b148:	0005303a 	rdctl	r2,status
   2b14c:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   2b150:	e0fff617 	ldw	r3,-40(fp)
   2b154:	00bfff84 	movi	r2,-2
   2b158:	1884703a 	and	r2,r3,r2
   2b15c:	1001703a 	wrctl	status,r2
  
  return context;
   2b160:	e0bff617 	ldw	r2,-40(fp)
      {
        /* Block waiting for space in the circular buffer */

        /* First, ensure transmit interrupts are enabled to avoid deadlock */

        context = alt_irq_disable_all ();
   2b164:	e0bff515 	stw	r2,-44(fp)
        sp->ctrl |= (ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
   2b168:	e0bffc17 	ldw	r2,-16(fp)
   2b16c:	10800117 	ldw	r2,4(r2)
   2b170:	10c11014 	ori	r3,r2,1088
   2b174:	e0bffc17 	ldw	r2,-16(fp)
   2b178:	10c00115 	stw	r3,4(r2)
                        ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
        IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
   2b17c:	e0bffc17 	ldw	r2,-16(fp)
   2b180:	10800017 	ldw	r2,0(r2)
   2b184:	10800304 	addi	r2,r2,12
   2b188:	e0fffc17 	ldw	r3,-16(fp)
   2b18c:	18c00117 	ldw	r3,4(r3)
   2b190:	10c00035 	stwio	r3,0(r2)
   2b194:	e0bff517 	ldw	r2,-44(fp)
   2b198:	e0bff715 	stw	r2,-36(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   2b19c:	0005303a 	rdctl	r2,status
   2b1a0:	e0bff815 	stw	r2,-32(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   2b1a4:	e0fff817 	ldw	r3,-32(fp)
   2b1a8:	00bfff84 	movi	r2,-2
   2b1ac:	1884703a 	and	r2,r3,r2
   2b1b0:	e0bff815 	stw	r2,-32(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   2b1b4:	e0bff717 	ldw	r2,-36(fp)
   2b1b8:	1080004c 	andi	r2,r2,1
   2b1bc:	e0fff817 	ldw	r3,-32(fp)
   2b1c0:	1884b03a 	or	r2,r3,r2
   2b1c4:	e0bff815 	stw	r2,-32(fp)
  
  NIOS2_WRITE_STATUS (status);
   2b1c8:	e0bff817 	ldw	r2,-32(fp)
   2b1cc:	1001703a 	wrctl	status,r2
          ALT_FLAG_PEND (sp->events, 
                         ALT_UART_WRITE_RDY,
                         OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                         0);
        }
        while ((next == sp->tx_start));
   2b1d0:	e0bffc17 	ldw	r2,-16(fp)
   2b1d4:	10c00417 	ldw	r3,16(r2)
   2b1d8:	e0bff417 	ldw	r2,-48(fp)
   2b1dc:	18bffc26 	beq	r3,r2,2b1d0 <altera_avalon_uart_write+0xfc>
      }
    }

    count--;
   2b1e0:	e0bff217 	ldw	r2,-56(fp)
   2b1e4:	10bfffc4 	addi	r2,r2,-1
   2b1e8:	e0bff215 	stw	r2,-56(fp)

    /* Add the next character to the transmit buffer */

    sp->tx_buf[sp->tx_end] = *ptr++;
   2b1ec:	e0bffc17 	ldw	r2,-16(fp)
   2b1f0:	10800517 	ldw	r2,20(r2)
   2b1f4:	e0fffd17 	ldw	r3,-12(fp)
   2b1f8:	18c00003 	ldbu	r3,0(r3)
   2b1fc:	e13ffc17 	ldw	r4,-16(fp)
   2b200:	2085883a 	add	r2,r4,r2
   2b204:	10801704 	addi	r2,r2,92
   2b208:	10c00005 	stb	r3,0(r2)
   2b20c:	e0bffd17 	ldw	r2,-12(fp)
   2b210:	10800044 	addi	r2,r2,1
   2b214:	e0bffd15 	stw	r2,-12(fp)
    sp->tx_end = next;
   2b218:	e0bffc17 	ldw	r2,-16(fp)
   2b21c:	e0fff417 	ldw	r3,-48(fp)
   2b220:	10c00515 	stw	r3,20(r2)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
   2b224:	e0bff217 	ldw	r2,-56(fp)
   2b228:	103fb81e 	bne	r2,zero,2b10c <altera_avalon_uart_write+0x38>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   2b22c:	0005303a 	rdctl	r2,status
   2b230:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   2b234:	e0fff917 	ldw	r3,-28(fp)
   2b238:	00bfff84 	movi	r2,-2
   2b23c:	1884703a 	and	r2,r3,r2
   2b240:	1001703a 	wrctl	status,r2
  
  return context;
   2b244:	e0bff917 	ldw	r2,-28(fp)
  /* 
   * Ensure that interrupts are enabled, so that the circular buffer can 
   * drain.
   */

  context = alt_irq_disable_all ();
   2b248:	e0bff515 	stw	r2,-44(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
   2b24c:	e0bffc17 	ldw	r2,-16(fp)
   2b250:	10800117 	ldw	r2,4(r2)
   2b254:	10c11014 	ori	r3,r2,1088
   2b258:	e0bffc17 	ldw	r2,-16(fp)
   2b25c:	10c00115 	stw	r3,4(r2)
                 ALTERA_AVALON_UART_CONTROL_DCTS_MSK;
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
   2b260:	e0bffc17 	ldw	r2,-16(fp)
   2b264:	10800017 	ldw	r2,0(r2)
   2b268:	10800304 	addi	r2,r2,12
   2b26c:	e0fffc17 	ldw	r3,-16(fp)
   2b270:	18c00117 	ldw	r3,4(r3)
   2b274:	10c00035 	stwio	r3,0(r2)
   2b278:	e0bff517 	ldw	r2,-44(fp)
   2b27c:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   2b280:	0005303a 	rdctl	r2,status
   2b284:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   2b288:	e0fffb17 	ldw	r3,-20(fp)
   2b28c:	00bfff84 	movi	r2,-2
   2b290:	1884703a 	and	r2,r3,r2
   2b294:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   2b298:	e0bffa17 	ldw	r2,-24(fp)
   2b29c:	1080004c 	andi	r2,r2,1
   2b2a0:	e0fffb17 	ldw	r3,-20(fp)
   2b2a4:	1884b03a 	or	r2,r3,r2
   2b2a8:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
   2b2ac:	e0bffb17 	ldw	r2,-20(fp)
   2b2b0:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* return the number of bytes written */

  return (len - count);
   2b2b4:	e0fffe17 	ldw	r3,-8(fp)
   2b2b8:	e0bff217 	ldw	r2,-56(fp)
   2b2bc:	1885c83a 	sub	r2,r3,r2
}
   2b2c0:	e037883a 	mov	sp,fp
   2b2c4:	dfc00117 	ldw	ra,4(sp)
   2b2c8:	df000017 	ldw	fp,0(sp)
   2b2cc:	dec00204 	addi	sp,sp,8
   2b2d0:	f800283a 	ret

0002b2d4 <VIC_0_VECTOR_TABLE>:

    .section .text, "xa"
    .align 2
    .globl VIC_0_VECTOR_TABLE
VIC_0_VECTOR_TABLE:
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2b2d4:	0030e03a 	nextpc	et
   2b2d8:	002b4d41 	jmpi	2b4d4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2b2e4:	0030e03a 	nextpc	et
   2b2e8:	002b4d41 	jmpi	2b4d4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2b2f4:	0030e03a 	nextpc	et
   2b2f8:	002b4d41 	jmpi	2b4d4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2b304:	0030e03a 	nextpc	et
   2b308:	002b4d41 	jmpi	2b4d4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2b314:	0030e03a 	nextpc	et
   2b318:	002b4d41 	jmpi	2b4d4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2b324:	0030e03a 	nextpc	et
   2b328:	002b4d41 	jmpi	2b4d4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2b334:	0030e03a 	nextpc	et
   2b338:	002b4d41 	jmpi	2b4d4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2b344:	0030e03a 	nextpc	et
   2b348:	002b4d41 	jmpi	2b4d4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2b354:	0030e03a 	nextpc	et
   2b358:	002b4d41 	jmpi	2b4d4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2b364:	0030e03a 	nextpc	et
   2b368:	002b4d41 	jmpi	2b4d4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2b374:	0030e03a 	nextpc	et
   2b378:	002b4d41 	jmpi	2b4d4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2b384:	0030e03a 	nextpc	et
   2b388:	002b4d41 	jmpi	2b4d4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2b394:	0030e03a 	nextpc	et
   2b398:	002b4d41 	jmpi	2b4d4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2b3a4:	0030e03a 	nextpc	et
   2b3a8:	002b4d41 	jmpi	2b4d4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2b3b4:	0030e03a 	nextpc	et
   2b3b8:	002b4d41 	jmpi	2b4d4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2b3c4:	0030e03a 	nextpc	et
   2b3c8:	002b4d41 	jmpi	2b4d4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2b3d4:	0030e03a 	nextpc	et
   2b3d8:	002b4d41 	jmpi	2b4d4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2b3e4:	0030e03a 	nextpc	et
   2b3e8:	002b4d41 	jmpi	2b4d4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2b3f4:	0030e03a 	nextpc	et
   2b3f8:	002b4d41 	jmpi	2b4d4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2b404:	0030e03a 	nextpc	et
   2b408:	002b4d41 	jmpi	2b4d4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2b414:	0030e03a 	nextpc	et
   2b418:	002b4d41 	jmpi	2b4d4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2b424:	0030e03a 	nextpc	et
   2b428:	002b4d41 	jmpi	2b4d4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2b434:	0030e03a 	nextpc	et
   2b438:	002b4d41 	jmpi	2b4d4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2b444:	0030e03a 	nextpc	et
   2b448:	002b4d41 	jmpi	2b4d4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2b454:	0030e03a 	nextpc	et
   2b458:	002b4d41 	jmpi	2b4d4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2b464:	0030e03a 	nextpc	et
   2b468:	002b4d41 	jmpi	2b4d4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2b474:	0030e03a 	nextpc	et
   2b478:	002b4d41 	jmpi	2b4d4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2b484:	0030e03a 	nextpc	et
   2b488:	002b4d41 	jmpi	2b4d4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2b494:	0030e03a 	nextpc	et
   2b498:	002b4d41 	jmpi	2b4d4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2b4a4:	0030e03a 	nextpc	et
   2b4a8:	002b4d41 	jmpi	2b4d4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2b4b4:	0030e03a 	nextpc	et
   2b4b8:	002b4d41 	jmpi	2b4d4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2b4c4:	0030e03a 	nextpc	et
   2b4c8:	002b4d41 	jmpi	2b4d4 <alt_shadow_non_preemptive_interrupt>
	...

0002b4d4 <alt_shadow_non_preemptive_interrupt>:
    .section ALTERA_VIC_DRIVER_LINKER_SECTION
    .set nobreak
    .globl alt_shadow_non_preemptive_interrupt
alt_shadow_non_preemptive_interrupt:

    ldw r16, 4(et)               /* load ISR pointer */
   2b4d4:	c4000117 	ldw	r16,4(et)

     /*
      * Get SP from previous register set.
      */

    rdprs sp, sp, 0
   2b4d8:	dec00038 	rdprs	sp,sp,0
  /*
   * Notify the operating system that we are at interrupt level.
   */
    ALT_OS_INT_ENTER_ASM

    ldw r4, 8(et)               /* load isr_context */
   2b4dc:	c1000217 	ldw	r4,8(et)
    callr r16                   /* call ISR */
   2b4e0:	803ee83a 	callr	r16
    /*
     * Notify the operating system that interrupt processing is complete.
     */
    ALT_OS_INT_EXIT_ASM

    addi ea, ea, -4             /* instruction that caused exception */
   2b4e4:	ef7fff04 	addi	ea,ea,-4
    eret
   2b4e8:	ef80083a 	eret

0002b4ec <alt_vic_irq_init>:
  * @API Type:              Internal
  * @param pdev             pointer of type alt_vic_dev, main Device Structure.
  * @return                 None
  */
void alt_vic_irq_init (alt_vic_dev* pdev)
{
   2b4ec:	defffd04 	addi	sp,sp,-12
   2b4f0:	df000215 	stw	fp,8(sp)
   2b4f4:	df000204 	addi	fp,sp,8
   2b4f8:	e13fff15 	stw	r4,-4(fp)
    alt_u32 i;
    static const int VEC_SIZE_ARRAY[]={4, 8, 16, 32, 64, 128, 256, 512};

    /* Stores the VIC instance to list */
    alt_vic_dev_list[pdev->intr_controller_id] = pdev;
   2b4fc:	e0bfff17 	ldw	r2,-4(fp)
   2b500:	10800117 	ldw	r2,4(r2)
   2b504:	1085883a 	add	r2,r2,r2
   2b508:	1087883a 	add	r3,r2,r2
   2b50c:	d0a8f804 	addi	r2,gp,-23584
   2b510:	1885883a 	add	r2,r3,r2
   2b514:	e0ffff17 	ldw	r3,-4(fp)
   2b518:	10c00015 	stw	r3,0(r2)

    /* Disables all interrupts */
    IOWR_ALTERA_VIC_INT_ENABLE_CLR(pdev->base, 0xFFFFFFFF);
   2b51c:	e0bfff17 	ldw	r2,-4(fp)
   2b520:	10800017 	ldw	r2,0(r2)
   2b524:	10802204 	addi	r2,r2,136
   2b528:	00ffffc4 	movi	r3,-1
   2b52c:	10c00035 	stwio	r3,0(r2)

    /* Initialize INT_CONFIG for all interrupts in this VIC */
    for(i = 0; i < pdev->num_of_intr_ports; i++)
   2b530:	e03ffe15 	stw	zero,-8(fp)
   2b534:	00001106 	br	2b57c <alt_vic_irq_init+0x90>
    {
        IOWR_ALTERA_VIC_INT_CONFIG(pdev->base, i, pdev->int_config[i]);
   2b538:	e0bfff17 	ldw	r2,-4(fp)
   2b53c:	10c00017 	ldw	r3,0(r2)
   2b540:	e0bffe17 	ldw	r2,-8(fp)
   2b544:	1085883a 	add	r2,r2,r2
   2b548:	1085883a 	add	r2,r2,r2
   2b54c:	1887883a 	add	r3,r3,r2
   2b550:	e13fff17 	ldw	r4,-4(fp)
   2b554:	e0bffe17 	ldw	r2,-8(fp)
   2b558:	108001c4 	addi	r2,r2,7
   2b55c:	1085883a 	add	r2,r2,r2
   2b560:	1085883a 	add	r2,r2,r2
   2b564:	2085883a 	add	r2,r4,r2
   2b568:	10800017 	ldw	r2,0(r2)
   2b56c:	18800035 	stwio	r2,0(r3)

    /* Disables all interrupts */
    IOWR_ALTERA_VIC_INT_ENABLE_CLR(pdev->base, 0xFFFFFFFF);

    /* Initialize INT_CONFIG for all interrupts in this VIC */
    for(i = 0; i < pdev->num_of_intr_ports; i++)
   2b570:	e0bffe17 	ldw	r2,-8(fp)
   2b574:	10800044 	addi	r2,r2,1
   2b578:	e0bffe15 	stw	r2,-8(fp)
   2b57c:	e0bfff17 	ldw	r2,-4(fp)
   2b580:	10800217 	ldw	r2,8(r2)
   2b584:	e0fffe17 	ldw	r3,-8(fp)
   2b588:	18bfeb36 	bltu	r3,r2,2b538 <alt_vic_irq_init+0x4c>
    {
        IOWR_ALTERA_VIC_INT_CONFIG(pdev->base, i, pdev->int_config[i]);
    }

    /* Set vector size and disable/enable daisy-chained input */
    for(i = 0; i < sizeof(VEC_SIZE_ARRAY)/sizeof(VEC_SIZE_ARRAY[0]); i++)
   2b58c:	e03ffe15 	stw	zero,-8(fp)
   2b590:	00001806 	br	2b5f4 <alt_vic_irq_init+0x108>
    {
        if(VEC_SIZE_ARRAY[i] == pdev->vec_size)
   2b594:	00c000f4 	movhi	r3,3
   2b598:	18c7b904 	addi	r3,r3,7908
   2b59c:	e0bffe17 	ldw	r2,-8(fp)
   2b5a0:	1085883a 	add	r2,r2,r2
   2b5a4:	1085883a 	add	r2,r2,r2
   2b5a8:	1885883a 	add	r2,r3,r2
   2b5ac:	10800017 	ldw	r2,0(r2)
   2b5b0:	1007883a 	mov	r3,r2
   2b5b4:	e0bfff17 	ldw	r2,-4(fp)
   2b5b8:	10800517 	ldw	r2,20(r2)
   2b5bc:	18800a1e 	bne	r3,r2,2b5e8 <alt_vic_irq_init+0xfc>
        {
            IOWR_ALTERA_VIC_CONFIG(pdev->base,
   2b5c0:	e0bfff17 	ldw	r2,-4(fp)
   2b5c4:	10800017 	ldw	r2,0(r2)
   2b5c8:	10802804 	addi	r2,r2,160
   2b5cc:	e0ffff17 	ldw	r3,-4(fp)
   2b5d0:	18c00417 	ldw	r3,16(r3)
   2b5d4:	180890fa 	slli	r4,r3,3
   2b5d8:	e0fffe17 	ldw	r3,-8(fp)
   2b5dc:	20c6b03a 	or	r3,r4,r3
   2b5e0:	10c00035 	stwio	r3,0(r2)
                (i | (pdev->daisy_chain_present << ALTERA_VIC_CONFIG_DC_OFST)));
            break;
   2b5e4:	00000606 	br	2b600 <alt_vic_irq_init+0x114>
    {
        IOWR_ALTERA_VIC_INT_CONFIG(pdev->base, i, pdev->int_config[i]);
    }

    /* Set vector size and disable/enable daisy-chained input */
    for(i = 0; i < sizeof(VEC_SIZE_ARRAY)/sizeof(VEC_SIZE_ARRAY[0]); i++)
   2b5e8:	e0bffe17 	ldw	r2,-8(fp)
   2b5ec:	10800044 	addi	r2,r2,1
   2b5f0:	e0bffe15 	stw	r2,-8(fp)
   2b5f4:	e0bffe17 	ldw	r2,-8(fp)
   2b5f8:	10800230 	cmpltui	r2,r2,8
   2b5fc:	103fe51e 	bne	r2,zero,2b594 <alt_vic_irq_init+0xa8>
            break;
        }
    }

    /* Set vector table base address */
    IOWR_ALTERA_VIC_VEC_TBL_BASE(pdev->base,((alt_u32)pdev->vec_addr));
   2b600:	e0bfff17 	ldw	r2,-4(fp)
   2b604:	10800017 	ldw	r2,0(r2)
   2b608:	10802a04 	addi	r2,r2,168
   2b60c:	e0ffff17 	ldw	r3,-4(fp)
   2b610:	18c00617 	ldw	r3,24(r3)
   2b614:	10c00035 	stwio	r3,0(r2)
}
   2b618:	e037883a 	mov	sp,fp
   2b61c:	df000017 	ldw	fp,0(sp)
   2b620:	dec00104 	addi	sp,sp,4
   2b624:	f800283a 	ret

0002b628 <alt_ic_isr_register>:
int alt_ic_isr_register(alt_u32 ic_id,
                        alt_u32 irq,
                        alt_isr_func isr,
                        void *isr_context,
                        void* flags)
{
   2b628:	defff504 	addi	sp,sp,-44
   2b62c:	df000a15 	stw	fp,40(sp)
   2b630:	df000a04 	addi	fp,sp,40
   2b634:	e13ffc15 	stw	r4,-16(fp)
   2b638:	e17ffd15 	stw	r5,-12(fp)
   2b63c:	e1bffe15 	stw	r6,-8(fp)
   2b640:	e1ffff15 	stw	r7,-4(fp)
    alt_vic_dev *pdev;
    alt_u32 *offset;
    alt_irq_context status;

    if(ic_id >= ALT_NUM_EXTERNAL_INTERRUPT_CONTROLLERS)
   2b644:	e0bffc17 	ldw	r2,-16(fp)
   2b648:	10000226 	beq	r2,zero,2b654 <alt_ic_isr_register+0x2c>
        return -1;
   2b64c:	00bfffc4 	movi	r2,-1
   2b650:	00004706 	br	2b770 <alt_ic_isr_register+0x148>

    /* Get VIC handle */
    pdev = alt_vic_dev_list[ic_id];
   2b654:	00c000f4 	movhi	r3,3
   2b658:	18d9e404 	addi	r3,r3,26512
   2b65c:	e0bffc17 	ldw	r2,-16(fp)
   2b660:	1085883a 	add	r2,r2,r2
   2b664:	1085883a 	add	r2,r2,r2
   2b668:	1885883a 	add	r2,r3,r2
   2b66c:	10800017 	ldw	r2,0(r2)
   2b670:	e0bff615 	stw	r2,-40(fp)

    if(irq < pdev->num_of_intr_ports)
   2b674:	e0bff617 	ldw	r2,-40(fp)
   2b678:	10800217 	ldw	r2,8(r2)
   2b67c:	e0fffd17 	ldw	r3,-12(fp)
   2b680:	18803a2e 	bgeu	r3,r2,2b76c <alt_ic_isr_register+0x144>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   2b684:	0005303a 	rdctl	r2,status
   2b688:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   2b68c:	e0fff917 	ldw	r3,-28(fp)
   2b690:	00bfff84 	movi	r2,-2
   2b694:	1884703a 	and	r2,r3,r2
   2b698:	1001703a 	wrctl	status,r2
  
  return context;
   2b69c:	e0bff917 	ldw	r2,-28(fp)
    {
        /* Disable all interrupts */
        status = alt_irq_disable_all ();
   2b6a0:	e0bff715 	stw	r2,-36(fp)

        /* Get table offset */
        offset = pdev->vec_addr + (irq * pdev->vec_size);
   2b6a4:	e0bff617 	ldw	r2,-40(fp)
   2b6a8:	10c00617 	ldw	r3,24(r2)
   2b6ac:	e0bff617 	ldw	r2,-40(fp)
   2b6b0:	11000517 	ldw	r4,20(r2)
   2b6b4:	e0bffd17 	ldw	r2,-12(fp)
   2b6b8:	2085383a 	mul	r2,r4,r2
   2b6bc:	1885883a 	add	r2,r3,r2
   2b6c0:	e0bff815 	stw	r2,-32(fp)

        /* Write ISR and ISR context to vector table */
        ALT_VECTOR_TABLE_WRITE(offset+2, isr);
   2b6c4:	e0bff817 	ldw	r2,-32(fp)
   2b6c8:	10800204 	addi	r2,r2,8
   2b6cc:	e0fffe17 	ldw	r3,-8(fp)
   2b6d0:	10c00015 	stw	r3,0(r2)
        ALT_VECTOR_TABLE_WRITE(offset+3, isr_context);
   2b6d4:	e0bff817 	ldw	r2,-32(fp)
   2b6d8:	10800304 	addi	r2,r2,12
   2b6dc:	e0ffff17 	ldw	r3,-4(fp)
   2b6e0:	10c00015 	stw	r3,0(r2)

        if(isr)
   2b6e4:	e0bffe17 	ldw	r2,-8(fp)
   2b6e8:	10000826 	beq	r2,zero,2b70c <alt_ic_isr_register+0xe4>
        {
            /* Enable this IRQ on the VIC */
            IOWR_ALTERA_VIC_INT_ENABLE_SET(pdev->base, 1 << irq);
   2b6ec:	e0bff617 	ldw	r2,-40(fp)
   2b6f0:	10800017 	ldw	r2,0(r2)
   2b6f4:	10802104 	addi	r2,r2,132
   2b6f8:	e0fffd17 	ldw	r3,-12(fp)
   2b6fc:	01000044 	movi	r4,1
   2b700:	20c6983a 	sll	r3,r4,r3
   2b704:	10c00035 	stwio	r3,0(r2)
   2b708:	00000706 	br	2b728 <alt_ic_isr_register+0x100>
        }
        else
        {
            /* Disable this IRQ on the VIC */
            IOWR_ALTERA_VIC_INT_ENABLE_CLR(pdev->base, 1 << irq);
   2b70c:	e0bff617 	ldw	r2,-40(fp)
   2b710:	10800017 	ldw	r2,0(r2)
   2b714:	10802204 	addi	r2,r2,136
   2b718:	e0fffd17 	ldw	r3,-12(fp)
   2b71c:	01000044 	movi	r4,1
   2b720:	20c6983a 	sll	r3,r4,r3
   2b724:	10c00035 	stwio	r3,0(r2)
   2b728:	e0bff717 	ldw	r2,-36(fp)
   2b72c:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   2b730:	0005303a 	rdctl	r2,status
   2b734:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   2b738:	e0fffb17 	ldw	r3,-20(fp)
   2b73c:	00bfff84 	movi	r2,-2
   2b740:	1884703a 	and	r2,r3,r2
   2b744:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   2b748:	e0bffa17 	ldw	r2,-24(fp)
   2b74c:	1080004c 	andi	r2,r2,1
   2b750:	e0fffb17 	ldw	r3,-20(fp)
   2b754:	1884b03a 	or	r2,r3,r2
   2b758:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
   2b75c:	e0bffb17 	ldw	r2,-20(fp)
   2b760:	1001703a 	wrctl	status,r2
        }

        /* Re-enable all interrupts */
        alt_irq_enable_all(status);

        return 0;
   2b764:	0005883a 	mov	r2,zero
   2b768:	00000106 	br	2b770 <alt_ic_isr_register+0x148>
    }

    return -1;
   2b76c:	00bfffc4 	movi	r2,-1
}
   2b770:	e037883a 	mov	sp,fp
   2b774:	df000017 	ldw	fp,0(sp)
   2b778:	dec00104 	addi	sp,sp,4
   2b77c:	f800283a 	ret

0002b780 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
   2b780:	defffb04 	addi	sp,sp,-20
   2b784:	df000415 	stw	fp,16(sp)
   2b788:	df000404 	addi	fp,sp,16
   2b78c:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
   2b790:	008000c4 	movi	r2,3
   2b794:	e0bffd15 	stw	r2,-12(fp)
  }
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));
   2b798:	e0fffd17 	ldw	r3,-12(fp)
   2b79c:	008003f4 	movhi	r2,15
   2b7a0:	10909004 	addi	r2,r2,16960
   2b7a4:	1885383a 	mul	r2,r3,r2
   2b7a8:	00c17db4 	movhi	r3,1526
   2b7ac:	18f84004 	addi	r3,r3,-7936
   2b7b0:	1885203a 	divu	r2,r3,r2
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
   2b7b4:	00e00034 	movhi	r3,32768
   2b7b8:	18ffffc4 	addi	r3,r3,-1
   2b7bc:	1885203a 	divu	r2,r3,r2
   2b7c0:	e0ffff17 	ldw	r3,-4(fp)
   2b7c4:	1885203a 	divu	r2,r3,r2
   2b7c8:	e0bffe15 	stw	r2,-8(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
   2b7cc:	e0bffe17 	ldw	r2,-8(fp)
   2b7d0:	10002526 	beq	r2,zero,2b868 <alt_busy_sleep+0xe8>
  {
    for(i=0;i<big_loops;i++)
   2b7d4:	e03ffc15 	stw	zero,-16(fp)
   2b7d8:	00001406 	br	2b82c <alt_busy_sleep+0xac>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
   2b7dc:	00a00034 	movhi	r2,32768
   2b7e0:	10bfffc4 	addi	r2,r2,-1
   2b7e4:	10bfffc4 	addi	r2,r2,-1
   2b7e8:	103ffe1e 	bne	r2,zero,2b7e4 <alt_busy_sleep+0x64>
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
      (cycles_per_loop * 1000000)));
   2b7ec:	e0fffd17 	ldw	r3,-12(fp)
   2b7f0:	008003f4 	movhi	r2,15
   2b7f4:	10909004 	addi	r2,r2,16960
   2b7f8:	1885383a 	mul	r2,r3,r2
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
   2b7fc:	00c17db4 	movhi	r3,1526
   2b800:	18f84004 	addi	r3,r3,-7936
   2b804:	1885203a 	divu	r2,r3,r2
   2b808:	00e00034 	movhi	r3,32768
   2b80c:	18ffffc4 	addi	r3,r3,-1
   2b810:	1885203a 	divu	r2,r3,r2
   2b814:	e0ffff17 	ldw	r3,-4(fp)
   2b818:	1885c83a 	sub	r2,r3,r2
   2b81c:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
   2b820:	e0bffc17 	ldw	r2,-16(fp)
   2b824:	10800044 	addi	r2,r2,1
   2b828:	e0bffc15 	stw	r2,-16(fp)
   2b82c:	e0fffc17 	ldw	r3,-16(fp)
   2b830:	e0bffe17 	ldw	r2,-8(fp)
   2b834:	18bfe916 	blt	r3,r2,2b7dc <alt_busy_sleep+0x5c>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
   2b838:	e0fffd17 	ldw	r3,-12(fp)
   2b83c:	008003f4 	movhi	r2,15
   2b840:	10909004 	addi	r2,r2,16960
   2b844:	1885383a 	mul	r2,r3,r2
   2b848:	00c17db4 	movhi	r3,1526
   2b84c:	18f84004 	addi	r3,r3,-7936
   2b850:	1887203a 	divu	r3,r3,r2
   2b854:	e0bfff17 	ldw	r2,-4(fp)
   2b858:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
   2b85c:	10bfffc4 	addi	r2,r2,-1
   2b860:	103ffe1e 	bne	r2,zero,2b85c <alt_busy_sleep+0xdc>
   2b864:	00000b06 	br	2b894 <alt_busy_sleep+0x114>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
   2b868:	e0fffd17 	ldw	r3,-12(fp)
   2b86c:	008003f4 	movhi	r2,15
   2b870:	10909004 	addi	r2,r2,16960
   2b874:	1885383a 	mul	r2,r3,r2
   2b878:	00c17db4 	movhi	r3,1526
   2b87c:	18f84004 	addi	r3,r3,-7936
   2b880:	1887203a 	divu	r3,r3,r2
   2b884:	e0bfff17 	ldw	r2,-4(fp)
   2b888:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
   2b88c:	10bfffc4 	addi	r2,r2,-1
   2b890:	00bffe16 	blt	zero,r2,2b88c <alt_busy_sleep+0x10c>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
   2b894:	0005883a 	mov	r2,zero
}
   2b898:	e037883a 	mov	sp,fp
   2b89c:	df000017 	ldw	fp,0(sp)
   2b8a0:	dec00104 	addi	sp,sp,4
   2b8a4:	f800283a 	ret

0002b8a8 <alt_dcache_flush>:
 *
 * Any dirty lines in the data cache are written back to memory.
 */

void alt_dcache_flush (void* start, alt_u32 len)
{
   2b8a8:	defffd04 	addi	sp,sp,-12
   2b8ac:	df000215 	stw	fp,8(sp)
   2b8b0:	df000204 	addi	fp,sp,8
   2b8b4:	e13ffe15 	stw	r4,-8(fp)
   2b8b8:	e17fff15 	stw	r5,-4(fp)
  {
    ALT_FLUSH_DATA(i);
  }

#endif /* NIOS2_DCACHE_SIZE > 0 */
}
   2b8bc:	e037883a 	mov	sp,fp
   2b8c0:	df000017 	ldw	fp,0(sp)
   2b8c4:	dec00104 	addi	sp,sp,4
   2b8c8:	f800283a 	ret

0002b8cc <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
   2b8cc:	deffff04 	addi	sp,sp,-4
   2b8d0:	df000015 	stw	fp,0(sp)
   2b8d4:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
   2b8d8:	e037883a 	mov	sp,fp
   2b8dc:	df000017 	ldw	fp,0(sp)
   2b8e0:	dec00104 	addi	sp,sp,4
   2b8e4:	f800283a 	ret

0002b8e8 <alt_get_errno>:
   2b8e8:	defffe04 	addi	sp,sp,-8
   2b8ec:	dfc00115 	stw	ra,4(sp)
   2b8f0:	df000015 	stw	fp,0(sp)
   2b8f4:	d839883a 	mov	fp,sp
   2b8f8:	008000f4 	movhi	r2,3
   2b8fc:	10910004 	addi	r2,r2,17408
   2b900:	10800017 	ldw	r2,0(r2)
   2b904:	10000526 	beq	r2,zero,2b91c <alt_get_errno+0x34>
   2b908:	008000f4 	movhi	r2,3
   2b90c:	10910004 	addi	r2,r2,17408
   2b910:	10800017 	ldw	r2,0(r2)
   2b914:	103ee83a 	callr	r2
   2b918:	00000206 	br	2b924 <alt_get_errno+0x3c>
   2b91c:	008000f4 	movhi	r2,3
   2b920:	1099dd04 	addi	r2,r2,26484
   2b924:	e037883a 	mov	sp,fp
   2b928:	dfc00117 	ldw	ra,4(sp)
   2b92c:	df000017 	ldw	fp,0(sp)
   2b930:	dec00204 	addi	sp,sp,8
   2b934:	f800283a 	ret

0002b938 <alt_dev_llist_insert>:
   2b938:	defffa04 	addi	sp,sp,-24
   2b93c:	dfc00515 	stw	ra,20(sp)
   2b940:	df000415 	stw	fp,16(sp)
   2b944:	df000404 	addi	fp,sp,16
   2b948:	e13ffe15 	stw	r4,-8(fp)
   2b94c:	e17fff15 	stw	r5,-4(fp)
   2b950:	e0bffe17 	ldw	r2,-8(fp)
   2b954:	10000326 	beq	r2,zero,2b964 <alt_dev_llist_insert+0x2c>
   2b958:	e0bffe17 	ldw	r2,-8(fp)
   2b95c:	10800217 	ldw	r2,8(r2)
   2b960:	1000051e 	bne	r2,zero,2b978 <alt_dev_llist_insert+0x40>
   2b964:	002b8e80 	call	2b8e8 <alt_get_errno>
   2b968:	00c00584 	movi	r3,22
   2b96c:	10c00015 	stw	r3,0(r2)
   2b970:	00bffa84 	movi	r2,-22
   2b974:	00001306 	br	2b9c4 <alt_dev_llist_insert+0x8c>
   2b978:	e0bffe17 	ldw	r2,-8(fp)
   2b97c:	e0ffff17 	ldw	r3,-4(fp)
   2b980:	e0fffc15 	stw	r3,-16(fp)
   2b984:	e0bffd15 	stw	r2,-12(fp)
   2b988:	e0bffd17 	ldw	r2,-12(fp)
   2b98c:	e0fffc17 	ldw	r3,-16(fp)
   2b990:	10c00115 	stw	r3,4(r2)
   2b994:	e0bffc17 	ldw	r2,-16(fp)
   2b998:	10c00017 	ldw	r3,0(r2)
   2b99c:	e0bffd17 	ldw	r2,-12(fp)
   2b9a0:	10c00015 	stw	r3,0(r2)
   2b9a4:	e0bffc17 	ldw	r2,-16(fp)
   2b9a8:	10800017 	ldw	r2,0(r2)
   2b9ac:	e0fffd17 	ldw	r3,-12(fp)
   2b9b0:	10c00115 	stw	r3,4(r2)
   2b9b4:	e0bffc17 	ldw	r2,-16(fp)
   2b9b8:	e0fffd17 	ldw	r3,-12(fp)
   2b9bc:	10c00015 	stw	r3,0(r2)
   2b9c0:	0005883a 	mov	r2,zero
   2b9c4:	e037883a 	mov	sp,fp
   2b9c8:	dfc00117 	ldw	ra,4(sp)
   2b9cc:	df000017 	ldw	fp,0(sp)
   2b9d0:	dec00204 	addi	sp,sp,8
   2b9d4:	f800283a 	ret

0002b9d8 <_do_ctors>:
   2b9d8:	defffd04 	addi	sp,sp,-12
   2b9dc:	dfc00215 	stw	ra,8(sp)
   2b9e0:	df000115 	stw	fp,4(sp)
   2b9e4:	df000104 	addi	fp,sp,4
   2b9e8:	008000f4 	movhi	r2,3
   2b9ec:	10b3ca04 	addi	r2,r2,-12504
   2b9f0:	e0bfff15 	stw	r2,-4(fp)
   2b9f4:	00000606 	br	2ba10 <_do_ctors+0x38>
   2b9f8:	e0bfff17 	ldw	r2,-4(fp)
   2b9fc:	10800017 	ldw	r2,0(r2)
   2ba00:	103ee83a 	callr	r2
   2ba04:	e0bfff17 	ldw	r2,-4(fp)
   2ba08:	10bfff04 	addi	r2,r2,-4
   2ba0c:	e0bfff15 	stw	r2,-4(fp)
   2ba10:	e0ffff17 	ldw	r3,-4(fp)
   2ba14:	008000f4 	movhi	r2,3
   2ba18:	10b3cb04 	addi	r2,r2,-12500
   2ba1c:	18bff62e 	bgeu	r3,r2,2b9f8 <_do_ctors+0x20>
   2ba20:	e037883a 	mov	sp,fp
   2ba24:	dfc00117 	ldw	ra,4(sp)
   2ba28:	df000017 	ldw	fp,0(sp)
   2ba2c:	dec00204 	addi	sp,sp,8
   2ba30:	f800283a 	ret

0002ba34 <_do_dtors>:
   2ba34:	defffd04 	addi	sp,sp,-12
   2ba38:	dfc00215 	stw	ra,8(sp)
   2ba3c:	df000115 	stw	fp,4(sp)
   2ba40:	df000104 	addi	fp,sp,4
   2ba44:	008000f4 	movhi	r2,3
   2ba48:	10b3ca04 	addi	r2,r2,-12504
   2ba4c:	e0bfff15 	stw	r2,-4(fp)
   2ba50:	00000606 	br	2ba6c <_do_dtors+0x38>
   2ba54:	e0bfff17 	ldw	r2,-4(fp)
   2ba58:	10800017 	ldw	r2,0(r2)
   2ba5c:	103ee83a 	callr	r2
   2ba60:	e0bfff17 	ldw	r2,-4(fp)
   2ba64:	10bfff04 	addi	r2,r2,-4
   2ba68:	e0bfff15 	stw	r2,-4(fp)
   2ba6c:	e0ffff17 	ldw	r3,-4(fp)
   2ba70:	008000f4 	movhi	r2,3
   2ba74:	10b3cb04 	addi	r2,r2,-12500
   2ba78:	18bff62e 	bgeu	r3,r2,2ba54 <_do_dtors+0x20>
   2ba7c:	e037883a 	mov	sp,fp
   2ba80:	dfc00117 	ldw	ra,4(sp)
   2ba84:	df000017 	ldw	fp,0(sp)
   2ba88:	dec00204 	addi	sp,sp,8
   2ba8c:	f800283a 	ret

0002ba90 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
   2ba90:	defffa04 	addi	sp,sp,-24
   2ba94:	dfc00515 	stw	ra,20(sp)
   2ba98:	df000415 	stw	fp,16(sp)
   2ba9c:	df000404 	addi	fp,sp,16
   2baa0:	e13ffe15 	stw	r4,-8(fp)
   2baa4:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
   2baa8:	e0bfff17 	ldw	r2,-4(fp)
   2baac:	10800017 	ldw	r2,0(r2)
   2bab0:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
   2bab4:	e13ffe17 	ldw	r4,-8(fp)
   2bab8:	00173b00 	call	173b0 <strlen>
   2babc:	10800044 	addi	r2,r2,1
   2bac0:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
   2bac4:	00000d06 	br	2bafc <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
   2bac8:	e0bffc17 	ldw	r2,-16(fp)
   2bacc:	10c00217 	ldw	r3,8(r2)
   2bad0:	e0bffd17 	ldw	r2,-12(fp)
   2bad4:	1809883a 	mov	r4,r3
   2bad8:	e17ffe17 	ldw	r5,-8(fp)
   2badc:	100d883a 	mov	r6,r2
   2bae0:	002cb100 	call	2cb10 <memcmp>
   2bae4:	1000021e 	bne	r2,zero,2baf0 <alt_find_dev+0x60>
    {
      /* match found */

      return next;
   2bae8:	e0bffc17 	ldw	r2,-16(fp)
   2baec:	00000706 	br	2bb0c <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
   2baf0:	e0bffc17 	ldw	r2,-16(fp)
   2baf4:	10800017 	ldw	r2,0(r2)
   2baf8:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
   2bafc:	e0fffc17 	ldw	r3,-16(fp)
   2bb00:	e0bfff17 	ldw	r2,-4(fp)
   2bb04:	18bff01e 	bne	r3,r2,2bac8 <alt_find_dev+0x38>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
   2bb08:	0005883a 	mov	r2,zero
}
   2bb0c:	e037883a 	mov	sp,fp
   2bb10:	dfc00117 	ldw	ra,4(sp)
   2bb14:	df000017 	ldw	fp,0(sp)
   2bb18:	dec00204 	addi	sp,sp,8
   2bb1c:	f800283a 	ret

0002bb20 <alt_flash_open_dev>:
#include "priv/alt_file.h"

ALT_LLIST_HEAD(alt_flash_dev_list);

alt_flash_fd* alt_flash_open_dev(const char* name)
{
   2bb20:	defffc04 	addi	sp,sp,-16
   2bb24:	dfc00315 	stw	ra,12(sp)
   2bb28:	df000215 	stw	fp,8(sp)
   2bb2c:	df000204 	addi	fp,sp,8
   2bb30:	e13fff15 	stw	r4,-4(fp)
  alt_flash_dev* dev = (alt_flash_dev*)alt_find_dev(name, &alt_flash_dev_list);
   2bb34:	e13fff17 	ldw	r4,-4(fp)
   2bb38:	d1601c04 	addi	r5,gp,-32656
   2bb3c:	002ba900 	call	2ba90 <alt_find_dev>
   2bb40:	e0bffe15 	stw	r2,-8(fp)

  if ((dev) && dev->open)
   2bb44:	e0bffe17 	ldw	r2,-8(fp)
   2bb48:	10000926 	beq	r2,zero,2bb70 <alt_flash_open_dev+0x50>
   2bb4c:	e0bffe17 	ldw	r2,-8(fp)
   2bb50:	10800317 	ldw	r2,12(r2)
   2bb54:	10000626 	beq	r2,zero,2bb70 <alt_flash_open_dev+0x50>
  {
    return dev->open(dev, name);
   2bb58:	e0bffe17 	ldw	r2,-8(fp)
   2bb5c:	10800317 	ldw	r2,12(r2)
   2bb60:	e13ffe17 	ldw	r4,-8(fp)
   2bb64:	e17fff17 	ldw	r5,-4(fp)
   2bb68:	103ee83a 	callr	r2
   2bb6c:	00000106 	br	2bb74 <alt_flash_open_dev+0x54>
  }

  return dev;
   2bb70:	e0bffe17 	ldw	r2,-8(fp)
}
   2bb74:	e037883a 	mov	sp,fp
   2bb78:	dfc00117 	ldw	ra,4(sp)
   2bb7c:	df000017 	ldw	fp,0(sp)
   2bb80:	dec00204 	addi	sp,sp,8
   2bb84:	f800283a 	ret

0002bb88 <alt_flash_close_dev>:

void alt_flash_close_dev(alt_flash_fd* fd)
{
   2bb88:	defffd04 	addi	sp,sp,-12
   2bb8c:	dfc00215 	stw	ra,8(sp)
   2bb90:	df000115 	stw	fp,4(sp)
   2bb94:	df000104 	addi	fp,sp,4
   2bb98:	e13fff15 	stw	r4,-4(fp)
  if (fd && fd->close)
   2bb9c:	e0bfff17 	ldw	r2,-4(fp)
   2bba0:	10000726 	beq	r2,zero,2bbc0 <alt_flash_close_dev+0x38>
   2bba4:	e0bfff17 	ldw	r2,-4(fp)
   2bba8:	10800417 	ldw	r2,16(r2)
   2bbac:	10000426 	beq	r2,zero,2bbc0 <alt_flash_close_dev+0x38>
  {
    fd->close(fd);
   2bbb0:	e0bfff17 	ldw	r2,-4(fp)
   2bbb4:	10800417 	ldw	r2,16(r2)
   2bbb8:	e13fff17 	ldw	r4,-4(fp)
   2bbbc:	103ee83a 	callr	r2
  }
  return;
   2bbc0:	0001883a 	nop
}
   2bbc4:	e037883a 	mov	sp,fp
   2bbc8:	dfc00117 	ldw	ra,4(sp)
   2bbcc:	df000017 	ldw	fp,0(sp)
   2bbd0:	dec00204 	addi	sp,sp,8
   2bbd4:	f800283a 	ret

0002bbd8 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
   2bbd8:	defffe04 	addi	sp,sp,-8
   2bbdc:	dfc00115 	stw	ra,4(sp)
   2bbe0:	df000015 	stw	fp,0(sp)
   2bbe4:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
   2bbe8:	0009883a 	mov	r4,zero
   2bbec:	01440004 	movi	r5,4096
   2bbf0:	002ca100 	call	2ca10 <alt_icache_flush>
#endif
}
   2bbf4:	e037883a 	mov	sp,fp
   2bbf8:	dfc00117 	ldw	ra,4(sp)
   2bbfc:	df000017 	ldw	fp,0(sp)
   2bc00:	dec00204 	addi	sp,sp,8
   2bc04:	f800283a 	ret

0002bc08 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
   2bc08:	defff904 	addi	sp,sp,-28
   2bc0c:	dfc00615 	stw	ra,24(sp)
   2bc10:	df000515 	stw	fp,20(sp)
   2bc14:	df000504 	addi	fp,sp,20
   2bc18:	e13ffc15 	stw	r4,-16(fp)
   2bc1c:	e17ffd15 	stw	r5,-12(fp)
   2bc20:	e1bffe15 	stw	r6,-8(fp)
   2bc24:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
   2bc28:	e13ffd17 	ldw	r4,-12(fp)
   2bc2c:	e17ffe17 	ldw	r5,-8(fp)
   2bc30:	e1bfff17 	ldw	r6,-4(fp)
   2bc34:	002be5c0 	call	2be5c <open>
   2bc38:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
   2bc3c:	e0bffb17 	ldw	r2,-20(fp)
   2bc40:	10001c16 	blt	r2,zero,2bcb4 <alt_open_fd+0xac>
  {
    fd->dev      = alt_fd_list[old].dev;
   2bc44:	00c000f4 	movhi	r3,3
   2bc48:	18cb2404 	addi	r3,r3,11408
   2bc4c:	e0bffb17 	ldw	r2,-20(fp)
   2bc50:	10800324 	muli	r2,r2,12
   2bc54:	1885883a 	add	r2,r3,r2
   2bc58:	10c00017 	ldw	r3,0(r2)
   2bc5c:	e0bffc17 	ldw	r2,-16(fp)
   2bc60:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
   2bc64:	00c000f4 	movhi	r3,3
   2bc68:	18cb2404 	addi	r3,r3,11408
   2bc6c:	e0bffb17 	ldw	r2,-20(fp)
   2bc70:	10800324 	muli	r2,r2,12
   2bc74:	1885883a 	add	r2,r3,r2
   2bc78:	10800104 	addi	r2,r2,4
   2bc7c:	10c00017 	ldw	r3,0(r2)
   2bc80:	e0bffc17 	ldw	r2,-16(fp)
   2bc84:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
   2bc88:	00c000f4 	movhi	r3,3
   2bc8c:	18cb2404 	addi	r3,r3,11408
   2bc90:	e0bffb17 	ldw	r2,-20(fp)
   2bc94:	10800324 	muli	r2,r2,12
   2bc98:	1885883a 	add	r2,r3,r2
   2bc9c:	10800204 	addi	r2,r2,8
   2bca0:	10c00017 	ldw	r3,0(r2)
   2bca4:	e0bffc17 	ldw	r2,-16(fp)
   2bca8:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
   2bcac:	e13ffb17 	ldw	r4,-20(fp)
   2bcb0:	0020dfc0 	call	20dfc <alt_release_fd>
  }
} 
   2bcb4:	e037883a 	mov	sp,fp
   2bcb8:	dfc00117 	ldw	ra,4(sp)
   2bcbc:	df000017 	ldw	fp,0(sp)
   2bcc0:	dec00204 	addi	sp,sp,8
   2bcc4:	f800283a 	ret

0002bcc8 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
   2bcc8:	defffb04 	addi	sp,sp,-20
   2bccc:	dfc00415 	stw	ra,16(sp)
   2bcd0:	df000315 	stw	fp,12(sp)
   2bcd4:	df000304 	addi	fp,sp,12
   2bcd8:	e13ffd15 	stw	r4,-12(fp)
   2bcdc:	e17ffe15 	stw	r5,-8(fp)
   2bce0:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
   2bce4:	010000f4 	movhi	r4,3
   2bce8:	210b2704 	addi	r4,r4,11420
   2bcec:	e17ffd17 	ldw	r5,-12(fp)
   2bcf0:	01800044 	movi	r6,1
   2bcf4:	01c07fc4 	movi	r7,511
   2bcf8:	002bc080 	call	2bc08 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
   2bcfc:	010000f4 	movhi	r4,3
   2bd00:	210b2404 	addi	r4,r4,11408
   2bd04:	e17ffe17 	ldw	r5,-8(fp)
   2bd08:	000d883a 	mov	r6,zero
   2bd0c:	01c07fc4 	movi	r7,511
   2bd10:	002bc080 	call	2bc08 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
   2bd14:	010000f4 	movhi	r4,3
   2bd18:	210b2a04 	addi	r4,r4,11432
   2bd1c:	e17fff17 	ldw	r5,-4(fp)
   2bd20:	01800044 	movi	r6,1
   2bd24:	01c07fc4 	movi	r7,511
   2bd28:	002bc080 	call	2bc08 <alt_open_fd>
}  
   2bd2c:	e037883a 	mov	sp,fp
   2bd30:	dfc00117 	ldw	ra,4(sp)
   2bd34:	df000017 	ldw	fp,0(sp)
   2bd38:	dec00204 	addi	sp,sp,8
   2bd3c:	f800283a 	ret

0002bd40 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   2bd40:	defffe04 	addi	sp,sp,-8
   2bd44:	dfc00115 	stw	ra,4(sp)
   2bd48:	df000015 	stw	fp,0(sp)
   2bd4c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   2bd50:	008000f4 	movhi	r2,3
   2bd54:	10910004 	addi	r2,r2,17408
   2bd58:	10800017 	ldw	r2,0(r2)
   2bd5c:	10000526 	beq	r2,zero,2bd74 <alt_get_errno+0x34>
   2bd60:	008000f4 	movhi	r2,3
   2bd64:	10910004 	addi	r2,r2,17408
   2bd68:	10800017 	ldw	r2,0(r2)
   2bd6c:	103ee83a 	callr	r2
   2bd70:	00000206 	br	2bd7c <alt_get_errno+0x3c>
   2bd74:	008000f4 	movhi	r2,3
   2bd78:	1099dd04 	addi	r2,r2,26484
}
   2bd7c:	e037883a 	mov	sp,fp
   2bd80:	dfc00117 	ldw	ra,4(sp)
   2bd84:	df000017 	ldw	fp,0(sp)
   2bd88:	dec00204 	addi	sp,sp,8
   2bd8c:	f800283a 	ret

0002bd90 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
   2bd90:	defffd04 	addi	sp,sp,-12
   2bd94:	df000215 	stw	fp,8(sp)
   2bd98:	df000204 	addi	fp,sp,8
   2bd9c:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
   2bda0:	e0bfff17 	ldw	r2,-4(fp)
   2bda4:	10800217 	ldw	r2,8(r2)
   2bda8:	10d00034 	orhi	r3,r2,16384
   2bdac:	e0bfff17 	ldw	r2,-4(fp)
   2bdb0:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
   2bdb4:	e03ffe15 	stw	zero,-8(fp)
   2bdb8:	00001d06 	br	2be30 <alt_file_locked+0xa0>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
   2bdbc:	00c000f4 	movhi	r3,3
   2bdc0:	18cb2404 	addi	r3,r3,11408
   2bdc4:	e0bffe17 	ldw	r2,-8(fp)
   2bdc8:	10800324 	muli	r2,r2,12
   2bdcc:	1885883a 	add	r2,r3,r2
   2bdd0:	10c00017 	ldw	r3,0(r2)
   2bdd4:	e0bfff17 	ldw	r2,-4(fp)
   2bdd8:	10800017 	ldw	r2,0(r2)
   2bddc:	1880111e 	bne	r3,r2,2be24 <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
   2bde0:	00c000f4 	movhi	r3,3
   2bde4:	18cb2404 	addi	r3,r3,11408
   2bde8:	e0bffe17 	ldw	r2,-8(fp)
   2bdec:	10800324 	muli	r2,r2,12
   2bdf0:	1885883a 	add	r2,r3,r2
   2bdf4:	10800204 	addi	r2,r2,8
   2bdf8:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
   2bdfc:	1000090e 	bge	r2,zero,2be24 <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
   2be00:	e0bffe17 	ldw	r2,-8(fp)
   2be04:	10c00324 	muli	r3,r2,12
   2be08:	008000f4 	movhi	r2,3
   2be0c:	108b2404 	addi	r2,r2,11408
   2be10:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
   2be14:	e0bfff17 	ldw	r2,-4(fp)
   2be18:	18800226 	beq	r3,r2,2be24 <alt_file_locked+0x94>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
   2be1c:	00bffcc4 	movi	r2,-13
   2be20:	00000a06 	br	2be4c <alt_file_locked+0xbc>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
   2be24:	e0bffe17 	ldw	r2,-8(fp)
   2be28:	10800044 	addi	r2,r2,1
   2be2c:	e0bffe15 	stw	r2,-8(fp)
   2be30:	008000f4 	movhi	r2,3
   2be34:	1090ff04 	addi	r2,r2,17404
   2be38:	10800017 	ldw	r2,0(r2)
   2be3c:	1007883a 	mov	r3,r2
   2be40:	e0bffe17 	ldw	r2,-8(fp)
   2be44:	18bfdd2e 	bgeu	r3,r2,2bdbc <alt_file_locked+0x2c>
    }
  }
  
  /* The device is not locked */
 
  return 0;
   2be48:	0005883a 	mov	r2,zero
}
   2be4c:	e037883a 	mov	sp,fp
   2be50:	df000017 	ldw	fp,0(sp)
   2be54:	dec00104 	addi	sp,sp,4
   2be58:	f800283a 	ret

0002be5c <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
   2be5c:	defff604 	addi	sp,sp,-40
   2be60:	dfc00915 	stw	ra,36(sp)
   2be64:	df000815 	stw	fp,32(sp)
   2be68:	df000804 	addi	fp,sp,32
   2be6c:	e13ffd15 	stw	r4,-12(fp)
   2be70:	e17ffe15 	stw	r5,-8(fp)
   2be74:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
   2be78:	00bfffc4 	movi	r2,-1
   2be7c:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
   2be80:	00bffb44 	movi	r2,-19
   2be84:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
   2be88:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
   2be8c:	e13ffd17 	ldw	r4,-12(fp)
   2be90:	014000f4 	movhi	r5,3
   2be94:	2950fd04 	addi	r5,r5,17396
   2be98:	002ba900 	call	2ba90 <alt_find_dev>
   2be9c:	e0bff815 	stw	r2,-32(fp)
   2bea0:	e0bff817 	ldw	r2,-32(fp)
   2bea4:	1000051e 	bne	r2,zero,2bebc <open+0x60>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
   2bea8:	e13ffd17 	ldw	r4,-12(fp)
   2beac:	002c8480 	call	2c848 <alt_find_file>
   2beb0:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
   2beb4:	00800044 	movi	r2,1
   2beb8:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
   2bebc:	e0bff817 	ldw	r2,-32(fp)
   2bec0:	10002926 	beq	r2,zero,2bf68 <open+0x10c>
  {
    if ((index = alt_get_fd (dev)) < 0)
   2bec4:	e13ff817 	ldw	r4,-32(fp)
   2bec8:	002c95c0 	call	2c95c <alt_get_fd>
   2becc:	e0bff915 	stw	r2,-28(fp)
   2bed0:	e0bff917 	ldw	r2,-28(fp)
   2bed4:	1000030e 	bge	r2,zero,2bee4 <open+0x88>
    {
      status = index;
   2bed8:	e0bff917 	ldw	r2,-28(fp)
   2bedc:	e0bffa15 	stw	r2,-24(fp)
   2bee0:	00002306 	br	2bf70 <open+0x114>
    }
    else
    {
      fd = &alt_fd_list[index];
   2bee4:	e0bff917 	ldw	r2,-28(fp)
   2bee8:	10c00324 	muli	r3,r2,12
   2beec:	008000f4 	movhi	r2,3
   2bef0:	108b2404 	addi	r2,r2,11408
   2bef4:	1885883a 	add	r2,r3,r2
   2bef8:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
   2befc:	e0fffe17 	ldw	r3,-8(fp)
   2bf00:	00900034 	movhi	r2,16384
   2bf04:	10bfffc4 	addi	r2,r2,-1
   2bf08:	1886703a 	and	r3,r3,r2
   2bf0c:	e0bffc17 	ldw	r2,-16(fp)
   2bf10:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
   2bf14:	e0bffb17 	ldw	r2,-20(fp)
   2bf18:	1000051e 	bne	r2,zero,2bf30 <open+0xd4>
   2bf1c:	e13ffc17 	ldw	r4,-16(fp)
   2bf20:	002bd900 	call	2bd90 <alt_file_locked>
   2bf24:	e0bffa15 	stw	r2,-24(fp)
   2bf28:	e0bffa17 	ldw	r2,-24(fp)
   2bf2c:	10001016 	blt	r2,zero,2bf70 <open+0x114>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
   2bf30:	e0bff817 	ldw	r2,-32(fp)
   2bf34:	10800317 	ldw	r2,12(r2)
   2bf38:	10000826 	beq	r2,zero,2bf5c <open+0x100>
   2bf3c:	e0bff817 	ldw	r2,-32(fp)
   2bf40:	10800317 	ldw	r2,12(r2)
   2bf44:	e13ffc17 	ldw	r4,-16(fp)
   2bf48:	e17ffd17 	ldw	r5,-12(fp)
   2bf4c:	e1bffe17 	ldw	r6,-8(fp)
   2bf50:	e1ffff17 	ldw	r7,-4(fp)
   2bf54:	103ee83a 	callr	r2
   2bf58:	00000106 	br	2bf60 <open+0x104>
   2bf5c:	0005883a 	mov	r2,zero
   2bf60:	e0bffa15 	stw	r2,-24(fp)
   2bf64:	00000206 	br	2bf70 <open+0x114>
      }
    }
  }
  else
  {
    status = -ENODEV;
   2bf68:	00bffb44 	movi	r2,-19
   2bf6c:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
   2bf70:	e0bffa17 	ldw	r2,-24(fp)
   2bf74:	1000080e 	bge	r2,zero,2bf98 <open+0x13c>
  {
    alt_release_fd (index);  
   2bf78:	e13ff917 	ldw	r4,-28(fp)
   2bf7c:	0020dfc0 	call	20dfc <alt_release_fd>
    ALT_ERRNO = -status;
   2bf80:	002bd400 	call	2bd40 <alt_get_errno>
   2bf84:	e0fffa17 	ldw	r3,-24(fp)
   2bf88:	00c7c83a 	sub	r3,zero,r3
   2bf8c:	10c00015 	stw	r3,0(r2)
    return -1;
   2bf90:	00bfffc4 	movi	r2,-1
   2bf94:	00000106 	br	2bf9c <open+0x140>
  }
  
  /* return the reference upon success */

  return index;
   2bf98:	e0bff917 	ldw	r2,-28(fp)
}
   2bf9c:	e037883a 	mov	sp,fp
   2bfa0:	dfc00117 	ldw	ra,4(sp)
   2bfa4:	df000017 	ldw	fp,0(sp)
   2bfa8:	dec00204 	addi	sp,sp,8
   2bfac:	f800283a 	ret

0002bfb0 <alt_program_amd>:
   2bfb0:	defff704 	addi	sp,sp,-36
   2bfb4:	dfc00815 	stw	ra,32(sp)
   2bfb8:	df000715 	stw	fp,28(sp)
   2bfbc:	df000704 	addi	fp,sp,28
   2bfc0:	e13ffc15 	stw	r4,-16(fp)
   2bfc4:	e17ffd15 	stw	r5,-12(fp)
   2bfc8:	e1bffe15 	stw	r6,-8(fp)
   2bfcc:	e1ffff15 	stw	r7,-4(fp)
   2bfd0:	e03ffa15 	stw	zero,-24(fp)
   2bfd4:	e0bffc17 	ldw	r2,-16(fp)
   2bfd8:	e0bffb15 	stw	r2,-20(fp)
   2bfdc:	008000f4 	movhi	r2,3
   2bfe0:	10b0d104 	addi	r2,r2,-15548
   2bfe4:	d8800015 	stw	r2,0(sp)
   2bfe8:	e13ffb17 	ldw	r4,-20(fp)
   2bfec:	e17ffe17 	ldw	r5,-8(fp)
   2bff0:	e1bfff17 	ldw	r6,-4(fp)
   2bff4:	e1c00217 	ldw	r7,8(fp)
   2bff8:	0021a740 	call	21a74 <alt_flash_program_block>
   2bffc:	e0bffa15 	stw	r2,-24(fp)
   2c000:	e0bffa17 	ldw	r2,-24(fp)
   2c004:	e037883a 	mov	sp,fp
   2c008:	dfc00117 	ldw	ra,4(sp)
   2c00c:	df000017 	ldw	fp,0(sp)
   2c010:	dec00204 	addi	sp,sp,8
   2c014:	f800283a 	ret

0002c018 <alt_erase_block_amd>:
   2c018:	defff804 	addi	sp,sp,-32
   2c01c:	dfc00715 	stw	ra,28(sp)
   2c020:	df000615 	stw	fp,24(sp)
   2c024:	df000604 	addi	fp,sp,24
   2c028:	e13ffe15 	stw	r4,-8(fp)
   2c02c:	e17fff15 	stw	r5,-4(fp)
   2c030:	e03ffa15 	stw	zero,-24(fp)
   2c034:	e0bffe17 	ldw	r2,-8(fp)
   2c038:	e0bffc15 	stw	r2,-16(fp)
   2c03c:	e0bffc17 	ldw	r2,-16(fp)
   2c040:	10c03317 	ldw	r3,204(r2)
   2c044:	e0bffc17 	ldw	r2,-16(fp)
   2c048:	10800a17 	ldw	r2,40(r2)
   2c04c:	1009883a 	mov	r4,r2
   2c050:	01415544 	movi	r5,1365
   2c054:	01802a84 	movi	r6,170
   2c058:	183ee83a 	callr	r3
   2c05c:	e0bffc17 	ldw	r2,-16(fp)
   2c060:	10c03317 	ldw	r3,204(r2)
   2c064:	e0bffc17 	ldw	r2,-16(fp)
   2c068:	10800a17 	ldw	r2,40(r2)
   2c06c:	1009883a 	mov	r4,r2
   2c070:	0140aa84 	movi	r5,682
   2c074:	01801544 	movi	r6,85
   2c078:	183ee83a 	callr	r3
   2c07c:	e0bffc17 	ldw	r2,-16(fp)
   2c080:	10c03317 	ldw	r3,204(r2)
   2c084:	e0bffc17 	ldw	r2,-16(fp)
   2c088:	10800a17 	ldw	r2,40(r2)
   2c08c:	1009883a 	mov	r4,r2
   2c090:	01415544 	movi	r5,1365
   2c094:	01802004 	movi	r6,128
   2c098:	183ee83a 	callr	r3
   2c09c:	e0bffc17 	ldw	r2,-16(fp)
   2c0a0:	10c03317 	ldw	r3,204(r2)
   2c0a4:	e0bffc17 	ldw	r2,-16(fp)
   2c0a8:	10800a17 	ldw	r2,40(r2)
   2c0ac:	1009883a 	mov	r4,r2
   2c0b0:	01415544 	movi	r5,1365
   2c0b4:	01802a84 	movi	r6,170
   2c0b8:	183ee83a 	callr	r3
   2c0bc:	e0bffc17 	ldw	r2,-16(fp)
   2c0c0:	10c03317 	ldw	r3,204(r2)
   2c0c4:	e0bffc17 	ldw	r2,-16(fp)
   2c0c8:	10800a17 	ldw	r2,40(r2)
   2c0cc:	1009883a 	mov	r4,r2
   2c0d0:	0140aa84 	movi	r5,682
   2c0d4:	01801544 	movi	r6,85
   2c0d8:	183ee83a 	callr	r3
   2c0dc:	e0bffc17 	ldw	r2,-16(fp)
   2c0e0:	10c03517 	ldw	r3,212(r2)
   2c0e4:	e0bffc17 	ldw	r2,-16(fp)
   2c0e8:	11000a17 	ldw	r4,40(r2)
   2c0ec:	e0bfff17 	ldw	r2,-4(fp)
   2c0f0:	2085883a 	add	r2,r4,r2
   2c0f4:	1009883a 	mov	r4,r2
   2c0f8:	01400c04 	movi	r5,48
   2c0fc:	183ee83a 	callr	r3
   2c100:	0109c404 	movi	r4,10000
   2c104:	00211c40 	call	211c4 <usleep>
   2c108:	00800c84 	movi	r2,50
   2c10c:	e0bffb15 	stw	r2,-20(fp)
   2c110:	e0bffc17 	ldw	r2,-16(fp)
   2c114:	10c00a17 	ldw	r3,40(r2)
   2c118:	e0bfff17 	ldw	r2,-4(fp)
   2c11c:	1885883a 	add	r2,r3,r2
   2c120:	10800023 	ldbuio	r2,0(r2)
   2c124:	10803fcc 	andi	r2,r2,255
   2c128:	e0bffd05 	stb	r2,-12(fp)
   2c12c:	0100fa04 	movi	r4,1000
   2c130:	00211c40 	call	211c4 <usleep>
   2c134:	e0bffb17 	ldw	r2,-20(fp)
   2c138:	10bfffc4 	addi	r2,r2,-1
   2c13c:	e0bffb15 	stw	r2,-20(fp)
   2c140:	e0bffd03 	ldbu	r2,-12(fp)
   2c144:	10803fcc 	andi	r2,r2,255
   2c148:	1080020c 	andi	r2,r2,8
   2c14c:	1000021e 	bne	r2,zero,2c158 <alt_erase_block_amd+0x140>
   2c150:	e0bffb17 	ldw	r2,-20(fp)
   2c154:	00bfee16 	blt	zero,r2,2c110 <alt_erase_block_amd+0xf8>
   2c158:	e0bffc17 	ldw	r2,-16(fp)
   2c15c:	10803117 	ldw	r2,196(r2)
   2c160:	e0bffb15 	stw	r2,-20(fp)
   2c164:	00001506 	br	2c1bc <alt_erase_block_amd+0x1a4>
   2c168:	e0bffc17 	ldw	r2,-16(fp)
   2c16c:	10c00a17 	ldw	r3,40(r2)
   2c170:	e0bfff17 	ldw	r2,-4(fp)
   2c174:	1885883a 	add	r2,r3,r2
   2c178:	10800023 	ldbuio	r2,0(r2)
   2c17c:	10803fcc 	andi	r2,r2,255
   2c180:	e0bffd05 	stb	r2,-12(fp)
   2c184:	e0bffd03 	ldbu	r2,-12(fp)
   2c188:	10803fcc 	andi	r2,r2,255
   2c18c:	1080201c 	xori	r2,r2,128
   2c190:	10bfe004 	addi	r2,r2,-128
   2c194:	10000b16 	blt	r2,zero,2c1c4 <alt_erase_block_amd+0x1ac>
   2c198:	e0bffd03 	ldbu	r2,-12(fp)
   2c19c:	10803fcc 	andi	r2,r2,255
   2c1a0:	1080080c 	andi	r2,r2,32
   2c1a4:	1000071e 	bne	r2,zero,2c1c4 <alt_erase_block_amd+0x1ac>
   2c1a8:	0100fa04 	movi	r4,1000
   2c1ac:	00211c40 	call	211c4 <usleep>
   2c1b0:	e0bffb17 	ldw	r2,-20(fp)
   2c1b4:	10bf0604 	addi	r2,r2,-1000
   2c1b8:	e0bffb15 	stw	r2,-20(fp)
   2c1bc:	e0bffb17 	ldw	r2,-20(fp)
   2c1c0:	00bfe916 	blt	zero,r2,2c168 <alt_erase_block_amd+0x150>
   2c1c4:	e0bffb17 	ldw	r2,-20(fp)
   2c1c8:	00800316 	blt	zero,r2,2c1d8 <alt_erase_block_amd+0x1c0>
   2c1cc:	00bfe304 	movi	r2,-116
   2c1d0:	e0bffa15 	stw	r2,-24(fp)
   2c1d4:	00000e06 	br	2c210 <alt_erase_block_amd+0x1f8>
   2c1d8:	e0bffc17 	ldw	r2,-16(fp)
   2c1dc:	10c00a17 	ldw	r3,40(r2)
   2c1e0:	e0bfff17 	ldw	r2,-4(fp)
   2c1e4:	1885883a 	add	r2,r3,r2
   2c1e8:	10800023 	ldbuio	r2,0(r2)
   2c1ec:	10803fcc 	andi	r2,r2,255
   2c1f0:	e0bffd05 	stb	r2,-12(fp)
   2c1f4:	e0bffd03 	ldbu	r2,-12(fp)
   2c1f8:	10803fcc 	andi	r2,r2,255
   2c1fc:	1080201c 	xori	r2,r2,128
   2c200:	10bfe004 	addi	r2,r2,-128
   2c204:	10000216 	blt	r2,zero,2c210 <alt_erase_block_amd+0x1f8>
   2c208:	00bffec4 	movi	r2,-5
   2c20c:	e0bffa15 	stw	r2,-24(fp)
   2c210:	e0bffa17 	ldw	r2,-24(fp)
   2c214:	e037883a 	mov	sp,fp
   2c218:	dfc00117 	ldw	ra,4(sp)
   2c21c:	df000017 	ldw	fp,0(sp)
   2c220:	dec00204 	addi	sp,sp,8
   2c224:	f800283a 	ret

0002c228 <alt_wait_for_command_to_complete_amd>:
   2c228:	defff804 	addi	sp,sp,-32
   2c22c:	dfc00715 	stw	ra,28(sp)
   2c230:	df000615 	stw	fp,24(sp)
   2c234:	df000604 	addi	fp,sp,24
   2c238:	e13ffd15 	stw	r4,-12(fp)
   2c23c:	e17ffe15 	stw	r5,-8(fp)
   2c240:	3005883a 	mov	r2,r6
   2c244:	e0bfff05 	stb	r2,-4(fp)
   2c248:	e0bffd17 	ldw	r2,-12(fp)
   2c24c:	10803017 	ldw	r2,192(r2)
   2c250:	10801924 	muli	r2,r2,100
   2c254:	e0bffa15 	stw	r2,-24(fp)
   2c258:	e03ffb15 	stw	zero,-20(fp)
   2c25c:	e0bffd17 	ldw	r2,-12(fp)
   2c260:	10c00a17 	ldw	r3,40(r2)
   2c264:	e0bffe17 	ldw	r2,-8(fp)
   2c268:	1885883a 	add	r2,r3,r2
   2c26c:	10800023 	ldbuio	r2,0(r2)
   2c270:	10803fcc 	andi	r2,r2,255
   2c274:	e0bffc05 	stb	r2,-16(fp)
   2c278:	00001606 	br	2c2d4 <alt_wait_for_command_to_complete_amd+0xac>
   2c27c:	e0bffc03 	ldbu	r2,-16(fp)
   2c280:	10c03fcc 	andi	r3,r2,255
   2c284:	e0bfff03 	ldbu	r2,-4(fp)
   2c288:	1884f03a 	xor	r2,r3,r2
   2c28c:	1080200c 	andi	r2,r2,128
   2c290:	10001226 	beq	r2,zero,2c2dc <alt_wait_for_command_to_complete_amd+0xb4>
   2c294:	e0bffc03 	ldbu	r2,-16(fp)
   2c298:	10803fcc 	andi	r2,r2,255
   2c29c:	1080080c 	andi	r2,r2,32
   2c2a0:	10000e1e 	bne	r2,zero,2c2dc <alt_wait_for_command_to_complete_amd+0xb4>
   2c2a4:	01000044 	movi	r4,1
   2c2a8:	00211c40 	call	211c4 <usleep>
   2c2ac:	e0bffa17 	ldw	r2,-24(fp)
   2c2b0:	10bfffc4 	addi	r2,r2,-1
   2c2b4:	e0bffa15 	stw	r2,-24(fp)
   2c2b8:	e0bffd17 	ldw	r2,-12(fp)
   2c2bc:	10c00a17 	ldw	r3,40(r2)
   2c2c0:	e0bffe17 	ldw	r2,-8(fp)
   2c2c4:	1885883a 	add	r2,r3,r2
   2c2c8:	10800023 	ldbuio	r2,0(r2)
   2c2cc:	10803fcc 	andi	r2,r2,255
   2c2d0:	e0bffc05 	stb	r2,-16(fp)
   2c2d4:	e0bffa17 	ldw	r2,-24(fp)
   2c2d8:	00bfe816 	blt	zero,r2,2c27c <alt_wait_for_command_to_complete_amd+0x54>
   2c2dc:	e0bffa17 	ldw	r2,-24(fp)
   2c2e0:	1000031e 	bne	r2,zero,2c2f0 <alt_wait_for_command_to_complete_amd+0xc8>
   2c2e4:	00bfe304 	movi	r2,-116
   2c2e8:	e0bffb15 	stw	r2,-20(fp)
   2c2ec:	00000f06 	br	2c32c <alt_wait_for_command_to_complete_amd+0x104>
   2c2f0:	e0bffd17 	ldw	r2,-12(fp)
   2c2f4:	10c00a17 	ldw	r3,40(r2)
   2c2f8:	e0bffe17 	ldw	r2,-8(fp)
   2c2fc:	1885883a 	add	r2,r3,r2
   2c300:	10800023 	ldbuio	r2,0(r2)
   2c304:	10803fcc 	andi	r2,r2,255
   2c308:	e0bffc05 	stb	r2,-16(fp)
   2c30c:	e0bffc03 	ldbu	r2,-16(fp)
   2c310:	10c03fcc 	andi	r3,r2,255
   2c314:	e0bfff03 	ldbu	r2,-4(fp)
   2c318:	1884f03a 	xor	r2,r3,r2
   2c31c:	1080200c 	andi	r2,r2,128
   2c320:	10000226 	beq	r2,zero,2c32c <alt_wait_for_command_to_complete_amd+0x104>
   2c324:	00bffec4 	movi	r2,-5
   2c328:	e0bffb15 	stw	r2,-20(fp)
   2c32c:	e0bffb17 	ldw	r2,-20(fp)
   2c330:	e037883a 	mov	sp,fp
   2c334:	dfc00117 	ldw	ra,4(sp)
   2c338:	df000017 	ldw	fp,0(sp)
   2c33c:	dec00204 	addi	sp,sp,8
   2c340:	f800283a 	ret

0002c344 <alt_write_word_amd>:
   2c344:	defff904 	addi	sp,sp,-28
   2c348:	dfc00615 	stw	ra,24(sp)
   2c34c:	df000515 	stw	fp,20(sp)
   2c350:	df000504 	addi	fp,sp,20
   2c354:	e13ffd15 	stw	r4,-12(fp)
   2c358:	e17ffe15 	stw	r5,-8(fp)
   2c35c:	e1bfff15 	stw	r6,-4(fp)
   2c360:	e03ffb15 	stw	zero,-20(fp)
   2c364:	e0bffd17 	ldw	r2,-12(fp)
   2c368:	10c03317 	ldw	r3,204(r2)
   2c36c:	e0bffd17 	ldw	r2,-12(fp)
   2c370:	10800a17 	ldw	r2,40(r2)
   2c374:	1009883a 	mov	r4,r2
   2c378:	01415544 	movi	r5,1365
   2c37c:	01802a84 	movi	r6,170
   2c380:	183ee83a 	callr	r3
   2c384:	e0bffd17 	ldw	r2,-12(fp)
   2c388:	10c03317 	ldw	r3,204(r2)
   2c38c:	e0bffd17 	ldw	r2,-12(fp)
   2c390:	10800a17 	ldw	r2,40(r2)
   2c394:	1009883a 	mov	r4,r2
   2c398:	0140aa84 	movi	r5,682
   2c39c:	01801544 	movi	r6,85
   2c3a0:	183ee83a 	callr	r3
   2c3a4:	e0bffd17 	ldw	r2,-12(fp)
   2c3a8:	10c03317 	ldw	r3,204(r2)
   2c3ac:	e0bffd17 	ldw	r2,-12(fp)
   2c3b0:	10800a17 	ldw	r2,40(r2)
   2c3b4:	1009883a 	mov	r4,r2
   2c3b8:	01415544 	movi	r5,1365
   2c3bc:	01802804 	movi	r6,160
   2c3c0:	183ee83a 	callr	r3
   2c3c4:	e0bfff17 	ldw	r2,-4(fp)
   2c3c8:	10800003 	ldbu	r2,0(r2)
   2c3cc:	e0bffc05 	stb	r2,-16(fp)
   2c3d0:	e13ffd17 	ldw	r4,-12(fp)
   2c3d4:	e17ffe17 	ldw	r5,-8(fp)
   2c3d8:	e1bfff17 	ldw	r6,-4(fp)
   2c3dc:	002191c0 	call	2191c <alt_write_value_to_flash>
   2c3e0:	e0bffc03 	ldbu	r2,-16(fp)
   2c3e4:	e13ffd17 	ldw	r4,-12(fp)
   2c3e8:	e17ffe17 	ldw	r5,-8(fp)
   2c3ec:	100d883a 	mov	r6,r2
   2c3f0:	002c2280 	call	2c228 <alt_wait_for_command_to_complete_amd>
   2c3f4:	e0bffb15 	stw	r2,-20(fp)
   2c3f8:	e0bffb17 	ldw	r2,-20(fp)
   2c3fc:	e037883a 	mov	sp,fp
   2c400:	dfc00117 	ldw	ra,4(sp)
   2c404:	df000017 	ldw	fp,0(sp)
   2c408:	dec00204 	addi	sp,sp,8
   2c40c:	f800283a 	ret

0002c410 <alt_program_intel>:
   2c410:	defff704 	addi	sp,sp,-36
   2c414:	dfc00815 	stw	ra,32(sp)
   2c418:	df000715 	stw	fp,28(sp)
   2c41c:	df000704 	addi	fp,sp,28
   2c420:	e13ffc15 	stw	r4,-16(fp)
   2c424:	e17ffd15 	stw	r5,-12(fp)
   2c428:	e1bffe15 	stw	r6,-8(fp)
   2c42c:	e1ffff15 	stw	r7,-4(fp)
   2c430:	e03ffa15 	stw	zero,-24(fp)
   2c434:	e0bffc17 	ldw	r2,-16(fp)
   2c438:	e0bffb15 	stw	r2,-20(fp)
   2c43c:	e13ffb17 	ldw	r4,-20(fp)
   2c440:	e17ffd17 	ldw	r5,-12(fp)
   2c444:	002c5f80 	call	2c5f8 <alt_unlock_block_intel>
   2c448:	e0bffa15 	stw	r2,-24(fp)
   2c44c:	e0bffa17 	ldw	r2,-24(fp)
   2c450:	1000091e 	bne	r2,zero,2c478 <alt_program_intel+0x68>
   2c454:	008000f4 	movhi	r2,3
   2c458:	10b1dd04 	addi	r2,r2,-14476
   2c45c:	d8800015 	stw	r2,0(sp)
   2c460:	e13ffb17 	ldw	r4,-20(fp)
   2c464:	e17ffe17 	ldw	r5,-8(fp)
   2c468:	e1bfff17 	ldw	r6,-4(fp)
   2c46c:	e1c00217 	ldw	r7,8(fp)
   2c470:	0021a740 	call	21a74 <alt_flash_program_block>
   2c474:	e0bffa15 	stw	r2,-24(fp)
   2c478:	e0bffa17 	ldw	r2,-24(fp)
   2c47c:	e037883a 	mov	sp,fp
   2c480:	dfc00117 	ldw	ra,4(sp)
   2c484:	df000017 	ldw	fp,0(sp)
   2c488:	dec00204 	addi	sp,sp,8
   2c48c:	f800283a 	ret

0002c490 <alt_erase_block_intel>:
   2c490:	defff804 	addi	sp,sp,-32
   2c494:	dfc00715 	stw	ra,28(sp)
   2c498:	df000615 	stw	fp,24(sp)
   2c49c:	df000604 	addi	fp,sp,24
   2c4a0:	e13ffe15 	stw	r4,-8(fp)
   2c4a4:	e17fff15 	stw	r5,-4(fp)
   2c4a8:	e03ffa15 	stw	zero,-24(fp)
   2c4ac:	e0bffe17 	ldw	r2,-8(fp)
   2c4b0:	e0bffc15 	stw	r2,-16(fp)
   2c4b4:	e0bffc17 	ldw	r2,-16(fp)
   2c4b8:	10803117 	ldw	r2,196(r2)
   2c4bc:	e0bffb15 	stw	r2,-20(fp)
   2c4c0:	e13ffc17 	ldw	r4,-16(fp)
   2c4c4:	e17fff17 	ldw	r5,-4(fp)
   2c4c8:	002c5f80 	call	2c5f8 <alt_unlock_block_intel>
   2c4cc:	e0bffa15 	stw	r2,-24(fp)
   2c4d0:	e0bffa17 	ldw	r2,-24(fp)
   2c4d4:	1000421e 	bne	r2,zero,2c5e0 <alt_erase_block_intel+0x150>
   2c4d8:	e0bffc17 	ldw	r2,-16(fp)
   2c4dc:	10c03517 	ldw	r3,212(r2)
   2c4e0:	e0bffc17 	ldw	r2,-16(fp)
   2c4e4:	11000a17 	ldw	r4,40(r2)
   2c4e8:	e0bfff17 	ldw	r2,-4(fp)
   2c4ec:	2085883a 	add	r2,r4,r2
   2c4f0:	1009883a 	mov	r4,r2
   2c4f4:	01400804 	movi	r5,32
   2c4f8:	183ee83a 	callr	r3
   2c4fc:	e0bffc17 	ldw	r2,-16(fp)
   2c500:	10c03517 	ldw	r3,212(r2)
   2c504:	e0bffc17 	ldw	r2,-16(fp)
   2c508:	11000a17 	ldw	r4,40(r2)
   2c50c:	e0bfff17 	ldw	r2,-4(fp)
   2c510:	2085883a 	add	r2,r4,r2
   2c514:	1009883a 	mov	r4,r2
   2c518:	01403404 	movi	r5,208
   2c51c:	183ee83a 	callr	r3
   2c520:	e0bffc17 	ldw	r2,-16(fp)
   2c524:	10c00a17 	ldw	r3,40(r2)
   2c528:	e0bfff17 	ldw	r2,-4(fp)
   2c52c:	1885883a 	add	r2,r3,r2
   2c530:	10800023 	ldbuio	r2,0(r2)
   2c534:	10803fcc 	andi	r2,r2,255
   2c538:	e0bffd05 	stb	r2,-12(fp)
   2c53c:	e0bffd03 	ldbu	r2,-12(fp)
   2c540:	10803fcc 	andi	r2,r2,255
   2c544:	1080201c 	xori	r2,r2,128
   2c548:	10bfe004 	addi	r2,r2,-128
   2c54c:	10000816 	blt	r2,zero,2c570 <alt_erase_block_intel+0xe0>
   2c550:	0100fa04 	movi	r4,1000
   2c554:	00211c40 	call	211c4 <usleep>
   2c558:	e0bffb17 	ldw	r2,-20(fp)
   2c55c:	10bf0604 	addi	r2,r2,-1000
   2c560:	e0bffb15 	stw	r2,-20(fp)
   2c564:	e0bffb17 	ldw	r2,-20(fp)
   2c568:	00bfed16 	blt	zero,r2,2c520 <alt_erase_block_intel+0x90>
   2c56c:	00000106 	br	2c574 <alt_erase_block_intel+0xe4>
   2c570:	0001883a 	nop
   2c574:	e0bffb17 	ldw	r2,-20(fp)
   2c578:	00800316 	blt	zero,r2,2c588 <alt_erase_block_intel+0xf8>
   2c57c:	00bfe304 	movi	r2,-116
   2c580:	e0bffa15 	stw	r2,-24(fp)
   2c584:	00000d06 	br	2c5bc <alt_erase_block_intel+0x12c>
   2c588:	e0bffd03 	ldbu	r2,-12(fp)
   2c58c:	10803fcc 	andi	r2,r2,255
   2c590:	10801fcc 	andi	r2,r2,127
   2c594:	10000926 	beq	r2,zero,2c5bc <alt_erase_block_intel+0x12c>
   2c598:	00bffec4 	movi	r2,-5
   2c59c:	e0bffa15 	stw	r2,-24(fp)
   2c5a0:	e0bffc17 	ldw	r2,-16(fp)
   2c5a4:	10c00a17 	ldw	r3,40(r2)
   2c5a8:	e0bfff17 	ldw	r2,-4(fp)
   2c5ac:	1885883a 	add	r2,r3,r2
   2c5b0:	10800023 	ldbuio	r2,0(r2)
   2c5b4:	10803fcc 	andi	r2,r2,255
   2c5b8:	e0bffd05 	stb	r2,-12(fp)
   2c5bc:	e0bffc17 	ldw	r2,-16(fp)
   2c5c0:	10c03517 	ldw	r3,212(r2)
   2c5c4:	e0bffc17 	ldw	r2,-16(fp)
   2c5c8:	11000a17 	ldw	r4,40(r2)
   2c5cc:	e0bfff17 	ldw	r2,-4(fp)
   2c5d0:	2085883a 	add	r2,r4,r2
   2c5d4:	1009883a 	mov	r4,r2
   2c5d8:	01403fc4 	movi	r5,255
   2c5dc:	183ee83a 	callr	r3
   2c5e0:	e0bffa17 	ldw	r2,-24(fp)
   2c5e4:	e037883a 	mov	sp,fp
   2c5e8:	dfc00117 	ldw	ra,4(sp)
   2c5ec:	df000017 	ldw	fp,0(sp)
   2c5f0:	dec00204 	addi	sp,sp,8
   2c5f4:	f800283a 	ret

0002c5f8 <alt_unlock_block_intel>:
   2c5f8:	defff904 	addi	sp,sp,-28
   2c5fc:	dfc00615 	stw	ra,24(sp)
   2c600:	df000515 	stw	fp,20(sp)
   2c604:	df000504 	addi	fp,sp,20
   2c608:	e13ffe15 	stw	r4,-8(fp)
   2c60c:	e17fff15 	stw	r5,-4(fp)
   2c610:	e03ffb15 	stw	zero,-20(fp)
   2c614:	e0bffe17 	ldw	r2,-8(fp)
   2c618:	10803017 	ldw	r2,192(r2)
   2c61c:	10801924 	muli	r2,r2,100
   2c620:	e0bffc15 	stw	r2,-16(fp)
   2c624:	e0bffe17 	ldw	r2,-8(fp)
   2c628:	10c03517 	ldw	r3,212(r2)
   2c62c:	e0bffe17 	ldw	r2,-8(fp)
   2c630:	11000a17 	ldw	r4,40(r2)
   2c634:	e0bfff17 	ldw	r2,-4(fp)
   2c638:	2085883a 	add	r2,r4,r2
   2c63c:	1009883a 	mov	r4,r2
   2c640:	01402404 	movi	r5,144
   2c644:	183ee83a 	callr	r3
   2c648:	e0bffe17 	ldw	r2,-8(fp)
   2c64c:	10c00a17 	ldw	r3,40(r2)
   2c650:	e0bfff17 	ldw	r2,-4(fp)
   2c654:	10800104 	addi	r2,r2,4
   2c658:	1885883a 	add	r2,r3,r2
   2c65c:	10800023 	ldbuio	r2,0(r2)
   2c660:	10803fcc 	andi	r2,r2,255
   2c664:	e0bffd05 	stb	r2,-12(fp)
   2c668:	e0bffd03 	ldbu	r2,-12(fp)
   2c66c:	1080004c 	andi	r2,r2,1
   2c670:	10003126 	beq	r2,zero,2c738 <alt_unlock_block_intel+0x140>
   2c674:	e0bffe17 	ldw	r2,-8(fp)
   2c678:	10c03517 	ldw	r3,212(r2)
   2c67c:	e0bffe17 	ldw	r2,-8(fp)
   2c680:	11000a17 	ldw	r4,40(r2)
   2c684:	e0bfff17 	ldw	r2,-4(fp)
   2c688:	2085883a 	add	r2,r4,r2
   2c68c:	1009883a 	mov	r4,r2
   2c690:	01401804 	movi	r5,96
   2c694:	183ee83a 	callr	r3
   2c698:	e0bffe17 	ldw	r2,-8(fp)
   2c69c:	10c03517 	ldw	r3,212(r2)
   2c6a0:	e0bffe17 	ldw	r2,-8(fp)
   2c6a4:	11000a17 	ldw	r4,40(r2)
   2c6a8:	e0bfff17 	ldw	r2,-4(fp)
   2c6ac:	2085883a 	add	r2,r4,r2
   2c6b0:	1009883a 	mov	r4,r2
   2c6b4:	01403404 	movi	r5,208
   2c6b8:	183ee83a 	callr	r3
   2c6bc:	e0bffe17 	ldw	r2,-8(fp)
   2c6c0:	10c00a17 	ldw	r3,40(r2)
   2c6c4:	e0bfff17 	ldw	r2,-4(fp)
   2c6c8:	1885883a 	add	r2,r3,r2
   2c6cc:	10800023 	ldbuio	r2,0(r2)
   2c6d0:	10803fcc 	andi	r2,r2,255
   2c6d4:	e0bffd45 	stb	r2,-11(fp)
   2c6d8:	e0bffd43 	ldbu	r2,-11(fp)
   2c6dc:	10803fcc 	andi	r2,r2,255
   2c6e0:	1080201c 	xori	r2,r2,128
   2c6e4:	10bfe004 	addi	r2,r2,-128
   2c6e8:	10000816 	blt	r2,zero,2c70c <alt_unlock_block_intel+0x114>
   2c6ec:	e0bffc17 	ldw	r2,-16(fp)
   2c6f0:	10bfffc4 	addi	r2,r2,-1
   2c6f4:	e0bffc15 	stw	r2,-16(fp)
   2c6f8:	01000044 	movi	r4,1
   2c6fc:	00211c40 	call	211c4 <usleep>
   2c700:	e0bffc17 	ldw	r2,-16(fp)
   2c704:	00bfed16 	blt	zero,r2,2c6bc <alt_unlock_block_intel+0xc4>
   2c708:	00000106 	br	2c710 <alt_unlock_block_intel+0x118>
   2c70c:	0001883a 	nop
   2c710:	e0bffc17 	ldw	r2,-16(fp)
   2c714:	1000031e 	bne	r2,zero,2c724 <alt_unlock_block_intel+0x12c>
   2c718:	00bfe304 	movi	r2,-116
   2c71c:	e0bffb15 	stw	r2,-20(fp)
   2c720:	00000506 	br	2c738 <alt_unlock_block_intel+0x140>
   2c724:	e0bffd43 	ldbu	r2,-11(fp)
   2c728:	10801fcc 	andi	r2,r2,127
   2c72c:	10000226 	beq	r2,zero,2c738 <alt_unlock_block_intel+0x140>
   2c730:	00bffec4 	movi	r2,-5
   2c734:	e0bffb15 	stw	r2,-20(fp)
   2c738:	e0bffe17 	ldw	r2,-8(fp)
   2c73c:	10c03517 	ldw	r3,212(r2)
   2c740:	e0bffe17 	ldw	r2,-8(fp)
   2c744:	11000a17 	ldw	r4,40(r2)
   2c748:	e0bfff17 	ldw	r2,-4(fp)
   2c74c:	2085883a 	add	r2,r4,r2
   2c750:	1009883a 	mov	r4,r2
   2c754:	01403fc4 	movi	r5,255
   2c758:	183ee83a 	callr	r3
   2c75c:	e0bffb17 	ldw	r2,-20(fp)
   2c760:	e037883a 	mov	sp,fp
   2c764:	dfc00117 	ldw	ra,4(sp)
   2c768:	df000017 	ldw	fp,0(sp)
   2c76c:	dec00204 	addi	sp,sp,8
   2c770:	f800283a 	ret

0002c774 <alt_write_word_intel>:
   2c774:	defff904 	addi	sp,sp,-28
   2c778:	dfc00615 	stw	ra,24(sp)
   2c77c:	df000515 	stw	fp,20(sp)
   2c780:	df000504 	addi	fp,sp,20
   2c784:	e13ffd15 	stw	r4,-12(fp)
   2c788:	e17ffe15 	stw	r5,-8(fp)
   2c78c:	e1bfff15 	stw	r6,-4(fp)
   2c790:	e03ffb15 	stw	zero,-20(fp)
   2c794:	e0bffd17 	ldw	r2,-12(fp)
   2c798:	10c03517 	ldw	r3,212(r2)
   2c79c:	e0bffd17 	ldw	r2,-12(fp)
   2c7a0:	11000a17 	ldw	r4,40(r2)
   2c7a4:	e0bffe17 	ldw	r2,-8(fp)
   2c7a8:	2085883a 	add	r2,r4,r2
   2c7ac:	1009883a 	mov	r4,r2
   2c7b0:	01401004 	movi	r5,64
   2c7b4:	183ee83a 	callr	r3
   2c7b8:	e13ffd17 	ldw	r4,-12(fp)
   2c7bc:	e17ffe17 	ldw	r5,-8(fp)
   2c7c0:	e1bfff17 	ldw	r6,-4(fp)
   2c7c4:	002191c0 	call	2191c <alt_write_value_to_flash>
   2c7c8:	e0bffd17 	ldw	r2,-12(fp)
   2c7cc:	10c00a17 	ldw	r3,40(r2)
   2c7d0:	e0bffe17 	ldw	r2,-8(fp)
   2c7d4:	1885883a 	add	r2,r3,r2
   2c7d8:	10800023 	ldbuio	r2,0(r2)
   2c7dc:	10803fcc 	andi	r2,r2,255
   2c7e0:	e0bffc05 	stb	r2,-16(fp)
   2c7e4:	e0bffc03 	ldbu	r2,-16(fp)
   2c7e8:	10803fcc 	andi	r2,r2,255
   2c7ec:	1080201c 	xori	r2,r2,128
   2c7f0:	10bfe004 	addi	r2,r2,-128
   2c7f4:	103ff40e 	bge	r2,zero,2c7c8 <alt_write_word_intel+0x54>
   2c7f8:	e0bffc03 	ldbu	r2,-16(fp)
   2c7fc:	10801fcc 	andi	r2,r2,127
   2c800:	10000226 	beq	r2,zero,2c80c <alt_write_word_intel+0x98>
   2c804:	00bffec4 	movi	r2,-5
   2c808:	e0bffb15 	stw	r2,-20(fp)
   2c80c:	e0bffd17 	ldw	r2,-12(fp)
   2c810:	10c03517 	ldw	r3,212(r2)
   2c814:	e0bffd17 	ldw	r2,-12(fp)
   2c818:	11000a17 	ldw	r4,40(r2)
   2c81c:	e0bffe17 	ldw	r2,-8(fp)
   2c820:	2085883a 	add	r2,r4,r2
   2c824:	1009883a 	mov	r4,r2
   2c828:	01403fc4 	movi	r5,255
   2c82c:	183ee83a 	callr	r3
   2c830:	e0bffb17 	ldw	r2,-20(fp)
   2c834:	e037883a 	mov	sp,fp
   2c838:	dfc00117 	ldw	ra,4(sp)
   2c83c:	df000017 	ldw	fp,0(sp)
   2c840:	dec00204 	addi	sp,sp,8
   2c844:	f800283a 	ret

0002c848 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
   2c848:	defffb04 	addi	sp,sp,-20
   2c84c:	dfc00415 	stw	ra,16(sp)
   2c850:	df000315 	stw	fp,12(sp)
   2c854:	df000304 	addi	fp,sp,12
   2c858:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
   2c85c:	008000f4 	movhi	r2,3
   2c860:	1090fb04 	addi	r2,r2,17388
   2c864:	10800017 	ldw	r2,0(r2)
   2c868:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
   2c86c:	00003106 	br	2c934 <alt_find_file+0xec>
  {
    len = strlen(next->name);
   2c870:	e0bffd17 	ldw	r2,-12(fp)
   2c874:	10800217 	ldw	r2,8(r2)
   2c878:	1009883a 	mov	r4,r2
   2c87c:	00173b00 	call	173b0 <strlen>
   2c880:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
   2c884:	e0bffd17 	ldw	r2,-12(fp)
   2c888:	10c00217 	ldw	r3,8(r2)
   2c88c:	e0bffe17 	ldw	r2,-8(fp)
   2c890:	10bfffc4 	addi	r2,r2,-1
   2c894:	1885883a 	add	r2,r3,r2
   2c898:	10800003 	ldbu	r2,0(r2)
   2c89c:	10803fcc 	andi	r2,r2,255
   2c8a0:	1080201c 	xori	r2,r2,128
   2c8a4:	10bfe004 	addi	r2,r2,-128
   2c8a8:	10800bd8 	cmpnei	r2,r2,47
   2c8ac:	1000031e 	bne	r2,zero,2c8bc <alt_find_file+0x74>
    {
      len -= 1;
   2c8b0:	e0bffe17 	ldw	r2,-8(fp)
   2c8b4:	10bfffc4 	addi	r2,r2,-1
   2c8b8:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
   2c8bc:	e0bffe17 	ldw	r2,-8(fp)
   2c8c0:	e0ffff17 	ldw	r3,-4(fp)
   2c8c4:	1885883a 	add	r2,r3,r2
   2c8c8:	10800003 	ldbu	r2,0(r2)
   2c8cc:	10803fcc 	andi	r2,r2,255
   2c8d0:	1080201c 	xori	r2,r2,128
   2c8d4:	10bfe004 	addi	r2,r2,-128
   2c8d8:	10800be0 	cmpeqi	r2,r2,47
   2c8dc:	1000081e 	bne	r2,zero,2c900 <alt_find_file+0xb8>
   2c8e0:	e0bffe17 	ldw	r2,-8(fp)
   2c8e4:	e0ffff17 	ldw	r3,-4(fp)
   2c8e8:	1885883a 	add	r2,r3,r2
   2c8ec:	10800003 	ldbu	r2,0(r2)
   2c8f0:	10803fcc 	andi	r2,r2,255
   2c8f4:	1080201c 	xori	r2,r2,128
   2c8f8:	10bfe004 	addi	r2,r2,-128
   2c8fc:	10000a1e 	bne	r2,zero,2c928 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
   2c900:	e0bffd17 	ldw	r2,-12(fp)
   2c904:	10c00217 	ldw	r3,8(r2)
   2c908:	e0bffe17 	ldw	r2,-8(fp)
   2c90c:	1809883a 	mov	r4,r3
   2c910:	e17fff17 	ldw	r5,-4(fp)
   2c914:	100d883a 	mov	r6,r2
   2c918:	002cb100 	call	2cb10 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
   2c91c:	1000021e 	bne	r2,zero,2c928 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
   2c920:	e0bffd17 	ldw	r2,-12(fp)
   2c924:	00000806 	br	2c948 <alt_find_file+0x100>
    }
    next = (alt_dev*) next->llist.next;
   2c928:	e0bffd17 	ldw	r2,-12(fp)
   2c92c:	10800017 	ldw	r2,0(r2)
   2c930:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
   2c934:	e0fffd17 	ldw	r3,-12(fp)
   2c938:	008000f4 	movhi	r2,3
   2c93c:	1090fb04 	addi	r2,r2,17388
   2c940:	18bfcb1e 	bne	r3,r2,2c870 <alt_find_file+0x28>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
   2c944:	0005883a 	mov	r2,zero
}
   2c948:	e037883a 	mov	sp,fp
   2c94c:	dfc00117 	ldw	ra,4(sp)
   2c950:	df000017 	ldw	fp,0(sp)
   2c954:	dec00204 	addi	sp,sp,8
   2c958:	f800283a 	ret

0002c95c <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
   2c95c:	defffc04 	addi	sp,sp,-16
   2c960:	df000315 	stw	fp,12(sp)
   2c964:	df000304 	addi	fp,sp,12
   2c968:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
   2c96c:	00bffa04 	movi	r2,-24
   2c970:	e0bffe15 	stw	r2,-8(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
   2c974:	e03ffd15 	stw	zero,-12(fp)
   2c978:	00001d06 	br	2c9f0 <alt_get_fd+0x94>
  {
    if (!alt_fd_list[i].dev)
   2c97c:	00c000f4 	movhi	r3,3
   2c980:	18cb2404 	addi	r3,r3,11408
   2c984:	e0bffd17 	ldw	r2,-12(fp)
   2c988:	10800324 	muli	r2,r2,12
   2c98c:	1885883a 	add	r2,r3,r2
   2c990:	10800017 	ldw	r2,0(r2)
   2c994:	1000131e 	bne	r2,zero,2c9e4 <alt_get_fd+0x88>
    {
      alt_fd_list[i].dev = dev;
   2c998:	00c000f4 	movhi	r3,3
   2c99c:	18cb2404 	addi	r3,r3,11408
   2c9a0:	e0bffd17 	ldw	r2,-12(fp)
   2c9a4:	10800324 	muli	r2,r2,12
   2c9a8:	1885883a 	add	r2,r3,r2
   2c9ac:	e0ffff17 	ldw	r3,-4(fp)
   2c9b0:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
   2c9b4:	008000f4 	movhi	r2,3
   2c9b8:	1090ff04 	addi	r2,r2,17404
   2c9bc:	10c00017 	ldw	r3,0(r2)
   2c9c0:	e0bffd17 	ldw	r2,-12(fp)
   2c9c4:	1880040e 	bge	r3,r2,2c9d8 <alt_get_fd+0x7c>
      {
        alt_max_fd = i;
   2c9c8:	008000f4 	movhi	r2,3
   2c9cc:	1090ff04 	addi	r2,r2,17404
   2c9d0:	e0fffd17 	ldw	r3,-12(fp)
   2c9d4:	10c00015 	stw	r3,0(r2)
      }
      rc = i;
   2c9d8:	e0bffd17 	ldw	r2,-12(fp)
   2c9dc:	e0bffe15 	stw	r2,-8(fp)
      goto alt_get_fd_exit;
   2c9e0:	00000606 	br	2c9fc <alt_get_fd+0xa0>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
   2c9e4:	e0bffd17 	ldw	r2,-12(fp)
   2c9e8:	10800044 	addi	r2,r2,1
   2c9ec:	e0bffd15 	stw	r2,-12(fp)
   2c9f0:	e0bffd17 	ldw	r2,-12(fp)
   2c9f4:	10800810 	cmplti	r2,r2,32
   2c9f8:	103fe01e 	bne	r2,zero,2c97c <alt_get_fd+0x20>
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
   2c9fc:	e0bffe17 	ldw	r2,-8(fp)
}
   2ca00:	e037883a 	mov	sp,fp
   2ca04:	df000017 	ldw	fp,0(sp)
   2ca08:	dec00104 	addi	sp,sp,4
   2ca0c:	f800283a 	ret

0002ca10 <alt_icache_flush>:
 * alt_icache_flush() is called to flush the instruction cache for a memory
 * region of length "len" bytes, starting at address "start".
 */

void alt_icache_flush (void* start, alt_u32 len)
{
   2ca10:	defffb04 	addi	sp,sp,-20
   2ca14:	df000415 	stw	fp,16(sp)
   2ca18:	df000404 	addi	fp,sp,16
   2ca1c:	e13ffe15 	stw	r4,-8(fp)
   2ca20:	e17fff15 	stw	r5,-4(fp)

  /*
   * This is the most we would ever need to flush.
   */
 
  if (len > NIOS2_ICACHE_SIZE)
   2ca24:	e0bfff17 	ldw	r2,-4(fp)
   2ca28:	10840070 	cmpltui	r2,r2,4097
   2ca2c:	1000021e 	bne	r2,zero,2ca38 <alt_icache_flush+0x28>
  {
    len = NIOS2_ICACHE_SIZE;
   2ca30:	00840004 	movi	r2,4096
   2ca34:	e0bfff15 	stw	r2,-4(fp)
  }

  end = ((char*) start) + len;
   2ca38:	e0fffe17 	ldw	r3,-8(fp)
   2ca3c:	e0bfff17 	ldw	r2,-4(fp)
   2ca40:	1885883a 	add	r2,r3,r2
   2ca44:	e0bffd15 	stw	r2,-12(fp)

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
   2ca48:	e0bffe17 	ldw	r2,-8(fp)
   2ca4c:	e0bffc15 	stw	r2,-16(fp)
   2ca50:	00000506 	br	2ca68 <alt_icache_flush+0x58>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
   2ca54:	e0bffc17 	ldw	r2,-16(fp)
   2ca58:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
   2ca5c:	e0bffc17 	ldw	r2,-16(fp)
   2ca60:	10800804 	addi	r2,r2,32
   2ca64:	e0bffc15 	stw	r2,-16(fp)
   2ca68:	e0fffc17 	ldw	r3,-16(fp)
   2ca6c:	e0bffd17 	ldw	r2,-12(fp)
   2ca70:	18bff836 	bltu	r3,r2,2ca54 <alt_icache_flush+0x44>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
   2ca74:	e0bffe17 	ldw	r2,-8(fp)
   2ca78:	108007cc 	andi	r2,r2,31
   2ca7c:	10000226 	beq	r2,zero,2ca88 <alt_icache_flush+0x78>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
   2ca80:	e0bffc17 	ldw	r2,-16(fp)
   2ca84:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
   2ca88:	0000203a 	flushp

#endif /* NIOS2_ICACHE_SIZE > 0 */
}
   2ca8c:	e037883a 	mov	sp,fp
   2ca90:	df000017 	ldw	fp,0(sp)
   2ca94:	dec00104 	addi	sp,sp,4
   2ca98:	f800283a 	ret

0002ca9c <atexit>:
   2ca9c:	200b883a 	mov	r5,r4
   2caa0:	000d883a 	mov	r6,zero
   2caa4:	0009883a 	mov	r4,zero
   2caa8:	000f883a 	mov	r7,zero
   2caac:	002cc201 	jmpi	2cc20 <__register_exitproc>

0002cab0 <exit>:
   2cab0:	defffe04 	addi	sp,sp,-8
   2cab4:	000b883a 	mov	r5,zero
   2cab8:	dc000015 	stw	r16,0(sp)
   2cabc:	dfc00115 	stw	ra,4(sp)
   2cac0:	2021883a 	mov	r16,r4
   2cac4:	002cd500 	call	2cd50 <__call_exitprocs>
   2cac8:	008000f4 	movhi	r2,3
   2cacc:	1090f604 	addi	r2,r2,17368
   2cad0:	11000017 	ldw	r4,0(r2)
   2cad4:	20800f17 	ldw	r2,60(r4)
   2cad8:	10000126 	beq	r2,zero,2cae0 <exit+0x30>
   2cadc:	103ee83a 	callr	r2
   2cae0:	8009883a 	mov	r4,r16
   2cae4:	002cef00 	call	2cef0 <_exit>

0002cae8 <malloc>:
   2cae8:	008000f4 	movhi	r2,3
   2caec:	1090f704 	addi	r2,r2,17372
   2caf0:	200b883a 	mov	r5,r4
   2caf4:	11000017 	ldw	r4,0(r2)
   2caf8:	001c03c1 	jmpi	1c03c <_malloc_r>

0002cafc <free>:
   2cafc:	008000f4 	movhi	r2,3
   2cb00:	1090f704 	addi	r2,r2,17372
   2cb04:	200b883a 	mov	r5,r4
   2cb08:	11000017 	ldw	r4,0(r2)
   2cb0c:	001b4a41 	jmpi	1b4a4 <_free_r>

0002cb10 <memcmp>:
   2cb10:	01c000c4 	movi	r7,3
   2cb14:	3980192e 	bgeu	r7,r6,2cb7c <memcmp+0x6c>
   2cb18:	2904b03a 	or	r2,r5,r4
   2cb1c:	11c4703a 	and	r2,r2,r7
   2cb20:	10000f26 	beq	r2,zero,2cb60 <memcmp+0x50>
   2cb24:	20c00003 	ldbu	r3,0(r4)
   2cb28:	28800003 	ldbu	r2,0(r5)
   2cb2c:	1880151e 	bne	r3,r2,2cb84 <memcmp+0x74>
   2cb30:	31bfff84 	addi	r6,r6,-2
   2cb34:	01ffffc4 	movi	r7,-1
   2cb38:	00000406 	br	2cb4c <memcmp+0x3c>
   2cb3c:	20c00003 	ldbu	r3,0(r4)
   2cb40:	28800003 	ldbu	r2,0(r5)
   2cb44:	31bfffc4 	addi	r6,r6,-1
   2cb48:	18800e1e 	bne	r3,r2,2cb84 <memcmp+0x74>
   2cb4c:	21000044 	addi	r4,r4,1
   2cb50:	29400044 	addi	r5,r5,1
   2cb54:	31fff91e 	bne	r6,r7,2cb3c <memcmp+0x2c>
   2cb58:	0005883a 	mov	r2,zero
   2cb5c:	f800283a 	ret
   2cb60:	20c00017 	ldw	r3,0(r4)
   2cb64:	28800017 	ldw	r2,0(r5)
   2cb68:	1880041e 	bne	r3,r2,2cb7c <memcmp+0x6c>
   2cb6c:	31bfff04 	addi	r6,r6,-4
   2cb70:	21000104 	addi	r4,r4,4
   2cb74:	29400104 	addi	r5,r5,4
   2cb78:	39bff936 	bltu	r7,r6,2cb60 <memcmp+0x50>
   2cb7c:	303fe91e 	bne	r6,zero,2cb24 <memcmp+0x14>
   2cb80:	003ff506 	br	2cb58 <memcmp+0x48>
   2cb84:	1885c83a 	sub	r2,r3,r2
   2cb88:	f800283a 	ret

0002cb8c <strcpy>:
   2cb8c:	2906b03a 	or	r3,r5,r4
   2cb90:	18c000cc 	andi	r3,r3,3
   2cb94:	2005883a 	mov	r2,r4
   2cb98:	18001a1e 	bne	r3,zero,2cc04 <strcpy+0x78>
   2cb9c:	29800017 	ldw	r6,0(r5)
   2cba0:	02bfbff4 	movhi	r10,65279
   2cba4:	52bfbfc4 	addi	r10,r10,-257
   2cba8:	02602074 	movhi	r9,32897
   2cbac:	4a602004 	addi	r9,r9,-32640
   2cbb0:	0188303a 	nor	r4,zero,r6
   2cbb4:	3287883a 	add	r3,r6,r10
   2cbb8:	20c6703a 	and	r3,r4,r3
   2cbbc:	1a46703a 	and	r3,r3,r9
   2cbc0:	1800101e 	bne	r3,zero,2cc04 <strcpy+0x78>
   2cbc4:	1007883a 	mov	r3,r2
   2cbc8:	19800015 	stw	r6,0(r3)
   2cbcc:	29400104 	addi	r5,r5,4
   2cbd0:	29800017 	ldw	r6,0(r5)
   2cbd4:	18c00104 	addi	r3,r3,4
   2cbd8:	0190303a 	nor	r8,zero,r6
   2cbdc:	328f883a 	add	r7,r6,r10
   2cbe0:	41ce703a 	and	r7,r8,r7
   2cbe4:	3a4e703a 	and	r7,r7,r9
   2cbe8:	383ff726 	beq	r7,zero,2cbc8 <strcpy+0x3c>
   2cbec:	29800007 	ldb	r6,0(r5)
   2cbf0:	18c00044 	addi	r3,r3,1
   2cbf4:	29400044 	addi	r5,r5,1
   2cbf8:	19bfffc5 	stb	r6,-1(r3)
   2cbfc:	3000021e 	bne	r6,zero,2cc08 <strcpy+0x7c>
   2cc00:	f800283a 	ret
   2cc04:	1007883a 	mov	r3,r2
   2cc08:	29800007 	ldb	r6,0(r5)
   2cc0c:	18c00044 	addi	r3,r3,1
   2cc10:	29400044 	addi	r5,r5,1
   2cc14:	19bfffc5 	stb	r6,-1(r3)
   2cc18:	303ffb1e 	bne	r6,zero,2cc08 <strcpy+0x7c>
   2cc1c:	f800283a 	ret

0002cc20 <__register_exitproc>:
   2cc20:	defffa04 	addi	sp,sp,-24
   2cc24:	008000f4 	movhi	r2,3
   2cc28:	1090f604 	addi	r2,r2,17368
   2cc2c:	dc000315 	stw	r16,12(sp)
   2cc30:	14000017 	ldw	r16,0(r2)
   2cc34:	dc400415 	stw	r17,16(sp)
   2cc38:	dfc00515 	stw	ra,20(sp)
   2cc3c:	80805217 	ldw	r2,328(r16)
   2cc40:	2023883a 	mov	r17,r4
   2cc44:	10003e26 	beq	r2,zero,2cd40 <__register_exitproc+0x120>
   2cc48:	10c00117 	ldw	r3,4(r2)
   2cc4c:	020007c4 	movi	r8,31
   2cc50:	40c0180e 	bge	r8,r3,2ccb4 <__register_exitproc+0x94>
   2cc54:	008000f4 	movhi	r2,3
   2cc58:	10b2ba04 	addi	r2,r2,-13592
   2cc5c:	1000061e 	bne	r2,zero,2cc78 <__register_exitproc+0x58>
   2cc60:	00bfffc4 	movi	r2,-1
   2cc64:	dfc00517 	ldw	ra,20(sp)
   2cc68:	dc400417 	ldw	r17,16(sp)
   2cc6c:	dc000317 	ldw	r16,12(sp)
   2cc70:	dec00604 	addi	sp,sp,24
   2cc74:	f800283a 	ret
   2cc78:	01006404 	movi	r4,400
   2cc7c:	d9400015 	stw	r5,0(sp)
   2cc80:	d9800115 	stw	r6,4(sp)
   2cc84:	d9c00215 	stw	r7,8(sp)
   2cc88:	002cae80 	call	2cae8 <malloc>
   2cc8c:	d9400017 	ldw	r5,0(sp)
   2cc90:	d9800117 	ldw	r6,4(sp)
   2cc94:	d9c00217 	ldw	r7,8(sp)
   2cc98:	103ff126 	beq	r2,zero,2cc60 <__register_exitproc+0x40>
   2cc9c:	80c05217 	ldw	r3,328(r16)
   2cca0:	10000115 	stw	zero,4(r2)
   2cca4:	10c00015 	stw	r3,0(r2)
   2cca8:	80805215 	stw	r2,328(r16)
   2ccac:	10006215 	stw	zero,392(r2)
   2ccb0:	10006315 	stw	zero,396(r2)
   2ccb4:	10c00117 	ldw	r3,4(r2)
   2ccb8:	88000d1e 	bne	r17,zero,2ccf0 <__register_exitproc+0xd0>
   2ccbc:	19000084 	addi	r4,r3,2
   2ccc0:	2109883a 	add	r4,r4,r4
   2ccc4:	18c00044 	addi	r3,r3,1
   2ccc8:	2109883a 	add	r4,r4,r4
   2cccc:	1109883a 	add	r4,r2,r4
   2ccd0:	10c00115 	stw	r3,4(r2)
   2ccd4:	0005883a 	mov	r2,zero
   2ccd8:	21400015 	stw	r5,0(r4)
   2ccdc:	dfc00517 	ldw	ra,20(sp)
   2cce0:	dc400417 	ldw	r17,16(sp)
   2cce4:	dc000317 	ldw	r16,12(sp)
   2cce8:	dec00604 	addi	sp,sp,24
   2ccec:	f800283a 	ret
   2ccf0:	02400044 	movi	r9,1
   2ccf4:	12806217 	ldw	r10,392(r2)
   2ccf8:	48d2983a 	sll	r9,r9,r3
   2ccfc:	19000804 	addi	r4,r3,32
   2cd00:	18d1883a 	add	r8,r3,r3
   2cd04:	2109883a 	add	r4,r4,r4
   2cd08:	4211883a 	add	r8,r8,r8
   2cd0c:	2109883a 	add	r4,r4,r4
   2cd10:	1109883a 	add	r4,r2,r4
   2cd14:	1211883a 	add	r8,r2,r8
   2cd18:	5254b03a 	or	r10,r10,r9
   2cd1c:	21c02215 	stw	r7,136(r4)
   2cd20:	41802215 	stw	r6,136(r8)
   2cd24:	12806215 	stw	r10,392(r2)
   2cd28:	01000084 	movi	r4,2
   2cd2c:	893fe31e 	bne	r17,r4,2ccbc <__register_exitproc+0x9c>
   2cd30:	11006317 	ldw	r4,396(r2)
   2cd34:	2252b03a 	or	r9,r4,r9
   2cd38:	12406315 	stw	r9,396(r2)
   2cd3c:	003fdf06 	br	2ccbc <__register_exitproc+0x9c>
   2cd40:	00800134 	movhi	r2,4
   2cd44:	1091c404 	addi	r2,r2,18192
   2cd48:	80805215 	stw	r2,328(r16)
   2cd4c:	003fbe06 	br	2cc48 <__register_exitproc+0x28>

0002cd50 <__call_exitprocs>:
   2cd50:	008000f4 	movhi	r2,3
   2cd54:	1090f604 	addi	r2,r2,17368
   2cd58:	10800017 	ldw	r2,0(r2)
   2cd5c:	defff304 	addi	sp,sp,-52
   2cd60:	df000b15 	stw	fp,44(sp)
   2cd64:	d8800015 	stw	r2,0(sp)
   2cd68:	10805204 	addi	r2,r2,328
   2cd6c:	dd400815 	stw	r21,32(sp)
   2cd70:	dfc00c15 	stw	ra,48(sp)
   2cd74:	ddc00a15 	stw	r23,40(sp)
   2cd78:	dd800915 	stw	r22,36(sp)
   2cd7c:	dd000715 	stw	r20,28(sp)
   2cd80:	dcc00615 	stw	r19,24(sp)
   2cd84:	dc800515 	stw	r18,20(sp)
   2cd88:	dc400415 	stw	r17,16(sp)
   2cd8c:	dc000315 	stw	r16,12(sp)
   2cd90:	d9000115 	stw	r4,4(sp)
   2cd94:	2839883a 	mov	fp,r5
   2cd98:	d8800215 	stw	r2,8(sp)
   2cd9c:	057fffc4 	movi	r21,-1
   2cda0:	d8800017 	ldw	r2,0(sp)
   2cda4:	ddc00217 	ldw	r23,8(sp)
   2cda8:	14805217 	ldw	r18,328(r2)
   2cdac:	90001726 	beq	r18,zero,2ce0c <__call_exitprocs+0xbc>
   2cdb0:	94400117 	ldw	r17,4(r18)
   2cdb4:	8c3fffc4 	addi	r16,r17,-1
   2cdb8:	80001116 	blt	r16,zero,2ce00 <__call_exitprocs+0xb0>
   2cdbc:	8c400044 	addi	r17,r17,1
   2cdc0:	8427883a 	add	r19,r16,r16
   2cdc4:	8c63883a 	add	r17,r17,r17
   2cdc8:	95802204 	addi	r22,r18,136
   2cdcc:	9ce7883a 	add	r19,r19,r19
   2cdd0:	8c63883a 	add	r17,r17,r17
   2cdd4:	b4e7883a 	add	r19,r22,r19
   2cdd8:	9463883a 	add	r17,r18,r17
   2cddc:	e0001726 	beq	fp,zero,2ce3c <__call_exitprocs+0xec>
   2cde0:	8c87c83a 	sub	r3,r17,r18
   2cde4:	b0c7883a 	add	r3,r22,r3
   2cde8:	18c01e17 	ldw	r3,120(r3)
   2cdec:	1f001326 	beq	r3,fp,2ce3c <__call_exitprocs+0xec>
   2cdf0:	843fffc4 	addi	r16,r16,-1
   2cdf4:	9cffff04 	addi	r19,r19,-4
   2cdf8:	8c7fff04 	addi	r17,r17,-4
   2cdfc:	857ff71e 	bne	r16,r21,2cddc <__call_exitprocs+0x8c>
   2ce00:	008000f4 	movhi	r2,3
   2ce04:	10b2bf04 	addi	r2,r2,-13572
   2ce08:	10002a1e 	bne	r2,zero,2ceb4 <__call_exitprocs+0x164>
   2ce0c:	dfc00c17 	ldw	ra,48(sp)
   2ce10:	df000b17 	ldw	fp,44(sp)
   2ce14:	ddc00a17 	ldw	r23,40(sp)
   2ce18:	dd800917 	ldw	r22,36(sp)
   2ce1c:	dd400817 	ldw	r21,32(sp)
   2ce20:	dd000717 	ldw	r20,28(sp)
   2ce24:	dcc00617 	ldw	r19,24(sp)
   2ce28:	dc800517 	ldw	r18,20(sp)
   2ce2c:	dc400417 	ldw	r17,16(sp)
   2ce30:	dc000317 	ldw	r16,12(sp)
   2ce34:	dec00d04 	addi	sp,sp,52
   2ce38:	f800283a 	ret
   2ce3c:	91000117 	ldw	r4,4(r18)
   2ce40:	88c00017 	ldw	r3,0(r17)
   2ce44:	213fffc4 	addi	r4,r4,-1
   2ce48:	24001526 	beq	r4,r16,2cea0 <__call_exitprocs+0x150>
   2ce4c:	88000015 	stw	zero,0(r17)
   2ce50:	183fe726 	beq	r3,zero,2cdf0 <__call_exitprocs+0xa0>
   2ce54:	00800044 	movi	r2,1
   2ce58:	1408983a 	sll	r4,r2,r16
   2ce5c:	91406217 	ldw	r5,392(r18)
   2ce60:	95000117 	ldw	r20,4(r18)
   2ce64:	214a703a 	and	r5,r4,r5
   2ce68:	28000b26 	beq	r5,zero,2ce98 <__call_exitprocs+0x148>
   2ce6c:	91406317 	ldw	r5,396(r18)
   2ce70:	2148703a 	and	r4,r4,r5
   2ce74:	20000c1e 	bne	r4,zero,2cea8 <__call_exitprocs+0x158>
   2ce78:	99400017 	ldw	r5,0(r19)
   2ce7c:	d9000117 	ldw	r4,4(sp)
   2ce80:	183ee83a 	callr	r3
   2ce84:	90c00117 	ldw	r3,4(r18)
   2ce88:	1d3fc51e 	bne	r3,r20,2cda0 <__call_exitprocs+0x50>
   2ce8c:	b8c00017 	ldw	r3,0(r23)
   2ce90:	1cbfd726 	beq	r3,r18,2cdf0 <__call_exitprocs+0xa0>
   2ce94:	003fc206 	br	2cda0 <__call_exitprocs+0x50>
   2ce98:	183ee83a 	callr	r3
   2ce9c:	003ff906 	br	2ce84 <__call_exitprocs+0x134>
   2cea0:	94000115 	stw	r16,4(r18)
   2cea4:	003fea06 	br	2ce50 <__call_exitprocs+0x100>
   2cea8:	99000017 	ldw	r4,0(r19)
   2ceac:	183ee83a 	callr	r3
   2ceb0:	003ff406 	br	2ce84 <__call_exitprocs+0x134>
   2ceb4:	90c00117 	ldw	r3,4(r18)
   2ceb8:	1800071e 	bne	r3,zero,2ced8 <__call_exitprocs+0x188>
   2cebc:	90c00017 	ldw	r3,0(r18)
   2cec0:	18000926 	beq	r3,zero,2cee8 <__call_exitprocs+0x198>
   2cec4:	9009883a 	mov	r4,r18
   2cec8:	b8c00015 	stw	r3,0(r23)
   2cecc:	002cafc0 	call	2cafc <free>
   2ced0:	bc800017 	ldw	r18,0(r23)
   2ced4:	003fb506 	br	2cdac <__call_exitprocs+0x5c>
   2ced8:	90c00017 	ldw	r3,0(r18)
   2cedc:	902f883a 	mov	r23,r18
   2cee0:	1825883a 	mov	r18,r3
   2cee4:	003fb106 	br	2cdac <__call_exitprocs+0x5c>
   2cee8:	0007883a 	mov	r3,zero
   2ceec:	003ffb06 	br	2cedc <__call_exitprocs+0x18c>

0002cef0 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
   2cef0:	defffc04 	addi	sp,sp,-16
   2cef4:	df000315 	stw	fp,12(sp)
   2cef8:	df000304 	addi	fp,sp,12
   2cefc:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
   2cf00:	0001883a 	nop
   2cf04:	e0bfff17 	ldw	r2,-4(fp)
   2cf08:	e0bffd15 	stw	r2,-12(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  int r2 = exit_code;
   2cf0c:	e0bffd17 	ldw	r2,-12(fp)
   2cf10:	e0bffe15 	stw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "D02"(r2), "D03"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
   2cf14:	e0bffe17 	ldw	r2,-8(fp)
   2cf18:	10000226 	beq	r2,zero,2cf24 <_exit+0x34>
    ALT_SIM_FAIL();
   2cf1c:	002af070 	cmpltui	zero,zero,43969
   2cf20:	00000106 	br	2cf28 <_exit+0x38>
  } else {
    ALT_SIM_PASS();
   2cf24:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
   2cf28:	003fff06 	br	2cf28 <_exit+0x38>
